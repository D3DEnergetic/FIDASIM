#!/bin/sh
"exec" "$FIDASIM_DIR/deps/python" "$0" "$@"

import argparse
import h5py
import fidasim as fs
import numpy as np

is_sorted = lambda a: np.all(a[:-1] <= a[1:])

def read_nbi(g, beam_index, time_index):
    path = 'unit/{}/'.format(beam_index)

    ab = g[path+'species/a'][:]
    Zb = g[path+'species/z_n'][:]
    einj = g[path+'energy/data'][time_index]*1e-3 #keV
    pinj = g[path+'power_launched/data'][time_index]*1e-6 #MW
    cfracs = g[path+'beam_current_fraction/data'][:,time_index]

    shape = g[path+'source/geometry_type'][:]
    if shape == 3:
        shape = 1
    elif shape == 2:
        shape == 2
    else
        shape = 1

    src_r = g[path+'source/centre/r'][:]
    src_z = g[path+'source/centre/z'][:]
    src_phi = g[path+'source/centre/phi'][:]

    src_u = src_r*np.cos(src_phi)
    src_v = src_r*np.sin(src_phi)
    uvw_src = np.array([src_u,src_v,src_z])
    uvw_axis = np.array([g[path+'source/x3_unit_vector/{}'.format(i)][:] for i in ['x','y','z'])

    # FIDASIM doesn't support beamlets yet so just average
    nbeamlets = len(g[path+'beamlets_group'].keys())
    widz = np.mean([g[path+'beamlets_group/{}/width_vertical'.format(i)][:] for i in range(nbeamlets)])
    widy = np.mean([g[path+'beamlets_group/{}/width_horizontal'.format(i)][:] for i in range(nbeamlets)])

    focz = np.mean([g[path+'beamlets_group/{}/focus/focal_length_vertical'.format(i)][:] for i in range(nbeamlets)])
    focy = np.mean([g[path+'beamlets_group/{}/focus/focal_length_horizontal'.format(i)][:] for i in range(nbeamlets)])

    divy = np.array([np.mean([g[path+'beamlets_group/{}/divergence_component/{}/horizontal'.format(i,j)][:] for i in range(nbeamlets)]) for j in range(3)])
    divz = np.array([np.mean([g[path+'beamlets_group/{}/divergence_component/{}/vertical'.format(i,j)][:] for i in range(nbeamlets)]) for j in range(3)])


    naper = len(g[path+'aperture'].keys())
    aper_shape = [g[path+'aperture/{}/geometry_type'.format(i)][:] for i in range(naper)]
    ashape = np.array([1 if a == 3 else 2 for a in aper_shape]) # ignores outline shape

    aper_rs = [g[path+'aperture/{}/centre/r'.format(i)][:] for i in range(naper)]
    aper_zs = [g[path+'aperture/{}/centre/z'.format(i)][:] for i in range(naper)]
    aper_phis = [g[path+'aperture/{}/centre/phi'.format(i)][:] for i in range(naper)]

    aper_xs = [r*np.cos(p) for (r,p) in zip(aper_rs,aper_phis)]
    aper_ys = [r*np.sin(p) for (r,p) in zip(aper_rs,aper_phis)]

    sx = src_u
    sy = src_v
    sz = src_z
    adist = np.array([np.sqrt((ax - sx)**2 + (ay - sy)**2 + (az - sz)**2) for (ax,ay,az) in zip(aper_xs,aper_ys,aper_zs)])

    #assume zero offset
    aoffz = np.zeros(naper)
    aoffy = np.zeros(naper)

    awidy = np.array([g[path+'aperture/{}/x1_width'.format(i)][:] for i in range(naper)]
    awidz = np.array([g[path+'aperture/{}/x2_width'.format(i)][:] for i in range(naper)]

    nbi = {"name":"beam: {}".format(beam_index),"shape":shape,"data_source":"imas file",
           "src":uvw_src, "axis":uvw_axis, "widy":widy, "widz":widz,
           "divy":divy, "divz":divz, "focy":focy, "focz":focz,
           "naperture":naper, "ashape":ashape, "adist":adist,
           "awidy":awidy, "awidz":awidz, "aoffy":aoffy, "aoffz":aoffz}

    return nbi, {"ab":ab,"Zb":Zb,"einj":einj,"pinj":pinj,"current_fractions":cfracs}

def read_equilbrium_plasma(g, time_index):

    path = "core_profiles/profiles_1d/{}/".format(time_index)

    psi = g[path+"grid/psi"][:]
    te = g[path+"electrons/temperature"][:]/1000 #keV
    dene = g[path+"electrons/density"][:]*1e-6 # cm-3

    #TODO: specify specific neutral/ion
    denn = g[path+"neutral/0/density"][:]*1e-6 # cm-3
    ti = g[path+"ion/0/temperature"][:]/1000 #keV
    zeff = g[path+"zeff"][:]
    vtor = g[path+"ion/0/velocity/toroidal"][:]*100 #cm/s

    path = "equilibrium/time_slice/{}/profiles_2d/0/".format(time_index)

    r = g[path+"grid/dim1"][:]*100
    z = g[path+"grid/dim2"][:]*100
    r2d = g[path+"r"][:,:]
    z2d = g[path+"z"][:,:]
    br = g[path+"b_field_r"][:,:]
    bz = g[path+"b_field_z"][:,:]
    bt = g[path+"b_field_tor"][:,:]
    psi_rz = g[path+"psi"][:,:]

    if !is_sorted(psi):
        psi = psi[::-1]
        te = te[::-1]
        dene = dene[::-1]
        denn = denn[::-1]
        ti = ti[::-1]
        zeff = zeff[::-1]
        vtor = vtor[::-1]




def main():
    parser = argparse.ArgumentParser(description="Creates FIDASIM input files from IMAS data structure")

    parser.add_argument('file',
                        help='IMAS HDF5 file')
    parser.add_argument('-t','--time_unit',
                        default = 0,
                        help='time unit. defaults to first timeslice')
    parser.add_argument('-b','--beam_unit',
                        default = 0,
                        help='beam unit. defaults to first unit')
    parser.add_argument('-o','--output',
                        default = '.',
                        help = 'Default output directory')
    parser.add_argument('-v','--verbose',
                        action = 'store_true',
                        help = 'Verbose')
    parser.add_argument('-db','--debug',
                        action = 'store_true',
                        help = 'Debug mode')

    args = parser.parse_args()


    f = h5py.File(args.file,'r')

if __name__=='__main__':
    main()
