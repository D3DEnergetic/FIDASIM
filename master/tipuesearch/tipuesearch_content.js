var tipuesearch = {"pages":[{"text":"FIDASIM Note This is the documentation for the release version of FIDASIM.\nClick here for the current development documentation. FIDASIM is a fast Fortran 90 code that simulates neutral beam deposition and various fast-ion diagnostics in axisyimmetric fusion devices. For more information, check out the user guide . Citing FIDASIM Source Code Along with the FIDASIM paper, please cite the source code. @misc{FIDASIMcode, author       = {Stagner, L. and Geiger, B. and Heidbrink, W.W.}, title        = {{ FIDASIM : A Neutral Beam and Fast-ion Diagnostic Modeling Suite }} , doi          = {10.5281/zenodo.1341369}, url          = {https://doi.org/10.5281/zenodo.1341369} } Developer Info Luke Stagner ORISE Postdoctoral Fellow","tags":"home","loc":"index.html","title":" FIDASIM "},{"text":"Files dependent on this one sourcefile~~mpi_utils.f90~~AfferentGraph sourcefile~mpi_utils.f90 mpi_utils.f90 sourcefile~utilities.f90 utilities.f90 sourcefile~utilities.f90->sourcefile~mpi_utils.f90 sourcefile~fidasim.f90 fidasim.f90 sourcefile~fidasim.f90->sourcefile~mpi_utils.f90 sourcefile~fidasim.f90->sourcefile~utilities.f90 sourcefile~atomic_tables.f90 atomic_tables.f90 sourcefile~atomic_tables.f90->sourcefile~mpi_utils.f90 sourcefile~atomic_tables.f90->sourcefile~utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mpi_utils Source Code mpi_utils.f90 Source Code module mpi_utils integer , parameter , private :: Float64 = 8 real , parameter , private :: max_bytes = 2 * 1e9 !!GigaBytes integer , private :: numranks , myrank interface parallel_sum module procedure parallel_sum_d0 , parallel_sum_d1 , parallel_sum_d2 , & parallel_sum_d3 , parallel_sum_d4 , parallel_sum_d5 ,& parallel_sum_i0 , parallel_sum_i1 , parallel_sum_i2 end interface contains subroutine init_mpi () use mpi implicit none integer :: provided , ierr #ifdef _OMP call MPI_INIT_THREAD ( MPI_THREAD_FUNNELED , provided , ierr ) #else call MPI_INIT ( ierr ) #endif numranks = 1 myrank = 0 if ( ierr /= 0 ) then write ( * , * ) \"MPI initialization failed, assuming single MPI process\" else call MPI_COMM_SIZE ( MPI_COMM_WORLD , numranks , ierr ) if ( numranks > 1 ) then call MPI_COMM_RANK ( MPI_COMM_WORLD , myrank , ierr ) endif endif end subroutine subroutine cleanup_mpi () use mpi implicit none integer :: ierr call MPI_BARRIER ( MPI_COMM_WORLD , ierr ) call MPI_FINALIZE ( ierr ) end subroutine recursive function my_rank () result ( n ) n = myrank end function recursive function num_ranks () result ( n ) n = numranks end function recursive subroutine parallel_sum_d0 ( A ) use mpi implicit none real ( Float64 ), intent ( inout ) :: A integer :: sizeA , ierr sizeA = 1 if ( numranks > 1 ) then call MPI_Allreduce ( MPI_IN_PLACE , A , sizeA , MPI_DOUBLE , MPI_Sum , MPI_COMM_WORLD , ierr ) endif ! else nothing to do end subroutine recursive subroutine parallel_sum_d1 ( A ) use mpi use iso_c_binding implicit none real ( Float64 ), dimension (:), intent ( inout ) :: A integer :: sizeA , h , ierr integer ( C_SIZE_T ) :: nbytes sizeA = size ( A , 1 ) if ( numranks > 1 ) then nbytes = Float64 * sizeA if ( nbytes . gt . max_bytes ) then h = int ( sizeA / 2 ) call parallel_sum_d1 ( A ( 1 : h )) call parallel_sum_d1 ( A (( h + 1 ): sizeA )) else call MPI_Allreduce ( MPI_IN_PLACE , A , sizeA , MPI_DOUBLE , MPI_Sum , MPI_COMM_WORLD , ierr ) endif endif ! else nothing to do end subroutine recursive subroutine parallel_sum_d2 ( A ) use mpi use iso_c_binding implicit none real ( Float64 ), dimension (:,:), target , intent ( inout ) :: A integer :: sizeA , h , ierr integer ( C_SIZE_T ) :: nbytes real ( Float64 ), pointer :: A_ptr (:) sizeA = size ( A , 1 ) * size ( A , 2 ) if ( numranks > 1 ) then nbytes = Float64 * sizeA if ( nbytes . gt . max_bytes ) then h = int ( sizeA / 2 ) call c_f_pointer ( c_loc ( A ), A_ptr , [ sizeA ]) call parallel_sum_d1 ( A_ptr ( 1 : h )) call parallel_sum_d1 ( A_ptr (( h + 1 ): sizeA )) else call MPI_Allreduce ( MPI_IN_PLACE , A , sizeA , MPI_DOUBLE , MPI_Sum , MPI_COMM_WORLD , ierr ) endif endif ! else nothing to do end subroutine recursive subroutine parallel_sum_d3 ( A ) use mpi use iso_c_binding implicit none real ( Float64 ), dimension (:,:,:), target , intent ( inout ) :: A integer :: sizeA , h , ierr integer ( C_SIZE_T ) :: nbytes real ( Float64 ), pointer :: A_ptr (:) sizeA = size ( A , 1 ) * size ( A , 2 ) * size ( A , 3 ) if ( numranks > 1 ) then nbytes = Float64 * sizeA if ( nbytes . gt . max_bytes ) then h = int ( sizeA / 2 ) call c_f_pointer ( c_loc ( A ), A_ptr , [ sizeA ]) call parallel_sum_d1 ( A_ptr ( 1 : h )) call parallel_sum_d1 ( A_ptr (( h + 1 ): sizeA )) else call MPI_Allreduce ( MPI_IN_PLACE , A , sizeA , MPI_DOUBLE , MPI_Sum , MPI_COMM_WORLD , ierr ) endif endif ! else nothing to do end subroutine recursive subroutine parallel_sum_d4 ( A ) use mpi use iso_c_binding implicit none real ( Float64 ), dimension (:,:,:,:), target , intent ( inout ) :: A integer :: sizeA , h , ierr integer ( C_SIZE_T ) :: nbytes real ( Float64 ), pointer :: A_ptr (:) sizeA = size ( A , 1 ) * size ( A , 2 ) * size ( A , 3 ) * size ( A , 4 ) if ( numranks > 1 ) then nbytes = Float64 * sizeA if ( nbytes . gt . max_bytes ) then h = int ( sizeA / 2 ) call c_f_pointer ( c_loc ( A ), A_ptr , [ sizeA ]) call parallel_sum_d1 ( A_ptr ( 1 : h )) call parallel_sum_d1 ( A_ptr (( h + 1 ): sizeA )) else call MPI_Allreduce ( MPI_IN_PLACE , A , sizeA , MPI_DOUBLE , MPI_Sum , MPI_COMM_WORLD , ierr ) endif endif ! else nothing to do end subroutine recursive subroutine parallel_sum_d5 ( A ) use mpi use iso_c_binding implicit none real ( Float64 ), dimension (:,:,:,:,:), target , intent ( inout ) :: A integer :: sizeA , h , ierr integer ( C_SIZE_T ) :: nbytes real ( Float64 ), pointer :: A_ptr (:) sizeA = size ( A , 1 ) * size ( A , 2 ) * size ( A , 3 ) * size ( A , 4 ) * size ( A , 5 ) if ( numranks > 1 ) then nbytes = Float64 * sizeA if ( nbytes . gt . max_bytes ) then h = int ( sizeA / 2 ) call c_f_pointer ( c_loc ( A ), A_ptr , [ sizeA ]) call parallel_sum_d1 ( A_ptr ( 1 : h )) call parallel_sum_d1 ( A_ptr (( h + 1 ): sizeA )) else call MPI_Allreduce ( MPI_IN_PLACE , A , sizeA , MPI_DOUBLE , MPI_Sum , MPI_COMM_WORLD , ierr ) endif endif ! else nothing to do end subroutine recursive subroutine parallel_sum_i0 ( A ) use mpi implicit none integer , intent ( inout ) :: A integer :: sizeA , ierr sizeA = 1 if ( numranks > 1 ) then call MPI_Allreduce ( MPI_IN_PLACE , A , sizeA , MPI_INTEGER , MPI_Sum , MPI_COMM_WORLD , ierr ) endif ! else nothing to do end subroutine recursive subroutine parallel_sum_i1 ( A ) use mpi use iso_c_binding implicit none integer , dimension (:), intent ( inout ) :: A integer :: sizeA , h , ierr integer ( C_SIZE_T ) :: nbytes sizeA = size ( A , 1 ) if ( numranks > 1 ) then nbytes = kind ( 1 ) * sizeA if ( nbytes . gt . max_bytes ) then h = int ( sizeA / 2 ) call parallel_sum_i1 ( A ( 1 : h )) call parallel_sum_i1 ( A (( h + 1 ): sizeA )) else call MPI_Allreduce ( MPI_IN_PLACE , A , sizeA , MPI_INTEGER , MPI_Sum , MPI_COMM_WORLD , ierr ) endif endif ! else nothing to do end subroutine recursive subroutine parallel_sum_i2 ( A ) use mpi use iso_c_binding implicit none integer , dimension (:,:), target , intent ( inout ) :: A integer :: sizeA , h , ierr integer ( C_SIZE_T ) :: nbytes integer , pointer :: A_ptr (:) sizeA = size ( A , 1 ) * size ( A , 2 ) if ( numranks > 1 ) then nbytes = kind ( 1 ) * sizeA if ( nbytes . gt . max_bytes ) then h = int ( sizeA / 2 ) call c_f_pointer ( c_loc ( A ), A_ptr , [ sizeA ]) call parallel_sum_i1 ( A_ptr ( 1 : h )) call parallel_sum_i1 ( A_ptr (( h + 1 ): sizeA )) else call MPI_Allreduce ( MPI_IN_PLACE , A , sizeA , MPI_INTEGER , MPI_Sum , MPI_COMM_WORLD , ierr ) endif endif ! else nothing to do end subroutine end module","tags":"","loc":"sourcefile/mpi_utils.f90.html","title":"mpi_utils.f90 – FIDASIM"},{"text":"This file contains the main routines for FIDASIM 2.0.0-dev This file depends on sourcefile~~fidasim.f90~~EfferentGraph sourcefile~fidasim.f90 fidasim.f90 sourcefile~utilities.f90 utilities.f90 sourcefile~fidasim.f90->sourcefile~utilities.f90 sourcefile~eigensystem.f90 eigensystem.f90 sourcefile~fidasim.f90->sourcefile~eigensystem.f90 sourcefile~hdf5_utils.f90 hdf5_utils.f90 sourcefile~fidasim.f90->sourcefile~hdf5_utils.f90 sourcefile~mpi_utils.f90 mpi_utils.f90 sourcefile~fidasim.f90->sourcefile~mpi_utils.f90 sourcefile~utilities.f90->sourcefile~mpi_utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs fidasim Modules libfida Source Code fidasim.f90 Source Code !+ This file contains the main routines for FIDASIM {!../VERSION!} module libfida !+ Main FIDASIM library USE H5LT !! High level HDF5 Interface USE HDF5 !! Base HDF5 USE hdf5_utils !! Additional HDF5 routines USE eigensystem , ONLY : eigen , linsolve USE utilities USE ISO_C_BINDING #ifdef _MPI USE mpi_utils #endif implicit none character ( 30 ) :: version = '' !+ FIDASIM version number integer , dimension ( 8 ) :: time_start !+ Start time integer , parameter , private :: Int32 = 4 !+ Defines a 32 bit integer integer , parameter , private :: Int64 = 8 !+ Defines a 64 bit integer integer , parameter , private :: Float32 = 4 !+ Defines a 32 bit floating point real integer , parameter , private :: Float64 = 8 !+ Defines a 64 bit floating point real integer , parameter :: charlim = 150 !+ Defines character limit for files and directories character ( charlim ) :: namelist_file !+ Input namelist file integer , parameter :: nbif_type = 1 !+ Identifier for full energy NBI neutral interaction integer , parameter :: nbih_type = 2 !+ Identifier for half energy NBI neutral interaction integer , parameter :: nbit_type = 3 !+ Identifier for third energy NBI neutral interaction integer , parameter :: dcx_type = 4 !+ Identifier for dcx neutral interaction integer , parameter :: halo_type = 5 !+ Identifier for halo neutral interaction integer , parameter :: fida_type = 6 !+ Identifier for fida neutral interaction integer , parameter :: brems_type = 7 !+ Identifier for bremsstrahlung interaction. Acts as dummy type integer , parameter :: ntypes = 7 !+ Number of different types of neutrals integer , parameter :: beam_ion = 1 !+ Identifier for a beam ion integer , parameter :: thermal_ion = 2 !+ Identifier for a thermal ion !! Physical units real ( Float64 ), parameter :: e_amu = 5.48579909070d-4 !+ Atomic mass of an electron [amu] real ( Float64 ), parameter :: H1_amu = 1.007276466879d0 !+ Atomic mass of Hydrogen-1 (protium) [amu] real ( Float64 ), parameter :: H2_amu = 2.013553212745d0 !+ Atomic mass of Hydrogen-2 (deuterium) [amu] real ( Float64 ), parameter :: H3_amu = 3.01550071632d0 !+ Atomic mass of Hydrogen-3 (tritium) [amu] real ( Float64 ), parameter :: He3_amu = 3.01602931914d0 !+ Atomic mass of Helium-3 [amu] real ( Float64 ), parameter :: B5_amu = 1 0.81d0 !+ Atomic mass of Boron [amu] real ( Float64 ), parameter :: C6_amu = 1 2.011d0 !+ Atomic mass of Carbon [amu] real ( Float64 ), parameter :: mass_u = 1.660539040d-27 !+ Atomic mass unit [kg] real ( Float64 ), parameter :: e0 = 1.60217733d-19 !+ Electron charge [C] real ( Float64 ), parameter :: pi = 3.14159265358979323846264d0 !+ Pi real ( Float64 ), parameter :: c0 = 2.99792458d+08 !+ Speed of light [m/s] real ( Float64 ), parameter :: h_planck = 4.135667516d-15 !+ Planck's constant [eV*s] real ( Float64 ), parameter :: lambda0 = 65 6.1d0 !+ D-alpha emission line [nm] real ( Float64 ), parameter :: v2_to_E_per_amu = mass_u / ( 2. * e0 * 1.d3 ) * 1.d-4 !+ cm&#94;2/s&#94;2 to keV conversion factor real ( Float64 ), parameter :: log_10 = log ( 1 0.d0 ) !+ Natural log of 10.0 integer , parameter :: n_stark = 15 !+ Number of Stark lines real ( Float64 ), parameter , dimension ( n_stark ) :: stark_wavel = & [ - 2.20200d-07 , - 1.65200d-07 , - 1.37700d-07 , - 1.10200d-07 , & - 8.26400d-08 , - 5.51000d-08 , - 2.75600d-08 , 0.00000d0 , & 2.75700d-08 , 5.51500d-08 , 8.27400d-08 , 1.10300d-07 , & 1.38000d-07 , 1.65600d-07 , 2.20900d-07 ] !+ Stark wavelengths [nm*m/V] real ( Float64 ), parameter , dimension ( n_stark ) :: stark_intens = & [ 1.000d0 , 1 8.00d0 , 1 6.00d0 , 168 1.d0 , 230 4.d0 , & 72 9.0d0 , 193 6.d0 , 549 0.d0 , 193 6.d0 , 72 9.0d0 , & 230 4.d0 , 168 1.d0 , 1 6.00d0 , 1 8.00d0 , 1.000d0 ] !+ Stark Intensities integer , parameter , dimension ( n_stark ) :: stark_pi = & [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 ] !+ Pi line indicators integer , parameter , dimension ( n_stark ) :: stark_sigma = 1 - stark_pi !+ Sigma line indicators !!Numerical Settings integer , parameter :: nlevs = 6 !+ Number of atomic energy levels real ( Float64 ), dimension ( ntypes ) :: halo_iter_dens = 0.d0 !+ Keeps track of how of each generations halo density integer :: nbi_outside = 0 !+ Keeps track of how many beam neutrals do not hit the [[libfida:beam_grid]] !!Loop Parallization Settings integer :: istart = 1 !+ Starting loop counter (1 if OpenMP, processor number if MPI) integer :: istep = 1 !+ Loop step size (1 if OpenMP, number of processes if MPI) type InterpolCoeffs1D !+ Linear Interpolation Coefficients and indices integer :: i = 0 !+ Index of position right before `xout` real ( Float64 ) :: b1 = 0.d0 !+ Coefficient for y(i) term real ( Float64 ) :: b2 = 0.d0 !+ Coefficient for y(i+1) term end type InterpolCoeffs1D type InterpolCoeffs2D !+ 2D Linear Interpolation Coefficients and indices integer :: i = 0 !+ Index of abscissa before `xout` integer :: j = 0 !+ Index of ordinate before `yout` real ( Float64 ) :: b11 = 0.d0 !+ Coefficient for z(i,j) term real ( Float64 ) :: b12 = 0.d0 !+ Coefficient for z(i,j+1) term real ( Float64 ) :: b21 = 0.d0 !+ Coefficient for z(i+1,j) term real ( Float64 ) :: b22 = 0.d0 !+ Coefficient for z(i+1,j+1) term end type InterpolCoeffs2D type InterpolCoeffs3D !+ 3D Cylindrical Interpolation Coefficients and indices integer :: i = 0 !+ Index of R before `rout` integer :: j = 0 !+ Index of Z before `zout` integer :: k = 0 !+ Index of Phi before `phiout` real ( Float64 ) :: b111 = 0.d0 !+ Coefficient for z(i,j,k) term real ( Float64 ) :: b121 = 0.d0 !+ Coefficient for z(i,j+1,k) term real ( Float64 ) :: b112 = 0.d0 !+ Coefficient for z(i,j,k+1) term real ( Float64 ) :: b122 = 0.d0 !+ Coefficient for z(i,j+1,k+1) term real ( Float64 ) :: b211 = 0.d0 !+ Coefficient for z(i+1,j,k) term real ( Float64 ) :: b212 = 0.d0 !+ Coefficient for z(i+1,j,k+1) term real ( Float64 ) :: b221 = 0.d0 !+ Coefficient for z(i+1,j+1,k) term real ( Float64 ) :: b222 = 0.d0 !+ Coefficient for z(i+1,j+1,k+1) term end type InterpolCoeffs3D type BeamGrid !+ Defines a 3D grid for neutral beam calculations integer ( Int32 ) :: nx !+ Number of cells in the x direction integer ( Int32 ) :: ny !+ Number of cells in the y direction integer ( Int32 ) :: nz !+ Number of cells in the z direction real ( Float64 ) :: xmin !+ Minimum x value real ( Float64 ) :: xmax !+ Maximum x value real ( Float64 ) :: ymin !+ Minimum y value real ( Float64 ) :: ymax !+ Maximum y value real ( Float64 ) :: zmin !+ Minimum z value real ( Float64 ) :: zmax !+ Maximum z value real ( Float64 ) :: alpha !+ Tait-Bryan angle for a rotation about z [radians] real ( Float64 ) :: beta !+ Tait-Bryan angle for a rotation about y' [radians] real ( Float64 ) :: gamma !+ Tait-Bryan angle for a rotation about x\" [radians] real ( Float64 ) :: drmin !+ Minimum cell spacing: `min(dx,dy,dz)` real ( Float64 ) :: dv !+ Cell volume [cm&#94;3] real ( Float64 ) :: volume !+ Grid volume [cm&#94;3] integer ( Int32 ) :: ntrack !+ Maximum number of cell for particle tracking integer ( Int32 ) :: ngrid !+ Number of cells integer ( Int32 ), dimension ( 3 ) :: dims !+ Dimensions of beam grid real ( Float64 ), dimension ( 3 ) :: origin !+ Origin of beam grid in machine coordinates real ( Float64 ), dimension ( 3 ) :: center !+ Center of beam grid in beam coordinates real ( Float64 ), dimension ( 3 ) :: dr !+ Cell spacings [dx, dy, dz] real ( Float64 ), dimension ( 3 ) :: lwh !+ Grid [length(x), width(y), height(z)] real ( Float64 ), dimension ( 3 , 3 ) :: basis !+Beam grid basis for converting from beam coordinates(xyz) !+to machine coordinates(uvw): (\\uvw = B*xyz + origin real ( Float64 ), dimension ( 3 , 3 ) :: inv_basis !+Inverse basis for reverse transformation: (\\xyz = B&#94;{-1}*(uvw - origin) real ( Float64 ), dimension (:), allocatable :: xc !+ x positions of cell centers real ( Float64 ), dimension (:), allocatable :: yc !+ y positions of cell centers real ( Float64 ), dimension (:), allocatable :: zc !+ z positions of cell centers end type BeamGrid type InterpolationGrid !+ Defines a 3D R-Z-phi grid for interpolating plasma parameters and fields integer ( Int32 ) :: nr !+ Number of Radii integer ( Int32 ) :: nz !+ Number of Z values integer ( Int32 ) :: nphi !+ Number of phi values real ( Float64 ) :: dr !+ Radial spacing [cm] real ( Float64 ) :: dz !+ Vertical spacing [cm] real ( Float64 ) :: dphi !+ Angular spacing [rad] real ( Float64 ) :: da !+ Grid element area [cm&#94;2] real ( Float64 ) :: dv !+ dr*dz*dphi [rad*cm&#94;2] integer ( Int32 ) :: dims ( 3 ) !+ Dimension of the interpolation grid real ( Float64 ), dimension (:), allocatable :: r !+ Radii values [cm] real ( Float64 ), dimension (:), allocatable :: z !+ Z values [cm] real ( Float64 ), dimension (:), allocatable :: phi !+ Angular values [rad] integer ( Int32 ) :: ntrack !+ Maximum number of cells for particle tracking integer ( Int32 ) :: ngrid !+ Number of cells end type InterpolationGrid type Profiles !+ Torodial symmetric plasma parameters at a given R-Z real ( Float64 ) :: dene = 0.d0 !+ Electron density [cm&#94;{-3}] real ( Float64 ) :: denp = 0.d0 !+ Ion density [cm&#94;{-3}] real ( Float64 ) :: denimp = 0.d0 !+ Impurity density [cm&#94;{-3}] real ( Float64 ) :: denf = 0.d0 !+ Fast-ion density [cm&#94;{-3}] real ( Float64 ) :: te = 0.d0 !+ Electron temperature [kev] real ( Float64 ) :: ti = 0.d0 !+ Ion temperature [kev] real ( Float64 ) :: zeff = 0.d0 !+ Effective Nuclear Charge real ( Float64 ) :: vr = 0.d0 !+ Plasma rotation in radial direction real ( Float64 ) :: vt = 0.d0 !+ Plasma rotation in torodial/phi direction real ( Float64 ) :: vz = 0.d0 !+ Plasma rotation in z direction real ( Float64 ) :: denn ( nlevs ) = 0.d0 !+ Cold neutral density [cm&#94;{-3}] end type Profiles type , extends ( Profiles ) :: LocalProfiles !+ Plasma parameters at given position logical :: in_plasma = . False . !+ Indicates whether plasma parameters are valid/known integer :: coords = 0 !+ Indicates coordinate system of vectors. Beam grid (0), machine (1) and cylindrical (2) real ( Float64 ), dimension ( 3 ) :: pos = 0.d0 !+ Position in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: uvw = 0.d0 !+ Position in machine coordinates real ( Float64 ), dimension ( 3 ) :: vrot = 0.d0 !+ Plasma rotation in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: vrot_uvw = 0.d0 !+ Plasma rotation in machine coordinates type ( InterpolCoeffs3D ) :: b !+ Cylindrical Interpolation Coefficients and indicies for interpolation at `pos` end type LocalProfiles type EMFields !+ Torodial symmetric electro-magnetic fields at given R-Z real ( Float64 ) :: br = 0.d0 !+ Radial magnetic field [T] real ( Float64 ) :: bt = 0.d0 !+ Torodial magnetic field [T] real ( Float64 ) :: bz = 0.d0 !+ Vertical magnetic field [T] real ( Float64 ) :: er = 0.d0 !+ Radial electric field [V/m] real ( Float64 ) :: et = 0.d0 !+ Torodial electric field [V/m] real ( Float64 ) :: ez = 0.d0 !+ Vertical electric field [V/m] real ( Float64 ) :: dbr_dr = 0.d0 !+ Radial derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbr_dphi = 0.d0 !+ Angular derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbr_dz = 0.d0 !+ Vertical derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbt_dr = 0.d0 !+ Radial derivative of the torodial magnetic field [T/m] real ( Float64 ) :: dbt_dphi = 0.d0 !+ Angular derivative of the torodial magnetic field [T/m] real ( Float64 ) :: dbt_dz = 0.d0 !+ Vertical derivative of the torodial magnetic field [T/m] real ( Float64 ) :: dbz_dr = 0.d0 !+ Radial derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbz_dphi = 0.d0 !+ Angular derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbz_dz = 0.d0 !+ Vertical derivative of the vertical magnetic field [T/m] end type EMFields type , extends ( EMFields ) :: LocalEMFields !+ Electro-magnetic fields at given position logical :: in_plasma = . False . !+ Indicates whether fields are valid/known integer :: coords = 0 !+ Indicates coordinate system of vectors. Beam grid (0), machine (1) and cylindrical (2) real ( Float64 ) :: b_abs = 0.d0 !+ Magnitude of magnetic field real ( Float64 ) :: e_abs = 0.d0 !+ Magnitude of electrin field real ( Float64 ), dimension ( 3 ) :: pos = 0.d0 !+ Position in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: uvw = 0.d0 !+ Position in machine coordinates real ( Float64 ), dimension ( 3 ) :: b_norm = 0.d0 !+ Direction of magnetic field in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: a_norm = 0.d0 !+ Vector perpendicular to `b_norm` and `c_norm` real ( Float64 ), dimension ( 3 ) :: c_norm = 0.d0 !+ Vector perpendicular to `b_norm` and `a_norm` real ( Float64 ), dimension ( 3 ) :: e_norm = 0.d0 !+ Direction of electric field in beam grid coordinates type ( InterpolCoeffs3D ) :: b !+ Cylindrical Interpolation Coefficients and indicies for interpolation at `pos` end type LocalEMFields type Equilibrium !+MHD Equilbrium type ( EMFields ), dimension (:,:,:), allocatable :: fields !+ Electro-magnetic fields at points defined in [[libfida:inter_grid]] type ( Profiles ), dimension (:,:,:), allocatable :: plasma !+ Plasma parameters at points defined in [[libfida:inter_grid]] real ( Float64 ), dimension (:,:,:), allocatable :: mask !+ Indicates whether fields and plasma are well-defined at points defined in [[libfida:inter_grid]] end type Equilibrium type FastIonDistribution !+ Defines a Guiding Center Fast-ion Distribution Function: F(E,p,R,Z,Phi) integer ( Int32 ) :: nenergy !+ Number of energies integer ( Int32 ) :: npitch !+ Number of pitches integer ( Int32 ) :: nr !+ Number of radii integer ( Int32 ) :: nz !+ Number of z values integer ( Int32 ) :: nphi !+ Number of phi values real ( Float64 ) :: dE !+ Energy spacing [keV] real ( Float64 ) :: dp !+ Pitch spacing real ( Float64 ) :: dr !+ Radial spacing [cm] real ( Float64 ) :: dz !+ Z spacing [cm] real ( Float64 ) :: dphi !+ Angular spacing [rad] real ( Float64 ) :: emin !+ Minimum energy [keV] real ( Float64 ) :: emax !+ Maximum energy [keV] real ( Float64 ) :: e_range !+ Energy interval length [keV] real ( Float64 ) :: pmin !+ Minimum pitch real ( Float64 ) :: pmax !+ Maximum pitch real ( Float64 ) :: p_range !+ Pitch interval length real ( Float64 ) :: rmin !+ Minimum radius [cm] real ( Float64 ) :: rmax !+ Maximum radius [cm] real ( Float64 ) :: r_range !+ Radius interval length [cm] real ( Float64 ) :: zmin !+ Minimum Z [cm] real ( Float64 ) :: zmax !+ Maximum Z [cm] real ( Float64 ) :: z_range !+ Z interval length [cm] real ( Float64 ) :: phimin !+ Minimum Phi [rad] real ( Float64 ) :: phimax !+ Maximum Phi [rad] real ( Float64 ) :: phi_range !+ Phi interval length [rad] real ( Float64 ) :: n_tot = 0.d0 !+ Total Number of fast-ions real ( Float64 ), dimension (:), allocatable :: energy !+ Energy values [keV] real ( Float64 ), dimension (:), allocatable :: pitch !+ Pitch w.r.t. the magnetic field real ( Float64 ), dimension (:), allocatable :: r !+ Radius [cm] real ( Float64 ), dimension (:), allocatable :: z !+ Z [cm] real ( Float64 ), dimension (:), allocatable :: phi !+ Angles [rad] real ( Float64 ), dimension (:,:,:), allocatable :: denf !+ Fast-ion density defined on the [[libfida:inter_grid]]: denf(R,Z,Phi) real ( Float64 ), dimension (:,:,:,:,:), allocatable :: f !+ Fast-ion distribution function defined on the [[libfida:inter_grid]]: F(E,p,R,Z,Phi) end type FastIonDistribution type FastIon !+ Defines a fast-ion logical :: beam_grid_cross_grid = . False . !+ Indicates whether the fast-ion crosses the [[libfida:beam_grid]] real ( Float64 ) :: r = 0.d0 !+ Radial position of fast-ion [cm] real ( Float64 ) :: phi = 0.d0 !+ Angular position of fast-ion [rad] real ( Float64 ) :: z = 0.d0 !+ Vertical position of fast-ion [cm] real ( Float64 ) :: beam_grid_phi_enter = 0.d0 !+ Torodial/phi position where fast-ion enters the [[libfida:beam_grid]] [radians] real ( Float64 ) :: delta_phi = 2 * pi !+ Angle subtended by the [[libfida:beam_grid]] at (r,z) real ( Float64 ) :: energy = 0.d0 !+ Energy [keV] real ( Float64 ) :: pitch = 0.d0 !+ Pitch w.r.t. the magnetic field real ( Float64 ) :: vabs = 0.d0 !+ Speed [cm/s] real ( Float64 ) :: vr = 0.d0 !+ Radial velocity [cm/s] real ( Float64 ) :: vt = 0.d0 !+ Torodial velocity [cm/s] real ( Float64 ) :: vz = 0.d0 !+ Z velocity [cm/s] real ( Float64 ) :: weight = 0.d0 !+ Particle weight: How many fast-ions does particle represent. integer ( Int32 ) :: class = 0 !+ Orbit class id end type FastIon type FastIonParticles !+ Collection of fast-ion particles integer ( Int32 ) :: nparticle = 0 !+ Number of particles integer ( Int32 ) :: nclass = 1 !+ Number of orbit classes logical :: axisym = . True . !+ Indicates whether distribution function is axisymmetric type ( FastIon ), dimension (:), allocatable :: fast_ion !+ Fast-ion particles end type FastIonParticles type NeutralBeam !+ Defines a neutral beam with +x defined to be into the plasma character ( 25 ) :: name = '' !+ Beam name integer :: shape !+ Beam source shape 1=\"rectangular\", 2=\"circular\" real ( Float64 ) :: widy !+ Half width of source in y direction real ( Float64 ) :: widz !+ Half height of source in z direction real ( Float64 ) :: focy !+ Focal length in y direction real ( Float64 ) :: focz !+ Focal length in z direction real ( Float64 ) :: einj !+ NBI voltage  [kV] real ( Float64 ) :: pinj !+ NBI power    [MW] real ( Float64 ) :: vinj !+ NBI velocity [cm/s] real ( Float64 ) :: alpha !+ Z rotation not same as [[libfida:beam_grid]] alpha real ( Float64 ) :: beta !+ Tilt rotation not same as [[libfida:beam_grid]] beta real ( Float64 ), dimension ( 3 ) :: divy !+ Energy dependent divergence in y direction real ( Float64 ), dimension ( 3 ) :: divz !+ Energy dependent divergence in z direction real ( Float64 ), dimension ( 3 ) :: current_fractions !+ Fractions of full, half, and third energy neutrals real ( Float64 ), dimension ( 3 ) :: src !+ Position of source in beam grid coordinates [cm] real ( Float64 ), dimension ( 3 ) :: axis !+ Beam centerline integer :: naperture !+ Number of beam apertures integer , dimension (:), allocatable :: ashape !+ Aperture shape 1=\"rectangular\", 2=\"circular\" real ( Float64 ), dimension (:), allocatable :: awidy !+ Half width of the aperture(s) in y direction real ( Float64 ), dimension (:), allocatable :: awidz !+ Half height of the aperture(s) in z direction real ( Float64 ), dimension (:), allocatable :: aoffy !+ Horizontal (y) offset of the aperture(s) relative to the beam centerline [cm] real ( Float64 ), dimension (:), allocatable :: aoffz !+ Vertical (z) offset of the aperture(s) relative to the beam centerline [cm] real ( Float64 ), dimension (:), allocatable :: adist !+ Distance from the center of the beam source grid to the aperture(s) plane [cm] real ( Float64 ), dimension ( 3 , 3 ) :: basis !+ Beam basis for converting from centerline coordinates to beam grid coordinates real ( Float64 ), dimension ( 3 , 3 ) :: inv_basis !+ Inverse basis for reverse transfomation end type NeutralBeam type AtomicCrossSection !+ Defines a n/m-resolved atomic cross section table integer :: nenergy = 1 !+ Number of beam energies real ( Float64 ) :: logemin = 0.d0 !+ Log-10 minimum energy real ( Float64 ) :: logemax = 0.d0 !+ Log-10 maximum energy integer :: n_max = nlevs !+ Number of initial atomic energy levels integer :: m_max = nlevs !+ Number of final atomic energy levels real ( Float64 ) :: dlogE = 0.d0 !+ Log-10 energy spacing real ( Float64 ) :: minlog_cross !+ Log-10 minimum cross section real ( Float64 ), dimension (:,:,:), allocatable :: log_cross !+ Log-10 cross sections end type AtomicCrossSection type AtomicRates !+ Defines a n/m-resolved atomic cross section table integer :: nenergy = 1 !+ Number of beam energies real ( Float64 ) :: logemin = 0.d0 !+ Log-10 minimum energy real ( Float64 ) :: logemax = 0.d0 !+ Log-10 maximum energy integer :: ntemp = 1 !+ Number of target temperatures real ( Float64 ) :: logtmin = 0.d0 !+ Log-10 minimum temperature real ( Float64 ) :: logtmax = 0.d0 !+ Log-10 maximum temperature integer :: n_max = nlevs !+ Number of initial atomic energy levels integer :: m_max = nlevs !+ Number of final atomic energy levels real ( Float64 ) :: dlogE = 0.d0 !+ Log-10 energy spacing real ( Float64 ) :: dlogT = 0.d0 !+ Log-10 temperature spacing real ( Float64 ) :: minlog_rate = 0.d0 !+ Log-10 minimum reaction rate real ( Float64 ), dimension ( 2 ) :: ab = 0.d0 !+ Atomic mass of beam and thermal ions respectively [amu] real ( Float64 ), dimension (:,:,:,:,:), allocatable :: log_rate !+ Log-10 beam-target rates end type AtomicRates type AtomicTransitions !+ Defines an atomic table for populating and de-populating reaction rates integer :: nenergy = 1 !+ Number of beam energies real ( Float64 ) :: logemin = 0.d0 !+ Log-10 minimum energy real ( Float64 ) :: logemax = 0.d0 !+ Log-10 maximum energy integer :: ntemp = 1 !+ Number of target temperatures real ( Float64 ) :: logtmin = 0.d0 !+ Log-10 minimum temperature real ( Float64 ) :: logtmax = 0.d0 !+ Log-10 maximum temperature integer :: n_max = nlevs !+ Number of initial atomic energy levels integer :: m_max = nlevs !+ Number of final atomic energy levels real ( Float64 ) :: dlogE = 0.d0 !+ Log-10 energy spacing real ( Float64 ) :: dlogT = 0.d0 !+ Log-10 temperature spacing real ( Float64 ) :: minlog_pop = 0.d0 !+ Log-10 minimum reaction rates for populating transistions real ( Float64 ) :: minlog_depop = 0.d0 !+ Log-10 minimum reaction rates for de-populating transistions real ( Float64 ), dimension ( 2 ) :: ab = 0.d0 !+ Atomic mass of beam and thermal ions respectively [amu] real ( Float64 ), dimension (:,:,:,:,:), allocatable :: log_pop !+ Log-10 reaction rates for populating transistions real ( Float64 ), dimension (:,:,:,:), allocatable :: log_depop !+ Log-10 reaction rates for de-populating transistions end type AtomicTransitions type NuclearRates !+ Nuclear reaction rates integer :: nbranch = 1 !+ Number of reaction branches integer :: nenergy = 1 !+ Number of beam energies real ( Float64 ) :: logemin = 0.d0 !+ Log-10 minimum energy real ( Float64 ) :: logemax = 0.d0 !+ Log-10 maximum energy integer :: ntemp = 1 !+ Number of target temperatures real ( Float64 ) :: logtmin = 0.d0 !+ Log-10 minimum temperature real ( Float64 ) :: logtmax = 0.d0 !+ Log-10 maximum temperature real ( Float64 ) :: dlogE = 0.d0 !+ Log-10 energy spacing real ( Float64 ) :: dlogT = 0.d0 !+ Log-10 temperature spacing real ( Float64 ) :: minlog_rate = 0.d0 !+ Log-10 minimum reaction rate real ( Float64 ), dimension ( 2 ) :: bt_amu = 0.d0 !+ Isotope mass of beam and thermal ions respectively [amu] real ( Float64 ), dimension (:,:,:), allocatable :: log_rate !+ Log-10 reaction rates: log_rate(energy, temperature, branch) end type NuclearRates type AtomicTables !+ Atomic tables for various types of interactions type ( AtomicCrossSection ) :: H_H_cx_cross !+ Hydrogen-Hydrogen charge exchange n/m-resolved cross sections type ( AtomicRates ) :: H_H_cx_rate !+ Hydrogen-Hydrogen charge exchange n/m-resolved beam-target rates type ( AtomicTransitions ) :: H_H !+ Hydrogen-Hydrogen atomic transitions type ( AtomicTransitions ) :: H_e !+ Hydrogen-Electron atomic transitions type ( AtomicTransitions ) :: H_Aq !+ Hydrogen-Impurity atomic transitions real ( Float64 ), dimension ( nlevs , nlevs ) :: einstein !+ Einstein coefficients for spontaneous emission type ( NuclearRates ) :: D_D !+ Deuterium-Deuterium reaction rates end type AtomicTables type LineOfSight !+ Defines a line of sight real ( Float64 ) :: sigma_pi = 1.d0 !+ Ratio of sigma to pi line intensity real ( Float64 ) :: spot_size = 0.d0 !+ Radius of spot size [cm] real ( Float64 ), dimension ( 3 ) :: lens = 0.d0 !+ Lens location in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: axis = 0.d0 !+ Optical axis in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: lens_uvw = 0.d0 !+ Lens location in machine coordinates real ( Float64 ), dimension ( 3 ) :: axis_uvw = 0.d0 !+ Optical axis in machine coordinates end type LineOfSight type LOSElement !+ Defines a element of a line of sight and cell intersection integer :: id !+ Line of sight index real ( Float64 ) :: length !+ Length of crossing end type LOSElement type LOSInters !+ Defines the channels that intersect a cell integer :: nchan = 0 !+ Number of channels that intersect type ( LOSElement ), dimension (:), allocatable :: los_elem !+ Array of crossing end type LOSInters type SpectralChords !+ Defines an spectral diagnostic system integer :: nchan = 0 !+ Number of channels integer :: ncell = 0 !+ Number of beam_grid cells with intersections integer :: cyl_ncell = 0 !+ Number of pass_grid cells with intersections type ( LineOfSight ), dimension (:), allocatable :: los !+ Line of sight array real ( Float64 ), dimension (:), allocatable :: radius !+ Radius of each line of sight type ( LOSInters ), dimension (:,:,:), allocatable :: inter !+ Array of LOS intersections with [[libfida:beam_grid]] type ( LOSInters ), dimension (:,:,:), allocatable :: cyl_inter !+ Array of LOS intersections with [[libfida:pass_grid]] integer , dimension (:), allocatable :: cell !+ Linear indices of beam_grid that have intersections integer , dimension (:), allocatable :: cyl_cell !+ Linear indices of pass_grid that have intersections end type SpectralChords type BoundedPlane !+ Defines a plane with a circular or rectangular boundary integer :: shape = 0 !+ Boundary shape 1=\"Rectangular\", 2=\"circular\" real ( Float64 ) :: hh = 0.d0 !+ Half height of boundary [cm] real ( Float64 ) :: hw = 0.d0 !+ Half width of boundary [cm] real ( Float64 ), dimension ( 3 ) :: origin = 0.d0 !+ Origin of plane in machine coordinates real ( Float64 ), dimension ( 3 , 3 ) :: basis = 0.d0 !+ Basis vectors basis(:,1) = u_1 is plane normal real ( Float64 ), dimension ( 3 , 3 ) :: inv_basis = 0.d0 !+ Inverse basis end type BoundedPlane type NPADetector !+ Defines a NPA detector type ( BoundedPlane ) :: detector !+ Detecting plane of NPA detector type ( BoundedPlane ) :: aperture !+ Aperture plane of NPA detector end type NPADetector type NPAProbability !+ Type to contain the probability of hitting a NPA detector real ( Float64 ) :: p = 0.d0 !+ Hit probability real ( Float64 ) :: pitch = - 2.d0 !+ Pitch real ( Float64 ), dimension ( 3 ) :: eff_rd = 0.d0 !+ Effective position of detector real ( Float64 ), dimension ( 3 ) :: dir = 0.d0 !+ Trajectory direction end type NPAProbability type NPAChords !+ Defines a NPA system integer :: nchan = 0 !+ Number of channels type ( NPADetector ), dimension (:), allocatable :: det !+ NPA detector array real ( Float64 ), dimension (:), allocatable :: radius !+ Radius [cm] logical , dimension (:,:,:), allocatable :: hit !+ Indicates whether a particle can hit any NPA detector from a grid cell: hit(x,y,z) type ( NPAProbability ), dimension (:,:,:,:), allocatable :: phit !+ Probability of hitting a detector from a grid cell: phit(x,y,z,chan) end type NPAChords type NPAParticle !+ Defines a NPA particle integer :: detector = 0 !+ Detector NPA particle hit integer ( Int32 ) :: class = 0 !+ Orbit class id real ( Float64 ) :: xi = 0.d0 !+ Initial x position real ( Float64 ) :: yi = 0.d0 !+ Initial y position real ( Float64 ) :: zi = 0.d0 !+ Initial z position real ( Float64 ) :: xf = 0.d0 !+ Final x position real ( Float64 ) :: yf = 0.d0 !+ Final y position real ( Float64 ) :: zf = 0.d0 !+ Final z position real ( Float64 ) :: weight = 0.d0 !+ NPA particle weight real ( Float64 ) :: energy = 0.d0 !+ Birth Energy [keV] real ( Float64 ) :: pitch = 0.d0 !+ Birth Pitch end type NPAParticle type NPAResults !+ MC NPA result structure integer ( Int32 ) :: nchan = 0 !+ Number of NPA channels integer ( Int32 ) :: npart = 0 !+ Number of particles that hit a detector integer ( Int32 ) :: nmax = 1000000 !+ Maximum allowed number of particles grows if necessary integer ( Int32 ) :: nenergy = 122 !+ Number of energy values type ( NPAParticle ), dimension (:), allocatable :: part !+ Array of NPA particles real ( Float64 ), dimension (:), allocatable :: energy !+ Energy array [keV] real ( Float64 ), dimension (:,:,:), allocatable :: flux !+ Neutral particle flux: flux(energy,chan, orbit_type) [neutrals/(s*dE)] end type NPAResults type BirthParticle !+ Defines a Birth particle integer :: neut_type = 0 !+ Birth type (1=Full, 2=Half, 3=Third) integer ( Int32 ), dimension ( 3 ) :: ind = 0 !+ Initial [[libfida:beam_grid]] indices real ( Float64 ), dimension ( 3 ) :: ri = 0.d0 !+ Initial position in beam grid coordinates [cm] real ( Float64 ), dimension ( 3 ) :: vi = 0.d0 !+ Initial velocity in beam grid coordinates [cm/s] real ( Float64 ), dimension ( 3 ) :: ri_gc = 0.d0 !+ Initial guiding-center position in beam grid coordinates [cm] real ( Float64 ) :: weight = 0.d0 !+ NPA particle weight [fast-ions/s] real ( Float64 ) :: energy = 0.d0 !+ Birth Energy [keV] real ( Float64 ) :: pitch = 0.d0 !+ Birth Pitch w.r.t. the magnetic field end type BirthParticle type BirthProfile !+ Birth profile structure integer :: cnt = 1 !+ Particle counter type ( BirthParticle ), dimension (:), allocatable :: part !+ Array of birth particles real ( Float64 ), dimension (:,:,:,:), allocatable :: dens !+ Birth density: dens(neutral_type,x,y,z) [fast-ions/(s*cm&#94;3)] end type BirthProfile type Spectra !+ Spectra storage structure real ( Float64 ), dimension (:,:), allocatable :: brems !+ Bremsstruhlung: brems(lambda,chan) real ( Float64 ), dimension (:,:), allocatable :: full !+ Full energy beam emission: full(lambda,chan) real ( Float64 ), dimension (:,:), allocatable :: half !+ Half energy beam emission: half(lambda,chan) real ( Float64 ), dimension (:,:), allocatable :: third !+ Third energy beam emission: third(lambda,chan) real ( Float64 ), dimension (:,:), allocatable :: dcx !+ Direct CX emission: dcx(lambda,chan) real ( Float64 ), dimension (:,:), allocatable :: halo !+ Thermal halo emission: halo(lambda,chan) real ( Float64 ), dimension (:,:), allocatable :: cold !+ Cold D-alpha emission: cold(lambda,chan) real ( Float64 ), dimension (:,:,:), allocatable :: fida !+ Active FIDA emission: fida(lambda,chan,orbit_type) real ( Float64 ), dimension (:,:,:), allocatable :: pfida !+ Passive FIDA emission: pfida(lambda,chan,orbit_type) end type Spectra type NeutronRate !+ Neutron storage structure real ( Float64 ), dimension (:), allocatable :: rate !+ Neutron rate: rate(orbit_type) [neutrons/sec] real ( Float64 ), dimension (:,:,:,:,:), allocatable :: weight !+ Neutron rate weight: weight(E,p,R,Z,Phi) real ( Float64 ), dimension (:,:,:), allocatable :: emis !+ Neutron emissivity: emis(R,Z,Phi) end type NeutronRate type NeutralDensity !+ Neutral density structure real ( Float64 ), dimension (:,:,:,:), allocatable :: full !+ Full energy neutral density: full(lev,x,y,z) real ( Float64 ), dimension (:,:,:,:), allocatable :: half !+ Half energy neutral density: half(lev,x,y,z) real ( Float64 ), dimension (:,:,:,:), allocatable :: third !+ Third energy neutral density: third(lev,x,y,z) real ( Float64 ), dimension (:,:,:,:), allocatable :: dcx !+ Direct CX neutral density: dcx(lev,x,y,z) real ( Float64 ), dimension (:,:,:,:), allocatable :: halo !+ Thermal halo neutral density: dens(lev,x,y,z) end type NeutralDensity type FIDAWeights !+ FIDA weights structure real ( Float64 ), dimension (:,:,:), allocatable :: mean_f !+ Estimate of mean fast-ion distribution function \"seen\" by LOS: mean_f(E,p,chan) real ( Float64 ), dimension (:,:,:,:), allocatable :: weight !+ FIDA weight function: weight(lambda,E,p,chan) end type FIDAWeights type NPAWeights !+ NPA weights structure real ( Float64 ), dimension (:,:,:,:,:), allocatable :: attenuation !+ Attenuation fraction: attenuation(E,x,y,z,chan) real ( Float64 ), dimension (:,:,:,:,:), allocatable :: cx !+ Charge Exchange reaction rates: cx(E,x,y,z,chan) real ( Float64 ), dimension (:,:,:,:), allocatable :: emissivity !+ Emissivity: emissivity(x,y,z,chan) [neutrals/(s*dV)] real ( Float64 ), dimension (:,:,:), allocatable :: weight !+ NPA weight function: weight(E,p,chan) [neutrals/(s*fast-ion*dE*dP)] real ( Float64 ), dimension (:,:), allocatable :: flux !+ Neutral particle flux: flux(E,chan) [neutrals/(s*dE)] end type NPAWeights type SimulationInputs !+ Simulation settings structure integer ( Int32 ) :: shot_number !+ Shot Number real ( Float64 ) :: time !+ Shot time [s] character ( charlim ) :: runid = '' !+ FIDASIM run ID character ( charlim ) :: result_dir = '' !+ Result directory character ( charlim ) :: tables_file = '' !+ Atomic tables file character ( charlim ) :: geometry_file = '' !+ FIDASIM input file containing geometric quantities character ( charlim ) :: equilibrium_file = '' !+ FIDASIM input file containing the plasma parameters and fields character ( charlim ) :: distribution_file = '' !+ FIDASIM input file containing the fast-ion distribution character ( charlim ) :: neutrals_file = '' !+ FIDASIM output/input file containing beam neutral density. !+ Used when [[SimulationInputs:load_neutrals]] is set. !! Random Number Generator Settings integer :: seed !+ Random number generator seed !! Monte Carlo settings integer ( Int64 ) :: n_fida !+ Number of Active FIDA mc markers integer ( Int64 ) :: n_pfida !+ Number of Passive FIDA mc markers integer ( Int64 ) :: n_npa !+ Number of Passiv NPA mc markers integer ( Int64 ) :: n_pnpa !+ Number of Passive NPA mc markers integer ( Int64 ) :: n_nbi !+ Number of neutral beam mc markers integer ( Int64 ) :: n_dcx !+ Number of direct charge exchange (DCX) mc markers integer ( Int64 ) :: n_halo !+ Number of halo mc markers integer ( Int64 ) :: n_birth !+ Number of birth particles per [[SimulationInputs:n_nbi]] !! Simulation switches integer ( Int32 ) :: calc_spec !+ Calculate spectra: 0 = off, 1=on integer ( Int32 ) :: calc_beam !+ Calculate beam densities: 0 = off, 1=on integer ( Int32 ) :: calc_nbi_dens !+ Calculate neutral beam density: 0 = off, 1=on integer ( Int32 ) :: calc_dcx_dens !+ Calculate Direct Charge Exchange (DCX) density: 0 = off, 1=on integer ( Int32 ) :: calc_halo_dens !+ Calculate Thermal Halo density: 0 = off, 1=on integer ( Int32 ) :: calc_brems !+ Calculate bremmstruhlung: 0 = off, 1=on integer ( Int32 ) :: calc_bes !+ Calculate NBI: 0 = off, 1=on integer ( Int32 ) :: calc_dcx !+ Calculate DCX: 0 = off, 1=on integer ( Int32 ) :: calc_halo !+ Calculate Halo: 0 = off, 1=on integer ( Int32 ) :: calc_cold !+ Calculate Cold D-alpha: 0 = off, 1=on integer ( Int32 ) :: calc_fida !+ Calculate Active FIDA: 0 = off, 1=on integer ( Int32 ) :: calc_pfida !+ Calculate Passive FIDA: 0 = off, 1=on integer ( Int32 ) :: tot_spectra !+ Total number of spectral switches on integer ( Int32 ) :: load_neutrals !+ Load neutrals from file: 0 = off, 1=on integer ( Int32 ) :: calc_npa !+ Calculate Active NPA: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: calc_pnpa !+ Calculate Passive NPA: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: calc_fida_wght !+ Calculate FIDA weight: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: calc_npa_wght !+ Calculate NPA weights: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: calc_birth !+ Calculate birth profile: 0 = off, 1=on integer ( Int32 ) :: calc_neutron !+ Calculate neutron flux: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: flr !+ FLR correction: 0=off, 1=1st order(vxb/omega), 2=2nd order correction integer ( Int32 ) :: split !+ Split signals by fast ion class: 0=off, 1=on integer ( Int32 ) :: verbose !+ Verbosity: <0 = off++, 0 = off, 1=on, 2=on++ !! Neutral Beam Settings real ( Float64 ) :: ab !+ Atomic mass of beam neutrals !! Plasma parameters integer ( Int32 ) :: impurity_charge !+ Impurity proton number real ( Float64 ) :: ai !+ Atomic mass of thermal ions !! Distribution settings integer ( Int32 ) :: dist_type !+ Type of fast-ion distribution !! Spectrum parameters integer ( Int32 ) :: nlambda !+ Number of wavelength to calculate real ( Float64 ) :: dlambda !+ Wavelength spacing [nm] real ( Float64 ) :: lambdamin !+ Minimum wavelength [nm] real ( Float64 ) :: lambdamax !+ Maximum wavelength [nm] !! Weight function settings integer ( Int32 ) :: ne_wght !+ Number of energies in weight functions integer ( Int32 ) :: np_wght !+ Number of pitches in weight functions integer ( Int32 ) :: nphi_wght !+ Number of gyro-angles to average over in weight functions integer ( Int32 ) :: nlambda_wght !+ Number of wavelength to calculate in weight functions real ( Float64 ) :: emax_wght !+ Maximum energy in weight functions [keV] real ( Float64 ) :: lambdamin_wght !+ Minimum wavelength in weight functions [nm] real ( Float64 ) :: lambdamax_wght !+ Maximum wavelength in weight functions [nm] end type SimulationInputs type ParticleTrack !+ Stores properties seen when traveling through a 3D grid real ( Float64 ) :: time = 0.d0 !+ Time/distance/... in cell real ( Float64 ) :: flux = 0.d0 !+ Flux/density/... in cell integer ( Int32 ), dimension ( 3 ) :: ind = 0 !+ Indices of cell real ( Float64 ), dimension ( 3 ) :: pos = 0.d0 !+ Midpoint of track in cell [cm] end type ParticleTrack type GyroSurface !+ Surface containing the fast-ion velocity vectors for all values of the !+ gyro-angle. It takes the form of a hyperboloid !+ (x(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(cos(\\gamma + \\pi/2) - \\omega_i t sin(\\gamma + \\pi/2))  !+ (y(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(sin(\\gamma + \\pi/2) + \\omega_i t cos(\\gamma + \\pi/2))  !+ (z(\\gamma,t) = \\alpha \\omega_i \\rm{pitch} t !+ where \\gamma is the gyro-angle, \\omega_i is the ion !+ gyro-frequency and \\alpha = V/\\omega_i  real ( Float64 ) :: v = 0.d0 !+ Particle speed real ( Float64 ) :: omega = 0.d0 !+ Ion gyro-frequency real ( Float64 ), dimension ( 3 ) :: axes = 0.d0 !+ Semi-axes of the hyperboloid, i.e. a, b, c coefficients real ( Float64 ), dimension ( 3 ) :: center = 0.d0 !+ Center of the gyrosurface real ( Float64 ), dimension ( 3 , 3 ) :: A = 0.d0 !+ Coefficients of quartic surface i.e. `basis*diagm(1/a&#94;2,1/b&#94;2,1/c&#94;2)*basis'` real ( Float64 ), dimension ( 3 , 3 ) :: basis = 0.d0 !+ Basis of coordinate system of gyrosurface end type GyroSurface interface assignment ( = ) !+ Allows for assigning [[Profiles]],[[LocalProfiles]], !+ [[EMFields]],[[LocalEMFields]],[[FastIon]], [[NPAParticle]], and [[BirthParticle]] module procedure pp_assign , lpp_assign , plp_assign , lplp_assign , & ff_assign , lff_assign , flf_assign , lflf_assign , & fast_ion_assign , npa_part_assign , birth_part_assign end interface interface operator ( + ) !+ Allows for adding [[Profiles]],[[LocalProfiles]], !+ [[EMFields]], and [[LocalEMFields]] module procedure pp_add , lplp_add , ff_add , lflf_add end interface interface operator ( - ) !+ Allows for subtracting [[Profiles]],[[LocalProfiles]], !+ [[EMFields]], and [[LocalEMFields]] module procedure pp_subtract , lplp_subtract , ff_subtract , lflf_subtract end interface interface operator ( * ) !+ Allows for multiplying [[Profiles]],[[LocalProfiles]], !+ [[EMFields]], and [[LocalEMFields]] by scalars module procedure sp_multiply , ps_multiply , lps_multiply , slp_multiply , & sf_multiply , fs_multiply , lfs_multiply , slf_multiply end interface interface operator ( / ) !+ Allows for dividing [[Profiles]],[[LocalProfiles]], !+ [[EMFields]], and [[LocalEMFields]] by scalars module procedure ps_divide , lps_divide , fs_divide , lfs_divide end interface interface interpol_coeff !+ Calculates interpolation coefficients module procedure interpol1D_coeff , interpol1D_coeff_arr module procedure interpol2D_coeff , interpol2D_coeff_arr module procedure cyl_interpol3D_coeff , cyl_interpol3D_coeff_arr end interface interface interpol !+ Performs linear/bilinear/cylindrical interpolation module procedure interpol1D_arr module procedure interpol2D_arr , interpol2D_2D_arr module procedure interpol3D_arr , interpol3D_2D_arr end interface !! definition of the structures: type ( BeamGrid ), save :: beam_grid !+ Variable containing beam grid definition type ( InterpolationGrid ), save :: inter_grid !+ Variable containing interpolation grid definition type ( InterpolationGrid ), save :: pass_grid !+ Variable containing passive neutral grid definition type ( FastIonDistribution ), save :: fbm !+ Variable containing the fast-ion distribution function type ( FastIonParticles ), save :: particles !+ Variable containing a MC fast-ion distribution type ( Equilibrium ), save :: equil !+ Variable containing the plasma parameters and fields type ( NeutralBeam ), save :: nbi !+ Variable containing the neutral beam geometry and settings type ( AtomicTables ), save :: tables !+ Variable containing the atomic tables type ( NPAResults ), save :: npa !+ Variable for storing the calculated active NPA results type ( NPAResults ), save :: pnpa !+ Variable for storing the calculated passive NPA results type ( SpectralChords ), save :: spec_chords !+ Variable containing the spectral system definition type ( NPAChords ), save :: npa_chords !+ Variable containing the NPA system definition type ( SimulationInputs ), save :: inputs !+ Variable containing the simulation inputs type ( BirthProfile ), save :: birth !+ Variable for storing the calculated birth profile type ( NeutralDensity ), save :: neut !+ Variable for storing the calculated beam density type ( Spectra ), save :: spec !+ Variable for storing the calculated spectra type ( NeutronRate ), save :: neutron !+ Variable for storing the neutron rate type ( FIDAWeights ), save :: fweight !+ Variable for storing the calculated FIDA weights type ( NPAWeights ), save :: nweight !+ Variable for storing the calculated NPA weights contains subroutine print_banner () !+ Prints FIDASIM banner write ( * , '(a)' ) \"   ____ ____ ___   ___    ____ ____ __  ___\" write ( * , '(a)' ) \"  / __//  _// _ \\ / _ |  / __//  _//  |/  /\" write ( * , '(a)' ) \" / _/ _/ / / // // __ | _\\ \\ _/ / / /|_/ / \" write ( * , '(a)' ) \"/_/  /___//____//_/ |_|/___//___//_/  /_/  \" write ( * , '(a)' ) \"                                           \" if ( version . ne . \"\" ) then write ( * , '(a,a)' ) \"Version: \" , trim ( version ) endif write ( * , '(a)' ) \"\" write ( * , '(a)' ) \"FIDASIM is released as open source code under the MIT Licence.\" write ( * , '(a)' ) \"For more information visit http://d3denergetic.github.io/FIDASIM/\" write ( * , '(a)' ) \"\" #ifdef _DEBUG write ( * , '(a)' ) \"########################### ATTENTION ###########################\" write ( * , '(a)' ) \"# Running in debug mode. All optimizations have been turned off #\" write ( * , '(a)' ) \"#################################################################\" write ( * , '(a)' ) \"\" #endif #ifdef _PROF write ( * , '(a)' ) \"########################### ATTENTION ###########################\" write ( * , '(a)' ) \"#                   Running in profiling mode                   #\" write ( * , '(a)' ) \"#################################################################\" write ( * , '(a)' ) \"\" #endif #ifndef _OMP #ifndef _MPI write ( * , '(a)' ) \"########################### ATTENTION ###########################\" write ( * , '(a)' ) \"#              OpenMP threading has been disabled               #\" write ( * , '(a)' ) \"#################################################################\" write ( * , '(a)' ) \"\" #endif #endif #ifndef _MPI #ifndef _OMP write ( * , '(a)' ) \"########################### ATTENTION ###########################\" write ( * , '(a)' ) \"#                     MPI has been disabled                     #\" write ( * , '(a)' ) \"#################################################################\" write ( * , '(a)' ) \"\" #endif #endif end subroutine print_banner !============================================================================ !---------------------------Operator Overloading----------------------------- !============================================================================ subroutine fast_ion_assign ( p1 , p2 ) !+ Defines how to assign [[FastIon]] types to eachother type ( FastIon ), intent ( in ) :: p2 type ( FastIon ), intent ( out ) :: p1 p1 % beam_grid_cross_grid = p2 % beam_grid_cross_grid p1 % r = p2 % r p1 % z = p2 % z p1 % phi = p2 % phi p1 % beam_grid_phi_enter = p2 % beam_grid_phi_enter p1 % delta_phi = p2 % delta_phi p1 % energy = p2 % energy p1 % pitch = p2 % pitch p1 % vabs = p2 % vabs p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % weight = p2 % weight p1 % class = p2 % class end subroutine fast_ion_assign subroutine npa_part_assign ( p1 , p2 ) !+ Defines how to assign [[NPAParticle]] types to eachother type ( NPAParticle ), intent ( in ) :: p2 type ( NPAParticle ), intent ( out ) :: p1 p1 % xi = p2 % xi p1 % yi = p2 % yi p1 % zi = p2 % zi p1 % xf = p2 % xf p1 % yf = p2 % yf p1 % zf = p2 % zf p1 % weight = p2 % weight p1 % energy = p2 % energy p1 % pitch = p2 % pitch p1 % detector = p2 % detector end subroutine npa_part_assign subroutine birth_part_assign ( p1 , p2 ) !+ Defines how to assign [[BirthParticle]] types to eachother type ( BirthParticle ), intent ( in ) :: p2 type ( BirthParticle ), intent ( out ) :: p1 p1 % neut_type = p2 % neut_type p1 % ind = p2 % ind p1 % ri = p2 % ri p1 % vi = p2 % vi p1 % ri_gc = p2 % ri_gc p1 % weight = p2 % weight p1 % energy = p2 % energy p1 % pitch = p2 % pitch end subroutine birth_part_assign subroutine pp_assign ( p1 , p2 ) !+ Defines how to assign [[Profiles]] types to eachother type ( Profiles ), intent ( in ) :: p2 type ( Profiles ), intent ( inout ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % denn = p2 % denn end subroutine pp_assign subroutine lpp_assign ( p1 , p2 ) !+ Defines how to assign a [[Profiles]] type to a [[LocalProfiles]] type type ( Profiles ), intent ( in ) :: p2 type ( LocalProfiles ), intent ( inout ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % denn = p2 % denn end subroutine lpp_assign subroutine plp_assign ( p1 , p2 ) !+ Defines how to assign a [[LocalProfiles]] type to a [[Profiles]] type type ( LocalProfiles ), intent ( in ) :: p2 type ( Profiles ), intent ( inout ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % denn = p2 % denn end subroutine plp_assign subroutine lplp_assign ( p1 , p2 ) !+ Defines how to assign [[LocalProfiles]] types to eachother type ( LocalProfiles ), intent ( in ) :: p2 type ( LocalProfiles ), intent ( inout ) :: p1 p1 % pos = p2 % pos p1 % uvw = p2 % uvw p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % denn = p2 % denn p1 % vrot = p2 % vrot end subroutine lplp_assign subroutine ff_assign ( p1 , p2 ) !+ Defines how to assign [[EMFields]] types to eachother type ( EMFields ), intent ( in ) :: p2 type ( EMFields ), intent ( inout ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine ff_assign subroutine lff_assign ( p1 , p2 ) !+ Defines how to assign a [[EMFields]] type to a [[LocalEMFields]] type type ( EMFields ), intent ( in ) :: p2 type ( LocalEMFields ), intent ( inout ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine lff_assign subroutine flf_assign ( p1 , p2 ) !+ Defines how to assign a [[LocalEMFields]] type to a [[EMFields]] type type ( LocalEMFields ), intent ( in ) :: p2 type ( EMFields ), intent ( inout ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine flf_assign subroutine lflf_assign ( p1 , p2 ) !+ Defines how to assign [[LocalEMFields]] types to eachother type ( LocalEMFields ), intent ( in ) :: p2 type ( LocalEMFields ), intent ( inout ) :: p1 p1 % pos = p2 % pos p1 % uvw = p2 % uvw p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % b_abs = p2 % b_abs p1 % e_abs = p2 % e_abs p1 % a_norm = p2 % a_norm p1 % b_norm = p2 % b_norm p1 % c_norm = p2 % c_norm p1 % e_norm = p2 % e_norm p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine lflf_assign function pp_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[Profiles]] types type ( Profiles ), intent ( in ) :: p1 , p2 type ( Profiles ) :: p3 p3 % dene = p1 % dene + p2 % dene p3 % ti = p1 % ti + p2 % ti p3 % te = p1 % te + p2 % te p3 % denp = p1 % denp + p2 % denp p3 % denf = p1 % denf + p2 % denf p3 % denimp = p1 % denimp + p2 % denimp p3 % zeff = p1 % zeff + p2 % zeff p3 % vr = p1 % vr + p2 % vr p3 % vt = p1 % vt + p2 % vt p3 % vz = p1 % vz + p2 % vz p3 % denn = p1 % denn + p2 % denn end function pp_add function pp_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[Profiles]] types type ( Profiles ), intent ( in ) :: p1 , p2 type ( Profiles ) :: p3 p3 % dene = p1 % dene - p2 % dene p3 % ti = p1 % ti - p2 % ti p3 % te = p1 % te - p2 % te p3 % denp = p1 % denp - p2 % denp p3 % denf = p1 % denf - p2 % denf p3 % denimp = p1 % denimp - p2 % denimp p3 % zeff = p1 % zeff - p2 % zeff p3 % vr = p1 % vr - p2 % vr p3 % vt = p1 % vt - p2 % vt p3 % vz = p1 % vz - p2 % vz p3 % denn = p1 % denn - p2 % denn end function pp_subtract function lplp_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[LocalProfiles]] types type ( LocalProfiles ), intent ( in ) :: p1 , p2 type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos + p2 % pos p3 % uvw = p1 % uvw + p2 % uvw p3 % dene = p1 % dene + p2 % dene p3 % ti = p1 % ti + p2 % ti p3 % te = p1 % te + p2 % te p3 % denp = p1 % denp + p2 % denp p3 % denf = p1 % denf + p2 % denf p3 % denimp = p1 % denimp + p2 % denimp p3 % zeff = p1 % zeff + p2 % zeff p3 % vr = p1 % vr + p2 % vr p3 % vt = p1 % vt + p2 % vt p3 % vz = p1 % vz + p2 % vz p3 % denn = p1 % denn + p2 % denn p3 % vrot = p1 % vrot + p2 % vrot end function lplp_add function lplp_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[LocalProfiles]] types type ( LocalProfiles ), intent ( in ) :: p1 , p2 type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos - p2 % pos p3 % uvw = p1 % uvw - p2 % uvw p3 % dene = p1 % dene - p2 % dene p3 % ti = p1 % ti - p2 % ti p3 % te = p1 % te - p2 % te p3 % denp = p1 % denp - p2 % denp p3 % denf = p1 % denf - p2 % denf p3 % denimp = p1 % denimp - p2 % denimp p3 % zeff = p1 % zeff - p2 % zeff p3 % vr = p1 % vr - p2 % vr p3 % vt = p1 % vt - p2 % vt p3 % vz = p1 % vz - p2 % vz p3 % denn = p1 % denn - p2 % denn p3 % vrot = p1 % vrot - p2 % vrot end function lplp_subtract function ps_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[Profiles]] types by a scalar type ( Profiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 % dene = p1 % dene * real_scalar p3 % ti = p1 % ti * real_scalar p3 % te = p1 % te * real_scalar p3 % denp = p1 % denp * real_scalar p3 % denf = p1 % denf * real_scalar p3 % denimp = p1 % denimp * real_scalar p3 % zeff = p1 % zeff * real_scalar p3 % vr = p1 % vr * real_scalar p3 % vt = p1 % vt * real_scalar p3 % vz = p1 % vz * real_scalar p3 % denn = p1 % denn * real_scalar end function ps_multiply function sp_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[Profiles]] types by a scalar type ( Profiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 = p1 * real_scalar end function sp_multiply function ps_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[Profiles]] types by a scalar type ( Profiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function ps_divide function lps_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[LocalProfiles]] types by a scalar type ( LocalProfiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos * real_scalar p3 % uvw = p1 % uvw * real_scalar p3 % dene = p1 % dene * real_scalar p3 % ti = p1 % ti * real_scalar p3 % te = p1 % te * real_scalar p3 % denp = p1 % denp * real_scalar p3 % denf = p1 % denf * real_scalar p3 % denimp = p1 % denimp * real_scalar p3 % zeff = p1 % zeff * real_scalar p3 % vr = p1 % vr * real_scalar p3 % vt = p1 % vt * real_scalar p3 % vz = p1 % vz * real_scalar p3 % denn = p1 % denn * real_scalar p3 % vrot = p1 % vrot * real_scalar end function lps_multiply function slp_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[LocalProfiles]] types by a scalar type ( LocalProfiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 = p1 * real_scalar end function slp_multiply function lps_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[LocalProfiles]] types by a scalar type ( LocalProfiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function lps_divide function ff_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[EMFields]] types type ( EMFields ), intent ( in ) :: p1 , p2 type ( EMFields ) :: p3 p3 % br = p1 % br + p2 % br p3 % bt = p1 % bt + p2 % bt p3 % bz = p1 % bz + p2 % bz p3 % er = p1 % er + p2 % er p3 % et = p1 % et + p2 % et p3 % ez = p1 % ez + p2 % ez p3 % dbr_dr = p1 % dbr_dr + p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz + p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr + p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz + p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr + p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz + p2 % dbz_dz end function ff_add function ff_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[EMFields]] types type ( EMFields ), intent ( in ) :: p1 , p2 type ( EMFields ) :: p3 p3 % br = p1 % br - p2 % br p3 % bt = p1 % bt - p2 % bt p3 % bz = p1 % bz - p2 % bz p3 % er = p1 % er - p2 % er p3 % et = p1 % et - p2 % et p3 % ez = p1 % ez - p2 % ez p3 % dbr_dr = p1 % dbr_dr - p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz - p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr - p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz - p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr - p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz - p2 % dbz_dz end function ff_subtract function fs_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[EMFields]] types by a scalar type ( EMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 % br = p1 % br * real_scalar p3 % bt = p1 % bt * real_scalar p3 % bz = p1 % bz * real_scalar p3 % er = p1 % er * real_scalar p3 % et = p1 % et * real_scalar p3 % ez = p1 % ez * real_scalar p3 % dbr_dr = p1 % dbr_dr * real_scalar p3 % dbr_dz = p1 % dbr_dz * real_scalar p3 % dbt_dr = p1 % dbt_dr * real_scalar p3 % dbt_dz = p1 % dbt_dz * real_scalar p3 % dbz_dr = p1 % dbz_dr * real_scalar p3 % dbz_dz = p1 % dbz_dz * real_scalar end function fs_multiply function sf_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[EMFields]] types by a scalar type ( EMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 = p1 * real_scalar end function sf_multiply function fs_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[EMFields]] types by a scalar type ( EMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function fs_divide function lflf_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[LocalEMFields]] types type ( LocalEMFields ), intent ( in ) :: p1 , p2 type ( LocalEMFields ) :: p3 real ( Float64 ), dimension ( 3 ) :: bfield , efield p3 % pos = p1 % pos + p2 % pos p3 % uvw = p1 % uvw + p2 % uvw p3 % br = p1 % br + p2 % br p3 % bt = p1 % bt + p2 % bt p3 % bz = p1 % bz + p2 % bz p3 % er = p1 % er + p2 % er p3 % et = p1 % et + p2 % et p3 % ez = p1 % ez + p2 % ez bfield = p1 % b_abs * p1 % b_norm + p2 % b_abs * p2 % b_norm p3 % b_abs = norm2 ( bfield ) if ( p3 % b_abs . gt . 0.d0 ) then p3 % b_norm = bfield / p3 % b_abs call calc_perp_vectors ( p3 % b_norm , p3 % a_norm , p3 % c_norm ) endif efield = p1 % e_abs * p1 % e_norm + p2 % e_abs * p2 % e_norm p3 % e_abs = norm2 ( efield ) if ( p3 % e_abs . gt . 0.d0 ) p3 % e_norm = efield / p3 % e_abs p3 % dbr_dr = p1 % dbr_dr + p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz + p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr + p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz + p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr + p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz + p2 % dbz_dz end function lflf_add function lflf_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[LocalEMFields]] types type ( LocalEMFields ), intent ( in ) :: p1 , p2 type ( LocalEMFields ) :: p3 real ( Float64 ), dimension ( 3 ) :: bfield , efield p3 % pos = p1 % pos - p2 % pos p3 % uvw = p1 % uvw - p2 % uvw p3 % br = p1 % br - p2 % br p3 % bt = p1 % bt - p2 % bt p3 % bz = p1 % bz - p2 % bz p3 % er = p1 % er - p2 % er p3 % et = p1 % et - p2 % et p3 % ez = p1 % ez - p2 % ez bfield = p1 % b_abs * p1 % b_norm - p2 % b_abs * p2 % b_norm p3 % b_abs = norm2 ( bfield ) if ( p3 % b_abs . gt . 0.d0 ) then p3 % b_norm = bfield / p3 % b_abs call calc_perp_vectors ( p3 % b_norm , p3 % a_norm , p3 % c_norm ) endif efield = p1 % e_abs * p1 % e_norm - p2 % e_abs * p2 % e_norm p3 % e_abs = norm2 ( efield ) if ( p3 % e_abs . gt . 0.d0 ) p3 % e_norm = efield / p3 % e_abs p3 % dbr_dr = p1 % dbr_dr - p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz - p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr - p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz - p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr - p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz - p2 % dbz_dz end function lflf_subtract function lfs_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[LocalEMFields]] types by a scalar type ( LocalEMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 % pos = p1 % pos * real_scalar p3 % uvw = p1 % uvw * real_scalar p3 % br = p1 % br * real_scalar p3 % bt = p1 % bt * real_scalar p3 % bz = p1 % bz * real_scalar p3 % er = p1 % er * real_scalar p3 % et = p1 % et * real_scalar p3 % ez = p1 % ez * real_scalar p3 % b_abs = p1 % b_abs * real_scalar p3 % e_abs = p1 % e_abs * real_scalar p3 % a_norm = p1 % a_norm p3 % b_norm = p1 % b_norm p3 % c_norm = p1 % c_norm p3 % e_norm = p1 % e_norm p3 % dbr_dr = p1 % dbr_dr * real_scalar p3 % dbr_dz = p1 % dbr_dz * real_scalar p3 % dbt_dr = p1 % dbt_dr * real_scalar p3 % dbt_dz = p1 % dbt_dz * real_scalar p3 % dbz_dr = p1 % dbz_dr * real_scalar p3 % dbz_dz = p1 % dbz_dz * real_scalar end function lfs_multiply function slf_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[LocalEMFields]] types by a scalar type ( LocalEMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 = p1 * real_scalar end function slf_multiply function lfs_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[LocalEMFields]] types by a scalar type ( LocalEMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function lfs_divide !============================================================================ !-------------------------------I/O Routines--------------------------------- !============================================================================ subroutine read_inputs !+ Reads input namelist file and stores the results into [[libfida:inputs]], !+ [[libfida:nbi]], and [[libfida:beam_grid]] character ( charlim ) :: runid , result_dir , tables_file character ( charlim ) :: distribution_file , equilibrium_file character ( charlim ) :: geometry_file , neutrals_file integer :: pathlen , calc_neutron , seed integer :: calc_brems , calc_dcx , calc_halo , calc_cold , calc_bes integer :: calc_fida , calc_pfida , calc_npa , calc_pnpa integer :: calc_birth , calc_fida_wght , calc_npa_wght integer :: load_neutrals , verbose , flr , split integer ( Int64 ) :: n_fida , n_pfida , n_npa , n_pnpa , n_nbi , n_halo , n_dcx , n_birth integer ( Int32 ) :: shot , nlambda , ne_wght , np_wght , nphi_wght , nlambda_wght real ( Float64 ) :: time , lambdamin , lambdamax , emax_wght real ( Float64 ) :: lambdamin_wght , lambdamax_wght real ( Float64 ) :: ai , ab , pinj , einj , current_fractions ( 3 ) integer ( Int32 ) :: impurity_charge integer ( Int32 ) :: nx , ny , nz real ( Float64 ) :: xmin , xmax , ymin , ymax , zmin , zmax real ( Float64 ) :: alpha , beta , gamma , origin ( 3 ) logical :: exis , error integer :: calc_nbi , no_flr !TODO Remove before release NAMELIST / fidasim_inputs / result_dir , tables_file , distribution_file , & geometry_file , equilibrium_file , neutrals_file , shot , time , runid , & calc_brems , calc_dcx , calc_halo , calc_cold , calc_fida , calc_bes ,& calc_pfida , calc_npa , calc_pnpa , calc_birth , seed , flr , split , & calc_fida_wght , calc_npa_wght , load_neutrals , verbose , & calc_neutron , n_fida , n_pfida , n_npa , n_pnpa , n_nbi , n_halo , n_dcx , n_birth , & ab , pinj , einj , current_fractions , ai , impurity_charge , & nx , ny , nz , xmin , xmax , ymin , ymax , zmin , zmax , & origin , alpha , beta , gamma , & ne_wght , np_wght , nphi_wght , & nlambda , lambdamin , lambdamax , emax_wght , & nlambda_wght , lambdamin_wght , lambdamax_wght , & calc_nbi , no_flr !TODO remove before release inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'READ_INPUTS: Input file does not exist: ' , trim ( namelist_file ) stop endif ! variables that are not changed not be auto-initalized ! provide reasonable defaults here result_dir = \".\" tables_file = \".\" distribution_file = \".\" geometry_file = \".\" equilibrium_file = \".\" neutrals_file = \".\" shot = 0 time = 0 runid = \"0\" seed = - 1 calc_brems = 0 calc_bes = 0 calc_dcx = 0 calc_halo = 0 calc_cold = 0 calc_fida = 0 calc_pfida = 0 calc_npa = 0 calc_pnpa = 0 calc_birth = 0 flr = 2 split = 1 calc_fida_wght = 0 calc_npa_wght = 0 load_neutrals = 0 verbose = 0 calc_neutron = 0 n_fida = 0 n_pfida = 0 n_npa = 0 n_pnpa = 0 n_nbi = 0 n_halo = 0 n_dcx = 0 n_birth = 0 ab = 0 pinj = 0 einj = 0 current_fractions = 0 ai = 0 impurity_charge = 0 nx = 0 ny = 0 nz = 0 xmin = 0 xmax = 0 ymin = 0 ymax = 0 zmin = 0 zmax = 0 origin = 0 alpha = 0 beta = 0 gamma = 0 ne_wght = 0 np_wght = 0 nphi_wght = 0 nlambda = 0 lambdamin = 0 lambdamax = 0 emax_wght = 0 nlambda_wght = 0 lambdamin_wght = 0 lambdamax_wght = 0 !TODO remove before release calc_nbi = 0 no_flr = 0 open ( 13 , file = namelist_file ) read ( 13 , NML = fidasim_inputs ) close ( 13 ) !!TODO remove before release if ( calc_nbi . gt . 0 ) calc_bes = 1 if ( no_flr . ge . 1 ) flr = 0 !!General Information inputs % shot_number = shot inputs % time = time inputs % runid = runid inputs % result_dir = result_dir !!Input Files inputs % tables_file = tables_file inputs % geometry_file = geometry_file inputs % equilibrium_file = equilibrium_file inputs % distribution_file = distribution_file inputs % neutrals_file = neutrals_file !! RNG seed inputs % seed = seed if ( inputs % seed . lt . 0 ) inputs % seed = rng_seed () !!Simulation Switches if (( calc_brems + calc_bes + calc_dcx + calc_halo + & calc_cold + calc_fida + calc_pfida ). gt . 0 ) then inputs % calc_spec = 1 inputs % tot_spectra = calc_brems + calc_bes + calc_dcx + calc_halo + & calc_cold + calc_fida + calc_pfida else inputs % calc_spec = 0 inputs % tot_spectra = 0 endif inputs % calc_beam = 0 if (( calc_bes + calc_birth + calc_dcx + & calc_halo + calc_fida + calc_npa + & calc_fida_wght + calc_npa_wght ). gt . 0 ) then inputs % calc_nbi_dens = 1 inputs % calc_beam = 1 else inputs % calc_nbi_dens = 0 endif if (( calc_dcx + calc_halo + calc_fida + calc_npa + & calc_fida_wght + calc_npa_wght ). gt . 0 ) then inputs % calc_dcx_dens = 1 inputs % calc_beam = 1 else inputs % calc_dcx_dens = 0 endif if (( calc_halo + calc_fida + calc_npa + & calc_fida_wght + calc_npa_wght ). gt . 0 ) then inputs % calc_halo_dens = 1 inputs % calc_beam = 1 else inputs % calc_halo_dens = 0 endif inputs % calc_brems = calc_brems inputs % calc_bes = calc_bes inputs % calc_dcx = calc_dcx inputs % calc_halo = calc_halo inputs % calc_cold = calc_cold inputs % calc_fida = calc_fida inputs % calc_pfida = calc_pfida inputs % calc_npa = calc_npa inputs % calc_pnpa = calc_pnpa inputs % calc_birth = calc_birth inputs % calc_fida_wght = calc_fida_wght inputs % calc_npa_wght = calc_npa_wght inputs % calc_neutron = calc_neutron inputs % load_neutrals = load_neutrals inputs % verbose = verbose inputs % flr = flr inputs % split = split !!Monte Carlo Settings inputs % n_fida = max ( 10 , n_fida ) inputs % n_pfida = max ( 10 , n_pfida ) inputs % n_npa = max ( 10 , n_npa ) inputs % n_pnpa = max ( 10 , n_pnpa ) inputs % n_nbi = max ( 10 , n_nbi ) inputs % n_halo = max ( 10 , n_halo ) inputs % n_dcx = max ( 10 , n_dcx ) inputs % n_birth = max ( 1 , nint ( n_birth / real ( n_nbi ))) !!Plasma Settings inputs % ai = ai inputs % impurity_charge = impurity_charge !!Neutral Beam Settings inputs % ab = ab nbi % current_fractions = current_fractions nbi % einj = einj nbi % pinj = pinj !!Weight Function Settings inputs % ne_wght = ne_wght inputs % np_wght = np_wght inputs % nphi_wght = nphi_wght inputs % emax_wght = emax_wght inputs % nlambda_wght = nlambda_wght inputs % lambdamin_wght = lambdamin_wght inputs % lambdamax_wght = lambdamax_wght !!Wavelength Grid Settings inputs % nlambda = nlambda inputs % lambdamin = lambdamin inputs % lambdamax = lambdamax inputs % dlambda = ( inputs % lambdamax - inputs % lambdamin ) / inputs % nlambda !!Beam Grid Settings beam_grid % nx = nx beam_grid % ny = ny beam_grid % nz = nz beam_grid % xmin = xmin beam_grid % xmax = xmax beam_grid % ymin = ymin beam_grid % ymax = ymax beam_grid % zmin = zmin beam_grid % zmax = zmax beam_grid % alpha = alpha beam_grid % beta = beta beam_grid % gamma = gamma beam_grid % origin = origin #ifdef _MPI if ( my_rank (). ne . 0 ) inputs % verbose = 0 #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Shot settings ----\" write ( * , '(T2,\"Shot: \",i8)' ) inputs % shot_number write ( * , '(T2,\"Time: \",i4,\" [ms]\")' ) int ( inputs % time * 1.d3 ) write ( * , '(T2,\"Runid: \",a)' ) trim ( adjustl ( inputs % runid )) write ( * , * ) '' write ( * , '(a)' ) \"---- Input files ----\" endif error = . False . inquire ( file = inputs % tables_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Tables file: \",a)' ) trim ( inputs % tables_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Tables file does not exist: ' , & trim ( inputs % tables_file ) endif error = . True . endif inquire ( file = inputs % geometry_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Geometry file: \",a)' ) trim ( inputs % geometry_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Geometry file does not exist: ' , & trim ( inputs % geometry_file ) endif error = . True . endif inquire ( file = inputs % equilibrium_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Equilibrium file: \",a)' ) trim ( inputs % equilibrium_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Equilibrium file does not exist: ' , & trim ( inputs % equilibrium_file ) endif error = . True . endif inquire ( file = inputs % distribution_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Distribution file: \",a)' ) trim ( inputs % distribution_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Distribution file does not exist: ' , & trim ( inputs % distribution_file ) endif error = . True . endif pathlen = len_trim ( inputs % result_dir ) + len_trim ( inputs % runid ) + 20 !+20 for suffixes and seperators e.g. /, _npa.h5, ... if ( pathlen . gt . charlim ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,i3,a,i3)' ) 'READ_INPUTS: Result directory path + runID use too many characters: ' , & pathlen - 20 , '>' , charlim - 20 endif error = . True . endif if ( inputs % verbose . ge . 1 ) then write ( * , * ) '' endif if ( error ) then stop endif end subroutine read_inputs subroutine make_beam_grid !+ Makes [[libfida:beam_grid] from user defined inputs integer ( Int32 ) :: i , j , k , n real ( Float64 ) :: dx , dy , dz , ri ( 3 ) logical :: inp allocate ( beam_grid % xc ( beam_grid % nx ), & beam_grid % yc ( beam_grid % ny ), & beam_grid % zc ( beam_grid % nz )) dx = ( beam_grid % xmax - beam_grid % xmin ) / beam_grid % nx dy = ( beam_grid % ymax - beam_grid % ymin ) / beam_grid % ny dz = ( beam_grid % zmax - beam_grid % zmin ) / beam_grid % nz do i = 1 , beam_grid % nx beam_grid % xc ( i ) = beam_grid % xmin + ( i - 0.5 ) * dx enddo do i = 1 , beam_grid % ny beam_grid % yc ( i ) = beam_grid % ymin + ( i - 0.5 ) * dy enddo do i = 1 , beam_grid % nz beam_grid % zc ( i ) = beam_grid % zmin + ( i - 0.5 ) * dz enddo beam_grid % dr ( 1 ) = abs ( beam_grid % xc ( 2 ) - beam_grid % xc ( 1 )) beam_grid % dr ( 2 ) = abs ( beam_grid % yc ( 2 ) - beam_grid % yc ( 1 )) beam_grid % dr ( 3 ) = abs ( beam_grid % zc ( 2 ) - beam_grid % zc ( 1 )) beam_grid % lwh ( 1 ) = abs ( beam_grid % xc ( beam_grid % nx ) - beam_grid % xc ( 1 )) + beam_grid % dr ( 1 ) beam_grid % lwh ( 2 ) = abs ( beam_grid % yc ( beam_grid % ny ) - beam_grid % yc ( 1 )) + beam_grid % dr ( 2 ) beam_grid % lwh ( 3 ) = abs ( beam_grid % zc ( beam_grid % nz ) - beam_grid % zc ( 1 )) + beam_grid % dr ( 3 ) beam_grid % volume = beam_grid % lwh ( 1 ) * beam_grid % lwh ( 2 ) * beam_grid % lwh ( 3 ) beam_grid % center ( 1 ) = ( minval ( beam_grid % xc ) - 0.5 * beam_grid % dr ( 1 )) + 0.5 * beam_grid % lwh ( 1 ) beam_grid % center ( 2 ) = ( minval ( beam_grid % yc ) - 0.5 * beam_grid % dr ( 2 )) + 0.5 * beam_grid % lwh ( 2 ) beam_grid % center ( 3 ) = ( minval ( beam_grid % zc ) - 0.5 * beam_grid % dr ( 3 )) + 0.5 * beam_grid % lwh ( 3 ) beam_grid % drmin = minval ( beam_grid % dr ) beam_grid % dv = beam_grid % dr ( 1 ) * beam_grid % dr ( 2 ) * beam_grid % dr ( 3 ) beam_grid % ntrack = beam_grid % nx + beam_grid % ny + beam_grid % nz beam_grid % ngrid = beam_grid % nx * beam_grid % ny * beam_grid % nz beam_grid % dims ( 1 ) = beam_grid % nx beam_grid % dims ( 2 ) = beam_grid % ny beam_grid % dims ( 3 ) = beam_grid % nz call tb_zyx ( beam_grid % alpha , beam_grid % beta , beam_grid % gamma , & beam_grid % basis , beam_grid % inv_basis ) !! Check if beam grid is in the plasma n = 0 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ri = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] call in_plasma ( ri , inp ) if ( inp ) n = n + 1 enddo enddo enddo if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Beam grid settings ----\" write ( * , '(T2,\"Nx: \", i3)' ) beam_grid % nx write ( * , '(T2,\"Ny: \", i3)' ) beam_grid % ny write ( * , '(T2,\"Nz: \", i3)' ) beam_grid % nz write ( * , '(T2,\"dV: \", f5.2,\" [cm&#94;3]\")' ) beam_grid % dv write ( * , '(T2,\"alpha: \",f5.2,\" [rad]\")' ) beam_grid % alpha write ( * , '(T2,\"beta:  \",f5.2,\" [rad]\")' ) beam_grid % beta write ( * , '(T2,\"gamma: \",f5.2,\" [rad]\")' ) beam_grid % gamma write ( * , '(T2,\"origin: [\",f7.2,\",\",f7.2,\",\",f7.2,\"] [cm]\")' ) beam_grid % origin write ( * , '(T2,\"Number of cells in plasma: \",i8)' ) n write ( * , * ) '' endif if ( n . le .( 0.1 * beam_grid % ngrid )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"MAKE_BEAM_GRID: Beam grid definition is poorly defined. & &Less than 10% of the beam grid cells fall within the plasma.\" endif stop endif end subroutine make_beam_grid subroutine make_passive_grid !+ Makes [[libfida:pass_grid] from user defined inputs real ( Float64 ), dimension ( 3 , spec_chords % nchan + npa_chords % nchan ) :: r0_arr , v0_arr real ( Float64 ), dimension ( 2 , spec_chords % nchan + npa_chords % nchan ) :: xy_enter , xy_exit logical , dimension ( 8 + 2 * ( spec_chords % nchan + npa_chords % nchan )) :: yle , ygt logical , dimension ( spec_chords % nchan + npa_chords % nchan ) :: skip real ( Float64 ), dimension (:), allocatable :: xarr , yarr real ( Float64 ), dimension ( 3 , 8 ) :: vertices_xyz , vertices_uvw real ( Float64 ), dimension ( 2 , 3 ) :: extrema real ( Float64 ), dimension ( 3 , 3 ) :: xyz_axis real ( Float64 ), dimension ( 3 ) :: r0 , vi real ( Float64 ), dimension ( 8 ) :: xarr_beam_grid , yarr_beam_grid real ( Float64 ) :: xmin , ymin , xmax , ymax , zmin , zmax , max_length real ( Float64 ) :: dlength = 3.0 !cm integer :: i , iin , iout , dim_le , dim_gt , dim logical :: inp , phi_pos !! Get beam grid boundaries ! Convert vertices_xyz to vertices_uvw ! Note: vertices_xyz has the following coordinate definitions: ! 111 = 1, 222 = 2, 112 = 3, 211 = 4, 121 = 5, 212 = 6, 122 = 7, 221 = 8 xmin = beam_grid % xmin ; xmax = beam_grid % xmax ymin = beam_grid % ymin ; ymax = beam_grid % ymax zmin = beam_grid % zmin ; zmax = beam_grid % zmax !Initialize minimum and maximum vertices vertices_xyz ( 1 , 1 ) = xmin ; vertices_xyz ( 2 , 1 ) = ymin ; vertices_xyz ( 3 , 1 ) = zmin vertices_xyz ( 1 , 2 ) = xmax ; vertices_xyz ( 2 , 2 ) = ymax ; vertices_xyz ( 3 , 2 ) = zmax !Initialize vertices_xyz (:, 3 ) = vertices_xyz (:, 1 ) vertices_xyz (:, 4 ) = vertices_xyz (:, 1 ) vertices_xyz (:, 5 ) = vertices_xyz (:, 1 ) !Update vertices_xyz ( 3 , 3 ) = zmax vertices_xyz ( 1 , 4 ) = xmax vertices_xyz ( 2 , 5 ) = ymax !Initialize vertices_xyz (:, 7 ) = vertices_xyz (:, 2 ) vertices_xyz (:, 8 ) = vertices_xyz (:, 2 ) vertices_xyz (:, 6 ) = vertices_xyz (:, 2 ) !Update vertices_xyz ( 1 , 7 ) = xmin vertices_xyz ( 3 , 8 ) = zmin vertices_xyz ( 2 , 6 ) = ymin do i = 1 , 8 call xyz_to_uvw ( vertices_xyz (:, i ), vertices_uvw (:, i )) xarr_beam_grid ( i ) = vertices_uvw ( 1 , i ) yarr_beam_grid ( i ) = vertices_uvw ( 2 , i ) enddo !! Next consider passive diagnostic extrema relative to the plasma if (( inputs % calc_pfida . gt . 0 ). and .( inputs % calc_pnpa . gt . 0 )) then do i = 1 ,( spec_chords % nchan ) r0_arr (:, i ) = spec_chords % los ( i )% lens_uvw v0_arr (:, i ) = spec_chords % los ( i )% axis_uvw enddo do i = 1 , npa_chords % nchan call xyz_to_uvw ( npa_chords % det ( i )% detector % origin , r0_arr (:, i + spec_chords % nchan )) xyz_axis = npa_chords % det ( i )% detector % basis v0_arr (:, i + spec_chords % nchan ) = matmul ( beam_grid % basis , xyz_axis (:, 3 )) enddo else if ( inputs % calc_pfida . gt . 0 ) then do i = 1 , spec_chords % nchan r0_arr (:, i ) = spec_chords % los ( i )% lens_uvw v0_arr (:, i ) = spec_chords % los ( i )% axis_uvw enddo else !pnpa>=1 case do i = 1 , npa_chords % nchan call xyz_to_uvw ( npa_chords % det ( i )% detector % origin , r0_arr (:, i )) xyz_axis = npa_chords % det ( i )% detector % basis v0_arr (:, i ) = matmul ( beam_grid % basis , xyz_axis (:, 3 )) enddo endif call get_plasma_extrema ( r0_arr , v0_arr , extrema , xarr_beam_grid , yarr_beam_grid ) !! Store the passive neutral grid pass_grid % dr = inter_grid % dr pass_grid % dz = inter_grid % dz pass_grid % nr = inter_grid % nr pass_grid % nz = inter_grid % nz allocate ( pass_grid % r ( pass_grid % nr ), pass_grid % z ( pass_grid % nz )) pass_grid % r = inter_grid % r pass_grid % z = inter_grid % z pass_grid % da = pass_grid % dr * pass_grid % dz pass_grid % dphi = 0.1 pass_grid % nphi = int ( ceiling (( extrema ( 2 , 3 ) - extrema ( 1 , 3 )) / pass_grid % dphi )) if ( pass_grid % nphi . gt . 20 ) then !! Avoid large memory allocation pass_grid % nphi = 20 pass_grid % dphi = ( extrema ( 2 , 3 ) - extrema ( 1 , 3 )) / pass_grid % nphi endif allocate ( pass_grid % phi ( pass_grid % nphi )) do i = 1 , pass_grid % nphi pass_grid % phi ( i ) = extrema ( 1 , 3 ) + ( i - 1 ) * pass_grid % dphi enddo pass_grid % dv = pass_grid % dr * pass_grid % dphi * pass_grid % dz pass_grid % dims = [ pass_grid % nr , pass_grid % nz , pass_grid % nphi ] pass_grid % ntrack = pass_grid % nr + pass_grid % nz + pass_grid % nphi pass_grid % ngrid = pass_grid % nr * pass_grid % nz * pass_grid % nphi if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Passive neutral grid settings ----\" write ( * , '(T2,\"Nr: \", i3)' ) pass_grid % nr write ( * , '(T2,\"Nz: \", i3)' ) pass_grid % nz write ( * , '(T2,\"Nphi: \", i3)' ) pass_grid % nphi write ( * , '(T2,\"R  range = [\",f6.2,\",\",f6.2,\"]\")' ) & pass_grid % r ( 1 ), pass_grid % r ( pass_grid % nr ) write ( * , '(T2,\"Z  range = [\",f7.2,\",\",f6.2,\"]\")' ) & pass_grid % z ( 1 ), pass_grid % z ( pass_grid % nz ) write ( * , '(T2,\"Phi  range = [\",f5.2,\",\",f5.2,\"]\")' ) & pass_grid % phi ( 1 ), pass_grid % phi ( pass_grid % nphi ) write ( * , '(T2,\"dA: \", f5.2,\" [cm&#94;3]\")' ) pass_grid % da write ( * , * ) '' endif end subroutine make_passive_grid subroutine make_diagnostic_grids !+ Makes [[libfida:pass_grid] from user defined inputs, and stores the quantities in !+ [[libfida:spec_chords]] and [[libfida:npa_chords]] real ( Float64 ), dimension (:,:,:), allocatable :: dlength type ( LOSElement ), dimension (:), allocatable :: los_elem type ( ParticleTrack ), dimension (:), allocatable :: tracks real ( Float64 ) :: r0 ( 3 ), v0 ( 3 ), r_enter ( 3 ), r_exit ( 3 ), r0_cyl ( 3 ), ri ( 3 ) real ( Float64 ), dimension ( 3 , 3 ) :: basis real ( Float64 ), dimension ( 2 ) :: randomu real ( Float64 ) :: theta , sqrt_rho , dl , length character ( len = 20 ) :: system = '' real ( Float64 ), dimension (:), allocatable :: probs real ( Float64 ), dimension (:,:), allocatable :: eff_rds real ( Float64 ), parameter :: inv_4pi = ( 4.d0 * pi ) ** ( - 1 ) real ( Float64 ), dimension ( 3 ) :: eff_rd , rd , rd_d , r0_d real ( Float64 ), dimension ( 3 , 3 ) :: inv_basis real ( Float64 ), dimension (:), allocatable :: xd , yd type ( LocalEMFields ) :: fields real ( Float64 ) :: total_prob , hh , hw , dprob , dx , dy , r , pitch integer :: ichan , k , id , ix , iy , d_index , nd , ind_d ( 2 ) integer :: i , j , ic , nc , ntrack , ind ( 3 ), ii , jj , kk integer :: error if ( inputs % calc_pfida + inputs % calc_pnpa . gt . 0 ) then if ( inter_grid % nphi . gt . 1 ) then pass_grid = inter_grid else call make_passive_grid () endif endif !! Spectral line-of-sight passive neutral grid intersection calculations allocate ( spec_chords % cyl_inter ( pass_grid % nr , pass_grid % nz , pass_grid % nphi )) if ( inputs % calc_pfida . gt . 0 ) then allocate ( tracks ( pass_grid % ntrack )) allocate ( dlength ( pass_grid % nr , & pass_grid % nz , & pass_grid % nphi ) ) pass_grid_chan_loop : do i = 1 , spec_chords % nchan r0 = spec_chords % los ( i )% lens_uvw v0 = spec_chords % los ( i )% axis_uvw v0 = v0 / norm2 ( v0 ) call line_basis ( r0 , v0 , basis ) call grid_intersect ( r0 , v0 , length , r_enter , r_exit , passive = . True .) if ( length . le . 0.d0 ) then if ( inputs % verbose . ge . 1 ) then WRITE ( * , '(\"Channel \",i5,\" missed the passive neutral grid or starts inside the plasma\")' ) i endif cycle pass_grid_chan_loop endif if ( spec_chords % los ( i )% spot_size . le . 0.d0 ) then nc = 1 else nc = 100 endif dlength = 0.d0 !$OMP PARALLEL DO schedule(guided) private(ic,randomu,sqrt_rho,theta,r0, & !$OMP& length, r_enter, r_exit, j, tracks, ntrack, ind) do ic = 1 , nc ! Uniformally sample within spot size call randu ( randomu ) sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) r0 ( 1 ) = 0.d0 r0 ( 2 ) = spec_chords % los ( i )% spot_size * sqrt_rho * cos ( theta ) r0 ( 3 ) = spec_chords % los ( i )% spot_size * sqrt_rho * sin ( theta ) r0 = matmul ( basis , r0 ) + spec_chords % los ( i )% lens_uvw call grid_intersect ( r0 , v0 , length , r_enter , r_exit , passive = . True .) call track_cylindrical ( r_enter , v0 , tracks , ntrack ) pass_grid_track_loop : do j = 1 , ntrack ind = tracks ( j )% ind !inds can repeat so add rather than assign !$OMP ATOMIC UPDATE dlength ( ind ( 1 ), ind ( 2 ), ind ( 3 )) = & dlength ( ind ( 1 ), ind ( 2 ), ind ( 3 )) + tracks ( j )% time / real ( nc ) !time == distance !$OMP END ATOMIC enddo pass_grid_track_loop enddo !$OMP END PARALLEL DO do kk = 1 , pass_grid % nphi do jj = 1 , pass_grid % nz rloop : do ii = 1 , pass_grid % nr if ( dlength ( ii , jj , kk ). ne . 0.d0 ) then dl = dlength ( ii , jj , kk ) nc = spec_chords % cyl_inter ( ii , jj , kk )% nchan + 1 if ( nc . eq . 1 ) then allocate ( spec_chords % cyl_inter ( ii , jj , kk )% los_elem ( nc )) spec_chords % cyl_inter ( ii , jj , kk )% los_elem ( nc ) = LOSElement ( i , dl ) else allocate ( los_elem ( nc )) los_elem ( 1 :( nc - 1 )) = spec_chords % cyl_inter ( ii , jj , kk )% los_elem los_elem ( nc ) = LOSElement ( i , dl ) deallocate ( spec_chords % cyl_inter ( ii , jj , kk )% los_elem ) call move_alloc ( los_elem , spec_chords % cyl_inter ( ii , jj , kk )% los_elem ) endif spec_chords % cyl_inter ( ii , jj , kk )% nchan = nc endif enddo rloop enddo enddo enddo pass_grid_chan_loop spec_chords % cyl_ncell = count ( spec_chords % cyl_inter % nchan . gt . 0 ) allocate ( spec_chords % cyl_cell ( spec_chords % cyl_ncell )) nc = 0 do ic = 1 , pass_grid % ngrid call ind2sub ( pass_grid % dims , ic , ind ) ii = ind ( 1 ) ; jj = ind ( 2 ) ; kk = ind ( 3 ) if ( spec_chords % cyl_inter ( ii , jj , kk )% nchan . gt . 0 ) then nc = nc + 1 spec_chords % cyl_cell ( nc ) = ic endif enddo deallocate ( dlength , tracks ) endif !! Spectral line-of-sight beam grid intersection calculations if (( inputs % tot_spectra + inputs % calc_fida_wght - inputs % calc_pfida ). gt . 0 ) then allocate ( dlength ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz ) ) allocate ( tracks ( beam_grid % ntrack )) spec_chan_loop : do i = 1 , spec_chords % nchan r0 = spec_chords % los ( i )% lens v0 = spec_chords % los ( i )% axis v0 = v0 / norm2 ( v0 ) call line_basis ( r0 , v0 , basis ) call grid_intersect ( r0 , v0 , length , r_enter , r_exit ) if ( length . le . 0.d0 ) then if ( inputs % verbose . ge . 1 ) then WRITE ( * , '(\"Channel \",i5,\" missed the beam grid\")' ) i endif cycle spec_chan_loop endif if ( spec_chords % los ( i )% spot_size . le . 0.d0 ) then nc = 1 else nc = 100 endif dlength = 0.d0 !$OMP PARALLEL DO schedule(guided) private(ic,randomu,sqrt_rho,theta,r0, & !$OMP& length, r_enter, r_exit, j, tracks, ntrack, ind) do ic = 1 , nc ! Uniformally sample within spot size call randu ( randomu ) sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) r0 ( 1 ) = 0.d0 r0 ( 2 ) = spec_chords % los ( i )% spot_size * sqrt_rho * cos ( theta ) r0 ( 3 ) = spec_chords % los ( i )% spot_size * sqrt_rho * sin ( theta ) r0 = matmul ( basis , r0 ) + spec_chords % los ( i )% lens call grid_intersect ( r0 , v0 , length , r_enter , r_exit ) call track ( r_enter , v0 , tracks , ntrack ) track_loop : do j = 1 , ntrack ind = tracks ( j )% ind !inds can repeat so add rather than assign !$OMP ATOMIC UPDATE dlength ( ind ( 1 ), ind ( 2 ), ind ( 3 )) = & dlength ( ind ( 1 ), ind ( 2 ), ind ( 3 )) + tracks ( j )% time / real ( nc ) !time == distance !$OMP END ATOMIC enddo track_loop enddo !$OMP END PARALLEL DO do kk = 1 , beam_grid % nz do jj = 1 , beam_grid % ny xloop : do ii = 1 , beam_grid % nx if ( dlength ( ii , jj , kk ). ne . 0.d0 ) then dl = dlength ( ii , jj , kk ) nc = spec_chords % inter ( ii , jj , kk )% nchan + 1 if ( nc . eq . 1 ) then allocate ( spec_chords % inter ( ii , jj , kk )% los_elem ( nc )) spec_chords % inter ( ii , jj , kk )% los_elem ( nc ) = LOSElement ( i , dl ) else allocate ( los_elem ( nc )) los_elem ( 1 :( nc - 1 )) = spec_chords % inter ( ii , jj , kk )% los_elem los_elem ( nc ) = LOSElement ( i , dl ) deallocate ( spec_chords % inter ( ii , jj , kk )% los_elem ) call move_alloc ( los_elem , spec_chords % inter ( ii , jj , kk )% los_elem ) endif spec_chords % inter ( ii , jj , kk )% nchan = nc endif enddo xloop enddo enddo enddo spec_chan_loop spec_chords % ncell = count ( spec_chords % inter % nchan . gt . 0 ) allocate ( spec_chords % cell ( spec_chords % ncell )) nc = 0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) ii = ind ( 1 ) ; jj = ind ( 2 ) ; kk = ind ( 3 ) if ( spec_chords % inter ( ii , jj , kk )% nchan . gt . 0 ) then nc = nc + 1 spec_chords % cell ( nc ) = ic endif enddo endif !! NPA probability calculations allocate ( xd ( 50 ), yd ( 50 )) allocate ( probs ( beam_grid % ngrid )) allocate ( eff_rds ( 3 , beam_grid % ngrid )) allocate ( npa_chords % phit ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan ) ) allocate ( npa_chords % hit ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz ) ) npa_chords % hit = . False . npa_chan_loop : do ichan = 1 , npa_chords % nchan v0 = npa_chords % det ( ichan )% aperture % origin - npa_chords % det ( ichan )% detector % origin v0 = v0 / norm2 ( v0 ) call grid_intersect ( npa_chords % det ( ichan )% detector % origin , v0 , length , r0 , r0_d ) if ( length . le . 0.0 ) then if ( inputs % verbose . ge . 0 ) then WRITE ( * , '(\"Channel \",i3,\" centerline missed the beam grid\")' ) ichan endif endif if ( inputs % calc_npa_wght . ge . 1 ) then hw = npa_chords % det ( ichan )% detector % hw hh = npa_chords % det ( ichan )% detector % hh nd = size ( xd ) do i = 1 , nd xd ( i ) = - hw + 2 * hw * ( i - 0.5 ) / real ( nd ) yd ( i ) = - hh + 2 * hh * ( i - 0.5 ) / real ( nd ) enddo dx = abs ( xd ( 2 ) - xd ( 1 )) dy = abs ( yd ( 2 ) - yd ( 1 )) basis = npa_chords % det ( ichan )% detector % basis inv_basis = npa_chords % det ( ichan )% detector % inv_basis eff_rds = 0.d0 probs = 0.d0 ! For each grid point find the probability of hitting the detector given an isotropic source !$OMP PARALLEL DO schedule(guided) private(ic,i,j,k,ix,iy,total_prob,eff_rd,r0,r0_d, & !$OMP& rd_d,rd,d_index,v0,dprob,r,fields,id,ind_d,ind) do ic = istart , beam_grid % ngrid , istep call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) r0 = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] r0_d = matmul ( inv_basis , r0 - npa_chords % det ( ichan )% detector % origin ) do id = 1 , nd * nd call ind2sub ([ nd , nd ], id , ind_d ) ix = ind_d ( 1 ) ; iy = ind_d ( 2 ) rd_d = [ xd ( ix ), yd ( iy ), 0.d0 ] rd = matmul ( basis , rd_d ) + npa_chords % det ( ichan )% detector % origin v0 = rd - r0 d_index = 0 call hit_npa_detector ( r0 , v0 , d_index , det = ichan ) if ( d_index . ne . 0 ) then r = norm2 ( rd_d - r0_d ) ** 2 dprob = ( dx * dy ) * inv_4pi * r0_d ( 3 ) / ( r * sqrt ( r )) eff_rds (:, ic ) = eff_rds (:, ic ) + dprob * rd probs ( ic ) = probs ( ic ) + dprob endif enddo enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( eff_rds ) call parallel_sum ( probs ) #endif do ic = 1 , beam_grid % ngrid if ( probs ( ic ). gt . 0.0 ) then call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) r0 = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] eff_rd = eff_rds (:, ic ) / probs ( ic ) call get_fields ( fields , pos = r0 ) v0 = ( eff_rd - r0 ) / norm2 ( eff_rd - r0 ) npa_chords % phit ( i , j , k , ichan )% pitch = dot_product ( fields % b_norm , v0 ) npa_chords % phit ( i , j , k , ichan )% p = probs ( ic ) npa_chords % phit ( i , j , k , ichan )% dir = v0 npa_chords % phit ( i , j , k , ichan )% eff_rd = eff_rd npa_chords % hit ( i , j , k ) = . True . endif enddo total_prob = sum ( probs ) if ( total_prob . le . 0.d0 ) then if ( inputs % verbose . ge . 0 ) then WRITE ( * , '(\"Channel \",i3,\" missed the beam grid\")' ) ichan endif cycle npa_chan_loop endif endif enddo npa_chan_loop deallocate ( probs , eff_rds , xd , yd ) end subroutine make_diagnostic_grids subroutine read_beam !+ Reads neutral beam geometry and stores the quantities in [[libfida:nbi]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 1 ) :: dims real ( Float64 ), dimension ( 3 ) :: uvw_src , uvw_axis , pos real ( Float64 ) :: dis logical :: path_valid integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDONLY_F , fid , error ) !!Check if SPEC group exists call h5ltpath_valid_f ( fid , \"/nbi\" , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_BEAM: NBI geometry is not in the geometry file' endif stop endif !!Open NBI group call h5gopen_f ( fid , \"/nbi\" , gid , error ) !!Read in beam definitions call h5ltread_dataset_string_f ( gid , \"/nbi/name\" , nbi % name , error ) dims ( 1 ) = 3 call h5ltread_dataset_double_f ( gid , \"/nbi/src\" , uvw_src , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/axis\" , uvw_axis , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/divy\" , nbi % divy , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/divz\" , nbi % divz , dims , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/nbi/shape\" , nbi % shape , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/focy\" , nbi % focy , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/focz\" , nbi % focz , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/widy\" , nbi % widy , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/widz\" , nbi % widz , error ) !!Read in aperture definitions !! Check for naperture for compatibility with old runs call h5ltpath_valid_f ( gid , \"/nbi/naperture\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltread_dataset_int_scalar_f ( gid , \"/nbi/naperture\" , nbi % naperture , error ) else nbi % naperture = 0 endif if ( nbi % naperture . gt . 0 ) then allocate ( nbi % ashape ( nbi % naperture ), nbi % adist ( nbi % naperture ), & nbi % awidy ( nbi % naperture ), nbi % awidz ( nbi % naperture ), & nbi % aoffy ( nbi % naperture ), nbi % aoffz ( nbi % naperture ) ) dims ( 1 ) = nbi % naperture call h5ltread_dataset_int_f ( gid , \"/nbi/ashape\" , nbi % ashape , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/awidy\" , nbi % awidy , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/awidz\" , nbi % awidz , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/aoffy\" , nbi % aoffy , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/aoffz\" , nbi % aoffz , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/adist\" , nbi % adist , dims , error ) endif !!Close NBI group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) !!Convert to beam grid coordinates call uvw_to_xyz ( uvw_src , nbi % src ) nbi % axis = matmul ( beam_grid % inv_basis , uvw_axis ) nbi % vinj = sqrt ( 2.d0 * nbi % einj * 1.d3 * e0 / ( inputs % ab * mass_u )) * 1.d2 !! [cm/s] pos = nbi % src + 20 0.0 * nbi % axis dis = sqrt ( sum (( pos - nbi % src ) ** 2 )) nbi % beta = asin (( nbi % src ( 3 ) - pos ( 3 )) / dis ) nbi % alpha = atan2 ( pos ( 2 ) - nbi % src ( 2 ), pos ( 1 ) - nbi % src ( 1 )) call tb_zyx ( nbi % alpha , nbi % beta , 0.d0 , nbi % basis , nbi % inv_basis ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Neutral beam settings ----' write ( * , '(T2,\"Beam: \",a)' ) nbi % name write ( * , '(T2,\"Power:   \",f5.2,\" [MW]\")' ) nbi % pinj write ( * , '(T2,\"Voltage: \",f6.2,\" [keV]\")' ) nbi % einj write ( * , * ) '' endif end subroutine read_beam subroutine read_chords !+ Reads the spectral geometry and stores the quantities in [[libfida:spec_chords]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 2 ) :: dims logical :: path_valid real ( Float64 ), dimension (:,:), allocatable :: lenses real ( Float64 ), dimension (:,:), allocatable :: axes real ( Float64 ) :: xyz_lens ( 3 ), xyz_axis ( 3 ) character ( len = 20 ) :: system = '' integer :: i integer :: error if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- FIDA/BES settings ----' endif !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDONLY_F , fid , error ) !!Check if SPEC group exists call h5ltpath_valid_f ( fid , \"/spec\" , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) 'FIDA/BES geometry is not in the geometry file' write ( * , '(a)' ) 'Continuing without spectral diagnostics' endif inputs % calc_spec = 0 inputs % tot_spectra = 0 inputs % calc_fida = 0 inputs % calc_pfida = 0 inputs % calc_bes = 0 inputs % calc_dcx = 0 inputs % calc_halo = 0 inputs % calc_cold = 0 inputs % calc_brems = 0 inputs % calc_fida_wght = 0 call h5fclose_f ( fid , error ) call h5close_f ( error ) return endif !!Open SPEC group call h5gopen_f ( fid , \"/spec\" , gid , error ) call h5ltread_dataset_string_f ( gid , \"/spec/system\" , system , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/spec/nchan\" , spec_chords % nchan , error ) allocate ( lenses ( 3 , spec_chords % nchan )) allocate ( axes ( 3 , spec_chords % nchan )) allocate ( spec_chords % los ( spec_chords % nchan )) allocate ( spec_chords % radius ( spec_chords % nchan )) dims = [ 3 , spec_chords % nchan ] call h5ltread_dataset_double_f ( gid , \"/spec/lens\" , lenses , dims , error ) call h5ltread_dataset_double_f ( gid , \"/spec/axis\" , axes , dims , error ) call h5ltread_dataset_double_f ( gid , \"/spec/spot_size\" , spec_chords % los % spot_size , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/spec/sigma_pi\" , spec_chords % los % sigma_pi , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/spec/radius\" , spec_chords % radius , dims ( 2 : 2 ), error ) !!Close SPEC group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) chan_loop : do i = 1 , spec_chords % nchan call uvw_to_xyz ( lenses (:, i ), xyz_lens ) xyz_axis = matmul ( beam_grid % inv_basis , axes (:, i )) spec_chords % los ( i )% lens = xyz_lens spec_chords % los ( i )% axis = xyz_axis spec_chords % los ( i )% lens_uvw = lenses (:, i ) spec_chords % los ( i )% axis_uvw = axes (:, i ) enddo chan_loop if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"FIDA/BES System: \",a)' ) trim ( adjustl ( system )) write ( * , '(T2,\"Number of channels: \",i5)' ) spec_chords % nchan write ( * , * ) '' endif deallocate ( lenses , axes ) end subroutine read_chords subroutine read_npa !+ Reads the NPA geometry and stores the quantities in [[libfida:npa_chords]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 2 ) :: dims logical :: path_valid real ( Float64 ), dimension (:,:), allocatable :: a_tedge , a_redge , a_cent real ( Float64 ), dimension (:,:), allocatable :: d_tedge , d_redge , d_cent character ( len = 20 ) :: system = '' real ( Float64 ), dimension ( 3 ) :: xyz_a_tedge , xyz_a_redge , xyz_a_cent real ( Float64 ), dimension ( 3 ) :: xyz_d_tedge , xyz_d_redge , xyz_d_cent real ( Float64 ), dimension ( 3 , 3 ) :: basis , inv_basis real ( Float64 ) :: hh , hw integer :: ichan integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDWR_F , fid , error ) !!Check if NPA group exists call h5ltpath_valid_f ( fid , \"/npa\" , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'NPA geometry is not in the geometry file' write ( * , '(a)' ) 'Continuing without NPA diagnostics' endif inputs % calc_npa = 0 inputs % calc_pnpa = 0 inputs % calc_npa_wght = 0 call h5fclose_f ( fid , error ) call h5close_f ( error ) return endif !!Open NPA group call h5gopen_f ( fid , \"/npa\" , gid , error ) call h5ltread_dataset_string_f ( gid , \"/npa/system\" , system , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/npa/nchan\" , npa_chords % nchan , error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- NPA settings ----\" write ( * , '(T2,\"NPA System: \", a)' ) trim ( adjustl ( system )) write ( * , '(T2,\"Number of channels: \",i3)' ) npa_chords % nchan endif allocate ( a_tedge ( 3 , npa_chords % nchan )) allocate ( a_redge ( 3 , npa_chords % nchan )) allocate ( a_cent ( 3 , npa_chords % nchan )) allocate ( d_tedge ( 3 , npa_chords % nchan )) allocate ( d_redge ( 3 , npa_chords % nchan )) allocate ( d_cent ( 3 , npa_chords % nchan )) allocate ( npa_chords % radius ( npa_chords % nchan )) allocate ( npa_chords % det ( npa_chords % nchan )) dims = [ 3 , spec_chords % nchan ] call h5ltread_dataset_double_f ( gid , \"/npa/radius\" , npa_chords % radius , dims ( 2 : 2 ), error ) call h5ltread_dataset_int_f ( gid , \"/npa/a_shape\" , npa_chords % det % aperture % shape , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_tedge\" , a_tedge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_redge\" , a_redge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_cent\" , a_cent , dims , error ) call h5ltread_dataset_int_f ( gid , \"/npa/d_shape\" , npa_chords % det % detector % shape , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_tedge\" , d_tedge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_redge\" , d_redge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_cent\" , d_cent , dims , error ) !!Close NPA group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) chan_loop : do ichan = 1 , npa_chords % nchan ! Convert to beam grid coordinates call uvw_to_xyz ( a_cent (:, ichan ), xyz_a_cent ) call uvw_to_xyz ( a_redge (:, ichan ), xyz_a_redge ) call uvw_to_xyz ( a_tedge (:, ichan ), xyz_a_tedge ) call uvw_to_xyz ( d_cent (:, ichan ), xyz_d_cent ) call uvw_to_xyz ( d_redge (:, ichan ), xyz_d_redge ) call uvw_to_xyz ( d_tedge (:, ichan ), xyz_d_tedge ) ! Define detector/aperture hh/hw npa_chords % det ( ichan )% detector % hw = norm2 ( xyz_d_redge - xyz_d_cent ) npa_chords % det ( ichan )% aperture % hw = norm2 ( xyz_a_redge - xyz_a_cent ) npa_chords % det ( ichan )% detector % hh = norm2 ( xyz_d_tedge - xyz_d_cent ) npa_chords % det ( ichan )% aperture % hh = norm2 ( xyz_a_tedge - xyz_a_cent ) ! Define detector/aperture origin npa_chords % det ( ichan )% detector % origin = xyz_d_cent npa_chords % det ( ichan )% aperture % origin = xyz_a_cent ! Define detector/aperture basis call plane_basis ( xyz_d_cent , xyz_d_redge , xyz_d_tedge , & npa_chords % det ( ichan )% detector % basis , & npa_chords % det ( ichan )% detector % inv_basis ) call plane_basis ( xyz_a_cent , xyz_a_redge , xyz_a_tedge , & npa_chords % det ( ichan )% aperture % basis , & npa_chords % det ( ichan )% aperture % inv_basis ) enddo chan_loop if ( inputs % verbose . ge . 1 ) write ( * , '(50X,a)' ) \"\" deallocate ( a_cent , a_redge , a_tedge ) deallocate ( d_cent , d_redge , d_tedge ) end subroutine read_npa subroutine read_equilibrium !+ Reads in the interpolation grid, plasma parameters, and fields !+ and stores the quantities in [[libfida:inter_grid]] and [[libfida:equil]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 3 ) :: dims integer :: impc , ic , ir , iz , iphi , it , ind ( 3 ), i type ( LocalProfiles ) :: plasma real ( Float64 ) :: photons real ( Float64 ), dimension ( nlevs ) :: rates , denn , rates_avg real ( Float64 ), dimension ( 3 ) :: vi , random3 integer :: error integer :: n = 50 logical :: path_valid integer , dimension (:,:,:), allocatable :: p_mask , f_mask real ( Float64 ), dimension (:,:,:), allocatable :: denn3d !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % equilibrium_file , H5F_ACC_RDONLY_F , fid , error ) !!Open PLASMA group call h5gopen_f ( fid , \"/plasma\" , gid , error ) !!Read in interpolation grid call h5ltread_dataset_int_scalar_f ( gid , \"/plasma/nr\" , inter_grid % nr , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/plasma/nz\" , inter_grid % nz , error ) call h5ltpath_valid_f ( gid , \"/plasma/nphi\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltread_dataset_int_scalar_f ( gid , \"/plasma/nphi\" , inter_grid % nphi , error ) else inter_grid % nphi = 1 endif inter_grid % dims = [ inter_grid % nr , inter_grid % nz , inter_grid % nphi ] allocate ( inter_grid % r ( inter_grid % nr ), inter_grid % z ( inter_grid % nz ), inter_grid % phi ( inter_grid % nphi )) allocate ( p_mask ( inter_grid % nr , inter_grid % nz , inter_grid % nphi )) allocate ( f_mask ( inter_grid % nr , inter_grid % nz , inter_grid % nphi )) allocate ( denn3d ( inter_grid % nr , inter_grid % nz , inter_grid % nphi )) dims = [ inter_grid % nr , inter_grid % nz , inter_grid % nphi ] call h5ltread_dataset_double_f ( gid , \"/plasma/r\" , inter_grid % r , dims ( 1 : 1 ), error ) call h5ltread_dataset_double_f ( gid , \"/plasma/z\" , inter_grid % z , dims ( 2 : 2 ), error ) if ( path_valid ) then call h5ltread_dataset_double_f ( gid , \"/plasma/phi\" , inter_grid % phi , dims ( 3 : 3 ), error ) else inter_grid % phi = 0.d0 endif inter_grid % dr = abs ( inter_grid % r ( 2 ) - inter_grid % r ( 1 )) inter_grid % dz = abs ( inter_grid % z ( 2 ) - inter_grid % z ( 1 )) inter_grid % da = inter_grid % dr * inter_grid % dz if ( inter_grid % nphi . eq . 1 ) then inter_grid % dphi = 2 * pi else inter_grid % dphi = abs ( inter_grid % phi ( 2 ) - inter_grid % phi ( 1 )) endif inter_grid % dv = inter_grid % dr * inter_grid % dphi * inter_grid % dz inter_grid % ntrack = inter_grid % nr + inter_grid % nz + inter_grid % nphi inter_grid % ngrid = inter_grid % nr * inter_grid % nz * inter_grid % nphi if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Interpolation grid settings ----' write ( * , '(T2,\"Nr: \",i3)' ) inter_grid % nr write ( * , '(T2,\"Nz: \",i3)' ) inter_grid % nz if ( inter_grid % nphi . gt . 1 ) then write ( * , '(T2,\"Nphi: \",i3)' ) inter_grid % nphi endif write ( * , '(T2,\"dA: \", f5.2,\" [cm&#94;2]\")' ) inter_grid % da write ( * , * ) '' endif !!Read in plasma parameters allocate ( equil % plasma ( inter_grid % nr , inter_grid % nz , inter_grid % nphi )) call h5ltread_dataset_double_f ( gid , \"/plasma/dene\" , equil % plasma % dene , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/te\" , equil % plasma % te , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/ti\" , equil % plasma % ti , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/zeff\" , equil % plasma % zeff , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vr\" , equil % plasma % vr , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vt\" , equil % plasma % vt , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vz\" , equil % plasma % vz , dims , error ) call h5ltread_dataset_int_f ( gid , \"/plasma/mask\" , p_mask , dims , error ) impc = inputs % impurity_charge where ( equil % plasma % zeff . lt . 1.0 ) equil % plasma % zeff = 1 endwhere where ( equil % plasma % zeff . gt . impc ) equil % plasma % zeff = impc endwhere where ( equil % plasma % dene . lt . 0.0 ) equil % plasma % dene = 0.0 endwhere where ( equil % plasma % te . lt . 0.0 ) equil % plasma % te = 0.0 endwhere where ( equil % plasma % ti . lt . 0.0 ) equil % plasma % ti = 0.0 endwhere equil % plasma % denimp = (( equil % plasma % zeff - 1.d0 ) / ( impc * ( impc - 1.d0 ))) * equil % plasma % dene equil % plasma % denp = equil % plasma % dene - impc * equil % plasma % denimp call h5ltpath_valid_f ( fid , \"/plasma/denn\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltread_dataset_double_f ( gid , \"/plasma/denn\" , denn3d , dims , error ) where ( denn3d . lt . 0.0 ) denn3d = 0.0 endwhere else if (( inputs % calc_pnpa + inputs % calc_pfida + inputs % calc_cold ). gt . 0 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"READ_EQUILIBRIUM: Cold neutral density was not provided\" write ( * , '(a)' ) \"Continuing without passive calculations\" endif endif inputs % calc_pnpa = 0 inputs % calc_pfida = 0 inputs % calc_cold = 0 endif loop_over_cells : do ic = 1 , inter_grid % nr * inter_grid % nz * inter_grid % nphi call ind2sub ( inter_grid % dims , ic , ind ) ir = ind ( 1 ) ; iz = ind ( 2 ) ; iphi = ind ( 3 ) if ( p_mask ( ir , iz , iphi ). lt . 0.5 ) cycle loop_over_cells if ( denn3d ( ir , iz , iphi ). le . 0.0 ) cycle loop_over_cells plasma = equil % plasma ( ir , iz , iphi ) plasma % vrot = [ plasma % vr , plasma % vt , plasma % vz ] plasma % in_plasma = . True . rates_avg = 0.0 do it = 1 , n rates = 0.0 rates ( 1 ) = 1.d19 call randn ( random3 ) vi = plasma % vrot + sqrt ( plasma % ti * 0.5 / ( v2_to_E_per_amu * inputs % ai )) * random3 call colrad ( plasma , thermal_ion , vi , 1.0d-7 , rates , denn , photons ) rates_avg = rates_avg + rates / n enddo if ( sum ( rates_avg ). le . 0.0 ) cycle loop_over_cells equil % plasma ( ir , iz , iphi )% denn = denn3d ( ir , iz , iphi ) * ( rates_avg ) / sum ( rates_avg ) enddo loop_over_cells !!Close PLASMA group call h5gclose_f ( gid , error ) !!Open FIELDS group call h5gopen_f ( fid , \"/fields\" , gid , error ) allocate ( equil % fields ( inter_grid % nr , inter_grid % nz , inter_grid % nphi )) !!Read in electromagnetic fields call h5ltread_dataset_double_f ( gid , \"/fields/br\" , equil % fields % br , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/bt\" , equil % fields % bt , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/bz\" , equil % fields % bz , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/er\" , equil % fields % er , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/et\" , equil % fields % et , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/ez\" , equil % fields % ez , dims , error ) call h5ltread_dataset_int_f ( gid , \"/fields/mask\" , f_mask , dims , error ) !!Calculate B field derivatives call deriv ( inter_grid % r , inter_grid % z , inter_grid % phi , equil % fields % br , & equil % fields % dbr_dr , equil % fields % dbr_dz , equil % fields % dbr_dphi ) call deriv ( inter_grid % r , inter_grid % z , inter_grid % phi , equil % fields % bt , & equil % fields % dbt_dr , equil % fields % dbt_dz , equil % fields % dbt_dphi ) call deriv ( inter_grid % r , inter_grid % z , inter_grid % phi , equil % fields % bz , & equil % fields % dbz_dr , equil % fields % dbz_dz , equil % fields % dbz_dphi ) !!Close FIELDS group call h5gclose_f ( gid , error ) !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) allocate ( equil % mask ( inter_grid % nr , inter_grid % nz , inter_grid % nphi )) equil % mask = 0.d0 where (( p_mask . eq . 1 ). and .( f_mask . eq . 1 )) equil % mask = 1.d0 if ( sum ( equil % mask ). le . 0.d0 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"READ_EQUILIBRIUM: Plasma and/or fields are not well defined anywhere\" endif stop endif end subroutine read_equilibrium subroutine read_f ( fid , error ) !+ Reads in the fast-ion distribution function and stores the quantities in [[libfida:fbm]] integer ( HID_T ), intent ( inout ) :: fid !+ HDF5 file ID integer , intent ( out ) :: error !+ Error code integer ( HSIZE_T ), dimension ( 5 ) :: dims real ( Float64 ) :: denp_tot integer :: ir logical :: path_valid if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Fast-ion distribution settings ----' endif call h5ltread_dataset_int_scalar_f ( fid , \"/nenergy\" , fbm % nenergy , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/npitch\" , fbm % npitch , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/nr\" , fbm % nr , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/nz\" , fbm % nz , error ) call h5ltpath_valid_f ( fid , \"/nphi\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltread_dataset_int_scalar_f ( fid , \"/nphi\" , fbm % nphi , error ) else fbm % nphi = 1 endif if ((( fbm % nr . ne . inter_grid % nr ). or .( fbm % nz . ne . inter_grid % nz )). or .( fbm % nphi . ne . inter_grid % nphi )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"READ_F: Distribution file has incompatable grid dimensions\" endif stop endif if ( fbm % nphi . eq . 1 ) then allocate ( fbm % energy ( fbm % nenergy ), fbm % pitch ( fbm % npitch ), fbm % r ( fbm % nr ), fbm % z ( fbm % nz ), fbm % phi ( 1 )) allocate ( fbm % denf ( fbm % nr , fbm % nz , 1 )) allocate ( fbm % f ( fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz , 1 )) else allocate ( fbm % energy ( fbm % nenergy ), fbm % pitch ( fbm % npitch ), fbm % r ( fbm % nr ), fbm % z ( fbm % nz ), fbm % phi ( fbm % nphi )) allocate ( fbm % denf ( fbm % nr , fbm % nz , fbm % nphi )) allocate ( fbm % f ( fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz , fbm % nphi )) endif if ( fbm % nphi . eq . 1 ) then dims = [ fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz , 1 ] call h5ltread_dataset_double_f ( fid , \"/denf\" , fbm % denf , dims ( 3 : 4 ), error ) call h5ltread_dataset_double_f ( fid , \"/f\" , fbm % f , dims ( 1 : 4 ), error ) else dims = [ fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz , fbm % nphi ] call h5ltread_dataset_double_f ( fid , \"/denf\" , fbm % denf , dims ( 3 : 5 ), error ) call h5ltread_dataset_double_f ( fid , \"/f\" , fbm % f , dims ( 1 : 5 ), error ) endif call h5ltread_dataset_double_f ( fid , \"/energy\" , fbm % energy , dims ( 1 : 1 ), error ) call h5ltread_dataset_double_f ( fid , \"/pitch\" , fbm % pitch , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( fid , \"/r\" , fbm % r , dims ( 3 : 3 ), error ) call h5ltread_dataset_double_f ( fid , \"/z\" , fbm % z , dims ( 4 : 4 ), error ) call h5ltpath_valid_f ( fid , \"/phi\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltread_dataset_double_f ( fid , \"/phi\" , fbm % phi , dims ( 5 : 5 ), error ) else fbm % phi = 0.d0 endif equil % plasma % denf = fbm % denf fbm % dE = abs ( fbm % energy ( 2 ) - fbm % energy ( 1 )) fbm % dp = abs ( fbm % pitch ( 2 ) - fbm % pitch ( 1 )) fbm % dr = abs ( fbm % r ( 2 ) - fbm % r ( 1 )) fbm % dz = abs ( fbm % z ( 2 ) - fbm % z ( 1 )) if ( fbm % nphi . eq . 1 ) then fbm % dphi = 2 * pi else fbm % dphi = abs ( fbm % phi ( 2 ) - fbm % phi ( 1 )) endif fbm % emin = minval ( fbm % energy , 1 ) fbm % emax = maxval ( fbm % energy , 1 ) fbm % e_range = fbm % emax - fbm % emin fbm % pmin = minval ( fbm % pitch , 1 ) fbm % pmax = maxval ( fbm % pitch , 1 ) fbm % p_range = fbm % pmax - fbm % pmin fbm % rmin = minval ( fbm % r , 1 ) fbm % rmax = maxval ( fbm % r , 1 ) fbm % r_range = fbm % rmax - fbm % rmin fbm % zmin = minval ( fbm % z , 1 ) fbm % zmax = maxval ( fbm % z , 1 ) fbm % z_range = fbm % zmax - fbm % zmin fbm % phimin = minval ( fbm % phi , 1 ) fbm % phimax = maxval ( fbm % phi , 1 ) fbm % phi_range = fbm % phimax - fbm % phimin denp_tot = 0.0 do ir = 1 , fbm % nr fbm % n_tot = fbm % n_tot + fbm % dphi * fbm % dr * fbm % dz * sum ( fbm % denf ( ir ,:,:)) * fbm % r ( ir ) denp_tot = denp_tot + fbm % dphi * fbm % dr * fbm % dz * sum ( equil % plasma ( ir ,:,:)% denp ) * fbm % r ( ir ) enddo if ( fbm % n_tot . ge . denp_tot ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,\" (\",ES10.3,\" >=\",ES10.3,\")\")' ) & \"READ_F: The total of number of fast ions exceeded the total number of thermal ions.\" , & fbm % n_tot , denp_tot write ( * , '(a)' ) \"This is usually caused by zeff being incorrect.\" endif stop endif if ( inputs % verbose . ge . 1 ) then if ( fbm % nphi . gt . 1 ) then write ( * , '(T2,\"Distribution type: \",a)' ) \"Non-axisymmetric Fast-ion Density Function F(energy,pitch,R,Z,Phi)\" else write ( * , '(T2,\"Distribution type: \",a)' ) \"Axisymmetric Fast-ion Density Function F(energy,pitch,R,Z)\" endif write ( * , '(T2,\"Nenergy = \",i3)' ) fbm % nenergy write ( * , '(T2,\"Npitch  = \",i3)' ) fbm % npitch write ( * , '(T2,\"Nr  = \",i3)' ) fbm % nr write ( * , '(T2,\"Nz  = \",i3)' ) fbm % nz if ( fbm % nphi . gt . 1 ) then write ( * , '(T2,\"Nphi  = \",i3)' ) fbm % nphi endif write ( * , '(T2,\"Energy range = [\",f5.2,\",\",f6.2,\"]\")' ) fbm % emin , fbm % emax write ( * , '(T2,\"Pitch  range = [\",f5.2,\",\",f5.2,\"]\")' ) fbm % pmin , fbm % pmax write ( * , '(T2,\"R  range = [\",f6.2,\",\",f6.2,\"]\")' ) fbm % rmin , fbm % rmax write ( * , '(T2,\"Z  range = [\",f7.2,\",\",f6.2,\"]\")' ) fbm % zmin , fbm % zmax if ( fbm % nphi . gt . 1 ) then write ( * , '(T2,\"Phi  range = [\",f5.2,\",\",f5.2,\"]\")' ) fbm % phimin , fbm % phimax endif write ( * , '(T2,\"Ntotal = \",ES10.3)' ) fbm % n_tot write ( * , * ) '' endif end subroutine read_f subroutine read_mc ( fid , error ) !+ Reads in a MC particle fast-ion distribution and puts them in [[libfida:particles]] integer ( HID_T ), intent ( inout ) :: fid !+ HDF5 file ID integer , intent ( out ) :: error !+ Error code integer ( HSIZE_T ), dimension ( 1 ) :: dims integer ( Int32 ) :: i , j , ii , ir , iz , iphi , nphi real ( Float64 ) :: phi , beam_grid_phi_enter , beam_grid_phi_exit , delta_phi , xp , yp , zp real ( Float64 ), dimension ( 3 ) :: uvw , xyz , ri , vi , e1_xyz , e2_xyz , C_xyz , dum real ( Float64 ), dimension (:), allocatable :: weight type ( LocalEMFields ) :: fields integer :: cnt , num logical :: inp , path_valid character ( len = 50 ) :: dist_type_name = '' if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Fast-ion distribution settings ----' endif call h5ltread_dataset_int_scalar_f ( fid , \"/nparticle\" , particles % nparticle , error ) !!ALLOCATE SPACE allocate ( particles % fast_ion ( particles % nparticle )) allocate ( weight ( particles % nparticle )) dims ( 1 ) = particles % nparticle call h5ltread_dataset_double_f ( fid , \"/r\" , particles % fast_ion % r , dims , error ) call h5ltread_dataset_double_f ( fid , \"/z\" , particles % fast_ion % z , dims , error ) call h5ltpath_valid_f ( fid , \"/phi\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltread_dataset_double_f ( fid , \"/phi\" , particles % fast_ion % phi , dims , error ) particles % axisym = . False . endif call h5ltread_dataset_int_f ( fid , \"/class\" , particles % fast_ion % class , dims , error ) if ( any ( particles % fast_ion % class . le . 0 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_MC: Orbit class ID must be greater than 0' endif stop endif if ( inputs % split . ge . 1 ) then call h5ltread_dataset_int_scalar_f ( fid , \"/nclass\" , particles % nclass , error ) if ( any ( particles % fast_ion % class . gt . particles % nclass )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_MC: Orbit class ID greater than the number of classes' endif stop endif endif if ( inputs % dist_type . eq . 2 ) then if ( particles % axisym ) then dist_type_name = \"Axisymmetric Guiding Center Monte Carlo\" else dist_type_name = \"Non-axisymmetric Guiding Center Monte Carlo\" endif call h5ltread_dataset_double_f ( fid , \"/energy\" , particles % fast_ion % energy , dims , error ) call h5ltread_dataset_double_f ( fid , \"/pitch\" , particles % fast_ion % pitch , dims , error ) particles % fast_ion % vabs = sqrt ( particles % fast_ion % energy / ( v2_to_E_per_amu * inputs % ab )) else if ( particles % axisym ) then dist_type_name = \"Axisymmetric Full Orbit Monte Carlo\" else dist_type_name = \"Non-axisymmetric Full Orbit Monte Carlo\" endif call h5ltread_dataset_double_f ( fid , \"/vr\" , particles % fast_ion % vr , dims , error ) call h5ltread_dataset_double_f ( fid , \"/vt\" , particles % fast_ion % vt , dims , error ) call h5ltread_dataset_double_f ( fid , \"/vz\" , particles % fast_ion % vz , dims , error ) particles % fast_ion % vabs = sqrt ( particles % fast_ion % vr ** 2 + & particles % fast_ion % vt ** 2 + & particles % fast_ion % vz ** 2 ) particles % fast_ion % energy = v2_to_E_per_amu * inputs % ab * particles % fast_ion % vabs ** 2 endif call h5ltread_dataset_double_f ( fid , \"/weight\" , weight , dims , error ) cnt = 0 e1_xyz = matmul ( beam_grid % inv_basis ,[ 1.0 , 0.0 , 0.0 ]) e2_xyz = matmul ( beam_grid % inv_basis ,[ 0.0 , 1.0 , 0.0 ]) !$OMP PARALLEL DO schedule(guided) private(i,ii,j,ir,iz,iphi,fields,uvw,phi,ri,vi, & !$OMP& delta_phi,beam_grid_phi_enter,beam_grid_phi_exit,C_xyz,xyz,xp,yp,zp,dum,inp) particle_loop : do i = 1 , particles % nparticle if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt / real ( particles % nparticle ) * 100 , char ( 13 ) endif if ( particles % axisym ) then uvw = [ particles % fast_ion ( i )% r , 0.d0 , particles % fast_ion ( i )% z ] else xp = particles % fast_ion ( i )% r * cos ( particles % fast_ion ( i )% phi ) yp = particles % fast_ion ( i )% r * sin ( particles % fast_ion ( i )% phi ) zp = particles % fast_ion ( i )% z uvw = [ xp , yp , zp ] endif call in_plasma ( uvw , inp , input_coords = 1 ) if (. not . inp ) cycle particle_loop if ( particles % axisym ) then beam_grid_phi_enter = 0.0 beam_grid_phi_exit = 0.0 dum = [ 0.d0 , 0.d0 , particles % fast_ion ( i )% z ] call uvw_to_xyz ( dum , C_xyz ) call circle_grid_intersect ( C_xyz , e1_xyz , e2_xyz , particles % fast_ion ( i )% r , beam_grid_phi_enter , beam_grid_phi_exit ) delta_phi = beam_grid_phi_exit - beam_grid_phi_enter if ( delta_phi . gt . 0 ) then particles % fast_ion ( i )% beam_grid_cross_grid = . True . else particles % fast_ion ( i )% beam_grid_cross_grid = . False . delta_phi = 2 * pi endif particles % fast_ion ( i )% beam_grid_phi_enter = beam_grid_phi_enter else delta_phi = 2 * pi call uvw_to_xyz ( uvw , xyz ) particles % fast_ion ( i )% beam_grid_cross_grid = in_grid ( xyz ) particles % fast_ion ( i )% beam_grid_phi_enter = particles % fast_ion ( i )% phi endif particles % fast_ion ( i )% delta_phi = delta_phi particles % fast_ion ( i )% weight = weight ( i ) ir = minloc ( abs ( inter_grid % r - particles % fast_ion ( i )% r ), 1 ) iphi = minloc ( abs ( inter_grid % phi - particles % fast_ion ( i )% phi ), 1 ) iz = minloc ( abs ( inter_grid % z - particles % fast_ion ( i )% z ), 1 ) !$OMP ATOMIC UPDATE equil % plasma ( ir , iz , iphi )% denf = equil % plasma ( ir , iz , iphi )% denf + weight ( i ) / & ( particles % fast_ion ( i )% r * inter_grid % dv ) !$OMP END ATOMIC cnt = cnt + 1 enddo particle_loop !$OMP END PARALLEL DO num = count ( particles % fast_ion % beam_grid_cross_grid ) if ( num . le . 0 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_MC: No mc particles in beam grid' endif stop endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Distribution type: \",a)' ) dist_type_name write ( * , '(T2,\"Number of mc particles: \",i10)' ) particles % nparticle write ( * , '(T2,\"Number of orbit classes: \",i6)' ) particles % nclass write ( * , * ) '' endif end subroutine read_mc subroutine read_distribution !+ Reads in the fast-ion distribution integer ( HID_T ) :: fid integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % distribution_file , H5F_ACC_RDONLY_F , fid , error ) !!Get distribution type call h5ltread_dataset_int_scalar_f ( fid , \"/type\" , inputs % dist_type , error ) if ( inputs % dist_type . eq . 1 ) then call read_f ( fid , error ) else !2 or 3 call read_mc ( fid , error ) endif !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) end subroutine read_distribution subroutine read_atomic_cross ( fid , grp , cross ) !+ Reads in a cross section table from file !+ and puts it into a [[AtomicCrossSection]] type integer ( HID_T ), intent ( in ) :: fid !+ HDF5 file ID character ( len =* ), intent ( in ) :: grp !+ HDF5 group to read from type ( AtomicCrossSection ), intent ( inout ) :: cross !+ Atomic cross section integer ( HSIZE_T ), dimension ( 3 ) :: dim3 real ( Float64 ) :: emin , emax , rmin integer :: i , n_max , m_max , error real ( Float64 ), dimension (:,:,:), allocatable :: dummy3 logical :: path_valid call h5ltpath_valid_f ( fid , grp , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_ATOMIC_CROSS: Unknown atomic interaction: ' , trim ( grp ) endif stop endif call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , cross % nenergy , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/m_max\" , m_max , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , cross % dlogE , error ) cross % logemin = log10 ( emin ) cross % logemax = log10 ( emax ) allocate ( dummy3 ( n_max , m_max , cross % nenergy )) allocate ( cross % log_cross ( cross % m_max , cross % n_max , cross % nenergy )) dim3 = [ n_max , m_max , cross % nenergy ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy3 , dim3 , error ) rmin = minval ( dummy3 , dummy3 . gt . 0.d0 ) where ( dummy3 . le . 0.0 ) dummy3 = 0.9 * rmin end where cross % minlog_cross = log10 ( rmin ) do i = 1 , cross % nenergy cross % log_cross (:,:, i ) = log10 ( transpose ( dummy3 ( 1 : nlevs , 1 : nlevs , i ))) enddo deallocate ( dummy3 ) end subroutine read_atomic_cross subroutine read_atomic_rate ( fid , grp , b_amu , t_amu , rates ) !+ Reads in a atomic rate table from file !+ and puts it into a [[AtomicRates]] type integer ( HID_T ), intent ( in ) :: fid !+ HDF5 file ID character ( len =* ), intent ( in ) :: grp !+ HDF5 group to read from real ( Float64 ), dimension ( 2 ), intent ( in ) :: b_amu !+ Atomic masses of \"beam\" species (beam ion and thermal ion) real ( Float64 ), intent ( in ) :: t_amu !+ Atomic mass of \"target\" species (thermal ion) type ( AtomicRates ), intent ( inout ) :: rates !+ Atomic reaction rates integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 logical :: path_valid integer :: i , j , n , n_max , m_max , error integer :: n_bt_amu , tt_ind , bt_ind , drank real ( Float64 ) :: emin , emax , tmin , tmax , rmin real ( Float64 ) :: bt_min , tt_min , tt_dum , bt_dum real ( Float64 ), dimension ( 2 ) :: bt_amu , tt_amu real ( Float64 ), dimension (:,:), allocatable :: dummy2 real ( Float64 ), dimension (:,:,:,:), allocatable :: dummy4 real ( Float64 ), dimension (:,:,:,:,:), allocatable :: dummy5 call h5ltpath_valid_f ( fid , grp , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_ATOMIC_RATE: Unknown atomic interaction: ' , trim ( grp ) endif stop endif call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_bt_amu\" , n_bt_amu , error ) allocate ( dummy2 ( 2 , n_bt_amu )) dim2 = [ 2 , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/bt_amu\" , dummy2 , dim2 , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/m_max\" , m_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , rates % nenergy , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , rates % dlogE , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/ntemp\" , rates % ntemp , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmin\" , tmin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmax\" , tmax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogT\" , rates % dlogT , error ) rates % logemin = log10 ( emin ) rates % logemax = log10 ( emax ) rates % logtmin = log10 ( tmin ) rates % logtmax = log10 ( tmax ) bt_ind = 1 tt_ind = 1 bt_amu = [ b_amu ( 1 ), t_amu ] tt_amu = [ b_amu ( 2 ), t_amu ] bt_min = norm2 ( bt_amu - dummy2 (:, 1 )) tt_min = norm2 ( tt_amu - dummy2 (:, 1 )) do i = 2 , n_bt_amu bt_dum = norm2 ( bt_amu - dummy2 (:, i )) tt_dum = norm2 ( tt_amu - dummy2 (:, i )) if ( bt_dum . lt . bt_min ) then bt_min = bt_dum bt_ind = i endif if ( tt_dum . lt . tt_min ) then tt_min = tt_dum tt_ind = i endif enddo rates % ab ( 1 ) = dummy2 ( 1 , bt_ind ) rates % ab ( 2 ) = dummy2 ( 1 , tt_ind ) deallocate ( dummy2 ) allocate ( rates % log_rate (& rates % m_max , & rates % n_max , & rates % nenergy , & rates % ntemp , 2 )) rates % log_rate = 0.d0 !!Read CX call h5ltpath_valid_f ( fid , grp // \"/cx\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltget_dataset_ndims_f ( fid , grp // \"/cx\" , drank , error ) if ( drank . eq . 5 ) then allocate ( dummy5 ( n_max , m_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim5 = [ n_max , m_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy5 , dim5 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy rates % log_rate (:,:, i , j , 1 ) = transpose ( dummy5 ( 1 : nlevs , 1 : nlevs , i , j , bt_ind )) rates % log_rate (:,:, i , j , 2 ) = transpose ( dummy5 ( 1 : nlevs , 1 : nlevs , i , j , tt_ind )) enddo enddo deallocate ( dummy5 ) else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_ATOMIC_RATE: Unsupported atomic interaction: ' , trim ( grp ) endif stop endif endif rmin = minval ( rates % log_rate , rates % log_rate . gt . 0.d0 ) where ( rates % log_rate . le . 0.d0 ) rates % log_rate = 0.9 * rmin end where rates % minlog_rate = log10 ( rmin ) rates % log_rate = log10 ( rates % log_rate ) end subroutine read_atomic_rate subroutine read_atomic_transitions ( fid , grp , b_amu , t_amu , rates ) !+ Reads in a atomic transitions table from file !+ and puts it into a [[AtomicTransitions]] type integer ( HID_T ), intent ( in ) :: fid !+ HDF5 file ID character ( len =* ), intent ( in ) :: grp !+ HDF5 group to read from real ( Float64 ), dimension ( 2 ), intent ( in ) :: b_amu !+ Atomic masses of \"beam\" species (beam ion and thermal ion) real ( Float64 ), intent ( in ) :: t_amu !+ Atomic mass of \"target\" species (thermal ion) type ( AtomicTransitions ), intent ( inout ) :: rates !+ Atomic transitions integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 logical :: path_valid integer :: i , j , n , n_max , m_max , error integer :: n_bt_amu , tt_ind , bt_ind , drank real ( Float64 ) :: emin , emax , tmin , tmax , rmin real ( Float64 ) :: bt_min , tt_min , tt_dum , bt_dum real ( Float64 ), dimension ( 2 ) :: bt_amu , tt_amu real ( Float64 ), dimension (:,:), allocatable :: dummy2 real ( Float64 ), dimension (:,:,:,:), allocatable :: dummy4 real ( Float64 ), dimension (:,:,:,:,:), allocatable :: dummy5 call h5ltpath_valid_f ( fid , grp , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_ATOMIC_TRANSITIONS: Unknown atomic interaction: ' , trim ( grp ) endif stop endif call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_bt_amu\" , n_bt_amu , error ) allocate ( dummy2 ( 2 , n_bt_amu )) dim2 = [ 2 , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/bt_amu\" , dummy2 , dim2 , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/m_max\" , m_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , rates % nenergy , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , rates % dlogE , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/ntemp\" , rates % ntemp , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmin\" , tmin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmax\" , tmax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogT\" , rates % dlogT , error ) rates % logemin = log10 ( emin ) rates % logemax = log10 ( emax ) rates % logtmin = log10 ( tmin ) rates % logtmax = log10 ( tmax ) bt_ind = 1 tt_ind = 1 bt_amu = [ b_amu ( 1 ), t_amu ] tt_amu = [ b_amu ( 2 ), t_amu ] bt_min = norm2 ( bt_amu - dummy2 (:, 1 )) tt_min = norm2 ( tt_amu - dummy2 (:, 1 )) do i = 2 , n_bt_amu bt_dum = norm2 ( bt_amu - dummy2 (:, i )) tt_dum = norm2 ( tt_amu - dummy2 (:, i )) if ( bt_dum . lt . bt_min ) then bt_min = bt_dum bt_ind = i endif if ( tt_dum . lt . tt_min ) then tt_min = tt_dum tt_ind = i endif enddo rates % ab ( 1 ) = dummy2 ( 1 , bt_ind ) rates % ab ( 2 ) = dummy2 ( 1 , tt_ind ) deallocate ( dummy2 ) allocate ( rates % log_pop (& rates % m_max , & rates % n_max , & rates % nenergy , & rates % ntemp , 2 )) allocate ( rates % log_depop (& rates % n_max , & rates % nenergy , & rates % ntemp , 2 )) rates % log_pop = 0.d0 rates % log_depop = 0.d0 !!Read CX call h5ltpath_valid_f ( fid , grp // \"/cx\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltget_dataset_ndims_f ( fid , grp // \"/cx\" , drank , error ) if ( drank . eq . 4 ) then allocate ( dummy4 ( n_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim4 = [ n_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy4 , dim4 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = dummy4 ( n , i , j , bt_ind ) rates % log_depop ( n , i , j , 2 ) = dummy4 ( n , i , j , tt_ind ) enddo enddo enddo deallocate ( dummy4 ) endif if ( drank . eq . 5 ) then allocate ( dummy5 ( n_max , m_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim5 = [ n_max , m_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy5 , dim5 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = sum ( dummy5 ( n ,:, i , j , bt_ind )) rates % log_depop ( n , i , j , 2 ) = sum ( dummy5 ( n ,:, i , j , tt_ind )) enddo enddo enddo deallocate ( dummy5 ) endif endif !!Read ionization call h5ltpath_valid_f ( fid , grp // \"/ionization\" , . True ., path_valid , error ) if ( path_valid ) then allocate ( dummy4 ( n_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim4 = [ n_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/ionization\" , dummy4 , dim4 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = rates % log_depop ( n , i , j , 1 ) + & dummy4 ( n , i , j , bt_ind ) rates % log_depop ( n , i , j , 2 ) = rates % log_depop ( n , i , j , 2 ) + & dummy4 ( n , i , j , tt_ind ) enddo enddo enddo deallocate ( dummy4 ) endif !!Read excitation call h5ltpath_valid_f ( fid , grp // \"/excitation\" , . True ., path_valid , error ) if ( path_valid ) then allocate ( dummy5 ( n_max , m_max ,& rates % nenergy , & rates % ntemp , n_bt_amu )) dim5 = [ n_max , m_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/excitation\" , dummy5 , dim5 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy rates % log_pop (:,:, i , j , 1 ) = transpose ( dummy5 ( 1 : nlevs , 1 : nlevs , i , j , bt_ind )) rates % log_pop (:,:, i , j , 2 ) = transpose ( dummy5 ( 1 : nlevs , 1 : nlevs , i , j , tt_ind )) do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = rates % log_depop ( n , i , j , 1 ) + & sum ( dummy5 ( n ,:, i , j , bt_ind )) rates % log_depop ( n , i , j , 2 ) = rates % log_depop ( n , i , j , 2 ) + & sum ( dummy5 ( n ,:, i , j , tt_ind )) enddo enddo enddo deallocate ( dummy5 ) endif rmin = minval ( rates % log_depop , rates % log_depop . gt . 0.d0 ) where ( rates % log_depop . le . 0.d0 ) rates % log_depop = 0.9 * rmin end where rates % minlog_depop = log10 ( rmin ) rates % log_depop = log10 ( rates % log_depop ) rmin = minval ( rates % log_pop , rates % log_pop . gt . 0.d0 ) where ( rates % log_pop . le . 0.d0 ) rates % log_pop = 0.9 * rmin end where rates % minlog_pop = log10 ( rmin ) rates % log_pop = log10 ( rates % log_pop ) end subroutine read_atomic_transitions subroutine read_nuclear_rates ( fid , grp , rates ) !+ Reads in a nuclear reaction rates table from file !+ and puts it into a [[NuclearRates]] type integer ( HID_T ), intent ( in ) :: fid !+ HDF5 file ID character ( len =* ), intent ( in ) :: grp !+ HDF5 group to read from type ( NuclearRates ), intent ( inout ) :: rates !+ Atomic reaction rates integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 logical :: path_valid , err integer :: i , j , error real ( Float64 ) :: emin , emax , tmin , tmax , rmin err = . False . call h5ltpath_valid_f ( fid , grp , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_NUCLEAR_RATES: Unknown nuclear interaction: ' , trim ( grp ) write ( * , '(a)' ) 'Continuing without neutron calculation' endif inputs % calc_neutron = 0 return endif dim1 = [ 2 ] call h5ltread_dataset_double_f ( fid , grp // \"/bt_amu\" , rates % bt_amu , dim1 , error ) if ( abs ( inputs % ab - rates % bt_amu ( 1 )). gt . 0.2 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,f6.3,a,f6.3,a)' ) 'READ_NUCLEAR_RATES: Unexpected beam species mass. Expected ' ,& rates % bt_amu ( 1 ), ' amu got ' , inputs % ab , ' amu' endif err = . True . endif if ( abs ( inputs % ai - rates % bt_amu ( 2 )). gt . 0.2 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,f6.3,a,f6.3,a)' ) 'READ_NUCLEAR_RATES: Unexpected thermal species mass. Expected ' ,& rates % bt_amu ( 2 ), ' amu got ' , inputs % ai , ' amu' endif err = . True . endif if ( err ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'Continuing without neutron calculation' endif inputs % calc_neutron = 0 return endif call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nbranch\" , rates % nbranch , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , rates % nenergy , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , rates % dlogE , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/ntemp\" , rates % ntemp , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmin\" , tmin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmax\" , tmax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogT\" , rates % dlogT , error ) rates % logemin = log10 ( emin ) rates % logemax = log10 ( emax ) rates % logtmin = log10 ( tmin ) rates % logtmax = log10 ( tmax ) allocate ( rates % log_rate ( rates % nenergy , & rates % ntemp , & rates % nbranch )) dim3 = [ rates % nenergy , rates % ntemp , rates % nbranch ] call h5ltread_dataset_double_f ( fid , grp // \"/fusion\" , rates % log_rate , dim3 , error ) rmin = minval ( rates % log_rate , rates % log_rate . gt . 0.d0 ) where ( rates % log_rate . le . 0.d0 ) rates % log_rate = 0.9 * rmin end where rates % minlog_rate = log10 ( rmin ) rates % log_rate = log10 ( rates % log_rate ) end subroutine read_nuclear_rates subroutine read_tables !+ Reads in atomic tables from file and stores them in [[libfida:tables]] integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: error integer :: n_max , m_max character ( len = 4 ) :: impname real ( Float64 ) :: imp_amu real ( Float64 ), dimension ( 2 ) :: b_amu real ( Float64 ), dimension (:,:), allocatable :: dummy2 if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Atomic tables settings ----\" endif !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % tables_file , H5F_ACC_RDONLY_F , fid , error ) !!Read Hydrogen-Hydrogen CX Cross Sections call read_atomic_cross ( fid , \"/cross/H_H\" , tables % H_H_cx_cross ) !!Read Hydrogen-Hydrogen CX Rates b_amu = [ inputs % ab , inputs % ai ] call read_atomic_rate ( fid , \"/rates/H_H\" , b_amu , inputs % ai , tables % H_H_cx_rate ) !!Read Hydrogen-Hydrogen Transitions call read_atomic_transitions ( fid , \"/rates/H_H\" , b_amu , inputs % ai , tables % H_H ) inputs % ab = tables % H_H % ab ( 1 ) inputs % ai = tables % H_H % ab ( 2 ) !!Read Hydrogen-Electron Transitions call read_atomic_transitions ( fid , \"/rates/H_e\" , b_amu , e_amu , tables % H_e ) !!Read Hydrogen-Impurity Transitions impname = '' select case ( inputs % impurity_charge ) case ( 5 ) impname = \"B5\" imp_amu = B5_amu case ( 6 ) impname = \"C6\" imp_amu = C6_amu case DEFAULT impname = \"Aq\" imp_amu = 2.d0 * inputs % impurity_charge end select call read_atomic_transitions ( fid , \"/rates/H_\" // trim ( adjustl ( impname )), b_amu , imp_amu , tables % H_Aq ) !!Read Einstein coefficients call h5ltread_dataset_int_scalar_f ( fid , \"/rates/spontaneous/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/rates/spontaneous/m_max\" , m_max , error ) allocate ( dummy2 ( n_max , m_max )) dim2 = [ n_max , m_max ] call h5ltread_dataset_double_f ( fid , \"/rates/spontaneous/einstein\" , dummy2 , dim2 , error ) tables % einstein (:,:) = transpose ( dummy2 ( 1 : nlevs , 1 : nlevs )) deallocate ( dummy2 ) !!Read nuclear Deuterium-Deuterium rates if ( inputs % calc_neutron . ge . 1 ) then call read_nuclear_rates ( fid , \"/rates/D_D\" , tables % D_D ) endif !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Maximum n/m: \",i2)' ) nlevs write ( * , '(T2,\"Beam/Fast-ion mass: \",f6.3,\" [amu]\")' ) inputs % ab write ( * , '(T2,\"Thermal/Bulk-ion mass: \",f6.3,\" [amu]\")' ) inputs % ai write ( * , '(T2,\"Impurity mass: \",f6.3,\" [amu]\")' ) imp_amu write ( * , * ) '' endif end subroutine read_tables subroutine write_beam_grid ( id , error ) !+ Write [[libfida:beam_grid]] to an HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file ID integer , intent ( out ) :: error !+ Error code integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 3 ) :: dims real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: u_grid , v_grid , w_grid real ( Float64 ) :: xyz ( 3 ), uvw ( 3 ) integer :: i , j , k !Create uvw grids do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx xyz = [ beam_grid % xc ( i ), & beam_grid % yc ( j ), & beam_grid % zc ( k )] call xyz_to_uvw ( xyz , uvw ) u_grid ( i , j , k ) = uvw ( 1 ) v_grid ( i , j , k ) = uvw ( 2 ) w_grid ( i , j , k ) = uvw ( 3 ) enddo enddo enddo !Create grid group call h5gcreate_f ( id , \"grid\" , gid , error ) !Write variables dims ( 1 ) = 1 call h5ltmake_dataset_int_f ( gid , \"nx\" , 0 , dims ( 1 : 1 ), [ beam_grid % nx ], error ) call h5ltmake_dataset_int_f ( gid , \"ny\" , 0 , dims ( 1 : 1 ), [ beam_grid % ny ], error ) call h5ltmake_dataset_int_f ( gid , \"nz\" , 0 , dims ( 1 : 1 ), [ beam_grid % nz ], error ) dims = [ beam_grid % nx , beam_grid % ny , beam_grid % nz ] call h5ltmake_compressed_dataset_double_f ( gid , \"x\" , 1 , dims ( 1 : 1 ), beam_grid % xc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"y\" , 1 , dims ( 2 : 2 ), beam_grid % yc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"z\" , 1 , dims ( 3 : 3 ), beam_grid % zc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"x_grid\" , 3 , dims , u_grid , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"y_grid\" , 3 , dims , v_grid , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"z_grid\" , 3 , dims , w_grid , error ) !Write attributes call h5ltset_attribute_string_f ( gid , \"nx\" , \"description\" , & \"Number of cells in the X direction\" , error ) call h5ltset_attribute_string_f ( gid , \"ny\" , \"description\" , & \"Number of cells in the Y direction\" , error ) call h5ltset_attribute_string_f ( gid , \"nz\" , \"description\" , & \"Number of cells in the Z direction\" , error ) call h5ltset_attribute_string_f ( gid , \"x\" , \"description\" , & \"X value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"x\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"y\" , \"description\" , & \"Y value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"y\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"z\" , \"description\" , & \"Z value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"z\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"x_grid\" , \"description\" , & \"X value of cell center in machine coordinates: x_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"x_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"y_grid\" , \"description\" , & \"Y value of cell center in machine coordinates: y_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"y_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"z_grid\" , \"description\" , & \"Z value of cell center in machine coordinates: z_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"z_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( id , \"grid\" , \"coordinate_system\" , & \"Right-handed cartesian\" , error ) !Close grid group call h5gclose_f ( gid , error ) end subroutine write_beam_grid subroutine write_birth_profile !+ Writes [[libfida:birth]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error , i , c , npart , start_index , end_index character ( charlim ) :: filename type ( LocalEMFields ) :: fields type ( BirthParticle ) :: part real ( Float64 ), dimension (:,:), allocatable :: ri , ri_gc real ( Float64 ), dimension (:,:), allocatable :: vi real ( Float64 ), dimension (:), allocatable :: energy , pitch , weight integer , dimension (:,:), allocatable :: inds integer , dimension (:), allocatable :: neut_types real ( Float64 ), dimension ( 3 ) :: xyz , v_xyz , uvw , v_uvw , r_gyro , uvw_gc logical :: do_write #ifdef _MPI integer :: rank integer , dimension (:), allocatable :: npart_image #endif npart = birth % cnt - 1 #ifdef _MPI call parallel_sum ( npart ) #endif allocate ( ri ( 3 , npart )) allocate ( vi ( 3 , npart )) allocate ( ri_gc ( 3 , npart )) allocate ( energy ( npart ), pitch ( npart ), weight ( npart )) allocate ( inds ( 3 , npart )) allocate ( neut_types ( npart )) ri = 0.d0 vi = 0.d0 ri_gc = 0.d0 energy = 0.d0 pitch = 0.d0 weight = 0.d0 inds = 0 neut_types = 0 c = 0 #ifdef _MPI rank = my_rank () allocate ( npart_image ( 0 : num_ranks () - 1 )) npart_image (:) = 0 npart_image ( rank ) = birth % cnt - 1 call parallel_sum ( npart_image ) do i = 0 , rank - 1 c = c + npart_image ( i ) enddo deallocate ( npart_image ) #endif start_index = 1 + c end_index = birth % cnt - 1 + c c = 1 do i = start_index , end_index part = birth % part ( c ) ! Convert position to rzphi xyz = part % ri v_xyz = part % vi inds (:, i ) = part % ind neut_types ( i ) = part % neut_type energy ( i ) = part % energy weight ( i ) = part % weight ! Get guiding center positions pitch ( i ) = part % pitch call xyz_to_uvw ( part % ri_gc , uvw_gc ) ri_gc ( 1 , i ) = sqrt ( uvw_gc ( 1 ) * uvw_gc ( 1 ) + uvw_gc ( 2 ) * uvw_gc ( 2 )) ri_gc ( 2 , i ) = uvw_gc ( 3 ) ri_gc ( 3 , i ) = atan2 ( uvw_gc ( 2 ), uvw_gc ( 1 )) ! Get position in cylindrical call xyz_to_uvw ( xyz , uvw ) ri ( 1 , i ) = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) ri ( 2 , i ) = uvw ( 3 ) ri ( 3 , i ) = atan2 ( uvw ( 2 ), uvw ( 1 )) ! Convert velocity to cylindrical v_uvw = matmul ( beam_grid % basis , v_xyz ) vi ( 1 , i ) = v_uvw ( 1 ) * cos ( ri ( 3 , i )) + v_uvw ( 2 ) * sin ( ri ( 3 , i )) vi ( 2 , i ) = v_uvw ( 3 ) vi ( 3 , i ) = - v_uvw ( 1 ) * sin ( ri ( 3 , i )) + v_uvw ( 2 ) * cos ( ri ( 3 , i )) c = c + 1 enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_birth.h5\" do_write = . True . #ifdef _MPI call parallel_sum ( ri_gc ) call parallel_sum ( energy ) call parallel_sum ( pitch ) call parallel_sum ( weight ) call parallel_sum ( ri ) call parallel_sum ( vi ) call parallel_sum ( inds ) call parallel_sum ( neut_types ) if ( my_rank (). ne . 0 ) do_write = . False . #endif if ( do_write ) then !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables call write_beam_grid ( fid , error ) d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/n_birth\" , 0 , d , [ npart ], error ) dim4 = shape ( birth % dens ) call h5ltmake_compressed_dataset_double_f ( fid , \"/dens\" , 4 , dim4 , birth % dens , error ) dim2 = [ 3 , npart ] call h5ltmake_compressed_dataset_double_f ( fid , \"/ri_gc\" , 2 , dim2 , ri_gc , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/ri\" , 2 , dim2 , ri , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vi\" , 2 , dim2 , vi , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/ind\" , 2 , dim2 , inds , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim2 ( 2 : 2 ), energy , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , dim2 ( 2 : 2 ), pitch , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 1 , dim2 ( 2 : 2 ), weight , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/type\" , 1 , dim2 ( 2 : 2 ), neut_types , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/n_birth\" , \"description\" , & \"Number of birth mc particles deposited\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"description\" , & \"Birth density: dens(beam_component,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"units\" , & \"fast-ions/(s*cm&#94;3)\" , error ) call h5ltset_attribute_string_f ( fid , \"/ri_gc\" , \"description\" , & \"Fast-ion guiding-center birth position in R-Z-Phi: ri_gc([r,z,phi],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/ri_gc\" , \"units\" , \"cm, radians\" , error ) call h5ltset_attribute_string_f ( fid , \"/ri\" , \"description\" , & \"Fast-ion birth position in R-Z-Phi: ri([r,z,phi],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/ri\" , \"units\" , \"cm, radians\" , error ) call h5ltset_attribute_string_f ( fid , \"/vi\" , \"description\" , & \"Fast-ion birth velocity in R-Z-Phi: vi([r,z,phi],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/vi\" , \"units\" , \"cm/s\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Fast-ion birth energy: energy(particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"Fast-ion birth weight: weight(particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , \"fast-ions/s\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Fast-ion birth pitch w.r.t. the magnetic field: pitch(particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/ind\" , \"description\" , & \"Fast-ion birth beam grid indices: ind([i,j,k],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/type\" , \"description\" , & \"Fast-ion birth type (1=Full, 2=Half, 3=Third)\" , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"coordinate_system\" , & \"Cylindrical (R,Z,Phi)\" , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Birth density and particles calculated by FIDASIM\" , error ) !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) endif ! Deallocate arrays since they aren't needed anymore deallocate ( ri , vi , ri_gc , energy , pitch , neut_types , inds ) deallocate ( birth % dens , birth % part ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'birth profile written to: ' , trim ( filename ) endif end subroutine write_birth_profile subroutine write_neutrals !+ Writes [[libfida:neut]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dims integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error character ( charlim ) :: filename filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_neutrals.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables call write_beam_grid ( fid , error ) dims = [ nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz ] d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nlevel\" , 0 , d , [ nlevs ], error ) call h5ltset_attribute_string_f ( fid , \"/nlevel\" , \"description\" , & \"Number of atomic energy levels\" , error ) if ( inputs % calc_nbi_dens . ge . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/fdens\" , 4 , dims , & neut % full , error ) call h5ltset_attribute_string_f ( fid , \"/fdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/hdens\" , 4 , dims , & neut % half , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/tdens\" , 4 , dims , & neut % third , error ) call h5ltset_attribute_string_f ( fid , \"/fdens\" , \"description\" , & \"Neutral density for the full energy component of the beam: fdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/hdens\" , \"description\" , & \"Neutral density for the half energy component of the beam: hdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/hdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/tdens\" , \"description\" , & \"Neutral density for the third energy component of the beam: tdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/tdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) endif if ( inputs % calc_dcx_dens . ge . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/dcxdens\" , 4 , dims , & neut % dcx , error ) call h5ltset_attribute_string_f ( fid , \"/dcxdens\" , \"description\" , & \"Direct Charge Exchange (DCX) neutral density: dcxdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/dcxdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) endif if ( inputs % calc_halo_dens . ge . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/halodens\" , 4 , dims , & neut % halo , error ) call h5ltset_attribute_string_f ( fid , \"/halodens\" , \"description\" , & \"Neutral density of the beam halo: halodens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/halodens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Beam neutral density calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'neutral density written to: ' , trim ( filename ) endif end subroutine write_neutrals subroutine write_npa !+ Writes [[libfida:npa]] to a HDF5 file integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error integer , dimension (:), allocatable :: dcount real ( Float64 ), dimension (:,:), allocatable :: ri , rf real ( Float64 ), dimension (:), allocatable :: weight , energy , pitch integer , dimension (:), allocatable :: det , orbit_type integer :: i , npart , c , start_index , end_index character ( charlim ) :: filename = '' logical :: do_write = . True . #ifdef _MPI integer :: rank integer , dimension (:), allocatable :: npart_image rank = my_rank () allocate ( npart_image ( 0 : num_ranks () - 1 )) #endif #ifdef _MPI if ( my_rank (). ne . 0 ) do_write = . False . #endif filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_npa.h5\" if ( do_write ) then !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) endif !! Active allocate ( dcount ( npa_chords % nchan )) npart = npa % npart if ( npart . gt . 0 ) then do i = 1 , npa_chords % nchan dcount ( i ) = count ( npa % part % detector . eq . i ) enddo else dcount = 0 endif #ifdef _MPI call parallel_sum ( dcount ) call parallel_sum ( npart ) #endif c = 0 #ifdef _MPI npart_image (:) = 0 npart_image ( rank ) = npa % npart call parallel_sum ( npart_image ) do i = 0 , rank - 1 c = c + npart_image ( i ) enddo #endif start_index = 1 + c end_index = npa % npart + c if ( npart . gt . 0 ) then allocate ( ri ( 3 , npart ), rf ( 3 , npart )) allocate ( weight ( npart ), energy ( npart ), pitch ( npart )) allocate ( det ( npart ), orbit_type ( npart )) ri = 0.d0 ; rf = 0.d0 weight = 0.d0 ; energy = 0.d0 pitch = 0.d0 ; det = 0 orbit_type = 0 c = 1 do i = start_index , end_index ri ( 1 , i ) = npa % part ( c )% xi ri ( 2 , i ) = npa % part ( c )% yi ri ( 3 , i ) = npa % part ( c )% zi rf ( 1 , i ) = npa % part ( c )% xf rf ( 2 , i ) = npa % part ( c )% yf rf ( 3 , i ) = npa % part ( c )% zf weight ( i ) = npa % part ( c )% weight energy ( i ) = npa % part ( c )% energy pitch ( i ) = npa % part ( c )% pitch det ( i ) = npa % part ( c )% detector orbit_type ( i ) = npa % part ( c )% class c = c + 1 enddo #ifdef _MPI call parallel_sum ( ri ) call parallel_sum ( rf ) call parallel_sum ( weight ) call parallel_sum ( energy ) call parallel_sum ( pitch ) call parallel_sum ( det ) call parallel_sum ( orbit_type ) #endif endif if ( do_write . and .( inputs % calc_npa . ge . 1 )) then !Write Active Flux d ( 1 ) = 1 dim2 = [ npa % nenergy , npa % nchan ] dim3 = [ npa % nenergy , npa % nchan , particles % nclass ] if ( particles % nclass . gt . 1 ) then call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , d , [ particles % nclass ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/flux\" , 3 , dim3 , npa % flux , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"description\" , & \"Active Neutral flux: flux(energy,chan,class)\" , error ) else call h5ltmake_compressed_dataset_double_f ( fid , \"/flux\" , 2 , dim3 ( 1 : 2 ), npa % flux (:,:, 1 ), error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"description\" , & \"Active Neutral flux: flux(energy,chan)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/flux\" , \"units\" , \"neutrals/(s*dE)\" , error ) call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , d , [ npa % nenergy ], error ) call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ npa % nchan ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim2 ( 1 : 1 ),& npa % energy , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dim2 ( 2 : 2 ),& npa_chords % radius , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/count\" , 1 , dim2 ( 2 : 2 ), dcount , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"NPA flux calculated by FIDASIM\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" ,& \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" ,& \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Detector line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/count\" , \"description\" , & \"Number of particles that hit the detector: count(chan)\" , error ) if (( npart . gt . 0 ). and .( inputs % calc_npa . ge . 2 )) then !Create Group call h5gcreate_f ( fid , \"/particles\" , gid , error ) call h5ltmake_dataset_int_f ( gid , \"nparticle\" , 0 , d , [ npart ], error ) d ( 1 ) = npart dim2 = [ 3 , npart ] call h5ltmake_compressed_dataset_double_f ( gid , \"ri\" , 2 , dim2 , ri , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"rf\" , 2 , dim2 , rf , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"pitch\" , 1 , d , pitch , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , d , energy , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"weight\" , 1 , d , weight , error ) call h5ltmake_compressed_dataset_int_f ( gid , \"detector\" , 1 , d , det , error ) call h5ltmake_compressed_dataset_int_f ( gid , \"class\" , 1 , d , orbit_type , error ) !Add attributes call h5ltset_attribute_string_f ( gid , \"nparticle\" , \"description\" , & \"Number of particles that hit a detector\" , error ) call h5ltset_attribute_string_f ( gid , \"ri\" , \"description\" , & \"Neutral particle's birth position in machine coordinates: ri([x,y,z],particle)\" , error ) call h5ltset_attribute_string_f ( gid , \"ri\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"rf\" , \"description\" , & \"Neutral particle's hit position in machine coordinates: rf([x,y,z],particle)\" , error ) call h5ltset_attribute_string_f ( gid , \"rf\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"pitch\" , \"description\" , & \"Pitch value of the neutral particle: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy value of the neutral particle\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"weight\" , \"description\" , & \"Neutral particle's contribution to the flux\" , error ) call h5ltset_attribute_string_f ( gid , \"weight\" , \"units\" , \"neutrals/s\" , error ) call h5ltset_attribute_string_f ( gid , \"detector\" , \"description\" , & \"Detector that the neutral particle hit\" , error ) call h5ltset_attribute_string_f ( gid , \"class\" , \"description\" , & \"Class of the neutral particle\" , error ) call h5ltset_attribute_string_f ( fid , \"/particles\" , \"coordinate_system\" , & \"Right-handed cartesian\" , error ) call h5ltset_attribute_string_f ( fid , \"/particles\" , \"description\" , & \"Active NPA Monte Carlo particles\" , error ) !Close group call h5gclose_f ( gid , error ) endif endif deallocate ( dcount ) if ( npart . gt . 0 ) then deallocate ( ri , rf ) deallocate ( energy , pitch , weight , det , orbit_type ) endif !! Passive allocate ( dcount ( npa_chords % nchan )) npart = pnpa % npart if ( npart . gt . 0 ) then do i = 1 , npa_chords % nchan dcount ( i ) = count ( pnpa % part % detector . eq . i ) enddo else dcount = 0 endif #ifdef _MPI call parallel_sum ( dcount ) call parallel_sum ( npart ) #endif c = 0 #ifdef _MPI npart_image (:) = 0 npart_image ( rank ) = pnpa % npart call parallel_sum ( npart_image ) do i = 0 , rank - 1 c = c + npart_image ( i ) enddo #endif start_index = 1 + c end_index = pnpa % npart + c if ( npart . gt . 0 ) then allocate ( ri ( 3 , npart ), rf ( 3 , npart )) allocate ( weight ( npart ), energy ( npart ), pitch ( npart )) allocate ( det ( npart ), orbit_type ( npart )) ri = 0.d0 ; rf = 0.d0 weight = 0.d0 ; energy = 0.d0 pitch = 0.d0 ; det = 0 orbit_type = 0 c = 1 do i = start_index , end_index ri ( 1 , i ) = pnpa % part ( c )% xi ri ( 2 , i ) = pnpa % part ( c )% yi ri ( 3 , i ) = pnpa % part ( c )% zi rf ( 1 , i ) = pnpa % part ( c )% xf rf ( 2 , i ) = pnpa % part ( c )% yf rf ( 3 , i ) = pnpa % part ( c )% zf weight ( i ) = pnpa % part ( c )% weight energy ( i ) = pnpa % part ( c )% energy pitch ( i ) = pnpa % part ( c )% pitch det ( i ) = pnpa % part ( c )% detector orbit_type ( i ) = pnpa % part ( c )% class c = c + 1 enddo #ifdef _MPI call parallel_sum ( ri ) call parallel_sum ( rf ) call parallel_sum ( weight ) call parallel_sum ( energy ) call parallel_sum ( pitch ) call parallel_sum ( det ) call parallel_sum ( orbit_type ) #endif endif if ( do_write . and .( inputs % calc_pnpa . ge . 1 )) then !Write Passive Flux d ( 1 ) = 1 dim2 = [ pnpa % nenergy , pnpa % nchan ] dim3 = [ pnpa % nenergy , pnpa % nchan , particles % nclass ] if ( particles % nclass . gt . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/pflux\" , 3 , dim3 , pnpa % flux , error ) call h5ltset_attribute_string_f ( fid , \"/pflux\" , \"description\" , & \"Passive Neutral flux: pflux(energy,chan,class)\" , error ) else call h5ltmake_compressed_dataset_double_f ( fid , \"/pflux\" , 2 , dim3 ( 1 : 2 ), pnpa % flux (:,:, 1 ), error ) call h5ltset_attribute_string_f ( fid , \"/pflux\" , \"description\" , & \"Passive Neutral flux: pflux(energy,chan)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/pflux\" , \"units\" , \"neutrals/(s*dE)\" , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/pcount\" , 1 , dim2 ( 2 : 2 ), dcount , error ) call h5ltset_attribute_string_f ( fid , \"/pcount\" , \"description\" , & \"Number of passive particles that hit the detector: pcount(chan)\" , error ) if ( inputs % calc_npa . le . 0 ) then call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , d , [ pnpa % nenergy ], error ) call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ pnpa % nchan ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim2 ( 1 : 1 ),& pnpa % energy , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dim2 ( 2 : 2 ),& npa_chords % radius , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"NPA flux calculated by FIDASIM\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" ,& \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" ,& \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Detector line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) endif if (( npart . gt . 0 ). and .( inputs % calc_pnpa . ge . 2 )) then !Create Group call h5gcreate_f ( fid , \"/passive_particles\" , gid , error ) call h5ltmake_dataset_int_f ( gid , \"nparticle\" , 0 , d , [ npart ], error ) d ( 1 ) = npart dim2 = [ 3 , npart ] call h5ltmake_compressed_dataset_double_f ( gid , \"ri\" , 2 , dim2 , ri , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"rf\" , 2 , dim2 , rf , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"pitch\" , 1 , d , pitch , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , d , energy , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"weight\" , 1 , d , weight , error ) call h5ltmake_compressed_dataset_int_f ( gid , \"detector\" , 1 , d , det , error ) call h5ltmake_compressed_dataset_int_f ( gid , \"class\" , 1 , d , orbit_type , error ) !Add attributes call h5ltset_attribute_string_f ( gid , \"nparticle\" , \"description\" , & \"Number of particles that hit a detector\" , error ) call h5ltset_attribute_string_f ( gid , \"ri\" , \"description\" , & \"Neutral particle's birth position in machine coordinates: ri([x,y,z],particle)\" , error ) call h5ltset_attribute_string_f ( gid , \"ri\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"rf\" , \"description\" , & \"Neutral particle's hit position in machine coordinates: rf([x,y,z],particle)\" , error ) call h5ltset_attribute_string_f ( gid , \"rf\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"pitch\" , \"description\" , & \"Pitch value of the neutral particle: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy value of the neutral particle\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"weight\" , \"description\" , & \"Neutral particle's contribution to the flux\" , error ) call h5ltset_attribute_string_f ( gid , \"weight\" , \"units\" , \"neutrals/s\" , error ) call h5ltset_attribute_string_f ( gid , \"detector\" , \"description\" , & \"Detector that the neutral particle hit\" , error ) call h5ltset_attribute_string_f ( gid , \"class\" , \"description\" , & \"Class of the neutral particle\" , error ) call h5ltset_attribute_string_f ( fid , \"/passive_particles\" , \"coordinate_system\" , & \"Right-handed cartesian\" , error ) call h5ltset_attribute_string_f ( fid , \"/passive_particles\" , \"description\" , & \"Passive NPA Monte Carlo particles\" , error ) !Close group call h5gclose_f ( gid , error ) endif endif if ( do_write ) then !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'NPA data written to: ' , trim ( filename ) endif #ifdef _MPI deallocate ( npart_image ) #endif end subroutine write_npa subroutine write_spectra !+ Writes [[libfida:spectra]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 3 ) :: dims integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error character ( charlim ) :: filename integer :: i real ( Float64 ) :: factor real ( Float64 ), dimension (:), allocatable :: lambda_arr allocate ( lambda_arr ( inputs % nlambda )) do i = 1 , inputs % nlambda lambda_arr ( i ) = ( i - 0.5 ) * inputs % dlambda + inputs % lambdamin enddo !! convert [Ph/(s*wavel_bin*cm&#94;2*all_directions)] to [Ph/(s*nm*sr*m&#94;2)]! factor = 1.d0 / ( inputs % dlambda ) / ( 4.d0 * pi ) * 1.d4 !! write to file filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_spectra.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ spec_chords % nchan ], error ) call h5ltmake_dataset_int_f ( fid , \"/nlambda\" , 0 , d , [ inputs % nlambda ], error ) dims ( 1 ) = inputs % nlambda dims ( 2 ) = spec_chords % nchan dims ( 3 ) = particles % nclass call h5ltmake_compressed_dataset_double_f ( fid , \"/lambda\" , 1 , dims ( 1 : 1 ), & lambda_arr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dims ( 2 : 2 ), & spec_chords % radius , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nlambda\" , \"description\" , & \"Number of wavelengths\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"description\" , & \"Wavelength array\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"units\" , \"nm\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) if ( inputs % calc_brems . ge . 1 ) then spec % brems = factor * spec % brems !Write variables call h5ltmake_compressed_dataset_double_f ( fid , \"/brems\" , 2 , & dims ( 1 : 2 ), spec % brems , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/brems\" , \"description\" , & \"Visible Bremsstrahlung: brems(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/brems\" , \"units\" ,& \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_bes . ge . 1 ) then spec % full = factor * spec % full spec % half = factor * spec % half spec % third = factor * spec % third !Write variables call h5ltmake_compressed_dataset_double_f ( fid , \"/full\" , 2 , dims ( 1 : 2 ), & spec % full , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/half\" , 2 , dims ( 1 : 2 ), & spec % half , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/third\" , 2 , dims ( 1 : 2 ),& spec % third , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/full\" , \"description\" , & \"Full energy component of the beam emmision: full(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/full\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/half\" , \"description\" , & \"Half energy component of the beam emmision: half(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/half\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/third\" , \"description\" , & \"Third energy component of the beam emmision: third(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/third\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_dcx . ge . 1 ) then spec % dcx = factor * spec % dcx call h5ltmake_compressed_dataset_double_f ( fid , \"/dcx\" , 2 , dims ( 1 : 2 ), & spec % dcx , error ) call h5ltset_attribute_string_f ( fid , \"/dcx\" , \"description\" , & \"Direct Charge Exchange (DCX) emission: dcx(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/dcx\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_halo . ge . 1 ) then spec % halo = factor * spec % halo call h5ltmake_compressed_dataset_double_f ( fid , \"/halo\" , 2 , dims ( 1 : 2 ), & spec % halo , error ) call h5ltset_attribute_string_f ( fid , \"/halo\" , \"description\" , & \"Halo component of the beam emmision: halo(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/halo\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_cold . ge . 1 ) then spec % cold = factor * spec % cold call h5ltmake_compressed_dataset_double_f ( fid , \"/cold\" , 2 , dims ( 1 : 2 ), & spec % cold , error ) call h5ltset_attribute_string_f ( fid , \"/cold\" , \"description\" , & \"Cold D-alpha emission: cold(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/cold\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_fida . ge . 1 ) then spec % fida = factor * spec % fida !Write variables if ( particles % nclass . le . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 2 , & dims ( 1 : 2 ), spec % fida (:,:, 1 ), error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Active Fast-ion D-alpha (FIDA) emmision: fida(lambda,chan)\" , error ) else call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , d , [ particles % nclass ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 3 , & dims , spec % fida , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Active Fast-ion D-alpha (FIDA) emmision: fida(lambda,chan,class)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/fida\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_pfida . ge . 1 ) then spec % pfida = factor * spec % pfida !Write variables if ( particles % nclass . le . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/pfida\" , 2 , & dims ( 1 : 2 ), spec % pfida (:,:, 1 ), error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/pfida\" , \"description\" , & \"Passive Fast-ion D-alpha (p-FIDA) emmision: pfida(lambda,chan)\" , error ) else if ( inputs % calc_fida . le . 0 ) then call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , d , [ particles % nclass ], error ) endif call h5ltmake_compressed_dataset_double_f ( fid , \"/pfida\" , 3 , & dims , spec % pfida , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/pfida\" , \"description\" , & \"Passive Fast-ion D-alpha (p-FIDA) emmision: pfida(lambda,chan,class)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/pfida\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" ,& \"Spectra calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'Spectra written to: ' , trim ( filename ) endif end subroutine write_spectra subroutine write_neutrons !+ Writes [[libfida:neutron]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: error character ( charlim ) :: filename !! write to file filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_neutrons.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables if ( particles % nclass . gt . 1 ) then dim1 ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , dim1 , [ particles % nclass ], error ) dim1 ( 1 ) = particles % nclass call h5ltmake_compressed_dataset_double_f ( fid , \"/rate\" , 1 , dim1 , neutron % rate , error ) call h5ltset_attribute_string_f ( fid , \"/rate\" , \"description\" , & \"Neutron rate: rate(orbit_class)\" , error ) else dim1 ( 1 ) = 1 call h5ltmake_dataset_double_f ( fid , \"/rate\" , 0 , dim1 , neutron % rate , error ) call h5ltset_attribute_string_f ( fid , \"/rate\" , \"description\" , & \"Neutron rate\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/rate\" , \"units\" , \"neutrons/s\" , error ) if (( inputs % dist_type . eq . 1 ). and .( inputs % calc_neutron . ge . 2 )) then dim1 ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , dim1 ,[ fbm % nenergy ], error ) call h5ltmake_dataset_int_f ( fid , \"/npitch\" , 0 , dim1 ,[ fbm % npitch ], error ) call h5ltmake_dataset_int_f ( fid , \"/nr\" , 0 , dim1 ,[ fbm % nr ], error ) call h5ltmake_dataset_int_f ( fid , \"/nz\" , 0 , dim1 ,[ fbm % nz ], error ) dim5 = shape ( neutron % weight ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 5 , dim5 , neutron % weight , error ) dim3 = shape ( neutron % emis ) call h5ltmake_compressed_dataset_double_f ( fid , \"/emissivity\" , 3 , dim3 , neutron % emis , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim5 ( 1 : 1 ), fbm % energy , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , dim5 ( 2 : 2 ), fbm % pitch , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/r\" , 1 , dim5 ( 3 : 3 ), fbm % r , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/z\" , 1 , dim5 ( 4 : 4 ), fbm % z , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/phi\" , 1 , dim5 ( 5 : 5 ), fbm % phi , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/npitch\" , \"description\" , & \"Number of pitch values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nr\" , \"description\" , & \"Number of R values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nz\" , \"description\" , & \"Number of Z values\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"Neutron Weight Function: weight(E,p,R,Z,Phi), rate = sum(f*weight)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , \"neutrons*cm&#94;3*dE*dp/fast-ion*s\" , error ) call h5ltset_attribute_string_f ( fid , \"/emissivity\" , \"description\" , & \"Neutron Emissivity: emissivity(R,Z,Phi), rate = sum(emissivity)\" , error ) call h5ltset_attribute_string_f ( fid , \"/emissivity\" , \"units\" , \"neutrons*cm&#94;3/fast-ion*s\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Pitch array: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( fid , \"/r\" , \"description\" , & \"Radius array\" , error ) call h5ltset_attribute_string_f ( fid , \"/r\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/z\" , \"description\" , & \"Z array\" , error ) call h5ltset_attribute_string_f ( fid , \"/z\" , \"units\" , \"cm\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" ,& \"Neutron rate calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'Neutrons written to: ' , trim ( filename ) endif end subroutine write_neutrons subroutine write_fida_weights !+ Writes [[libfida:fweight]] to a HDF5 file !! HDF5 variables integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer :: error character ( charlim ) :: filename integer :: i , ie , ip , ic , iwav real ( Float64 ), dimension (:), allocatable :: lambda_arr real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr real ( Float64 ), dimension (:,:), allocatable :: jacobian , e_grid , p_grid real ( Float64 ), dimension (:,:), allocatable :: vpa_grid , vpe_grid , fida real ( Float64 ) :: dlambda , wtot , dE , dP dlambda = ( inputs % lambdamax_wght - inputs % lambdamin_wght ) / inputs % nlambda_wght allocate ( lambda_arr ( inputs % nlambda_wght )) do i = 1 , inputs % nlambda_wght lambda_arr ( i ) = ( i - 0.5 ) * dlambda + inputs % lambdamin_wght enddo !! define arrays !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) !! define 2d grids !! define energy grid allocate ( e_grid ( inputs % ne_wght , inputs % np_wght )) do i = 1 , inputs % ne_wght e_grid ( i ,:) = ebarr ( i ) enddo !! define pitch grid allocate ( p_grid ( inputs % ne_wght , inputs % np_wght )) do i = 1 , inputs % np_wght p_grid (:, i ) = ptcharr ( i ) enddo !! define velocity space grid allocate ( vpe_grid ( inputs % ne_wght , inputs % np_wght )) !! V perpendicular allocate ( vpa_grid ( inputs % ne_wght , inputs % np_wght )) !! V parallel vpa_grid = 100 * sqrt (((( 2.0d3 ) * e0 ) / ( mass_u * inputs % ab )) * e_grid ) * p_grid ! [cm/s] vpe_grid = 100 * sqrt (((( 2.0d3 ) * e0 ) / ( mass_u * inputs % ab )) * e_grid * ( 1.0 - p_grid ** 2 )) ![cm/s] !! define jacobian to convert between E-p to velocity allocate ( jacobian ( inputs % ne_wght , inputs % np_wght )) jacobian = (( inputs % ab * mass_u ) / ( e0 * 1.0d3 )) * vpe_grid / sqrt ( vpa_grid ** 2 + vpe_grid ** 2 ) !! normalize mean_f do ic = 1 , spec_chords % nchan do ip = 1 , inputs % np_wght do ie = 1 , inputs % ne_wght wtot = sum ( fweight % weight (:, ie , ip , ic )) if (( wtot . gt . 0.d0 )) then fweight % mean_f ( ie , ip , ic ) = fweight % mean_f ( ie , ip , ic ) / wtot endif enddo enddo enddo !! Calculate FIDA estimate allocate ( fida ( inputs % nlambda_wght , spec_chords % nchan )) do iwav = 1 , size ( fida , 1 ) fida ( iwav ,:) = ( dE * dP * 1 d4 ) * sum ( sum ( fweight % mean_f (:,:,:) * fweight % weight ( iwav ,:,:,:), 1 ), 1 ) enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_fida_weights.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) dim1 ( 1 ) = 1 dim2 = [ inputs % nlambda_wght , spec_chords % nchan ] dim4 = [ inputs % nlambda_wght , inputs % ne_wght , inputs % np_wght , spec_chords % nchan ] call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , dim1 ,[ inputs % ne_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/npitch\" , 0 , dim1 ,[ inputs % np_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , dim1 ,[ spec_chords % nchan ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 4 , dim4 , fweight % weight , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 2 , dim2 , fida , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/mean_f\" , 3 , dim4 ( 2 : 4 ), fweight % mean_f , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/lambda\" , 1 , dim4 ( 1 : 1 ), lambda_arr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim4 ( 2 : 2 ), ebarr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , dim4 ( 3 : 3 ), ptcharr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dim4 ( 4 : 4 ), spec_chords % radius , error ) dim2 = [ inputs % ne_wght , inputs % np_wght ] call h5ltmake_compressed_dataset_double_f ( fid , \"/jacobian\" , 2 , dim2 , jacobian , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vpe_grid\" , 2 , dim2 , vpe_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vpa_grid\" , 2 , dim2 , vpa_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/e_grid\" , 2 , dim2 , e_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/p_grid\" , 2 , dim2 , p_grid , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) if ( inputs % calc_fida_wght . eq . 1 ) then call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Line of Sight averaged FIDA E-p space sensitivity/weights \" // & \"and spectra calculated by FIDASIM\" , error ) else call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Full FIDA E-p space sensitivity/weights and spectra calculated \" // & \"by FIDASIM via Monte Carlo method\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"E-p space sensivity/weight of FIDA diagnostic: weight(lambda,energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , & \"(Ph*cm)/(s*nm*sr*fast-ion*dE*dP)\" , error ) call h5ltset_attribute_string_f ( fid , \"/fida\" , \"units\" , & \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Estimate of Fast-ion D-alpha (FIDA) emmision calculated by 1e4*weight*mean_f*dEdP: fida(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/mean_f\" , \"description\" , & \"Estimated mean fast-ion distribution function seen by los: mean_f(energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/mean_f\" , \"units\" , & \"fast-ion/(dE*dP*cm&#94;3)\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"description\" , & \"Wavelength array\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"units\" , \"nm\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/npitch\" , \"description\" , & \"Number of pitch value\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Pitch array: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/jacobian\" , \"description\" , & \"Jacobian used to convert from E-p space to velocity space\" , error ) call h5ltset_attribute_string_f ( fid , \"/jacobian\" , \"units\" , & \"(dE*dP)/(dvpa*dvpe)\" , error ) call h5ltset_attribute_string_f ( fid , \"/e_grid\" , \"description\" , & \"2D energy grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/e_grid\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/p_grid\" , \"description\" , & \"2D pitch grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpe_grid\" , \"description\" , & \"2D perpendicular velocity grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpe_grid\" , \"units\" , \"cm/s\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpa_grid\" , \"description\" , & \"2D parallel velocity grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpa_grid\" , \"units\" , \"cm/s\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'FIDA weights written to: ' , trim ( filename ) endif end subroutine write_fida_weights subroutine write_npa_weights !+ Writes [[libfida:nweight]] to a HDF5 file character ( charlim ) :: filename integer :: i real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr !! HDF5 variables integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_npa_weights.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables d ( 1 ) = 1 dim2 = [ inputs % ne_wght , npa_chords % nchan ] dim3 = [ inputs % ne_wght , inputs % np_wght , npa_chords % nchan ] dim5 = [ inputs % ne_wght , beam_grid % nx , beam_grid % ny , beam_grid % nz , npa_chords % nchan ] call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ npa_chords % nchan ], error ) call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , d , [ inputs % ne_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/npitch\" , 0 , d , [ inputs % np_wght ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , & dim2 ( 2 : 2 ), npa_chords % radius , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , & dim2 ( 1 : 1 ), ebarr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , & dim3 ( 2 : 2 ), ptcharr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/flux\" , 2 , & dim2 , nweight % flux , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 3 , & dim3 , nweight % weight , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"NPA E-p space sensitivity/weights and Flux calculated by FIDASIM\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/npitch\" , \"description\" , & \"Number of pitch value\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Pitch array: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"description\" , & \"Neutral flux: flux(energy,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"units\" , & \"neutrals/(s*dE)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"E-p space sensivity/weight of NPA diagnostics: weight(energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , & \"neutrals/(s*fast-ion*dE*dP)\" , error ) if ( inputs % calc_npa_wght . ge . 2 ) then !Write diagnostic variables call write_beam_grid ( fid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/emissivity\" , 4 , & dim5 ( 2 : 5 ), nweight % emissivity , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/attenuation\" , 5 , & dim5 , nweight % attenuation , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/cx\" , 5 , & dim5 , nweight % cx , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/phit\" , 4 , & dim5 ( 2 : 5 ), npa_chords % phit % p , error ) call h5ltset_attribute_string_f ( fid , \"/emissivity\" , \"description\" , & \"Neutral emissivity: emissivity(x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/emissivity\" , \"units\" , & \"neutrals/(s*dV)\" , error ) call h5ltset_attribute_string_f ( fid , \"/cx\" , \"description\" , & \"Charge-exchange rate: cx(energy,x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/cx\" , \"units\" , \"s&#94;(-1)\" , error ) call h5ltset_attribute_string_f ( fid , \"/attenuation\" , \"description\" , & \"Attenuation factor i.e. survival probability: attenuation(energy,x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/phit\" , \"description\" , & \"Probability of hitting the detector given an isotropic source: phit(x,y,z,chan)\" , error ) endif !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'NPA weights written to: ' , trim ( filename ) endif end subroutine write_npa_weights subroutine read_neutrals !+ Reads neutral density from file and puts it in [[libfida:neut]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 4 ) :: dims integer :: error , nx , ny , nz logical :: exis , fatal_error if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- loading neutrals ----' endif inquire ( file = inputs % neutrals_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Neutrals file: \",a)' ) trim ( inputs % neutrals_file ) write ( * , * ) '' endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_NEUTRALS: Neutrals file does not exist: ' , inputs % neutrals_file endif stop endif !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fopen_f ( inputs % neutrals_file , H5F_ACC_RDONLY_F , fid , error ) call h5gopen_f ( fid , \"/grid\" , gid , error ) call h5ltread_dataset_int_scalar_f ( gid , \"nx\" , nx , error ) call h5ltread_dataset_int_scalar_f ( gid , \"ny\" , ny , error ) call h5ltread_dataset_int_scalar_f ( gid , \"nz\" , nz , error ) call h5gclose_f ( gid , error ) fatal_error = . False . if (( nx . ne . beam_grid % nx ). or . & ( ny . ne . beam_grid % ny ). or . & ( nz . ne . beam_grid % nz )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_NEUTRALS: Neutrals file has incompatable grid dimensions' endif fatal_error = . True . endif !Check to make sure the neutrals file has all the needed neutrals call h5ltpath_valid_f ( fid , \"/fdens\" , . True ., exis , error ) if ((. not . exis ). and .( inputs % calc_nbi_dens . ge . 1 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_NEUTRALS: Full energy neutral density is not in the neutrals file' endif fatal_error = . True . endif call h5ltpath_valid_f ( fid , \"/hdens\" , . True ., exis , error ) if ((. not . exis ). and .( inputs % calc_nbi_dens . ge . 1 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_NEUTRALS: Half energy neutral density is not in the neutrals file' endif fatal_error = . True . endif call h5ltpath_valid_f ( fid , \"/tdens\" , . True ., exis , error ) if ((. not . exis ). and .( inputs % calc_nbi_dens . ge . 1 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_NEUTRALS: Third energy neutral density is not in the neutrals file' endif fatal_error = . True . endif call h5ltpath_valid_f ( fid , \"/dcxdens\" , . True ., exis , error ) if ((. not . exis ). and .( inputs % calc_dcx_dens . ge . 1 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_NEUTRALS: Direct Charge Exchange (DCX) neutral density is not in the neutrals file' endif fatal_error = . True . endif call h5ltpath_valid_f ( fid , \"/halodens\" , . True ., exis , error ) if ((. not . exis ). and .( inputs % calc_halo_dens . ge . 1 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_NEUTRALS: Thermal Halo neutral density is not in the neutrals file' endif fatal_error = . True . endif if ( fatal_error ) stop dims = [ nlevs , nx , ny , nz ] if ( inputs % calc_nbi_dens . ge . 1 ) then call h5ltread_dataset_double_f ( fid , \"/fdens\" , & neut % full , dims , error ) call h5ltread_dataset_double_f ( fid , \"/hdens\" , & neut % half , dims , error ) call h5ltread_dataset_double_f ( fid , \"/tdens\" , & neut % third , dims , error ) endif if ( inputs % calc_dcx_dens . ge . 1 ) then call h5ltread_dataset_double_f ( fid , \"/dcxdens\" , & neut % dcx , dims , error ) endif if ( inputs % calc_halo_dens . ge . 1 ) then call h5ltread_dataset_double_f ( fid , \"/halodens\" , & neut % halo , dims , error ) endif !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) end subroutine read_neutrals !============================================================================= !-----------------------------Geometry Routines------------------------------- !============================================================================= function approx_eq ( x , y , tol ) result ( a ) !+ Inexact equality comparison: `x ~= y` true if `abs(x-y) <= tol` else false real ( Float64 ), intent ( in ) :: x !+First value in comparison real ( Float64 ), intent ( in ) :: y !+Second value in comparison real ( Float64 ), intent ( in ) :: tol !+Equality tolerance logical :: a a = abs ( x - y ). le . tol end function approx_eq function approx_ge ( x , y , tol ) result ( a ) !+ Inexact greater than or equal to comparison: `x >~= y` real ( Float64 ), intent ( in ) :: x !+First value in comparison real ( Float64 ), intent ( in ) :: y !+Second value in comparison real ( Float64 ), intent ( in ) :: tol !+Equality tolerance logical :: a a = ( x . gt . y ). or .( approx_eq ( x , y , tol )) end function approx_ge function approx_le ( x , y , tol ) result ( a ) !+ Inexact less then or equal to comparison: `x <~= y` real ( Float64 ), intent ( in ) :: x !+First value in comparison real ( Float64 ), intent ( in ) :: y !+Second value in comparison real ( Float64 ), intent ( in ) :: tol !+Equality tolerance logical :: a a = ( x . lt . y ). or .( approx_eq ( x , y , tol )) end function approx_le function cross_product ( u , v ) result ( s ) !+ Calculates the cross product of two vectors: `u`x`v` real ( Float64 ), dimension ( 3 ), intent ( in ) :: u real ( Float64 ), dimension ( 3 ), intent ( in ) :: v real ( Float64 ), dimension ( 3 ) :: s s ( 1 ) = u ( 2 ) * v ( 3 ) - u ( 3 ) * v ( 2 ) s ( 2 ) = u ( 3 ) * v ( 1 ) - u ( 1 ) * v ( 3 ) s ( 3 ) = u ( 1 ) * v ( 2 ) - u ( 2 ) * v ( 1 ) end function cross_product subroutine tb_zyx ( alpha , beta , gamma , basis , inv_basis ) !+ Creates active rotation matrix for z-y'-x\" rotation given Tait-Bryan angles real ( Float64 ), intent ( in ) :: alpha !+ Angle of rotation about z real ( Float64 ), intent ( in ) :: beta !+ Angle of rotation about y' real ( Float64 ), intent ( in ) :: gamma !+ Angle of rotation about x\" real ( Float64 ), dimension ( 3 , 3 ), intent ( out ) :: basis !+ Rotation matrix/basis for transforming from rotated to non-rotated coordinates real ( Float64 ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis !+ Inverse basis for reverse transformation real ( Float64 ) :: sa , sb , sg , ca , cb , cg sa = sin ( alpha ) ; sb = sin ( beta ) ; sg = sin ( gamma ) ca = cos ( alpha ) ; cb = cos ( beta ) ; cg = cos ( gamma ) basis ( 1 , 1 ) = ca * cb ; basis ( 1 , 2 ) = ca * sb * sg - cg * sa ; basis ( 1 , 3 ) = sa * sg + ca * cg * sb basis ( 2 , 1 ) = cb * sa ; basis ( 2 , 2 ) = ca * cg + sa * sb * sg ; basis ( 2 , 3 ) = cg * sa * sb - ca * sg basis ( 3 , 1 ) = - sb ; basis ( 3 , 2 ) = cb * sg ; basis ( 3 , 3 ) = cb * cg if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine tb_zyx subroutine line_basis ( r0 , v0 , basis , inv_basis ) !+ Calculates basis from a line with +x in the direction of line real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Starting point of line [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Direction of line real ( Float64 ), dimension ( 3 , 3 ), intent ( out ) :: basis !+ Basis for transforming from line coordinates to cartesian real ( Float64 ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis !+ Inverse basis for the reverse transformation cartesian to line real ( Float64 ), dimension ( 3 ) :: rf real ( Float64 ) :: alpha , beta , dis rf = r0 + v0 dis = sqrt ( sum (( rf - r0 ) ** 2 )) beta = asin (( r0 ( 3 ) - rf ( 3 )) / dis ) alpha = atan2 ( rf ( 2 ) - r0 ( 2 ), rf ( 1 ) - r0 ( 1 )) call tb_zyx ( alpha , beta , 0.d0 , basis ) if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine line_basis subroutine plane_basis ( center , redge , tedge , basis , inv_basis ) !+ Calculates basis from 3 points on a plane with +z being the plane normal real ( Float64 ), dimension ( 3 ), intent ( in ) :: center !+ Plane origin real ( Float64 ), dimension ( 3 ), intent ( in ) :: redge !+ Right edge of plane real ( Float64 ), dimension ( 3 ), intent ( in ) :: tedge !+ Top edge of plane real ( Float64 ), dimension ( 3 , 3 ), intent ( out ) :: basis !+ Basis for transforming from plane to cartesian coordinates real ( Float64 ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis !+ Inverse basis for the reverse transformation cartesian to plane real ( Float64 ), dimension ( 3 ) :: u1 , u2 , u3 u1 = ( redge - center ) u1 = u1 / norm2 ( u1 ) u2 = ( tedge - center ) u2 = u2 / norm2 ( u2 ) u3 = cross_product ( u1 , u2 ) u3 = u3 / norm2 ( u3 ) basis (:, 1 ) = u1 basis (:, 2 ) = u2 basis (:, 3 ) = u3 if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine plane_basis subroutine line_plane_intersect ( l0 , l , p0 , n , p , t ) !+ Calculates the intersection of a line and a plane real ( Float64 ), dimension ( 3 ), intent ( in ) :: l0 !+ Point on line real ( Float64 ), dimension ( 3 ), intent ( in ) :: l !+ Ray of line real ( Float64 ), dimension ( 3 ), intent ( in ) :: p0 !+ Point on plane real ( Float64 ), dimension ( 3 ), intent ( in ) :: n !+ Normal vector of plane real ( Float64 ), dimension ( 3 ), intent ( out ) :: p !+ Line-plane intersect point real ( Float64 ), intent ( out ) :: t !+ \"time\" to intersect real ( Float64 ) :: ldotn ldotn = dot_product ( l , n ) if ( ldotn . eq . 0.0 ) then t = 0.0 else t = dot_product ( p0 - l0 , n ) / ldotn endif p = l0 + t * l end subroutine line_plane_intersect subroutine line_cylinder_intersect ( l0 , l , p0 , p , t ) !+ Calculates the intersection of a line and a cylinder real ( Float64 ), dimension ( 3 ), intent ( in ) :: l0 !+ Point on line real ( Float64 ), dimension ( 3 ), intent ( in ) :: l !+ Ray of line real ( Float64 ), dimension ( 3 ), intent ( in ) :: p0 !+ Point on cylinder real ( Float64 ), dimension ( 3 ), intent ( out ) :: p !+ Line-cylinder intersect point real ( Float64 ), intent ( out ) :: t !+ \"time\" to intersect real ( Float64 ), dimension ( 2 ) :: times logical , dimension ( 2 ) :: mask real ( Float64 ) :: r , vx , vy , x0 , y0 real ( Float64 ) :: radicand , npos r = sqrt ( p0 ( 1 ) * p0 ( 1 ) + p0 ( 2 ) * p0 ( 2 )) x0 = l0 ( 1 ) ; y0 = l0 ( 2 ) vx = l ( 1 ) ; vy = l ( 2 ) if (( vx . eq . 0.d0 ). and .( vy . eq . 0.d0 )) then t = 0.d0 ! Parallel to a plane tangent to the cylinder else radicand = r ** 2 * ( vx ** 2 + vy ** 2 ) - ( vy * x0 - vx * y0 ) ** 2 if ( radicand . lt . 0 ) then t = 0.d0 ! Parallel to a plane tangent to the cylinder else times ( 1 ) = ( - vx * x0 - vy * y0 - sqrt ( radicand )) / ( vx ** 2 + vy ** 2 ) times ( 2 ) = ( - vx * x0 - vy * y0 + sqrt ( radicand )) / ( vx ** 2 + vy ** 2 ) mask = times . gt . 0 npos = count ( mask ) if ( npos . gt . 0 ) then t = minval ( times , mask = times . gt . 0 ) else t = maxval ( times , mask = times . le . 0 ) endif endif endif p = l0 + l * t end subroutine line_cylinder_intersect function in_boundary ( bplane , p ) result ( in_b ) !+ Indicator function for determining if a point on a plane is within the plane boundary type ( BoundedPlane ), intent ( in ) :: bplane !+ Plane with boundary real ( Float64 ), dimension ( 3 ), intent ( in ) :: p !+ Point on plane logical :: in_b real ( Float64 ), dimension ( 3 ) :: pp real ( Float64 ) :: hh , hw hh = bplane % hh hw = bplane % hw pp = matmul ( bplane % inv_basis , p - bplane % origin ) in_b = . False . SELECT CASE ( bplane % shape ) CASE ( 1 ) !Rectangular boundary if (( abs ( pp ( 1 )). le . hw ). and . & ( abs ( pp ( 2 )). le . hh )) then in_b = . True . endif CASE ( 2 ) !Circular/Ellipsoidal boundary if ((( hh * pp ( 1 )) ** 2 + ( hw * pp ( 2 )) ** 2 ). le .(( hh * hw ) ** 2 )) then in_b = . True . endif CASE DEFAULT if ( inputs % verbose . ge . 0 ) then write ( * , '(\"IN_BOUNDARY: Unknown boundary shape: \",i2)' ) bplane % shape endif stop END SELECT end function in_boundary subroutine boundary_edge ( bplane , bedge , nb ) !+ Returns 3 x `nb` array containing points along the BoundedPlane's boundary edge type ( BoundedPlane ), intent ( in ) :: bplane !+ Bounded plane real ( Float64 ), dimension (:,:), intent ( out ) :: bedge !+ Boundary edge points of bounded plane integer , intent ( out ) :: nb !+ Number of points in boundary edge integer :: i real ( Float64 ) :: th , dth , x , y real ( Float64 ), dimension ( 4 ) :: xx , yy select case ( bplane % shape ) case ( 1 ) !Rectangular boundary nb = 4 if ( nb . gt . size ( bedge , 2 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(\"BOUNDARY_EDGE: Incompatible boundary edge array : \",i2,\" > \",i2)' ) nb , size ( bedge , 2 ) endif stop endif xx = [ - bplane % hw , - bplane % hw , bplane % hw , bplane % hw ] yy = [ - bplane % hh , bplane % hh , bplane % hh , - bplane % hh ] do i = 1 , nb bedge (:, i ) = matmul ( bplane % basis ,[ xx ( i ), yy ( i ), 0.d0 ]) + bplane % origin enddo case ( 2 ) nb = 50 if ( nb . gt . size ( bedge , 2 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(\"BOUNDARY_EDGE: Incompatible boundary edge array : \",i2,\" > \",i2)' ) nb , size ( bedge , 2 ) endif stop endif dth = 2 * pi / nb do i = 1 , nb th = i * dth x = bplane % hw * cos ( th ) y = bplane % hh * sin ( th ) bedge (:, i ) = matmul ( bplane % basis ,[ x , y , 0.d0 ]) + bplane % origin enddo case default if ( inputs % verbose . ge . 0 ) then write ( * , '(\"BOUNDARY_EDGE: Unknown boundary shape: \",i2)' ) bplane % shape endif stop end select end subroutine boundary_edge subroutine gyro_surface ( fields , energy , pitch , gs ) !+ Calculates the surface of all possible trajectories type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields at guiding center real ( Float64 ), intent ( in ) :: energy !+ Energy of particle real ( Float64 ), intent ( in ) :: pitch !+ Particle pitch w.r.t the magnetic field type ( GyroSurface ), intent ( out ) :: gs !+ Gyro-surface integer :: i real ( Float64 ) :: alpha , vabs , omega real ( Float64 ), dimension ( 3 , 3 ) :: s vabs = sqrt ( energy / ( v2_to_E_per_amu * inputs % ab )) omega = ( fields % b_abs * e0 ) / ( inputs % ab * mass_u ) alpha = vabs / omega gs % omega = omega gs % v = vabs gs % axes ( 1 ) = alpha * sqrt ( 1 - pitch ** 2 ) gs % axes ( 2 ) = alpha * sqrt ( 1 - pitch ** 2 ) gs % axes ( 3 ) = pitch * alpha s = 0.d0 s ( 1 , 1 ) = gs % axes ( 1 ) ** ( - 2 ) s ( 2 , 2 ) = gs % axes ( 2 ) ** ( - 2 ) s ( 3 , 3 ) = - gs % axes ( 3 ) ** ( - 2 ) gs % center = fields % pos gs % basis (:, 1 ) = fields % a_norm gs % basis (:, 2 ) = fields % c_norm gs % basis (:, 3 ) = fields % b_norm gs % A = matmul ( gs % basis , matmul ( s , transpose ( gs % basis ))) end subroutine gyro_surface subroutine line_gyro_surface_intersect ( r0 , v0 , gs , t ) !+ Calculates the times of intersection of a line and a gyro-surface real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Point on line real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Direction of line type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-surface real ( Float64 ), dimension ( 2 ), intent ( out ) :: t !+ \"time\" to intersect real ( Float64 ), dimension ( 3 ) :: rr real ( Float64 ) :: a , b , c , d , tp , tm rr = r0 - gs % center a = dot_product ( v0 , matmul ( gs % A , v0 )) b = dot_product ( rr , matmul ( gs % A , v0 )) + dot_product ( v0 , matmul ( gs % A , rr )) c = dot_product ( rr , matmul ( gs % A , rr )) - 1.0 d = b ** 2 - 4 * a * c if ( d . lt . 0.0 ) then t = 0.0 return endif t ( 1 ) = ( - b - sqrt ( d )) / ( 2 * a ) t ( 2 ) = ( - b + sqrt ( d )) / ( 2 * a ) end subroutine line_gyro_surface_intersect subroutine gyro_surface_coordinates ( gs , p , u ) !+ Calculates the parametric coordinates, `u`, of point `p` on the gyro_surface type ( GyroSurface ), intent ( in ) :: gs !+ Gyro_surface real ( Float64 ), dimension ( 3 ), intent ( in ) :: p !+ Point on gyro_surface real ( Float64 ), dimension ( 2 ), intent ( out ) :: u !+ Parametric coordinates (gyro-angle, t) real ( Float64 ), dimension ( 3 ) :: pp real ( Float64 ) :: t , a , b , c , d , thm , thp , dp , dm , th integer :: i pp = matmul ( transpose ( gs % basis ), p - gs % center ) t = pp ( 3 ) / gs % axes ( 3 ) a = gs % axes ( 1 ) + gs % axes ( 2 ) * t b = gs % axes ( 2 ) - gs % axes ( 1 ) * t d = pp ( 1 ) + pp ( 2 ) c = max ( min ( d / sqrt ( a ** 2 + b ** 2 ), 1.d0 ), - 1.d0 ) thm = - acos ( c ) + atan2 ( b , a ) thp = acos ( c ) + atan2 ( b , a ) dm = norm2 ([ gs % axes ( 1 ) * ( cos ( thm ) - t * sin ( thm )), & gs % axes ( 2 ) * ( sin ( thm ) + t * cos ( thm )), & gs % axes ( 3 ) * t ] - pp ) dp = norm2 ([ gs % axes ( 1 ) * ( cos ( thp ) - t * sin ( thp )), & gs % axes ( 2 ) * ( sin ( thp ) + t * cos ( thp )), & gs % axes ( 3 ) * t ] - pp ) th = thm - pi / 2 if ( dp . le . dm ) th = thp - pi / 2 if ( th . lt . 0.0 ) th = th + 2 * pi u = [ th , t / gs % omega ] end subroutine gyro_surface_coordinates subroutine gyro_trajectory ( gs , theta , ri , vi ) !+ Calculate particle trajectory for a given gyro-angle and gyro-surface type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-Surface real ( Float64 ), intent ( in ) :: theta !+ Gyro-angle real ( Float64 ), dimension ( 3 ) :: ri !+ Particle position real ( Float64 ), dimension ( 3 ) :: vi !+ Particle Velocity real ( Float64 ) :: a , b , c , th a = gs % axes ( 1 ) b = gs % axes ( 2 ) c = gs % axes ( 3 ) th = theta + pi / 2 ri = matmul ( gs % basis , [ a * cos ( th ), b * sin ( th ), 0.d0 ]) + gs % center vi = gs % omega * matmul ( gs % basis , [ - a * sin ( th ), b * cos ( th ), c ]) end subroutine gyro_trajectory function in_gyro_surface ( gs , p ) result ( in_gs ) !+ Indicator function for determining if a point is inside the gyro_surface type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-surface real ( Float64 ), dimension ( 3 ), intent ( in ) :: p !+ Point logical :: in_gs real ( Float64 ), dimension ( 3 ) :: pp pp = p - gs % center in_gs = dot_product ( pp , matmul ( gs % A , pp )). le . 1.d0 end function in_gyro_surface subroutine gyro_range ( b , gs , gyrange , nrange ) !+ Calculates the range(s) of gyro-angles that would land within a bounded plane type ( BoundedPlane ), intent ( in ) :: b !+ Bounded Plane type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-surface real ( Float64 ), dimension ( 2 , 4 ), intent ( out ) :: gyrange !+ (theta, dtheta) values integer , intent ( out ) :: nrange !+ Number of ranges. `1 <= nrange <= 4` integer :: nb , i , j , ninter logical :: in_gs logical , dimension ( 8 ) :: cross = . False . real ( Float64 ) :: t_p , th1 , th2 , dth real ( Float64 ), dimension ( 2 ) :: u_cur , t_i real ( Float64 ), dimension ( 3 ) :: rc , p_pre , p_cur , v0 , ri real ( Float64 ), dimension ( 2 , 8 ) :: u real ( Float64 ), dimension ( 3 , 50 ) :: bedge nrange = 0 gyrange = 0.d0 call line_plane_intersect ( gs % center , gs % basis (:, 3 ), b % origin , b % basis (:, 3 ), rc , t_p ) if ( t_p . eq . 0.0 ) return call boundary_edge ( b , bedge , nb ) p_pre = bedge (:, 1 ) in_gs = in_gyro_surface ( gs , p_pre ) ninter = 0 u = 0.d0 boundary_loop : do i = 1 , nb p_cur = bedge (:, modulo ( i , nb ) + 1 ) v0 = p_cur - p_pre call line_gyro_surface_intersect ( p_pre , v0 , gs , t_i ) do j = 1 , 2 if (( t_i ( j ). gt . 0.0 ). and .( t_i ( j ). lt . 1.0 )) then ri = p_pre + t_i ( j ) * v0 call gyro_surface_coordinates ( gs , ri , u_cur ) if ( u_cur ( 2 ). gt . 0.0 ) then in_gs = . not . in_gs ninter = ninter + 1 cross ( ninter ) = in_gs u (:, ninter ) = u_cur endif endif enddo p_pre = p_cur enddo boundary_loop if ( ninter . eq . 0 ) then if ( in_boundary ( b , rc )) then nrange = 1 gyrange (:, 1 ) = [ 0.d0 , 2 * pi ] endif return endif do i = 1 , ninter if ( cross ( i )) then th1 = u ( 1 , i ) j = modulo ( i , ninter ) + 1 th2 = u ( 1 , j ) dth = th2 - th1 nrange = nrange + 1 if ( dth . gt . 0.0 ) then gyrange (:, nrange ) = [ th1 , dth ] else gyrange (:, nrange ) = [ th2 , - dth ] endif endif !! OpenMP with multiple threads is duplicating gyro-ranges for some markers !! causing double counting and I don't know why. !! It should be very unlikely for multiple gyro-ranges to occur so for !! now I'm including this cludge to force only one gyro-range when using !! OpenMP. #ifdef _OMP if ( nrange . eq . 1 ) exit #endif enddo end subroutine gyro_range subroutine npa_gyro_range ( ichan , gs , gyrange , nrange ) !+ Calculates range of gyro-angles that would hit the NPA detector integer , intent ( in ) :: ichan !+ Index of NPA detector type ( GyroSurface ), intent ( in ) :: gs real ( Float64 ), dimension ( 2 , 4 ), intent ( out ) :: gyrange integer , intent ( out ) :: nrange type ( LocalEMFields ) :: fields integer :: i , j , a_nrange , d_nrange real ( Float64 ) :: a0 , a , b , c , d real ( Float64 ), dimension ( 2 , 4 ) :: a_gyrange , d_gyrange nrange = 0 gyrange = 0.d0 call gyro_range ( npa_chords % det ( ichan )% aperture , gs , a_gyrange , a_nrange ) if ( a_nrange . eq . 0 ) return call gyro_range ( npa_chords % det ( ichan )% detector , gs , d_gyrange , d_nrange ) if ( d_nrange . eq . 0 ) return if (( a_nrange . eq . 1 ). and . approx_eq ( a_gyrange ( 2 , 1 ), 2 * pi , 1 d - 6 )) then gyrange = d_gyrange nrange = d_nrange return endif if (( d_nrange . eq . 1 ). and . approx_eq ( d_gyrange ( 2 , 1 ), 2 * pi , 1 d - 6 )) then gyrange = a_gyrange nrange = a_nrange return endif do i = 1 , a_nrange do j = 1 , d_nrange a0 = 0.d0 if ( d_gyrange ( 1 , j ). gt . a_gyrange ( 1 , i )) then a0 = a_gyrange ( 1 , i ) a = 0.d0 b = modulo ( a_gyrange ( 1 , i ) + a_gyrange ( 2 , i ) - a0 , 2 * pi ) c = modulo ( d_gyrange ( 1 , j ) - a0 , 2 * pi ) d = modulo ( d_gyrange ( 1 , j ) + d_gyrange ( 2 , j ) - a0 , 2 * pi ) else a0 = d_gyrange ( 1 , j ) a = 0.d0 b = modulo ( d_gyrange ( 1 , j ) + d_gyrange ( 2 , j ) - a0 , 2 * pi ) c = modulo ( a_gyrange ( 1 , i ) - a0 , 2 * pi ) d = modulo ( a_gyrange ( 1 , i ) + a_gyrange ( 2 , i ) - a0 , 2 * pi ) endif if (( c . lt . b ). or .( d . lt . c )) then if ( c . lt . d ) then nrange = nrange + 1 gyrange (:, nrange ) = [ a0 + c , min ( d - c , b - c )] else nrange = nrange + 1 gyrange (:, nrange ) = [ a0 , d ] nrange = nrange + 1 gyrange (:, nrange ) = [ a0 + c , b - c ] endif endif enddo enddo end subroutine npa_gyro_range subroutine hit_npa_detector ( r0 , v0 , d_index , rd , det ) !+ Routine to check if a particle will hit a NPA detector real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Starting point of particle real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Particle velocity integer , intent ( out ) :: d_index !+ Index of NPA detector. Zero if particle doesn't hit real ( Float64 ), dimension ( 3 ), intent ( out ), optional :: rd !+ Point where particle hit detector integer , intent ( in ), optional :: det !+ Index of NPA detector to check real ( Float64 ), dimension ( 3 ) :: d , a real ( Float64 ) :: t_a , t_d integer :: i , s , ndet if ( present ( det )) then s = det ndet = det else s = 1 ndet = npa_chords % nchan endif d_index = 0 detector_loop : do i = s , ndet !! Find where trajectory crosses detector plane call line_plane_intersect ( r0 , v0 , npa_chords % det ( i )% detector % origin , & npa_chords % det ( i )% detector % basis (:, 3 ), d , t_d ) !! Find where trajectory crosses aperture plane call line_plane_intersect ( r0 , v0 , npa_chords % det ( i )% aperture % origin , & npa_chords % det ( i )% aperture % basis (:, 3 ), a , t_a ) !! If both points are in plane boundaries and the !! particle is heading toward the detector then its a hit if ( in_boundary ( npa_chords % det ( i )% aperture , a ) . and . & in_boundary ( npa_chords % det ( i )% detector , d ) . and . & ( t_d . gt . 0.0 ) ) then d_index = i exit detector_loop endif enddo detector_loop if ( present ( rd )) rd = d end subroutine hit_npa_detector subroutine xyz_to_uvw ( xyz , uvw ) !+ Convert beam coordinate `xyz` to machine coordinate `uvw` real ( Float64 ), dimension ( 3 ), intent ( in ) :: xyz real ( Float64 ), dimension ( 3 ), intent ( out ) :: uvw real ( Float64 ), dimension ( 3 ) :: origin real ( Float64 ), dimension ( 3 , 3 ) :: basis origin = beam_grid % origin basis = beam_grid % basis uvw = matmul ( basis , xyz ) uvw = uvw + origin end subroutine xyz_to_uvw subroutine xyz_to_cyl ( xyz , cyl ) !+ Convert beam coordinate `xyz` to cylindrical coordinate `cyl` real ( Float64 ), dimension ( 3 ), intent ( in ) :: xyz real ( Float64 ), dimension ( 3 ), intent ( out ) :: cyl real ( Float64 ), dimension ( 3 ) :: uvw call xyz_to_uvw ( xyz , uvw ) call uvw_to_cyl ( uvw , cyl ) end subroutine xyz_to_cyl subroutine uvw_to_xyz ( uvw , xyz ) !+ Convert machine coordinate `uvw` to beam coordinate `xyz` real ( Float64 ), dimension ( 3 ), intent ( in ) :: uvw real ( Float64 ), dimension ( 3 ), intent ( out ) :: xyz real ( Float64 ), dimension ( 3 ) :: origin , uvw_p real ( Float64 ), dimension ( 3 , 3 ) :: basis origin = beam_grid % origin basis = beam_grid % inv_basis uvw_p = uvw - origin xyz = matmul ( basis , uvw_p ) end subroutine uvw_to_xyz subroutine cyl_to_uvw ( cyl , uvw ) !+ Convert cylindrical coordinate `cyl` to machine coordinate `uvw` real ( Float64 ), dimension ( 3 ), intent ( in ) :: cyl real ( Float64 ), dimension ( 3 ), intent ( out ) :: uvw uvw ( 1 ) = cyl ( 1 ) * cos ( cyl ( 3 )) uvw ( 2 ) = cyl ( 1 ) * sin ( cyl ( 3 )) uvw ( 3 ) = cyl ( 2 ) end subroutine cyl_to_uvw subroutine cyl_to_xyz ( cyl , xyz ) !+ Convert cylindrical coordinate `cyl` to beam coordinate `xyz` real ( Float64 ), dimension ( 3 ), intent ( in ) :: cyl real ( Float64 ), dimension ( 3 ), intent ( out ) :: xyz real ( Float64 ), dimension ( 3 ) :: uvw call cyl_to_uvw ( cyl , uvw ) call uvw_to_xyz ( uvw , xyz ) end subroutine cyl_to_xyz subroutine uvw_to_cyl ( uvw , cyl ) !+ Convert machine coordinate `uvw` to cylindrical coordinate `cyl` real ( Float64 ), dimension ( 3 ), intent ( in ) :: uvw real ( Float64 ), dimension ( 3 ), intent ( out ) :: cyl cyl ( 1 ) = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) cyl ( 2 ) = uvw ( 3 ) cyl ( 3 ) = atan2 ( uvw ( 2 ), uvw ( 1 )) end subroutine uvw_to_cyl subroutine grid_intersect ( r0 , v0 , length , r_enter , r_exit , center_in , lwh_in , passive ) !+ Calculates a particles intersection length with the [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Initial position of particle [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Velocity of particle [cm/s] real ( Float64 ), intent ( out ) :: length !+ Intersection length [cm] real ( Float64 ), dimension ( 3 ), intent ( out ) :: r_enter !+ Point where particle enters real ( Float64 ), dimension ( 3 ), intent ( out ) :: r_exit !+ Point where particle exits real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: center_in !+ Alternative grid center real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: lwh_in !+ Alternative grid [length,width,height] logical , intent ( in ), optional :: passive !+ Calculates a particles intersection length with the [[libfida:pass_grid]] real ( Float64 ), dimension ( 3 , 6 ) :: ipnts real ( Float64 ), dimension ( 3 ) :: ri , vi real ( Float64 ), dimension ( 3 ) :: center real ( Float64 ), dimension ( 3 ) :: lwh integer , dimension ( 6 ) :: side_inter integer , dimension ( 2 ) :: ind integer :: i , j , nunique , ind1 , ind2 real ( Float64 ) :: dlength , max_length logical :: ing , pas pas = . False . if ( present ( passive )) pas = passive if ( pas ) then ing = in_passive_grid ( r0 ) if ( ing ) then length = 0.d0 return endif ri = r0 ; vi = v0 dlength = 2.0 !cm max_length = 0.0 do while (. not . ing ) ri = ri + vi * dlength ! move dlength ing = in_passive_grid ( ri ) max_length = max_length + dlength if ( max_length . gt . 1 d3 ) then length = 0.d0 return endif enddo r_enter = ri do while ( ing ) ri = ri + vi * dlength ing = in_passive_grid ( ri ) enddo r_exit = ri length = sqrt ( sum (( r_exit - r_enter ) ** 2 )) else if ( present ( center_in )) then center = center_in else center = beam_grid % center endif if ( present ( lwh_in )) then lwh = lwh_in else lwh = beam_grid % lwh endif side_inter = 0 ipnts = 0.d0 do i = 1 , 6 j = int ( ceiling ( i / 2.0 )) if ( j . eq . 1 ) ind = [ 2 , 3 ] if ( j . eq . 2 ) ind = [ 1 , 3 ] if ( j . eq . 3 ) ind = [ 1 , 2 ] if ( abs ( v0 ( j )). gt . 0.d0 ) then ipnts (:, i ) = r0 + v0 * ( ( ( center ( j ) + & ( mod ( i , 2 ) - 0.5 ) * lwh ( j )) - r0 ( j )) / v0 ( j ) ) if (( abs ( ipnts ( ind ( 1 ), i ) - center ( ind ( 1 ))). le .( 0.5 * lwh ( ind ( 1 )))). and . & ( abs ( ipnts ( ind ( 2 ), i ) - center ( ind ( 2 ))). le .( 0.5 * lwh ( ind ( 2 ))))) then side_inter ( i ) = 1 endif endif enddo length = 0.d0 r_enter = r0 r_exit = r0 ind1 = 0 ind2 = 0 if ( sum ( side_inter ). ge . 2 ) then ! Find first intersection side i = 1 do while ( i . le . 6 ) if ( side_inter ( i ). eq . 1 ) exit i = i + 1 enddo ind1 = i !Find number of unique points nunique = 0 do i = ind1 + 1 , 6 if ( side_inter ( i ). ne . 1 ) cycle if ( sqrt ( sum ( ( ipnts (:, i ) - ipnts (:, ind1 ) ) ** 2 ) ). gt . 0.001 ) then ind2 = i nunique = 2 exit endif enddo if ( nunique . eq . 2 ) then vi = ipnts (:, ind2 ) - ipnts (:, ind1 ) if ( dot_product ( v0 , vi ). gt . 0.0 ) then r_enter = ipnts (:, ind1 ) r_exit = ipnts (:, ind2 ) else r_enter = ipnts (:, ind2 ) r_exit = ipnts (:, ind1 ) endif length = sqrt ( sum (( r_exit - r_enter ) ** 2 )) endif endif endif end subroutine grid_intersect function in_grid ( xyz ) result ( ing ) !+ Determines if a position `pos` is in the [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: xyz !+ Position in beam grid coordinates [cm] logical :: ing !+ Indicates whether the position is in the beam grid real ( Float64 ) :: tol = 1.0d-10 if (( approx_ge ( xyz ( 1 ), beam_grid % xmin , tol ). and . approx_le ( xyz ( 1 ), beam_grid % xmax , tol )). and . & ( approx_ge ( xyz ( 2 ), beam_grid % ymin , tol ). and . approx_le ( xyz ( 2 ), beam_grid % ymax , tol )). and . & ( approx_ge ( xyz ( 3 ), beam_grid % zmin , tol ). and . approx_le ( xyz ( 3 ), beam_grid % zmax , tol ))) then ing = . True . else ing = . False . endif end function function in_passive_grid ( uvw ) result ( ing ) !+ Determines if a position `pos` is in the [[libfida:pass_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: uvw !+ Position in machine coordinates [cm] logical :: ing !+ Indicates whether the position is in the passive neutral grid real ( Float64 ), dimension ( 3 ) :: cyl real ( Float64 ) :: phimin , phimax real ( Float64 ) :: tol = 1.0d-10 phimin = minval ( pass_grid % phi ) phimax = maxval ( pass_grid % phi ) call uvw_to_cyl ( uvw , cyl ) if (( approx_ge ( cyl ( 1 ), minval ( pass_grid % r ), tol ). and . approx_le ( cyl ( 1 ), maxval ( pass_grid % r ), tol )). and . & ( approx_ge ( cyl ( 2 ), minval ( pass_grid % z ), tol ). and . approx_le ( cyl ( 2 ), maxval ( pass_grid % z ), tol )). and . & (( approx_ge ( cyl ( 3 ), phimin , tol ). and . approx_le ( cyl ( 3 ), phimax , tol )). or . & ( approx_ge ( modulo ( cyl ( 3 ), 2 * pi ), phimin , tol ). and . approx_le ( modulo ( cyl ( 3 ), 2 * pi ), phimax , tol )))) then ing = . True . else ing = . False . endif end function subroutine circle_grid_intersect ( r0 , e1 , e2 , radius , beam_grid_phi_enter , beam_grid_phi_exit ) !+ Calculates the intersection arclength of a circle with the [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Position of center enter of the circle in beam grid coordinates [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: e1 !+ Unit vector pointing towards (R, 0) (r,phi) position of the circle in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: e2 !+ Unit vector pointing towards (R, pi/2) (r,phi) position of the circle in beam grid coordinates real ( Float64 ), intent ( in ) :: radius !+ Radius of circle [cm] real ( Float64 ), intent ( out ) :: beam_grid_phi_enter !+ Phi value where the circle entered the [[libfida:beam_grid]] [rad] real ( Float64 ), intent ( out ) :: beam_grid_phi_exit !+ Phi value where the circle exits the [[libfida:beam_grid]] [rad] real ( Float64 ), dimension ( 3 ) :: i1_p , i1_n , i2_p , i2_n real ( Float64 ), dimension ( 4 ) :: d real ( Float64 ), dimension ( 6 ) :: p , gams real ( Float64 ), dimension ( 4 , 6 ) :: phi logical , dimension ( 4 , 6 ) :: inter integer , dimension ( 6 ) :: n integer :: i real ( Float64 ) :: alpha , beta , delta , sinx1 , cosx1 , sinx2 , cosx2 , tmp real ( Float64 ) :: tol = 1.0d-10 logical :: r0_ing p = [ beam_grid % xmin , beam_grid % xmax , & beam_grid % ymin , beam_grid % ymax , & beam_grid % zmin , beam_grid % zmax ] n = [ 1 , 1 , 2 , 2 , 3 , 3 ] inter = . False . phi = 0.d0 r0_ing = in_grid ( r0 ) do i = 1 , 6 alpha = e2 ( n ( i )) beta = e1 ( n ( i )) if (( alpha . eq . 0.0 ). and .( beta . eq . 0.0 )) cycle gams ( i ) = ( p ( i ) - r0 ( n ( i ))) / radius delta = alpha ** 4 + ( alpha ** 2 ) * ( beta ** 2 - gams ( i ) ** 2 ) if ( delta . ge . 0.0 ) then cosx1 = ( gams ( i ) * beta + sqrt ( delta )) / ( alpha ** 2 + beta ** 2 ) if (( cosx1 ** 2 ). le . 1.0 ) then sinx1 = sqrt ( 1 - cosx1 ** 2 ) i1_p = r0 + radius * cosx1 * e1 + radius * sinx1 * e2 i1_n = r0 + radius * cosx1 * e1 - radius * sinx1 * e2 if ( approx_eq ( i1_p ( n ( i )), p ( i ), tol ). and . in_grid ( i1_p )) then inter ( 1 , i ) = . True . phi ( 1 , i ) = atan2 ( sinx1 , cosx1 ) endif if ( approx_eq ( i1_n ( n ( i )), p ( i ), tol ). and . in_grid ( i1_n )) then inter ( 2 , i ) = . True . phi ( 2 , i ) = atan2 ( - sinx1 , cosx1 ) endif endif if ( delta . gt . 0.0 ) then cosx2 = ( gams ( i ) * beta - sqrt ( delta )) / ( alpha ** 2 + beta ** 2 ) if (( cosx2 ** 2 ). le . 1.0 ) then sinx2 = sqrt ( 1 - cosx2 ** 2 ) i2_p = r0 + radius * cosx2 * e1 + radius * sinx2 * e2 i2_n = r0 + radius * cosx2 * e1 - radius * sinx2 * e2 if ( approx_eq ( i2_p ( n ( i )), p ( i ), tol ). and . in_grid ( i2_p )) then inter ( 3 , i ) = . True . phi ( 3 , i ) = atan2 ( sinx2 , cosx2 ) endif if ( approx_eq ( i2_n ( n ( i )), p ( i ), tol ). and . in_grid ( i2_n )) then inter ( 4 , i ) = . True . phi ( 4 , i ) = atan2 ( - sinx2 , cosx2 ) endif endif endif endif enddo beam_grid_phi_enter = 0.d0 beam_grid_phi_exit = 0.d0 if ( count ( inter ). gt . 2 ) then write ( * , '(\"CIRCLE_GRID_INTERSECT: Circle intersects grid more than 2 times: \",i2)' ) count ( inter ) return endif if ( any ( inter )) then beam_grid_phi_enter = minval ( phi , inter ) beam_grid_phi_exit = maxval ( phi , inter ) if ( r0_ing . and . any ( count ( inter , 1 ). ge . 2 )) then if (( beam_grid_phi_exit - beam_grid_phi_enter ) . lt . pi ) then tmp = beam_grid_phi_enter beam_grid_phi_enter = beam_grid_phi_exit beam_grid_phi_exit = tmp + 2 * pi endif else if (( beam_grid_phi_exit - beam_grid_phi_enter ) . gt . pi ) then tmp = beam_grid_phi_enter beam_grid_phi_enter = beam_grid_phi_exit beam_grid_phi_exit = tmp + 2 * pi endif endif if ( approx_eq ( beam_grid_phi_exit - beam_grid_phi_enter , pi , tol ). and . r0_ing ) then beam_grid_phi_enter = 0.0 beam_grid_phi_exit = 2 * pi endif else if ( r0_ing ) then call grid_intersect ( r0 , e1 , tmp , i1_n , i1_p ) call grid_intersect ( r0 , e2 , tmp , i2_n , i2_p ) d ( 1 ) = norm2 ( r0 - i1_n ) / radius d ( 2 ) = norm2 ( r0 - i1_p ) / radius d ( 3 ) = norm2 ( r0 - i2_n ) / radius d ( 4 ) = norm2 ( r0 - i2_p ) / radius if ( all ( d . ge . 1.0 )) then beam_grid_phi_enter = 0.d0 beam_grid_phi_exit = 2.d0 * pi endif endif endif end subroutine circle_grid_intersect subroutine get_indices ( pos , ind ) !+ Find closests [[libfida:beam_grid]] indices `ind` to position `pos` real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position [cm] integer ( Int32 ), dimension ( 3 ), intent ( out ) :: ind !+ Closest indices to position real ( Float64 ), dimension ( 3 ) :: mini integer ( Int32 ), dimension ( 3 ) :: maxind integer :: i maxind ( 1 ) = beam_grid % nx maxind ( 2 ) = beam_grid % ny maxind ( 3 ) = beam_grid % nz mini ( 1 ) = minval ( beam_grid % xc ) - 0.5 * beam_grid % dr ( 1 ) mini ( 2 ) = minval ( beam_grid % yc ) - 0.5 * beam_grid % dr ( 2 ) mini ( 3 ) = minval ( beam_grid % zc ) - 0.5 * beam_grid % dr ( 3 ) do i = 1 , 3 ind ( i ) = floor (( pos ( i ) - mini ( i )) / beam_grid % dr ( i )) + 1 if ( ind ( i ). gt . maxind ( i )) ind ( i ) = maxind ( i ) if ( ind ( i ). lt . 1 ) ind ( i ) = 1 enddo end subroutine get_indices subroutine get_passive_grid_indices ( pos , ind , input_coords ) !+ Find closest [[libfida:pass_grid]] indices `ind` to position `pos` real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position [cm] integer ( Int32 ), dimension ( 3 ), intent ( out ) :: ind !+ Closest indices to position integer , intent ( in ), optional :: input_coords !+ Indicates coordinate system of `pos`. Beam grid (0), machine (1) and cylindrical (2) real ( Float64 ), dimension ( 3 ) :: mini , differentials , loc integer ( Int32 ), dimension ( 3 ) :: maxind integer :: i , ics if ( present ( input_coords )) then ics = input_coords else ics = 2 endif if ( ics . eq . 1 ) then loc ( 1 ) = sqrt ( pos ( 1 ) * pos ( 1 ) + pos ( 2 ) * pos ( 2 )) loc ( 2 ) = pos ( 3 ) loc ( 3 ) = atan2 ( pos ( 2 ), pos ( 1 )) endif if ( ics . eq . 2 ) then loc ( 1 ) = pos ( 1 ) loc ( 2 ) = pos ( 2 ) loc ( 3 ) = pos ( 3 ) endif maxind ( 1 ) = pass_grid % nr maxind ( 2 ) = pass_grid % nz maxind ( 3 ) = pass_grid % nphi mini ( 1 ) = minval ( pass_grid % r ) mini ( 2 ) = minval ( pass_grid % z ) mini ( 3 ) = minval ( pass_grid % phi ) differentials ( 1 ) = pass_grid % dr differentials ( 2 ) = pass_grid % dz differentials ( 3 ) = pass_grid % dphi do i = 1 , 3 ind ( i ) = floor (( loc ( i ) - mini ( i )) / differentials ( i )) + 1 if ( ind ( i ). gt . maxind ( i )) ind ( i ) = maxind ( i ) if ( ind ( i ). lt . 1 ) ind ( i ) = 1 enddo end subroutine get_passive_grid_indices subroutine get_plasma_extrema ( r0 , v0 , extrema , x0 , y0 ) !+ Returns extrema points where line(s) parametrized by `r0` and `v0` intersect the plasma boudnary real ( Float64 ), dimension (:,:), intent ( in ) :: r0 , v0 !+ Arrays the define line(s) in machine coordinates real ( Float64 ), dimension ( 2 , 3 ), intent ( out ) :: extrema !+ Minimum and maximumm R, Z, and Phi points real ( Float64 ), dimension (:), intent ( in ), optional :: x0 , y0 !+ Additional x and y points to consider real ( Float64 ), dimension (:,:), allocatable :: xy_in , xy_out real ( Float64 ), dimension (:,:), allocatable :: cyl_in , cyl_out real ( Float64 ), dimension (:), allocatable :: x , y , xlo , xhi real ( Float64 ), dimension (:), allocatable :: r , z , phi logical , dimension (:), allocatable :: skip real ( Float64 ), dimension ( 3 ) :: ri , vi real ( Float64 ) :: max_length , dlength integer :: i , iin , iout , ilo , ihi , dlo , dhi , dim , nlines , d logical :: inp nlines = size ( r0 ( 1 ,:)) allocate ( xy_in ( 2 , nlines ), xy_out ( 2 , nlines )) allocate ( cyl_in ( 3 , nlines ), cyl_out ( 3 , nlines )) allocate ( skip ( nlines )) dlength = 3.0 !cm skip = . False . loop_over_channels : do i = 1 , nlines ri = r0 (:, i ) vi = v0 (:, i ) vi = vi / norm2 ( vi ) ! Find the position that the los first intersects the plasma call in_plasma ( ri , inp , input_coords = 1 ) max_length = 0.0 do while (. not . inp ) ri = ri + vi * dlength ! move dlength call in_plasma ( ri , inp , input_coords = 1 ) max_length = max_length + dlength if ( max_length . gt . 1 d9 ) then skip ( i ) = . True . !used below to skip los that do not intersect the plasma cycle loop_over_channels endif enddo xy_in ( 1 , i ) = ri ( 1 ) ; xy_in ( 2 , i ) = ri ( 2 ) call uvw_to_cyl ( ri , cyl_in (:, i )) ! Find the position that the los intersects upon exiting the plasma do while ( inp ) ri = ri + vi * dlength call in_plasma ( ri , inp , input_coords = 1 ) enddo xy_out ( 1 , i ) = ri ( 1 ) ; xy_out ( 2 , i ) = ri ( 2 ) call uvw_to_cyl ( ri , cyl_out (:, i )) enddo loop_over_channels dim = 2 * count (. not . skip ) ! 2 for enter and exit d = 0 if ( present ( x0 ). and . present ( y0 )) then d = size ( x0 ) if ( size ( x0 ). ne . size ( y0 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(\"GET_PLASMA_EXTREMA: Sizes of X and Y input arrays are not identical\")' ) stop endif endif endif allocate ( x ( dim + d ), y ( dim + d ), r ( dim ), z ( dim ), phi ( dim )) iin = 1 ; iout = 2 do i = 1 , nlines if (. not . skip ( i )) then x ( iin ) = xy_in ( 1 , i ) ; x ( iout ) = xy_out ( 1 , i ) y ( iin ) = xy_in ( 2 , i ) ; y ( iout ) = xy_out ( 2 , i ) r ( iin ) = cyl_in ( 1 , i ) ; r ( iout ) = cyl_out ( 1 , i ) z ( iin ) = cyl_in ( 2 , i ) ; z ( iout ) = cyl_out ( 2 , i ) iin = iin + 2 ; iout = iout + 2 endif enddo extrema ( 1 , 1 ) = minval ( r ) ; extrema ( 2 , 1 ) = maxval ( r ) extrema ( 1 , 2 ) = minval ( z ) ; extrema ( 2 , 2 ) = maxval ( z ) ! Append extra x and y points if ( d . gt . 0 ) then x ( dim + 1 : dim + d ) = x0 y ( dim + 1 : dim + d ) = y0 endif !! Domain is between 0 and 2 pi if all x points are left of the line x=0 !! Else domain is between -pi and pi dlo = count ( y . le . 0 ) ; dhi = count ( y . gt . 0 ) allocate ( xlo ( dlo ), xhi ( dhi )) ilo = 0 ; ihi = 0 do i = 1 , size ( x ) if ( y ( i ). le . 0.d10 ) then ilo = ilo + 1 xlo ( ilo ) = x ( i ) else ihi = ihi + 1 xhi ( ihi ) = x ( i ) endif enddo phi = atan2 ( y , x ) if ( all ( x . le . 0 ) & !none in quadrant 1 and 4 . or .( all ( xlo . le . 0 ). and .( size ( x ). ne . size ( xhi ))) & !quadrant 3 . or .( all ( xhi . le . 0 ). and .( size ( x ). ne . size ( xlo )))) then !quadrant 2 phi = modulo ( phi , 2 * pi ) endif extrema ( 1 , 3 ) = minval ( phi ) ; extrema ( 2 , 3 ) = maxval ( phi ) end subroutine get_plasma_extrema subroutine get_position ( ind , pos , input_coords ) !+ Get position `pos` given indices `ind` integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ Indices real ( Float64 ), dimension ( 3 ), intent ( out ) :: pos !+ Position in [[libfida:beam_grid]] coordinates [cm] integer , intent ( in ), optional :: input_coords !+ Indicates coordinate system of `ind`. Beam grid (0) and cylindrical (2) real ( Float64 ), dimension ( 3 ) :: pos_temp1 , pos_temp2 integer :: ics , ocs if ( present ( input_coords )) then ics = input_coords else ics = 0 endif if ( ics . eq . 0 ) then pos ( 1 ) = beam_grid % xc ( ind ( 1 )) pos ( 2 ) = beam_grid % yc ( ind ( 2 )) pos ( 3 ) = beam_grid % zc ( ind ( 3 )) endif if ( ics . eq . 2 ) then pos_temp1 ( 1 ) = inter_grid % r ( ind ( 1 )) pos_temp1 ( 2 ) = inter_grid % z ( ind ( 2 )) pos_temp1 ( 3 ) = inter_grid % phi ( ind ( 3 )) call cyl_to_xyz ( pos_temp1 , pos ) endif end subroutine get_position subroutine track ( rin , vin , tracks , ntrack , los_intersect ) !+ Computes the path of a neutral through the [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: rin !+ Initial position of particle real ( Float64 ), dimension ( 3 ), intent ( in ) :: vin !+ Initial velocity of particle type ( ParticleTrack ), dimension (:), intent ( inout ) :: tracks !+ Array of [[ParticleTrack]] type integer ( Int32 ), intent ( out ) :: ntrack !+ Number of cells that a particle crosses logical , intent ( out ), optional :: los_intersect !+ Indicator whether particle intersects a LOS in [[libfida:spec_chords]] integer :: cc , i , j , ii , mind , ncross , id integer , dimension ( 3 ) :: ind logical :: in_plasma1 , in_plasma2 , in_plasma_tmp , los_inter real ( Float64 ) :: dT , dt1 , inv_50 real ( Float64 ), dimension ( 3 ) :: dt_arr , dr real ( Float64 ), dimension ( 3 ) :: vn , inv_vn , vp real ( Float64 ), dimension ( 3 ) :: ri , ri_tmp , ri_cell type ( LocalEMFields ) :: fields type ( LOSInters ) :: inter real ( Float64 ), dimension ( n_stark ) :: lambda integer , dimension ( 3 ) :: sgn integer , dimension ( 3 ) :: gdims vn = vin ; ri = rin ; sgn = 0 ; ntrack = 0 los_inter = . False . if (. not . present ( los_intersect )) then los_inter = . True . !avoids computation if not needed endif if ( dot_product ( vin , vin ). eq . 0.0 ) then return endif gdims ( 1 ) = beam_grid % nx gdims ( 2 ) = beam_grid % ny gdims ( 3 ) = beam_grid % nz !! define actual cell call get_indices ( ri , ind ) ri_cell = [ beam_grid % xc ( ind ( 1 )), & beam_grid % yc ( ind ( 2 )), & beam_grid % zc ( ind ( 3 ))] do i = 1 , 3 if ( vn ( i ). gt . 0.0 ) sgn ( i ) = 1 if ( vn ( i ). lt . 0.0 ) sgn ( i ) =- 1 if ( vn ( i ). eq . 0.0 ) vn ( i ) = 1.0d-3 enddo dr = beam_grid % dr * sgn inv_vn = 1 / vn inv_50 = 1.0 / 5 0.0 cc = 1 tracks % time = 0.d0 tracks % flux = 0.d0 ncross = 0 call in_plasma ( ri , in_plasma1 ) track_loop : do i = 1 , beam_grid % ntrack if ( cc . gt . beam_grid % ntrack ) exit track_loop dt_arr = abs (( ( ri_cell + 0.5 * dr ) - ri ) * inv_vn ) mind = minloc ( dt_arr , 1 ) dT = dt_arr ( mind ) ri_tmp = ri + dT * vn !! Check if velocity intersects LOS and produces wavelength in the right region inter = spec_chords % inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) if ((. not . los_inter ). and .( inter % nchan . ne . 0 )) then call get_fields ( fields , pos = ri_tmp ) chan_loop : do j = 1 , inter % nchan id = inter % los_elem ( j )% id vp = ri_tmp - spec_chords % los ( id )% lens call doppler_stark ( vp , vn , fields , lambda ) los_inter = any (( lambda . ge . inputs % lambdamin ). and .( lambda . le . inputs % lambdamax )) if ( los_inter ) exit chan_loop enddo chan_loop endif call in_plasma ( ri_tmp , in_plasma2 ) if ( in_plasma1 . neqv . in_plasma2 ) then dt1 = 0.0 track_fine : do ii = 1 , 50 dt1 = dt1 + dT * inv_50 ri_tmp = ri + vn * dt1 call in_plasma ( ri_tmp , in_plasma_tmp ) if ( in_plasma2 . eqv . in_plasma_tmp ) exit track_fine enddo track_fine tracks ( cc )% pos = ri + 0.5 * dt1 * vn tracks ( cc + 1 )% pos = ri + 0.5 * ( dt1 + dT ) * vn tracks ( cc )% time = dt1 tracks ( cc + 1 )% time = dT - dt1 tracks ( cc )% ind = ind tracks ( cc + 1 )% ind = ind cc = cc + 2 ncross = ncross + 1 else tracks ( cc )% pos = ri + 0.5 * dT * vn tracks ( cc )% time = dT tracks ( cc )% ind = ind cc = cc + 1 endif in_plasma1 = in_plasma2 ri = ri + dT * vn ind ( mind ) = ind ( mind ) + sgn ( mind ) ri_cell ( mind ) = ri_cell ( mind ) + dr ( mind ) if ( ind ( mind ). gt . gdims ( mind )) exit track_loop if ( ind ( mind ). lt . 1 ) exit track_loop if ( ncross . ge . 2 ) then cc = cc - 1 !dont include last segment exit track_loop endif enddo track_loop ntrack = cc - 1 if ( present ( los_intersect )) then los_intersect = los_inter endif end subroutine track subroutine track_cylindrical ( rin , vin , tracks , ntrack , los_intersect ) !+ Computes the path of a neutral through the [[libfida:pass_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: rin !+ Initial position of particle real ( Float64 ), dimension ( 3 ), intent ( in ) :: vin !+ Initial velocity of particle type ( ParticleTrack ), dimension (:), intent ( inout ) :: tracks !+ Array of [[ParticleTrack]] type integer ( Int32 ), intent ( out ) :: ntrack !+ Number of cells that a particle crosses logical , intent ( out ), optional :: los_intersect !+ Indicator whether particle intersects a LOS in [[libfida:spec_chords]] real ( Float64 ), dimension ( 3 , 3 ) :: basis real ( Float64 ), dimension ( 3 ) :: dt_arr , dr !! Need to make this rzphi real ( Float64 ), dimension ( 3 ) :: vn , vn_cyl , vp real ( Float64 ), dimension ( 3 ) :: ri , ri_cyl , ri_tmp real ( Float64 ), dimension ( 3 ) :: p , nz real ( Float64 ), dimension ( 3 ) :: v_plane_cyl , v_plane real ( Float64 ), dimension ( 3 ) :: h_plane_cyl , h_plane real ( Float64 ), dimension ( 3 ) :: arc_cyl , arc real ( Float64 ), dimension ( 3 ) :: redge , tedge real ( Float64 ), dimension ( 3 ) :: redge_cyl , tedge_cyl integer , dimension ( 3 ) :: sgn integer , dimension ( 3 ) :: gdims integer , dimension ( 1 ) :: minpos integer , dimension ( 3 ) :: ind real ( Float64 ) :: dT , dt1 , inv_50 , t real ( Float64 ) :: s , c , phi integer :: cc , i , j , ii , mind , ncross , id type ( LocalEMFields ) :: fields type ( LOSInters ) :: inter real ( Float64 ), dimension ( n_stark ) :: lambda logical :: in_plasma1 , in_plasma2 , in_plasma_tmp , los_inter integer :: ir , iz , iphi vn = vin ; ri = rin ; sgn = 0 ; ntrack = 0 los_inter = . False . if (. not . present ( los_intersect )) then los_inter = . True . !avoids computation if not needed endif if ( dot_product ( vn , vn ). eq . 0.0 ) then return endif gdims ( 1 ) = pass_grid % nr gdims ( 2 ) = pass_grid % nz gdims ( 3 ) = pass_grid % nphi phi = atan2 ( rin ( 2 ), rin ( 1 )) s = sin ( phi ) ; c = cos ( phi ) vn_cyl ( 1 ) = c * vn ( 1 ) + s * vn ( 2 ) vn_cyl ( 3 ) = - s * vn ( 1 ) + c * vn ( 2 ) vn_cyl ( 2 ) = vn ( 3 ) do i = 1 , 3 !! sgn is in R-Z-Phi coordinates if ( vn_cyl ( i ). gt . 0.d0 ) then sgn ( i ) = 1 else if ( vn_cyl ( i ). lt . 0.d0 ) then sgn ( i ) =- 1 end if enddo dr ( 1 ) = pass_grid % dr * sgn ( 1 ) dr ( 2 ) = pass_grid % dz * sgn ( 2 ) dr ( 3 ) = pass_grid % dphi * sgn ( 3 ) !! Define actual cell ri_cyl ( 1 ) = sqrt ( ri ( 1 ) * ri ( 1 ) + ri ( 2 ) * ri ( 2 )) ri_cyl ( 2 ) = ri ( 3 ) ri_cyl ( 3 ) = atan2 ( ri ( 2 ), ri ( 1 )) call get_passive_grid_indices ( ri_cyl , ind ) arc_cyl ( 1 ) = pass_grid % r ( ind ( 1 )) arc_cyl ( 2 ) = pass_grid % z ( ind ( 2 )) arc_cyl ( 3 ) = pass_grid % phi ( ind ( 3 )) h_plane_cyl = arc_cyl v_plane_cyl = arc_cyl !! Define surfaces to intersect if ( sgn ( 1 ). gt . 0.d0 ) arc_cyl ( 1 ) = pass_grid % r ( ind ( 1 ) + 1 ) if ( sgn ( 2 ). gt . 0.d0 ) h_plane_cyl ( 2 ) = pass_grid % z ( ind ( 2 ) + 1 ) if ( sgn ( 3 ). gt . 0.d0 ) v_plane_cyl ( 3 ) = pass_grid % phi ( ind ( 3 ) + 1 ) ! Special case of the particle being on the surace handled below if (( sgn ( 1 ). lt . 0.d0 ). and .( arc_cyl ( 1 ). eq . ri_cyl ( 1 ))) then arc_cyl ( 1 ) = pass_grid % r ( ind ( 1 ) - 1 ) h_plane_cyl ( 1 ) = pass_grid % r ( ind ( 1 ) - 1 ) v_plane_cyl ( 1 ) = pass_grid % r ( ind ( 1 ) - 1 ) endif if (( sgn ( 2 ). lt . 0.d0 ). and .( h_plane_cyl ( 2 ). eq . ri_cyl ( 2 ))) then arc_cyl ( 2 ) = pass_grid % z ( ind ( 2 ) - 1 ) h_plane_cyl ( 2 ) = pass_grid % z ( ind ( 2 ) - 1 ) v_plane_cyl ( 2 ) = pass_grid % z ( ind ( 2 ) - 1 ) endif if (( sgn ( 3 ). lt . 0.d0 ). and .( v_plane_cyl ( 3 ). eq . ri_cyl ( 3 ))) then arc_cyl ( 3 ) = pass_grid % phi ( ind ( 3 ) - 1 ) h_plane_cyl ( 3 ) = pass_grid % phi ( ind ( 3 ) - 1 ) v_plane_cyl ( 3 ) = pass_grid % phi ( ind ( 3 ) - 1 ) endif call cyl_to_uvw ( arc_cyl , arc ) call cyl_to_uvw ( h_plane_cyl , h_plane ) call cyl_to_uvw ( v_plane_cyl , v_plane ) !! Normal vectors nz ( 1 ) = 0.d0 ; nz ( 2 ) = 0.d0 ; nz ( 3 ) = 1.d0 redge_cyl ( 1 ) = v_plane_cyl ( 1 ) + pass_grid % dr redge_cyl ( 2 ) = v_plane_cyl ( 2 ) redge_cyl ( 3 ) = v_plane_cyl ( 3 ) call cyl_to_uvw ( redge_cyl , redge ) tedge_cyl ( 1 ) = v_plane_cyl ( 1 ) tedge_cyl ( 2 ) = v_plane_cyl ( 2 ) + pass_grid % dz tedge_cyl ( 3 ) = v_plane_cyl ( 3 ) call cyl_to_uvw ( tedge_cyl , tedge ) call plane_basis ( v_plane , redge , tedge , basis ) !! Track the particle inv_50 = 1.0 / 5 0.0 cc = 1 tracks % time = 0.d0 tracks % flux = 0.d0 ncross = 0 call in_plasma ( ri , in_plasma1 , input_coords = 1 ) track_loop : do i = 1 , pass_grid % ntrack if ( cc . gt . pass_grid % ntrack ) exit track_loop call line_cylinder_intersect ( ri , vn , arc , p , dt_arr ( 1 )) call line_plane_intersect ( ri , vn , h_plane , nz , p , dt_arr ( 2 )) call line_plane_intersect ( ri , vn , v_plane , - basis (:, 3 ), p , dt_arr ( 3 )) minpos = minloc ( dt_arr , mask = dt_arr . gt . 0.d0 ) mind = minpos ( 1 ) dT = dt_arr ( mind ) ri_tmp = ri + dT * vn !! Check if velocity intersects LOS and produces wavelength in the right region inter = spec_chords % cyl_inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) if ((. not . los_inter ). and .( inter % nchan . ne . 0 )) then call get_fields ( fields , pos = ri_tmp , input_coords = 1 ) chan_loop : do j = 1 , inter % nchan id = inter % los_elem ( j )% id vp = ri_tmp - spec_chords % los ( id )% lens_uvw call doppler_stark ( vp , vn , fields , lambda ) los_inter = any (( lambda . ge . inputs % lambdamin ). and .( lambda . le . inputs % lambdamax )) if ( los_inter ) exit chan_loop enddo chan_loop endif call in_plasma ( ri_tmp , in_plasma2 , input_coords = 1 ) if ( in_plasma1 . neqv . in_plasma2 ) then dt1 = 0.0 track_fine : do ii = 1 , 50 dt1 = dt1 + dT * inv_50 ri_tmp = ri + vn * dt1 call in_plasma ( ri_tmp , in_plasma_tmp , input_coords = 1 ) if ( in_plasma2 . eqv . in_plasma_tmp ) exit track_fine enddo track_fine tracks ( cc )% pos = ri + 0.5 * dt1 * vn tracks ( cc + 1 )% pos = ri + 0.5 * ( dt1 + dT ) * vn tracks ( cc )% time = dt1 tracks ( cc + 1 )% time = dT - dt1 tracks ( cc )% ind = ind tracks ( cc + 1 )% ind = ind cc = cc + 2 ncross = ncross + 1 else tracks ( cc )% pos = ri + 0.5 * dT * vn tracks ( cc )% time = dT tracks ( cc )% ind = ind cc = cc + 1 endif in_plasma1 = in_plasma2 ri = ri + dT * vn ind ( mind ) = ind ( mind ) + sgn ( mind ) if ( ind ( mind ). gt . gdims ( mind )) exit track_loop if ( ind ( mind ). lt . 1 ) exit track_loop if ( ncross . ge . 2 ) then cc = cc - 1 !dont include last segment exit track_loop endif !! Particle advancement and basis update arc_cyl ( mind ) = arc_cyl ( mind ) + dr ( mind ) h_plane_cyl ( mind ) = h_plane_cyl ( mind ) + dr ( mind ) v_plane_cyl ( mind ) = v_plane_cyl ( mind ) + dr ( mind ) call cyl_to_uvw ( arc_cyl , arc ) call cyl_to_uvw ( h_plane_cyl , h_plane ) call cyl_to_uvw ( v_plane_cyl , v_plane ) redge_cyl ( 1 ) = v_plane_cyl ( 1 ) + pass_grid % dr redge_cyl ( 2 ) = v_plane_cyl ( 2 ) redge_cyl ( 3 ) = v_plane_cyl ( 3 ) call cyl_to_uvw ( redge_cyl , redge ) tedge_cyl ( 1 ) = v_plane_cyl ( 1 ) tedge_cyl ( 2 ) = v_plane_cyl ( 2 ) + pass_grid % dz tedge_cyl ( 3 ) = v_plane_cyl ( 3 ) call cyl_to_uvw ( tedge_cyl , tedge ) call plane_basis ( v_plane , redge , tedge , basis ) enddo track_loop ntrack = cc - 1 if ( present ( los_intersect )) then los_intersect = los_inter endif end subroutine track_cylindrical !============================================================================ !---------------------------Interpolation Routines--------------------------- !============================================================================ subroutine interpol1D_coeff ( xmin , dx , nx , xout , c , err ) !+ Linear interpolation coefficients and index for a 1D grid y(x) real ( Float64 ), intent ( in ) :: xmin !+ Minimum abscissa value real ( Float64 ), intent ( in ) :: dx !+ Absissa spacing integer , intent ( in ) :: nx !+ Number of abscissa real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate type ( InterpolCoeffs1D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: x1 , xp , b1 , b2 integer :: i , err_status err_status = 1 xp = max ( xout , xmin ) i = floor (( xp - xmin ) / dx ) + 1 if (( i . gt . 0 ). and .( i . le .( nx - 1 ))) then x1 = xmin + ( i - 1 ) * dx b2 = ( xp - x1 ) / dx b1 = ( 1.0 - b2 ) c % i = i c % b1 = b1 c % b2 = b2 err_status = 0 endif if ( present ( err )) err = err_status end subroutine interpol1D_coeff subroutine interpol1D_coeff_arr ( x , xout , c , err ) !+ Linear interpolation coefficients and index for a 1D grid y(x) real ( Float64 ), dimension (:), intent ( in ) :: x !+ Abscissa values real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate type ( InterpolCoeffs1D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: xmin , dx integer :: sx , err_status err_status = 1 sx = size ( x ) xmin = x ( 1 ) dx = abs ( x ( 2 ) - x ( 1 )) call interpol1D_coeff ( xmin , dx , sx , xout , c , err_status ) if ( present ( err )) err = err_status end subroutine interpol1D_coeff_arr subroutine interpol2D_coeff ( xmin , dx , nx , ymin , dy , ny , xout , yout , c , err ) !+ Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) real ( Float64 ), intent ( in ) :: xmin !+ Minimum abscissa real ( Float64 ), intent ( in ) :: dx !+ Abscissa spacing integer , intent ( in ) :: nx !+ Number of abscissa real ( Float64 ), intent ( in ) :: ymin !+ Minimum ordinate real ( Float64 ), intent ( in ) :: dy !+ Ordinate spacing integer , intent ( in ) :: ny !+ Number of ordinates points real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ Ordinate value to interpolate type ( InterpolCoeffs2D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: x1 , x2 , y1 , y2 , xp , yp integer :: i , j , err_status err_status = 1 xp = max ( xout , xmin ) yp = max ( yout , ymin ) i = floor (( xp - xmin ) / dx ) + 1 j = floor (( yp - ymin ) / dy ) + 1 if ((( i . gt . 0 ). and .( i . le .( nx - 1 ))). and .(( j . gt . 0 ). and .( j . le .( ny - 1 )))) then x1 = xmin + ( i - 1 ) * dx x2 = x1 + dx y1 = ymin + ( j - 1 ) * dy y2 = y1 + dy c % b11 = (( x2 - xp ) * ( y2 - yp )) / ( dx * dy ) c % b21 = (( xp - x1 ) * ( y2 - yp )) / ( dx * dy ) c % b12 = (( x2 - xp ) * ( yp - y1 )) / ( dx * dy ) c % b22 = (( xp - x1 ) * ( yp - y1 )) / ( dx * dy ) c % i = i c % j = j err_status = 0 endif if ( present ( err )) err = err_status end subroutine interpol2D_coeff subroutine interpol2D_coeff_arr ( x , y , xout , yout , c , err ) !!Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) real ( Float64 ), dimension (:), intent ( in ) :: x !+ Abscissa values real ( Float64 ), dimension (:), intent ( in ) :: y !+ Ordinate values real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ Ordinate value to interpolate type ( InterpolCoeffs2D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: xmin , ymin , dx , dy integer :: sx , sy , err_status err_status = 1 sx = size ( x ) sy = size ( y ) xmin = x ( 1 ) ymin = y ( 1 ) dx = abs ( x ( 2 ) - x ( 1 )) dy = abs ( y ( 2 ) - y ( 1 )) call interpol2D_coeff ( xmin , dx , sx , ymin , dy , sy , xout , yout , c , err_status ) if ( present ( err )) err = err_status end subroutine interpol2D_coeff_arr subroutine cyl_interpol3D_coeff ( rmin , dr , nr , zmin , dz , nz , phimin , dphi , nphi , rout , zout , phiout , c , err ) !+ Cylindrical interpolation coefficients and indicies for a 3D grid real ( Float64 ), intent ( in ) :: rmin !+ Minimum R real ( Float64 ), intent ( in ) :: dr !+ R spacing integer , intent ( in ) :: nr !+ Number of R points real ( Float64 ), intent ( in ) :: zmin !+ Minimum Z real ( Float64 ), intent ( in ) :: dz !+ Z spacing integer , intent ( in ) :: nz !+ Number of Z points real ( Float64 ), intent ( in ) :: phimin !+ Minimum phi real ( Float64 ), intent ( in ) :: dphi !+ Phi spacing integer , intent ( in ) :: nphi !+ Number of phi points real ( Float64 ), intent ( in ) :: rout !+ R value to interpolate real ( Float64 ), intent ( in ) :: zout !+ Z value to interpolate real ( Float64 ), intent ( in ) :: phiout !+ Phi value to interpolate type ( InterpolCoeffs3D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs2D ) :: b real ( Float64 ) :: r1 , r2 , phi1 , phi2 , z1 , z2 , rp , phip , zp , dV real ( Float64 ) :: phi integer :: i , j , k , err_status err_status = 1 rp = max ( rout , rmin ) zp = max ( zout , zmin ) phip = max ( phiout , phimin ) i = floor (( rp - rmin ) / dr ) + 1 j = floor (( zp - zmin ) / dz ) + 1 k = floor (( phip - phimin ) / dphi ) + 1 if ( nphi . eq . 1 ) then if ((( i . gt . 0 ). and .( i . le .( nr - 1 ))). and .(( j . gt . 0 ). and .( j . le .( nz - 1 )))) then call interpol2D_coeff ( rmin , dr , nr , zmin , dz , nz , rout , zout , b , err_status ) c % b111 = b % b11 c % b121 = b % b12 c % b221 = b % b22 c % b211 = b % b21 c % b212 = 0 c % b222 = 0 c % b122 = 0 c % b112 = 0 c % i = b % i c % j = b % j c % k = 1 err_status = 0 endif else if (((( i . gt . 0 ). and .( i . le .( nr - 1 ))). and .(( j . gt . 0 ). and .( j . le .( nz - 1 )))). and .(( k . gt . 0 ). and .( k . le .( nphi - 1 )))) then r1 = rmin + ( i - 1 ) * dr r2 = r1 + dr z1 = zmin + ( j - 1 ) * dz z2 = z1 + dz phi1 = phimin + ( k - 1 ) * dphi phi2 = phi1 + dphi dV = (( r2 ** 2 - r1 ** 2 ) * ( phi2 - phi1 ) * ( z2 - z1 )) !! Both volume elements have a factor of 1/2 that cancels out c % b111 = (( r2 ** 2 - rp ** 2 ) * ( phi2 - phip ) * ( z2 - zp )) / dV c % b121 = (( r2 ** 2 - rp ** 2 ) * ( phi2 - phip ) * ( zp - z1 )) / dV c % b221 = (( rp ** 2 - r1 ** 2 ) * ( phi2 - phip ) * ( zp - z1 )) / dV c % b211 = (( rp ** 2 - r1 ** 2 ) * ( phi2 - phip ) * ( z2 - zp )) / dV c % b212 = (( rp ** 2 - r1 ** 2 ) * ( phip - phi1 ) * ( z2 - zp )) / dV c % b222 = (( rp ** 2 - r1 ** 2 ) * ( phip - phi1 ) * ( zp - z1 )) / dV c % b122 = (( r2 ** 2 - rp ** 2 ) * ( phip - phi1 ) * ( zp - z1 )) / dV c % b112 = (( r2 ** 2 - rp ** 2 ) * ( phip - phi1 ) * ( z2 - zp )) / dV c % i = i c % j = j c % k = k err_status = 0 endif endif if ( present ( err )) err = err_status end subroutine cyl_interpol3D_coeff subroutine cyl_interpol3D_coeff_arr ( r , z , phi , rout , zout , phiout , c , err ) !+ Cylindrical interpolation coefficients and indicies for a 3D grid real ( Float64 ), dimension (:), intent ( in ) :: r !+ R values real ( Float64 ), dimension (:), intent ( in ) :: z !+ Z values real ( Float64 ), dimension (:), intent ( in ) :: phi !+ Phi values real ( Float64 ), intent ( in ) :: rout !+ R value to interpolate real ( Float64 ), intent ( in ) :: zout !+ Z value to interpolate real ( Float64 ), intent ( in ) :: phiout !+ Phi value to interpolate type ( InterpolCoeffs3D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs2D ) :: b real ( Float64 ) :: rmin , phimin , zmin , dr , dphi , dz integer :: sr , sphi , sz , err_status err_status = 1 sr = size ( r ) sphi = size ( phi ) sz = size ( z ) rmin = r ( 1 ) zmin = z ( 1 ) dr = abs ( r ( 2 ) - r ( 1 )) dz = abs ( z ( 2 ) - z ( 1 )) if ( sphi . eq . 1 ) then call interpol2D_coeff ( rmin , dr , sr , zmin , dz , sz , rout , zout , b , err_status ) c % b111 = b % b11 c % b121 = b % b12 c % b221 = b % b22 c % b211 = b % b21 c % b212 = 0 c % b222 = 0 c % b122 = 0 c % b112 = 0 c % i = b % i c % j = b % j c % k = 1 else phimin = phi ( 1 ) dphi = abs ( phi ( 2 ) - phi ( 1 )) call cyl_interpol3D_coeff ( rmin , dr , sr , zmin , dz , sz , phimin , dphi , sphi , rout , zout , phiout , c , err_status ) endif if ( present ( err )) err = err_status end subroutine cyl_interpol3D_coeff_arr subroutine interpol1D_arr ( x , y , xout , yout , err , coeffs ) !+ Performs linear interpolation on a uniform 1D grid y(x) real ( Float64 ), dimension (:), intent ( in ) :: x !+ The abscissa values of `y` real ( Float64 ), dimension (:), intent ( in ) :: y !+ Values at abscissa values `x`: y(x) real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate real ( Float64 ), intent ( out ) :: yout !+ Interpolant: y(xout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs1D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients type ( InterpolCoeffs1D ) :: c integer :: i , err_status err_status = 1 if ( present ( coeffs )) then c = coeffs err_status = 0 else call interpol_coeff ( x , xout , c , err_status ) endif if ( err_status . eq . 0 ) then i = c % i yout = c % b1 * y ( i ) + c % b2 * y ( i + 1 ) else yout = 0.d0 endif if ( present ( err )) err = err_status end subroutine interpol1D_arr subroutine interpol2D_arr ( x , y , z , xout , yout , zout , err , coeffs ) !+ Performs bilinear interpolation on a 2D grid z(x,y) real ( Float64 ), dimension (:), intent ( in ) :: x !+ The abscissa values of `z` real ( Float64 ), dimension (:), intent ( in ) :: y !+ The ordinate values of `z` real ( Float64 ), dimension (:,:), intent ( in ) :: z !+ Values at the abscissa/ordinates: z(x,y) real ( Float64 ), intent ( in ) :: xout !+ The abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ The ordinate value to interpolate real ( Float64 ), intent ( out ) :: zout !+ Interpolant: z(xout,yout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs2D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients type ( InterpolCoeffs2D ) :: c integer :: i , j , err_status err_status = 1 if ( present ( coeffs )) then c = coeffs err_status = 0 else call interpol_coeff ( x , y , xout , yout , c , err_status ) endif if ( err_status . eq . 0 ) then i = c % i j = c % j zout = c % b11 * z ( i , j ) + c % b12 * z ( i , j + 1 ) + c % b21 * z ( i + 1 , j ) + c % b22 * z ( i + 1 , j + 1 ) else zout = 0.d0 endif if ( present ( err )) err = err_status end subroutine interpol2D_arr subroutine interpol2D_2D_arr ( x , y , z , xout , yout , zout , err , coeffs ) !+ Performs bilinear interpolation on a 2D grid of 2D arrays z(:,:,x,y) real ( Float64 ), dimension (:), intent ( in ) :: x !+ The abscissa values of `z` real ( Float64 ), dimension (:), intent ( in ) :: y !+ The ordinate values of `z` real ( Float64 ), dimension (:,:,:,:), intent ( in ) :: z !+ Values at the abscissa/ordinates: z(:,:,x,y) real ( Float64 ), intent ( in ) :: xout !+ The abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ The ordinate value to interpolate real ( Float64 ), dimension (:,:), intent ( out ) :: zout !+ Interpolant: z(:,:,xout,yout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs2D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients type ( InterpolCoeffs2D ) :: c integer :: i , j , err_status err_status = 1 if ( present ( coeffs )) then c = coeffs err_status = 0 else call interpol_coeff ( x , y , xout , yout , c , err_status ) endif if ( err_status . eq . 0 ) then i = c % i j = c % j zout = c % b11 * z (:,:, i , j ) + c % b12 * z (:,:, i , j + 1 ) + c % b21 * z (:,:, i + 1 , j ) + c % b22 * z (:,:, i + 1 , j + 1 ) else zout = 0.0 endif if ( present ( err )) err = err_status end subroutine interpol2D_2D_arr subroutine interpol3D_arr ( r , z , phi , d , rout , zout , phiout , dout , err , coeffs ) !+ Performs cylindrical interpolation on a 3D grid f(r,z,phi) real ( Float64 ), dimension (:), intent ( in ) :: r !+ R values real ( Float64 ), dimension (:), intent ( in ) :: z !+ Z values real ( Float64 ), dimension (:), intent ( in ) :: phi !+ Phi values real ( Float64 ), dimension (:,:,:), intent ( in ) :: d !+ Values at r,z,phi: d(r,z,phi) real ( Float64 ), intent ( in ) :: rout !+ R value to interpolate real ( Float64 ), intent ( in ) :: zout !+ Z value to interpolate real ( Float64 ), intent ( in ) :: phiout !+ Phi value to interpolate real ( Float64 ), intent ( out ) :: dout !+ Interpolant: d(rout,zout,phiout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs3D ), intent ( in ), optional :: coeffs !+ Precomputed Interpolation Coefficients type ( InterpolCoeffs3D ) :: b integer :: i , j , k , k2 , err_status integer :: nphi err_status = 1 nphi = size ( phi ) if ( present ( coeffs )) then b = coeffs if ( nphi . eq . 1 ) then b % b212 = 0 b % b222 = 0 b % b122 = 0 b % b112 = 0 b % k = 1 endif err_status = 0 else call interpol_coeff ( r , z , phi , rout , zout , phiout , b , err_status ) endif if ( err_status . eq . 0 ) then i = b % i j = b % j k = b % k if ( nphi . eq . 1 ) then k2 = min ( k + 1 , nphi ) else k2 = k + 1 endif dout = b % b111 * d ( i , j , k ) + b % b121 * d ( i , j + 1 , k ) + & b % b112 * d ( i , j , k2 ) + b % b122 * d ( i , j + 1 , k2 ) + & b % b211 * d ( i + 1 , j , k ) + b % b221 * d ( i + 1 , j + 1 , k ) + & b % b212 * d ( i + 1 , j , k2 ) + b % b222 * d ( i + 1 , j + 1 , k2 ) else dout = 0.d0 endif if ( present ( err )) err = err_status end subroutine interpol3D_arr subroutine interpol3D_2D_arr ( r , z , phi , f , rout , zout , phiout , fout , err , coeffs ) !+ Performs cylindrical interpolation on a 3D grid of 2D arrays !+ f(:,:,r,z,phi) real ( Float64 ), dimension (:), intent ( in ) :: r !+ R values real ( Float64 ), dimension (:), intent ( in ) :: z !+ Z values real ( Float64 ), dimension (:), intent ( in ) :: phi !+ Phi values real ( Float64 ), dimension (:,:,:,:,:), intent ( in ) :: f !+ Values at r,z,phi: f(:,:,r,z,phi) real ( Float64 ), intent ( in ) :: rout !+ R value to interpolate real ( Float64 ), intent ( in ) :: zout !+ Z value to interpolate real ( Float64 ), intent ( in ) :: phiout !+ Phi value to interpolate real ( Float64 ), dimension (:,:), intent ( out ) :: fout !+ Interpolant: f(:,:,rout,zout,phiout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs3D ), intent ( in ), optional :: coeffs !+ Precomputed Interpolation Coefficients type ( InterpolCoeffs3D ) :: b integer :: i , j , k , k2 , err_status integer :: nphi err_status = 1 nphi = size ( phi ) if ( present ( coeffs )) then b = coeffs if ( nphi . eq . 1 ) then b % b212 = 0 b % b222 = 0 b % b122 = 0 b % b112 = 0 b % k = 1 endif err_status = 0 else call interpol_coeff ( r , z , phi , rout , zout , phiout , b , err_status ) endif if ( err_status . eq . 0 ) then i = b % i j = b % j k = b % k if ( nphi . eq . 1 ) then k2 = min ( k + 1 , nphi ) else k2 = k + 1 endif fout = b % b111 * f (:,:, i , j , k ) + b % b121 * f (:,:, i , j + 1 , k ) + & b % b112 * f (:,:, i , j , k2 ) + b % b122 * f (:,:, i , j + 1 , k2 ) + & b % b211 * f (:,:, i + 1 , j , k ) + b % b221 * f (:,:, i + 1 , j + 1 , k ) + & b % b212 * f (:,:, i + 1 , j , k2 ) + b % b222 * f (:,:, i + 1 , j + 1 , k2 ) else fout = 0.0 endif if ( present ( err )) err = err_status end subroutine interpol3D_2D_arr !============================================================================= !-------------------------Profiles and Fields Routines------------------------ !============================================================================= subroutine in_plasma ( xyz , inp , input_coords , coeffs , uvw_out ) !+ Indicator subroutine to determine if a position is in a region where !+ the plasma parameter and fields are valid/known real ( Float64 ), dimension ( 3 ), intent ( in ) :: xyz !+ Position in beam coordinates logical , intent ( out ) :: inp !+ Indicates whether plasma parameters and fields are valid/known integer , intent ( in ), optional :: input_coords !+ Indicates coordinate system of xyz. Beam grid (0), machine (1) and cylindrical (2) type ( InterpolCoeffs3D ), intent ( out ), optional :: coeffs !+ Interpolation coefficients used in calculation real ( Float64 ), dimension ( 3 ), intent ( out ), optional :: uvw_out !+ Position in machine coordinates real ( Float64 ), dimension ( 3 ) :: uvw type ( InterpolCoeffs3D ) :: b real ( Float64 ) :: R , W , mask real ( Float64 ) :: phi integer :: i , j , k , k2 , err , ics err = 1 if ( present ( input_coords )) then ics = input_coords else ics = 0 endif if ( ics . eq . 0 ) then call xyz_to_uvw ( xyz , uvw ) endif if ( ics . eq . 1 ) then uvw = xyz endif if ( ics . eq . 2 ) then call cyl_to_uvw ( xyz , uvw ) endif R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) W = uvw ( 3 ) phi = atan2 ( uvw ( 2 ), uvw ( 1 )) !! Interpolate mask value call interpol_coeff ( inter_grid % r , inter_grid % z , inter_grid % phi , R , W , phi , b , err ) inp = . False . if ( err . eq . 0 ) then i = b % i j = b % j k = b % k if ( inter_grid % nphi . eq . 1 ) then k2 = min ( k + 1 , inter_grid % nphi ) else k2 = k + 1 endif mask = b % b111 * equil % mask ( i , j , k ) + b % b112 * equil % mask ( i , j , k2 ) + & b % b121 * equil % mask ( i , j + 1 , k ) + b % b122 * equil % mask ( i , j + 1 , k2 ) + & b % b211 * equil % mask ( i + 1 , j , k ) + b % b212 * equil % mask ( i + 1 , j , k2 ) + & b % b221 * equil % mask ( i + 1 , j + 1 , k ) + b % b222 * equil % mask ( i + 1 , j + 1 , k2 ) if (( mask . ge . 0.5 ). and .( err . eq . 0 )) then inp = . True . endif endif if ( present ( coeffs )) coeffs = b if ( present ( uvw_out )) uvw_out = uvw end subroutine in_plasma subroutine get_plasma ( plasma , pos , ind , input_coords , output_coords ) !+ Gets plasma parameters at position `pos` or [[libfida:beam_grid]] indices `ind` type ( LocalProfiles ), intent ( out ) :: plasma !+ Plasma parameters at `pos`/`ind` real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices integer ( Int32 ), intent ( in ), optional :: input_coords !+ Indicates coordinate system of inputs. Beam grid (0), machine (1) and cylindrical (2) integer ( Int32 ), intent ( in ), optional :: output_coords !+ Indicates coordinate system of outputs. Beam grid (0), machine (1) and cylindrical (2) logical :: inp type ( InterpolCoeffs3D ) :: coeffs real ( Float64 ), dimension ( 3 ) :: xyz , uvw , cyl , vrot_uvw real ( Float64 ) :: phi , s , c integer :: i , j , k , k2 , ics , ocs plasma % in_plasma = . False . if ( present ( input_coords )) then ics = input_coords else ics = 0 endif if ( present ( output_coords )) then ocs = output_coords else ocs = 0 endif if ( present ( ind )) then if ( ics . eq . 0 ) then call get_position ( ind , xyz ) endif if ( ics . eq . 2 ) then call get_position ( ind , xyz , input_coords = 2 ) endif endif if ( present ( pos )) then if ( ics . eq . 0 ) then xyz = pos call xyz_to_uvw ( xyz , uvw ) endif if ( ics . eq . 1 ) then uvw = pos call uvw_to_xyz ( uvw , xyz ) endif endif call in_plasma ( xyz , inp , 0 , coeffs ) if ( inp ) then phi = atan2 ( uvw ( 2 ), uvw ( 1 )) i = coeffs % i j = coeffs % j k = coeffs % k if ( inter_grid % nphi . eq . 1 ) then k2 = min ( k + 1 , inter_grid % nphi ) else k2 = k + 1 endif plasma = coeffs % b111 * equil % plasma ( i , j , k ) + coeffs % b121 * equil % plasma ( i , j + 1 , k ) + & coeffs % b112 * equil % plasma ( i , j , k2 ) + coeffs % b122 * equil % plasma ( i , j + 1 , k2 ) + & coeffs % b211 * equil % plasma ( i + 1 , j , k ) + coeffs % b221 * equil % plasma ( i + 1 , j + 1 , k ) + & coeffs % b212 * equil % plasma ( i + 1 , j , k2 ) + coeffs % b222 * equil % plasma ( i + 1 , j + 1 , k2 ) s = sin ( phi ) ; c = cos ( phi ) vrot_uvw ( 1 ) = plasma % vr * c - plasma % vt * s vrot_uvw ( 2 ) = plasma % vr * s + plasma % vt * c vrot_uvw ( 3 ) = plasma % vz if ( ocs . eq . 0 ) then plasma % vrot = matmul ( beam_grid % inv_basis , vrot_uvw ) plasma % pos = xyz endif if ( ocs . eq . 1 ) then plasma % vrot = vrot_uvw plasma % pos = uvw endif plasma % uvw = uvw plasma % in_plasma = . True . plasma % b = coeffs endif end subroutine get_plasma subroutine calc_perp_vectors ( b , a , c ) !+ Calculates normalized vectors that are perpendicular to b !+ such that `a` x `c` = `b_norm` real ( Float64 ), dimension ( 3 ), intent ( in ) :: b real ( Float64 ), dimension ( 3 ), intent ( out ) :: a real ( Float64 ), dimension ( 3 ), intent ( out ) :: c real ( Float64 ), dimension ( 3 ) :: bnorm bnorm = b / norm2 ( b ) if ( abs ( bnorm ( 3 )). eq . 1 ) then a = [ 1.d0 , 0.d0 , 0.d0 ] c = [ 0.d0 , 1.d0 , 0.d0 ] else if ( bnorm ( 3 ). eq . 0. ) then a = [ 0.d0 , 0.d0 , 1.d0 ] c = [ bnorm ( 2 ), - bnorm ( 1 ), 0.d0 ] / sqrt ( bnorm ( 1 ) ** 2 + bnorm ( 2 ) ** 2 ) else a = [ bnorm ( 2 ), - bnorm ( 1 ), 0.d0 ] / sqrt ( bnorm ( 1 ) ** 2 + bnorm ( 2 ) ** 2 ) c =- [ a ( 2 ) , - a ( 1 ) , ( a ( 1 ) * bnorm ( 2 ) - a ( 2 ) * bnorm ( 1 )) / bnorm ( 3 ) ] c = c / norm2 ( c ) if ( bnorm ( 3 ). lt . 0.0 ) then c =- c endif endif endif end subroutine calc_perp_vectors subroutine get_fields ( fields , pos , ind , input_coords , output_coords ) !+ Gets electro-magnetic fields at position `pos` or [[libfida:beam_grid]] indices `ind` type ( LocalEMFields ), intent ( out ) :: fields !+ Electro-magnetic fields at `pos`/`ind` real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices integer ( Int32 ), intent ( in ), optional :: input_coords !+ Indicates coordinate system of inputs. Beam grid (0), machine (1) and cylindrical (2) integer ( Int32 ), intent ( in ), optional :: output_coords !+ Indicates coordinate system of outputs. Beam grid (0), machine (1) and cylindrical (2) logical :: inp real ( Float64 ), dimension ( 3 ) :: xyz , uvw real ( Float64 ), dimension ( 3 ) :: uvw_bfield , uvw_efield real ( Float64 ), dimension ( 3 ) :: xyz_bfield , xyz_efield real ( Float64 ) :: phi , s , c type ( InterpolCoeffs3D ) :: coeffs integer :: i , j , k , k2 , mc , ocs , ics fields % in_plasma = . False . if ( present ( input_coords )) then ics = input_coords else ics = 0 endif if ( present ( output_coords )) then ocs = output_coords else ocs = 0 endif if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) then if ( ics . eq . 0 ) then xyz = pos call xyz_to_uvw ( xyz , uvw ) endif if ( ics . eq . 1 ) then uvw = pos call uvw_to_xyz ( uvw , xyz ) endif endif call in_plasma ( xyz , inp , 0 , coeffs ) if ( inp ) then i = coeffs % i j = coeffs % j k = coeffs % k if ( inter_grid % nphi . eq . 1 ) then k2 = min ( k + 1 , inter_grid % nphi ) else k2 = k + 1 endif fields = coeffs % b111 * equil % fields ( i , j , k ) + coeffs % b121 * equil % fields ( i , j + 1 , k ) + & coeffs % b112 * equil % fields ( i , j , k2 ) + coeffs % b122 * equil % fields ( i , j + 1 , k2 ) + & coeffs % b211 * equil % fields ( i + 1 , j , k ) + coeffs % b221 * equil % fields ( i + 1 , j + 1 , k ) + & coeffs % b212 * equil % fields ( i + 1 , j , k2 ) + coeffs % b222 * equil % fields ( i + 1 , j + 1 , k2 ) phi = atan2 ( uvw ( 2 ), uvw ( 1 )) s = sin ( phi ) ; c = cos ( phi ) !Convert cylindrical coordinates to uvw uvw_bfield ( 1 ) = c * fields % br - s * fields % bt uvw_bfield ( 2 ) = s * fields % br + c * fields % bt uvw_bfield ( 3 ) = fields % bz uvw_efield ( 1 ) = c * fields % er - s * fields % et uvw_efield ( 2 ) = s * fields % er + c * fields % et uvw_efield ( 3 ) = fields % ez if ( ocs . eq . 0 ) then !Represent fields in beam grid coordinates xyz_bfield = matmul ( beam_grid % inv_basis , uvw_bfield ) xyz_efield = matmul ( beam_grid % inv_basis , uvw_efield ) fields % pos = xyz endif if ( ocs . eq . 1 ) then xyz_bfield = uvw_bfield xyz_efield = uvw_efield fields % pos = uvw endif !Calculate field directions and magnitudes fields % b_abs = norm2 ( xyz_bfield ) fields % e_abs = norm2 ( xyz_efield ) if ( fields % b_abs . gt . 0.d0 ) fields % b_norm = xyz_bfield / fields % b_abs if ( fields % e_abs . gt . 0.d0 ) fields % e_norm = xyz_efield / fields % e_abs call calc_perp_vectors ( fields % b_norm , fields % a_norm , fields % c_norm ) fields % uvw = uvw fields % in_plasma = . True . fields % coords = ocs fields % b = coeffs endif end subroutine get_fields subroutine get_distribution ( fbeam , denf , pos , ind , coeffs ) !+ Gets Guiding Center distribution at position `pos` or [[libfida:beam_grid]] indices `ind` real ( Float64 ), dimension (:,:), intent ( out ) :: fbeam !+ Guiding Center Fast-ion distribution at `pos`/`ind`: F(E,p) real ( Float64 ), intent ( out ) :: denf !+ Guiding Center Fast-ion density at `pos`/`ind` [fast-ions/cm&#94;3] real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices type ( InterpolCoeffs3D ), intent ( in ), optional :: coeffs !+ Precomputed interpolation coefficients real ( Float64 ), dimension ( 3 ) :: xyz , uvw real ( Float64 ) :: R , Z , Phi integer :: err if ( present ( coeffs )) then call interpol ( fbm % r , fbm % z , fbm % phi , fbm % f , R , Z , Phi , fbeam , err , coeffs ) call interpol ( fbm % r , fbm % z , fbm % phi , fbm % denf , R , Z , Phi , denf , err , coeffs ) else if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) Z = uvw ( 3 ) Phi = atan2 ( uvw ( 2 ), uvw ( 1 )) call interpol ( fbm % r , fbm % z , fbm % phi , fbm % f , R , Z , Phi , fbeam , err ) call interpol ( fbm % r , fbm % z , fbm % phi , fbm % denf , R , Z , Phi , denf , err ) endif end subroutine get_distribution subroutine get_ep_denf ( energy , pitch , denf , pos , ind , coeffs ) !+ Get guiding center fast-ion density at given energy and pitch !+ at position `pos` or [[libfida:beam_grid]] indices `ind` real ( Float64 ), intent ( in ) :: energy !+ Energy [keV] real ( Float64 ), intent ( in ) :: pitch !+ Pitch real ( Float64 ), intent ( out ) :: denf !+ Fast-ion density [fast-ions/(cm&#94;3*dE*dp)] real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices type ( InterpolCoeffs3D ), intent ( in ), optional :: coeffs !+ Precomputed interpolation coefficients real ( Float64 ), dimension ( 3 ) :: xyz , uvw real ( Float64 ), dimension ( fbm % nenergy , fbm % npitch ) :: fbeam integer ( Int32 ), dimension ( 2 ) :: epi real ( Float64 ) :: R , Phi , Z real ( Float64 ) :: dE , dp integer :: err epi ( 1 ) = minloc ( abs ( fbm % energy - energy ), 1 ) epi ( 2 ) = minloc ( abs ( fbm % pitch - pitch ), 1 ) dE = abs ( fbm % energy ( epi ( 1 )) - energy ) dp = abs ( fbm % pitch ( epi ( 2 )) - pitch ) if (( dE . le . fbm % dE ). and .( dp . le . fbm % dp )) then if ( present ( coeffs )) then call interpol ( inter_grid % r , inter_grid % z , inter_grid % phi , fbm % f , R , Z , Phi , fbeam , err , coeffs ) else if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) Z = uvw ( 3 ) Phi = atan2 ( uvw ( 2 ), uvw ( 1 )) call interpol ( inter_grid % r , inter_grid % z , inter_grid % phi , fbm % f , R , Z , Phi , fbeam , err ) endif denf = fbeam ( epi ( 1 ), epi ( 2 )) else denf = 0.0 endif end subroutine get_ep_denf !============================================================================= !--------------------------Result Storage Routines---------------------------- !============================================================================= subroutine store_neutrals ( ind , neut_type , dens , vn , store_iter ) !Store neutrals in [[libfida:neut]] at indices `ind` integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices integer , intent ( in ) :: neut_type !+ Neutral type real ( Float64 ), dimension (:), intent ( in ) :: dens !+ Neutral density [neutrals/cm&#94;3] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vn !+ Neutral particle velocity [cm/s] logical , intent ( in ), optional :: store_iter !+ Store DCX/Halo iteration density in [[libfida:halo_iter_dens]] logical :: iter integer :: i , j , k if ( present ( store_iter )) then iter = store_iter else iter = . False . endif i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) !$OMP CRITICAL(store_neutrals_1) if ( iter ) halo_iter_dens ( neut_type ) = halo_iter_dens ( neut_type ) + sum ( dens ) select case ( neut_type ) case ( nbif_type ) neut % full (:, i , j , k ) = neut % full (:, i , j , k ) + dens case ( nbih_type ) neut % half (:, i , j , k ) = neut % half (:, i , j , k ) + dens case ( nbit_type ) neut % third (:, i , j , k ) = neut % third (:, i , j , k ) + dens case ( dcx_type ) neut % dcx (:, i , j , k ) = neut % dcx (:, i , j , k ) + dens case ( halo_type ) neut % halo (:, i , j , k ) = neut % halo (:, i , j , k ) + dens case default if ( inputs % verbose . ge . 0 ) then write ( * , '(\"STORE_NEUTRALS: Unknown neutral type: \",i2)' ) neut_type endif stop end select !$OMP END CRITICAL(store_neutrals_1) end subroutine store_neutrals subroutine store_births ( ind , neut_type , dflux ) !+ Store birth particles/density in [[libfida:birth]] integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices integer ( Int32 ), intent ( in ) :: neut_type !+ Neutral type real ( Float64 ), intent ( in ) :: dflux !+ Deposited flux !$OMP ATOMIC UPDATE birth % dens ( neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) = & birth % dens ( neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) + dflux !$OMP END ATOMIC end subroutine store_births subroutine store_npa ( det , ri , rf , vn , flux , orbit_class , passive ) !+ Store NPA particles in [[libfida:npa]] integer , intent ( in ) :: det !+ Detector/Channel Number real ( Float64 ), dimension ( 3 ), intent ( in ) :: ri !+ Birth position in beam coordinates [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: rf !+ Detector position in beam coordinates [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vn !+ Particle velocity [cm/s] real ( Float64 ), intent ( in ) :: flux !+ Neutral flux [neutrals/s] integer , intent ( in ), optional :: orbit_class !+ Orbit class ID logical , intent ( in ), optional :: passive !+ Indicates whether npa particle is passive integer :: iclass , oclass type ( LocalEMFields ) :: fields real ( Float64 ), dimension ( 3 ) :: uvw_ri , uvw_rf , vn_norm real ( Float64 ) :: energy , pitch , dE integer ( Int32 ), dimension ( 1 ) :: ienergy type ( NPAParticle ), dimension (:), allocatable :: parts logical :: pas = . False . if ( present ( orbit_class )) then iclass = min ( orbit_class , particles % nclass ) oclass = orbit_class else iclass = 1 oclass = 1 endif if ( present ( passive )) pas = passive ! Convert to machine coordinates call xyz_to_uvw ( ri , uvw_ri ) call xyz_to_uvw ( rf , uvw_rf ) ! Calculate energy energy = inputs % ab * v2_to_E_per_amu * dot_product ( vn , vn ) if ( pas ) then dE = pnpa % energy ( 2 ) - pnpa % energy ( 1 ) else dE = npa % energy ( 2 ) - npa % energy ( 1 ) endif ! Calculate pitch if distribution actually uses pitch if ( inputs % dist_type . le . 2 ) then call get_fields ( fields , pos = ri ) vn_norm = vn / norm2 ( vn ) pitch = dot_product ( fields % b_norm , vn_norm ) else pitch = 0.d0 endif if ( pas ) then !$OMP CRITICAL(store_npa_1) pnpa % npart = pnpa % npart + 1 if ( pnpa % npart . gt . pnpa % nmax ) then pnpa % nmax = int ( pnpa % nmax * 2 ) allocate ( parts ( pnpa % nmax )) parts ( 1 :( pnpa % npart - 1 )) = pnpa % part deallocate ( pnpa % part ) call move_alloc ( parts , pnpa % part ) endif pnpa % part ( pnpa % npart )% detector = det pnpa % part ( pnpa % npart )% class = oclass pnpa % part ( pnpa % npart )% xi = uvw_ri ( 1 ) pnpa % part ( pnpa % npart )% yi = uvw_ri ( 2 ) pnpa % part ( pnpa % npart )% zi = uvw_ri ( 3 ) pnpa % part ( pnpa % npart )% xf = uvw_rf ( 1 ) pnpa % part ( pnpa % npart )% yf = uvw_rf ( 2 ) pnpa % part ( pnpa % npart )% zf = uvw_rf ( 3 ) pnpa % part ( pnpa % npart )% energy = energy pnpa % part ( pnpa % npart )% pitch = pitch pnpa % part ( pnpa % npart )% weight = flux ienergy = minloc ( abs ( pnpa % energy - energy )) pnpa % flux ( ienergy ( 1 ), det , iclass ) = & pnpa % flux ( ienergy ( 1 ), det , iclass ) + flux / dE !$OMP END CRITICAL(store_npa_1) else !$OMP CRITICAL(store_npa_2) npa % npart = npa % npart + 1 if ( npa % npart . gt . npa % nmax ) then npa % nmax = int ( npa % nmax * 2 ) allocate ( parts ( npa % nmax )) parts ( 1 :( npa % npart - 1 )) = npa % part deallocate ( npa % part ) call move_alloc ( parts , npa % part ) endif npa % part ( npa % npart )% detector = det npa % part ( npa % npart )% class = oclass npa % part ( npa % npart )% xi = uvw_ri ( 1 ) npa % part ( npa % npart )% yi = uvw_ri ( 2 ) npa % part ( npa % npart )% zi = uvw_ri ( 3 ) npa % part ( npa % npart )% xf = uvw_rf ( 1 ) npa % part ( npa % npart )% yf = uvw_rf ( 2 ) npa % part ( npa % npart )% zf = uvw_rf ( 3 ) npa % part ( npa % npart )% energy = energy npa % part ( npa % npart )% pitch = pitch npa % part ( npa % npart )% weight = flux ienergy = minloc ( abs ( npa % energy - energy )) npa % flux ( ienergy ( 1 ), det , iclass ) = & npa % flux ( ienergy ( 1 ), det , iclass ) + flux / dE !$OMP END CRITICAL(store_npa_2) endif end subroutine store_npa !============================================================================= !--------------------------Atomic Physics Routines---------------------------- !============================================================================= subroutine bb_cx_rates ( denn , vi , vn , rates ) !+ Get beam-beam neutralization/cx rates real ( Float64 ), dimension ( nlevs ), intent ( in ) :: denn !+ Neutral density [cm&#94;-3] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Ion velocity [cm/s] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vn !+ Neutral velocity [cm/s] real ( Float64 ), dimension ( nlevs ), intent ( out ) :: rates !+ Reaction rates [1/s] real ( Float64 ), dimension ( nlevs , nlevs ) :: neut !!rate coeff real ( Float64 ) :: eb !! relative Energy type ( InterpolCoeffs1D ) :: c real ( Float64 ) :: dlogE , logEmin , logeb real ( Float64 ) :: vrel !! relative velocity integer :: ebi , neb , err !Eeff vrel = norm2 ( vi - vn ) eb = v2_to_E_per_amu * vrel ** 2 ! [kev/amu] logeb = log10 ( eb ) logEmin = tables % H_H_cx_cross % logemin dlogE = tables % H_H_cx_cross % dlogE neb = tables % H_H_cx_cross % nenergy call interpol_coeff ( logEmin , dlogE , neb , logeb , c , err ) ebi = c % i if ( err . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"BB_CX_RATES: Eb out of range of H_H_cx table. Using nearest energy value.\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb endif if ( ebi . lt . 1 ) then ebi = 1 c % b1 = 1.0 ; c % b2 = 0.0 else ebi = neb - 1 c % b1 = 0.0 ; c % b2 = 1.0 endif endif neut (:,:) = ( c % b1 * tables % H_H_cx_cross % log_cross (:,:, ebi ) + & c % b2 * tables % H_H_cx_cross % log_cross (:,:, ebi + 1 )) where ( neut . lt . tables % H_H_cx_cross % minlog_cross ) neut = 0.d0 elsewhere neut = exp ( neut * log_10 ) end where rates = matmul ( neut , denn ) * vrel end subroutine bb_cx_rates subroutine bt_cx_rates ( plasma , denn , vi , i_type , rates ) !+ Get beam-target neutralization/cx rates type ( LocalProfiles ), intent ( in ) :: plasma !+ Plasma parameters real ( Float64 ), dimension ( nlevs ), intent ( in ) :: denn !+ Neutral density [cm&#94;-3] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Ion velocity [cm/s] integer , intent ( in ) :: i_type !+ Ion type real ( Float64 ), dimension ( nlevs ), intent ( out ) :: rates !+ Reaction rates [1/s] real ( Float64 ) :: logEmin , dlogE , logeb , eb real ( Float64 ) :: logTmin , dlogT , logti , vrel integer :: neb , nt type ( InterpolCoeffs2D ) :: c real ( Float64 ) :: b11 , b12 , b21 , b22 , b_amu real ( Float64 ), dimension ( nlevs , nlevs ) :: H_H_rate integer :: ebi , tii , n , err_status H_H_rate = 0.d0 if ( i_type . eq . beam_ion ) then b_amu = inputs % ab else b_amu = inputs % ai endif vrel = norm2 ( vi - plasma % vrot ) eb = b_amu * v2_to_E_per_amu * vrel ** 2 ! [kev/amu] logeb = log10 ( eb ) logti = log10 ( plasma % ti ) !!H_H err_status = 1 logEmin = tables % H_H_cx_rate % logemin logTmin = tables % H_H_cx_rate % logtmin dlogE = tables % H_H_cx_rate % dlogE dlogT = tables % H_H_cx_rate % dlogT neb = tables % H_H_cx_rate % nenergy nt = tables % H_H_cx_rate % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , c , err_status ) ebi = c % i tii = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"BT_CX_RATES: Eb or Ti out of range of H_H_CX table. Setting H_H_CX rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",ES10.3,\" [keV]\")' ) plasma % ti endif rates = 0.0 return endif H_H_rate = ( b11 * tables % H_H_cx_rate % log_rate (:,:, ebi , tii , i_type ) + & b12 * tables % H_H_cx_rate % log_rate (:,:, ebi , tii + 1 , i_type ) + & b21 * tables % H_H_cx_rate % log_rate (:,:, ebi + 1 , tii , i_type ) + & b22 * tables % H_H_cx_rate % log_rate (:,:, ebi + 1 , tii + 1 , i_type )) where ( H_H_rate . lt . tables % H_H_cx_rate % minlog_rate ) H_H_rate = 0.d0 elsewhere H_H_rate = exp ( H_H_rate * log_10 ) !cm&#94;3/s end where rates = matmul ( H_H_rate , denn ) !1/s end subroutine bt_cx_rates subroutine get_neutron_rate ( plasma , eb , rate ) !+ Gets neutron rate for a beam with energy `eb` interacting with a target plasma type ( LocalProfiles ), intent ( in ) :: plasma !+ Plasma Paramters real ( Float64 ), intent ( in ) :: eb !+ Beam energy [keV] real ( Float64 ), intent ( out ) :: rate !+ Neutron reaction rate [1/s] integer :: err_status , neb , nt , ebi , tii real ( Float64 ) :: dlogE , dlogT , logEmin , logTmin real ( Float64 ) :: logeb , logti , lograte , denp type ( InterpolCoeffs2D ) :: c real ( Float64 ) :: b11 , b12 , b21 , b22 logeb = log10 ( eb ) logti = log10 ( plasma % ti ) denp = plasma % denp !!D_D err_status = 1 logEmin = tables % D_D % logemin logTmin = tables % D_D % logtmin dlogE = tables % D_D % dlogE dlogT = tables % D_D % dlogT neb = tables % D_D % nenergy nt = tables % D_D % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , c , err_status ) ebi = c % i tii = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_NEUTRON_RATE: Eb or Ti out of range of D_D table. Setting D_D rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",ES10.3,\" [keV]\")' ) plasma % ti endif denp = 0.d0 endif lograte = ( b11 * tables % D_D % log_rate ( ebi , tii , 2 ) + & b12 * tables % D_D % log_rate ( ebi , tii + 1 , 2 ) + & b21 * tables % D_D % log_rate ( ebi + 1 , tii , 2 ) + & b22 * tables % D_D % log_rate ( ebi + 1 , tii + 1 , 2 )) if ( lograte . lt . tables % D_D % minlog_rate ) then rate = 0.d0 else rate = denp * exp ( lograte * log_10 ) endif end subroutine get_neutron_rate subroutine get_beam_cx_rate ( ind , pos , v_ion , i_type , types , rate_tot ) !+ Get probability of a thermal ion charge exchanging with `types` neutrals integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Interaction position in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: v_ion !+ Ion velocity [cm/s] integer , intent ( in ) :: i_type !+ Ion type integer ( Int32 ), dimension (:), intent ( in ) :: types !+ Neutral types real ( Float64 ), dimension ( nlevs ), intent ( out ) :: rate_tot !+ Total charge exchange rate [1/s] integer :: n , i , j , k , ii type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: rates , denn real ( Float64 ), dimension ( 3 ) :: vhalo , vn , vnbi vnbi = pos - nbi % src vnbi = nbi % vinj * vnbi / norm2 ( vnbi ) n = size ( types ) rate_tot = 0 i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) do ii = 1 , n select case ( types ( ii )) case ( nbif_type ) vn = vnbi call bb_cx_rates ( neut % full (:, i , j , k ), v_ion , vn , rates ) case ( nbih_type ) vn = vnbi / sqrt ( 2.0 ) call bb_cx_rates ( neut % half (:, i , j , k ), v_ion , vn , rates ) case ( nbit_type ) vn = vnbi / sqrt ( 3.0 ) call bb_cx_rates ( neut % third (:, i , j , k ), v_ion , vn , rates ) case ( dcx_type ) call get_plasma ( plasma , pos = pos ) call bt_cx_rates ( plasma , neut % dcx (:, i , j , k ), v_ion , i_type , rates ) case ( halo_type ) call get_plasma ( plasma , pos = pos ) call bt_cx_rates ( plasma , neut % halo (:, i , j , k ), v_ion , i_type , rates ) end select rate_tot = rate_tot + rates enddo end subroutine get_beam_cx_rate subroutine get_rate_matrix ( plasma , i_type , eb , rmat ) !+ Gets rate matrix for use in [[libfida:colrad]] type ( LocalProfiles ), intent ( in ) :: plasma !+ Plasma parameters integer , intent ( in ) :: i_type !+ Ion type real ( Float64 ), intent ( in ) :: eb !+ Ion energy [keV] real ( Float64 ), dimension ( nlevs , nlevs ), intent ( out ) :: rmat !+ Rate matrix real ( Float64 ) :: logEmin , dlogE , logeb real ( Float64 ) :: logTmin , dlogT , logti , logte integer :: neb , nt type ( InterpolCoeffs2D ) :: c real ( Float64 ) :: b11 , b12 , b21 , b22 , dene , denp , denimp real ( Float64 ), dimension ( nlevs , nlevs ) :: H_H_pop , H_e_pop , H_Aq_pop real ( Float64 ), dimension ( nlevs ) :: H_H_depop , H_e_depop , H_Aq_depop integer :: ebi , tii , tei , n , err_status H_H_pop = 0.d0 H_e_pop = 0.d0 H_Aq_pop = 0.d0 H_H_depop = 0.d0 H_e_depop = 0.d0 H_Aq_depop = 0.d0 denp = plasma % denp dene = plasma % dene denimp = plasma % denimp logeb = log10 ( eb ) logti = log10 ( plasma % ti ) logte = log10 ( plasma % te ) !!H_H err_status = 1 logEmin = tables % H_H % logemin logTmin = tables % H_H % logtmin dlogE = tables % H_H % dlogE dlogT = tables % H_H % dlogT neb = tables % H_H % nenergy nt = tables % H_H % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , c , err_status ) ebi = c % i tii = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Ti out of range of H_H table. Setting H_H rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",ES10.3,\" [keV]\")' ) plasma % ti endif else H_H_pop = ( b11 * tables % H_H % log_pop (:,:, ebi , tii , i_type ) + & b12 * tables % H_H % log_pop (:,:, ebi , tii + 1 , i_type ) + & b21 * tables % H_H % log_pop (:,:, ebi + 1 , tii , i_type ) + & b22 * tables % H_H % log_pop (:,:, ebi + 1 , tii + 1 , i_type )) where ( H_H_pop . lt . tables % H_H % minlog_pop ) H_H_pop = 0.d0 elsewhere H_H_pop = denp * exp ( H_H_pop * log_10 ) end where H_H_depop = ( b11 * tables % H_H % log_depop (:, ebi , tii , i_type ) + & b12 * tables % H_H % log_depop (:, ebi , tii + 1 , i_type ) + & b21 * tables % H_H % log_depop (:, ebi + 1 , tii , i_type ) + & b22 * tables % H_H % log_depop (:, ebi + 1 , tii + 1 , i_type )) where ( H_H_depop . lt . tables % H_H % minlog_depop ) H_H_depop = 0.d0 elsewhere H_H_depop = denp * exp ( H_H_depop * log_10 ) end where endif !!H_e err_status = 1 logEmin = tables % H_e % logemin logTmin = tables % H_e % logtmin dlogE = tables % H_e % dlogE dlogT = tables % H_e % dlogT neb = tables % H_e % nenergy nt = tables % H_e % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logte , c , err_status ) ebi = c % i tei = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Te out of range of H_e table. Setting H_e rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"te = \",ES10.3,\" [keV]\")' ) plasma % te endif else H_e_pop = ( b11 * tables % H_e % log_pop (:,:, ebi , tei , i_type ) + & b12 * tables % H_e % log_pop (:,:, ebi , tei + 1 , i_type ) + & b21 * tables % H_e % log_pop (:,:, ebi + 1 , tei , i_type ) + & b22 * tables % H_e % log_pop (:,:, ebi + 1 , tei + 1 , i_type )) where ( H_e_pop . lt . tables % H_e % minlog_pop ) H_e_pop = 0.d0 elsewhere H_e_pop = dene * exp ( H_e_pop * log_10 ) end where H_e_depop = ( b11 * tables % H_e % log_depop (:, ebi , tei , i_type ) + & b12 * tables % H_e % log_depop (:, ebi , tei + 1 , i_type ) + & b21 * tables % H_e % log_depop (:, ebi + 1 , tei , i_type ) + & b22 * tables % H_e % log_depop (:, ebi + 1 , tei + 1 , i_type )) where ( H_e_depop . lt . tables % H_e % minlog_depop ) H_e_depop = 0.d0 elsewhere H_e_depop = dene * exp ( H_e_depop * log_10 ) end where endif !!H_Aq err_status = 1 logEmin = tables % H_Aq % logemin logTmin = tables % H_Aq % logtmin dlogE = tables % H_Aq % dlogE dlogT = tables % H_Aq % dlogT neb = tables % H_Aq % nenergy nt = tables % H_Aq % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , c , err_status ) ebi = c % i tii = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Ti out of range of H_Aq table. Setting H_Aq rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",ES10.3,\" [keV]\")' ) plasma % ti endif else H_Aq_pop = ( b11 * tables % H_Aq % log_pop (:,:, ebi , tii , i_type ) + & b12 * tables % H_Aq % log_pop (:,:, ebi , tii + 1 , i_type ) + & b21 * tables % H_Aq % log_pop (:,:, ebi + 1 , tii , i_type ) + & b22 * tables % H_Aq % log_pop (:,:, ebi + 1 , tii + 1 , i_type )) where ( H_Aq_pop . lt . tables % H_Aq % minlog_pop ) H_Aq_pop = 0.d0 elsewhere H_Aq_pop = denimp * exp ( H_Aq_pop * log_10 ) end where H_Aq_depop = ( b11 * tables % H_Aq % log_depop (:, ebi , tii , i_type ) + & b12 * tables % H_Aq % log_depop (:, ebi , tii + 1 , i_type ) + & b21 * tables % H_Aq % log_depop (:, ebi + 1 , tii , i_type ) + & b22 * tables % H_Aq % log_depop (:, ebi + 1 , tii + 1 , i_type )) where ( H_Aq_depop . lt . tables % H_Aq % minlog_depop ) H_Aq_depop = 0.d0 elsewhere H_Aq_depop = denimp * exp ( H_Aq_depop * log_10 ) end where endif rmat = tables % einstein + H_H_pop + H_e_pop + H_Aq_pop do n = 1 , nlevs rmat ( n , n ) = - sum ( tables % einstein (:, n )) - H_H_depop ( n ) - H_e_depop ( n ) - H_Aq_depop ( n ) enddo end subroutine get_rate_matrix subroutine colrad ( plasma , i_type , vn , dt , states , dens , photons ) !+ Evolve density of states in time `dt` via collisional radiative model type ( LocalProfiles ), intent ( in ) :: plasma !+ Plasma parameters integer , intent ( in ) :: i_type !+ Ion/Neutral type (beam,thermal) real ( Float64 ), dimension (:), intent ( in ) :: vn !+ Neutral velocitiy [cm/s] real ( Float64 ), intent ( in ) :: dt !+ Time interval [s] real ( Float64 ), dimension (:), intent ( inout ) :: states !+ Density of states real ( Float64 ), dimension ( nlevs ), intent ( out ) :: dens !+ Density of neutrals real ( Float64 ), intent ( out ) :: photons !+ Emitted photons(3->2) real ( Float64 ), dimension ( nlevs , nlevs ) :: matrix !! Matrix real ( Float64 ) :: b_amu real ( Float64 ) :: vnet_square !! net velocity of neutrals squared real ( Float64 ) :: eb !! Energy of the fast neutral real ( Float64 ), dimension ( nlevs , nlevs ) :: eigvec real ( Float64 ), dimension ( nlevs ) :: eigval , coef real ( Float64 ), dimension ( nlevs ) :: exp_eigval_dt real ( Float64 ) :: iflux !!Initial total flux integer :: n photons = 0.d0 dens = 0.d0 iflux = sum ( states ) if (. not . plasma % in_plasma ) then dens = states * dt return endif if ( i_type . eq . beam_ion ) then b_amu = inputs % ab else b_amu = inputs % ai endif vnet_square = dot_product ( vn - plasma % vrot , vn - plasma % vrot ) ![cm/s] eb = v2_to_E_per_amu * b_amu * vnet_square ![kev] call get_rate_matrix ( plasma , i_type , eb , matrix ) call eigen ( nlevs , matrix , eigvec , eigval ) call linsolve ( eigvec , states , coef ) !coeffs determined from states at t=0 exp_eigval_dt = exp ( eigval * dt ) ! to improve speed (used twice) do n = 1 , nlevs if ( eigval ( n ). eq . 0.0 ) eigval ( n ) = eigval ( n ) + 1 !protect against dividing by zero enddo states = matmul ( eigvec , coef * exp_eigval_dt ) ![neutrals/cm&#94;3/s]! dens = matmul ( eigvec , coef * ( exp_eigval_dt - 1.d0 ) / eigval ) where ( states . lt . 0 ) states = 0.d0 endwhere where ( dens . lt . 0 ) dens = 0.d0 endwhere photons = dens ( 3 ) * tables % einstein ( 2 , 3 ) !! - [Ph/(s*cm&#94;3)] - !! end subroutine colrad subroutine attenuate ( ri , rf , vi , states , dstep_in ) !+ Attenuate `states` along a trajectory real ( Float64 ), dimension ( 3 ), intent ( in ) :: ri !+ Initial position in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: rf !+ Final position in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Initial velocity of neutral real ( Float64 ), dimension ( nlevs ), intent ( inout ) :: states !+ Density of states real ( Float64 ), intent ( in ), optional :: dstep_in !+ Step length [cm] type ( LocalProfiles ) :: plasma real ( Float64 ) :: photons , vabs , dt , dstep , dis , max_dis real ( Float64 ), dimension ( 3 ) :: r0 real ( Float64 ), dimension ( nlevs ) :: dens logical :: inp integer :: ncross if ( present ( dstep_in )) then dstep = dstep_in else dstep = sqrt ( inter_grid % da ) !cm endif max_dis = norm2 ( rf - ri ) vabs = norm2 ( vi ) dt = dstep / vabs call get_plasma ( plasma , pos = ri ) r0 = ri dis = 0.d0 ncross = 0 inp = plasma % in_plasma do while ( dis . le . max_dis ) call colrad ( plasma , beam_ion , vi , dt , states , dens , photons ) r0 = r0 + vi * dt dis = dis + dstep call get_plasma ( plasma , pos = r0 ) if ( inp . neqv . plasma % in_plasma ) then ncross = ncross + 1 inp = plasma % in_plasma endif enddo if ( ncross . gt . 1 ) states = 0.0 end subroutine attenuate subroutine doppler_stark ( vecp , vi , fields , lambda ) !+ Calculates doppler shift and stark split wavelengths real ( Float64 ), dimension ( 3 ), intent ( in ) :: vecp !+ Vector directing towards optical head real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Particle velocity type ( LocalEMFields ), intent ( in ) :: fields !+ Electro-magnetic fields real ( Float64 ), dimension ( n_stark ), intent ( out ) :: lambda !+ Wavelengths [nm] real ( Float64 ), dimension ( 3 ) :: vp , vn real ( Float64 ), dimension ( 3 ) :: bfield , efield real ( Float64 ) :: E , lambda_shifted !! vector directing towards the optical head vp = vecp / norm2 ( vecp ) !! Calculate Doppler shift vn = vi * 0.01d0 ! [m/s] lambda_shifted = lambda0 * ( 1.d0 + dot_product ( vn , vp ) / c0 ) !! Calculate Stark Splitting !! Calculate E-field bfield = fields % b_norm * fields % b_abs efield = fields % e_norm * fields % e_abs efield ( 1 ) = efield ( 1 ) + vn ( 2 ) * bfield ( 3 ) - vn ( 3 ) * bfield ( 2 ) efield ( 2 ) = efield ( 2 ) - ( vn ( 1 ) * bfield ( 3 ) - vn ( 3 ) * bfield ( 1 )) efield ( 3 ) = efield ( 3 ) + vn ( 1 ) * bfield ( 2 ) - vn ( 2 ) * bfield ( 1 ) E = norm2 ( efield ) !! Stark Splitting lambda = lambda_shifted + E * stark_wavel ![nm] end subroutine spectrum ( vecp , vi , fields , sigma_pi , photons , dlength , lambda , intensity ) !+ Calculates doppler shift, stark splitting, and intensities real ( Float64 ), dimension ( 3 ), intent ( in ) :: vecp !+ Vector directing towards optical head real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Particle velocity type ( LocalEMFields ), intent ( in ) :: fields !+ Electro-magnetic fields real ( Float64 ), intent ( in ) :: sigma_pi !+ Sigma-pi ratio real ( Float64 ), intent ( in ) :: photons !+ Photon density from [[libfida:colrad]] real ( Float64 ), intent ( in ) :: dlength !+ LOS intersection length with [[libfida:beam_grid]] cell particle is in real ( Float64 ), dimension ( n_stark ), intent ( out ) :: lambda !+ Wavelengths [nm] real ( Float64 ), dimension ( n_stark ), intent ( out ) :: intensity !+ Spectra intensities [Ph/(s cm&#94;2 starkline)] real ( Float64 ), dimension ( 3 ) :: vp , vn real ( Float64 ), dimension ( 3 ) :: bfield , efield real ( Float64 ) :: E , cos_los_Efield , lambda_shifted integer , parameter , dimension ( n_stark ) :: stark_sign = + 1 * stark_sigma - 1 * stark_pi !! vector directing towards the optical head vp = vecp / norm2 ( vecp ) ! Calculate Doppler shift vn = vi * 0.01d0 ! [m/s] lambda_shifted = lambda0 * ( 1.d0 + dot_product ( vn , vp ) / c0 ) !! Calculate Stark Splitting ! Calculate E-field bfield = fields % b_norm * fields % b_abs efield = fields % e_norm * fields % e_abs efield ( 1 ) = efield ( 1 ) + vn ( 2 ) * bfield ( 3 ) - vn ( 3 ) * bfield ( 2 ) efield ( 2 ) = efield ( 2 ) - ( vn ( 1 ) * bfield ( 3 ) - vn ( 3 ) * bfield ( 1 )) efield ( 3 ) = efield ( 3 ) + vn ( 1 ) * bfield ( 2 ) - vn ( 2 ) * bfield ( 1 ) E = norm2 ( efield ) !Stark Splitting lambda = lambda_shifted + E * stark_wavel ![nm] !Intensities of stark components if ( E . eq . 0.d0 ) then cos_los_Efield = 0.d0 else cos_los_Efield = dot_product ( vp , efield ) / E endif intensity = stark_intens * ( 1.d0 + stark_sign * cos_los_Efield ** 2 ) !! E.g. mirrors may change the pi to sigma intensity ratio where ( stark_sigma . eq . 1 ) intensity = intensity * sigma_pi endwhere !! normalize and multiply with photon density from colrad intensity = intensity / sum ( intensity ) * photons * dlength endsubroutine spectrum subroutine store_photons ( pos , vi , photons , spectra , passive ) !+ Store photons in `spectra` real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position of neutral real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocitiy of neutral [cm/s] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] real ( Float64 ), dimension (:,:), intent ( inout ) :: spectra logical , intent ( in ), optional :: passive !+ Indicates whether photon is passive FIDA real ( Float64 ), dimension ( n_stark ) :: lambda , intensity real ( Float64 ) :: dlength , sigma_pi type ( LocalEMFields ) :: fields integer ( Int32 ), dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: pos_xyz , lens_xyz , cyl , vp type ( LOSInters ) :: inter integer :: ichan , i , j , bin , nchan logical :: pas = . False . if ( present ( passive )) pas = passive if ( pas ) then cyl ( 1 ) = sqrt ( pos ( 1 ) * pos ( 1 ) + pos ( 2 ) * pos ( 2 )) cyl ( 2 ) = pos ( 3 ) cyl ( 3 ) = atan2 ( pos ( 2 ), pos ( 1 )) call get_passive_grid_indices ( cyl , ind ) inter = spec_chords % cyl_inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) call uvw_to_xyz ( pos , pos_xyz ) else call get_indices ( pos , ind ) inter = spec_chords % inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) pos_xyz = pos endif nchan = inter % nchan if ( nchan . eq . 0 ) return call get_fields ( fields , pos = pos_xyz ) loop_over_channels : do j = 1 , nchan ichan = inter % los_elem ( j )% id dlength = inter % los_elem ( j )% length sigma_pi = spec_chords % los ( ichan )% sigma_pi if ( pas ) then call uvw_to_xyz ( spec_chords % los ( ichan )% lens_uvw , lens_xyz ) else lens_xyz = spec_chords % los ( ichan )% lens endif vp = pos_xyz - lens_xyz call spectrum ( vp , vi , fields , sigma_pi , photons , & dlength , lambda , intensity ) loop_over_stark : do i = 1 , n_stark bin = floor (( lambda ( i ) - inputs % lambdamin ) / inputs % dlambda ) + 1 if ( bin . lt . 1 ) cycle loop_over_stark if ( bin . gt . inputs % nlambda ) cycle loop_over_stark !$OMP ATOMIC UPDATE spectra ( bin , ichan ) = spectra ( bin , ichan ) + intensity ( i ) !$OMP END ATOMIC enddo loop_over_stark enddo loop_over_channels end subroutine store_photons subroutine store_bes_photons ( pos , vi , photons , neut_type ) !+ Store BES photons in [[libfida:spectra]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position of neutral in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocitiy of neutral [cm/s] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] integer , intent ( in ) :: neut_type !+ Neutral type (full,half,third,halo) select case ( neut_type ) case ( nbif_type ) call store_photons ( pos , vi , photons , spec % full ) case ( nbih_type ) call store_photons ( pos , vi , photons , spec % half ) case ( nbit_type ) call store_photons ( pos , vi , photons , spec % third ) case ( dcx_type ) call store_photons ( pos , vi , photons , spec % dcx ) case ( halo_type ) call store_photons ( pos , vi , photons , spec % halo ) case default if ( inputs % verbose . ge . 0 ) then write ( * , '(\"STORE_BES_PHOTONS: Unknown neutral type: \",i2)' ) neut_type endif stop end select end subroutine store_bes_photons subroutine store_fida_photons ( pos , vi , photons , orbit_class , passive ) !+ Store fida photons in [[libfida:spectra]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position of neutral in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocitiy of neutral [cm/s] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] integer , intent ( in ), optional :: orbit_class !+ Orbit class ID logical , intent ( in ), optional :: passive !+ Indicates whether photon is passive FIDA integer :: iclass = 1 logical :: pas = . False . if ( present ( orbit_class )) then iclass = min ( orbit_class , particles % nclass ) endif if ( present ( passive )) pas = passive if ( pas ) then call store_photons ( pos , vi , photons , spec % pfida (:,:, iclass ), passive = . True .) else call store_photons ( pos , vi , photons , spec % fida (:,:, iclass )) endif end subroutine store_fida_photons subroutine store_neutrons ( rate , orbit_class ) !+ Store neutron rate in [[libfida:neutron]] real ( Float64 ), intent ( in ) :: rate !+ Neutron rate [neutrons/sec] integer , intent ( in ), optional :: orbit_class !+ Orbit class ID integer :: iclass if ( present ( orbit_class )) then iclass = min ( orbit_class , particles % nclass ) else iclass = 1 endif !$OMP ATOMIC UPDATE neutron % rate ( iclass ) = neutron % rate ( iclass ) + rate !$OMP END ATOMIC end subroutine store_neutrons subroutine store_fw_photons_at_chan ( ichan , eind , pind , vp , vi , fields , dlength , sigma_pi , denf , photons ) !+ Store FIDA weight photons in [[libfida:fweight]] for a specific channel integer , intent ( in ) :: ichan !+ Channel index integer , intent ( in ) :: eind !+ Energy index integer , intent ( in ) :: pind !+ Pitch index real ( Float64 ), dimension ( 3 ), intent ( in ) :: vp !+ Vector pointing toward optical head real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocity of neutral [cm/s] type ( LocalEMFields ), intent ( in ) :: fields !+ Electro-magnetic fields real ( Float64 ), intent ( in ) :: dlength !+ LOS intersection length with [[libfida:beam_grid]] cell particle is in real ( Float64 ), intent ( in ) :: sigma_pi !+ Sigma-pi ratio for channel real ( Float64 ), intent ( in ) :: denf !+ Fast-ion density [cm&#94;-3] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] real ( Float64 ), dimension ( n_stark ) :: lambda , intensity real ( Float64 ) :: dlambda , intens_fac integer :: i , bin dlambda = ( inputs % lambdamax_wght - inputs % lambdamin_wght ) / inputs % nlambda_wght intens_fac = ( 1.d0 ) / ( 4.d0 * pi * dlambda ) call spectrum ( vp , vi , fields , sigma_pi , photons , & dlength , lambda , intensity ) !$OMP CRITICAL(fida_wght) loop_over_stark : do i = 1 , n_stark bin = floor (( lambda ( i ) - inputs % lambdamin_wght ) / dlambda ) + 1 if ( bin . lt . 1 ) cycle loop_over_stark if ( bin . gt . inputs % nlambda_wght ) cycle loop_over_stark !fida(bin,ichan)= fida(bin,ichan) + & !  (denf*intens_fac*1.d4)*intensity(i) !ph/(s*nm*sr*m&#94;2) fweight % weight ( bin , eind , pind , ichan ) = & fweight % weight ( bin , eind , pind , ichan ) + intensity ( i ) * intens_fac !(ph*cm)/(s*nm*sr*fast-ion*dE*dp) enddo loop_over_stark if ( denf . gt . 0.d0 ) then fweight % mean_f ( eind , pind , ichan ) = fweight % mean_f ( eind , pind , ichan ) + & ( denf * intens_fac ) * sum ( intensity ) endif !$OMP END CRITICAL(fida_wght) end subroutine store_fw_photons_at_chan subroutine store_fw_photons ( eind , pind , pos , vi , denf , photons ) !+ Store FIDA weight photons in [[libfida:fweight]] integer , intent ( in ) :: eind !+ Energy index integer , intent ( in ) :: pind !+ Pitch index real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position of neutral real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocity of neutral [cm/s] real ( Float64 ), intent ( in ) :: denf !+ Fast-ion density [cm&#94;-3] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] real ( Float64 ) :: dlength , sigma_pi type ( LocalEMFields ) :: fields integer ( Int32 ), dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: vp type ( LOSInters ) :: inter integer :: ichan , nchan , i call get_indices ( pos , ind ) inter = spec_chords % inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) nchan = inter % nchan if ( nchan . eq . 0 ) return call get_fields ( fields , pos = pos ) loop_over_channels : do i = 1 , nchan ichan = inter % los_elem ( i )% id dlength = inter % los_elem ( i )% length sigma_pi = spec_chords % los ( ichan )% sigma_pi vp = pos - spec_chords % los ( ichan )% lens call store_fw_photons_at_chan ( ichan , eind , pind , & vp , vi , fields , dlength , sigma_pi , denf , photons ) enddo loop_over_channels end subroutine store_fw_photons !============================================================================= !---------------------------Monte Carlo Routines------------------------------ !============================================================================= subroutine get_nlaunch ( nr_markers , papprox , nlaunch ) !+ Sets the number of MC markers launched from each [[libfida:beam_grid]] cell integer ( Int64 ), intent ( in ) :: nr_markers !+ Approximate total number of markers to launch real ( Float64 ), dimension (:,:,:), target , intent ( in ) :: papprox !+ [[libfida:beam_grid]] cell weights integer ( Int32 ), dimension (:,:,:), intent ( out ) :: nlaunch !+ Number of mc markers to launch for each cell: nlaunch(x,y,z) logical , dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: mask real ( Float64 ), dimension ( beam_grid % ngrid ) :: cdf integer :: c , i , j , k , nc , nm , ind ( 3 ) integer :: nmin = 5 integer , dimension ( 1 ) :: randomi type ( rng_type ) :: r real ( Float64 ), pointer :: papprox_ptr (:) !! Fill in minimum number of markers per cell nlaunch = 0 mask = papprox . gt . 0.0 where ( mask ) nlaunch = nmin endwhere !! If there are any left over distribute according to papprox nc = count ( mask ) if ( nr_markers . gt .( nmin * nc )) then nm = nr_markers - nmin * nc !! precalculate cdf to save time call c_f_pointer ( c_loc ( papprox ), papprox_ptr , [ beam_grid % ngrid ]) call cumsum ( papprox_ptr , cdf ) !! use the same seed for all processes call rng_init ( r , 932117 ) do c = 1 , nm call randind_cdf ( r , cdf , randomi ) call ind2sub ( beam_grid % dims , randomi ( 1 ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) nlaunch ( i , j , k ) = nlaunch ( i , j , k ) + 1 enddo endif end subroutine get_nlaunch subroutine get_nlaunch_pass_grid ( nr_markers , papprox , nlaunch ) !+ Sets the number of MC markers launched from each [[libfida:pass_grid]] cell integer ( Int64 ), intent ( in ) :: nr_markers !+ Approximate total number of markers to launch real ( Float64 ), dimension (:,:,:), intent ( in ) :: papprox !+ [[libfida:pass_grid]] cell weights integer ( Int32 ), dimension (:,:,:), intent ( out ) :: nlaunch !+ Number of mc markers to launch for each cell: nlaunch(r,z,phi) logical , dimension ( pass_grid % nr , pass_grid % nz , pass_grid % nphi ) :: mask real ( Float64 ), dimension ( pass_grid % ngrid ) :: cdf integer , dimension ( 1 ) :: randomi type ( rng_type ) :: r integer :: c , i , j , k , nc , nm , ind ( 3 ) integer :: nmin = 5 !! Fill in minimum number of markers per cell nlaunch = 0 mask = papprox . gt . 0.0 where ( mask ) nlaunch = nmin endwhere !! If there are any left over distribute according to papprox nc = count ( mask ) if ( nr_markers . gt .( nmin * nc )) then nm = nr_markers - nmin * nc !! precalculate cdf to save time call cumsum ( reshape ( papprox ,[ pass_grid % ngrid ]), cdf ) !! use the same seed for all processes call rng_init ( r , 932117 ) do c = 1 , nm call randind_cdf ( r , cdf , randomi ) call ind2sub ( pass_grid % dims , randomi ( 1 ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) nlaunch ( i , j , k ) = nlaunch ( i , j , k ) + 1 enddo endif end subroutine get_nlaunch_pass_grid subroutine pitch_to_vec ( pitch , gyroangle , fields , vi_norm ) !+ Calculates velocity vector from pitch, gyroangle and fields real ( Float64 ), intent ( in ) :: pitch !+ Pitch real ( Float64 ), intent ( in ) :: gyroangle !+ Gyroangle [radians] type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields real ( Float64 ), dimension ( 3 ), intent ( out ) :: vi_norm !+ Normalized velocity vector real ( Float64 ) :: sinus sinus = sqrt ( max ( 1.d0 - pitch ** 2 , 0.d0 )) vi_norm = ( sinus * cos ( gyroangle ) * fields % a_norm + & pitch * fields % b_norm + & sinus * sin ( gyroangle ) * fields % c_norm ) end subroutine pitch_to_vec subroutine gyro_step ( vi , fields , r_gyro ) !+ Calculates gyro-step !+ !+###References !+ Belova, E. V., N. N. Gorelenkov, and C. Z. Cheng. \"Self-consistent equilibrium model of low aspect- !+ ratio toroidal plasma with energetic beam ions.\" Physics of Plasmas (1994-present) 10.8 (2003): !+ 3240-3251. Appendix A: Last equation real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Ion velocity type ( LocalEMFields ), intent ( in ) :: fields !+ Electro-magnetic fields real ( Float64 ), dimension ( 3 ), intent ( out ) :: r_gyro !+ Gyro-step !+ Gyro-radius vector from particle position to guiding center real ( Float64 ), dimension ( 3 ) :: vxB , rg_uvw , uvw , cuvrxb , b_rtz , grad_B , rg_rtz real ( Float64 ) :: one_over_omega , phi , R , vpar , term1 , term2 if ( inputs % flr . ge . 1 ) then uvw = fields % uvw R = sqrt ( uvw ( 1 ) ** 2 + uvw ( 2 ) ** 2 ) phi = atan2 ( uvw ( 2 ), uvw ( 1 )) one_over_omega = inputs % ab * mass_u / ( fields % b_abs * e0 ) vxB = cross_product ( vi , fields % b_norm ) vpar = dot_product ( vi , fields % b_norm ) r_gyro = vxB * one_over_omega !points towards gyrocenter, in beam coordinates if ( inputs % flr . ge . 2 ) then !! convert the r_gyro vector to machine coordiantes if ( fields % coords . eq . 0 ) then rg_uvw = matmul ( beam_grid % basis , r_gyro ) endif if ( fields % coords . eq . 1 ) then rg_uvw = r_gyro endif b_rtz ( 1 ) = fields % br / fields % b_abs b_rtz ( 2 ) = fields % bt / fields % b_abs b_rtz ( 3 ) = fields % bz / fields % b_abs cuvrxb ( 1 ) = ( 1. / R * fields % dbz_dphi - fields % dbt_dz ) / fields % b_abs cuvrxb ( 2 ) = ( fields % dbr_dz - fields % dbz_dr ) / fields % b_abs cuvrxb ( 3 ) = ( 1.0 / R * fields % bt + fields % dbt_dr - 1.0 / R * fields % dbr_dphi ) / fields % b_abs term1 = vpar * one_over_omega * dot_product ( b_rtz , cuvrxb ) grad_B ( 1 ) = ( fields % br * fields % dbr_dr + fields % bt * fields % dbt_dr + fields % bz * fields % dbz_dr ) / & fields % b_abs grad_B ( 2 ) = 1.0 / R * ( fields % br * fields % dbr_dphi + fields % bt * fields % dbt_dphi + fields % bz * fields % dbz_dphi ) / & fields % b_abs grad_B ( 3 ) = ( fields % br * fields % dbr_dz + fields % bt * fields % dbt_dz + fields % bz * fields % dbz_dz ) / & fields % b_abs !convert rg_uvw vector to cylindrical coordiantes rg_rtz ( 1 ) = rg_uvw ( 1 ) * cos ( phi ) + rg_uvw ( 2 ) * sin ( phi ) rg_rtz ( 2 ) = - rg_uvw ( 1 ) * sin ( phi ) + rg_uvw ( 2 ) * cos ( phi ) rg_rtz ( 3 ) = rg_uvw ( 3 ) term2 = - 1.0 / ( 2.0 * fields % b_abs ) * dot_product ( rg_rtz , grad_B ) else term1 = 0.0 term2 = 0.0 endif r_gyro = r_gyro * ( 1.0 - term1 - term2 ) if (( 1.0 - term1 - term2 . le . 0.0 ) . or . ( 1.0 - term1 - term2 . ge . 2.0 ) ) then write ( * , * ) 'GYRO_STEP: Gyro correction results in negative distances or too large shift: ' , & 1.0 - term1 - term2 stop endif else r_gyro = 0.d0 endif end subroutine gyro_step subroutine gyro_correction ( fields , energy , pitch , rp , vp , theta_in ) !+ Calculates gyro correction for Guiding Center MC distribution calculation type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields at guiding center real ( Float64 ), intent ( in ) :: energy !+ Energy of particle real ( Float64 ), intent ( in ) :: pitch !+ Particle pitch w.r.t the magnetic field real ( Float64 ), dimension ( 3 ), intent ( out ) :: rp !+ Particle position real ( Float64 ), dimension ( 3 ), intent ( out ) :: vp !+ Particle velocity real ( Float64 ), intent ( in ), optional :: theta_in !+ Gyro-angle real ( Float64 ), dimension ( 3 ) :: vi_norm , r_step real ( Float64 ), dimension ( 1 ) :: randomu real ( Float64 ) :: vabs , theta vabs = sqrt ( energy / ( v2_to_E_per_amu * inputs % ab )) if ( present ( theta_in )) then theta = theta_in else !! Sample gyroangle call randu ( randomu ) theta = 2 * pi * randomu ( 1 ) endif !! Calculate velocity vector call pitch_to_vec ( pitch , theta , fields , vi_norm ) vp = vabs * vi_norm !! Move to particle location call gyro_step ( vp , fields , r_step ) rp = fields % pos - r_step end subroutine gyro_correction function gyro_radius ( fields , energy , pitch ) result ( gyro_rad ) !+ Calculates mean gyro-radius type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields at guiding center real ( Float64 ), intent ( in ) :: energy !+ Energy of particle real ( Float64 ), intent ( in ) :: pitch !+ Particle pitch w.r.t the magnetic field real ( Float64 ) :: gyro_rad !+ Mean gyro-radius real ( Float64 ), dimension ( 3 ) :: vi_norm , r_step real ( Float64 ) :: vabs , phi integer :: i , n vabs = sqrt ( energy / ( v2_to_E_per_amu * inputs % ab )) gyro_rad = 0.d0 n = 6 do i = 1 , n phi = i * 2 * pi / n call pitch_to_vec ( pitch , phi , fields , vi_norm ) call gyro_step ( vabs * vi_norm , fields , r_step ) gyro_rad = gyro_rad + norm2 ( r_step ) / n enddo end function gyro_radius subroutine mc_fastion ( ind , fields , eb , ptch , denf ) !+ Samples a Guiding Center Fast-ion distribution function at a given [[libfida:beam_grid]] index integer , dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] index type ( LocalEMFields ), intent ( out ) :: fields !+ Electromagnetic fields at the guiding center real ( Float64 ), intent ( out ) :: eb !+ Energy of the fast ion real ( Float64 ), intent ( out ) :: ptch !+ Pitch of the fast ion real ( Float64 ), intent ( out ) :: denf !+ Fast-ion density at guiding center real ( Float64 ), dimension ( fbm % nenergy , fbm % npitch ) :: fbeam real ( Float64 ), dimension ( 3 ) :: rg real ( Float64 ), dimension ( 3 ) :: randomu3 integer , dimension ( 2 , 1 ) :: ep_ind call randu ( randomu3 ) rg ( 1 ) = beam_grid % xc ( ind ( 1 )) + beam_grid % dr ( 1 ) * ( randomu3 ( 1 ) - 0.5 ) rg ( 2 ) = beam_grid % yc ( ind ( 2 )) + beam_grid % dr ( 2 ) * ( randomu3 ( 2 ) - 0.5 ) rg ( 3 ) = beam_grid % zc ( ind ( 3 )) + beam_grid % dr ( 3 ) * ( randomu3 ( 3 ) - 0.5 ) denf = 0.d0 call get_fields ( fields , pos = rg ) if (. not . fields % in_plasma ) return call get_distribution ( fbeam , denf , pos = rg , coeffs = fields % b ) call randind ( fbeam , ep_ind ) call randu ( randomu3 ) eb = fbm % energy ( ep_ind ( 1 , 1 )) + fbm % dE * ( randomu3 ( 1 ) - 0.5 ) ptch = fbm % pitch ( ep_ind ( 2 , 1 )) + fbm % dp * ( randomu3 ( 2 ) - 0.5 ) end subroutine mc_fastion subroutine mc_fastion_pass_grid ( ind , fields , eb , ptch , denf , output_coords ) !+ Samples a Guiding Center Fast-ion distribution function at a given [[libfida:pass_grid]] index integer , dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:pass_grid]] index type ( LocalEMFields ), intent ( out ) :: fields !+ Electromagnetic fields at the guiding center real ( Float64 ), intent ( out ) :: eb !+ Energy of the fast ion real ( Float64 ), intent ( out ) :: ptch !+ Pitch of the fast ion real ( Float64 ), intent ( out ) :: denf !+ Fast-ion density at guiding center integer , intent ( in ), optional :: output_coords !+ Indicates coordinate system of `fields`. Beam grid (0), machine (1) and cylindrical (2) real ( Float64 ), dimension ( fbm % nenergy , fbm % npitch ) :: fbeam real ( Float64 ), dimension ( 3 ) :: rg , rg_cyl real ( Float64 ), dimension ( 3 ) :: randomu3 real ( Float64 ) :: rmin , rmax , zmin , phimin integer , dimension ( 2 , 1 ) :: ep_ind integer :: ocs if ( present ( output_coords )) then ocs = output_coords else ocs = 0 endif denf = 0.d0 call randu ( randomu3 ) rmin = pass_grid % r ( ind ( 1 )) rmax = rmin + pass_grid % dr zmin = pass_grid % z ( ind ( 2 )) phimin = pass_grid % phi ( ind ( 3 )) ! Sample uniformally in annulus rg_cyl ( 1 ) = sqrt ( randomu3 ( 1 ) * ( rmax ** 2 - rmin ** 2 ) + rmin ** 2 ) rg_cyl ( 2 ) = zmin + randomu3 ( 2 ) * pass_grid % dz rg_cyl ( 3 ) = phimin + randomu3 ( 3 ) * pass_grid % dphi call cyl_to_uvw ( rg_cyl , rg ) call get_fields ( fields , pos = rg , input_coords = 1 , output_coords = ocs ) if (. not . fields % in_plasma ) return call get_distribution ( fbeam , denf , coeffs = fields % b ) call randind ( fbeam , ep_ind ) call randu ( randomu3 ) eb = fbm % energy ( ep_ind ( 1 , 1 )) + fbm % dE * ( randomu3 ( 1 ) - 0.5 ) ptch = fbm % pitch ( ep_ind ( 2 , 1 )) + fbm % dp * ( randomu3 ( 2 ) - 0.5 ) end subroutine mc_fastion_pass_grid subroutine mc_halo ( ind , vhalo , ri , plasma_in ) !+ Sample thermal Maxwellian distribution at [[libfida:beam_grid]] indices `ind` integer , dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices real ( Float64 ), dimension ( 3 ), intent ( out ) :: vhalo !+ Velocity [cm/s] real ( Float64 ), dimension ( 3 ), intent ( out ), optional :: ri !+ Position in [[libfida:beam_grid]] cell type ( LocalProfiles ), intent ( in ), optional :: plasma_in !+ Plasma parameters type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( 3 ) :: random3 if (. not . present ( plasma_in )) then if ( present ( ri )) then call randu ( random3 ) ri ( 1 ) = beam_grid % xc ( ind ( 1 )) + beam_grid % dr ( 1 ) * ( random3 ( 1 ) - 0.5 ) ri ( 2 ) = beam_grid % yc ( ind ( 2 )) + beam_grid % dr ( 2 ) * ( random3 ( 2 ) - 0.5 ) ri ( 3 ) = beam_grid % zc ( ind ( 3 )) + beam_grid % dr ( 3 ) * ( random3 ( 3 ) - 0.5 ) call get_plasma ( plasma , pos = ri ) else call get_plasma ( plasma , ind = ind ) endif else plasma = plasma_in endif call randn ( random3 ) vhalo = plasma % vrot + sqrt ( plasma % ti * 0.5 / ( v2_to_E_per_amu * inputs % ai )) * random3 !![cm/s] end subroutine mc_halo subroutine mc_nbi ( vnbi , efrac , rnbi , err ) !+ Generates a neutral beam particle trajectory integer , intent ( in ) :: efrac !+ Beam neutral type (1,2,3) real ( Float64 ), dimension ( 3 ), intent ( out ) :: vnbi !+ Velocity [cm/s] real ( Float64 ), dimension ( 3 ), intent ( out ) :: rnbi !+ Starting position on [[libfida:beam_grid]] logical , intent ( out ) :: err !+ Error Code real ( Float64 ), dimension ( 3 ) :: r_exit real ( Float64 ), dimension ( 3 ) :: uvw_src !! Start position on ion source real ( Float64 ), dimension ( 3 ) :: xyz_src !! Start position on ion source real ( Float64 ), dimension ( 3 ) :: uvw_ray !! NBI velocity in uvw coords real ( Float64 ), dimension ( 3 ) :: xyz_ray !! NBI velocity in xyz coords real ( Float64 ), dimension ( 3 ) :: xyz_ape !! Aperture plane intersection point real ( Float64 ), dimension ( 2 ) :: randomu !! uniform random numbers real ( Float64 ), dimension ( 2 ) :: randomn !! normal random numbers real ( Float64 ) :: length , sqrt_rho , theta integer :: i , j logical :: inp , valid_trajectory err = . False . valid_trajectory = . False . rejection_loop : do i = 1 , 1000 call randu ( randomu ) select case ( nbi % shape ) case ( 1 ) ! Uniformally sample in rectangle xyz_src ( 1 ) = 0.d0 xyz_src ( 2 ) = nbi % widy * 2.d0 * ( randomu ( 1 ) - 0.5d0 ) xyz_src ( 3 ) = nbi % widz * 2.d0 * ( randomu ( 2 ) - 0.5d0 ) case ( 2 ) ! Uniformally sample in ellipse sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) xyz_src ( 1 ) = 0.d0 xyz_src ( 2 ) = nbi % widy * sqrt_rho * cos ( theta ) xyz_src ( 3 ) = nbi % widz * sqrt_rho * sin ( theta ) end select !! Create random velocity vector call randn ( randomn ) xyz_ray ( 1 ) = 1.d0 xyz_ray ( 2 ) = ( - xyz_src ( 2 ) / nbi % focy + tan ( nbi % divy ( efrac ) * randomn ( 1 ))) xyz_ray ( 3 ) = ( - xyz_src ( 3 ) / nbi % focz + tan ( nbi % divz ( efrac ) * randomn ( 2 ))) aperture_loop : do j = 1 , nbi % naperture xyz_ape = xyz_ray * nbi % adist ( j ) + xyz_src select case ( nbi % ashape ( j )) case ( 1 ) if (( abs ( xyz_ape ( 2 ) - nbi % aoffy ( j )). gt . nbi % awidy ( j )). or .& ( abs ( xyz_ape ( 3 ) - nbi % aoffz ( j )). gt . nbi % awidz ( j ))) then cycle rejection_loop endif case ( 2 ) if (((( xyz_ape ( 2 ) - nbi % aoffy ( j )) * nbi % awidz ( j )) ** 2 + & (( xyz_ape ( 3 ) - nbi % aoffz ( j )) * nbi % awidy ( j )) ** 2 ). gt . & ( nbi % awidy ( j ) * nbi % awidz ( j )) ** 2 ) then cycle rejection_loop endif end select enddo aperture_loop valid_trajectory = . True . !! Convert to beam centerline coordinates to beam grid coordinates uvw_src = matmul ( nbi % basis , xyz_src ) + nbi % src uvw_ray = matmul ( nbi % basis , xyz_ray ) exit rejection_loop enddo rejection_loop !Set Default trajectory in case rejection sampling fails if (. not . valid_trajectory ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"MC_NBI: Failed to find trajectory though aperture(s). Using beam centerline.\" endif uvw_src = nbi % src uvw_ray = nbi % axis endif vnbi = uvw_ray / norm2 ( uvw_ray ) !! Determine start position on beam grid call grid_intersect ( uvw_src , vnbi , length , rnbi , r_exit ) if ( length . le . 0.0 ) then err = . True . nbi_outside = nbi_outside + 1 endif !! Check if start position is in the plasma call in_plasma ( rnbi , inp ) if ( inp ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"MC_NBI: A beam neutral has started inside the plasma.\" write ( * , '(a)' ) \"Move the beam grid closer to the source to fix\" endif stop endif !! Determine velocity of neutrals corrected by efrac vnbi = vnbi * nbi % vinj / sqrt ( real ( efrac )) end subroutine mc_nbi subroutine mc_nbi_cell ( ind , neut_type , vnbi , weight ) !+ Generates a neutral beam velocity vector !+ that passes through cell at `ind` with weight `weight` integer , dimension ( 3 ), intent ( in ) :: ind !+ Cell index integer , intent ( in ) :: neut_type !+ Neutral Type (1=Full,2=Half,3=Third) real ( Float64 ), dimension ( 3 ), intent ( out ) :: vnbi !+ Normalized Velocity real ( Float64 ), intent ( out ) :: weight !+ Weigth/probability of trajectory real ( Float64 ), dimension ( 3 ) :: rc !! Center of cell in uvw coords real ( Float64 ), dimension ( 3 ) :: uvw_rf !! End position in xyz coords real ( Float64 ), dimension ( 3 ) :: xyz_rf !! End position in xyz coords real ( Float64 ), dimension ( 3 ) :: uvw_src !! Start position on ion source real ( Float64 ), dimension ( 3 ) :: xyz_src !! Start position on ion source real ( Float64 ), dimension ( 3 ) :: uvw_ray !! NBI velocity in uvw coords real ( Float64 ), dimension ( 3 ) :: xyz_ray !! NBI velocity in xyz coords real ( Float64 ), dimension ( 3 ) :: xyz_ape !! Aperture plane intersection point real ( Float64 ), dimension ( 3 ) :: randomu !! uniform random numbers real ( Float64 ) :: sqrt_rho , theta , vy , vz , theta_y , theta_z , py , pz integer :: i , j logical :: valid_trajectory rc = [ beam_grid % xc ( ind ( 1 )), beam_grid % yc ( ind ( 2 )), beam_grid % zc ( ind ( 3 ))] valid_trajectory = . False . rejection_loop : do i = 1 , 1000 call randu ( randomu ) select case ( nbi % shape ) case ( 1 ) ! Uniformally sample in rectangle xyz_src ( 1 ) = 0.d0 xyz_src ( 2 ) = nbi % widy * 2.d0 * ( randomu ( 1 ) - 0.5d0 ) xyz_src ( 3 ) = nbi % widz * 2.d0 * ( randomu ( 2 ) - 0.5d0 ) case ( 2 ) ! Uniformally sample in ellipse sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) xyz_src ( 1 ) = 0.d0 xyz_src ( 2 ) = nbi % widy * sqrt_rho * cos ( theta ) xyz_src ( 3 ) = nbi % widz * sqrt_rho * sin ( theta ) end select !! Create random position in the cell call randu ( randomu ) uvw_rf = rc + ( randomu - 0.5 ) * beam_grid % dr xyz_rf = matmul ( nbi % inv_basis , uvw_rf - nbi % src ) xyz_ray = xyz_rf - xyz_src xyz_ray = xyz_ray / norm2 ( xyz_ray ) aperture_loop : do j = 1 , nbi % naperture xyz_ape = xyz_ray * nbi % adist ( j ) + xyz_src select case ( nbi % ashape ( j )) case ( 1 ) if (( abs ( xyz_ape ( 2 ) - nbi % aoffy ( j )). gt . nbi % awidy ( j )). or .& ( abs ( xyz_ape ( 3 ) - nbi % aoffz ( j )). gt . nbi % awidz ( j ))) then cycle rejection_loop endif case ( 2 ) if (((( xyz_ape ( 2 ) - nbi % aoffy ( j )) * nbi % awidz ( j )) ** 2 + & (( xyz_ape ( 3 ) - nbi % aoffz ( j )) * nbi % awidy ( j )) ** 2 ). gt . & ( nbi % awidy ( j ) * nbi % awidz ( j )) ** 2 ) then cycle rejection_loop endif end select enddo aperture_loop valid_trajectory = . True . !! Convert to beam centerline coordinates to beam grid coordinates uvw_src = matmul ( nbi % basis , xyz_src ) + nbi % src uvw_ray = matmul ( nbi % basis , xyz_ray ) vnbi = nbi % vinj * uvw_ray / norm2 ( uvw_ray ) / sqrt ( real ( neut_type )) exit rejection_loop enddo rejection_loop !Set Default trajectory in case rejection sampling fails if (. not . valid_trajectory ) then call randu ( randomu ) uvw_rf = rc + ( randomu - 0.5 ) * beam_grid % dr uvw_ray = uvw_rf - nbi % src vnbi = nbi % vinj * uvw_ray / norm2 ( uvw_ray ) / sqrt ( real ( neut_type )) endif !! Find probability of trajectory vy = xyz_ray ( 2 ) / xyz_ray ( 1 ) vz = xyz_ray ( 3 ) / xyz_ray ( 1 ) theta_y = atan ( vy + xyz_src ( 2 ) / nbi % focy ) theta_z = atan ( vz + xyz_src ( 3 ) / nbi % focz ) py = ( 1.0 / ( 1.0 + ( vy + xyz_src ( 2 ) / nbi % focy ) ** 2 )) * & exp ( - ( theta_y ** 2 ) / ( 2 * nbi % divy ( neut_type ) ** 2 )) / & sqrt ( 2 * nbi % divy ( neut_type ) ** 2 ) pz = ( 1.0 / ( 1.0 + ( vz + xyz_src ( 3 ) / nbi % focy ) ** 2 )) * & exp ( - ( theta_z ** 2 ) / ( 2 * nbi % divz ( neut_type ) ** 2 )) / & sqrt ( 2 * nbi % divz ( neut_type ) ** 2 ) weight = py * pz end subroutine mc_nbi_cell !============================================================================= !------------------------Primary Simulation Routines-------------------------- !============================================================================= subroutine ndmc !+ Calculates neutral beam deposition and spectra integer :: neut_type !! full half third energy real ( Float64 ) :: nlaunch !! nr. of markers real ( Float64 ) :: nneutrals !! # NBI particles real ( Float64 ), dimension ( 3 ) :: vnbi !! velocities(full..) real ( Float64 ), dimension ( 3 ) :: rnbi !! initial position integer ( Int64 ) :: jj , ii , kk , cnt integer :: ntrack type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( Float64 ), dimension ( nlevs ) :: states , dens real ( Float64 ) :: photons , iflux , flux_tot integer ( Int32 ), dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: ri , ri_gc , r_gyro real ( Float64 ), dimension ( 1 ) :: randomu integer , dimension ( 1 ) :: randi logical :: err if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) inputs % n_nbi if ( inputs % calc_birth . ge . 1 ) then write ( * , '(T6,\"# of birth markers: 3 x\",i10)' ) int ( inputs % n_nbi * inputs % n_birth ) endif endif !! # of injected neutrals = NBI power/energy_per_particle nneutrals = 1.d6 * nbi % pinj / ( 1.d3 * nbi % einj * e0 & * ( nbi % current_fractions ( 1 ) & + nbi % current_fractions ( 2 ) / 2.d0 & + nbi % current_fractions ( 3 ) / 3.d0 ) ) nlaunch = real ( inputs % n_nbi ) !$OMP PARALLEL DO schedule(guided) & !$OMP& private(vnbi,rnbi,tracks,ntrack,plasma,fields,randi,flux_tot, & !$OMP& states,dens,iflux,photons,neut_type,jj,ii,kk,ind,err,ri,ri_gc,r_gyro) loop_over_markers : do ii = istart , inputs % n_nbi , istep energy_fractions : do neut_type = 1 , 3 !! (type = 1: full energy, =2: half energy, =3: third energy call mc_nbi ( vnbi , neut_type , rnbi , err ) if ( err ) cycle energy_fractions call track ( rnbi , vnbi , tracks , ntrack ) if ( ntrack . eq . 0 ) cycle energy_fractions !! Solve collisional radiative model along track flux_tot = 0.d0 states = 0.d0 states ( 1 ) = nneutrals * nbi % current_fractions ( neut_type ) / beam_grid % dv loop_along_track : do jj = 1 , ntrack iflux = sum ( states ) ind = tracks ( jj )% ind call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vnbi , tracks ( jj )% time , states , dens , photons ) call store_neutrals ( ind , neut_type , dens / nlaunch , vnbi ) tracks ( jj )% flux = ( iflux - sum ( states )) / nlaunch flux_tot = flux_tot + tracks ( jj )% flux * beam_grid % dv if ( inputs % calc_birth . ge . 1 ) then call store_births ( ind , neut_type , tracks ( jj )% flux ) endif if (( photons . gt . 0.d0 ). and .( inputs % calc_bes . ge . 1 )) then call store_bes_photons ( tracks ( jj )% pos , vnbi , photons / nlaunch , neut_type ) endif enddo loop_along_track if (( inputs % calc_birth . ge . 1 ). and .( flux_tot . gt . 0.d0 )) then !! Sample according to deposited flux along neutral trajectory !$OMP CRITICAL(ndmc_birth) do kk = 1 , inputs % n_birth call randind ( tracks ( 1 : ntrack )% flux , randi ) call randu ( randomu ) birth % part ( birth % cnt )% neut_type = neut_type birth % part ( birth % cnt )% energy = nbi % einj / real ( neut_type ) birth % part ( birth % cnt )% weight = flux_tot / inputs % n_birth birth % part ( birth % cnt )% ind = tracks ( randi ( 1 ))% ind birth % part ( birth % cnt )% vi = vnbi ri = tracks ( randi ( 1 ))% pos + vnbi * ( tracks ( randi ( 1 ))% time * ( randomu ( 1 ) - 0.5 )) birth % part ( birth % cnt )% ri = ri call get_fields ( fields , pos = ri ) birth % part ( birth % cnt )% pitch = dot_product ( fields % b_norm , vnbi / norm2 ( vnbi )) call gyro_step ( vnbi , fields , r_gyro ) birth % part ( birth % cnt )% ri_gc = ri + r_gyro birth % cnt = birth % cnt + 1 enddo !$OMP END CRITICAL(ndmc_birth) endif enddo energy_fractions enddo loop_over_markers !$OMP END PARALLEL DO #ifdef _MPI !! Combine beam neutrals call parallel_sum ( neut % full ) call parallel_sum ( neut % half ) call parallel_sum ( neut % third ) call parallel_sum ( nbi_outside ) if ( inputs % calc_birth . ge . 1 ) then call parallel_sum ( birth % dens ) endif !! Combine spectra if ( inputs % calc_bes . ge . 1 ) then call parallel_sum ( spec % full ) call parallel_sum ( spec % half ) call parallel_sum ( spec % third ) endif #endif if ( nbi_outside . gt . 0 ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a, f6.2,a)' ) 'Percent of markers outside the grid: ' , & 10 0. * nbi_outside / ( 3. * inputs % n_nbi ), '%' endif if ( sum ( neut % full ). eq . 0 ) stop 'Beam does not intersect the grid!' endif end subroutine ndmc subroutine bremsstrahlung !+ Calculates bremsstrahlung type ( LocalProfiles ) :: plasma integer :: i , ichan , nc , ic real ( Float64 ) :: dlength , dlambda , gaunt , max_length real ( Float64 ) :: spot_size , theta , sqrt_rho real ( Float64 ), dimension ( 2 ) :: randomu real ( Float64 ), dimension ( 3 ) :: vi , xyz , r0 real ( Float64 ), dimension ( 3 , 3 ) :: basis real ( Float64 ), dimension (:), allocatable :: lambda_arr , brems allocate ( lambda_arr ( inputs % nlambda )) allocate ( brems ( inputs % nlambda )) do i = 1 , inputs % nlambda lambda_arr ( i ) = 10 * (( i - 0.5 ) * inputs % dlambda + inputs % lambdamin ) ! [A] enddo dlambda = 10 * inputs % dlambda ![A] dlength = 0.3 !cm !! $OMP PARALLEL DO schedule(guided) private(ichan,xyz,vi,basis,spot_size, & !! $OMP& max_length, ic, nc,randomu,sqrt_rho,theta,r0,plasma,gaunt,brems) loop_over_channels : do ichan = istart , spec_chords % nchan , istep xyz = spec_chords % los ( ichan )% lens vi = spec_chords % los ( ichan )% axis vi = vi / norm2 ( vi ) spot_size = spec_chords % los ( ichan )% spot_size call line_basis ( xyz , vi , basis ) if ( spot_size . le . 0.d0 ) then nc = 1 else nc = 100 endif loop_over_los : do ic = 1 , nc call randu ( randomu ) sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) r0 ( 1 ) = 0.d0 r0 ( 2 ) = spot_size * sqrt_rho * cos ( theta ) r0 ( 3 ) = spot_size * sqrt_rho * sin ( theta ) r0 = matmul ( basis , r0 ) + xyz ! Find edge of plasma call get_plasma ( plasma , pos = r0 ) max_length = 0.0 do while (. not . plasma % in_plasma ) r0 = r0 + vi * dlength ! move dlength call get_plasma ( plasma , pos = r0 ) max_length = max_length + dlength if ( max_length . gt . 300 ) cycle loop_over_los enddo ! Calculate bremsstrahlung along los do while ( plasma % in_plasma ) if ( plasma % te . gt . 0.0 ) then gaunt = 5.542 - ( 3.108 - log ( plasma % te )) * ( 0.6905 - 0.1323 / plasma % zeff ) brems = ( 7.57d-9 ) * gaunt * (( plasma % dene ** 2 ) * plasma % zeff / ( lambda_arr & * sqrt ( plasma % te * 100 0.0 ))) * exp ( - h_planck * c0 / (( 1.d-10 ) * lambda_arr * plasma % te * 1.d3 )) & * dlambda * ( 4.d0 * pi ) * 1.d-4 spec % brems (:, ichan ) = spec % brems (:, ichan ) + ( brems * dlength * 1.d-2 ) / nc endif ! Take a step r0 = r0 + vi * dlength call get_plasma ( plasma , pos = r0 ) enddo enddo loop_over_los enddo loop_over_channels !! $OMP END PARALLEL DO #ifdef _MPI !! Combine Brems call parallel_sum ( spec % brems ) #endif deallocate ( lambda_arr , brems ) end subroutine bremsstrahlung subroutine dcx !+ Calculates Direct Charge Exchange (DCX) neutral density and spectra integer :: ic , i , j , k , ncell integer ( Int64 ) :: idcx !! counter real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vihalo integer , dimension ( 3 ) :: ind integer , dimension ( 3 ) :: neut_types = [ 1 , 2 , 3 ] !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( Float64 ), dimension ( nlevs ) :: rates !!  CX rates !! Collisiional radiative model along track real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states integer :: ntrack type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks !! Particle tracks integer :: jj !! counter along track real ( Float64 ) :: max_papprox , tot_denn , photons !! photon flux integer , dimension ( beam_grid % ngrid ) :: cell_ind real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox integer ( Int32 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: nlaunch real ( Float64 ) :: fi_correction halo_iter_dens ( dcx_type ) = 0.d0 papprox = 0.d0 tot_denn = 0.d0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) call get_plasma ( plasma , ind = ind ) if (. not . plasma % in_plasma ) cycle tot_denn = sum ( neut % full (:, i , j , k )) + & sum ( neut % half (:, i , j , k )) + & sum ( neut % third (:, i , j , k )) papprox ( i , j , k ) = tot_denn * ( plasma % denp - plasma % denf ) enddo !! TODO: Remove this once we have a 3D interpolation grid max_papprox = maxval ( papprox ) where ( papprox . lt .( max_papprox * 1.d-3 )) papprox = 0.0 endwhere ncell = 0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) if ( papprox ( i , j , k ). gt . 0.0 ) then ncell = ncell + 1 cell_ind ( ncell ) = ic endif enddo call get_nlaunch ( inputs % n_dcx , papprox , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) sum ( nlaunch ) endif !$OMP PARALLEL DO schedule(dynamic,1) private(i,j,k,ic,idcx,ind,vihalo, & !$OMP& ri,tracks,ntrack,rates,denn,states,jj,photons,plasma,fi_correction) loop_over_cells : do ic = istart , ncell , istep call ind2sub ( beam_grid % dims , cell_ind ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) !! Loop over the markers loop_over_dcx : do idcx = 1 , nlaunch ( i , j , k ) !! Calculate ri,vhalo and track call mc_halo ( ind , vihalo , ri ) call track ( ri , vihalo , tracks , ntrack ) if ( ntrack . eq . 0 ) cycle loop_over_dcx !! Calculate CX probability call get_beam_cx_rate ( tracks ( 1 )% ind , ri , vihalo , thermal_ion , neut_types , rates ) if ( sum ( rates ). le . 0. ) cycle loop_over_dcx !! Solve collisional radiative model along track call get_plasma ( plasma , pos = tracks ( 1 )% pos ) !! Weight CX rates by ion source density states = rates * plasma % denp fi_correction = max (( plasma % denp - plasma % denf ) / plasma % denp , 0.d0 ) loop_along_track : do jj = 1 , ntrack call get_plasma ( plasma , pos = tracks ( jj )% pos ) if (. not . plasma % in_plasma ) exit loop_along_track call colrad ( plasma , thermal_ion , vihalo , tracks ( jj )% time , states , denn , photons ) call store_neutrals ( tracks ( jj )% ind , dcx_type , denn / nlaunch ( i , j , k ), vihalo , plasma % in_plasma ) if (( photons . gt . 0.d0 ). and .( inputs % calc_dcx . ge . 1 )) then photons = fi_correction * photons !! Correct for including fast-ions in states call store_bes_photons ( tracks ( jj )% pos , vihalo , photons / nlaunch ( i , j , k ), dcx_type ) endif enddo loop_along_track enddo loop_over_dcx enddo loop_over_cells !$OMP END PARALLEL DO #ifdef _MPI !! Combine densities call parallel_sum ( neut % dcx ) if ( inputs % calc_dcx . ge . 1 ) then call parallel_sum ( spec % dcx ) endif call parallel_sum ( halo_iter_dens ( dcx_type )) #endif end subroutine dcx subroutine halo !+ Calculates halo neutral density and spectra integer :: ic , i , j , k , ncell integer ( Int64 ) :: ihalo !! counter real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vihalo !! velocity bulk plasma ion integer , dimension ( 3 ) :: ind , tind !! actual cell !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( Float64 ), dimension ( nlevs ) :: rates !! CX rates !! Collisiional radiative model along track real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states integer :: ntrack type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks !! Particle Tracks integer :: jj !! counter along track real ( Float64 ) :: tot_denn , photons !! photon flux integer , dimension ( beam_grid % ngrid ) :: cell_ind real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox integer ( Int32 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: nlaunch real ( Float64 ), dimension ( nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: dens_prev real ( Float64 ), dimension (:,:,:,:,:), allocatable :: dens_cur real ( Float64 ) :: local_iter_dens integer :: n_slices , cur_slice , is #ifdef _OMP integer , external :: omp_get_max_threads , omp_get_thread_num #endif !! Halo iteration integer ( Int64 ) :: hh , n_halo !! counters real ( Float64 ) :: max_papprox , dcx_dens , halo_iteration_dens , seed_dcx integer :: prev_type ! previous iteration integer :: cur_type ! current iteration real ( Float64 ) :: fi_correction prev_type = fida_type cur_type = brems_type cur_slice = 1 n_slices = 1 #ifdef _OMP n_slices = omp_get_max_threads () #endif allocate ( dens_cur ( nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz , n_slices )) dens_prev = 0.d0 dens_cur = 0.d0 dcx_dens = halo_iter_dens ( dcx_type ) halo_iter_dens ( prev_type ) = dcx_dens if ( dcx_dens . eq . 0 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'HALO: Density of DCX-neutrals is zero' endif stop endif dens_prev = neut % dcx n_halo = inputs % n_halo seed_dcx = 1.0 iterations : do hh = 1 , 200 papprox = 0.d0 tot_denn = 0.d0 halo_iter_dens ( cur_type ) = 0.d0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) call get_plasma ( plasma , ind = ind ) if (. not . plasma % in_plasma ) cycle tot_denn = sum ( dens_prev (:, i , j , k )) papprox ( i , j , k ) = tot_denn * ( plasma % denp - plasma % denf ) enddo !! TODO: Remove this once we have a 3D interpolation grid max_papprox = maxval ( papprox ) where ( papprox . lt .( max_papprox * 1.d-3 )) papprox = 0.0 endwhere cell_ind = 0 ncell = 0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) if ( papprox ( i , j , k ). gt . 0.0 ) then ncell = ncell + 1 cell_ind ( ncell ) = ic endif enddo call get_nlaunch ( n_halo , papprox , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10,\" --- Seed/DCX: \",f5.3)' ) sum ( nlaunch ), seed_dcx endif local_iter_dens = halo_iter_dens ( cur_type ) !$OMP PARALLEL DO schedule(dynamic,1) private(i,j,k,ic,ihalo,ind,vihalo, & !$OMP& ri,tracks,ntrack,rates,denn,states,jj,photons,plasma,tind, cur_slice,fi_correction) & !$OMP& reduction(+: local_iter_dens ) loop_over_cells : do ic = istart , ncell , istep #ifdef _OMP cur_slice = omp_get_thread_num () + 1 #endif call ind2sub ( beam_grid % dims , cell_ind ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) !! Loop over the markers loop_over_halos : do ihalo = 1 , nlaunch ( i , j , k ) !! Calculate ri,vhalo and track call mc_halo ( ind , vihalo , ri ) call track ( ri , vihalo , tracks , ntrack ) if ( ntrack . eq . 0 ) cycle loop_over_halos !! Get plasma parameters at particle location call get_plasma ( plasma , pos = ri ) !! Calculate CX probability tind = tracks ( 1 )% ind call bt_cx_rates ( plasma , dens_prev (:, tind ( 1 ), tind ( 2 ), tind ( 3 )), vihalo , thermal_ion , rates ) if ( sum ( rates ). le . 0. ) cycle loop_over_halos !! Get plasma parameters at mean point in cell call get_plasma ( plasma , pos = tracks ( 1 )% pos ) !! Weight CX rates by ion source density states = rates * plasma % denp fi_correction = max (( plasma % denp - plasma % denf ) / plasma % denp , 0.d0 ) loop_along_track : do jj = 1 , ntrack call get_plasma ( plasma , pos = tracks ( jj )% pos ) if (. not . plasma % in_plasma ) exit loop_along_track call colrad ( plasma , thermal_ion , vihalo , tracks ( jj )% time , states , denn , photons ) !! Store Neutrals tind = tracks ( jj )% ind dens_cur (:, tind ( 1 ), tind ( 2 ), tind ( 3 ), cur_slice ) = & dens_cur (:, tind ( 1 ), tind ( 2 ), tind ( 3 ), cur_slice ) + denn / nlaunch ( i , j , k ) local_iter_dens = & local_iter_dens + sum ( denn ) / nlaunch ( i , j , k ) if (( photons . gt . 0.d0 ). and .( inputs % calc_halo . ge . 1 )) then photons = fi_correction * photons !! Correct for including fast-ions in states call store_bes_photons ( tracks ( jj )% pos , vihalo , photons / nlaunch ( i , j , k ), halo_type ) endif enddo loop_along_track enddo loop_over_halos enddo loop_over_cells !$OMP END PARALLEL DO halo_iter_dens ( cur_type ) = local_iter_dens #ifdef _OMP !$OMP PARALLEL DO private(i,j,is) do i = 1 , beam_grid % nz do j = 1 , beam_grid % ny do is = 2 , n_slices dens_cur (:,:, j , i , 1 ) = dens_cur (:,:, j , i , 1 ) + dens_cur (:,:, j , i , is ) enddo enddo enddo #endif ! at this point, dens_cur(*,1) contains all the info #ifdef _MPI !! Combine densities call parallel_sum ( dens_cur (:,:,:,:, 1 )) call parallel_sum ( halo_iter_dens ( cur_type )) #endif if ( halo_iter_dens ( cur_type ) / halo_iter_dens ( prev_type ). gt . 1.0 ) then write ( * , '(a)' ) \"HALO: Halo generation density exceeded seed density. This shouldn't happen.\" exit iterations endif halo_iteration_dens = halo_iter_dens ( cur_type ) halo_iter_dens ( prev_type ) = halo_iter_dens ( cur_type ) !$OMP PARALLEL DO private(i) do i = 1 , beam_grid % nz neut % halo (:,:,:, i ) = neut % halo (:,:,:, i ) + dens_cur (:,:,:, i , 1 ) dens_prev (:,:,:, i ) = dens_cur (:,:,:, i , 1 ) dens_cur (:,:,:, i ,:) = 0.d0 enddo seed_dcx = halo_iteration_dens / dcx_dens n_halo = int ( inputs % n_halo * seed_dcx , Int64 ) if ( seed_dcx . lt . 0.01 ) exit iterations enddo iterations #ifdef _MPI !! Combine Spectra if ( inputs % calc_halo . ge . 1 ) then call parallel_sum ( spec % halo ) endif #endif deallocate ( dens_cur ) end subroutine halo subroutine nbi_spec !+ Calculates approximate neutral beam emission (full, half, third) !+ from user supplied neutrals file integer :: ic , i , j , k , it real ( Float64 ), dimension ( 3 ) :: ri , vnbi , random3 , rc integer , dimension ( 3 ) :: ind !! Determination of the CX probability real ( Float64 ) :: nbif_photons , nbih_photons , nbit_photons real ( Float64 ) :: f_wght , h_wght , t_wght real ( Float64 ) :: f_tot , h_tot , t_tot real ( Float64 ), dimension ( inputs % nlambda , spec_chords % nchan ) :: full , half , third logical :: inp integer :: n = 10000 !$OMP PARALLEL DO schedule(dynamic,1) private(i,j,k,ic,ind, & !$OMP& nbif_photons, nbih_photons, nbit_photons, rc, ri,inp, vnbi,& !$OMP& random3,f_tot,h_tot,t_tot,full,half,third,f_wght,h_wght,t_wght) loop_over_cells : do ic = istart , spec_chords % ncell , istep call ind2sub ( beam_grid % dims , spec_chords % cell ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) nbif_photons = neut % full ( 3 , i , j , k ) * tables % einstein ( 2 , 3 ) nbih_photons = neut % half ( 3 , i , j , k ) * tables % einstein ( 2 , 3 ) nbit_photons = neut % third ( 3 , i , j , k ) * tables % einstein ( 2 , 3 ) if (( nbif_photons + nbih_photons + nbit_photons ). le . 0.0 ) then cycle loop_over_cells endif rc = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] !Find a point in cell that is also in the plasma ri = rc call in_plasma ( ri , inp ) do while (. not . inp ) call randu ( random3 ) ri = rc + beam_grid % dr * ( random3 - 0.5 ) call in_plasma ( ri , inp ) enddo f_tot = 0.0 ; h_tot = 0.0 ; t_tot = 0.0 full = 0.0 ; half = 0.0 ; third = 0.0 do it = 1 , n !! Full Spectra call mc_nbi_cell ( ind , nbif_type , vnbi , f_wght ) f_tot = f_tot + f_wght call store_photons ( ri , vnbi , f_wght * nbif_photons , full ) !! Half Spectra call mc_nbi_cell ( ind , nbih_type , vnbi , h_wght ) h_tot = h_tot + h_wght call store_photons ( ri , vnbi , h_wght * nbih_photons , half ) !! Third Spectra call mc_nbi_cell ( ind , nbit_type , vnbi , t_wght ) t_tot = t_tot + t_wght call store_photons ( ri , vnbi , t_wght * nbit_photons , third ) enddo !$OMP CRITICAL(nbi_spec_1) spec % full = spec % full + full / f_tot spec % half = spec % half + half / h_tot spec % third = spec % third + third / t_tot !$OMP END CRITICAL(nbi_spec_1) enddo loop_over_cells !$OMP END PARALLEL DO #ifdef _MPI !! Combine Spectra call parallel_sum ( spec % full ) call parallel_sum ( spec % half ) call parallel_sum ( spec % third ) #endif end subroutine nbi_spec subroutine dcx_spec !+ Calculates DCX emission from user supplied neutrals file integer :: ic , i , j , k , it real ( Float64 ), dimension ( 3 ) :: ri , vhalo , random3 , rc integer , dimension ( 3 ) :: ind !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( Float64 ) :: dcx_photons logical :: inp integer :: n = 10000 !$OMP PARALLEL DO schedule(dynamic,1) private(i,j,k,ic,ind, & !$OMP& dcx_photons, rc, ri, inp, vhalo, random3, plasma) loop_over_cells : do ic = istart , spec_chords % ncell , istep call ind2sub ( beam_grid % dims , spec_chords % cell ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) dcx_photons = neut % dcx ( 3 , i , j , k ) * tables % einstein ( 2 , 3 ) if ( dcx_photons . le . 0.0 ) cycle loop_over_cells rc = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] !Find a point in cell that is also in the plasma ri = rc call in_plasma ( ri , inp ) do while (. not . inp ) call randu ( random3 ) ri = rc + beam_grid % dr * ( random3 - 0.5 ) call in_plasma ( ri , inp ) enddo call get_plasma ( plasma , pos = ri ) do it = 1 , n !! DCX Spectra call randn ( random3 ) vhalo = plasma % vrot + sqrt ( plasma % ti * 0.5 / ( v2_to_E_per_amu * inputs % ai )) * random3 call store_photons ( ri , vhalo , dcx_photons / n , spec % dcx ) enddo enddo loop_over_cells !$OMP END PARALLEL DO #ifdef _MPI !! Combine Spectra call parallel_sum ( spec % dcx ) #endif end subroutine dcx_spec subroutine halo_spec !+ Calculates halo emission from user supplied neutrals file integer :: ic , i , j , k , it real ( Float64 ), dimension ( 3 ) :: ri , vhalo , random3 , rc integer , dimension ( 3 ) :: ind !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( Float64 ) :: halo_photons logical :: inp integer :: n = 10000 !$OMP PARALLEL DO schedule(dynamic,1) private(i,j,k,ic,ind, & !$OMP& halo_photons, rc, ri, inp, vhalo, random3, plasma) loop_over_cells : do ic = istart , spec_chords % ncell , istep call ind2sub ( beam_grid % dims , spec_chords % cell ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) halo_photons = neut % halo ( 3 , i , j , k ) * tables % einstein ( 2 , 3 ) if ( halo_photons . le . 0.0 ) cycle loop_over_cells rc = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] !Find a point in cell that is also in the plasma ri = rc call in_plasma ( ri , inp ) do while (. not . inp ) call randu ( random3 ) ri = rc + beam_grid % dr * ( random3 - 0.5 ) call in_plasma ( ri , inp ) enddo call get_plasma ( plasma , pos = ri ) do it = 1 , n !! Halo Spectra call randn ( random3 ) vhalo = plasma % vrot + sqrt ( plasma % ti * 0.5 / ( v2_to_E_per_amu * inputs % ai )) * random3 call store_photons ( ri , vhalo , halo_photons / n , spec % halo ) enddo enddo loop_over_cells !$OMP END PARALLEL DO #ifdef _MPI !! Combine Spectra call parallel_sum ( spec % halo ) #endif end subroutine halo_spec subroutine cold_spec !+ Calculates cold D-alpha emission integer :: ic , i , j , k , it , ncell real ( Float64 ), dimension ( 3 ) :: ri , vhalo , random3 integer , dimension ( 3 ) :: ind !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( Float64 ) :: cold_photons integer :: n = 10000 !$OMP PARALLEL DO schedule(dynamic,1) private(i,j,k,ic,ind, & !$OMP& cold_photons, ri, vhalo, random3, plasma) loop_over_cells : do ic = istart , spec_chords % ncell , istep call ind2sub ( beam_grid % dims , spec_chords % cell ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) ri = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] call get_plasma ( plasma , pos = ri ) cold_photons = plasma % denn ( 3 ) * tables % einstein ( 2 , 3 ) if ( cold_photons . le . 0.0 ) cycle loop_over_cells do it = 1 , n !! Cold Spectra call randn ( random3 ) vhalo = plasma % vrot + sqrt ( plasma % ti * 0.5 / ( v2_to_E_per_amu * inputs % ai )) * random3 call store_photons ( ri , vhalo , cold_photons / n , spec % cold ) enddo enddo loop_over_cells !$OMP END PARALLEL DO #ifdef _MPI !! Combine Spectra call parallel_sum ( spec % cold ) #endif end subroutine cold_spec subroutine fida_f !+ Calculate Active FIDA emission using a Fast-ion distribution function F(E,p,r,z) integer :: i , j , k , ic , ncell integer ( Int64 ) :: iion real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions real ( Float64 ) :: denf !! fast-ion density integer , dimension ( 3 ) :: ind !! new actual cell integer , dimension ( 5 ) :: neut_types = [ 1 , 2 , 3 , 4 , 5 ] logical :: los_intersect !! Determination of the CX probability type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: rates !! CX rates !! Collisiional radiative model along track integer :: ntrack integer :: jj !! counter along track type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks real ( Float64 ) :: photons !! photon flux real ( Float64 ), dimension ( nlevs ) :: states !! Density of n-states real ( Float64 ), dimension ( nlevs ) :: denn !! Number of particles to launch real ( Float64 ) :: max_papprox , eb , ptch integer , dimension ( beam_grid % ngrid ) :: cell_ind real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox integer ( Int32 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: nlaunch !! Estimate how many particles to launch in each cell papprox = 0.d0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) call get_plasma ( plasma , ind = ind ) if (. not . plasma % in_plasma ) cycle papprox ( i , j , k ) = ( sum ( neut % full (:, i , j , k )) + & sum ( neut % half (:, i , j , k )) + & sum ( neut % third (:, i , j , k )) + & sum ( neut % dcx (:, i , j , k )) + & sum ( neut % halo (:, i , j , k ))) * & plasma % denf enddo !! TODO: Remove this once we have a 3D interpolation grid max_papprox = maxval ( papprox ) where ( papprox . lt .( max_papprox * 1.d-3 )) papprox = 0.0 endwhere ncell = 0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) if ( papprox ( i , j , k ). gt . 0.0 ) then ncell = ncell + 1 cell_ind ( ncell ) = ic endif enddo call get_nlaunch ( inputs % n_fida , papprox , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) sum ( nlaunch ) endif !! Loop over all cells that have neutrals !$OMP PARALLEL DO schedule(dynamic,1) private(ic,i,j,k,ind,iion,vi,ri,fields, & !$OMP tracks,ntrack,jj,plasma,rates,denn,states,photons,denf,eb,ptch,los_intersect) loop_over_cells : do ic = istart , ncell , istep call ind2sub ( beam_grid % dims , cell_ind ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) loop_over_fast_ions : do iion = 1 , nlaunch ( i , j , k ) !! Sample fast ion distribution for velocity and position call mc_fastion ( ind , fields , eb , ptch , denf ) if ( denf . le . 0.0 ) cycle loop_over_fast_ions !! Correct for gyro motion and get particle position and velocity call gyro_correction ( fields , eb , ptch , ri , vi ) !! Find the particles path through the beam grid call track ( ri , vi , tracks , ntrack , los_intersect ) if (. not . los_intersect ) cycle loop_over_fast_ions if ( ntrack . eq . 0 ) cycle loop_over_fast_ions !! Calculate CX probability with beam and halo neutrals call get_beam_cx_rate ( tracks ( 1 )% ind , ri , vi , beam_ion , neut_types , rates ) if ( sum ( rates ). le . 0. ) cycle loop_over_fast_ions !! Weight CX rates by ion source density states = rates * denf !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ntrack call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fida_photons ( tracks ( jj )% pos , vi , photons / nlaunch ( i , j , k )) enddo loop_along_track enddo loop_over_fast_ions enddo loop_over_cells !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( spec % fida ) #endif end subroutine fida_f subroutine pfida_f !+ Calculate Passive FIDA emission using a Fast-ion distribution function F(E,p,r,z) integer :: i , j , k , ic , ncell integer ( Int64 ) :: iion real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions real ( Float64 ), dimension ( 3 ) :: xyz_vi real ( Float64 ) :: denf !! fast-ion density integer , dimension ( 3 ) :: ind !! new actual cell logical :: los_intersect !! Determination of the CX probability type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: rates !! CX rates !! Collisiional radiative model along track integer :: ntrack integer :: jj !! counter along track type ( ParticleTrack ), dimension ( pass_grid % ntrack ) :: tracks real ( Float64 ) :: photons !! photon flux real ( Float64 ), dimension ( nlevs ) :: states !! Density of n-states real ( Float64 ), dimension ( nlevs ) :: denn !! Number of particles to launch real ( Float64 ) :: max_papprox , eb , ptch integer , dimension ( pass_grid % ngrid ) :: cell_ind real ( Float64 ), dimension ( pass_grid % nr , pass_grid % nz , pass_grid % nphi ) :: papprox integer ( Int32 ), dimension ( pass_grid % nr , pass_grid % nz , pass_grid % nphi ) :: nlaunch !! Estimate how many particles to launch in each cell papprox = 0.d0 do ic = 1 , pass_grid % ngrid call ind2sub ( pass_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) call get_plasma ( plasma , ind = ind , input_coords = 2 ) if (. not . plasma % in_plasma ) cycle papprox ( i , j , k ) = sum ( plasma % denn ) * plasma % denf enddo max_papprox = maxval ( papprox ) where ( papprox . lt .( max_papprox * 1.d-3 )) papprox = 0.0 endwhere ncell = 0 do ic = 1 , pass_grid % ngrid call ind2sub ( pass_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) if ( papprox ( i , j , k ). gt . 0.0 ) then ncell = ncell + 1 cell_ind ( ncell ) = ic endif enddo call get_nlaunch_pass_grid ( inputs % n_pfida , papprox , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) sum ( nlaunch ) endif !! Loop over all cells that have neutrals !$OMP PARALLEL DO schedule(dynamic,1) private(ic,i,j,k,ind,iion,vi,xyz_vi,ri,fields, & !$OMP tracks,ntrack,jj,plasma,rates,denn,states,photons,denf,eb,ptch,los_intersect) loop_over_cells : do ic = istart , ncell , istep call ind2sub ( pass_grid % dims , cell_ind ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) loop_over_fast_ions : do iion = 1 , nlaunch ( i , j , k ) !! Sample fast ion distribution for velocity and position call mc_fastion_pass_grid ( ind , fields , eb , ptch , denf , output_coords = 1 ) if ( denf . le . 0.0 ) cycle loop_over_fast_ions !! Correct for gyro motion and get particle position and velocity call gyro_correction ( fields , eb , ptch , ri , vi ) xyz_vi = matmul ( beam_grid % inv_basis , vi ) !! Find the particles path through the interpolation grid call track_cylindrical ( ri , vi , tracks , ntrack , los_intersect ) if (. not . los_intersect ) cycle loop_over_fast_ions if ( ntrack . eq . 0 ) cycle loop_over_fast_ions !! Calculate CX probability with beam and halo neutrals call get_plasma ( plasma , pos = ri , input_coords = 1 ) call bt_cx_rates ( plasma , plasma % denn , xyz_vi , beam_ion , rates ) if ( sum ( rates ). le . 0. ) cycle loop_over_fast_ions !! Weight CX rates by ion source density states = rates * denf !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ntrack call get_plasma ( plasma , pos = tracks ( jj )% pos , input_coords = 1 ) call colrad ( plasma , beam_ion , xyz_vi , tracks ( jj )% time , states , denn , photons ) call store_fida_photons ( tracks ( jj )% pos , xyz_vi , photons / nlaunch ( i , j , k ), passive = . True .) enddo loop_along_track enddo loop_over_fast_ions enddo loop_over_cells !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( spec % pfida ) #endif end subroutine pfida_f subroutine fida_mc !+ Calculate Active FIDA emission using a Monte Carlo Fast-ion distribution integer :: iion , igamma , ngamma type ( FastIon ) :: fast_ion type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma real ( Float64 ) :: phi real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions !! Determination of the CX probability real ( Float64 ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( Float64 ), dimension ( nlevs ) :: rates !! CX rates !! Collisiional radiative model along track real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states integer :: ntrack type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks logical :: los_intersect integer :: jj !! counter along track real ( Float64 ) :: photons !! photon flux integer , dimension ( 5 ) :: neut_types = [ 1 , 2 , 3 , 4 , 5 ] real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ) :: s , c real ( Float64 ), dimension ( 1 ) :: randomu ngamma = 1 if ( particles % axisym . or .( inputs % dist_type . eq . 2 )) then ngamma = ceiling ( dble ( inputs % n_fida ) / particles % nparticle ) endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) int ( particles % nparticle * ngamma , Int64 ) endif !$OMP PARALLEL DO schedule(dynamic,1) private(iion,igamma,fast_ion,vi,ri,phi,tracks,s,c, & !$OMP& randomu,plasma,fields,uvw,uvw_vi,ntrack,jj,rates,denn,los_intersect,states,photons) loop_over_fast_ions : do iion = istart , particles % nparticle , istep fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0 ) cycle loop_over_fast_ions if (. not . fast_ion % beam_grid_cross_grid ) cycle loop_over_fast_ions gamma_loop : do igamma = 1 , ngamma if ( particles % axisym ) then !! Pick random toroidal angle call randu ( randomu ) phi = fast_ion % beam_grid_phi_enter + fast_ion % delta_phi * randomu ( 1 ) else phi = fast_ion % phi endif s = sin ( phi ) c = cos ( phi ) !! Calculate position in machine coordinates uvw ( 1 ) = fast_ion % r * c uvw ( 2 ) = fast_ion % r * s uvw ( 3 ) = fast_ion % z !! Convert to beam grid coordinates call uvw_to_xyz ( uvw , ri ) if ( inputs % dist_type . eq . 2 ) then !! Get electomagnetic fields call get_fields ( fields , pos = ri ) !! Correct for gyro motion and get particle position and velocity call gyro_correction ( fields , fast_ion % energy , fast_ion % pitch , ri , vi ) else !! Full Orbit !! Calculate velocity vector uvw_vi ( 1 ) = c * fast_ion % vr - s * fast_ion % vt uvw_vi ( 2 ) = s * fast_ion % vr + c * fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) endif !! Track particle through grid call track ( ri , vi , tracks , ntrack , los_intersect ) if (. not . los_intersect ) cycle gamma_loop if ( ntrack . eq . 0 ) cycle gamma_loop !! Calculate CX probability call get_beam_cx_rate ( tracks ( 1 )% ind , ri , vi , beam_ion , neut_types , rates ) if ( sum ( rates ). le . 0. ) cycle gamma_loop !! Weight CX rates by ion source density states = rates * fast_ion % weight * ( fast_ion % delta_phi / ( 2 * pi )) / beam_grid % dv / ngamma !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ntrack call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fida_photons ( tracks ( jj )% pos , vi , photons , fast_ion % class ) enddo loop_along_track enddo gamma_loop enddo loop_over_fast_ions !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( spec % fida ) #endif end subroutine fida_mc subroutine pfida_mc !+ Calculate Passive FIDA emission using a Monte Carlo Fast-ion distribution integer :: iion , igamma , ngamma type ( FastIon ) :: fast_ion type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma real ( Float64 ) :: phi real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions real ( Float64 ), dimension ( 3 ) :: xyz_vi !! Determination of the CX probability real ( Float64 ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( Float64 ), dimension ( nlevs ) :: rates !! CX rates !! Collisiional radiative model along track real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states type ( ParticleTrack ), dimension ( pass_grid % ntrack ) :: tracks integer :: ntrack logical :: los_intersect integer :: jj !! counter along track real ( Float64 ) :: photons !! photon flux real ( Float64 ) :: s , c real ( Float64 ), dimension ( 1 ) :: randomu ngamma = 1 if ( particles % axisym . or .( inputs % dist_type . eq . 2 )) then ngamma = ceiling ( dble ( inputs % n_pfida ) / particles % nparticle ) endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) int ( particles % nparticle * ngamma , Int64 ) endif !$OMP PARALLEL DO schedule(dynamic,1) private(iion,igamma,fast_ion,vi,ri,phi,tracks,s,c,& !$OMP& randomu,plasma,fields,ntrack,jj,rates,denn,los_intersect,states,photons,xyz_vi) loop_over_fast_ions : do iion = istart , particles % nparticle , istep fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0 ) cycle loop_over_fast_ions gamma_loop : do igamma = 1 , ngamma if ( particles % axisym ) then !! Pick random toroidal angle call randu ( randomu ) phi = pass_grid % phi ( 1 ) + pass_grid % nphi * pass_grid % dphi * randomu ( 1 ) else phi = fast_ion % phi endif s = sin ( phi ) c = cos ( phi ) !! Calculate position in machine coordinates ri ( 1 ) = fast_ion % r * c ri ( 2 ) = fast_ion % r * s ri ( 3 ) = fast_ion % z if ( inputs % dist_type . eq . 2 ) then !! Get electomagnetic fields call get_fields ( fields , pos = ri , input_coords = 1 , output_coords = 1 ) !! Correct for gyro motion and get particle position and velocity call gyro_correction ( fields , fast_ion % energy , fast_ion % pitch , ri , vi ) else !! Full Orbit !! Calculate velocity vector vi ( 1 ) = c * fast_ion % vr - s * fast_ion % vt vi ( 2 ) = s * fast_ion % vr + c * fast_ion % vt vi ( 3 ) = fast_ion % vz endif xyz_vi = matmul ( beam_grid % inv_basis , vi ) !! Track particle through grid call track_cylindrical ( ri , vi , tracks , ntrack , los_intersect ) if (. not . los_intersect ) cycle gamma_loop if ( ntrack . eq . 0 ) cycle gamma_loop !! Calculate CX probability call get_plasma ( plasma , pos = ri , input_coords = 1 ) call bt_cx_rates ( plasma , plasma % denn , xyz_vi , beam_ion , rates ) if ( sum ( rates ). le . 0. ) cycle gamma_loop !! Weight CX rates by ion source density if ( particles % axisym ) then states = rates * fast_ion % weight * ( pass_grid % nphi * pass_grid % dphi / ( 2 * pi )) & / ( fast_ion % r * pass_grid % dv ) / ngamma else states = rates * fast_ion % weight / ( fast_ion % r * pass_grid % dv ) / ngamma endif !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ntrack call get_plasma ( plasma , pos = tracks ( jj )% pos , input_coords = 1 ) call colrad ( plasma , beam_ion , xyz_vi , tracks ( jj )% time , states , denn , photons ) call store_fida_photons ( tracks ( jj )% pos , xyz_vi , photons , fast_ion % class , passive = . True .) enddo loop_along_track enddo gamma_loop enddo loop_over_fast_ions !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( spec % pfida ) #endif end subroutine pfida_mc subroutine npa_f !+ Calculate Active NPA flux using a fast-ion distribution function F(E,p,r,z) integer :: i , j , k , det , ic integer ( Int64 ) :: iion real ( Float64 ), dimension ( 3 ) :: rg , ri , rf , vi integer , dimension ( 3 ) :: ind , pind real ( Float64 ) :: denf type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields type ( GyroSurface ) :: gs real ( Float64 ), dimension ( 2 , 4 ) :: gyrange integer , dimension ( 5 ) :: neut_types = [ 1 , 2 , 3 , 4 , 5 ] real ( Float64 ), dimension ( nlevs ) :: rates real ( Float64 ), dimension ( nlevs ) :: states real ( Float64 ) :: flux , theta , dtheta , eb , ptch , max_papprox integer :: inpa , ichan , nrange , ir , npart , ncell integer , dimension ( beam_grid % ngrid ) :: cell_ind real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox integer ( Int32 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: nlaunch papprox = 0.d0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) call get_plasma ( plasma , ind = ind ) if (. not . plasma % in_plasma ) cycle papprox ( i , j , k ) = ( sum ( neut % full (:, i , j , k )) + & sum ( neut % half (:, i , j , k )) + & sum ( neut % third (:, i , j , k )) + & sum ( neut % dcx (:, i , j , k )) + & sum ( neut % halo (:, i , j , k ))) * & plasma % denf enddo !! TODO: Remove this once we have a 3D interpolation grid max_papprox = maxval ( papprox ) where ( papprox . lt .( max_papprox * 1.d-3 )) papprox = 0.0 endwhere ncell = 0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) if ( papprox ( i , j , k ). gt . 0.0 ) then ncell = ncell + 1 cell_ind ( ncell ) = ic endif enddo call get_nlaunch ( inputs % n_npa , papprox , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i12)' ) sum ( nlaunch ) endif !! Loop over all cells that can contribute to NPA signal !$OMP PARALLEL DO schedule(dynamic,1) private(ic,i,j,k,ind,iion,ichan,fields,nrange,gyrange, & !$OMP& pind,vi,ri,rf,det,plasma,rates,states,flux,denf,eb,ptch,gs,ir,theta,dtheta) loop_over_cells : do ic = istart , ncell , istep call ind2sub ( beam_grid % dims , cell_ind ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) loop_over_fast_ions : do iion = 1 , nlaunch ( i , j , k ) !! Sample fast ion distribution for energy and pitch call mc_fastion ( ind , fields , eb , ptch , denf ) if ( denf . le . 0.0 ) cycle loop_over_fast_ions call gyro_surface ( fields , eb , ptch , gs ) detector_loop : do ichan = 1 , npa_chords % nchan call npa_gyro_range ( ichan , gs , gyrange , nrange ) if ( nrange . eq . 0 ) cycle detector_loop gyro_range_loop : do ir = 1 , nrange dtheta = gyrange ( 2 , ir ) theta = gyrange ( 1 , ir ) + 0.5 * dtheta call gyro_trajectory ( gs , theta , ri , vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf , ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"NPA_F: Missed Detector \" , ichan endif cycle gyro_range_loop endif !! Get beam grid indices at ri call get_indices ( ri , pind ) !! Calculate CX probability with beam and halo neutrals call get_beam_cx_rate ( pind , ri , vi , beam_ion , neut_types , rates ) if ( sum ( rates ). le . 0. ) cycle gyro_range_loop !! Weight CX rates by ion source density states = rates * denf !! Attenuate states as the particle move through plasma call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = ( dtheta / ( 2 * pi )) * sum ( states ) * beam_grid % dv / nlaunch ( i , j , k ) call store_npa ( det , ri , rf , vi , flux ) enddo gyro_range_loop enddo detector_loop enddo loop_over_fast_ions enddo loop_over_cells !$OMP END PARALLEL DO npart = npa % npart #ifdef _MPI call parallel_sum ( npart ) call parallel_sum ( npa % flux ) #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Number of Active NPA particles that hit a detector: \",i8)' ) npart endif end subroutine npa_f subroutine pnpa_f !+ Calculate Passive NPA flux using a fast-ion distribution function F(E,p,r,z) integer :: i , j , k , det , ic integer ( Int64 ) :: iion real ( Float64 ), dimension ( 3 ) :: rg , ri , rf , vi , ri_uvw integer , dimension ( 3 ) :: ind real ( Float64 ) :: denf , r type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields type ( GyroSurface ) :: gs real ( Float64 ), dimension ( 2 , 4 ) :: gyrange real ( Float64 ), dimension ( nlevs ) :: rates real ( Float64 ), dimension ( nlevs ) :: states real ( Float64 ) :: flux , theta , dtheta , eb , ptch , max_papprox integer :: inpa , ichan , nrange , ir , npart , ncell integer , dimension ( pass_grid % ngrid ) :: cell_ind real ( Float64 ), dimension ( pass_grid % nr , pass_grid % nz , pass_grid % nphi ) :: papprox integer ( Int32 ), dimension ( pass_grid % nr , pass_grid % nz , pass_grid % nphi ) :: nlaunch papprox = 0.d0 do ic = 1 , pass_grid % ngrid call ind2sub ( pass_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) call get_plasma ( plasma , ind = ind , input_coords = 2 ) if (. not . plasma % in_plasma ) cycle papprox ( i , j , k ) = sum ( plasma % denn ) * plasma % denf enddo max_papprox = maxval ( papprox ) where ( papprox . lt .( max_papprox * 1.d-3 )) papprox = 0.0 endwhere ncell = 0 do ic = 1 , pass_grid % ngrid call ind2sub ( pass_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) if ( papprox ( i , j , k ). gt . 0.0 ) then ncell = ncell + 1 cell_ind ( ncell ) = ic endif enddo call get_nlaunch_pass_grid ( inputs % n_pnpa , papprox , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i12)' ) sum ( nlaunch ) endif !! Loop over all cells that can contribute to NPA signal !$OMP PARALLEL DO schedule(dynamic,1) private(ic,i,j,k,ind,iion,ichan,fields,nrange,gyrange, & !$OMP& vi,ri,rf,det,plasma,rates,states,flux,denf,eb,ptch,gs,ir,theta,dtheta,r,ri_uvw) loop_over_cells : do ic = istart , ncell , istep call ind2sub ( pass_grid % dims , cell_ind ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) loop_over_fast_ions : do iion = 1 , nlaunch ( i , j , k ) !! Sample fast ion distribution for energy and pitch call mc_fastion_pass_grid ( ind , fields , eb , ptch , denf ) if ( denf . le . 0.0 ) cycle loop_over_fast_ions call gyro_surface ( fields , eb , ptch , gs ) detector_loop : do ichan = 1 , npa_chords % nchan call npa_gyro_range ( ichan , gs , gyrange , nrange ) if ( nrange . eq . 0 ) cycle detector_loop gyro_range_loop : do ir = 1 , nrange dtheta = gyrange ( 2 , ir ) theta = gyrange ( 1 , ir ) + 0.5 * dtheta call gyro_trajectory ( gs , theta , ri , vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf , ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"PNPA_F: Missed Detector \" , ichan endif cycle gyro_range_loop endif !! Calculate CX probability with beam and halo neutrals call get_plasma ( plasma , pos = ri ) call bt_cx_rates ( plasma , plasma % denn , vi , beam_ion , rates ) if ( sum ( rates ). le . 0. ) cycle gyro_range_loop !! Weight CX rates by ion source density states = rates * denf !! Attenuate states as the particle move through plasma call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = ( dtheta / ( 2 * pi )) * sum ( states ) * pass_grid % r ( i ) * pass_grid % dv / nlaunch ( i , j , k ) call store_npa ( det , ri , rf , vi , flux , passive = . True .) enddo gyro_range_loop enddo detector_loop enddo loop_over_fast_ions enddo loop_over_cells !$OMP END PARALLEL DO npart = pnpa % npart #ifdef _MPI call parallel_sum ( npart ) call parallel_sum ( pnpa % flux ) #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Number of Passive NPA particles that hit a detector: \",i8)' ) npart endif end subroutine pnpa_f subroutine npa_mc !+ Calculate Active NPA flux using a Monte Carlo fast-ion distribution integer :: iion , igamma , ngamma , npart type ( FastIon ) :: fast_ion real ( Float64 ) :: phi , theta , dtheta real ( Float64 ), dimension ( 3 ) :: ri , rf , rg , vi integer :: det , ichan , ir , nrange , it type ( LocalEMFields ) :: fields type ( GyroSurface ) :: gs real ( Float64 ), dimension ( nlevs ) :: rates real ( Float64 ), dimension ( nlevs ) :: states real ( Float64 ) :: flux integer , dimension ( 5 ) :: neut_types = [ 1 , 2 , 3 , 4 , 5 ] integer , dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ), dimension ( 2 , 4 ) :: gyrange real ( Float64 ) :: s , c real ( Float64 ), dimension ( 1 ) :: randomu ngamma = 1 if ( particles % axisym . or .( inputs % dist_type . eq . 2 )) then ngamma = ceiling ( dble ( inputs % n_npa ) / particles % nparticle ) endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) int ( particles % nparticle * ngamma , Int64 ) endif !$OMP PARALLEL DO schedule(guided) private(iion,igamma,ind,fast_ion,vi,ri,rf,phi,s,c,ir,it, & !$OMP& randomu,rg,fields,uvw,uvw_vi,rates,states,flux,det,ichan,gs,nrange,gyrange,theta,dtheta) loop_over_fast_ions : do iion = istart , particles % nparticle , istep fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0 ) cycle loop_over_fast_ions if (. not . fast_ion % beam_grid_cross_grid ) cycle loop_over_fast_ions gamma_loop : do igamma = 1 , ngamma if ( particles % axisym ) then !! Pick random toroidal angle call randu ( randomu ) phi = fast_ion % beam_grid_phi_enter + fast_ion % delta_phi * randomu ( 1 ) else phi = fast_ion % phi endif s = sin ( phi ) c = cos ( phi ) !! Calculate position in machine coordinates uvw ( 1 ) = fast_ion % r * c uvw ( 2 ) = fast_ion % r * s uvw ( 3 ) = fast_ion % z if ( inputs % dist_type . eq . 2 ) then !! Convert to beam grid coordinates call uvw_to_xyz ( uvw , rg ) !! Get electomagnetic fields call get_fields ( fields , pos = rg ) !! Correct for gyro motion and get position and velocity call gyro_surface ( fields , fast_ion % energy , fast_ion % pitch , gs ) detector_loop : do ichan = 1 , npa_chords % nchan call npa_gyro_range ( ichan , gs , gyrange , nrange ) if ( nrange . eq . 0 ) cycle detector_loop gyro_range_loop : do ir = 1 , nrange dtheta = gyrange ( 2 , ir ) theta = gyrange ( 1 , ir ) + 0.5 * dtheta call gyro_trajectory ( gs , theta , ri , vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf , det = ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"NPA_MC: Missed Detector \" , ichan endif cycle gyro_range_loop endif !! Get beam grid indices at ri call get_indices ( ri , ind ) !! Calculate CX probability with beam and halo neutrals call get_beam_cx_rate ( ind , ri , vi , beam_ion , neut_types , rates ) if ( sum ( rates ). le . 0. ) cycle gyro_range_loop !! Weight CX rates by ion source density states = rates * fast_ion % weight * ( fast_ion % delta_phi / ( 2 * pi )) / beam_grid % dv / ngamma !! Attenuate states as the particle move through plasma call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = ( dtheta / ( 2 * pi )) * sum ( states ) * beam_grid % dv spread_loop : do it = 1 , 25 theta = gyrange ( 1 , ir ) + ( it - 0.5 ) * dtheta / 25 call gyro_trajectory ( gs , theta , ri , vi ) call hit_npa_detector ( ri , vi , det , rf , det = ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"NPA_MC: Missed Detector \" , ichan endif cycle spread_loop endif call store_npa ( det , ri , rf , vi , flux / 25 , fast_ion % class ) enddo spread_loop enddo gyro_range_loop enddo detector_loop else !! Full Orbit !! Convert to beam grid coordinates call uvw_to_xyz ( uvw , ri ) !! Calculate velocity vector uvw_vi ( 1 ) = c * fast_ion % vr - s * fast_ion % vt uvw_vi ( 2 ) = s * fast_ion % vr + c * fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf ) if ( det . eq . 0 ) cycle gamma_loop !! Get beam grid indices at ri call get_indices ( ri , ind ) !! Calculate CX probability with beam and halo neutrals call get_beam_cx_rate ( ind , ri , vi , beam_ion , neut_types , rates ) if ( sum ( rates ). le . 0. ) cycle gamma_loop !! Weight CX rates by ion source density states = rates * fast_ion % weight * ( fast_ion % delta_phi / ( 2 * pi )) / beam_grid % dv / ngamma !! Attenuate states as the particle moves though plasma call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = sum ( states ) * beam_grid % dv call store_npa ( det , ri , rf , vi , flux , fast_ion % class ) endif enddo gamma_loop enddo loop_over_fast_ions !$OMP END PARALLEL DO npart = npa % npart #ifdef _MPI call parallel_sum ( npart ) call parallel_sum ( npa % flux ) #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Number of Active NPA particles that hit a detector: \",i8)' ) npart endif end subroutine npa_mc subroutine pnpa_mc !+ Calculate Passive NPA flux using a Monte Carlo fast-ion distribution integer :: iion , igamma , ngamma , npart type ( FastIon ) :: fast_ion real ( Float64 ) :: phi , theta , dtheta real ( Float64 ), dimension ( 3 ) :: ri , rf , rg , vi integer :: det , j , ichan , ir , nrange , it type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma type ( GyroSurface ) :: gs real ( Float64 ), dimension ( nlevs ) :: rates real ( Float64 ), dimension ( nlevs ) :: states real ( Float64 ) :: flux integer , dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ), dimension ( 2 , 4 ) :: gyrange real ( Float64 ) :: s , c real ( Float64 ), dimension ( 1 ) :: randomu ngamma = 1 if ( particles % axisym . or .( inputs % dist_type . eq . 2 )) then ngamma = ceiling ( dble ( inputs % n_pnpa ) / particles % nparticle ) endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) int ( particles % nparticle * ngamma , Int64 ) endif !$OMP PARALLEL DO schedule(guided) private(iion,igamma,ind,fast_ion,vi,ri,rf,phi,s,c,ir,it,plasma, & !$OMP& randomu,rg,fields,uvw,uvw_vi,rates,states,flux,det,ichan,gs,nrange,gyrange,theta,dtheta) loop_over_fast_ions : do iion = istart , particles % nparticle , istep fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0 ) cycle loop_over_fast_ions gamma_loop : do igamma = 1 , ngamma if ( particles % axisym ) then !! Pick random toroidal angle call randu ( randomu ) phi = pass_grid % phi ( 1 ) + pass_grid % nphi * pass_grid % dphi * randomu ( 1 ) else phi = fast_ion % phi endif s = sin ( phi ) c = cos ( phi ) !! Calculate position in machine coordinates uvw ( 1 ) = fast_ion % r * c uvw ( 2 ) = fast_ion % r * s uvw ( 3 ) = fast_ion % z if ( inputs % dist_type . eq . 2 ) then !! Get electomagnetic fields call get_fields ( fields , pos = uvw , input_coords = 1 ) !! Correct for gyro motion and get position and velocity call gyro_surface ( fields , fast_ion % energy , fast_ion % pitch , gs ) detector_loop : do ichan = 1 , npa_chords % nchan call npa_gyro_range ( ichan , gs , gyrange , nrange ) if ( nrange . eq . 0 ) cycle detector_loop gyro_range_loop : do ir = 1 , nrange dtheta = gyrange ( 2 , ir ) theta = gyrange ( 1 , ir ) + 0.5 * dtheta call gyro_trajectory ( gs , theta , ri , vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf , det = ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"PNPA_MC: Missed Detector \" , ichan endif cycle gyro_range_loop endif !! Calculate CX probability with beam and halo neutrals call get_plasma ( plasma , pos = ri ) call bt_cx_rates ( plasma , plasma % denn , vi , beam_ion , rates ) if ( sum ( rates ). le . 0. ) cycle gyro_range_loop !! Weight CX rates by ion source density if ( particles % axisym ) then states = rates * fast_ion % weight * ( pass_grid % nphi * pass_grid % dphi / ( 2 * pi )) & / ( fast_ion % r * pass_grid % dv ) / ngamma else states = rates * fast_ion % weight / ( fast_ion % r * pass_grid % dv ) / ngamma endif !! Attenuate states as the particle move through plasma call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = ( dtheta / ( 2 * pi )) * sum ( states ) * ( fast_ion % r * pass_grid % dv ) spread_loop : do it = 1 , 25 theta = gyrange ( 1 , ir ) + ( it - 0.5 ) * dtheta / 25 call gyro_trajectory ( gs , theta , ri , vi ) call hit_npa_detector ( ri , vi , det , rf , det = ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"PNPA_MC: Missed Detector \" , ichan endif cycle spread_loop endif call store_npa ( det , ri , rf , vi , flux / 25 , fast_ion % class , passive = . True .) enddo spread_loop enddo gyro_range_loop enddo detector_loop else !! Full Orbit !! Convert to beam grid coordinates call uvw_to_xyz ( uvw , ri ) !! Calculate velocity vector uvw_vi ( 1 ) = c * fast_ion % vr - s * fast_ion % vt uvw_vi ( 2 ) = s * fast_ion % vr + c * fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf ) if ( det . eq . 0 ) cycle gamma_loop !! Calculate CX probability with beam and halo neutrals call get_plasma ( plasma , pos = ri ) call bt_cx_rates ( plasma , plasma % denn , vi , beam_ion , rates ) if ( sum ( rates ). le . 0. ) cycle gamma_loop !! Weight CX rates by ion source density if ( particles % axisym ) then states = rates * fast_ion % weight * ( pass_grid % nphi * pass_grid % dphi / ( 2 * pi )) & / ( fast_ion % r * pass_grid % dv ) / ngamma else states = rates * fast_ion % weight / ( fast_ion % r * pass_grid % dv ) / ngamma endif !! Attenuate states as the particle moves though plasma call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = sum ( states ) * ( fast_ion % r * pass_grid % dv ) call store_npa ( det , ri , rf , vi , flux , fast_ion % class , passive = . True .) endif enddo gamma_loop enddo loop_over_fast_ions !$OMP END PARALLEL DO npart = pnpa % npart #ifdef _MPI call parallel_sum ( npart ) call parallel_sum ( pnpa % flux ) #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Number of Passive NPA particles that hit a detector: \",i8)' ) npart endif end subroutine pnpa_mc subroutine neutron_f !+ Calculate neutron emission rate using a fast-ion distribution function F(E,p,r,z) integer :: ir , iphi , iz , ie , ip , igamma , ngamma type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( Float64 ) :: eb , pitch real ( Float64 ) :: erel , rate real ( Float64 ), dimension ( 3 ) :: ri real ( Float64 ), dimension ( 3 ) :: vi real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ) :: vnet_square , factor real ( Float64 ) :: s , c if ( inputs % calc_neutron . ge . 2 ) then allocate ( neutron % weight ( fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz , fbm % nphi )) neutron % weight = 0.d0 allocate ( neutron % emis ( fbm % nr , fbm % nz , fbm % nphi )) neutron % emis = 0.d0 endif ngamma = 20 rate = 0 !$OMP PARALLEL DO schedule(guided) private(fields,vi,ri,pitch,eb,& !$OMP& ir,iphi,iz,ie,ip,igamma,plasma,factor,uvw,uvw_vi,vnet_square,rate,erel,s,c) phi_loop : do iphi = 1 , fbm % nphi z_loop : do iz = istart , fbm % nz , istep r_loop : do ir = 1 , fbm % nr !! Calculate position if ( fbm % nphi . eq . 1 ) then s = 0.d0 c = 1.d0 else s = sin ( fbm % phi ( iphi )) c = cos ( fbm % phi ( iphi )) endif uvw ( 1 ) = fbm % r ( ir ) * c uvw ( 2 ) = fbm % r ( ir ) * s uvw ( 3 ) = fbm % z ( iz ) !! Get fields call get_fields ( fields , pos = uvw , input_coords = 1 ) if (. not . fields % in_plasma ) cycle r_loop factor = fbm % r ( ir ) * fbm % dE * fbm % dp * fbm % dr * fbm % dz * fbm % dphi / ngamma !! Loop over energy/pitch/gamma pitch_loop : do ip = 1 , fbm % npitch pitch = fbm % pitch ( ip ) energy_loop : do ie = 1 , fbm % nenergy eb = fbm % energy ( ie ) gyro_loop : do igamma = 1 , ngamma call gyro_correction ( fields , eb , pitch , ri , vi ) !! Get plasma parameters at particle position call get_plasma ( plasma , pos = ri ) if (. not . plasma % in_plasma ) cycle gyro_loop !! Calculate effective beam energy vnet_square = dot_product ( vi - plasma % vrot , vi - plasma % vrot ) ![cm/s] erel = v2_to_E_per_amu * inputs % ab * vnet_square ![kev] !! Get neutron production rate call get_neutron_rate ( plasma , erel , rate ) if ( inputs % calc_neutron . ge . 2 ) then neutron % weight ( ie , ip , ir , iz , iphi ) = neutron % weight ( ie , ip , ir , iz , iphi ) & + rate * factor !$OMP CRITICAL(neutron_emis) neutron % emis ( ir , iz , iphi ) = neutron % emis ( ir , iz , iphi ) & + rate * fbm % f ( ie , ip , ir , iz , iphi ) & * factor !$OMP END CRITICAL(neutron_emis) endif rate = rate * fbm % f ( ie , ip , ir , iz , iphi ) * factor !! Store neutrons call store_neutrons ( rate ) enddo gyro_loop enddo energy_loop enddo pitch_loop enddo r_loop enddo z_loop enddo phi_loop !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( neutron % rate ) if ( inputs % calc_neutron . ge . 2 ) then call parallel_sum ( neutron % weight ) call parallel_sum ( neutron % emis ) endif #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,A,ES14.5,\" [neutrons/s]\")' ) 'Rate:   ' , sum ( neutron % rate ) write ( * , '(30X,a)' ) '' write ( * , * ) 'write neutrons:    ' , time ( time_start ) endif #ifdef _MPI if ( my_rank (). eq . 0 ) call write_neutrons () #else call write_neutrons () #endif end subroutine neutron_f subroutine neutron_mc !+ Calculate neutron flux using a Monte Carlo Fast-ion distribution integer :: iion , ngamma , igamma type ( FastIon ) :: fast_ion type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( Float64 ) :: eb , rate real ( Float64 ), dimension ( 3 ) :: ri real ( Float64 ), dimension ( 3 ) :: vi real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ) :: vnet_square real ( Float64 ) :: phi , s , c , factor , delta_phi if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) particles % nparticle endif !! Correct neutron rate when equilibrium is 3D and MC distribution is 4D if ( particles % axisym . and .( inter_grid % nphi . gt . 1 )) then delta_phi = inter_grid % phi ( inter_grid % nphi ) - inter_grid % phi ( 1 ) delta_phi = delta_phi + delta_phi / ( inter_grid % nphi - 1 ) / 2 !Add half a cell factor = delta_phi / ( 2 * pi ) * 2 !Riemann sum below assumes coord's are at midpoint of cell else factor = 1 endif rate = 0.0 ngamma = 20 !$OMP PARALLEL DO schedule(guided) private(iion,fast_ion,vi,ri,s,c, & !$OMP& plasma,fields,uvw,uvw_vi,vnet_square,rate,eb,igamma,phi) loop_over_fast_ions : do iion = istart , particles % nparticle , istep fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0.d0 ) cycle loop_over_fast_ions !! Calculate position in machine coordinates if ( particles % axisym ) then s = 0.d0 c = 1.d0 else phi = fast_ion % phi s = sin ( phi ) c = cos ( phi ) endif uvw ( 1 ) = fast_ion % r * c uvw ( 2 ) = fast_ion % r * s uvw ( 3 ) = fast_ion % z if ( inputs % dist_type . eq . 2 ) then !! Get electomagnetic fields call get_fields ( fields , pos = uvw , input_coords = 1 ) if (. not . fields % in_plasma ) cycle loop_over_fast_ions gyro_loop : do igamma = 1 , ngamma !! Correct for Gyro-motion call gyro_correction ( fields , fast_ion % energy , fast_ion % pitch , ri , vi ) !! Get plasma parameters call get_plasma ( plasma , pos = ri ) if (. not . plasma % in_plasma ) cycle gyro_loop !! Calculate effective beam energy vnet_square = dot_product ( vi - plasma % vrot , vi - plasma % vrot ) ![cm/s] eb = v2_to_E_per_amu * inputs % ab * vnet_square ![kev] !! Get neutron production rate call get_neutron_rate ( plasma , eb , rate ) rate = rate * fast_ion % weight / ngamma * factor !! Store neutrons call store_neutrons ( rate , fast_ion % class ) enddo gyro_loop else !! Get plasma parameters call get_plasma ( plasma , pos = uvw , input_coords = 1 ) if (. not . plasma % in_plasma ) cycle loop_over_fast_ions !! Calculate effective beam energy uvw_vi ( 1 ) = fast_ion % vr uvw_vi ( 2 ) = fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) vnet_square = dot_product ( vi - plasma % vrot , vi - plasma % vrot ) ![cm/s] eb = v2_to_E_per_amu * inputs % ab * vnet_square ![kev] !! Get neutron production rate call get_neutron_rate ( plasma , eb , rate ) rate = rate * fast_ion % weight * factor !! Store neutrons call store_neutrons ( rate , fast_ion % class ) endif enddo loop_over_fast_ions !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( neutron % rate ) #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,A,ES14.5,\" [neutrons/s]\")' ) 'Rate:   ' , sum ( neutron % rate ) write ( * , '(30X,a)' ) '' write ( * , * ) 'write neutrons:    ' , time ( time_start ) endif #ifdef _MPI if ( my_rank (). eq . 0 ) call write_neutrons () #else call write_neutrons () #endif end subroutine neutron_mc subroutine fida_weights_mc !+ Calculates FIDA weights integer :: i , j , k , ic , ncell integer ( Int64 ) :: iion , ip real ( Float64 ), dimension ( 3 ) :: ri , rg !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions integer , dimension ( 3 ) :: ind !! new actual cell integer , dimension ( 5 ) :: neut_types = [ 1 , 2 , 3 , 4 , 5 ] logical :: los_intersect !! Determination of the CX rates type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( Float64 ), dimension ( nlevs ) :: rates !! CX rates !! Collisiional radiative model along track integer :: ntrack integer :: jj !! counter along track type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks real ( Float64 ) :: photons !! photon flux real ( Float64 ), dimension ( nlevs ) :: states !! Density of n-states real ( Float64 ), dimension ( nlevs ) :: denn integer :: nwav real ( Float64 ) :: etov2 , energy , pitch real ( Float64 ) :: dE , dP , dEdP real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr integer , dimension ( 1 ) :: ienergy , ipitch real ( Float64 ), dimension ( 3 ) :: randomu3 !! Number of particles to launch real ( Float64 ) :: fbm_denf , phase_area , max_papprox integer , dimension ( beam_grid % ngrid ) :: cell_ind real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox integer ( Int32 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: nlaunch nwav = inputs % nlambda_wght !! define arrays !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) dEdP = dE * dP phase_area = dEdP * real ( inputs % np_wght ) * real ( inputs % ne_wght ) !! allocate storage arrays allocate ( fweight % weight ( nwav , inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( fweight % mean_f ( inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) if ( inputs % verbose . ge . 1 ) then write ( * , '(T3,\"Number of Channels: \",i5)' ) spec_chords % nchan write ( * , '(T3,\"Nlambda: \",i4)' ) nwav write ( * , '(T3,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T3,\"Maximum Energy: \",f7.2)' ) inputs % emax_wght write ( * , '(T3,\"LOS averaged: \",a)' ) \"False\" endif !! zero out arrays fweight % weight = 0.d0 fweight % mean_f = 0.d0 etov2 = 1.d0 / ( v2_to_E_per_amu * inputs % ab ) !! Estimate how many particles to launch in each cell papprox = 0.d0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) call get_plasma ( plasma , ind = ind ) if (. not . plasma % in_plasma ) cycle papprox ( i , j , k ) = ( sum ( neut % full (:, i , j , k )) + & sum ( neut % half (:, i , j , k )) + & sum ( neut % third (:, i , j , k )) + & sum ( neut % dcx (:, i , j , k )) + & sum ( neut % halo (:, i , j , k ))) enddo !! TODO: Remove this once we have a 3D interpolation grid max_papprox = maxval ( papprox ) where ( papprox . lt .( max_papprox * 1.d-3 )) papprox = 0.0 endwhere ncell = 0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) if ( papprox ( i , j , k ). gt . 0.0 ) then ncell = ncell + 1 cell_ind ( ncell ) = ic endif enddo call get_nlaunch ( 10 * inputs % n_fida , papprox , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) sum ( nlaunch ) endif !! Loop over all cells that have neutrals !$OMP PARALLEL DO schedule(guided) private(ic,i,j,k,ind,iion,vi,ri,rg,ienergy,ipitch, & !$OMP tracks,ntrack,jj,plasma,fields,rates,denn,states,photons,energy,pitch, & !$OMP los_intersect,randomu3,fbm_denf) loop_over_cells : do ic = istart , ncell , istep call ind2sub ( beam_grid % dims , cell_ind ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) loop_over_fast_ions : do iion = 1 , nlaunch ( i , j , k ) !! Sample fast ion distribution uniformally call randind ( inputs % ne_wght , ienergy ) call randind ( inputs % np_wght , ipitch ) call randu ( randomu3 ) energy = ebarr ( ienergy ( 1 )) + dE * ( randomu3 ( 1 ) - 0.5 ) pitch = ptcharr ( ipitch ( 1 )) + dP * ( randomu3 ( 2 ) - 0.5 ) if ( energy . le . 0 ) cycle loop_over_fast_ions call randu ( randomu3 ) rg = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] + beam_grid % dr * ( randomu3 - 0.5 ) !! Get velocity call get_fields ( fields , pos = rg ) if (. not . fields % in_plasma ) cycle loop_over_fast_ions call gyro_correction ( fields , energy , pitch , ri , vi ) fbm_denf = 0.0 if ( inputs % dist_type . eq . 1 ) then call get_ep_denf ( energy , pitch , fbm_denf , coeffs = fields % b ) endif !! Find the particles path through the beam grid call track ( ri , vi , tracks , ntrack , los_intersect ) if (. not . los_intersect ) cycle loop_over_fast_ions if ( ntrack . eq . 0 ) cycle loop_over_fast_ions !! Calculate CX probability with beam and halo neutrals call get_beam_cx_rate ( tracks ( 1 )% ind , ri , vi , beam_ion , neut_types , rates ) if ( sum ( rates ). le . 0. ) cycle loop_over_fast_ions states = rates * 1.d20 !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ntrack call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fw_photons ( ienergy ( 1 ), ipitch ( 1 ), & tracks ( jj )% pos , vi , fbm_denf , photons / nlaunch ( i , j , k )) enddo loop_along_track enddo loop_over_fast_ions enddo loop_over_cells !$OMP END PARALLEL DO fweight % weight = (( 1.d-20 ) * phase_area / dEdP ) * fweight % weight fweight % mean_f = (( 1.d-20 ) * phase_area / dEdP ) * fweight % mean_f if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'write fida weights:    ' , time ( time_start ) endif #ifdef _MPI call parallel_sum ( fweight % weight ) call parallel_sum ( fweight % mean_f ) if ( my_rank (). eq . 0 ) call write_fida_weights () #else call write_fida_weights () #endif end subroutine fida_weights_mc subroutine fida_weights_los !+ Calculates LOS averaged FIDA weights type ( LocalProfiles ) :: plasma , plasma_cell type ( LocalEMFields ) :: fields , fields_cell real ( Float64 ) :: denf real ( Float64 ) :: wght , wght_tot real ( Float64 ) :: photons !! photon flux real ( Float64 ) :: length type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks integer :: nwav integer ( Int32 ) :: i , j , k , ienergy , cid , cind integer ( Int32 ) :: ipitch , igyro , icell , ichan real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr , phiarr real ( Float64 ), dimension (:,:), allocatable :: mean_f real ( Float64 ), dimension ( 3 ) :: vi , vi_norm , vp real ( Float64 ), dimension ( 3 ) :: vnbi_f , vnbi_h , vnbi_t , vhalo real ( Float64 ), dimension ( 3 ) :: r_enter , r_exit real ( Float64 ) :: vabs , dE , dP !! Determination of the CX probability real ( Float64 ), dimension ( nlevs ) :: fdens , hdens , tdens , dcxdens , halodens real ( Float64 ), dimension ( nlevs ) :: rates real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states real ( Float64 ), dimension ( nlevs ) :: denn ! Density of n-states !! COLRAD real ( Float64 ) :: dt , max_dens , dlength , sigma_pi type ( LOSInters ) :: inter real ( Float64 ) :: eb , ptch , phi !! Solution of differential equation integer , dimension ( 3 ) :: ind !!actual cell real ( Float64 ), dimension ( 3 ) :: ri integer ( Int32 ) :: ntrack logical :: inp real ( Float64 ) :: etov2 , dEdP nwav = inputs % nlambda_wght !! Define energy array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! Define pitch array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) dEdP = dE * dP !! define gyro - array allocate ( phiarr ( inputs % nphi_wght )) do i = 1 , inputs % nphi_wght phiarr ( i ) = real ( i - 0.5 ) * 2.d0 * pi / real ( inputs % nphi_wght ) enddo !! allocate storage arrays allocate ( fweight % mean_f ( inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( fweight % weight ( nwav , inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( mean_f ( inputs % ne_wght , inputs % np_wght )) !! zero out arrays fweight % weight = 0.d0 fweight % mean_f = 0.d0 mean_f = 0.d0 if ( inputs % verbose . ge . 1 ) then write ( * , '(T3,\"Number of Channels: \",i5)' ) spec_chords % nchan write ( * , '(T3,\"Nlambda: \",i4)' ) nwav write ( * , '(T3,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T3,\"Npitch: \",i3)' ) inputs % np_wght write ( * , '(T3,\"Ngyro: \", i3)' ) inputs % nphi_wght write ( * , '(T3,\"Maximum Energy: \",f7.2)' ) inputs % emax_wght write ( * , '(T3,\"LOS averaged: \",a)' ) \"True\" write ( * , * ) '' endif etov2 = 1.0 / ( v2_to_E_per_amu * inputs % ab ) chan_loop : do ichan = 1 , spec_chords % nchan fdens = 0.d0 ; hdens = 0.d0 ; tdens = 0.d0 halodens = 0.d0 ; dcxdens = 0.d0 plasma = plasma * 0.d0 fields = fields * 0.d0 wght_tot = 0.d0 mean_f = 0.d0 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny x_loop : do i = 1 , beam_grid % nx inter = spec_chords % inter ( i , j , k ) cid = 0 cind = 0 do while ( cid . ne . ichan . and . cind . lt . inter % nchan ) cind = cind + 1 cid = inter % los_elem ( cind )% id enddo if ( cid . eq . ichan ) then ind = [ i , j , k ] ri = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] call in_plasma ( ri , inp ) if (. not . inp ) cycle x_loop dlength = inter % los_elem ( cind )% length fdens = fdens + neut % full (:, i , j , k ) * dlength hdens = hdens + neut % half (:, i , j , k ) * dlength tdens = tdens + neut % third (:, i , j , k ) * dlength dcxdens = dcxdens + neut % dcx (:, i , j , k ) * dlength halodens = halodens + neut % halo (:, i , j , k ) * dlength wght = ( neut % full ( 3 , i , j , k ) + neut % half ( 3 , i , j , k ) + & neut % third ( 3 , i , j , k ) + neut % dcx ( 3 , i , j , k ) + & neut % halo ( 3 , i , j , k )) * dlength call get_plasma ( plasma_cell , pos = ri ) call get_fields ( fields_cell , pos = ri ) plasma = plasma + wght * plasma_cell fields = fields + wght * fields_cell if ( inputs % dist_type . eq . 1 ) then do ipitch = 1 , inputs % np_wght do ienergy = 1 , inputs % ne_wght call get_ep_denf ( ebarr ( ienergy ), ptcharr ( ipitch ), denf , coeffs = fields_cell % b ) mean_f ( ienergy , ipitch ) = mean_f ( ienergy , ipitch ) + wght * denf enddo enddo endif wght_tot = wght_tot + wght endif enddo x_loop enddo enddo if ( wght_tot . le . 0 ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Skipping channel \",i5,\": Neutral density is zero\")' ) ichan endif cycle chan_loop else plasma = plasma / wght_tot plasma % in_plasma = . True . fields = fields / wght_tot fields % in_plasma = . True . mean_f = mean_f / wght_tot if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Channel: \",i5)' ) ichan write ( * , '(T4,\"Radius: \",f7.2)' ) spec_chords % radius ( ichan ) write ( * , '(T4,\"Mean Fast-ion Density: \",ES14.5)' ) sum ( mean_f ) * dEdP write ( * , * ) '' endif endif ri = plasma % pos vp = ri - spec_chords % los ( ichan )% lens vnbi_f = ri - nbi % src vnbi_f = vnbi_f / norm2 ( vnbi_f ) * nbi % vinj vnbi_h = vnbi_f / sqrt ( 2.d0 ) vnbi_t = vnbi_f / sqrt ( 3.d0 ) sigma_pi = spec_chords % los ( ichan )% sigma_pi dlength = 1.d0 !$OMP PARALLEL DO schedule(guided) collapse(3) private(eb,vabs,ptch,phi,vi,vi_norm, & !$OMP& r_enter,r_exit,length,max_dens,ind,tracks,ntrack,dt,icell,states,rates, & !$OMP& vhalo,denn,denf,photons,ienergy,ipitch,igyro) do ienergy = istart , inputs % ne_wght , istep do ipitch = 1 , inputs % np_wght do igyro = 1 , inputs % nphi_wght eb = ebarr ( ienergy ) vabs = sqrt ( eb * etov2 ) ptch = ptcharr ( ipitch ) phi = phiarr ( igyro ) call pitch_to_vec ( ptch , phi , fields , vi_norm ) vi = vabs * vi_norm call grid_intersect ( ri , vi , length , r_enter , r_exit ) call track ( r_enter , vi , tracks , ntrack ) max_dens = 0.d0 do icell = 1 , ntrack ind = tracks ( icell )% ind tracks ( icell )% flux = neut % full ( 3 , ind ( 1 ), ind ( 2 ), ind ( 3 )) + & neut % half ( 3 , ind ( 1 ), ind ( 2 ), ind ( 3 )) + & neut % third ( 3 , ind ( 1 ), ind ( 2 ), ind ( 3 )) + & neut % dcx ( 3 , ind ( 1 ), ind ( 2 ), ind ( 3 )) + & neut % halo ( 3 , ind ( 1 ), ind ( 2 ), ind ( 3 )) if ( tracks ( icell )% flux . gt . max_dens ) max_dens = tracks ( icell )% flux enddo dt = 0.d0 do icell = 1 , ntrack if ( tracks ( icell )% flux . gt .( 0.5 * max_dens )) then dt = dt + tracks ( icell )% time endif enddo states = 0.d0 call bb_cx_rates ( fdens , vi , vnbi_f , rates ) states = states + rates call bb_cx_rates ( hdens , vi , vnbi_h , rates ) states = states + rates call bb_cx_rates ( tdens , vi , vnbi_t , rates ) states = states + rates call bt_cx_rates ( plasma , dcxdens + halodens , vi , beam_ion , rates ) states = states + rates call colrad ( plasma , beam_ion , vi , dt , states , denn , photons ) denf = mean_f ( ienergy , ipitch ) * dEdP photons = photons / real ( inputs % nphi_wght ) call store_fw_photons_at_chan ( ichan , ienergy , ipitch , & vp , vi , fields , dlength , sigma_pi , denf , photons ) enddo enddo enddo !$OMP END PARALLEL DO enddo chan_loop fweight % mean_f = fweight % mean_f / ( dEdP ) if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'write fida weights:    ' , time ( time_start ) endif #ifdef _MPI call parallel_sum ( fweight % weight ) call parallel_sum ( fweight % mean_f ) if ( my_rank (). eq . 0 ) call write_fida_weights () #else call write_fida_weights () #endif end subroutine fida_weights_los subroutine npa_weights !+ Calculates NPA weights type ( LocalEMFields ) :: fields type ( NPAProbability ) :: phit real ( Float64 ) :: pitch real ( Float64 ) :: pcxa integer ( Int32 ) :: det integer ( Int32 ) :: ii , jj , kk , i , ic !!indices integer , dimension ( 1 ) :: ipitch real ( Float64 ), dimension ( 3 ) :: vi , vi_norm real ( Float64 ) :: vabs , fbm_denf , dE , dP real ( Float64 ), dimension ( nlevs ) :: pcx !! Rate coefficiants for CX real ( Float64 ), dimension ( nlevs ) :: states , states_i ! Density of n-states integer , dimension ( 5 ) :: neut_types = [ 1 , 2 , 3 , 4 , 5 ] real ( Float64 ), dimension ( 3 ) :: pos , dpos , r_gyro integer ( Int32 ) :: ichan real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) if ( inputs % verbose . ge . 1 ) then write ( * , '(T3,\"Number of Channels: \",i3)' ) npa_chords % nchan write ( * , '(T3,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T3,\"Npitch: \",i3)' ) inputs % np_wght write ( * , '(T3,\"Maximum energy: \",f7.2)' ) inputs % emax_wght write ( * , * ) '' endif !! define storage arrays allocate ( nweight % emissivity ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % attenuation ( inputs % ne_wght , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % cx ( inputs % ne_wght , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % weight ( inputs % ne_wght , & inputs % np_wght , & npa_chords % nchan )) allocate ( nweight % flux ( inputs % ne_wght , npa_chords % nchan )) nweight % emissivity = 0.d0 nweight % attenuation = 0.d0 nweight % cx = 0.d0 nweight % weight = 0.d0 nweight % flux = 0.d0 loop_over_channels : do ichan = 1 , npa_chords % nchan !$OMP PARALLEL DO schedule(guided) collapse(3) private(ii,jj,kk,fields,phit,& !$OMP& ic,det,pos,dpos,r_gyro,pitch,ipitch,vabs,vi,pcx,pcxa,states,states_i,vi_norm,fbm_denf) loop_along_z : do kk = 1 , beam_grid % nz loop_along_y : do jj = 1 , beam_grid % ny loop_along_x : do ii = 1 , beam_grid % nx phit = npa_chords % phit ( ii , jj , kk , ichan ) if ( phit % p . gt . 0.d0 ) then pos = [ beam_grid % xc ( ii ), beam_grid % yc ( jj ), beam_grid % zc ( kk )] call get_fields ( fields , pos = pos ) if (. not . fields % in_plasma ) cycle loop_along_x !!Check if it hits a detector just to make sure dpos = phit % eff_rd vi_norm = phit % dir call hit_npa_detector ( pos , vi_norm , det ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'NPA_WEIGHTS: Missed detector' endif cycle loop_along_x endif !! Determine the angle between the B-field and the Line of Sight pitch = phit % pitch ipitch = minloc ( abs ( ptcharr - pitch )) loop_over_energy : do ic = istart , inputs % ne_wght , istep !! energy loop vabs = sqrt ( ebarr ( ic ) / ( v2_to_E_per_amu * inputs % ab )) vi = vi_norm * vabs !!Correct for gyro orbit call gyro_step ( vi , fields , r_gyro ) fbm_denf = 0 if ( inputs % dist_type . eq . 1 ) then !get dist at guiding center call get_ep_denf ( ebarr ( ic ), pitch , fbm_denf , pos = ( pos + r_gyro )) endif if ( fbm_denf . ne . fbm_denf ) cycle loop_over_energy !! -------------- calculate CX probability -------!! call get_beam_cx_rate ([ ii , jj , kk ], pos , vi , beam_ion , neut_types , pcx ) if ( sum ( pcx ). le . 0 ) cycle loop_over_energy !!Calculate attenuation states = pcx * 1.0d14 !!needs to be large aribitrary number so colrad works states_i = states call attenuate ( pos , dpos , vi , states ) pcxa = sum ( states ) / sum ( states_i ) !$OMP CRITICAL(npa_wght) nweight % attenuation ( ic , ii , jj , kk , ichan ) = pcxa nweight % cx ( ic , ii , jj , kk , ichan ) = sum ( pcx ) nweight % weight ( ic , ipitch ( 1 ), ichan ) = nweight % weight ( ic , ipitch ( 1 ), ichan ) + & 2 * sum ( pcx ) * pcxa * phit % p * beam_grid % dv / dP nweight % flux ( ic , ichan ) = nweight % flux ( ic , ichan ) + & 2 * beam_grid % dv * fbm_denf * sum ( pcx ) * pcxa * phit % p !Factor of 2 above is to convert fbm to ions/(cm&#94;3 dE (domega/4pi)) nweight % emissivity ( ii , jj , kk , ichan ) = nweight % emissivity ( ii , jj , kk , ichan ) + & 2 * fbm_denf * sum ( pcx ) * pcxa * phit % p * dE !$OMP END CRITICAL(npa_wght) enddo loop_over_energy endif enddo loop_along_x enddo loop_along_y enddo loop_along_z !$OMP END PARALLEL DO enddo loop_over_channels #ifdef _MPI call parallel_sum ( nweight % weight ) call parallel_sum ( nweight % flux ) call parallel_sum ( nweight % cx ) call parallel_sum ( nweight % attenuation ) call parallel_sum ( nweight % emissivity ) #endif do ichan = 1 , npa_chords % nchan if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Channel: \",i3)' ) ichan write ( * , '(T4,\"Radius: \",f10.3)' ) npa_chords % radius ( ichan ) write ( * , '(T4,A,ES14.5)' ) 'Flux:   ' , sum ( nweight % flux (:, ichan )) * dE write ( * , '(T4,A,ES14.5)' ) 'Weight: ' , sum ( nweight % weight (:,:, ichan )) * dE * dP write ( * , * ) '' endif enddo if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'write npa weights:    ' , time ( time_start ) endif #ifdef _MPI if ( my_rank (). eq . 0 ) call write_npa_weights () #else call write_npa_weights () #endif end subroutine npa_weights end module libfida !============================================================================= !-------------------------------Main Program---------------------------------- !============================================================================= program fidasim !+ FIDASIM {!../VERSION!} use libfida use hdf5_utils #ifdef _OMP use omp_lib #endif #ifdef _MPI use mpi_utils #endif implicit none character ( 3 ) :: arg = '' integer :: i , narg , nthreads , max_threads , seed #ifdef _VERSION version = _ VERSION #endif #ifdef _MPI call init_mpi () if ( my_rank (). eq . 0 ) call print_banner () #else call print_banner () #endif narg = command_argument_count () if ( narg . eq . 0 ) then #ifdef _MPI if ( my_rank (). eq . 0 ) write ( * , '(a)' ) \"usage: mpirun -np [num_processes] ./fidasim namelist_file\" call cleanup_mpi () #else write ( * , '(a)' ) \"usage: ./fidasim namelist_file [num_threads]\" #endif stop else call get_command_argument ( 1 , namelist_file ) endif !! Check if compression is possible call check_compression_availability () !! measure time call date_and_time ( values = time_start ) call read_inputs () #ifdef _OMP max_threads = OMP_get_num_procs () if ( narg . ge . 2 ) then call get_command_argument ( 2 , arg ) read ( arg , '(i3)' ) nthreads else nthreads = max_threads endif max_threads = min ( nthreads , max_threads ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- OpenMP settings ----\" write ( * , '(T2,\"Number of threads: \",i2)' ) max_threads write ( * , * ) '' endif call OMP_set_num_threads ( max_threads ) #else max_threads = 1 #endif #ifdef _MPI istart = my_rank () + 1 istep = num_ranks () if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- MPI settings ----\" write ( * , '(T2,\"Number of processes: \",i3)' ) istep write ( * , * ) '' endif #endif !! ---------------------------------------------------------- !! ------ INITIALIZE THE RANDOM NUMBER GENERATOR  ----------- !! ---------------------------------------------------------- allocate ( rng ( max_threads )) #ifdef _OMP do i = 1 , max_threads if ( inputs % seed . lt . 0 ) then call rng_init ( rng ( i ), inputs % seed ) else call rng_init ( rng ( i ), inputs % seed + i ) endif enddo #else call rng_init ( rng ( 1 ), inputs % seed ) #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Random Number Generator settings ----\" write ( * , '(T2,\"RNG Seed: \",i10)' ) inputs % seed write ( * , * ) '' endif !! ---------------------------------------------------------- !! ------- READ GRIDS, PROFILES, LOS, TABLES, & FBM -------- !! ---------------------------------------------------------- call read_tables () call read_equilibrium () call make_beam_grid () if ( inputs % calc_beam . ge . 1 ) call read_beam () call read_distribution () allocate ( spec_chords % inter ( beam_grid % nx , beam_grid % ny , beam_grid % nz )) if (( inputs % calc_spec . ge . 1 ). or .( inputs % calc_fida_wght . ge . 1 )) then call read_chords () endif if (( inputs % calc_npa . ge . 1 ). or .( inputs % calc_npa_wght . ge . 1 ). or .( inputs % calc_pnpa . ge . 1 )) then call read_npa () endif call make_diagnostic_grids () !! ---------------------------------------------------------- !! --------------- ALLOCATE THE RESULT ARRAYS --------------- !! ---------------------------------------------------------- !! neutral density array! allocate ( neut % full ( nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz )) allocate ( neut % half ( nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz )) allocate ( neut % third ( nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz )) allocate ( neut % dcx ( nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz )) allocate ( neut % halo ( nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz )) neut % full = 0.d0 neut % half = 0.d0 neut % third = 0.d0 neut % dcx = 0.d0 neut % halo = 0.d0 !! birth profile if ( inputs % calc_birth . ge . 1 ) then allocate ( birth % dens ( 3 , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz )) allocate ( birth % part ( int ( 3 * inputs % n_birth * inputs % n_nbi ))) endif if ( inputs % calc_spec . ge . 1 ) then if ( inputs % calc_brems . ge . 1 ) then allocate ( spec % brems ( inputs % nlambda , spec_chords % nchan )) spec % brems = 0.d0 endif if ( inputs % calc_bes . ge . 1 ) then allocate ( spec % full ( inputs % nlambda , spec_chords % nchan )) allocate ( spec % half ( inputs % nlambda , spec_chords % nchan )) allocate ( spec % third ( inputs % nlambda , spec_chords % nchan )) spec % full = 0.d0 spec % half = 0.d0 spec % third = 0.d0 endif if ( inputs % calc_dcx . ge . 1 ) then allocate ( spec % dcx ( inputs % nlambda , spec_chords % nchan )) spec % dcx = 0.d0 endif if ( inputs % calc_halo . ge . 1 ) then allocate ( spec % halo ( inputs % nlambda , spec_chords % nchan )) spec % halo = 0.d0 endif if ( inputs % calc_cold . ge . 1 ) then allocate ( spec % cold ( inputs % nlambda , spec_chords % nchan )) spec % cold = 0.d0 endif if ( inputs % calc_fida . ge . 1 ) then allocate ( spec % fida ( inputs % nlambda , spec_chords % nchan , particles % nclass )) spec % fida = 0.d0 endif if ( inputs % calc_pfida . ge . 1 ) then allocate ( spec % pfida ( inputs % nlambda , spec_chords % nchan , particles % nclass )) spec % pfida = 0.d0 endif endif if ( inputs % calc_npa . ge . 1 ) then npa % nchan = npa_chords % nchan allocate ( npa % part ( npa % nmax )) if ( inputs % dist_type . eq . 1 ) then npa % nenergy = fbm % nenergy allocate ( npa % energy ( npa % nenergy )) npa % energy = fbm % energy else allocate ( npa % energy ( npa % nenergy )) do i = 1 , npa % nenergy npa % energy ( i ) = real ( i - 0.5 ) enddo endif allocate ( npa % flux ( npa % nenergy , npa % nchan , particles % nclass )) npa % flux = 0.0 endif if ( inputs % calc_pnpa . ge . 1 ) then pnpa % nchan = npa_chords % nchan allocate ( pnpa % part ( pnpa % nmax )) if ( inputs % dist_type . eq . 1 ) then pnpa % nenergy = fbm % nenergy allocate ( pnpa % energy ( pnpa % nenergy )) pnpa % energy = fbm % energy else allocate ( pnpa % energy ( pnpa % nenergy )) do i = 1 , pnpa % nenergy pnpa % energy ( i ) = real ( i - 0.5 ) enddo endif allocate ( pnpa % flux ( pnpa % nenergy , pnpa % nchan , particles % nclass )) pnpa % flux = 0.0 endif if ( inputs % calc_neutron . ge . 1 ) then allocate ( neutron % rate ( particles % nclass )) neutron % rate = 0.d0 endif !! ----------------------------------------------------------------------- !! --------------- CALCULATE/LOAD the BEAM and HALO DENSITY--------------- !! ----------------------------------------------------------------------- if ( inputs % load_neutrals . eq . 1 ) then call read_neutrals () if ( inputs % calc_bes . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'nbi:     ' , time ( time_start ) endif call nbi_spec () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_dcx . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'dcx:     ' , time ( time_start ) endif call dcx_spec () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_halo . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'halo:    ' , time ( time_start ) endif call halo_spec () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif else if ( inputs % calc_beam . ge . 1 ) then !! ----------- BEAM NEUTRALS ---------- !! if ( inputs % calc_nbi_dens . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'nbi:     ' , time ( time_start ) endif call ndmc if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' if ( inputs % calc_birth . eq . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'write birth:    ' , time ( time_start ) endif call write_birth_profile () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif endif !! ---------- DCX (Direct charge exchange) ---------- !! if ( inputs % calc_dcx_dens . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'dcx:     ' , time ( time_start ) endif call dcx () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ---------- HALO ---------- !! if ( inputs % calc_halo_dens . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'halo:    ' , time ( time_start ) endif call halo () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ---------- WRITE NEUTRALS ---------- !! if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'write neutrals:    ' , time ( time_start ) endif #ifdef _MPI if ( my_rank (). eq . 0 ) call write_neutrals () #else call write_neutrals () #endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif endif !! ----------------------------------------------------------------------- !!------------------------------ COLD D-ALPHA ---------------------------- !! ----------------------------------------------------------------------- if ( inputs % calc_cold . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'cold:    ' , time ( time_start ) endif call cold_spec () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ----------------------------------------------------------------------- !!----------------------------- BREMSSTRAHLUNG --------------------------- !! ----------------------------------------------------------------------- if ( inputs % calc_brems . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'bremsstrahlung:    ' , time ( time_start ) endif call bremsstrahlung () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ----------------------------------------------------------------------- !! --------------------- CALCULATE the FIDA RADIATION -------------------- !! ----------------------------------------------------------------------- if ( inputs % calc_fida . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'fida:    ' , time ( time_start ) endif if ( inputs % dist_type . eq . 1 ) then call fida_f () else call fida_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_pfida . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'pfida:   ' , time ( time_start ) endif if ( inputs % dist_type . eq . 1 ) then call pfida_f () else call pfida_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_spec . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'write spectra:    ' , time ( time_start ) endif #ifdef _MPI if ( my_rank (). eq . 0 ) call write_spectra () #else call write_spectra () #endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ----------------------------------------------------------------------- !! ----------------------- CALCULATE the NPA FLUX ------------------------ !! ----------------------------------------------------------------------- if ( inputs % calc_npa . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'npa:     ' , time ( time_start ) endif if ( inputs % dist_type . eq . 1 ) then call npa_f () else call npa_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_pnpa . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'pnpa:     ' , time ( time_start ) endif if ( inputs % dist_type . eq . 1 ) then call pnpa_f () else call pnpa_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if (( inputs % calc_npa . ge . 1 ). or .( inputs % calc_pnpa . ge . 1 )) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'write npa:    ' , time ( time_start ) endif call write_npa () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ------------------------------------------------------------------- !! ------------------- Calculation of neutron flux ------------------- !! ------------------------------------------------------------------- if ( inputs % calc_neutron . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'neutron rate:    ' , time ( time_start ) endif if ( inputs % dist_type . eq . 1 ) then call neutron_f () else call neutron_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ------------------------------------------------------------------- !! ----------- Calculation of weight functions ----------------------- !! ------------------------------------------------------------------- if ( inputs % calc_fida_wght . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'fida weight function:    ' , time ( time_start ) endif if ( inputs % calc_fida_wght . eq . 1 ) then call fida_weights_los () else call fida_weights_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_npa_wght . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'npa weight function:    ' , time ( time_start ) endif call npa_weights () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif #ifdef _MPI call cleanup_mpi () #endif if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'END: hour:minute:second ' , time ( time_start ) endif end program fidasim","tags":"","loc":"sourcefile/fidasim.f90.html","title":"fidasim.f90 – FIDASIM"},{"text":"This file contains all the linear algebra routines FIDASIM uses Files dependent on this one sourcefile~~eigensystem.f90~~AfferentGraph sourcefile~eigensystem.f90 eigensystem.f90 sourcefile~fidasim.f90 fidasim.f90 sourcefile~fidasim.f90->sourcefile~eigensystem.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules eigensystem Source Code eigensystem.f90 Source Code !+ This file contains all the linear algebra routines FIDASIM uses module eigensystem !+ A basic libary for calculating matrix eigen-decompositions and inverses implicit none !!Definition for the kind of the variables: integer , parameter :: long = kind ( int ( 1 )) integer , parameter :: float = kind ( 1.e0 ) integer , parameter :: double = kind ( 1.d0 ) !! eigenvalue decomposition values real ( double ), parameter :: ONE = 1.d0 , TWO = 2.d0 , ZERO = 0.d0 real ( double ), parameter :: XMACH_EPS = 2.22d-16 integer , parameter :: MAXIT = 50 contains ! first subroutines for eigenvalue decomposition subroutine RSWAP ( a , b ) !+ Swaps values `a` and `b` real ( double ) :: a , b , t t = a ; a = b ; b = t end subroutine RSWAP subroutine balance ( n , mat , scal , low , high ) !+Balances the matrix so that the rows with zero entries !+off the diagonal are isolated and the remaining columns and rows !+are resized to have one norm close to 1. integer , intent ( in ) :: n !+ Dimension of `mat` real ( double ) :: mat ( 0 : n - 1 , 0 : n - 1 ) !+ `n`x`n` scaled matrix real ( double ) :: scal ( 0 : n - 1 ) !+ Contains isolated eigenvalue in the positions 0-`low` and `high`-`n`-1 !+ its other components contain the scaling factors for transforming `mat` integer , intent ( out ) :: high integer , intent ( out ) :: low integer , parameter :: basis = 2 real ( double ) :: b2 , r , c , f , g , s integer :: m , k , i , j , iter scal = 0.d0 b2 = basis * basis m = 0 k = n - 1 iter = 1 do while ( iter == 1 ) iter = 0 do j = k , 0 , - 1 r = ZERO do i = 0 , k if ( i . ne . j ) r = r + DABS ( mat ( j , i )) enddo if ( r == ZERO ) then scal ( k ) = j if ( j . ne . k ) then do i = 0 , k call RSWAP ( mat ( i , j ), mat ( i , k )) enddo do i = m , n - 1 call RSWAP ( mat ( j , i ), mat ( k , i )) enddo endif k = k - 1 iter = 1 endif enddo !j loop enddo !while iter=1 iter = 1 do while ( iter == 1 ) iter = 0 do j = m , k c = ZERO do i = m , k if ( i . ne . j ) c = c + DABS ( mat ( i , j )) enddo if ( c == ZERO ) then scal ( m ) = j if ( j . ne . m ) then do i = 0 , k call RSWAP ( mat ( i , j ), mat ( i , m )) enddo do i = m , n - 1 call RSWAP ( mat ( j , i ), mat ( m , i )) enddo endif m = m + 1 iter = 1 endif enddo !j loop enddo !while iter=1 low = m high = k do i = m , k scal ( i ) = ONE enddo iter = 1 do while ( iter == 1 ) iter = 0 do i = m , k c = ZERO ; r = ZERO do j = m , k if ( j . ne . i ) then c = c + DABS ( mat ( j , i )) r = r + DABS ( mat ( i , j )) endif enddo g = r / basis f = ONE s = c + r do while ( c < g ) f = f * basis c = c * b2 enddo g = r * basis do while ( c >= g ) f = f / basis c = c / b2 enddo if (( c + r ) / f < 0.95 * s ) then g = ONE / f scal ( i ) = scal ( i ) * f iter = 1 do j = m , n - 1 mat ( i , j ) = mat ( i , j ) * g enddo do j = 0 , k mat ( j , i ) = mat ( j , i ) * f enddo endif enddo !i loop enddo !while iter=1 return end subroutine balance subroutine balback ( n , low , high , scal , eivec ) !+  Reverses the balancing of balance for the eigenvectors integer , intent ( in ) :: n !+ Dimension of matrix integer , intent ( in ) :: low !+ First nonzero row integer , intent ( in ) :: high !+ Last nonzero row real ( double ), intent ( in ) :: scal ( 0 : n - 1 ) !+ Scaling data from balance real ( double ), intent ( inout ) :: eivec ( 0 : n - 1 , 0 : n - 1 ) !+ Input: n x n matrix of eigenvectors, as computed in qr2 !+ Output: Non-normalized eigenvectors of the original matrix real ( double ) :: s integer :: i , j , k do i = low , high s = scal ( i ) do j = 0 , n - 1 eivec ( i , j ) = eivec ( i , j ) * s enddo enddo do i = low - 1 , 0 , - 1 k = Int ( scal ( i )) if ( k . ne . i ) then do j = 0 , n - 1 call RSWAP ( eivec ( i , j ), eivec ( k , j )) enddo endif enddo do i = high + 1 , n - 1 k = Int ( scal ( i )) if ( k . ne . i ) then do j = 0 , n - 1 call RSWAP ( eivec ( i , j ), eivec ( k , j )) enddo endif enddo return end subroutine balback subroutine elmhes ( n , low , high , mat , perm ) !+Transforms the matrix `mat` to upper Hessenberg form. integer , intent ( in ) :: n !+Dimension of `mat` integer , intent ( in ) :: low !+First nonzero row integer , intent ( in ) :: high !+Last nonzero row real ( double ), intent ( inout ) :: mat ( 0 : n - 1 , 0 : n - 1 ) !+Input: `n`x`n` matrix !+Output: Upper Hessenberg matrix; additional information on the tranformation !+is stored in the lower triangle integer , intent ( out ) :: perm ( 0 : n - 1 ) !+Permutation vector for elmtrans integer :: i , j , m real ( double ) :: x , y do m = low + 1 , high - 1 i = m x = ZERO do j = m , high if ( DABS ( mat ( j , m - 1 )) > DABS ( x )) then x = mat ( j , m - 1 ) i = j endif enddo perm ( m ) = i if ( i . ne . m ) then do j = m - 1 , n - 1 call RSWAP ( mat ( i , j ), mat ( m , j )) enddo do j = 0 , high call RSWAP ( mat ( j , i ), mat ( j , m )) enddo endif if ( x . ne . ZERO ) then do i = m + 1 , high y = mat ( i , m - 1 ) if ( y . ne . ZERO ) then y = y / x mat ( i , m - 1 ) = y do j = m , n - 1 mat ( i , j ) = mat ( i , j ) - y * mat ( m , j ) enddo do j = 0 , high mat ( j , m ) = mat ( j , m ) + y * mat ( j , i ) enddo endif enddo !i loop endif !x <> ZERO enddo !m loop end subroutine elmhes Subroutine elmtrans ( n , low , high , mat , perm , h ) !+  Elmtrans copies the Hessenberg matrix stored in `mat` to `h` integer , intent ( in ) :: n !+ Dimension of mat integer , intent ( in ) :: low !+ First nonzero row integer , intent ( in ) :: high !+ Last nonzero row real ( double ), intent ( in ) :: mat ( 0 : n - 1 , 0 : n - 1 ) !+ `n`x`n` input matrix integer , intent ( in ) :: perm ( 0 : n - 1 ) !+ Permutation data from elmhes real ( double ), intent ( out ) :: h ( 0 : n - 1 , 0 : n - 1 ) !+ Hessenberg matrix integer :: i , j , k do i = 0 , n - 1 do k = 0 , n - 1 h ( i , k ) = ZERO enddo h ( i , i ) = ONE enddo do i = high - 1 , low + 1 , - 1 j = perm ( i ) do k = i + 1 , high h ( k , i ) = mat ( k , i - 1 ) enddo if ( i . ne . j ) then do k = i , high h ( i , k ) = h ( j , k ) h ( j , k ) = ZERO enddo h ( j , i ) = ONE endif enddo end subroutine elmtrans subroutine Comdiv ( ar , ai , br , bi , cr , ci , rc ) !+ Performs complex division `c` = `a` / `b` real ( double ) :: ar !+ Real part of numerator real ( double ) :: ai !+ Imaginary part of numerator real ( double ) :: br !+ Real part of denominator real ( double ) :: bi !+ Imaginary part of denominator real ( double ) :: cr !+ Real part of quotient real ( double ) :: ci !+ Imaginary part of quotient integer :: rc !+ return code real ( double ) :: tmp if ( br == ZERO . AND . bi == ZERO ) then rc = 1 return endif if ( dabs ( br ) > dabs ( bi )) then tmp = bi / br br = tmp * bi + br cr = ( ar + tmp * ai ) / br ci = ( ai - tmp * ar ) / br else tmp = br / bi bi = tmp * br + bi cr = ( tmp * ar + ai ) / bi ci = ( tmp * ai - ar ) / bi endif rc = 0 end subroutine Comdiv !Comdiv function comabs ( ar , ai ) !+ Calculates absolute value of a complex number `a` real ( double ) :: ar !+ Real part of `a` real ( double ) :: ai !+ Imaginary part of `a` real ( double ) :: comabs !+ Absolute value of `a` if ( ar == ZERO . and . ai == ZERO ) then Comabs = ZERO return endif ar = DABS ( ar ) ai = DABS ( ai ) if ( ai > ar ) then !Switch  ai and ar call RSWAP ( ai , ar ) endif if ( ai == ZERO ) then Comabs = ar else Comabs = ar * DSQRT ( ONE + ai / ar * ai / ar ) endif end function comabs subroutine hqrvec ( n , & !Dimension of matrix ....... low , & !first nonzero row ......... high , & !last nonzero row .......... h , & !upper Hessenberg matrix ... wr , & !Real parts of evalues ..... wi , & !Imaginary parts of evalues eivec , & !Eigenvectors .............. rc ) !return code ............... !+Computes the eigenvectors for the eigenvalues found in hqr2 !+ !+###Input parameters !+   n     :   int n;  ( n > 0 ) !+         :   Dimension of  mat and eivec, number of eigenvalues. !+ !+   low   :   int low; !+ !+   high  :   int high; see  balance !+ !+   h     :   n x n upper Hessenberg matrix !+ !+   wr    :   vector of size n; !+         :   Real parts of the n eigenvalues. !+ !+   wi    :   vector of size n; Imaginary parts of the n eigenvalues. !+ !+###Output parameter: !+   eivec :  n x n matrix, whose columns are the eigenvectors integer , intent ( in ) :: n integer , intent ( in ) :: high , low real ( double ), intent ( in ) :: wr ( 0 : n - 1 ), wi ( 0 : n - 1 ) real ( double ), intent ( out ) :: eivec ( 0 : n - 1 , 0 : n - 1 ) real ( double ) :: h ( 0 : n - 1 , 0 : n - 1 ) integer :: rc integer :: i , j , m , k , na , l integer :: code , en real ( double ) :: p , q , r , s , t , w , x , y , z , ra , sa , vr , vi , norm , temp r = ZERO ; s = ZERO ; z = ZERO ; norm = ZERO do i = 0 , n - 1 !find norm of h do j = i , n - 1 norm = norm + DABS ( h ( i , j )) enddo enddo if ( norm == ZERO ) then rc = 1 !zero matrix return endif do en = n - 1 , 0 , - 1 !transform back p = wr ( en ) q = wi ( en ) na = en - 1 if ( q == ZERO ) then m = en h ( en , en ) = ONE do i = na , 0 , - 1 w = h ( i , i ) - p r = h ( i , en ) do j = m , na r = r + h ( i , j ) * h ( j , en ) enddo if ( wi ( i ) < ZERO ) then z = w s = r else m = i if ( wi ( i ) == ZERO ) then if ( w . ne . ZERO ) then temp = w else temp = XMACH_EPS * norm endif h ( i , en ) = - r / temp else !Solve the linear system: !| w   x |  | h[i][en]   |   | -r | !|       |  |            | = |    | !| y   z |  | h[i+1][en] |   | -s | x = h ( i , i + 1 ) y = h ( i + 1 , i ) q = ( wr ( i ) - p ) ** 2 + wi ( i ) ** 2 h ( i , en ) = ( x * s - z * r ) / q t = h ( i , en ) if ( DABS ( x ) > DABS ( z )) then temp = ( - r - w * t ) / x else temp = ( - s - y * t ) / z endif h ( i + 1 , en ) = temp endif endif !wi[i] < 0 enddo !i loop else if ( q < ZERO ) then m = na if ( DABS ( h ( en , na )) > DABS ( h ( na , en ))) then h ( na , na ) = - ( h ( en , en ) - p ) / h ( en , na ) h ( na , en ) = - q / h ( en , na ) else call Comdiv ( - h ( na , en ), 0.d0 , h ( na , na ) - p , q , h ( na , na ), h ( na , en ), code ) endif h ( en , na ) = ONE h ( en , en ) = ZERO do i = na - 1 , 0 , - 1 w = h ( i , i ) - p ra = h ( i , en ) sa = ZERO do j = m , na ra = ra + h ( i , j ) * h ( j , na ) sa = sa + h ( i , j ) * h ( j , en ) enddo if ( wi ( i ) < ZERO ) then z = w r = ra s = sa else m = i if ( wi ( i ) == ZERO ) then call Comdiv ( - ra , - sa , w , q , h ( i , na ), h ( i , en ), code ) else !  solve complex linear system: !| w+i*q     x | | h[i][na] + i*h[i][en]  |   | -ra+i*sa | !|             | |                        | = |          | !|   y    z+i*q| | h[i+1][na]+i*h[i+1][en]|   | -r+i*s   | x = h ( i , i + 1 ) y = h ( i + 1 , i ) vr = ( wr ( i ) - p ) ** 2 + wi ( i ) ** 2 - q * q vi = TWO * q * ( wr ( i ) - p ) if ( vr == ZERO . AND . vi == ZERO ) then vr = XMACH_EPS * norm * ( DABS ( w ) + DABS ( q ) & + DABS ( x ) + DABS ( y ) + DABS ( z )) endif call Comdiv ( x * r - z * ra + q * sa , x * s - z * sa - q * ra & , vr , vi , h ( i , na ), h ( i , en ), code ) if ( DABS ( x ) > DABS ( z ) + DABS ( q )) then h ( i + 1 , na ) = ( - ra - w * h ( i , na ) + q * h ( i , en )) / x h ( i + 1 , en ) = ( - sa - w * h ( i , en ) - q * h ( i , na )) / x else call Comdiv ( - r - y * h ( i , na ), - s - y * h ( i , en ) & , z , q , h ( i + 1 , na ), h ( i + 1 , en ), code ) endif endif !wi[i] = 0 endif !wi[i] < 0 enddo !i loop endif !else if q < 0 enddo !en loop do i = 0 , n - 1 !Eigenvectors for the evalues for if ( i < low . or . i > high ) then !rows < low  and rows  > high do k = i + 1 , n - 1 eivec ( i , k ) = h ( i , k ) enddo endif enddo j = n - 1 do while ( j >= low ) if ( j <= high ) then m = j else j = high endif if ( j < 0 ) exit if ( wi ( j ) < ZERO ) then l = j - 1 do i = low , high y = ZERO ; z = ZERO do k = low , m y = y + eivec ( i , k ) * h ( k , l ) z = z + eivec ( i , k ) * h ( k , j ) enddo eivec ( i , l ) = y eivec ( i , j ) = z enddo else if ( wi ( j ) == ZERO ) then do i = low , high z = ZERO do k = low , m z = z + eivec ( i , k ) * h ( k , j ) enddo eivec ( i , j ) = z enddo endif endif j = j - 1 enddo !j loop rc = 0 end subroutine hqrvec subroutine hqr2 ( n , & !Dimension of matrix ......... low , & !first nonzero row ........... high , & !last nonzero row ............ h , & !Hessenberg matrix ........... wr , & !Real parts of eigenvalues ... wi , & !Imaginary parts of evalues .. eivec ,& !Matrix of eigenvectors ...... cnt , & !Iteration counter ........... rc ) !return code ................. !+Computes the eigenvalues and (if vec = True) the eigenvectors !+of an  n * n upper Hessenberg matrix. !+ !+###Input parameters !+   n     :  integer;  ( n > 0 ) !+            Dimension of  h and eivec, !+            length of the real parts vector  wr and of the !+            imaginary parts vector  wi of the eigenvalues. !+ !+   low   :  integer; !+ !+   high  :  integer;  see balance !+ !+   h     :  n x n matrix; !+            upper Hessenberg matrix as output of Elmhes !+            (destroyed in the process). !+###Output parameters !+   eivec :  n x n matrix;  (only if vec = 1) !+            Matrix, which for vec = 1 contains the !+            eigenvectors as follows: !+            For real eigebvalues the corresponding column !+            contains the corresponding eigenvactor, while for !+            complex eigenvalues the corresponding column contains !+            the real part of the eigenvactor with its imaginary !+            part is stored in the subsequent column of eivec. !+            The eigenvactor for the complex conjugate eigenvactor !+            is given by the complex conjugate eigenvactor. !+ !+   wr    :  vector of size n; !+            Real part of the n eigenvalues. !+ !+   wi    :  vector of size n; !+            Imaginary parts of the eigenvalues !+ !+   cnt   :  Integer vector of size n; !+            vector of iterations used for each eigenvalue. !+            For a complex conjugate eigenvalue pair the second !+            entry is negative. integer , intent ( in ) :: n integer , intent ( in ) :: high , low real ( double ) , intent ( out ) :: h ( 0 : n - 1 , 0 : n - 1 ) real ( double ), intent ( out ) :: wr ( 0 : n - 1 ), wi ( 0 : n - 1 ) real ( double ), intent ( out ) :: eivec ( 0 : n - 1 , 0 : n - 1 ) integer , intent ( out ) :: rc integer , intent ( out ) :: cnt ( 0 : n - 1 ) integer :: en integer :: i , j , na , iter , l , ll , m , k real ( double ) :: p , q , r , s , t , w , x , y , z real ( double ) :: r_p , r_r , r_s , r_x , r_z p = ZERO ; q = ZERO ; r = ZERO do i = 0 , n - 1 if ( i < low . or . i > high ) then wr ( i ) = h ( i , i ) wi ( i ) = ZERO cnt ( i ) = 0 endif enddo en = high t = ZERO do while ( en >= low ) iter = 0 na = en - 1 do while ( 1 < 2 ) ll = 999 do l = en , low + 1 , - 1 !search for small !subdiagonal element if ( DABS ( h ( l , l - 1 )) <= XMACH_EPS * ( DABS ( h ( l - 1 , l - 1 )) + DABS ( h ( l , l )))) then ll = l ; !save current index goto 10 !exit l loop endif enddo 10 if ( ll . ne . 999 ) then l = ll else l = 0 !restore l endif x = h ( en , en ) if ( l == en ) then !found one evalue wr ( en ) = x + t h ( en , en ) = x + t wi ( en ) = ZERO cnt ( en ) = iter en = en - 1 goto 15 !exit from loop while(True) endif y = h ( na , na ) w = h ( en , na ) * h ( na , en ) if ( l == na ) then !found two evalues p = ( y - x ) * 0.5d0 q = p * p + w z = DSQRT ( DABS ( q )) x = x + t h ( en , en ) = x + t h ( na , na ) = y + t cnt ( en ) = - iter cnt ( na ) = iter if ( q >= ZERO ) then !real eigenvalues if ( p < ZERO ) then z = p - z else z = p + z endif r_z = 1.0d0 / z wr ( na ) = x + z wr ( en ) = x - w * r_z s = w - w * r_z wi ( na ) = ZERO wi ( en ) = ZERO x = h ( en , na ) r = DSQRT ( x * x + z * z ) r_r = 1.0d0 / r p = x * r_r q = z * r_r do j = na , n - 1 z = h ( na , j ) h ( na , j ) = q * z + p * h ( en , j ) h ( en , j ) = q * h ( en , j ) - p * z enddo do i = 0 , en z = h ( i , na ) h ( i , na ) = q * z + p * h ( i , en ) h ( i , en ) = q * h ( i , en ) - p * z enddo do i = low , high z = eivec ( i , na ) eivec ( i , na ) = q * z + p * eivec ( i , en ) eivec ( i , en ) = q * eivec ( i , en ) - p * z enddo else !pair of complex wr ( na ) = x + p wr ( en ) = x + p wi ( na ) = z wi ( en ) = - z endif !if q>=ZERO en = en - 2 goto 15 !exit while(1<2) endif !if l = na if ( iter >= MAXIT ) then cnt ( en ) = MAXIT + 1 rc = en write ( * , * ) ' stop at iter >= MAXIT.' return endif if ( iter . ne . 0. and . MOD ( iter , 10 ) == 0 ) then t = t + x do i = low , en h ( i , i ) = h ( i , i ) - x enddo s = DABS ( h ( en , na )) + DABS ( h ( na , en - 2 )) x = 0.75d0 * s ; y = x w = - 0.4375d0 * s * s endif iter = iter + 1 do m = en - 2 , l , - 1 z = h ( m , m ) r = x - z s = y - z p = ( r * s - w ) / h ( m + 1 , m ) + h ( m , m + 1 ) q = h ( m + 1 , m + 1 ) - z - r - s r = h ( m + 2 , m + 1 ) s = DABS ( p ) + DABS ( q ) + DABS ( r ) r_s = 1.0d0 / s p = p * r_s q = q * r_s r = r * r_s if ( m == l ) goto 12 if ( DABS ( h ( m , m - 1 )) * ( DABS ( q ) + DABS ( r )) <= XMACH_EPS * DABS ( p ) & * ( DABS ( h ( m - 1 , m - 1 )) + DABS ( z ) + DABS ( h ( m + 1 , m + 1 )))) then goto 12 !exit m loop endif enddo 12 do i = m + 2 , en h ( i , i - 2 ) = ZERO enddo do i = m + 3 , en h ( i , i - 3 ) = ZERO enddo do k = m , na if ( k . ne . m ) then !double QR step, for rows l to en and columns m to en p = h ( k , k - 1 ) q = h ( k + 1 , k - 1 ) if ( k . ne . na ) then r = h ( k + 2 , k - 1 ) else r = ZERO endif x = DABS ( p ) + DABS ( q ) + DABS ( r ) if ( x == ZERO ) goto 30 !next k r_x = 1.0d0 / x p = p * r_x q = q * r_x r = r * r_x endif s = DSQRT ( p * p + q * q + r * r ) if ( p < ZERO ) s = - s r_s = 1.0d0 / s if ( k . ne . m ) then h ( k , k - 1 ) = - s * x else if ( l . ne . m ) then h ( k , k - 1 ) = - h ( k , k - 1 ) endif p = p + s r_p = 1.0d0 / p x = p * r_s y = q * r_s z = r * r_s q = q * r_p r = r * r_p do j = k , n - 1 !modify rows p = h ( k , j ) + q * h ( k + 1 , j ) if ( k . ne . na ) then p = p + r * h ( k + 2 , j ) h ( k + 2 , j ) = h ( k + 2 , j ) - p * z endif h ( k + 1 , j ) = h ( k + 1 , j ) - p * y h ( k , j ) = h ( k , j ) - p * x enddo if ( k + 3 < en ) then j = k + 3 else j = en endif do i = 0 , j !modify columns p = x * h ( i , k ) + y * h ( i , k + 1 ) if ( k . ne . na ) then p = p + z * h ( i , k + 2 ) h ( i , k + 2 ) = h ( i , k + 2 ) - p * r endif h ( i , k + 1 ) = h ( i , k + 1 ) - p * q h ( i , k ) = h ( i , k ) - p enddo do i = low , high p = x * eivec ( i , k ) + y * eivec ( i , k + 1 ) if ( k . ne . na ) then p = p + z * eivec ( i , k + 2 ) eivec ( i , k + 2 ) = eivec ( i , k + 2 ) - p * r endif eivec ( i , k + 1 ) = eivec ( i , k + 1 ) - p * q eivec ( i , k ) = eivec ( i , k ) - p enddo 30 continue enddo !k loop enddo !while(1<2) 15 continue enddo !while en >= low                         All evalues found !transform evectors back call hqrvec ( n , low , high , h , wr , wi , eivec , rc ) end subroutine hqr2 subroutine eigen ( n , matrix , eigvec , eigval ) !+The subroutine eigen  determines all eigenvalues and (if desired) !+all eigenvectors of a real square  n * n  matrix via the QR method !+in the version of Martin, Parlett, Peters, Reinsch and Wilkinson. !+ !+###Literature !+1. Peters, Wilkinson: Eigenvectors of real and complex !+   matrices by LR and QR triangularisations, !+   Num. Math. 16, p.184-204, (1970); [PETE70]; contribution !+   II/15, p. 372 - 395 in [WILK71]. !+2. Martin, Wilkinson: Similarity reductions of a general !+   matrix to Hessenberg form, Num. Math. 12, p. 349-368,(1968) !+   [MART 68]; contribution II,13, p. 339 - 358 in [WILK71]. !+3. Parlett, Reinsch: Balancing a matrix for calculations of !+   eigenvalues and eigenvectors, Num. Math. 13, p. 293-304, !+   (1969); [PARL69]; contribution II/11, p.315 - 326 in !+   [WILK71]. !+ !+###Input parameters !+   n     :  integer; ( n > 0 ) !+            size of matrix, number of eigenvalues !+ !+   mat   :  n x n matrix; !+            input matrix !+ !+###Output parameters !+   eivec :  n x n matrix;     (only if vec = 1) !+            matrix, if  vec = 1  that holds the eigenvectors !+            thus : !+            If the jth eigenvalue of the matrix is real then the !+            jth column is the corresponding real eigenvector; !+            if the jth eigenvalue is complex then the jth column !+            of eivec contains the real part of the eigenvector !+            while its imaginary part is in column j+1. !+            (the j+1st eigenvector is the complex conjugate !+            vector.) !+ !+   valre :  vector of size n; !+            Real parts of the eigenvalues. !+ !+   valim :  vector of size n; !+            Imaginary parts of the eigenvalues !+ !+   cnt   :  Integer vector of size n; !+            vector containing the number of iterations for each !+            eigenvalue. (for a complex conjugate pair the second !+            entry is negative). integer , intent ( in ) :: n ! nlevels real ( double ) , intent ( in ), dimension ( n , n ) :: matrix real ( double ) , intent ( out ), dimension ( n , n ) :: eigvec real ( double ) , intent ( out ), dimension ( n ) :: eigval real ( double ) :: mat ( 0 : n - 1 , 0 : n - 1 ) real ( double ) :: eivec ( 0 : n - 1 , 0 : n - 1 ) real ( double ) :: valre ( 0 : n - 1 ) !real parts of eigenvalues real ( double ) :: valim ( 0 : n - 1 ) !imaginary parts of eigenvalues integer :: rc !return code integer :: cnt ( 0 : n - 1 ) !Iteration counter integer :: high , low real ( double ) :: d ( 0 : n - 1 ), scale ( 0 : n - 1 ) integer :: perm ( 0 : n - 1 ) cnt = 0 ; d = 0.d0 mat ( 0 : n - 1 , 0 : n - 1 ) = matrix ( 1 : n , 1 : n ) !balance mat for nearly call balance ( n , mat , scale , low , high ) !equal row and column !reduce mat to upper call elmhes ( n , low , high , mat , perm ) !reduce mat to upper !Hessenberg form call elmtrans ( n , low , high , mat , perm , eivec ) !QR algorithm for eigenvalues and eigenvectors call hqr2 ( n , low , high , mat , valre , valim , eivec , cnt , rc ) !reverse balancing to determine eigenvectors call balback ( n , low , high , scale , eivec ) if ( rc . ne . 0 ) then print * , 'matrix = ' print * , matrix stop 'problem in eigen!' endif eigval ( 1 : n ) = valre ( 0 : n - 1 ) eigvec ( 1 : n , 1 : n ) = eivec ( 0 : n - 1 , 0 : n - 1 ) end subroutine eigen function outerprod ( a , b ) !+ Calculates outer product real ( double ), dimension (:), intent ( IN ) :: a , b real ( double ), dimension ( size ( a ), size ( b )) :: outerprod outerprod = spread ( a , dim = 2 , ncopies = size ( b )) * & spread ( b , dim = 1 , ncopies = size ( a )) end function outerprod subroutine swap ( a , b ) !+Swap arrays `a` and `b` real ( double ), dimension (:), intent ( INOUT ) :: a , b real ( double ), dimension ( size ( a )) :: dum dum = a a = b b = dum end subroutine swap subroutine ludcmp ( a , indx , d ) !+Calculates LU decomposition real ( double ), dimension (:,:), intent ( INOUT ) :: a integer , dimension (:), intent ( OUT ) :: indx real ( double ), intent ( OUT ) :: d real ( double ), dimension ( size ( a , 1 )) :: vv integer , dimension ( 1 ) :: imaxloc integer :: j , n , imax n = size ( indx ) d = 1.0 vv = maxval ( abs ( a ), dim = 2 ) if ( any ( vv . eq . 0. )) stop 'singular matrix in ludcmp' vv = 1.d0 / vv do j = 1 , n imaxloc = maxloc ( vv ( j : n ) * abs ( a ( j : n , j ))) imax = ( j - 1 ) + imaxloc ( 1 ) if ( j /= imax ) then call swap ( a ( imax ,:), a ( j ,:)) d =- d vv ( imax ) = vv ( j ) endif indx ( j ) = imax if ( a ( j , j ) == 0.0 ) a ( j , j ) = 1.0d-20 a ( j + 1 : n , j ) = a ( j + 1 : n , j ) / a ( j , j ) a ( j + 1 : n , j + 1 : n ) = a ( j + 1 : n , j + 1 : n ) - outerprod ( a ( j + 1 : n , j ), a ( j , j + 1 : n )) enddo end subroutine ludcmp subroutine lubksb ( a , indx , b ) !+ Does LU back substitution real ( double ), dimension (:,:), intent ( IN ) :: a integer , dimension (:), intent ( IN ) :: indx real ( double ), dimension (:), intent ( INOUT ) :: b integer :: i , n , ii , ll real ( double ) :: summ n = size ( indx ) ii = 0 do i = 1 , n ll = indx ( i ) summ = b ( ll ) b ( ll ) = b ( i ) if ( ii /= 0 ) then summ = summ - dot_product ( a ( i , ii : i - 1 ), b ( ii : i - 1 )) else if ( summ /= 0.0 ) then ii = i endif b ( i ) = summ enddo do i = n , 1 , - 1 b ( i ) = ( b ( i ) - dot_product ( a ( i , i + 1 : n ), b ( i + 1 : n ))) / a ( i , i ) enddo end subroutine lubksb subroutine matinv ( a , b ) !+ Matrix inversion with LU-decomposition !==================================================== real ( double ), dimension (:,:), intent ( IN ) :: a real ( double ), dimension (:,:), intent ( OUT ) :: b real ( double ), dimension ( size ( a , dim = 1 ), size ( a , dim = 2 )) :: ah , y integer :: i , N integer , dimension ( size ( a , dim = 1 )) :: indx real ( double ) :: d N = size ( a , dim = 1 ) if ( N /= size ( a , dim = 2 )) stop 'SUB matinv: ludcmp matrix must be square!' ah = a y = 0. do i = 1 , N y ( i , i ) = 1.d0 enddo call ludcmp ( ah , indx , d ) do i = 1 , N call lubksb ( ah , indx , y (:, i )) enddo b = y end subroutine matinv subroutine linsolve ( a , b , x ) !+ Solve linear equations A * X = B real ( double ), dimension (:,:), intent ( IN ) :: a ! assume a square real ( double ), dimension (:), intent ( IN ) :: b ! assume size(b) == size(a,1) real ( double ), dimension (:), intent ( OUT ) :: x ! assume size(x) == size(b) #ifdef _USE_BLAS real ( double ), dimension ( size ( b ), size ( b )) :: lu integer , dimension ( size ( b )) :: ipiv integer :: n , info n = size ( b ) ! first factorize a lu (:,:) = a (:,:) call DGETRF ( n , n , lu , n , ipiv , info ) if ( info /= 0 ) stop 'sub linsolve: DGETRF failed!' x (:) = b (:) call DGETRS ( 'N' , n , 1 , lu , n , ipiv , x , n , info ) if ( info /= 0 ) stop 'sub linsolve: DGETRS failed!' #else real ( double ), dimension ( size ( b ), size ( b )) :: a_inv call matinv ( a , a_inv ) x = matmul ( a_inv , b ) !coeffs determined from states at t=0 #endif end subroutine linsolve end module eigensystem","tags":"","loc":"sourcefile/eigensystem.f90.html","title":"eigensystem.f90 – FIDASIM"},{"text":"This file contains routines for parallel random number generation and a basic\nsparse array implementation This file depends on sourcefile~~utilities.f90~~EfferentGraph sourcefile~utilities.f90 utilities.f90 sourcefile~mpi_utils.f90 mpi_utils.f90 sourcefile~utilities.f90->sourcefile~mpi_utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~utilities.f90~~AfferentGraph sourcefile~utilities.f90 utilities.f90 sourcefile~fidasim.f90 fidasim.f90 sourcefile~fidasim.f90->sourcefile~utilities.f90 sourcefile~atomic_tables.f90 atomic_tables.f90 sourcefile~atomic_tables.f90->sourcefile~utilities.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules utilities Source Code utilities.f90 Source Code !+This file contains routines for parallel random number generation and a basic !+sparse array implementation module utilities !+ Utilities for parallel random number generation and sparse arrays #ifdef _OMP use omp_lib #endif use iso_c_binding implicit none private public :: ind2sub , sub2ind , time , cumsum public :: rng_type , rng_init , rng_seed , get_rng , rng , randind_cdf public :: rng_uniform , rng_normal , randu , randn , randind public :: SparseArray , get_value , sparse public :: deriv #ifdef _DEF_INTR public :: norm2 #endif integer , parameter :: Int32 = 4 integer , parameter :: Int64 = kind ( int8 ( 1 )) integer , parameter :: Float32 = kind ( 1.e0 ) integer , parameter :: Float64 = kind ( 1.d0 ) integer ( Int32 ), parameter :: IA = 16807 integer ( Int32 ), parameter :: IM = 2147483647 integer ( Int32 ), parameter :: IQ = 127773 integer ( Int32 ), parameter :: IR = 2836 integer , parameter :: ns = 2 type :: rng_type !+ Random Number Generator Derived Type integer ( Int32 ) :: seed integer ( Int32 ), dimension ( ns ) :: state end type rng_type type ( rng_type ), dimension (:), allocatable :: rng type SparseArray integer :: nnz = 0 !+ Number of non-zero elements integer :: nd = 0 !+ Number of dimensions integer , dimension (:), allocatable :: dims !+ Dimensions of array integer , dimension (:), allocatable :: inds !+ Linear index of non-zero elements real ( Float64 ), dimension (:), allocatable :: vals !+ Array values end type SparseArray interface randu module procedure randu_arr module procedure randu_r_arr end interface interface randn module procedure randn_arr module procedure randn_r_arr end interface interface randind_cdf !+ Procedure for generating a random array index/subscripts module procedure randind_r_cdf_1 module procedure randind_cdf_1 end interface interface randind !+ Procedure for generating a random array index/subscripts module procedure randind_n module procedure randind_w_1 module procedure randind_w_2 module procedure randind_w_3 module procedure randind_w_4 module procedure randind_w_5 module procedure randind_r_n module procedure randind_r_w_1 module procedure randind_r_w_2 module procedure randind_r_w_3 module procedure randind_r_w_4 module procedure randind_r_w_5 end interface interface search_sorted_first !+ Function for searching a sorted array module procedure search_sorted_first_integer module procedure search_sorted_first_float64 end interface interface sparse !+ Creates a sparse array from a dense array module procedure sparse_1 module procedure sparse_2 module procedure sparse_3 module procedure sparse_4 end interface interface deriv !+ Procedure for finding derivatives from an array module procedure deriv_1d module procedure deriv_2d module procedure deriv_3d end interface contains !============================================================================ !---------------------------Array Indexing Routines-------------------------- !============================================================================ subroutine ind2sub ( dims , ind , subs ) !+ Calculate the subscripts `subs` into an array with dimensions `dims` !+ given the corresponding linear index `ind` integer , dimension (:), intent ( in ) :: dims !+ Dimensions of array integer , intent ( in ) :: ind !+ Linear index integer , dimension (:), intent ( out ) :: subs !+ Subscripts corresponding to the linear index integer :: i , ndims , ind1 , ind2 ind1 = ind ndims = size ( dims ) do i = 1 , ndims - 1 ind2 = ( ind1 - 1 ) / dims ( i ) + 1 subs ( i ) = ind1 - dims ( i ) * ( ind2 - 1 ) ind1 = ind2 enddo subs ( ndims ) = ind1 end subroutine ind2sub function sub2ind ( dims , subs ) result ( ind ) !+ Calculates the linear index of an array with dimensions `dims` and !+ subcripts `subs` integer , dimension (:), intent ( in ) :: dims !+ Dimension of Array integer , dimension (:), intent ( in ) :: subs !+ Subscripts to convert integer :: ind !+ Linear index integer :: k , l , p ind = subs ( 1 ) do k = 2 , size ( dims ) p = dims ( 1 ) do l = 2 , k - 1 p = p * dims ( l ) enddo ind = ind + p * ( subs ( k ) - 1 ) enddo end function sub2ind !============================================================================ !-------------------------------Search Routines------------------------------ !============================================================================ function search_sorted_first_integer ( x , v ) result ( hi ) !+ Returns the index of the first value in `x` greater or equal to `v`. !+ Returns `length(x)+1` if `v` is greater then all values in `x`. integer , dimension (:), intent ( in ) :: x !+ Monotonically increasing array integer , intent ( in ) :: v !+ Value to search integer :: hi , lo , m lo = 0 hi = size ( x ) + 1 do while ( lo . lt .( hi - 1 )) m = rshift ( lo + hi , 1 ) if ( x ( m ). lt . v ) then lo = m else hi = m endif enddo end function search_sorted_first_integer function search_sorted_first_float64 ( x , v ) result ( hi ) !+ Returns the index of the first value in `x` greater or equal to `v`. !+ Returns `length(x)+1` if `v` is greater then all values in `x`. real ( Float64 ), dimension (:), intent ( in ) :: x !+ Monotonically increasing array real ( Float64 ), intent ( in ) :: v !+ Value to search integer :: hi , lo , m lo = 0 hi = size ( x ) + 1 do while ( lo . lt .( hi - 1 )) m = rshift ( lo + hi , 1 ) if ( x ( m ). lt . v ) then lo = m else hi = m endif enddo end function search_sorted_first_float64 !============================================================================ !-----------------------Parallel Random Number Routines---------------------- !============================================================================ function rng_seed () result ( seed ) !+ Generates random 32-bit integer seed from `/dev/urandom` integer ( Int32 ) :: seed !+ Seed value open ( 89 , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" ) read ( 89 ) seed close ( 89 ) seed = abs ( seed ) end function rng_seed subroutine rng_init ( self , seed ) #ifdef _MPI use mpi_utils #endif !+ Procedure to initialize a random number generator with a seed. !+ If seed is negative then random seed is used type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator integer ( Int32 ), intent ( in ) :: seed !+ Initial Seed Value integer ( Int32 ) :: s if ( seed . lt . 0 ) then s = rng_seed () else #ifdef _MPI s = seed + my_rank () #else s = seed #endif endif self % seed = s self % state ( 1 ) = ieor ( 777755555 , abs ( s )) self % state ( 2 ) = ior ( ieor ( 888889999 , abs ( s )), 1 ) end subroutine rng_init function get_rng () result ( r ) type ( rng_type ) :: r integer :: thread_id #ifdef _OMP thread_id = OMP_get_thread_num () + 1 #else thread_id = 1 #endif r = rng ( thread_id ) end function get_rng subroutine update_rng ( r ) type ( rng_type ), intent ( in ) :: r integer :: thread_id #ifdef _OMP thread_id = OMP_get_thread_num () + 1 #else thread_id = 1 #endif rng ( thread_id ) = r end subroutine update_rng function rng_uniform ( self ) result ( u ) !+ Generate a uniformally-distributed random number in the range [0,1) type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator real ( Float64 ) :: u !+ Uniform random deviate integer ( Int32 ) :: ix , iy , k real ( Float64 ) :: am ix = self % state ( 1 ) iy = self % state ( 2 ) ix = ieor ( ix , ishft ( ix , 13 )) ix = ieor ( ix , ishft ( ix , - 17 )) ix = ieor ( ix , ishft ( ix , 5 )) k = iy / IQ iy = IA * ( iy - k * IQ ) - IR * k if ( iy . lt . 0 ) iy = iy + IM self % state ( 1 ) = ix self % state ( 2 ) = iy am = nearest ( 1.0 , - 1.0 ) / IM u = am * ior ( iand ( IM , ieor ( ix , iy )), 1 ) end function rng_uniform function rng_normal ( self ) result ( n ) !+ Generate a normally-distributed random number with mean 0 and standard deviation 1 type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator real ( Float64 ) :: n !+ Normal random deviate real ( Float64 ), parameter :: s = 0.449871d0 real ( Float64 ), parameter :: t = 0.386595d0 real ( Float64 ), parameter :: a = 0.196000d0 real ( Float64 ), parameter :: b = 0.254720d0 real ( Float64 ), parameter :: r1 = 0.27597d0 real ( Float64 ), parameter :: r2 = 0.27846d0 real ( Float64 ) :: u , v , x , y , q do u = rng_uniform ( self ) v = rng_uniform ( self ) v = 1.7156d0 * ( v - 0.5d0 ) x = u - s y = abs ( v ) + t q = x ** 2 + y * ( a * y - b * x ) if ( q . lt . r1 ) exit if ( q . gt . r2 ) cycle if (( v ** 2 ). lt .( - 4.0 * log ( u ) * u ** 2 )) exit enddo n = v / u end function rng_normal subroutine randu_r_arr ( r , randomu ) !+ Generate an array of uniformally-distributed random deviates type ( rng_type ), intent ( inout ) :: r !+ Random Number Generator real ( Float64 ), dimension (:), intent ( out ) :: randomu !+ Array of uniform random deviates integer :: i randomu = 0.d0 do i = 1 , size ( randomu ) randomu ( i ) = rng_uniform ( r ) enddo end subroutine randu_r_arr subroutine randu_arr ( randomu ) !+ Generate an array of uniformally-distributed random deviates real ( Float64 ), dimension (:), intent ( out ) :: randomu !+ Array of uniform random deviates type ( rng_type ) :: r r = get_rng () call randu_r_arr ( r , randomu ) call update_rng ( r ) end subroutine randu_arr subroutine randn_r_arr ( r , randomn ) !+ Generate an array of normally-distributed random deviates type ( rng_type ), intent ( inout ) :: r !+ Random Number Generator real ( Float64 ), dimension (:), intent ( out ) :: randomn !+ Array of normal random deviates integer :: i randomn = 0.d0 do i = 1 , size ( randomn ) randomn ( i ) = rng_normal ( r ) enddo end subroutine randn_r_arr subroutine randn_arr ( randomn ) !+ Generate an array of normally-distributed random deviates real ( Float64 ), dimension (:), intent ( out ) :: randomn !+ Array of normal random deviates type ( rng_type ) :: r r = get_rng () call randn_r_arr ( r , randomn ) call update_rng ( r ) end subroutine randn_arr subroutine randind_r_n ( r , n , randomi ) !+ Generate a array of uniformally-distributed random integers in the range [1, n] type ( rng_type ), intent ( inout ) :: r !+ Random Number Generator integer , intent ( in ) :: n !+ Largest possible value integer , dimension (:), intent ( out ) :: randomi !+ Array of uniform deviates integer :: i real ( Float64 ), dimension ( 1 ) :: randomu randomi = 0 do i = 1 , size ( randomi ) call randu_r_arr ( r , randomu ) randomi ( i ) = ceiling ( randomu ( 1 ) * n ) enddo end subroutine randind_r_n subroutine randind_n ( n , randomi ) !+ Generate a array of uniformally-distributed random integers in the range [1, n] integer , intent ( in ) :: n !+ Largest possible value integer , dimension (:), intent ( out ) :: randomi !+ Array of uniform deviates type ( rng_type ) :: r r = get_rng () call randind_r_n ( r , n , randomi ) call update_rng ( r ) end subroutine randind_n subroutine randind_r_cdf_1 ( r , cdf , randomi ) !+ Generate an array of random indices of an 1D array distributed according to `cdf` type ( rng_type ), intent ( inout ) :: r !+ Random Number Generator real ( Float64 ), dimension (:), intent ( in ) :: cdf !+ 1D array of index weights integer , dimension (:), intent ( out ) :: randomi !+ Random indices integer :: i , n real ( Float64 ) :: cdf_val real ( Float64 ), dimension ( 1 ) :: randomu n = size ( cdf ) randomi = 0 do i = 1 , size ( randomi ) call randu_r_arr ( r , randomu ) cdf_val = randomu ( 1 ) * cdf ( n ) randomi ( i ) = min ( search_sorted_first ( cdf , cdf_val ), n ) enddo end subroutine randind_r_cdf_1 subroutine randind_cdf_1 ( cdf , randomi ) !+ Generate an array of random indices of an 1D array distributed according to `cdf` real ( Float64 ), dimension (:), intent ( in ) :: cdf !+ 1D array of index weights integer , dimension (:), intent ( out ) :: randomi !+ Random indices type ( rng_type ) :: r r = get_rng () call randind_r_cdf_1 ( r , cdf , randomi ) call update_rng ( r ) end subroutine randind_cdf_1 subroutine cumsum ( x , cs ) !+ Calculate cumulative sum real ( Float64 ), dimension (:), intent ( in ) :: x !+ Array to sum real ( Float64 ), dimension (:), intent ( out ) :: cs !+ Cumulative sum of `x` integer :: i , n real ( Float64 ) :: cdf_val , t n = size ( x ) t = 0.d0 do i = 1 , n cs ( i ) = t + x ( i ) t = cs ( i ) enddo end subroutine cumsum subroutine randind_r_w_1 ( r , w , randomi ) !+ Generate an array of random indices of an 1D array distributed according to `w` type ( rng_type ), intent ( inout ) :: r !+ Random Number Generator real ( Float64 ), dimension (:), intent ( in ) :: w !+ 1D array of index weights integer , dimension (:), intent ( out ) :: randomi !+ Random indices real ( Float64 ), dimension ( size ( w )) :: cdf call cumsum ( w , cdf ) call randind_r_cdf_1 ( r , cdf , randomi ) end subroutine randind_r_w_1 subroutine randind_w_1 ( w , randomi ) !+ Generate an array of random indices of an 1D array distributed according to `w` real ( Float64 ), dimension (:), intent ( in ) :: w !+ 1D array of index weights integer , dimension (:), intent ( out ) :: randomi !+ Random indices type ( rng_type ) :: r r = get_rng () call randind_r_w_1 ( r , w , randomi ) call update_rng ( r ) end subroutine randind_w_1 subroutine randind_r_w_2 ( r , w , randomi ) !+ Generate an array of random subscripts of an 2D array distributed according to `w` type ( rng_type ), intent ( inout ) :: r !+ Random Number Generator real ( Float64 ), dimension (:,:), target , intent ( in ) :: w !+ 2D array of subscript weights integer , dimension (:,:), intent ( out ) :: randomi !+ A 2D (ndim, :) array of random subscripts integer :: i , nw integer , dimension ( 2 ) :: subs integer , dimension ( size ( randomi , 2 )) :: randi real ( Float64 ), pointer :: w_ptr (:) randomi = 0 nw = size ( w ) call c_f_pointer ( c_loc ( w ), w_ptr , [ nw ]) call randind_r_w_1 ( r , w_ptr , randi ) do i = 1 , size ( randomi , 2 ) call ind2sub ( shape ( w ), randi ( i ), subs ) randomi (:, i ) = subs enddo end subroutine randind_r_w_2 subroutine randind_w_2 ( w , randomi ) !+ Generate an array of random subscripts of an 2D array distributed according to `w` real ( Float64 ), dimension (:,:), intent ( in ) :: w !+ 2D array of subscript weights integer , dimension (:,:), intent ( out ) :: randomi !+ A 2D (ndim, :) array of random subscripts type ( rng_type ) :: r r = get_rng () call randind_r_w_2 ( r , w , randomi ) call update_rng ( r ) end subroutine randind_w_2 subroutine randind_r_w_3 ( r , w , randomi ) !+ Generate an array of random subscripts of an 3D array distributed according to `w` type ( rng_type ), intent ( inout ) :: r !+ Random Number Generator real ( Float64 ), dimension (:,:,:), target , intent ( in ) :: w !+ 3D array of subscript weights integer , dimension (:,:), intent ( out ) :: randomi !+ A 2D (ndim, :) array of random subscripts integer :: i , nw integer , dimension ( 3 ) :: subs integer , dimension ( size ( randomi , 2 )) :: randi real ( Float64 ), pointer :: w_ptr (:) randomi = 0 nw = size ( w ) call c_f_pointer ( c_loc ( w ), w_ptr , [ nw ]) call randind_r_w_1 ( r , w_ptr , randi ) do i = 1 , size ( randomi , 2 ) call ind2sub ( shape ( w ), randi ( i ), subs ) randomi (:, i ) = subs enddo end subroutine randind_r_w_3 subroutine randind_w_3 ( w , randomi ) !+ Generate an array of random subscripts of an 3D array distributed according to `w` real ( Float64 ), dimension (:,:,:), intent ( in ) :: w !+ 3D array of subscript weights integer , dimension (:,:), intent ( out ) :: randomi !+ A 2D (ndim, :) array of random subscripts type ( rng_type ) :: r r = get_rng () call randind_r_w_3 ( r , w , randomi ) call update_rng ( r ) end subroutine randind_w_3 subroutine randind_r_w_4 ( r , w , randomi ) !+ Generate an array of random subscripts of an 4D array distributed according to `w` type ( rng_type ), intent ( inout ) :: r !+ Random Number Generator real ( Float64 ), dimension (:,:,:,:), target , intent ( in ) :: w !+ 4D array of subscript weights integer , dimension (:,:), intent ( out ) :: randomi !+ A 2D (ndim, :) array of random subscripts integer :: i , nw integer , dimension ( 4 ) :: subs integer , dimension ( size ( randomi , 2 )) :: randi real ( Float64 ), pointer :: w_ptr (:) randomi = 0 nw = size ( w ) call c_f_pointer ( c_loc ( w ), w_ptr , [ nw ]) call randind_r_w_1 ( r , w_ptr , randi ) do i = 1 , size ( randomi , 2 ) call ind2sub ( shape ( w ), randi ( i ), subs ) randomi (:, i ) = subs enddo end subroutine randind_r_w_4 subroutine randind_w_4 ( w , randomi ) !+ Generate an array of random subscripts of an 4D array distributed according to `w` real ( Float64 ), dimension (:,:,:,:), intent ( in ) :: w !+ 4D array of subscript weights integer , dimension (:,:), intent ( out ) :: randomi !+ A 2D (ndim, :) array of random subscripts type ( rng_type ) :: r r = get_rng () call randind_r_w_4 ( r , w , randomi ) call update_rng ( r ) end subroutine randind_w_4 subroutine randind_r_w_5 ( r , w , randomi ) !+ Generate an array of random subscripts of an 5D array distributed according to `w` type ( rng_type ), intent ( inout ) :: r !+ Random Number Generator real ( Float64 ), dimension (:,:,:,:,:), target , intent ( in ) :: w !+ 5D array of subscript weights integer , dimension (:,:), intent ( out ) :: randomi !+ A 2D (ndim, :) array of random subscripts integer :: i , nw integer , dimension ( 5 ) :: subs integer , dimension ( size ( randomi , 2 )) :: randi real ( Float64 ), pointer :: w_ptr (:) randomi = 0 nw = size ( w ) call c_f_pointer ( c_loc ( w ), w_ptr , [ nw ]) call randind_r_w_1 ( r , w_ptr , randi ) do i = 1 , size ( randomi , 2 ) call ind2sub ( shape ( w ), randi ( i ), subs ) randomi (:, i ) = subs enddo end subroutine randind_r_w_5 subroutine randind_w_5 ( w , randomi ) !+ Generate an array of random subscripts of an 5D array distributed according to `w` real ( Float64 ), dimension (:,:,:,:,:), intent ( in ) :: w !+ 5D array of subscript weights integer , dimension (:,:), intent ( out ) :: randomi !+ A 2D (ndim, :) array of random subscripts type ( rng_type ) :: r r = get_rng () call randind_r_w_5 ( r , w , randomi ) call update_rng ( r ) end subroutine randind_w_5 !============================================================================ !------------------------------Sparse Routines------------------------------- !============================================================================ subroutine sparse_1 ( A , SA ) !+ Routine to create a 1D sparse array from a 1D dense array real ( Float64 ), dimension (:), intent ( in ) :: A !+ Dense Array type ( SparseArray ), intent ( out ) :: SA !+ Sparse Array integer :: n , i , c SA % nd = 1 allocate ( SA % dims ( SA % nd )) SA % dims = shape ( A ) SA % nnz = count ( A . ne . 0.d0 ) if ( SA % nnz . eq . 0 ) return allocate ( SA % vals ( SA % nnz ), SA % inds ( SA % nnz )) n = size ( A ) c = 1 do i = 1 , n if ( A ( i ). ne . 0.d0 ) then SA % inds ( c ) = i SA % vals ( c ) = A ( i ) c = c + 1 endif if ( c . gt . SA % nnz ) exit enddo end subroutine sparse_1 subroutine sparse_2 ( A , SA ) !+ Routine to create a 2D sparse array from a 2D dense array real ( Float64 ), dimension (:,:), intent ( in ) :: A !+ Dense Array type ( SparseArray ), intent ( out ) :: SA !+ Sparse Array integer :: subs ( 2 ) integer :: n , i , c SA % nd = 2 allocate ( SA % dims ( SA % nd )) SA % dims = shape ( A ) SA % nnz = count ( A . ne . 0.d0 ) if ( SA % nnz . eq . 0 ) return allocate ( SA % vals ( SA % nnz ), SA % inds ( SA % nnz )) n = size ( A ) c = 1 do i = 1 , n call ind2sub ( SA % dims , i , subs ) if ( A ( subs ( 1 ), subs ( 2 )). ne . 0.d0 ) then SA % inds ( c ) = i SA % vals ( c ) = A ( subs ( 1 ), subs ( 2 )) c = c + 1 endif if ( c . gt . SA % nnz ) exit enddo end subroutine sparse_2 subroutine sparse_3 ( A , SA ) !+ Routine to create a 3D sparse array from a 3D dense array real ( Float64 ), dimension (:,:,:), intent ( in ) :: A !+ Dense Array type ( SparseArray ), intent ( out ) :: SA !+ Sparse Array integer :: subs ( 3 ) integer :: n , i , c SA % nd = 3 allocate ( SA % dims ( SA % nd )) SA % dims = shape ( A ) SA % nnz = count ( A . ne . 0.d0 ) if ( SA % nnz . eq . 0 ) return allocate ( SA % vals ( SA % nnz ), SA % inds ( SA % nnz )) n = size ( A ) c = 1 do i = 1 , n call ind2sub ( SA % dims , i , subs ) if ( A ( subs ( 1 ), subs ( 2 ), subs ( 3 )). ne . 0.d0 ) then SA % inds ( c ) = i SA % vals ( c ) = A ( subs ( 1 ), subs ( 2 ), subs ( 3 )) c = c + 1 endif if ( c . gt . SA % nnz ) exit enddo end subroutine sparse_3 subroutine sparse_4 ( A , SA ) !+ Routine to create a 4D sparse array from a 4D dense array real ( Float64 ), dimension (:,:,:,:), intent ( in ) :: A !+ Dense Array type ( SparseArray ), intent ( out ) :: SA !+ Sparse Array integer :: subs ( 4 ) integer :: n , i , c SA % nd = 4 allocate ( SA % dims ( SA % nd )) SA % dims = shape ( A ) SA % nnz = count ( A . ne . 0.d0 ) if ( SA % nnz . eq . 0 ) return allocate ( SA % vals ( SA % nnz ), SA % inds ( SA % nnz )) n = size ( A ) c = 1 do i = 1 , n call ind2sub ( SA % dims , i , subs ) if ( A ( subs ( 1 ), subs ( 2 ), subs ( 3 ), subs ( 4 )). ne . 0.d0 ) then SA % inds ( c ) = i SA % vals ( c ) = A ( subs ( 1 ), subs ( 2 ), subs ( 3 ), subs ( 4 )) c = c + 1 endif if ( c . gt . SA % nnz ) exit enddo end subroutine sparse_4 function get_value ( SA , subs ) result ( val ) !+ Gets value of sparse array `SA` at the subscripts `subs` type ( SparseArray ), intent ( in ) :: SA !+ Sparse Array integer , dimension (:), intent ( in ) :: subs !+ Subscripts of Sparse Array real ( Float64 ) :: val !+ Value of `SA` at `subs` integer :: ind , cind val = 0.d0 if ( SA % nnz . eq . 0 ) return ind = sub2ind ( SA % dims , subs ) cind = search_sorted_first ( SA % inds , ind ) if ( ind . eq . SA % inds ( cind )) then val = SA % vals ( cind ) endif end function get_value !============================================================================ !--------------------------------Deriv Routines------------------------------ !============================================================================ subroutine deriv_1d ( x , y , yp ) !+ Uses 3 point lagrangian method to calculate the derivative of an array real ( Float64 ), dimension (:), intent ( in ) :: x !+ X Values real ( Float64 ), dimension (:), intent ( in ) :: y !+ Y Values real ( Float64 ), dimension (:), intent ( out ) :: yp !+ Derivative of Y w.r.t. X integer :: i , n !! temporary values for loops real ( Float64 ) :: p1 , p2 , p3 !! intermeadiate values for 3 point lagrangian n = size ( x ) - 1 do i = 2 , n p1 = x ( i - 1 ) p2 = x ( i ) p3 = x ( i + 1 ) yp ( i ) = ( y ( i - 1 ) * ( p2 - p3 ) / (( p1 - p2 ) * ( p1 - p3 ))) + & ( y ( i ) * (( 1 / ( p2 - p3 )) - ( 1 / ( p1 - p2 )))) - & ( y ( i + 1 ) * ( p1 - p2 ) / (( p1 - p3 ) * ( p2 - p3 ))) enddo yp ( 1 ) = ( y ( 1 ) * (( x ( 1 ) - x ( 2 )) + ( x ( 1 ) - x ( 3 ))) / (( x ( 1 ) - x ( 2 )) * ( x ( 1 ) - x ( 3 )))) - & ( y ( 2 ) * ( x ( 1 ) - x ( 3 )) / (( x ( 1 ) - x ( 2 )) * ( x ( 2 ) - x ( 3 )))) + & ( y ( 3 ) * ( x ( 1 ) - x ( 2 )) / (( x ( 1 ) - x ( 3 )) * ( x ( 2 ) - x ( 3 )))) yp ( n + 1 ) = - ( y ( n - 1 ) * ( x ( n ) - x ( n + 1 )) / (( x ( n - 1 ) - x ( n )) * ( x ( n - 1 ) - x ( n + 1 )))) + & ( y ( n ) * ( x ( n - 1 ) - x ( n + 1 )) / (( x ( n - 1 ) - x ( n )) * ( x ( n ) - x ( n + 1 )))) - & ( y ( n + 1 ) * (( x ( n - 1 ) - x ( n + 1 )) + ( x ( n ) - x ( n + 1 ))) / (( x ( n - 1 ) - x ( n + 1 )) * & ( x ( n ) - x ( n + 1 )))) end subroutine deriv_1d subroutine deriv_2d ( x , y , z , zxp , zyp ) !+ Uses 3 point lagrangian method to calculate the partial derivative !+ of an array Z w.r.t X and Y real ( Float64 ), dimension (:), intent ( in ) :: x !+ X Values real ( Float64 ), dimension (:), intent ( in ) :: y !+ Y Values real ( Float64 ), dimension (:,:), intent ( in ) :: z !+ Z Values real ( Float64 ), dimension (:,:), intent ( out ) :: zxp !+ Derivative of Z w.r.t. X real ( Float64 ), dimension (:,:), intent ( out ) :: zyp !+ Derivative of Z w.r.t. Y integer :: i , n !! temporary values for loops n = size ( y ) do i = 1 , n call deriv_1d ( x , z (:, i ), zxp (:, i )) enddo n = size ( x ) do i = 1 , n call deriv_1d ( y , z ( i ,:), zyp ( i ,:)) enddo end subroutine deriv_2d subroutine deriv_3d ( r , z , phi , f , frp , fzp , fphip ) !+ Uses 3 point lagrangian method to calculate the partial derivative !+ of an array F w.r.t R, Z and Phi real ( Float64 ), dimension (:), intent ( in ) :: r !+ R Values real ( Float64 ), dimension (:), intent ( in ) :: z !+ Z Values real ( Float64 ), dimension (:), intent ( in ) :: phi !+ Phi Values real ( Float64 ), dimension (:,:,:), intent ( in ) :: f !+ F Values real ( Float64 ), dimension (:,:,:), intent ( out ) :: frp !+ Derivative of F w.r.t. R real ( Float64 ), dimension (:,:,:), intent ( out ) :: fzp !+ Derivative of F w.r.t. Z real ( Float64 ), dimension (:,:,:), intent ( out ) :: fphip !+ Derivative of F w.r.t. Phi integer :: i , n !! temporary values for loops if ( size ( phi ) . gt . 1 ) then n = size ( phi ) do i = 1 , n call deriv_2d ( r , z , f (:,:, i ), frp (:,:, i ), fzp (:,:, i )) enddo n = size ( z ) do i = 1 , n call deriv_2d ( r , phi , f (:, i ,:), frp (:, i ,:), fphip (:, i ,:)) enddo n = size ( r ) do i = 1 , n call deriv_2d ( z , phi , f ( i ,:,:), fzp ( i ,:,:), fphip ( i ,:,:)) enddo else fphip = 0.0d0 call deriv_2d ( r , z , f (:,:, 1 ), frp (:,:, 1 ), fzp (:,:, 1 )) endif end subroutine deriv_3d !============================================================================ !------------------------------ Misc. Routines ------------------------------ !============================================================================ function time ( time_start ) result ( time_str ) !+ Returns time string integer , dimension ( 8 ), intent ( in ), optional :: time_start !+ Optional start time character ( 30 ) :: time_str !+ Time string integer :: ts ( 8 ), ta ( 8 ), hour , minu , sec ts = 0 if ( present ( time_start )) then ts = time_start endif call date_and_time ( values = ta ) hour = ta ( 5 ) - ts ( 5 ) minu = ta ( 6 ) - ts ( 6 ) sec = ta ( 7 ) - ts ( 7 ) if ( minu . lt . 0. ) then minu = minu + 60 hour = hour - 1 endif if ( sec . lt . 0. ) then sec = sec + 60 minu = minu - 1 endif if ( present ( time_start )) then write ( time_str , '(I2,\":\",I2.2,\":\",I2.2,\" --- elapsed:\",I2,\":\",I2.2,\":\",I2.2)' ) & ta ( 5 ), ta ( 6 ), ta ( 7 ), hour , minu , sec else write ( time_str , '(I2,\":\",I2.2,\":\",I2.2)' ) & ta ( 5 ), ta ( 6 ), ta ( 7 ) endif end function time #ifdef _DEF_INTR ! define missing intrinsics function norm2 ( in ) result ( res ) implicit none real ( Float64 ), dimension (:) :: in real ( Float64 ) :: res res = sqrt ( sum ( in (:) ** 2 )) end function norm2 #endif end module utilities","tags":"","loc":"sourcefile/utilities.f90.html","title":"utilities.f90 – FIDASIM"},{"text":"This file contains HDF5 helper routines for writing compressed data files Files dependent on this one sourcefile~~hdf5_utils.f90~~AfferentGraph sourcefile~hdf5_utils.f90 hdf5_utils.f90 sourcefile~fidasim.f90 fidasim.f90 sourcefile~fidasim.f90->sourcefile~hdf5_utils.f90 sourcefile~atomic_tables.f90 atomic_tables.f90 sourcefile~atomic_tables.f90->sourcefile~hdf5_utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules hdf5_utils Source Code hdf5_utils.f90 Source Code !+This file contains HDF5 helper routines for writing compressed data files MODULE hdf5_utils !+ A library for writing compressed HDF5 files USE H5LT USE HDF5 IMPLICIT NONE public :: h5ltmake_compressed_dataset_double_f public :: h5ltmake_compressed_dataset_double_f_1 public :: h5ltmake_compressed_dataset_double_f_2 public :: h5ltmake_compressed_dataset_double_f_3 public :: h5ltmake_compressed_dataset_double_f_4 public :: h5ltmake_compressed_dataset_double_f_5 public :: h5ltmake_compressed_dataset_double_f_6 public :: h5ltmake_compressed_dataset_double_f_7 public :: h5ltmake_compressed_dataset_int_f public :: h5ltmake_compressed_dataset_int_f_1 public :: h5ltmake_compressed_dataset_int_f_2 public :: h5ltmake_compressed_dataset_int_f_3 public :: h5ltmake_compressed_dataset_int_f_4 public :: h5ltmake_compressed_dataset_int_f_5 public :: h5ltmake_compressed_dataset_int_f_6 public :: h5ltmake_compressed_dataset_int_f_7 public :: h5ltread_dataset_int_scalar_f public :: h5ltread_dataset_double_scalar_f public :: check_compression_availability integer , parameter , private :: Int32 = 4 !bytes = 32 bits (-2,147,483,648 to 2,147,483,647) integer , parameter , private :: Int64 = 8 !bytes = 64 bits (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807) integer , parameter , private :: Float32 = 4 !bytes = 32 bits (1.2E-38 to 3.4E+38) at 6 decimal places integer , parameter , private :: Float64 = 8 !bytes = 64 bits (2.3E-308 to 1.7E+308) at 15 decimal places logical , private :: compress_data = . True . interface h5ltmake_compressed_dataset_double_f !+ Write a compressed datasets of 64-bit floats module procedure h5ltmake_compressed_dataset_double_f_1 module procedure h5ltmake_compressed_dataset_double_f_2 module procedure h5ltmake_compressed_dataset_double_f_3 module procedure h5ltmake_compressed_dataset_double_f_4 module procedure h5ltmake_compressed_dataset_double_f_5 module procedure h5ltmake_compressed_dataset_double_f_6 module procedure h5ltmake_compressed_dataset_double_f_7 end interface interface h5ltmake_compressed_dataset_int_f !+ Write a compressed dataset of 32-bit integers module procedure h5ltmake_compressed_dataset_int_f_1 module procedure h5ltmake_compressed_dataset_int_f_2 module procedure h5ltmake_compressed_dataset_int_f_3 module procedure h5ltmake_compressed_dataset_int_f_4 module procedure h5ltmake_compressed_dataset_int_f_5 module procedure h5ltmake_compressed_dataset_int_f_6 module procedure h5ltmake_compressed_dataset_int_f_7 end interface contains subroutine check_compression_availability !+ Checks whether dataset compression is available IMPLICIT NONE logical :: shuffle_avail , gzip_avail integer :: gzip_info , shuf_info , filter_info_both integer :: error call h5open_f ( error ) filter_info_both = ior ( H5Z_FILTER_ENCODE_ENABLED_F , H5Z_FILTER_DECODE_ENABLED_F ) !! Check for GZIP filter call h5zfilter_avail_f ( H5Z_FILTER_DEFLATE_F , gzip_avail , error ) call h5zget_filter_info_f ( H5Z_FILTER_DEFLATE_F , gzip_info , error ) if (. not . gzip_avail ) then print * , 'HDF5: gzip filter is not available' compress_data = . False . endif if ( filter_info_both . ne . gzip_info ) then print * , 'HDF5: gzip filter is not available for encoding and decoding' compress_data = . False . endif !! Check for SHUFFLE filter call h5zfilter_avail_f ( H5Z_FILTER_SHUFFLE_F , shuffle_avail , error ) call h5zget_filter_info_f ( H5Z_FILTER_SHUFFLE_F , shuf_info , error ) if (. not . shuffle_avail ) then print * , 'HDF5: shuffle filter is not available' compress_data = . False . endif if ( filter_info_both . ne . shuf_info ) then print * , 'HDF5: shuffle filter is not available for encoding and decoding' compress_data = . False . endif if (. not . compress_data ) then print * , 'HDF5: Compression is not available. Proceeding without compression.' endif call h5close_f ( error ) end subroutine check_compression_availability subroutine h5ltread_dataset_int_scalar_f ( loc_id , dset_name , x , error ) !+ Write a scalar 32-bit integer IMPLICIT NONE integer ( HID_T ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( inout ) :: x !+ Data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HSIZE_T ), dimension ( 1 ) :: dims ( 1 ) = 1 integer , dimension ( 1 ) :: dummy call h5ltread_dataset_int_f ( loc_id , dset_name , dummy , dims , error ) x = dummy ( 1 ) end subroutine h5ltread_dataset_int_scalar_f subroutine h5ltread_dataset_double_scalar_f ( loc_id , dset_name , x , error ) !+ Write a scalar 64-bit float IMPLICIT NONE integer ( HID_T ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create real ( Float64 ), intent ( inout ) :: x !+ Data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HSIZE_T ), dimension ( 1 ) :: dims ( 1 ) = 1 real ( Float64 ), dimension ( 1 ) :: dummy call h5ltread_dataset_double_f ( loc_id , dset_name , dummy , dims , error ) x = dummy ( 1 ) end subroutine h5ltread_dataset_double_scalar_f subroutine chunk_size ( elsize , dims , cdims ) integer , intent ( in ) :: elsize !+ Size of elements in bytes integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Dimensions of dataset integer ( HSIZE_T ), dimension (:), intent ( out ) :: cdims !+ Maximum allowed chunk size/dims real , parameter :: max_bytes = 4 * 1e9 !GigaBytes integer :: d real ( Float64 ) :: nbytes d = size ( cdims ) cdims ( 1 : d ) = dims ( 1 : d ) nbytes = elsize * product ( 1.d0 * cdims ) do while (( nbytes . gt . max_bytes ). and .( d . gt . 0 )) cdims ( d ) = max ( floor ( cdims ( d ) * max_bytes / nbytes , Int32 ), 1 ) nbytes = elsize * product ( 1.d0 * cdims ) d = d - 1 enddo end subroutine chunk_size !Compressed Doubles subroutine h5ltmake_compressed_dataset_double_f_1 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 1 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( Float64 ), dimension ( dims ( 1 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 1 ) if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Float64 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_1 subroutine h5ltmake_compressed_dataset_double_f_2 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 2 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( Float64 ), dimension ( dims ( 1 ), dims ( 2 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 2 ) if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Float64 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_2 subroutine h5ltmake_compressed_dataset_double_f_3 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 3 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( Float64 ), dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 3 ) if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Float64 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_3 subroutine h5ltmake_compressed_dataset_double_f_4 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 4 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( Float64 ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 4 ) if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Float64 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_4 subroutine h5ltmake_compressed_dataset_double_f_5 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 5 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( Float64 ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 5 ) if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Float64 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_5 subroutine h5ltmake_compressed_dataset_double_f_6 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 6 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( Float64 ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 6 ) if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Float64 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_6 subroutine h5ltmake_compressed_dataset_double_f_7 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 7 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( Float64 ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 ), dims ( 7 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 7 ) if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Float64 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_7 !Compressed Integers subroutine h5ltmake_compressed_dataset_int_f_1 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 1 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 1 ) if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Int32 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_1 subroutine h5ltmake_compressed_dataset_int_f_2 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 2 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 2 ) if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Int32 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_2 subroutine h5ltmake_compressed_dataset_int_f_3 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 3 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 3 ) if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Int32 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_3 subroutine h5ltmake_compressed_dataset_int_f_4 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 4 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 4 ) if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Int32 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_4 subroutine h5ltmake_compressed_dataset_int_f_5 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 5 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 5 ) if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Int32 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_5 subroutine h5ltmake_compressed_dataset_int_f_6 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 6 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 6 ) if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Int32 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_6 subroutine h5ltmake_compressed_dataset_int_f_7 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 7 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 ), dims ( 7 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 7 ) if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Int32 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_7 END MODULE hdf5_utils","tags":"","loc":"sourcefile/hdf5_utils.f90.html","title":"hdf5_utils.f90 – FIDASIM"},{"text":"This file contains the routines for calculating atomic cross sections and reaction rates for FIDASIM This file depends on sourcefile~~atomic_tables.f90~~EfferentGraph sourcefile~atomic_tables.f90 atomic_tables.f90 sourcefile~utilities.f90 utilities.f90 sourcefile~atomic_tables.f90->sourcefile~utilities.f90 sourcefile~hdf5_utils.f90 hdf5_utils.f90 sourcefile~atomic_tables.f90->sourcefile~hdf5_utils.f90 sourcefile~mpi_utils.f90 mpi_utils.f90 sourcefile~atomic_tables.f90->sourcefile~mpi_utils.f90 sourcefile~utilities.f90->sourcefile~mpi_utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs generate_tables Modules atomic_tables Source Code atomic_tables.f90 Source Code !+This file contains the routines for calculating atomic cross sections and reaction rates for FIDASIM module atomic_tables !+Library for calculating atomic cross sections and reaction rate coefficients for Hydrogen interactions !+ !+###References !+ !+1. [W.L. Wiese, M.W. Smith, and B.M. Glennon. *Atomic Transition Probabilities. Volume 1. Hydrogen through Neon*. !+National Bureau of Standards Washington DC Institute for Basic Standards, 1966.](http://www.dtic.mil/dtic/tr/fulltext/u2/634145.pdf) !+2. [R.K. Janev, D. Reiter, and  U. Samm. *Collision processes in low-temperature hydrogen plasmas*. !+Forschungszentrum Jülich, Zentralbibliothek, 2003.](http://www.eirene.de/report_4105.pdf) !+3. [M. O'Mullane. *Review of proton impact driven ionisation from the excited levels in neutral hydrogen beams*. !+ADAS note, 2009.](http://www.adas.ac.uk/notes/adas_c09-01.pdf) !+4. [ADAS: Atomic Data and Analysis Structure](http://www.adas.ac.uk/) !+5. [R.K. Janev and J.J. Smith. *Cross sections for collision processes of hydrogen atoms !+with electrons, protons and multiply charged ions.* Atomic and Plasma-Material Interaction Data for Fusion: !+Volume 4, 1993.](http://www-pub.iaea.org/books/IAEABooks/1839/Atomic-and-Plasma-Material-Interaction-Data-for-Fusion) !+6. [Reinhold, C. O., R. E. Olson, and W. Fritsch. *Excitation of atomic hydrogen by fully stripped ions.* !+Physical Review A 41.9 1990.](http://journals.aps.org/pra/abstract/10.1103/PhysRevA.41.4837) !+7. [Bosch, H-S., and G. M. Hale. *Improved formulas for fusion cross-sections and thermal reactivities.* !+ Nuclear fusion 32.4 1992.](http://iopscience.iop.org/article/10.1088/0029-5515/32/4/I07/meta) !+8. [Aladdin Database: R.K. Janev, W.D. Langer, K. Evans Jr., D.E. Post Jr. H-HE-PLASMA (1987)](https://www-amdis.iaea.org/ALADDIN/collision.html) use H5LT use HDF5 use hdf5_utils #ifdef _MPI use mpi_utils #endif IMPLICIT NONE interface bt_maxwellian !+Calculates the reaction rate coefficients given beam energy `eb` and target temperature `T` !+where the velocity distribution of the target is a Maxwellian module procedure bt_maxwellian_eb module procedure bt_maxwellian_n , bt_maxwellian_n_m module procedure bt_maxwellian_q_n , bt_maxwellian_q_n_m end interface integer , parameter , private :: Int32 = 4 !+ Defines a 32 bit integer integer , parameter , private :: Int64 = 8 !+ Defines a 64 bit integer integer , parameter , private :: Float32 = 4 !+ Defines a 32 bit floating point real integer , parameter , private :: Float64 = 8 !+ Defines a 64 bit floating point real real ( Float64 ), parameter :: PI = 3.14159265d0 real ( Float64 ), parameter :: e_amu = 5.48579909070d-4 !+ Atomic mass of an electron [amu] real ( Float64 ), parameter :: H1_amu = 1.007276466879d0 !+ Atomic mass of Hydrogen-1 (protium) [amu] real ( Float64 ), parameter :: H2_amu = 2.013553212745d0 !+ Atomic mass of Hydrogen-2 (deuterium) [amu] real ( Float64 ), parameter :: H3_amu = 3.01550071632d0 !+ Atomic mass of Hydrogen-3 (tritium) [amu] real ( Float64 ), parameter :: He3_amu = 3.01602931914d0 !+ Atomic mass of Helium-3 [amu] real ( Float64 ), parameter :: B_amu = 1 0.81d0 !+ Atomic mass of Boron [amu] real ( Float64 ), parameter :: C_amu = 1 2.011d0 !+ Atomic mass of Carbon [amu] integer , parameter :: B_q = 5 !+ Proton number of Boron integer , parameter :: C_q = 6 !+ Proton number of Carbon real ( Float64 ), dimension ( 15 , 15 ), parameter :: EINSTEIN = reshape ([ & !(n,m) 0.d0 , 4.699d8 , 5.575d7 , 1.278d7 , 4.125d6 , 1.644d6 , 7.568d5 , 3.869d5 , 2.143d5 , 1.263d5 , 7.834d4 , 5.066d4 , 3.393d4 , 2.341d4 , 1.657d4 ,& !(:,1) 0.d0 , 0.d0 , 4.410d7 , 8.419d6 , 2.530d6 , 9.732d5 , 4.389d5 , 2.215d5 , 1.216d5 , 7.122d4 , 4.397d4 , 2.834d4 , 1.893d4 , 1.303d4 , 9.210d3 ,& !(:,2) 0.d0 , 0.d0 , 0.d0 , 8.986d6 , 2.201d6 , 7.783d5 , 3.358d5 , 1.651d5 , 8.905d4 , 5.156d4 , 3.156d4 , 2.021d4 , 1.343d4 , 9.211d3 , 6.490d3 ,& !(:,3) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 2.699d6 , 7.711d5 , 3.041d5 , 1.424d5 , 7.459d4 , 4.235d4 , 2.556d4 , 1.620d4 , 1.069d4 , 7.288d3 , 5.110d3 ,& !(:,4) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 1.025d6 , 3.253d5 , 1.388d5 , 6.908d4 , 3.800d4 , 2.246d4 , 1.402d4 , 9.148d3 , 6.185d3 , 4.308d3 ,& !(:,5) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 4.561d5 , 1.561d5 , 7.065d4 , 3.688d4 , 2.110d4 , 1.288d4 , 8.271d3 , 5.526d3 , 3.815d3 ,& !(:,6) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 2.272d5 , 8.237d4 , 3.905d4 , 2.117d4 , 1.250d4 , 7.845d3 , 5.156d3 , 3.516d3 ,& !(:,7) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 1.233d5 , 4.676d4 , 2.301d4 , 1.287d4 , 7.804d3 , 5.010d3 , 3.359d3 ,& !(:,8) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 7.141d4 , 2.812d4 , 1.427d4 , 8.192d3 , 5.080d3 , 3.325d3 ,& !(:,9) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 4.377d4 , 1.774d4 , 9.231d3 , 5.417d3 , 3.324d3 ,& !(:,10) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 2.799d4 , 1.163d4 , 6.186d3 , 3.699d3 ,& !(:,11) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 1.857d4 , 7.884d3 , 4.271d3 ,& !(:,12) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 1.271d4 , 5.496d3 ,& !(:,13) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 8.933d3 ,& !(:,14) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 ]& !(:,15) , [ 15 , 15 ]) !+ Einstein coefficients for spontaneous emission from state initial state `n` to final state `m` !+ !+References: !+ !+* H - Table A in Ref. 1 [[atomic_tables(module)]] !!Loop Parallization Settings integer :: istart = 1 !+ Starting loop counter (1 if OpenMP, processor number if MPI) integer :: istep = 1 !+ Loop step size (1 if OpenMP, number of processes if MPI) logical :: verbose = . True . !+ Indicates whether process is verbose contains function p_cx_1_janev ( Erel ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=1 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 3.2345d0 , 2.3588d2 , 2.3713d0 , & 3.8371d-2 , 3.8068d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ), parameter :: n = 1.d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_1_janev function p_cx_2_janev ( Erel ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 9.2750d-1 , 6.5040d3 , 2.0699d1 , & 1.3405d-2 , 3.0842d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ), parameter :: n = 2.d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_2_janev function p_cx_3_janev ( Erel ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 3.7271d-1 , 2.7645d6 , 1.4857d3 , & 1.5720d-3 , 3.0842d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ), parameter :: n = 3.d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_3_janev function p_cx_n_janev ( Erel , n ) result ( sigma ) !+Calculates cross section for proton-Hydrogen charge exchange interactions from the n \\geq 4 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n \\geq 4) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 2.1336d-1 , 1.0000d10 , 1.3426d6 , & 1.8184d-3 , 3.0842d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ) :: Ehat if ( n . lt . 4 ) then write ( * , '(a)' ) \"P_CX_N_JANEV: n cannot be less than 4\" stop endif Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_n_janev function p_cx_janev ( Erel , n ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the `n` state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer :: i i = min ( n , 4 ) select case ( i ) case ( 0 ) stop case ( 1 ) sigma = p_cx_1_janev ( Erel ) case ( 2 ) sigma = p_cx_2_janev ( Erel ) case ( 3 ) sigma = p_cx_3_janev ( Erel ) case DEFAULT sigma = p_cx_n_janev ( Erel , n ) end select end function p_cx_janev function aljan1 ( energy , pcf ) result ( sigma ) !+ Fit function for [[p_cx_1_2_janev]] real ( Float64 ), intent ( in ) :: energy !+ Relative collision energy [eV] real ( Float64 ), dimension (:), intent ( in ) :: pcf !+ Fit Coefficients real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ) :: aloge1 , aloge , xjan , xcon , emin , emax integer :: i emin = pcf ( 2 ) emax = pcf ( 3 ) if (( energy . lt . emin ). or .( energy . gt . emax )) then sigma = 0 return endif aloge1 = log ( energy ) aloge = aloge1 xjan = pcf ( 4 ) do i = 5 , 12 xcon = pcf ( i ) * aloge xjan = xjan + xcon aloge = aloge * aloge1 enddo sigma = exp ( xjan ) end function p_cx_1_2_janev ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(2) + H&#94;+ !+###References !+* Ref. 8 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 12 ), parameter :: c2s = [ 0.d0 , 26 2.d0 , 2000 0.d0 , & - 1327 3.250877640001d0 , & 1317 5.766145199999d0 , & - 568 3.9321578580002d0 , & 138 6.3097801490001d0 , & - 20 8.97945613069999d0 , & 1 9.92976245274d0 , & - 1.1738005761570001d0 , & 0.039024228107669999d0 , & - 0.00056062403399319998d0 ] real ( Float64 ), dimension ( 12 ), parameter :: c2p = [ 0.d0 , 1 9.d0 , 2000 0.d0 , & - 2 1.975719499349999d0 , & - 4 7.425022512600002d0 , & 3 6.280131405959999d0 , & - 1 4.23003075866d0 , & 3.2730902401440001d0 , & - 0.45579289122599997d0 , & 0.037735883474579998d0 , & - 0.001707904867106d0 , & 3.251203344615d-5 ] real ( Float64 ) :: e , sigma2s , sigma2p , logsig1 , logsig2 , slope e = Erel * 1.d3 sigma2s = aljan1 ( e , c2s ) sigma2p = aljan1 ( e , c2p ) if ( e . gt . c2p ( 2 )) then sigma = sigma2s + sigma2p else ! linearly extrapolate in log-space logsig2 = log ( aljan1 ( c2p ( 2 ) + 1 , c2s ) + aljan1 ( c2p ( 2 ) + 1 , c2p )) logsig1 = log ( aljan1 ( c2p ( 2 ), c2s ) + aljan1 ( c2p ( 2 ), c2p )) slope = ( logsig2 - logsig1 ) / ( log ( c2p ( 2 ) + 1 ) - log ( c2p ( 2 ))) sigma = exp ( slope * ( log ( e ) - log ( c2p ( 2 ))) + logsig1 ) endif end function p_cx_1_1_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=1 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(1) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 7 ), parameter :: a = [ - 3.496092687d2 , 4.724931484d2 , & - 2.720493064d2 , 8.158564625d1 , & - 1.339790721d1 , 1.138706949d0 , & - 3.914774156d-2 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 1.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 1.0d3 fac = Erel ** ( - 0.2 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_1_1_adas function p_cx_1_2_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(2) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 9 ), parameter :: a = [ - 4.036239511d3 , 6.941235312d3 , & - 5.186974866d3 , 2.194885201d3 , & - 5.765960509d2 , 9.653534186d1 , & - 1.008066138d1 , 6.010731909d-1 ,& - 1.567417031d-2 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 1.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 1.0d3 fac = Erel ** ( 0.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_1_2_adas function p_cx_1_3_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(3) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ 7.037287586d4 , - 1.479161477d5 , & 1.370120708d5 , - 7.343180122d4 , & 2.509832081d4 , - 5.674317075d3 , & 8.487767749d2 , - 8.102284612d1 , & 4.480007503d0 , - 1.093512342d-1 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 2.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 2.0d3 fac = ( Erel ** ( 1.4 )) / 2.8 endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = max ( fac * ( 1 0.d0 ** p ), 1.d-300 ) end function p_cx_1_3_adas function p_cx_1_4_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=4 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(4) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ 6.826447557d4 , - 1.431980004d5 , & 1.323968679d5 , - 7.083995050d4 , & 2.417608863d4 , - 5.458418789d3 , & 8.154875237d2 , - 7.776012846d1 , & 4.295431731d0 , - 1.047567211d-1 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 2.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 2.0d3 fac = ( Erel ** ( 2.0 )) / 4.0 endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = max ( fac * ( 1 0.d0 ** p ), 1.d-300 ) end function p_cx_1_4_adas function p_cx_1 ( Erel , m_max ) result ( sigma ) !+Calculates an array of cross section for proton-Hydrogen charge exchange interactions !+from the n=1 state to m = 1..`m_max` states at energy `Erel` !+ !+@note Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]] !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 2 [[atomic_tables(module)]] !+* Ref. 4 [[atomic_tables(module)]] !+* Ref. 8 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] integer :: i real ( Float64 ) :: norm_fac sigma = 0.d0 do i = 1 , m_max select case ( i ) case ( 1 ) if ( Erel . le . 2.0 ) then sigma ( 1 ) = p_cx_janev ( Erel , 1 ) else sigma ( 1 ) = p_cx_1_1_adas ( Erel ) endif case ( 2 ) if ( Erel . le . 2.0 ) then sigma ( 2 ) = p_cx_1_2_janev ( Erel ) else sigma ( 2 ) = p_cx_1_2_adas ( Erel ) endif case ( 3 ) sigma ( 3 ) = p_cx_1_3_adas ( Erel ) case ( 4 ) sigma ( 4 ) = p_cx_1_4_adas ( Erel ) case DEFAULT sigma ( i ) = 0.d0 end select enddo !Normalize to Janev to be consistent with other n levels (p_cx_2/3/...) norm_fac = p_cx_janev ( Erel , 1 ) / sum ( sigma ) sigma = norm_fac * sigma end function p_cx_1 function p_cx_2_2_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=2 state to the m=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(2) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a2s = [ - 1.896015167d6 , 4.431727330d6 , & - 4.627815357d6 , 2.843068107d6 , & - 1.137952956d6 , 3.100801094d5 , & - 5.825744660d4 , 7.452319142d3 , & - 6.212350647d2 , 3.047712749d1 , & - 6.682658463d-1 ] real ( Float64 ), dimension ( 11 ), parameter :: a2p = [ - 1.614213508d5 , 3.772469288d5 , & - 3.924736424d5 , 2.393127027d5 , & - 9.470300966d4 , 2.541276100d4 , & - 4.682860453d3 , 5.851219013d2 , & - 4.744504549d1 , 2.254460913d0 , & - 4.767235839d-2 ] real ( Float64 ), parameter :: n = 2.d0 real ( Float64 ) :: e , ee , fac , l , sigma2s , sigma2p e = Erel * 1.d3 * n ** 2.0 if ( Erel . le . 1.5d2 ) then ee = max ( e , 1.d3 ) fac = 1.d0 else ee = 1.5e5 * n ** 2.d0 fac = 2.d15 * (( e * 1.d-3 ) ** ( - 5.5 )) endif l = log10 ( ee ) sigma2s = a2s ( 1 ) + a2s ( 2 ) * l + a2s ( 3 ) * l ** 2.0 + a2s ( 4 ) * l ** 3.0 + & a2s ( 5 ) * l ** 4.0 + a2s ( 6 ) * l ** 5.0 + a2s ( 7 ) * l ** 6.0 + & a2s ( 8 ) * l ** 7.0 + a2s ( 9 ) * l ** 8.0 + a2s ( 10 ) * l ** 9.0 + a2s ( 11 ) * l ** 1 0.0 sigma2s = 1 0.d0 ** ( sigma2s ) sigma2p = a2p ( 1 ) + a2p ( 2 ) * l + a2p ( 3 ) * l ** 2.0 + a2p ( 4 ) * l ** 3.0 + & a2p ( 5 ) * l ** 4.0 + a2p ( 6 ) * l ** 5.0 + a2p ( 7 ) * l ** 6.0 + & a2p ( 8 ) * l ** 7.0 + a2p ( 9 ) * l ** 8.0 + a2p ( 10 ) * l ** 9.0 + a2p ( 11 ) * l ** 1 0.0 sigma2p = 1 0.d0 ** ( sigma2p ) sigma = fac * ( 0.25 * sigma2s + 0.75 * sigma2p ) end function p_cx_2_2_adas function p_cx_2_3_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=2 state to the m=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(3) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a2s = [ - 3.513030327d5 , 9.281116596d5 , & - 1.086843398d6 , 7.437325055d5 , & - 3.296609685d5 , 9.897503768d4 , & - 2.039707143d4 , 2.850670244d3 , & - 2.587092857d2 , 1.377382945d1 , & - 3.268306303d-1 ] real ( Float64 ), dimension ( 11 ), parameter :: a2p = [ - 1.901264631d5 , 5.124716103d5 , & - 6.101921504d5 , 4.234717934d5 , & - 1.899866398d5 , 5.764464326d4 , & - 1.199087959d4 , 1.689900512d3 , & - 1.545334374d2 , 8.285001228d0 , & - 1.978656474d-1 ] real ( Float64 ), parameter :: n = 2.d0 real ( Float64 ) :: ee , l , sigma2s , sigma2p ee = min ( max ( Erel * 1.d3 * n ** 2.d0 , 1.d3 ), 4.d6 ) l = log10 ( ee ) sigma2s = a2s ( 1 ) + a2s ( 2 ) * l + a2s ( 3 ) * l ** 2.0 + a2s ( 4 ) * l ** 3.0 + & a2s ( 5 ) * l ** 4.0 + a2s ( 6 ) * l ** 5.0 + a2s ( 7 ) * l ** 6.0 + & a2s ( 8 ) * l ** 7.0 + a2s ( 9 ) * l ** 8.0 + a2s ( 10 ) * l ** 9.0 + a2s ( 11 ) * l ** 1 0.0 sigma2s = 1 0.d0 ** ( sigma2s ) sigma2p = a2p ( 1 ) + a2p ( 2 ) * l + a2p ( 3 ) * l ** 2.0 + a2p ( 4 ) * l ** 3.0 + & a2p ( 5 ) * l ** 4.0 + a2p ( 6 ) * l ** 5.0 + a2p ( 7 ) * l ** 6.0 + & a2p ( 8 ) * l ** 7.0 + a2p ( 9 ) * l ** 8.0 + a2p ( 10 ) * l ** 9.0 + a2p ( 11 ) * l ** 1 0.0 sigma2p = 1 0.d0 ** ( sigma2p ) sigma = ( 0.25 * sigma2s + 0.75 * sigma2p ) end function p_cx_2_3_adas subroutine m_spread ( n , m_max , sigma_tot , sigma ) !+ Spreads the total charge exchange cross section, `sigma_tot`, !+ among the non-filled m states of `sigma` according to an exponential integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states in `sigma` real ( Float64 ), intent ( in ) :: sigma_tot !+ Amount of \"cross section\" to spread about the non-filled m state of sigma real ( Float64 ), dimension ( m_max ), intent ( inout ) :: sigma !+ Array of cross sections from the `n` state to m=1..`m_max` [cm&#94;2] real ( Float64 ) :: En , Em real ( Float64 ) :: norm_fac real ( Float64 ), dimension ( m_max ) :: sigma_m integer :: m sigma_m = 0.d0 En = 1 3.6 / ( real ( n ) ** 2.0 ) do m = 1 , m_max Em = 1 3.6 / ( real ( m ) ** 2.0 ) if ( sigma ( m ). eq . 0.d0 ) then sigma_m ( m ) = ( sigma_tot / sqrt ( 2.0 * PI )) * exp ( - 0.5 * ( En - Em ) ** 2.0 ) endif enddo norm_fac = sigma_tot / sum ( sigma_m ) do m = 1 , m_max if ( sigma ( m ). eq . 0.d0 ) sigma ( m ) = sigma_m ( m ) * norm_fac if ( sigma ( m ). ne . sigma ( m )) sigma ( m ) = 0.d0 enddo end subroutine m_spread function p_cx_2 ( Erel , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen charge exchange interactions !+from the n=2 state to m = 1..`m_max` states at energy `Erel` !+ !+@note !+Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]]. !+ !+@note !+Cross sections for the n=2 \\rightarrow m=1 states are calculated via !+equivalence principle using [[p_cx_1_2_adas(proc)]]. !+ !+@note !+Cross Sections for m \\geq 4 are calculated by \"spreading\" their !+expected total cross sections among the m \\geq 4 states. !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 2 [[atomic_tables(module)]] !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] real ( Float64 ), parameter :: n2 = 4.d0 integer :: i real ( Float64 ) :: En , Em , sigma_n , norm_fac sigma = 0.d0 do i = 1 , min ( m_max , 3 ) select case ( i ) case ( 1 ) sigma ( 1 ) = p_cx_1_2_adas ( Erel * n2 ) / n2 case ( 2 ) sigma ( 2 ) = p_cx_2_2_adas ( Erel ) case ( 3 ) sigma ( 3 ) = p_cx_2_3_adas ( Erel ) end select enddo sigma_n = max ( p_cx_janev ( Erel , 2 ) - sum ( sigma ), 0.d0 ) call m_spread ( 2 , m_max , sigma_n , sigma ) norm_fac = p_cx_janev ( Erel , 2 ) / sum ( sigma ) sigma = sigma * norm_fac end function p_cx_2 function p_cx_3_2_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(2) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a = [ - 1.149224555d6 , 2.750368877d6 , & - 2.942222842d6 , 1.852584954d6 , & - 7.603284323d5 , 2.125284465d5 , & - 4.097580431d4 , 5.380901722d3 , & - 4.606297192d2 , 2.321345254d1 , & - 5.230186707d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2.0 fac = 1.d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0.d0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_2_adas function p_cx_3_3_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(3) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ - 4.302808608d4 , 9.499298161d4 , & - 9.264698488d4 , 5.236947172d4 , & - 1.890479538d4 , 4.519068626d3 , & - 7.152485009d2 , 7.227063167d1 , & - 4.230036444d0 , 1.092702525d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2 fac = 0.85d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_3_adas function p_cx_3_4_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=4 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(4) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 9 ), parameter :: a = [ 1.705303425d4 , - 3.316878090d4 , & 2.792556433d4 , - 1.330264490d4 , & 3.921666688d3 , - 7.327555138d2 , & 8.476342861d1 , - 5.551987930d0 , & 1.577120745d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2.0 fac = 0.82d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_4_adas function p_cx_3_5_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=5 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(5) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a = [ - 2.786268232d2 , 4.269683825d4 , & - 8.973561028d4 , 8.365732310d4 , & - 4.524587937d4 , 1.563630402d4 , & - 3.580391824d3 , 5.432527332d2 , & - 5.267599631d1 , 2.962329657d0 , & - 7.362649692d-2 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p ee = max ( min ( Erel * 1.d3 , 5.5d5 ) * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_5_adas function p_cx_3_6inf_adas ( Erel ) result ( sigma ) !+Calculates total cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to \\forall \\; m \\geq 6 states at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(\\forall \\; m \\geq 6) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a = [ 7.146969470d5 , - 1.665413326d6 , & 1.735840441d6 , - 1.065792786d6 , & 4.269334710d5 , - 1.165954977d5 , & 2.198700496d4 , - 2.827160468d3 , & 2.372409350d2 , - 1.173264972d1 , & 2.596865877d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2.0 fac = 2.d20 * ( Erel * n ** 2.0 ) ** ( - 7.0 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_6inf_adas function p_cx_3 ( Erel , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen charge exchange interactions !+from the n=3 state to m = 1..`m_max` states at energy `Erel` !+ !+@note !+Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]]. !+ !+@note !+Cross sections for the n=3 \\rightarrow m=1 states are calculated via !+equivalence principle using [[p_cx_1_3_adas(proc)]]. !+ !+@note !+Cross Sections for m \\geq 6 are calculated by \"spreading\" their !+expected total cross sections among the  m \\geq 6 states. !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] real ( Float64 ), parameter :: n2 = 9.d0 real ( Float64 ) :: eb , En , Em , sigma_m6 , norm_fac real ( Float64 ), dimension ( m_max ) :: sigma1 sigma = 0.d0 sigma1 = 0.d0 sigma1 = p_cx_1 ( Erel * n2 , m_max ) sigma ( 1 ) = p_cx_1_3_adas ( Erel * n2 ) / n2 sigma ( 2 ) = p_cx_3_2_adas ( Erel ) sigma ( 3 ) = p_cx_3_3_adas ( Erel ) sigma ( 4 ) = p_cx_3_4_adas ( Erel ) if ( m_max . ge . 5 ) then sigma ( 5 ) = p_cx_3_5_adas ( Erel ) endif if ( m_max . ge . 6 ) then sigma_m6 = p_cx_3_6inf_adas ( Erel ) call m_spread ( 3 , m_max , sigma_m6 , sigma ) endif norm_fac = p_cx_janev ( Erel , 3 ) / sum ( sigma ) sigma = sigma * norm_fac end function p_cx_3 function p_cx_n ( Erel , n , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen charge exchange interactions !+from the `n` state to m = 1..`m_max` states at energy `Erel` !+ !+@note !+Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]]. !+ !+@note !+Cross sections for some transitions are calculated via the equivalence principle or !+by \"spreading\" their expected total cross sections among the non-filled m states. !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 2 [[atomic_tables(module)]] !+* Ref. 4 [[atomic_tables(module)]] !+* Ref. 8 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] real ( Float64 ), dimension ( m_max ) :: sigma2 , sigma3 real ( Float64 ) :: sigma_n , e , norm_fac sigma = 0.d0 select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_cx_1 ( Erel , m_max ) return case ( 2 ) sigma = p_cx_2 ( Erel , m_max ) return case ( 3 ) sigma = p_cx_3 ( Erel , m_max ) return case ( 4 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 1 ) = p_cx_1_4_adas ( e / ( 1.0 ** 2.0 )) * ( 1.d0 / n ) ** 2.0 sigma ( 2 ) = sigma2 ( 4 ) * ( 2.d0 / n ) ** 2.0 sigma ( 3 ) = p_cx_3_4_adas ( e / ( 3.0 ** 2.0 )) * ( 3.d0 / n ) ** 2.0 case ( 5 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 2 ) = sigma2 ( 5 ) * ( 2.d0 / n ) ** 2.0 sigma ( 3 ) = p_cx_3_5_adas ( e / ( 3.0 ** 2.0 )) * ( 3.d0 / n ) ** 2.0 case ( 6 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 2 ) = sigma2 ( 6 ) * ( 2.d0 / n ) ** 2.0 sigma3 = p_cx_3 ( e / ( 3.0 ** 2.0 ), m_max ) * ( 3.d0 / n ) ** 2.0 sigma ( 3 ) = sigma3 ( 6 ) case DEFAULT end select sigma_n = max ( p_cx_janev ( Erel , n ) - sum ( sigma ), 0.0 ) call m_spread ( n , m_max , sigma_n , sigma ) norm_fac = p_cx_janev ( Erel , n ) / sum ( sigma ) sigma = norm_fac * sigma end function p_cx_n function p_cx_n_m ( Erel , n , m ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the `n` state to the `m` state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ !+###References !+* Ref. 2 [[atomic_tables(module)]] !+* Ref. 4 [[atomic_tables(module)]] !+* Ref. 8 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer :: m_max = 12 real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = p_cx_n ( Erel , n , m_max ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function p_cx_n_m function p_cx ( Erel , n_max , m_max ) result ( sigma ) !+Calculates a matrix of cross sections for proton-Hydrogen charge exchange interactions !+from the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n=1..n_{max}) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 2 [[atomic_tables(module)]] !+* Ref. 4 [[atomic_tables(module)]] !+* Ref. 8 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n_max !+ Number of initial atomic energy levels/states integer , intent ( in ) :: m_max !+ Number of final atomic energy levels/states real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts correspond !+ to the n \\rightarrow m transitions: p_cx[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = p_cx_n ( Erel , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function p_cx !proton-Hydrogen impact ionization function p_ioniz_1_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=1 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 40 and Table 8 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 2.0160d-3 , 3.7154d0 , & 3.9890d-2 , 3.1413d-1 , & 2.1254d0 , 6.3990d3 , & 6.1897d1 , 9.2731d3 ] !+ Fitting Parameters from Table 8 in Ref. 2 real ( Float64 ), parameter :: n2 = 1.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_1_janev function p_ioniz_2_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=2 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 3.9330d-3 , 1.8188d0 , & 1.8870d-2 , 6.7489d-3 , & 1.3768d0 , 6.8852d2 , & 9.6435d1 , 5.6515d23 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 4.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_2_omullane function p_ioniz_3_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=3 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1076d-2 , 1.6197d0 , & 6.7154d-3 , 5.1188d-3 , & 1.8549d0 , 2.3696d2 , & 7.8286d1 , 1.0926d23 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 9.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_3_omullane function p_ioniz_4_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(4) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1033d-2 , 1.6281d0 , & 5.5955d-3 , 7.2023d-3 , & 1.7358d0 , 2.2755d2 , & 8.6339d1 , 3.9151d29 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 1 6.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_4_omullane function p_ioniz_5_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(5) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1297d-2 , 1.8685d0 , & 1.5038d-2 , 1.1195d-1 , & 1.0538d0 , 8.6096d2 , & 8.9939d1 , 1.9249d4 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 2 5.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_5_omullane function p_ioniz_n ( eb , n ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the `n`th state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 40 and Table 8 in Ref. 2 for n=1 [[atomic_tables(module)]] !+* Eq. 5 and Table 1 in Ref. 3 for n \\geq 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_ioniz_1_janev ( eb ) case ( 2 ) sigma = p_ioniz_2_omullane ( eb ) case ( 3 ) sigma = p_ioniz_3_omullane ( eb ) case ( 4 ) sigma = p_ioniz_4_omullane ( eb ) case DEFAULT sigma = p_ioniz_5_omullane ( eb ) * ( n / 5.d0 ) ** 4 end select end function p_ioniz_n function p_ioniz ( eb , n_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen impact ionization interactions !+from the n = 1..`n_max` state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n=1..n_{max}) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 40 and Table 8 in Ref. 2 for n=1 [[atomic_tables(module)]] !+* Eq. 5 and Table 1 in Ref. 3 for n \\geq 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n_max !+ Number of initial atomic energy level/state real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the index refers to the `n`'th state [cm&#94;2] integer :: i do i = 1 , n_max sigma ( i ) = p_ioniz_n ( eb , i ) enddo end function p_ioniz !! proton-Hydrogen impact excitation function p_excit_1_2_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=2 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(2)  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ 3 4.433d0 , 8.5476d0 , & 7.8501d0 , - 9.2217d0 , & 1.8020d-2 , 1.6931d0 , & 1.9422d-3 , 2.9068d0 , & 4 4.507d0 , 0.56870d0 ] !+ Fitting parameters from Table 4 in Ref. 2 sigma = 1.d-16 * a ( 1 ) * ( a ( 2 ) * exp ( - a ( 3 ) * eb ) / ( eb ** a ( 4 )) + & a ( 5 ) * exp ( - a ( 6 ) / eb ) / ( 1. + a ( 7 ) * eb ** a ( 8 )) + & exp ( - a ( 9 ) / eb ) * log ( 1. + a ( 10 ) * eb ) / eb ) end function p_excit_1_2_janev function p_excit_1_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=3 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(3)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 6.1950d0 , 5.5162d-3 , & 0.29114d0 , - 4.5264d0 , & 6.0311d0 , - 2.0679d0 , & 3 5.773d0 , 0.54818d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_3_janev function p_excit_1_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(4)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 2.0661d0 , 5.1335d-4 , & 0.28953d0 , - 2.2849d0 , & 0.11528d0 , - 4.8970d0 , & 3 4.975d0 , 0.91213d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_4_janev function p_excit_1_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(5)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.2449d0 , 3.0826d-4 , & 0.31063d0 , - 2.4161d0 , & 0.024664d0 , - 6.3726d0 , & 3 2.291d0 , 0.21176d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_5_janev function p_excit_1_6_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=6 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(6)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 0.63771d0 , 3.2949d-4 , & 0.25757d0 , - 2.2950d0 , & 0.050796d0 , - 5.5986d0 , & 3 7.174d0 , 0.39265d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_6_janev function p_excit_1_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from !+the n=1 state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 1  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for m \\gt 6 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from n=1 to m [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = p_excit_1_2_janev ( eb ) case ( 3 ) sigma ( 3 ) = p_excit_1_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = p_excit_1_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_1_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_1_6_janev ( eb ) case DEFAULT sigma ( m ) = p_excit_1_6_janev ( eb ) * ( 6.0 / real ( m )) ** 3.0 end select enddo end function p_excit_1_janev function p_excit_2_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=3 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(3)  !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 39 4.51d0 , 0.013597d0 , & 0.16565d0 , - 0.8949d0 , & 2 1.606d0 , 0.62426d0 ] !+ Fitting parameters from Table 6 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_3_janev function p_excit_2_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(4)  !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 5 0.744d0 , 0.014398d0 , & 0.31584d0 , - 1.4799d0 , & 1 9.416d0 , 4.0262d0 ] !+ Fitting parameters from Table 6 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_4_janev function p_excit_2_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(5)  !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 1 8.264d0 , 0.013701d0 , & 0.31711d0 , - 1.4775d0 , & 1 8.973d0 , 2.9056d0 ] !+ Fitting parameters from Table 6 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_5_janev function p_excit_2_6_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=6 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(6)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 4.61d-1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_6_janev function p_excit_2_7_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=7 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(7)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 2.475d-1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_7_janev function p_excit_2_8_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=8 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(8)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.465d-1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_8_janev function p_excit_2_9_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=9 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(9)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 9.2d-2 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_9_janev function p_excit_2_10_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=10 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(10)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 6.05d-2 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_10_janev function p_excit_2_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from !+the n=2 state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 2 !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 for m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for m \\gt 10 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from n=2 to m [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = p_excit_2_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = p_excit_2_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_2_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_2_6_janev ( eb ) case ( 7 ) sigma ( 7 ) = p_excit_2_7_janev ( eb ) case ( 8 ) sigma ( 8 ) = p_excit_2_8_janev ( eb ) case ( 9 ) sigma ( 9 ) = p_excit_2_9_janev ( eb ) case ( 10 ) sigma ( 10 ) = p_excit_2_10_janev ( eb ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / real ( m )) ** 3.0 end select enddo end function p_excit_2_janev function p_excit_3_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(4)  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 124 7.5d0 , 0.068781d0 , & 0.521176d0 , - 1.2722d0 , & 1 1.319d0 , 2.6235d0 ] !+ Fitting parameters from Table 7 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_4_janev function p_excit_3_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(5)  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 19 0.59d0 , 0.073307d0 , & 0.54177d0 , - 1.2894d0 , & 1 1.096d0 , 2.9098d0 ] !+ Fitting parameters from Table 7 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_5_janev function p_excit_3_6_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=6 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(6)  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 6 3.494d0 , 0.077953d0 , & 0.53461d0 , - 1.2881d0 , & 1 1.507d0 , 4.3417d0 ] !+ Fitting parameters from Table 7 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_6_janev function p_excit_3_7_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=7 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(7)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 4.67d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_7_janev function p_excit_3_8_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=8 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(8)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 2.545d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_8_janev function p_excit_3_9_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=9 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(9)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.54d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_9_janev function p_excit_3_10_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=10 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(10)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.0d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_10_janev function p_excit_3_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen impact excitation transitions from !+the n=3 state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 3  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 for m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for m \\gt 10 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from n=3 to m [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = 0.d0 case ( 4 ) sigma ( 4 ) = p_excit_3_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_3_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_3_6_janev ( eb ) case ( 7 ) sigma ( 7 ) = p_excit_3_7_janev ( eb ) case ( 8 ) sigma ( 8 ) = p_excit_3_8_janev ( eb ) case ( 9 ) sigma ( 9 ) = p_excit_3_9_janev ( eb ) case ( 10 ) sigma ( 10 ) = p_excit_3_10_janev ( eb ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / real ( m )) ** 3.0 end select enddo end function p_excit_3_janev function p_excit_n ( eb , n , m_max ) result ( sigma ) !+Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from !+the `n` state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 [[atomic_tables(module)]] !+* Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from `n` to m [cm&#94;2] integer :: m real ( Float64 ) :: nf , mf , Etil , s , D , A , G , L , F real ( Float64 ) :: y , zpl , zmi , C2pl , C2mi , H sigma = 0.d0 select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_excit_1_janev ( eb , m_max ) case ( 2 ) sigma = p_excit_2_janev ( eb , m_max ) case ( 3 ) sigma = p_excit_3_janev ( eb , m_max ) case DEFAULT nf = real ( n ) m_loop : do m = 1 , m_max if ( n . ge . m ) then sigma ( m ) = 0.d0 cycle m_loop endif mf = real ( m ) Etil = Eb / 2 5.0 s = ( mf - nf ) D = exp ( - 1.0 / ( nf * mf * Etil ** 2.0 )) A = 8.0 / ( 3.0 * s ) * ( mf / ( s * nf )) ** 3 * ( 0.184 - 0.04 / s ** ( 2.0 / 3.0 )) * & ( 1.0 - 0.2 * s / ( nf * mf )) ** ( 1.0 + 2.0 * s ) G = 0.5 * ( Etil * nf ** 2.0 / ( mf - 1.0 / mf ) ) ** 3. L = log ( 1.0 + 0.53 * Etil ** 2.0 * nf * ( mf - 2.0 / mf ) / ( 1.0 + 0.4 * Etil )) F = ( 1.0 - 0.3 * s * D / ( nf * mf ) ) ** ( 1.0 + 2.0 * s ) y = 1.0 / ( 1.0 - D * log ( 18 * s ) / ( 4.0 * s ) ) zpl = 2.0 / ( Etil * nf ** 2 * ( ( 2.0 - ( nf / mf ) ** 2 ) ** 0.5 + 1.0 )) zmi = 2.0 / ( Etil * nf ** 2 * ( ( 2.0 - ( nf / mf ) ** 2 ) ** 0.5 - 1.0 )) C2pl = zpl ** 2 * log ( 1.0 + 2.0 * zpl / 3.0 ) / ( 2.0 * y + 3.0 * zpl / 2.0 ) C2mi = zmi ** 2 * log ( 1.0 + 2.0 * zmi / 3.0 ) / ( 2.0 * y + 3.0 * zmi / 2.0 ) H = C2mi - C2pl sigma ( m ) = (( 8.8d-17 * n ** 4 ) / Etil ) * ( A * L * D + F * G * H ) enddo m_loop end select end function p_excit_n function p_excit_n_m ( eb , n , m ) result ( sigma ) !+Calculates the cross section for a proton-Hydrogen impact excitation transition from !+the `n` state to the `m` state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m), m \\gt n  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 [[atomic_tables(module)]] !+* Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = p_excit_n ( eb , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function p_excit_n_m function p_excit ( eb , n_max , m_max ) result ( sigma ) !+Calculates a matrix of cross sections for a proton-Hydrogen impact excitation transitions !+from the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n=1..n_{max}) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 [[atomic_tables(module)]] !+* Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of initial atomic energy levels/states integer , intent ( in ) :: n_max !+ Number of final atomic energy levels/states real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts correspond !+ to the n \\rightarrow m transitions: p_excit[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = p_excit_n ( eb , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function p_excit function e_ioniz_1_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the n=1 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer , parameter :: n = 1 !+ Initial atomic energy level/state real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.18450d0 , - 0.032226d0 , & - 0.034539d0 , 1.4003d0 , & - 2.8115d0 , 2.2986d0 ] !+ Fitting parameters from Table 3 in Ref. 2 real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1.d3 !keV to eV x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1.d-13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) sigma = max ( sigma , 0.d0 ) end function e_ioniz_1_janev function e_ioniz_2_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the n=2 state at energy `eb` !+ !+###Equation !+ e + H(2) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer , parameter :: n = 2 !+ Initial atomic energy level/state real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.14784d0 , 0.0080871d0 , & - 0.062270d0 , 1.9414d0 , & - 2.1980d0 , 0.95894d0 ] !+ Fitting parameters from Table 3 in Ref. 2 real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1.d3 !keV to eV x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1.d-13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) sigma = max ( sigma , 0.d0 ) end function e_ioniz_2_janev function e_ioniz_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the n=3 state at energy `eb` !+ !+###Equation !+ e + H(3) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer , parameter :: n = 3 !+ Initial atomic energy level/state real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.058463d0 , - 0.051272d0 , & 0.85310d0 , - 0.57014d0 , & 0.76684d0 , 0.00d0 ] !+ Fitting parameters from Table 3 in Ref. 2 real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1.d3 !keV to eV if ( e . ge . 1.5 ) then x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1.d-13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) else sigma = 0.d0 endif end function e_ioniz_3_janev function e_ioniz_n ( eb , n ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the `n` state at energy `eb` !+ !+###Equation !+ e + H(n) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+* Eq. 15-16 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ) :: rn , xn , Edn2 real ( Float64 ) :: g0 , g1 , g2 , An , b , Bn select case ( n ) case ( 0 ) stop case ( 1 ) sigma = e_ioniz_1_janev ( eb ) case ( 2 ) sigma = e_ioniz_2_janev ( eb ) case ( 3 ) sigma = e_ioniz_3_janev ( eb ) case DEFAULT rn = 1.94 / n ** 1.57 Edn2 = 1 3.6 / n ** 2.0 xn = ( eb * 1.d3 ) / Edn2 g0 = 0.9935 + 0.2328 / n - 0.1296 / n ** 2.0 g1 = - ( 1.0 / n ) * ( 0.6282 - 0.5598 / n + 0.5299 / n ** 2.0 ) g2 = ( 1.0 / n ** 2.0 ) * ( 0.3887 - 1.181 / n + 1.47 / n ** 2.0 ) An = 3 2.0 * n / ( 3.0 * sqrt ( 3.0 ) * PI ) * ( g0 / 3.0 + g1 / 4.0 + g2 / 5.0 ) b = ( 1.0 / n ) * ( 4.0 - 1 8.63 / n + 3 6.24 / n ** 2.0 - 2 8.09 / n ** 3.0 ) Bn = ( 2.0 / 3.0 ) * ( n ** 2.0 ) * ( 5.0 + b ) if ( xn . gt . 1 ) then sigma = 1.76 * n ** 2 / xn * ( 1.0 - exp ( - rn * xn )) * & ( An * log ( xn ) + ( Bn - An * log ( 2.0 * n ** 2 )) * & ( 1.0 - 1.0 / xn ) ** 2 ) * 1.e-16 else sigma = 0.d0 endif end select end function e_ioniz_n function e_ioniz ( eb , n_max ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact ionization from !+the n=1..n_{max} states at energy `eb` !+ !+###Equation !+ e + H(n=1..n_{max}) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+* Eq. 15-16 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n_max !+ Number of initial atomic energy levels/states to calculate real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the n'th index refers to a ionization from the n'th state [cm&#94;2] integer :: i do i = 1 , n_max sigma ( i ) = e_ioniz_n ( eb , i ) enddo end function e_ioniz function e_excit_1_2_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=2 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(2)  !+ !+###References !+* Eq. 4 and Table 1 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 0.2d0 real ( Float64 ), parameter :: a = 0.228d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: b = 0.1865d0 !+ Fitting paramter from Table 2 in Ref. 2 real ( Float64 ), parameter :: c = 0.5025d0 !+ Fitting paramter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 6 ), parameter :: An = [ 4.4979d0 , 1.4182d0 , & - 2 0.877d0 , 4 9.735d0 , & - 4 6.249d0 , 1 7.442d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ( ecoll ) / deltaE if (( ecoll . gt . 1 0.2 ). and .( ecoll . le . 1 1.56 )) then sigma = 1.d-16 * ( a + b * ( ecoll - deltaE )) return endif if (( ecoll . ge . 1 1.56 ). and .( ecoll . le . 1 2.23 )) then sigma = 1.d-16 * c return endif if ( ecoll . ge . 1 2.23 ) then s = An ( 2 ) + An ( 3 ) / x + An ( 4 ) / x ** 2.0 + An ( 5 ) / x ** 3.0 + An ( 6 ) / x ** 4.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( An ( 1 ) * log ( x ) + s ) return endif if ( x . le . 1.0 ) then sigma = 0.0 return endif end function e_excit_1_2_janev function e_excit_1_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=3 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(3)  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 2.09d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: alpha = 0.38277d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.75448d0 , 0.42956d0 , & - 0.58288d0 , 1.0693d0 , & 0.d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_1_3_janev function e_excit_1_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=4 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(4)  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 2.75d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: alpha = 0.41844d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.24300d0 , 0.24846d0 , & 0.19701d0 , 0.d0 , & 0.d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_1_4_janev function e_excit_1_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=5 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(5)  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 3.06d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: alpha = 0.45929d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.11508d0 , 0.13092d0 , & 0.23581d0 , 0.d0 , & 0.d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_1_5_janev function e_excit_f ( n , m ) result ( fnm ) !+ Oscillator strength for a `n`\\rightarrow`m` transition due to electron-Hydrogen impact excitation !+ !+###References !+* Eqs. 11-13 in Ref. 2 [[atomic_tables(module)]] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: fnm !+ Oscillator strength real ( Float64 ), dimension ( 3 ) :: g real ( Float64 ) :: x , nf , mf , gs nf = real ( n ) mf = real ( m ) x = 1.0 - ( nf / mf ) ** 2.0 select case ( n ) case ( 1 ) g = [ 1.133 , - 0.4059 , 0.0714 ] case ( 2 ) g = [ 1.0785 , - 0.2319 , 0.02947 ] case DEFAULT g ( 1 ) = 0.9935 + 0.2328 / nf - 0.1296 / nf ** 2 g ( 2 ) =- 1.0 / nf * ( 0.6282 - 0.5598 / nf + 0.5299 / nf ** 2 ) g ( 3 ) = 1.0 / nf ** 2.0 * ( 0.3887 - 1.1810 / nf + 1.4700 / nf ** 2 ) end select gs = g ( 1 ) + g ( 2 ) / x + g ( 3 ) / x ** 2 fnm = 3 2.0 / ( 3.0 * sqrt ( 3.0 ) * PI ) * nf / mf ** 3 * 1 / x ** 3 * gs end function e_excit_f function e_excit_1_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=1..m_{max} state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(m=1..m_{max})  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=1 state to the m'th state [cm&#94;2] integer :: m real ( Float64 ) :: x , y , A , B , deltaE do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = e_excit_1_2_janev ( eb ) case ( 3 ) sigma ( 3 ) = e_excit_1_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = e_excit_1_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = e_excit_1_5_janev ( eb ) case DEFAULT y = 1.0 - ( 1.d0 / m ) ** 2.0 deltaE = 1 3.6 * y x = ( eb * 1.d3 ) / deltaE A = 2.0 * e_excit_f ( 1 , m ) / y B = 4.0 / ( m ** 3.0 * y ) * ( 1.0 + 4.0 / ( 3.0 * y ) - 0.603 / y ** 2.0 ) sigma ( m ) = 1.76e-16 / ( y * x ) * ( 1.0 - exp ( - 0.45 * y * x )) * & ( A * ( log ( x ) + 1.0 / ( 2.0 * x )) + ( B - A * log ( 2.0 / y )) * & ( 1.0 - 1.0 / x )) if ( x . le . 1.0 ) sigma ( m ) = 0.d0 end select enddo end function e_excit_1_janev function e_excit_2_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=2 state to the m=3 state at energy `eb` !+ !+###Equation !+ e + H(2) \\rightarrow e + H(3)  !+ !+###References !+* Eq. 5 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1.8888d0 !+ Energy difference between n=1 and n=3: !+ \\Delta E = 13.6\\left (\\frac{1}{2&#94;2} - \\frac{1}{3&#94;2}\\right ) real ( Float64 ), parameter :: alpha = 1.3196d0 !+ Fitting parameter from Section 2.1.1 B in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 3 8.906d0 , 5.2373d0 , 11 9.25d0 , & - 59 5.39d0 , 81 6.71d0 ] !+ Fitting parameters from Section 2.1.1 B in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_2_3_janev function e_excit_n ( eb , n , m_max ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from !+the `n` state to the m=1..m_{max} state at energy `eb` !+ !+###Equation !+ e + H(n) \\rightarrow e + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the `n`\\rightarrow`m` state [cm&#94;2] integer :: m real ( Float64 ) :: nf , mf real ( Float64 ) :: x , y , A , B , bn , r , deltaE nf = real ( n ) if ( n . eq . 1 ) then sigma = e_excit_1_janev ( eb , m_max ) else m_loop : do m = 1 , m_max mf = real ( m ) if ( n . ge . m ) then sigma ( m ) = 0.d0 cycle m_loop endif if (( n . eq . 2 ). and .( m . eq . 3 )) then sigma ( m ) = e_excit_2_3_janev ( eb ) else deltaE = 1 3.6 * ( 1.0 / nf ** 2 - 1.0 / mf ** 2 ) x = ( eb * 1.d3 ) / deltaE y = 1.0 - ( nf / mf ) ** 2 r = 1.94 / nf ** 1.57 A = 2.0 * nf ** 2 * e_excit_f ( n , m ) / y bn = 1.0 / nf * ( 4.0 - 1 8.63 / nf + 3 6.24 / nf ** 2 - 2 8.09 / nf ** 3 ) B = 4.0 * nf ** 4 / ( mf ** 3 * y ** 2 ) * ( 1.0 + 4.0 / ( 3.0 * y ) + bn / y ** 2.0 ) sigma ( m ) = 1.76e-16 * nf ** 2 / ( y * x ) * ( 1.0 - exp ( - r * y * x )) * & ( A * ( log ( x ) + 1.0 / ( 2.0 * x )) + ( B - A * log ( 2.0 * n ** 2.0 / y )) * & ( 1.0 - 1.0 / x )) if ( x . le . 1.0 ) sigma ( m ) = 0.d0 endif enddo m_loop endif end function e_excit_n function e_excit_n_m ( eb , n , m ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from !+the `n` \\rightarrow `m` state at energy `eb` !+ !+###Equation !+ e + H(n) \\rightarrow e + H(m), m \\gt n  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = e_excit_n ( eb , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function e_excit_n_m function e_excit ( eb , n_max , m_max ) result ( sigma ) !+Calculates a matrix of cross section for a proton-Hydrogen impact excitation transition !+from the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy `eb` !+ !+###Equation !+ e + H(n=1..n_{max}) \\rightarrow e + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of initial atomic energy levels/states integer , intent ( in ) :: n_max !+ Number of final atomic energy levels/states real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts correspond !+ to the n \\rightarrow m transitions: e_excit[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n do n = 1 , 12 sigma_full ( n ,:) = e_excit_n ( eb , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function e_excit !Impurities !A[q]_cx_[n]_[source] function B5_cx_1_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(1) \\rightarrow B&#94;{4+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 7 ), parameter :: A = [ 1.174052518d3 , - 1.793561728d3 , & 1.117522436d3 , - 3.679435571d2 , & 6.750816878d1 , - 6.542029074d0 , & 2.614113716d-1 ] real ( Float64 ) :: e , l , p e = max ( eb , 1.0 ) * 1.d3 !set lower limit to be 1keV l = log10 ( e ) if ( e . le . 4.d5 ) then p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 sigma = 1 0.d0 ** p else sigma = 0.d0 endif end function B5_cx_1_adas function B5_cx_2_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=2 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(2) \\rightarrow B&#94;{4+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: A = [ 6.603246818d1 , - 3.072575676d2 , & 5.030801019d2 , - 4.585636345d2 , & 2.568666393d2 , - 9.185150382d1 , & 2.100012584d1 , - 2.964174788d0 , & 2.346396110d-1 , - 7.943766873d-3 ] real ( Float64 ) :: e , l , p e = max ( eb * 1.d3 , 1 0.0 ) l = log10 ( e ) if ( e . le . 1.d5 ) then p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 sigma = 1 0.d0 ** p else sigma = 0.d0 endif end function B5_cx_2_adas function C6_cx_1_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(1) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 7 ), parameter :: A = [ 2.007882674d2 , - 3.546893286d2 , & 2.381542403d2 , - 8.355431742d1 , & 1.617519888d1 , - 1.638152470d0 , & 6.768953863d-2 ] real ( Float64 ) :: e , l , p , m e = max ( eb * 1.d3 , 1.5d3 ) if ( eb . le . 500 ) then l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 else l = log10 ( 500 * 1.d3 ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 m = A ( 2 ) + 2 * A ( 3 ) * l + 3 * A ( 4 ) * l ** 2 + & 4 * A ( 5 ) * l ** 3 + 5 * A ( 6 ) * l ** 4 + 6 * A ( 7 ) * l ** 5 p = p + m * ( log10 ( e ) - l ) endif sigma = 1 0.d0 ** p end function C6_cx_1_adas function C6_cx_2_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=2 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(2) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 9.151879441d5 , - 2.134573133d6 , & 2.223792624d6 , - 1.362648703d6 , & 5.438401343d5 , - 1.477110500d5 , & 2.764972254d4 , - 3.522105245d3 , & 2.921934171d2 , - 1.425552507d1 , & 3.106007048d-1 ] real ( Float64 ) :: e , l , p , m e = max ( eb * 1.d3 , 1.5d3 ) * 2.0 ** 2 if ( eb . le . 700 ) then l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 + A ( 11 ) * l ** 10 else l = log10 ( 700 * 1.d3 * 2.0 ** 2 ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 + A ( 11 ) * l ** 10 m = A ( 2 ) + 2 * A ( 3 ) * l + 3 * A ( 4 ) * l ** 2 + & 4 * A ( 5 ) * l ** 3 + 5 * A ( 6 ) * l ** 4 + 6 * A ( 7 ) * l ** 5 + & 7 * A ( 8 ) * l ** 6 + 8 * A ( 9 ) * l ** 7 + 9 * A ( 10 ) * l ** 8 + 10 * A ( 11 ) * l ** 9 p = p + m * ( log10 ( e ) - l ) endif sigma = 1 0.d0 ** p end function C6_cx_2_adas function C6_cx_3_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=3 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(3) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 9.208877916d5 , - 2.147294379d6 , & 2.236451628d6 , - 1.370042347d6 , & 5.466461899d5 , - 1.484338816d5 , & 2.777765778d4 , - 3.537459450d3 , & 2.933884362d2 , - 1.430994136d1 , & 3.117002878d-1 ] real ( Float64 ) :: e , l , p , m e = max ( eb * 1.d3 , 1.5d3 ) * 3.0 ** 2 if ( eb . le . 300 ) then l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 + A ( 11 ) * l ** 10 else l = log10 ( 300 * 1.d3 * 3.0 ** 2 ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 + A ( 11 ) * l ** 10 m = A ( 2 ) + 2 * A ( 3 ) * l + 3 * A ( 4 ) * l ** 2 + & 4 * A ( 5 ) * l ** 3 + 5 * A ( 6 ) * l ** 4 + 6 * A ( 7 ) * l ** 5 + & 7 * A ( 8 ) * l ** 6 + 8 * A ( 9 ) * l ** 7 + 9 * A ( 10 ) * l ** 8 + 10 * A ( 11 ) * l ** 9 p = p + m * ( log10 ( e ) - l ) endif sigma = 1 0.d0 ** p end function C6_cx_3_adas function Aq_cx_n_adas ( eb , q , n ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+@note Returns 0 if ADAS cross sections are not available for given inputs !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] sigma = 0.d0 select case ( q ) case ( 5 ) if ( n . eq . 1 ) sigma = B5_cx_1_adas ( eb ) if ( n . eq . 2 ) sigma = B5_cx_2_adas ( eb ) case ( 6 ) if ( n . eq . 1 ) sigma = C6_cx_1_adas ( eb ) if ( n . eq . 2 ) sigma = C6_cx_2_adas ( eb ) if ( n . eq . 3 ) sigma = C6_cx_3_adas ( eb ) case DEFAULT sigma = 0.d0 end select end function Aq_cx_n_adas function B5_cx_1_janev ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(1) \\rightarrow B&#94;{4+} + H&#94;+  !+ !+###References !+* Page 166 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 3 1.226d0 , 1.1442d0 , & 4.8372d-8 , 3.0961d-10 , & 4.7205d0 , 6.2844d-7 , & 3.1297d0 , 0.12556d0 , & 0.30098d0 , 5.9607d-2 , & - 0.57923d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ** A ( 8 )) / & ( 1.0 + A ( 3 ) * eb ** 2 + A ( 4 ) * eb ** A ( 5 ) + & A ( 6 ) * eb ** A ( 7 )) + A ( 9 ) * exp ( - A ( 10 ) * eb ) / eb ** A ( 11 )) end function B5_cx_1_janev function C6_cx_1_janev ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(1) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Page 168 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 41 8.18d0 , 2.1585d0 , & 3.4808d-4 , 5.3333d-9 , & 4.6556d0 , 0.33755d0 , & 0.81736d0 , 0.27874d0 , & 1.8003d-6 , 7.1033d-2 , & 0.53261d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ** A ( 8 )) / & ( 1.0 + A ( 3 ) * eb ** 2 + A ( 4 ) * eb ** A ( 5 ) + & A ( 6 ) * eb ** A ( 7 )) + A ( 9 ) * exp ( - A ( 10 ) * eb ) / eb ** A ( 11 )) end function C6_cx_1_janev function Aq_cx_n_janev ( eb , q , n ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Page 166 in Ref. 5 [[atomic_tables(module)]] !+* Page 168 in Ref. 5 [[atomic_tables(module)]] !+* Page 174 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.507d5 real ( Float64 ), parameter :: B = 1.974d-5 real ( Float64 ) :: etil , nf , qf nf = real ( n ) qf = real ( q ) if (( n . eq . 1 ). and .( q . eq . 5 )) then sigma = B5_cx_1_janev ( eb ) return endif if (( n . eq . 1 ). and .( q . eq . 6 )) then sigma = C6_cx_1_janev ( eb ) return endif if ( n . le . 1 ) then sigma = 0.d0 return endif etil = eb * ( nf ** 2.0 ) / ( qf ** 0.5 ) sigma = qf * nf ** 4 * 7.04d-16 * A / ( etil ** 3.5 * ( 1.0 + B * etil ** 2 )) * & ( 1.0 - exp ( - 2.0 * etil ** 3.5 * ( 1.0 + B * etil ** 2 ) / ( 3.0 * A ))) end function Aq_cx_n_janev function Aq_cx_n ( eb , q , n ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses ADAS(Ref. 4) cross sections if available else uses Janev (Ref. 5) cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] !+* Page 166 in Ref. 5 [[atomic_tables(module)]] !+* Page 168 in Ref. 5 [[atomic_tables(module)]] !+* Page 174 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] sigma = Aq_cx_n_adas ( eb , q , n ) if ( sigma . eq . 0.d0 ) then sigma = Aq_cx_n_janev ( eb , q , n ) endif end function Aq_cx_n function Aq_cx ( eb , q , n_max ) result ( sigma ) !+ Calculates an array of total charge exchange cross sections for a Neutral Hydrogen atom !+in the n=1...n_max states colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses ADAS(Ref. 4) cross sections if available else uses Janev (Ref. 5) cross sections !+ !+###Equation !+ A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] !+* Page 174 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n_max !+ Number of initial atomic energy levels/states real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the n'th index refers to a charge exchange from the n'th state [cm&#94;2] integer :: n do n = 1 , n_max sigma ( n ) = Aq_cx_n ( eb , q , n ) enddo end function Aq_cx !Impurity impact ionization function B5_ioniz_1_janev ( eb ) result ( sigma ) !+ Calculates the total ionization cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(1) \\rightarrow B&#94;{5+} + H&#94;+ + e  !+ !+###References !+* Page 152 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: A = [ 35 1.52d0 , 23 3.63d0 , & 3.2952d3 , 5.3787d-6 , & 1.8834d-2 , - 2.2064d0 , & 7.2074d0 , - 3.78664d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ) * log ( 1 + A ( 3 ) * eb ) / eb & + A ( 4 ) * exp ( - A ( 5 ) * eb ) / (( eb ** A ( 6 )) + A ( 7 ) * ( eb ** A ( 8 )))) end function B5_ioniz_1_janev function C6_ioniz_1_janev ( eb ) result ( sigma ) !+ Calculates the total ionization cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(1) \\rightarrow C&#94;{6+} + H&#94;+ + e  !+ !+###References !+* Page 154 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: A = [ 43 8.36d0 , 32 7.10d0 , & 1.4444d5 , 3.5212d-3 , & 8.3031d-3 , - 0.63731d0 , & 1.9116d4 , - 3.1003d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ) * log ( 1 + A ( 3 ) * eb ) / eb & + A ( 4 ) * exp ( - A ( 5 ) * eb ) / (( eb ** A ( 6 )) + A ( 7 ) * ( eb ** A ( 8 )))) end function C6_ioniz_1_janev function Aq_ioniz_n_janev ( eb , q , n ) result ( sigma ) !+ Calculates the generic total ionization cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H&#94;+ + e, n \\gt 1, q \\gt 3  !+ !+###References !+* Page 160 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: M = 0.283d0 real ( Float64 ), parameter :: B = 4.04d0 real ( Float64 ), parameter :: c = 13 7.d0 real ( Float64 ), parameter :: g = 0.662d0 real ( Float64 ), parameter :: lambda = 0.76d0 real ( Float64 ) :: nf , qf , u , v , sigma_b nf = real ( n ) qf = real ( q ) v = sqrt ( eb / 2 5. ) u = nf * v sigma_b = 3.52d-16 * ( nf ** 4 ) * ( qf ** 2 ) / ( u ** 2 ) * & ( M * ( log (( u ** 2 ) / ( c ** 2 - u ** 2 )) - ( u ** 2 ) / ( c ** 2 )) + B - g / u ** 2 ) sigma_b = max ( sigma_b , 0.d0 ) sigma = exp ( - lambda * qf / u ** 2 ) * sigma_b end function Aq_ioniz_n_janev function Aq_ioniz_n ( eb , q , n ) result ( sigma ) !+ Calculates the total ionization cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Page 152 in Ref. 5 [[atomic_tables(module)]] !+* Page 154 in Ref. 5 [[atomic_tables(module)]] !+* Page 160 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] if (( q . eq . 5 ). and .( n . eq . 1 )) then sigma = B5_ioniz_1_janev ( eb ) return endif if (( q . eq . 6 ). and .( n . eq . 1 )) then sigma = C6_ioniz_1_janev ( eb ) return endif sigma = Aq_ioniz_n_janev ( eb , q , n ) end function Aq_ioniz_n function Aq_ioniz ( eb , q , n_max ) result ( sigma ) !+ Calculates an array of total ionization cross sections for a Neutral Hydrogen atom !+in the n=1...n_max states colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Page 152 in Ref. 5 [[atomic_tables(module)]] !+* Page 154 in Ref. 5 [[atomic_tables(module)]] !+* Page 160 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n_max !+ Number of initial states n to calculate real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the n'th index refers to a ionization from the n'th state [cm&#94;2] integer :: n do n = 1 , n_max sigma ( n ) = Aq_ioniz_n ( eb , q , n ) enddo end function Aq_ioniz !Impurity impact excitation function Aq_excit_1_2_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=2 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(2), q \\gt 4  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 3 8.738d0 , 3 7.033d0 , & 0.39862d0 , 7.7582d-5 , & 0.25402d0 , - 2.7418d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_2_janev function Aq_excit_1_3_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=3 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(3), q \\gt 4  !+ !+###References !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 4.3619d0 , 5 7.451d0 , & 2 1.001d0 , 2.3292d-4 , & 0.083130d0 , - 2.2364d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_3_janev function Aq_excit_1_4_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=4 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(4), q \\gt 4  !+ !+###References !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 1.3730d0 , 6 0.710d0 , & 3 1.797d0 , 2.0207d-4 , & 0.082513d0 , - 2.3055d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_4_janev function Aq_excit_1_5_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=5 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(5), q \\gt 4  !+ !+###References !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.56565d0 , 6 7.333d0 , & 5 5.290d0 , 2.1595d-4 , & 0.081624d0 , - 2.1971d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_5_janev function Aq_excit_1_janev ( eb , q , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=1 state to the m'th state [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = Aq_excit_1_2_janev ( eb , q ) case ( 3 ) sigma ( 3 ) = Aq_excit_1_3_janev ( eb , q ) case ( 4 ) sigma ( 4 ) = Aq_excit_1_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_1_5_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 5 ) * ( 5.0 / m ) ** 3.0 end select enddo end function Aq_excit_1_janev function Aq_excit_2_3_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=3 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(3), q \\gt 3  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 35 8.03d0 , 2 5.283d0 , & 1.4726d0 , 0.014398d0 , & 0.12207d0 , - 0.86210d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_3_janev function Aq_excit_2_4_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=4 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(4), q \\gt 3  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 5 0.744d0 , 1 9.416d0 , & 4.0262d0 , 0.014398d0 , & 0.31584d0 , - 1.4799d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_4_janev function Aq_excit_2_5_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=5 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(5), q \\gt 3  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 1 8.264d0 , 1 8.973d0 , & 2.9056d0 , 0.013701d0 , & 0.31711d0 , - 1.4775d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_5_janev function Aq_excit_2_6_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=6 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(6), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.4610d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_6_janev function Aq_excit_2_7_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=7 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(7), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.2475d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_7_janev function Aq_excit_2_8_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=8 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(8), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.1465d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_8_janev function Aq_excit_2_9_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=9 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(9), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.092d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_9_janev function Aq_excit_2_10_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=10 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(10), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.0605d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_10_janev function Aq_excit_2_janev ( eb , q , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4, m \\gt n  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=2 state to the m'th state [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = Aq_excit_2_3_janev ( eb , q ) case ( 4 ) sigma ( 4 ) = Aq_excit_2_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_2_5_janev ( eb , q ) case ( 6 ) sigma ( 6 ) = Aq_excit_2_6_janev ( eb , q ) case ( 7 ) sigma ( 7 ) = Aq_excit_2_7_janev ( eb , q ) case ( 8 ) sigma ( 8 ) = Aq_excit_2_8_janev ( eb , q ) case ( 9 ) sigma ( 9 ) = Aq_excit_2_9_janev ( eb , q ) case ( 10 ) sigma ( 10 ) = Aq_excit_2_10_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / m ) ** 3.0 end select enddo end function Aq_excit_2_janev function Aq_excit_3_4_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=4 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(4), q \\gt 3  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 124 7.5d0 , 1 1.319d0 , & 2.6235d0 , 0.068781d0 , & 0.521176d0 , - 1.2722d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_4_janev function Aq_excit_3_5_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=5 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(5), q \\gt 3  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 19 0.59d0 , 1 1.096d0 , & 2.9098d0 , 0.073307d0 , & 0.54177d0 , - 1.2894d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_5_janev function Aq_excit_3_6_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=6 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(6), q \\gt 3  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 6 3.494d0 , 1 1.507d0 , & 4.3417d0 , 0.077953d0 , & 0.53461d0 , - 1.2881d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_6_janev function Aq_excit_3_7_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=7 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(7), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.4670d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_7_janev function Aq_excit_3_8_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=8 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(8), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.2545d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_8_janev function Aq_excit_3_9_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=9 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(9), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.1540d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_9_janev function Aq_excit_3_10_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=10 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(10), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.1d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_10_janev function Aq_excit_3_janev ( eb , q , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4, m \\gt n  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=3 state to the m'th state [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = 0.d0 case ( 4 ) sigma ( 4 ) = Aq_excit_3_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_3_5_janev ( eb , q ) case ( 6 ) sigma ( 6 ) = Aq_excit_3_6_janev ( eb , q ) case ( 7 ) sigma ( 7 ) = Aq_excit_3_7_janev ( eb , q ) case ( 8 ) sigma ( 8 ) = Aq_excit_3_8_janev ( eb , q ) case ( 9 ) sigma ( 9 ) = Aq_excit_3_9_janev ( eb , q ) case ( 10 ) sigma ( 10 ) = Aq_excit_3_10_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / m ) ** 3.0 end select enddo end function Aq_excit_3_janev function Aq_excit_n_janev ( eb , q , n , m_max ) result ( sigma ) !+Calculates an array of the generic excitation cross sections for a neutral Hydrogen atom transitioning from !+the `n` state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n, n \\gt 3  !+ !+###References !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the `n` state to the m'th state [cm&#94;2] integer :: m real ( Float64 ) :: nf , mf , qf , etil , hi , s real ( Float64 ) :: D , A , G , L , F , H , y , zpl , zmi , C2pl , C2mi nf = real ( n ) qf = real ( q ) sigma = 0.d0 m_loop : do m = 1 , m_max mf = real ( m ) if ( n . ge . m ) then sigma ( m ) = 0.d0 cycle m_loop endif etil = eb / ( 2 5.0 * qf ) hi = 2.0 ** ( 0.322 * ( 1.0 - sqrt ( 2.0 / qf ))) s = ( mf - nf ) D = exp ( - 1.0 / ( nf * mf * etil ** 2 )) A = 8.0 / ( 3.0 * s ) * ( mf / ( s * nf )) ** 3 * ( 0.184 - 0.04 / s ** ( 2.0 / 3.0 )) * & ( 1.0 - 0.2 * s / ( nf * mf )) ** ( 1.0 + 2.0 * s ) G = 0.5 * ( etil * nf ** 2.0 / ( mf - 1.0 / mf )) ** 3.0 L = log ( 1.0 + 0.53 * etil ** 2.0 * nf * ( mf - 2.0 / mf ) / ( 1.0 + 0.4 * etil )) F = ( 1.0 - 0.3 * s * D / ( nf * mf )) ** ( 1.0 + 2.0 * s ) y = 1.0 / ( 1.0 - D * log ( 18 * s ) / ( 4.0 * s )) zpl = 2.0 / ( etil * nf ** 2 * ( sqrt ( 2.0 - nf ** 2 / mf ** 2 ) + 1.0 )) zmi = 2.0 / ( etil * nf ** 2 * ( sqrt ( 2.0 - nf ** 2 / mf ** 2 ) - 1.0 )) C2pl = zpl ** 2 * log ( 1.0 + 2.0 * zpl / 3.0 ) / ( 2.0 * y + 3.0 * zpl / 2.0 ) C2mi = zmi ** 2 * log ( 1.0 + 2.0 * zmi / 3.0 ) / ( 2.0 * y + 3.0 * zmi / 2.0 ) H = C2mi - C2pl sigma ( m ) = q * hi * 8.86e-17 * nf ** 4 / etil * ( A * D * L + F * G * H ) enddo m_loop end function Aq_excit_n_janev function Aq_excit_n ( eb , q , n , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the `n` state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n, n \\gt 3  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the `n` state to the m'th state [cm&#94;2] select case ( n ) case ( 0 ) stop case ( 1 ) sigma = Aq_excit_1_janev ( eb , q , m_max ) case ( 2 ) sigma = Aq_excit_2_janev ( eb , q , m_max ) case ( 3 ) sigma = Aq_excit_3_janev ( eb , q , m_max ) case DEFAULT sigma = Aq_excit_n_janev ( eb , q , n , m_max ) end select end function Aq_excit_n function Aq_excit_n_m ( eb , q , n , m ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the `n`\\rightarrow`m` state due to a collision an ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m), q \\gt 3, m \\gt n  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = Aq_excit_n ( eb , q , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function Aq_excit_n_m function Aq_excit ( eb , q , n_max , m_max ) result ( sigma ) !+Calculates an matrix of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=1..`n_max` state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n_max !+ Number of n states to calculate integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts refers to !+an excitation from the `n` state to the m'th state: Aq_excit[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = Aq_excit_n ( eb , q , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function Aq_excit function d_d_fusion_t ( eb ) result ( sigma ) !+Calculates total cross section at a given Deuterium energy, `eb`, !+for the Tritium branch of Deuterium-Deutrium nuclear reactions !+ !+###Equation !+ D + D \\rightarrow T(1.01 MeV) + p(3.02 MeV) (50%) !+ !+###References !+* Equations 8-9 !+* Table IV in Ref. 7 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Deuterium energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 5 ), parameter :: A = [ 5.5576d4 , 2.1054d2 , & - 3.2638d-2 , 1.4987d-6 , & 1.8181d-10 ] real ( Float64 ), dimension ( 4 ), parameter :: B = [ 0.d0 , 0.d0 , 0.d0 , 0.d0 ] real ( Float64 ), parameter :: Bg = 3 1.3970 real ( Float64 ) :: S , E E = min ( max ( eb , 0.5 ), 500 0.0 ) S = ( A ( 1 ) + E * ( A ( 2 ) + E * ( A ( 3 ) + E * ( A ( 4 ) + E * A ( 5 ))))) / & ( 1 + E * ( B ( 1 ) + E * ( B ( 2 ) + E * ( B ( 3 ) + E * B ( 4 ))))) sigma = ( 1.0d-27 ) * ( S / ( E * exp ( Bg / sqrt ( E )))) end function d_d_fusion_t function d_d_fusion_he ( eb ) result ( sigma ) !+Calculates total cross section at a given deuterium energy, `eb`, !+for the Helium-3 branch of Deuterium-Deutrium nuclear reactions !+ !+###Equation !+ D + D \\rightarrow He&#94;3(0.82 MeV) + n(2.45 MeV) (50%) !+ !+###References !+* Equations 8-9 !+* Table IV in Ref. 7 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Deuterium energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 5 ), parameter :: A = [ 5.3701d4 , 3.3027d2 , & - 1.2706d-1 , 2.9327d-5 , & - 2.5151d-9 ] real ( Float64 ), dimension ( 4 ), parameter :: B = [ 0.d0 , 0.d0 , 0.d0 , 0.d0 ] real ( Float64 ), parameter :: Bg = 3 1.3970 real ( Float64 ) :: S , E E = min ( max ( eb , 0.5 ), 490 0.0 ) S = ( A ( 1 ) + E * ( A ( 2 ) + E * ( A ( 3 ) + E * ( A ( 4 ) + E * A ( 5 ))))) / & ( 1 + E * ( B ( 1 ) + E * ( B ( 2 ) + E * ( B ( 3 ) + E * B ( 4 ))))) sigma = ( 1.0d-27 ) * ( S / ( E * exp ( Bg / sqrt ( E )))) end function d_d_fusion_he function d_t_fusion ( eb ) result ( sigma ) !+Calculates total cross section at a given deuterium energy, `eb`, !+for Deuterium-Tritium nuclear reactions in the range [0.5-550 keV] !+ !+###Equation !+ D + T \\rightarrow He&#94;4(3.5 MeV) + n(14.1 MeV) !+ !+###References !+* Equations 8-9 !+* Table IV, VI in Ref. 7 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Deuterium energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 5 ), parameter :: A1 = [ 6.927d4 , 7.454d8 , & 2.050d6 , 5.2002d4 , & 0.d0 ] real ( Float64 ), dimension ( 4 ), parameter :: B1 = [ 6.38d1 , - 9.95d-1 , & 6.981d-5 , 1.728d-4 ] real ( Float64 ), dimension ( 5 ), parameter :: A2 = [ - 1.4714d6 , 0.d0 , & 0.d0 , 0.d0 , 0.d0 ] real ( Float64 ), dimension ( 4 ), parameter :: B2 = [ - 8.4127d-3 , 4.7983d-6 , & - 1.0748d-9 , 8.5184d-14 ] real ( Float64 ), parameter :: Bg = 3 4.3827 real ( Float64 ), dimension ( 5 ) :: A real ( Float64 ), dimension ( 4 ) :: B real ( Float64 ) :: S , E E = min ( max ( eb , 0.5 ), 470 0.0 ) if ( E . le . 53 0.0 ) then A = A1 B = B1 else A = A2 B = B2 endif S = ( A ( 1 ) + E * ( A ( 2 ) + E * ( A ( 3 ) + E * ( A ( 4 ) + E * A ( 5 ))))) / & ( 1 + E * ( B ( 1 ) + E * ( B ( 2 ) + E * ( B ( 3 ) + E * B ( 4 ))))) sigma = ( 1.0d-27 ) * ( S / ( E * exp ( Bg / sqrt ( E )))) end function d_t_fusion function simpsons_rule ( f , dx ) result ( I ) !+ Performs 1D integration using Simpsons rule !+ !+ ###References !+* [Simpson's rule](http://mathworld.wolfram.com/SimpsonsRule.html) real ( Float64 ), dimension (:), intent ( in ) :: f !+ Array of equally spaced f(x) values real ( Float64 ), intent ( in ) :: dx !+ Spacing between x values real ( Float64 ) :: I integer :: s , ii s = size ( f ) I = 0.d0 if ( mod ( s , 2 ). eq . 1 ) then write ( * , '(a)' ) \"Length of array must be even\" return endif I = f ( 1 ) do ii = 2 , s - 1 if ( mod ( ii , 2 ). eq . 1 ) then I = I + 4.0 * f ( ii ) else I = I + 2.0 * f ( ii ) endif enddo I = I + f ( s ) I = ( dx / 3.0 ) * I end function simpsons_rule subroutine bt_maxwellian_eb ( fn , T , eb , am , ab , rate ) !+ Calculates Maxwellian reaction rate for a beam with atomic mass `ab` and energy `eb` !+firing into a target with atomic mass `am` and temperature `T` which has a cross section given by the function `fn` interface function fn ( a ) !+Cross section function real ( 8 ) :: fn !sigma real ( 8 ), intent ( in ) :: a !eb end function fn end interface real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] integer , parameter :: n_vr = 30 real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( n_vr ) :: vr real ( Float64 ), dimension ( n_vr ) :: fr integer , parameter :: n_vz = 60 real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( n_vz ) :: vz real ( Float64 ), dimension ( n_vz ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , v_therm , dE integer :: i , j vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 sig = fn ( erel ) fr ( j ) = sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm end subroutine bt_maxwellian_eb subroutine bt_maxwellian_n ( fn , T , eb , am , ab , n , rate ) !+ Calculates Maxwellian reaction rate for a beam with atomic mass `ab`, energy `eb`, and energy level `n` !+firing into a target with atomic mass `am` and temperature `T` which has a cross section given by the function `fn` interface function fn ( a , b ) !+Cross section function real ( 8 ) :: fn !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !n end function fn end interface real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] logical :: dxc integer , parameter :: n_vr = 30 real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( n_vr ) :: vr real ( Float64 ), dimension ( n_vr ) :: fr integer , parameter :: n_vz = 60 real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( n_vz ) :: vz real ( Float64 ), dimension ( n_vz ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , v_therm , dE integer :: i , j vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) dE = ( 1 3.6d-3 ) / ( n ** 2.0 ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 !for electron interactions fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( erel . ge . dE ) then sig = fn ( erel / ared , n ) else sig = 0.d0 endif fr ( j ) = sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm end subroutine bt_maxwellian_n subroutine bt_maxwellian_q_n ( fqn , q , T , eb , am , ab , n , rate ) !+ Calculates Maxwellian reaction rate for a beam with atomic mass `ab`, energy `eb`, and energy level `n` !+firing into a target with atomic mass `am`, temperature `T`, and charge `q`  which has a cross section given by the function `fqn` interface function fqn ( a , b , c ) !+Cross section function real ( 8 ) :: fqn !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !q integer , intent ( in ) :: c !n end function fqn end interface integer , intent ( in ) :: q !+Target charge real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] integer , parameter :: n_vr = 30 real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( n_vr ) :: vr real ( Float64 ), dimension ( n_vr ) :: fr integer , parameter :: n_vz = 60 real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( n_vz ) :: vz real ( Float64 ), dimension ( n_vz ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , v_therm , dE integer :: i , j vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) dE = ( 1 3.6d-3 ) / ( n ** 2.0 ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( erel . ge . dE ) then sig = fqn ( erel / ared , q , n ) else sig = 0.d0 endif fr ( j ) = sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm end subroutine bt_maxwellian_q_n subroutine bt_maxwellian_n_m ( fnm , T , eb , am , ab , n , m , rate , deexcit ) !+ Calculates Maxwellian reaction rate for a `n`\\rightarrow)`m` transition due to a beam with atomic mass `ab` and energy `eb` !+firing into a target with atomic mass `am` and temperature `T` which has a cross section given by the function `fnm` interface function fnm ( a , b , c ) !+Cross section function real ( 8 ) :: fnm !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !n integer , intent ( in ) :: c !m end function fnm end interface real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state integer , intent ( in ) :: m !+Final atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] logical , intent ( in ), optional :: deexcit !+Calculate de-excitation reaction rate logical :: dxc integer , parameter :: n_vr = 30 real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( n_vr ) :: vr real ( Float64 ), dimension ( n_vr ) :: fr integer , parameter :: n_vz = 60 real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( n_vz ) :: vz real ( Float64 ), dimension ( n_vz ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , dE , factor , En , Em , v_therm integer :: i , j if ( present ( deexcit )) then dxc = deexcit else dxc = . False . endif vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo En = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / n ) ** 2.0 ) Em = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / m ) ** 2.0 ) dE = Em - En T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( dxc ) then factor = ( erel + dE ) / erel erel = erel + dE else factor = 1.0 endif if ( erel . ge . dE ) then sig = fnm ( erel / ared , n , m ) else sig = 0.d0 endif fr ( j ) = factor * sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm if ( dxc ) rate = rate * ( real ( n ) / real ( m )) ** 2.0 end subroutine bt_maxwellian_n_m subroutine bt_maxwellian_q_n_m ( fqnm , q , T , eb , am , ab , n , m , rate , deexcit ) !+ Calculates Maxwellian reaction rate for a `n`\\rightarrow)`m` transition due to a beam with atomic mass `ab` and energy `eb` !+firing into a target with atomic mass `am`, temperature `T`, and charge `q` which has a cross section given by the function `fqnm` interface function fqnm ( a , b , c , d ) !+Cross section function real ( 8 ) :: fqnm !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !q integer , intent ( in ) :: c !n integer , intent ( in ) :: d !m end function fqnm end interface integer , intent ( in ) :: q !+Target charge real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state integer , intent ( in ) :: m !+Final atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] logical , intent ( in ), optional :: deexcit !+Calculate de-excitation reaction rate logical :: dxc integer , parameter :: n_vr = 30 real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( n_vr ) :: vr real ( Float64 ), dimension ( n_vr ) :: fr integer , parameter :: n_vz = 60 real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( n_vz ) :: vz real ( Float64 ), dimension ( n_vz ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , dE , factor , En , Em , v_therm integer :: i , j if ( present ( deexcit )) then dxc = deexcit else dxc = . False . endif vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo En = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / n ) ** 2.0 ) Em = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / m ) ** 2.0 ) dE = Em - En T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( dxc ) then factor = ( erel + dE ) / erel erel = erel + dE else factor = 1.0 endif if ( erel . ge . dE ) then sig = fqnm ( erel / ared , q , n , m ) else sig = 0.d0 endif fr ( j ) = factor * sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm if ( dxc ) rate = rate * ( real ( n ) / real ( m )) ** 2.0 end subroutine bt_maxwellian_q_n_m subroutine write_einstein ( id , n_max , m_max ) !+ Write Einstein coefficients to HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate real ( Float64 ), dimension ( n_max , m_max ) :: ein integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: error if ( verbose ) then ein (:,:) = EINSTEIN ( 1 : n_max , 1 : m_max ) call h5gcreate_f ( id , \"spontaneous\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , m_max ] call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_compressed_dataset_double_f ( gid , \"einstein\" , 2 , dim2 , ein , error ) call h5ltset_attribute_string_f ( id , \"spontaneous\" , \"description\" , & \"Atomic rates for spontaneous emission/deexcitation\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"description\" , & \"n/m resolved einstein coefficients: einstein(n,m)\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"units\" , \"1/s\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"reaction\" , & \"H(n) -> H(m) + ph, n > m\" , error ) call h5gclose_f ( gid , error ) endif end subroutine write_einstein subroutine write_bb_H_H ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Hydrogen interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate logical :: calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:), allocatable :: cx , excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: i , cnt , error logical :: exis NAMELIST / H_H_cross / calculate , nenergy , emin , emax calculate = . True .; nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_H: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_H_cross ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( cx ( n_max , m_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 if ( verbose ) then write ( * , '(a)' ) \"---- H-H cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' endif cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = istart , nenergy , istep eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb cx (:,:, i ) = p_cx ( eb , n_max , m_max ) excit (:,:, i ) = p_excit ( eb , n_max , m_max ) ioniz (:, i ) = p_ioniz ( eb , n_max ) cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt * istep / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( ebarr ) call parallel_sum ( cx ) call parallel_sum ( excit ) call parallel_sum ( ioniz ) #endif if ( verbose ) then call h5gcreate_f ( id , \"H_H\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 3 , dim3 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_H\" , \"description\" , & \"Cross sections for Hydrogen-Hydrogen interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n/m resolved charge exchange cross sections: cx(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"H(+) + H(n) -> H(m) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , cx , excit , ioniz ) end subroutine write_bb_H_H subroutine write_bb_H_e ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Electron interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate logical :: calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: i , cnt , error logical :: exis NAMELIST / H_e_cross / calculate , nenergy , emin , emax calculate = . True .; nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_E: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_e_cross ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0.d0 ioniz = 0.d0 excit = 0.d0 if ( verbose ) then write ( * , '(a)' ) \"---- H-e cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' endif cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = istart , nenergy , istep eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb excit (:,:, i ) = e_excit ( eb , n_max , m_max ) ioniz (:, i ) = e_ioniz ( eb , n_max ) cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt * istep / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( ebarr ) call parallel_sum ( excit ) call parallel_sum ( ioniz ) #endif if ( verbose ) then call h5gcreate_f ( id , \"H_e\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_e\" , \"description\" , & \"Cross sections for Hydrogen-Electron interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum Energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum Energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"e- + H(n) -> e- + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"e- + H(n) -> e- + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , ioniz , excit ) end subroutine write_bb_H_e subroutine write_bb_H_Aq ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Impurity interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate logical :: calculate integer :: q ( 10 ) = 0 real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: cx , ioniz real ( Float64 ), dimension (:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 character ( len = 10 ) :: aname character ( len = 5 ) :: asym integer :: i , iq , cnt , error logical :: exis NAMELIST / H_Aq_cross / calculate , q , nenergy , emin , emax nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 calculate = . True .; q ( 1 ) = 6 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_Aq: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_Aq_cross ) close ( 13 ) endif if (. not . calculate ) return q_loop : do iq = 1 , size ( q ) if ( q ( iq ). eq . 0 ) cycle q_loop allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( cx ( n_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 select case ( q ( iq )) case ( 5 ) aname = \"Boron\" asym = \"H_B5\" case ( 6 ) aname = \"Carbon\" asym = \"H_C6\" case DEFAULT write ( aname , '(\"Impurity-\",i1)' ) q ( iq ) write ( asym , '(\"H_A\",i1)' ) q ( iq ) end select if ( verbose ) then write ( * , '(a)' ) \"---- H-\" // trim ( adjustl ( aname )) // \" cross sections settings ----\" write ( * , '(T2,\"q = \", i2)' ) q ( iq ) write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' endif cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = istart , nenergy , istep eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb cx (:, i ) = Aq_cx ( eb , q ( iq ), n_max ) ioniz (:, i ) = Aq_ioniz ( eb , q ( iq ), n_max ) excit (:,:, i ) = Aq_excit ( eb , q ( iq ), n_max , m_max ) cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt * istep / real ( nenergy ), char ( 13 ) enddo #ifdef _MPI call parallel_sum ( ebarr ) call parallel_sum ( cx ) call parallel_sum ( excit ) call parallel_sum ( ioniz ) #endif if ( verbose ) then call h5gcreate_f ( id , trim ( adjustl ( asym )), gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 2 , dim2 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , trim ( adjustl ( asym )), \"description\" , & \"Cross sections for Hydrogen-\" // trim ( adjustl ( aname )) // \" interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n resolved charge exchange / electron capture cross sections: cx(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"A(q+) + H(n) -> A((q-1)+) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , ioniz , cx , excit ) enddo q_loop end subroutine write_bb_H_Aq subroutine write_bb_D_D ( id , namelist_file ) !+ Write Deuterium-Deuterium interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings logical :: calculate integer :: nbranch = 2 real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: i , cnt , error logical :: exis NAMELIST / D_D_cross / calculate , nenergy , emin , emax calculate = . True .; nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_D_D: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_D_cross ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( fusion ( nenergy , nbranch )) ebarr = 0.d0 fusion = 0.d0 if ( verbose ) then write ( * , '(a)' ) \"---- D-D cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' endif cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = istart , nenergy , istep eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb fusion ( i , 1 ) = d_d_fusion_t ( eb ) fusion ( i , 2 ) = d_d_fusion_he ( eb ) cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt * istep / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( ebarr ) call parallel_sum ( fusion ) #endif if ( verbose ) then call h5gcreate_f ( id , \"D_D\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] dim2 = [ nenergy , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 2 , dim2 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_D\" , \"description\" , & \"Cross sections for Deuterium-Deuterium interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Deuterium energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Cross sections for the Tritium[1] and He3[2] branches of D-D nuclear reactions: fusion(energy, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + D -> [1] T(1.01 MeV) + p(3.02 MeV) (50%); [2] He3(0.82 MeV) + n(2.45 MeV) (50%)\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , fusion ) end subroutine write_bb_D_D subroutine write_bb_D_T ( id , namelist_file ) !+ Write Deuterium-Tritium interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings logical :: calculate integer :: nbranch = 1 real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: i , cnt , error logical :: exis NAMELIST / D_T_cross / calculate , nenergy , emin , emax calculate = . True .; nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_D_T: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_T_cross ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( fusion ( nenergy , nbranch )) ebarr = 0.d0 fusion = 0.d0 if ( verbose ) then write ( * , '(a)' ) \"---- D-T cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' endif cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = istart , nenergy , istep eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb fusion ( i , 1 ) = d_t_fusion ( eb ) cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt * istep / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( ebarr ) call parallel_sum ( fusion ) #endif if ( verbose ) then call h5gcreate_f ( id , \"D_T\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] dim2 = [ nenergy , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 2 , dim2 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_T\" , \"description\" , & \"Cross sections for Deuterium-Tritium interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Deuterium energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Total cross sections for D-T nuclear reactions: fusion(deuterium energy, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + T -> He4(3.5 MeV) + n(14.1 MeV)\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , fusion ) end subroutine write_bb_D_T subroutine write_bt_H_H ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Hydrogen reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate logical :: calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit , cx integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 9 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a logical :: exis NAMELIST / H_H_rates / calculate , nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 calculate = . True . inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_H: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_H_rates ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( cx ( n_max , m_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) ebarr = 0.d0 tarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 a (:, 1 ) = [ H1_amu , H1_amu ] a (:, 2 ) = [ H1_amu , H2_amu ] a (:, 3 ) = [ H1_amu , H3_amu ] a (:, 4 ) = [ H2_amu , H1_amu ] a (:, 5 ) = [ H2_amu , H2_amu ] a (:, 6 ) = [ H2_amu , H3_amu ] a (:, 7 ) = [ H3_amu , H1_amu ] a (:, 8 ) = [ H3_amu , H2_amu ] a (:, 9 ) = [ H3_amu , H3_amu ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo if ( verbose ) then write ( * , '(a)' ) \"---- H-H reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' endif cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = istart , nenergy , istep eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max call bt_maxwellian ( p_cx_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) cx ( n , m , ie , it , ia ) = rate if ( m . gt . n ) then call bt_maxwellian ( p_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( p_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( p_ioniz_n , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * istep * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( cx ) call parallel_sum ( excit ) call parallel_sum ( ioniz ) #endif if ( verbose ) then call h5gcreate_f ( id , \"H_H\" , gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 5 , dim5 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_H\" , \"description\" , & \"Beam-Target reaction rates for Hydrogen(beam)-Hydrogen(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n/m resolved charge exchange reaction rates: cx(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"H(+) + H(n) -> H(m) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , tarr , cx , excit , ioniz ) end subroutine write_bt_H_H subroutine write_bt_H_e ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Electron reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate logical :: calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 3 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a logical :: exis NAMELIST / H_e_rates / calculate , nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 calculate = . True . inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_E: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_e_rates ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) ebarr = 0.d0 ioniz = 0.d0 excit = 0.d0 a (:, 1 ) = [ H1_amu , e_amu ] a (:, 2 ) = [ H2_amu , e_amu ] a (:, 3 ) = [ H3_amu , e_amu ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo if ( verbose ) then write ( * , '(a)' ) \"---- H-e reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' endif cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = istart , nenergy , istep eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max if ( m . gt . n ) then call bt_maxwellian ( e_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( e_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( e_ioniz_n , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * istep * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( excit ) call parallel_sum ( ioniz ) #endif if ( verbose ) then call h5gcreate_f ( id , \"H_e\" , gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_e\" , \"description\" , & \"Beam-Target reaction rates for Hydrogen(beam)-Electron(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"e- + H(n) -> e- + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"e- + H(n) -> e- + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , tarr , excit , ioniz ) end subroutine write_bt_H_e subroutine write_bt_H_Aq ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Impurity reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate logical :: calculate integer :: q ( 10 ) = 0 real ( Float64 ) :: mass real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz , cx real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: iq , ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 3 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a character ( len = 10 ) :: aname character ( len = 5 ) :: asym logical :: exis NAMELIST / H_Aq_rates / calculate , q , mass , nenergy , emin , emax , ntemp , tmin , tmax calculate = . True . ; q ( 1 ) = 6 ; mass = C_amu nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_Aq: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_Aq_rates ) close ( 13 ) endif if (. not . calculate ) return q_loop : do iq = 1 , size ( q ) if ( q ( iq ). eq . 0 ) cycle q_loop allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( cx ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) select case ( q ( iq )) case ( 5 ) aname = \"Boron\" asym = \"H_B5\" case ( 6 ) aname = \"Carbon\" asym = \"H_C6\" case DEFAULT write ( aname , '(\"Impurity-\",i1)' ) q ( iq ) write ( asym , '(\"H_A\",i1)' ) q ( iq ) end select ebarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 a (:, 1 ) = [ H1_amu , mass ] a (:, 2 ) = [ H2_amu , mass ] a (:, 3 ) = [ H3_amu , mass ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo if ( verbose ) then write ( * , '(a)' ) \"---- H-\" // trim ( adjustl ( aname )) // \" reaction rates settings ----\" write ( * , '(T2,\"q = \", i2)' ) q ( iq ) write ( * , '(T2,\"mass = \",f7.2, \" amu\")' ) mass write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' endif cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = istart , nenergy , istep eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max if ( m . gt . n ) then call bt_maxwellian ( Aq_excit_n_m , q ( iq ), ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( Aq_excit_n_m , q ( iq ), ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( Aq_cx_n , q ( iq ), ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) cx ( n , ie , it , ia ) = rate call bt_maxwellian ( Aq_ioniz_n , q ( iq ), ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * istep * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( cx ) call parallel_sum ( excit ) call parallel_sum ( ioniz ) #endif if ( verbose ) then call h5gcreate_f ( id , trim ( adjustl ( asym )), gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 4 , dim4 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , trim ( adjustl ( asym )), \"description\" , & \"Beam-Target reaction rates for Hydrogen(beam)-\" // trim ( adjustl ( aname )) // & \"(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n-resolved charge exchange reaction rates: cx(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"A(q+) + H(n) -> A((q-1)+) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , tarr , excit , ioniz , cx ) enddo q_loop end subroutine write_bt_H_Aq subroutine write_bt_D_D ( id , namelist_file ) !+ Write Deuterium-Deuterium reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings logical :: calculate integer :: nbranch = 2 real ( Float64 ), dimension ( 2 ) :: bt_amu = [ H2_amu , H2_amu ] real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: ie , it , error , cnt real ( Float64 ) :: rate_a , rate_b logical :: exis NAMELIST / D_D_rates / calculate , nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 calculate = . True . inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_D_D: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_D_rates ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( fusion ( nenergy , ntemp , nbranch )) ebarr = 0.d0 tarr = 0.d0 fusion = 0.d0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo if ( verbose ) then write ( * , '(a)' ) \"---- D-D reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' endif cnt = 0 !$OMP PARALLEL DO private(ie, it, eb, ti, rate_a, rate_b) do ie = istart , nenergy , istep eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) call bt_maxwellian ( d_d_fusion_t , ti , eb , bt_amu ( 1 ), bt_amu ( 2 ), rate_a ) call bt_maxwellian ( d_d_fusion_he , ti , eb , bt_amu ( 2 ), bt_amu ( 2 ), rate_b ) fusion ( ie , it , 1 ) = rate_a fusion ( ie , it , 2 ) = rate_b cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * istep * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( fusion ) #endif if ( verbose ) then call h5gcreate_f ( id , \"D_D\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim1 = [ 2 ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 1 , dim1 , bt_amu , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) dim3 = [ nenergy , ntemp , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 3 , dim3 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_D\" , \"description\" , & \"Beam-Target reaction rates for Deuterium(beam)-Deuterium(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Isotope mass of the beam and target species respectively\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"units\" , \"amu\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Beam-Target reaction rates for T/He3 branches of D-D nuclear reactions: fusion(energy, temp, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + D -> [1] T(1.01 MeV) + p(3.02 MeV) (50%); [2] He3(0.82 MeV) + n(2.45 MeV) (50%)\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , tarr , fusion ) end subroutine write_bt_D_D subroutine write_bt_D_T ( id , namelist_file ) !+ Write Deuterium-Tritium reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer :: nbranch = 1 real ( Float64 ), dimension ( 2 ) :: bt_amu = [ H2_amu , H3_amu ] logical :: calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: ie , it , error , cnt real ( Float64 ) :: rate logical :: exis NAMELIST / D_T_rates / calculate , nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 calculate = . True . inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_D_T: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_T_rates ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( fusion ( nenergy , ntemp , nbranch )) ebarr = 0.d0 tarr = 0.d0 fusion = 0.d0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo if ( verbose ) then write ( * , '(a)' ) \"---- D-T reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' endif cnt = 0 !$OMP PARALLEL DO private(ie, it, eb, ti, rate) do ie = istart , nenergy , istep eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) call bt_maxwellian ( d_t_fusion , ti , eb , bt_amu ( 1 ), bt_amu ( 2 ), rate ) fusion ( ie , it , 1 ) = rate cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * istep * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( fusion ) #endif if ( verbose ) then call h5gcreate_f ( id , \"D_T\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim1 = [ 2 ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 1 , dim1 , bt_amu , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) dim3 = [ nenergy , ntemp , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 3 , dim3 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_T\" , \"description\" , & \"Beam-Target reaction rates for Deuterium(beam)-Tritium(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Isotope mass of the beam and target species respectively\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"units\" , \"amu\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Beam-Target reaction rates for D-T nuclear reactions: fusion(energy, temperature, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + T -> He4(3.5 MeV) + n(14.1 MeV)\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , tarr , fusion ) end subroutine write_bt_D_T subroutine print_default_namelist !+ Prints out the default settings as a namelist write ( * , '(a)' ) \"!Default Atomic Table Settings\" write ( * , '(a)' ) \"&general_settings\" write ( * , '(a)' ) \"n_max = 12,    !Number of initial atomic energy levels\" write ( * , '(a)' ) \"m_max = 12,    !Number of final atomic energy levels\" write ( * , '(a)' ) \"tables_file = './atomic_tables.h5'\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Hydrogen Cross Sections\" write ( * , '(a)' ) \"&H_H_cross\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Electron Cross Sections\" write ( * , '(a)' ) \"&H_e_cross\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Impurity Cross Sections. Up to 10 impurity charges\" write ( * , '(a)' ) \"&H_Aq_cross\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"q(1) = 5,      !Impurity charge: Boron: 5, Carbon: 6, ...\" write ( * , '(a)' ) \"q(2) = 6,      !Impurity charge: Boron: 5, Carbon: 6, ...\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Deuterium-Deuterium Nuclear Cross Sections\" write ( * , '(a)' ) \"&D_D_cross\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Hydrogen Reaction Rates\" write ( * , '(a)' ) \"&H_H_rates\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum ion temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum ion temperature [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Electron Reaction Rates\" write ( * , '(a)' ) \"&H_e_rates\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum electron temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum electron temperature [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Impurity Reaction Rates. Up to 10 impurity charges\" write ( * , '(a)' ) \"&H_Aq_rates\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"q(1) = 5,      !Impurity charge: Boron: 5, Carbon: 6, ...\" write ( * , '(a)' ) \"q(2) = 6,      !Impurity charge: Boron: 5, Carbon: 6, ...\" write ( * , '(a)' ) \"mass = 12.011, !Impurity mass [amu]\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum ion temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum ion temperature [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Deuterium-Deuterium Nuclear Reaction Rates\" write ( * , '(a)' ) \"&D_D_rates\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum deuterium temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum deuterium temperature [keV]\" write ( * , '(a)' ) \"/\" end subroutine print_default_namelist end module atomic_tables program generate_tables !+ Tabulates cross sections and reaction rates and writes them to a HDF5 file use atomic_tables use H5LT use HDF5 use hdf5_utils use utilities #ifdef _OMP use omp_lib #endif character ( len = 200 ) :: namelist_file character ( len = 3 ) :: arg character ( len = 200 ) :: tables_file = '' integer :: n_max , m_max integer , dimension ( 8 ) :: time_start integer :: hour , minu , sec integer :: argc , max_threads , nthreads integer ( HID_T ) :: fid , gid integer :: error logical :: exis NAMELIST / general_settings / n_max , m_max , tables_file argc = command_argument_count () if ( argc . eq . 0 ) then call print_default_namelist () stop endif if ( argc . ge . 1 ) then call get_command_argument ( 1 , namelist_file ) endif inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'Input file does not exist: ' , trim ( namelist_file ) stop else open ( 13 , file = namelist_file ) read ( 13 , NML = general_settings ) close ( 13 ) n_max = min ( n_max , 15 ) m_max = min ( m_max , 15 ) endif #ifdef _OMP max_threads = OMP_get_num_procs () if ( argc . ge . 2 ) then call get_command_argument ( 2 , arg ) read ( arg , '(i3)' ) nthreads else nthreads = max_threads endif max_threads = min ( nthreads , max_threads ) write ( * , '(a)' ) \"---- OpenMP settings ----\" write ( * , '(T2,\"Number of threads: \",i2)' ) max_threads write ( * , * ) '' call OMP_set_num_threads ( max_threads ) #endif #ifdef _MPI call init_mpi () istart = my_rank () + 1 istep = num_ranks () if ( my_rank (). ne . 0 ) verbose = . False . if ( verbose ) then write ( * , '(a)' ) \"---- MPI settings ----\" write ( * , '(T2,\"Number of processes: \",i2)' ) num_ranks () write ( * , * ) '' endif #endif if ( verbose ) then write ( * , '(a)' ) \"---- General settings ----\" write ( * , '(T2,\"n_max = \",i2)' ) n_max write ( * , '(T2,\"m_max = \",i2)' ) m_max write ( * , '(T2,\"Tables File: \",a)' ) trim ( tables_file ) write ( * , * ) '' endif !! Check if compression is possible call check_compression_availability () call date_and_time ( values = time_start ) if ( verbose ) then !! Open HDF5 Interface call h5open_f ( error ) !! Create tables file. Overwrites if already exists call h5fcreate_f ( tables_file , H5F_ACC_TRUNC_F , fid , error ) !! Create group for cross sections call h5gcreate_f ( fid , \"cross\" , gid , error ) endif !! Calculate cross sections if ( verbose ) then write ( * , * ) 'Cross Sections:   ' , time ( time_start ) write ( * , * ) '' endif call write_bb_H_H ( gid , namelist_file , n_max , m_max ) call write_bb_H_e ( gid , namelist_file , n_max , m_max ) call write_bb_H_Aq ( gid , namelist_file , n_max , m_max ) call write_bb_D_D ( gid , namelist_file ) if ( verbose ) then !! Close cross section group call h5gclose_f ( gid , error ) !! Create group for reaction rates call h5gcreate_f ( fid , \"rates\" , gid , error ) endif !! Calculate reaction rates if ( verbose ) then write ( * , * ) 'Reaction Rates:   ' , time ( time_start ) write ( * , * ) '' endif call write_bt_H_H ( gid , namelist_file , n_max , m_max ) call write_bt_H_e ( gid , namelist_file , n_max , m_max ) call write_bt_H_Aq ( gid , namelist_file , n_max , m_max ) call write_einstein ( gid , n_max , m_max ) call write_bt_D_D ( gid , namelist_file ) if ( verbose ) then !! Close reaction rates group call h5gclose_f ( gid , error ) !! Add group attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Atomic Cross Sections and Rates\" , error ) call h5ltset_attribute_string_f ( fid , \"cross\" , \"description\" , & \"Atomic Cross Sections\" , error ) call h5ltset_attribute_string_f ( fid , \"rates\" , \"description\" , & \"Atomic Reaction Rates\" , error ) !! Close file and HDF5 interface call h5fclose_f ( fid , error ) call h5close_f ( error ) write ( * , '(a)' ) \"Atomic tables written to \" // trim ( tables_file ) write ( * , * ) '' endif #ifdef _MPI call cleanup_mpi () #endif if ( verbose ) then write ( * , * ) 'END: hour:minute:second ' , time ( time_start ) endif end program","tags":"","loc":"sourcefile/atomic_tables.f90.html","title":"atomic_tables.f90 – FIDASIM"},{"text":"check_plasma Checks if plasma paramters structure is valid Input Arguments inputs : Input structure grid : Interpolation grid structure plasma : Plasma parameters structure Example Usage IDL > check_plasma, inputs, grid, plasma Contents Source Code check_plasma.pro Source Code PRO check_plasma , inp , grid , plasma ; +#check_plasma ; + Checks if plasma paramters structure is valid ; +*** ; +## Input Arguments ; + **inputs**: Input structure ; + ; + **grid**: Interpolation grid structure ; + ; + **plasma**: Plasma parameters structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_plasma , inputs , grid , plasma ; + ``` err_status = 0 info , 'Checking plasma parameters...' nr = grid . nr nz = grid . nz w = where ( \"nphi\" eq strlowcase ( TAG_NAMES ( grid )), nw ) if nw eq 0 then begin info , '\"nphi\" is missing from the plasma, assuming axisymmetry' nphi = 1 endif else begin nphi = grid . nphi endelse zero_string = { dims : 0 , type : 'STRING' } zero_double = { dims : 0 , type : 'DOUBLE' } nrnznphi_double = { dims :[ nr , nz , nphi ], type : 'DOUBLE' } nrnznphi_int = { dims :[ nr , nz , nphi ], type : 'INT' } schema = { time : zero_double , $ vr : nrnznphi_double , $ vt : nrnznphi_double , $ vz : nrnznphi_double , $ dene : nrnznphi_double , $ denn : nrnznphi_double , $ ti : nrnznphi_double , $ te : nrnznphi_double , $ zeff : nrnznphi_double , $ mask : nrnznphi_int , $ data_source:zero_string } check_struct_schema , schema , plasma , err_status , desc = \"plasma parameters\" if err_status eq 1 then begin goto , GET_OUT endif if plasma . data_source eq '' then begin error , 'Invalid data source. An empty string is not a data source.' err_status = 1 endif ;; Electron density plasma . dene = plasma . dene > 0. ;[ 1 / cm&#94; 3 ] ;; Neutral density plasma . denn = plasma . denn > 0. ;[ 1 / cm&#94; 3 ] ;; Zeff plasma . zeff = plasma . zeff > 1.0 ;; Electron temperature plasma . te = plasma . te > 0. ;[ keV ] ;; Ion temperature plasma . ti = plasma . ti > 0. ;[ keV ] if abs ( plasma . time - inp . time ) gt 0.02 then begin warn , 'Plasma time and input time do not match' print , 'Input time: ' , inp . time print , 'Plasma time: ' , plasma . time endif plasma = create_struct ( plasma , grid ) GET_OUT : if err_status ne 0 then begin error , 'Invalid plasma parameters. Exiting...' , / halt endif else begin success , 'Plasma parameters are valid' endelse END","tags":"","loc":"sourcefile/check_plasma.pro.html","title":"check_plasma.pro – FIDASIM"},{"text":"xyz_to_uvw(alpha, beta, gamma, xyz, origin=[0,0,0]) Express rotated coordinate xyz in non-rotated uvw coordinates Arguments alpha : Rotation angle about z [radians] beta : Rotation angle about y' [radians] gamma : Rotation angle about x\" [radians] xyz : Point in rotated coordinate system Keyword Arguments origin : Origin of rotated coordinate system in non-rotated (uvw) coordinates. Example Usage IDL > uvw = xyz_to_uvw(!DPI / 2 , 0.0 ,!DPI / 3 ,xyz) Contents Source Code xyz_to_uvw.pro Source Code FUNCTION xyz_to_uvw , alpha , beta , gamma , xyz , origin = origin ; +## ` xyz_to_uvw ( alpha , beta , gamma , xyz , origin = [ 0 , 0 , 0 ]) ` ; + Express rotated coordinate ` xyz ` in non - rotated ` uvw ` coordinates ; +### Arguments ; + **alpha**: Rotation angle about z [ radians ] ; + ; + **beta**: Rotation angle about y ' [ radians ] ; + ; + **gamma**: Rotation angle about x \" [ radians ] ; + ; + **xyz**: Point in rotated coordinate system ; + ; +### Keyword Arguments ; + **origin**: Origin of rotated coordinate system in non - rotated ( uvw ) coordinates . ; + ; +### Example Usage ; + ``` idl ; + IDL > uvw = xyz_to_uvw (! DPI / 2 , 0.0 ,! DPI / 3 , xyz ) ; + ``` if not keyword_set ( origin ) then origin = [ 0.0 , 0.0 , 0.0 ] s = size ( xyz , / dim ) if n_elements ( s ) ne 2 then s = [ s , 1 ] xyz = transpose ( xyz ) ; Column Vector R = tb_zyx ( alpha , beta , gamma ) uvw = R ##xyz return , tranpose ( uvw ) + tile_array ( origin , 1 , s [ 1 ]) END","tags":"","loc":"sourcefile/xyz_to_uvw.pro.html","title":"xyz_to_uvw.pro – FIDASIM"},{"text":"tb_zyx Calculates Tait-Bryan z-y'-x\" active rotation matrix given rotation angles alpha , beta , gamma in radians Arguments alpha : rotation angle about z [radians] beta : rotation angle about y' [radians] gamma : rotation angle about x\" [radians] Return Value Rotation Matrix prefida Example Usage IDL > rot_mat = tb_zyx(!DPI / 2 , 0.0 , !DPI / 3 ) Contents Source Code tb_zyx.pro Source Code FUNCTION tb_zyx , a , b , g ; +#tb_zyx ; + Calculates Tait - Bryan z - y'-x\" active rotation matrix given rotation angles `alpha`,`beta`,`gamma` in radians ;+##Arguments ;+     **alpha**: rotation angle about z [radians] ;+ ;+     **beta**: rotation angle about y' [ radians ] ; + ; + **gamma**: rotation angle about x \" [ radians ] ; + ; +## Return Value ; + Rotation Matrix [ prefida ](| url | / sourcefile / prefida . pro . html ) ; + ; +## Example Usage ; + ``` idl ; + IDL > rot_mat = tb_zyx (! DPI / 2 , 0.0 , ! DPI / 3 ) ; + ``` sa = sin ( a ) & ca = cos ( a ) sb = sin ( b ) & cb = cos ( b ) sg = sin ( g ) & cg = cos ( g ) R = dblarr ( 3 , 3 ) R [ 0 , 0 ] = ca * cb & R [ 1 , 0 ] = ca * sb * sg - cg * sa & R [ 2 , 0 ] = sa * sg + ca * cg * sb R [ 0 , 1 ] = cb * sa & R [ 1 , 1 ] = ca * cg + sa * sb * sg & R [ 2 , 1 ] = cg * sa * sb - ca * sg R [ 0 , 2 ] = - sb & R [ 1 , 2 ] = cb * sg & R [ 2 , 2 ] = cb * cg return , R END","tags":"","loc":"sourcefile/tb_zyx.pro.html","title":"tb_zyx.pro – FIDASIM"},{"text":"write_equilibrium, filename, plasma, fields Write MHD equilibrium values to a HDF5 file Input Arguments filename : Name of the equilibrium file plasma : Plasma structure fields : Electromagnetic fields structure Example Usage IDL > write_equilibrium, filename, plasma, fields Contents Source Code write_equilibrium.pro Source Code PRO write_equilibrium , filename , plasma , fields ; +## ` write_equilibrium , filename , plasma , fields ` ; + Write MHD equilibrium values to a HDF5 file ; + ; +### Input Arguments ; + **filename**: Name of the equilibrium file ; + ; + **plasma**: Plasma structure ; + ; + **fields**: Electromagnetic fields structure ; + ; +### Example Usage ; + ``` idl ; + IDL > write_equilibrium , filename , plasma , fields ; + ``` info , 'Writing equilibrium file...' root_atts = { attribute , obj : '/' , $ name : 'description' , $ data : 'Plasma Parameters and Electromagnetic Fields for FIDASIM' } ;; Plasma Attributes plasma_desc = { attribute , obj : '/plasma' , $ name : 'description' , $ data : 'Plasma Parameters' } plasma_cs = { attribute , obj : '/plasma' , $ name : 'coordinate_system' , $ data : 'Cylindrical' } plasma_ds_desc = { attribute , obj : '/plasma/data_source' , $ name : 'description' , $ data : 'Source of the plasma parameters' } plasma_time_desc = { attribute , obj : '/plasma/time' , $ name : 'description' , $ data : 'Time' } plasma_time_unit = { attribute , obj : '/plasma/time' , $ name : 'units' , $ data : 's' } plasma_dene_desc = { attribute , obj : '/plasma/dene' , $ name : 'description' , $ data : 'Electron Number Density: Dene(r,z)' } plasma_dene_unit = { attribute , obj : '/plasma/dene' , $ name : 'units' , $ data : 'cm&#94;-3' } plasma_denn_desc = { attribute , obj : '/plasma/denn' , $ name : 'description' , $ data : 'Cold Neutral Number Density: Denn(r,z)' } plasma_denn_unit = { attribute , obj : '/plasma/denn' , $ name : 'units' , $ data : 'cm&#94;-3' } plasma_te_desc = { attribute , obj : '/plasma/te' , $ name : 'description' , $ data : 'Electron Temperature: Te(r,z)' } plasma_te_unit = { attribute , obj : '/plasma/te' , $ name : 'units' , $ data : 'keV' } plasma_ti_desc = { attribute , obj : '/plasma/ti' , $ name : 'description' , $ data : 'Ion Temperature: Ti(r,z)' } plasma_ti_unit = { attribute , obj : '/plasma/ti' , $ name : 'units' , $ data : 'keV' } plasma_zeff_desc = { attribute , obj : '/plasma/zeff' , $ name : 'description' , $ data : 'Effective Nuclear Charge: Zeff(r,z)' } plasma_vr_desc = { attribute , obj : '/plasma/vr' , $ name : 'description' , $ data : 'Bulk plasma flow in the r-direction: Vr(r,z)' } plasma_vr_unit = { attribute , obj : '/plasma/vr' , $ name : 'units' , $ data : 'cm/s' } plasma_vt_desc = { attribute , obj : '/plasma/vt' , $ name : 'description' , $ data : 'Bulk plasma flow in the theta/torodial-direction: Vt(r,z)' } plasma_vt_unit = { attribute , obj : '/plasma/vt' , $ name : 'units' , $ data : 'cm/s' } plasma_vz_desc = { attribute , obj : '/plasma/vz' , $ name : 'description' , $ data : 'Bulk plasma flow in the z-direction: Vz(r,z)' } plasma_vz_unit = { attribute , obj : '/plasma/vz' , $ name : 'units' , $ data : 'cm/s' } plasma_nr_desc = { attribute , obj : '/plasma/nr' , $ name : 'description' , $ data : 'Number of R values' } plasma_nz_desc = { attribute , obj : '/plasma/nz' , $ name : 'description' , $ data : 'Number of Z values' } plasma_r_desc = { attribute , obj : '/plasma/r' , $ name : 'description' , $ data : 'Radius' } plasma_r_unit = { attribute , obj : '/plasma/r' , $ name : 'units' , $ data : 'cm' } plasma_z_desc = { attribute , obj : '/plasma/z' , $ name : 'description' , $ data : 'Z' } plasma_z_unit = { attribute , obj : '/plasma/z' , $ name : 'units' , $ data : 'cm' } plasma_r2d_desc = { attribute , obj : '/plasma/r2d' , $ name : 'description' , $ data : 'Radius grid: R(r,z)' } plasma_r2d_unit = { attribute , obj : '/plasma/r2d' , $ name : 'units' , $ data : 'cm' } plasma_z2d_desc = { attribute , obj : '/plasma/z2d' , $ name : 'description' , $ data : 'Z grid: Z(r,z)' } plasma_z2d_unit = { attribute , obj : '/plasma/z2d' , $ name : 'units' , $ data : 'cm' } plasma_mask_desc = { attribute , obj : '/plasma/mask' , $ name : 'description' , $ data : 'Boolean mask that indicates where' + $ ' the plasma parameters are well defined' } plasma_atts = [ plasma_desc , plasma_cs , plasma_ds_desc , $ plasma_time_desc , plasma_time_unit , $ plasma_mask_desc , $ plasma_dene_desc , plasma_dene_unit , $ plasma_denn_desc , plasma_denn_unit , $ plasma_te_desc , plasma_te_unit , $ plasma_ti_desc , plasma_ti_unit , $ plasma_zeff_desc , $ plasma_vr_desc , plasma_vr_unit , $ plasma_vt_desc , plasma_vt_unit , $ plasma_vz_desc , plasma_vz_unit , $ plasma_nr_desc , plasma_nz_desc , $ plasma_r_desc , plasma_r_unit , $ plasma_z_desc , plasma_z_unit , $ plasma_r2d_desc , plasma_r2d_unit , $ plasma_z2d_desc , plasma_z2d_unit ] ;; Electromagnetic fields attributes fields_desc = { attribute , obj : '/fields' , $ name : 'description' , $ data : 'Electromagnetic Fields' } fields_cs = { attribute , obj : '/fields' , $ name : 'coordinate_system' , $ data : 'Cylindrical' } fields_ds_desc = { attribute , obj : '/fields/data_source' , $ name : 'description' , $ data : 'Source of the EM equilibrium' } fields_mask_desc = { attribute , obj : '/fields/mask' , $ name : 'description' , $ data : 'Boolean mask that indicates where' + $ ' the fields are well defined' } fields_time_desc = { attribute , obj : '/fields/time' , $ name : 'description' , $ data : 'Time' } fields_time_unit = { attribute , obj : '/fields/time' , $ name : 'units' , $ data : 's' } fields_br_desc = { attribute , obj : '/fields/br' , $ name : 'description' , $ data : 'Magnetic field in the r-direction: Br(r,z)' } fields_br_unit = { attribute , obj : '/fields/br' , $ name : 'units' , $ data : 'T' } fields_bt_desc = { attribute , obj : '/fields/bt' , $ name : 'description' , $ data : 'Magnetic field in the theta/torodial-direction: Bt(r,z)' } fields_bt_unit = { attribute , obj : '/fields/bt' , $ name : 'units' , $ data : 'T' } fields_bz_desc = { attribute , obj : '/fields/bz' , $ name : 'description' , $ data : 'Magnetic field in the z-direction: Bz(r,z)' } fields_bz_unit = { attribute , obj : '/fields/bz' , $ name : 'units' , $ data : 'T' } fields_er_desc = { attribute , obj : '/fields/er' , $ name : 'description' , $ data : 'Electric field in the r-direction: Er(r,z)' } fields_er_unit = { attribute , obj : '/fields/er' , $ name : 'units' , $ data : 'V/m' } fields_et_desc = { attribute , obj : '/fields/et' , $ name : 'description' , $ data : 'Electric field in the theta/torodial-direction: Et(r,z)' } fields_et_unit = { attribute , obj : '/fields/et' , $ name : 'units' , $ data : 'V/m' } fields_ez_desc = { attribute , obj : '/fields/ez' , $ name : 'description' , $ data : 'Electric field in the z-direction: Ez(r,z)' } fields_ez_unit = { attribute , obj : '/fields/ez' , $ name : 'units' , $ data : 'V/m' } fields_nr_desc = { attribute , obj : '/fields/nr' , $ name : 'description' , $ data : 'Number of R values' } fields_nz_desc = { attribute , obj : '/fields/nz' , $ name : 'description' , $ data : 'Number of Z values' } fields_r_desc = { attribute , obj : '/fields/r' , $ name : 'description' , $ data : 'Radius' } fields_r_unit = { attribute , obj : '/fields/r' , $ name : 'units' , $ data : 'cm' } fields_z_desc = { attribute , obj : '/fields/z' , $ name : 'description' , $ data : 'Z' } fields_z_unit = { attribute , obj : '/fields/z' , $ name : 'units' , $ data : 'cm' } fields_r2d_desc = { attribute , obj : '/fields/r2d' , $ name : 'description' , $ data : 'Radius grid: R(r,z)' } fields_r2d_unit = { attribute , obj : '/fields/r2d' , $ name : 'units' , $ data : 'cm' } fields_z2d_desc = { attribute , obj : '/fields/z2d' , $ name : 'description' , $ data : 'Z grid: Z(r,z)' } fields_z2d_unit = { attribute , obj : '/fields/z2d' , $ name : 'units' , $ data : 'cm' } fields_atts = [ fields_desc , fields_cs , fields_ds_desc , $ fields_mask_desc , $ fields_time_desc , fields_time_unit , $ fields_br_desc , fields_br_unit , $ fields_bt_desc , fields_bt_unit , $ fields_bz_desc , fields_bz_unit , $ fields_er_desc , fields_er_unit , $ fields_et_desc , fields_et_unit , $ fields_ez_desc , fields_ez_unit , $ fields_nr_desc , fields_nz_desc , $ fields_r_desc , fields_r_unit , $ fields_z_desc , fields_z_unit , $ fields_r2d_desc , fields_r2d_unit , $ fields_z2d_desc , fields_z2d_unit ] atts = [ root_atts , plasma_atts , fields_atts ] write_hdf5 ,[ \"plasma\" , \"fields\" ], filename = filename , atts = atts , / clobber if file_test ( filename ) then begin success , 'Equilibrium file created: ' + filename endif else begin error , 'Equilibrium file creation failed.' endelse END","tags":"","loc":"sourcefile/write_equilibrium.pro.html","title":"write_equilibrium.pro – FIDASIM"},{"text":"get_fidasim_dir Gets FIDASIM install directory Example Usage IDL > fida_dir = get_fidasim_dir() Contents Source Code get_fidasim_dir.pro Source Code FUNCTION get_fidasim_dir ; +#get_fidasim_dir ; + Gets FIDASIM install directory ; +*** ; + ; +## Example Usage ; + ``` idl ; + IDL > fida_dir = get_fidasim_dir () ; + ``` return , file_dirname ( file_dirname ( file_dirname ( source_file ()))) END","tags":"","loc":"sourcefile/get_fidasim_dir.pro.html","title":"get_fidasim_dir.pro – FIDASIM"},{"text":"Returns the source file of the routine name If name is not given then it returns the source file of caller routine Contents Source Code source_file.pro Source Code FUNCTION source_file , name ; + Returns the source file of the routine ` name ` ; + If name is not given then it returns the source file of caller routine if N_PARAMS () eq 0 then begin s = scope_traceback ( / structure ) nlevels = n_elements ( s ) sfile = s [ nlevels - 2 ]. filename return , file_expand_path ( sfile ) endif else begin help , / source_files , output = csf ; all compiled source files nc = n_elements ( csf ) for i = 2 , nc - 1 do begin has_name = stregex ( csf [ i ], name , / fold_case ) ne - 1 if has_name then begin sfile = stregex ( csf [ i ], \"(/[&#94;/ ]*)+/?$\" , / extract , / fold_case ) return , file_expand_path ( sfile ) endif endfor endelse return , '' END","tags":"","loc":"sourcefile/source_file.pro.html","title":"source_file.pro – FIDASIM"},{"text":"get_version Gets FIDASIM version number from git.\nFalls back to reading VERSION file when git is not available Input Arguments fidasim_dir : FIDASIM install directory Example Usage IDL > version = get_version( getenv ( \"FIDASIM_DIR\" )) Contents Source Code get_version.pro Source Code FUNCTION get_version , fidasim_dir ; +#get_version ; + Gets FIDASIM version number from git . ; + Falls back to reading VERSION file when git is not available ; +*** ; +## Input Arguments ; + **fidasim_dir**: FIDASIM install directory ; + ; +## Example Usage ; + ``` idl ; + IDL > version = get_version ( getenv ( \"FIDASIM_DIR\" )) ; + ``` version = '' git_dir = fidasim_dir+'/.git' if strcmp (! VERSION . OS_FAMILY , 'windows' , / fold_case ) then begin spawn , 'command -v git ' , git_command endif else begin spawn , 'command -v git ' , git_command , / sh endelse if file_test ( git_command ) and file_test ( git_dir , / dir ) then begin spawn , git_command+' --git-dir=' + git_dir+' describe --tags --always --dirty' , version , err_status endif else begin version_file = fidasim_dir+'/VERSION' version = '' if file_test ( version_file ) then begin openr , lun , version_file , / get_lun readf , lun , version free_lun , lun endif endelse return , version END","tags":"","loc":"sourcefile/get_version.pro.html","title":"get_version.pro – FIDASIM"},{"text":"colored Creates colored string Arguments str : String to be colored Keyword Arguments c : Foreground color code s : Style code Foreground Color Codes k : Black, r : Red, g : Green, y : Yellow, b : Blue, m : Magenta, c : Cyan, w : White Style Format Codes n : Normal, b : Bright, d : Dim, i : Italics, u : Underline, r : Reverse, h : Hidden, s : Strikethrough Return Value Colored string Example Usage IDL > blue_bright_hello = colored( \"Hello\" ,c = \"b\" ,s = \"b\" ) Contents Source Code colored.pro Source Code FUNCTION colored , str , c = c , s = s ; +#colored ; + Creates colored string ; +*** ; +## Arguments ; + **str**: String to be colored ; + ; +## Keyword Arguments ; + **c**: Foreground color code ; + ; + **s**: Style code ; + ; +### Foreground Color Codes ; + **k**: Black , ; + **r**: Red , ; + **g**: Green , ; + **y**: Yellow , ; + **b**: Blue , ; + **m**: Magenta , ; + **c**: Cyan , ; + **w**: White ; +### Style Format Codes ; + **n**: Normal , ; + **b**: Bright , ; + **d**: Dim , ; + **i**: Italics , ; + **u**: Underline , ; + **r**: Reverse , ; + **h**: Hidden , ; + **s**: Strikethrough ; +## Return Value ; + Colored string ; + ; +## Example Usage ; + ``` idl ; + IDL > blue_bright_hello = colored ( \"Hello\" , c= \"b\" , s= \"b\" ) ; + ``` if not keyword_set ( c ) then c='w' ;; Foreground Color if not keyword_set ( s ) then s='n' ;; Style esc = string ( 27 b ) back = esc+ \"[0m\" style = { n : '0' , b : '1' , d : '2' , i : '3' , u : '4' , r : '7' , h : '8' , s : '9' } sTags = [ \"n\" , \"b\" , \"d\" , \"i\" , \"u\" , \"r\" , \"h\" , \"s\" ] fgColors = { k : '30' , r : '31' , g : '32' , y : '33' , $ b : '34' , m : '35' , c : '36' , w : '37' } fgTags = [ \"k\" , \"r\" , \"g\" , \"y\" , \"b\" , \"m\" , \"c\" , \"w\" ] sIndex = where ( s eq sTags ) fgIndex = where ( c eq fgTags ) if sIndex eq - 1 then sIndex = 0 if fgIndex eq - 1 then fgIndex = 7 return , esc+ \"[\" + style .( sIndex ) + \";\" + fgColors .( fgIndex ) + \"m\" + str + back END","tags":"","loc":"sourcefile/colored.pro.html","title":"colored.pro – FIDASIM"},{"text":"nubeam_geometry Calculates the FIDASIM beam geometry from the beam geometry variables in the TRANSP/NUBEAM namelist Arguments NUBEAM : Structure containing the following NUBEAM.NAME : Ion source name NUBEAM.NBSHAP : Ion source shape 1=rectangular, 2=circular NUBEAM.FOCLZ : Vertical focal length [cm] NUBEAM.FOCLR : Horizontal focal length [cm] NUBEAM.DIVZ : Vertical divergence [rad] NUBEAM.DIVR : Horizontal divergence [rad] NUBEAM.BMWIDZ : Ion source half height [cm] NUBEAM.BMWIDR : Ion source half width [cm] NUBEAM.RTCENA : Radius of tangency point [cm] NUBEAM.XLBTNA : Distance from center of beam source grid to tangency point [cm] NUBEAM.XBZETA : Torodial angle [deg] Positive angles defined to be in the counter-clockwise direction NUBEAM.XYBSCA : Elevation above/below vacuum vessel midplane of center of beam source grid [cm] NUBEAM.NLJCCW : Orientation of Ip. 1 for True/Counter-clockwise current, 0 or -1 for False/Clock-wise current NUBEAM.NLCO : 1 for Co-beam, 0 or -1 for Counter-beam NUBEAM.NBAPSHA : Vector of aperture shapes 1=rectangular, 2=circular NUBEAM.XLBAPA : Vector of distances from center of beam source grid to the aperture plane [cm] NUBEAM.XYBAPA : Vector of elevation above/below vacuum vessel midplane of beam centerline at aperture [cm] NUBEAM.RAPEDGA : Vector of aperture half-widths [cm] NUBEAM.XZPEDGA : Vector of aperture half-heights [cm] NUBEAM.XRAPOFFA : Vector of horizontal (y) offsets relative to the +x aligned beam centerline [cm] NUBEAM.XZAPOFFA : Vector of vertical (z) offsets relative to the +x aligned beam centerline [cm] Keyword Arguments angle : Angle to add to XBZETA to rotate the beams into correct coordinates [deg] verbose : Print out positions plot : Plot the beam Return Value Neutral beam structure Example Usage IDL > nbi = nubeam_geometry(nubeam) Contents Source Code nubeam_geometry.pro Source Code FUNCTION nubeam_geometry , nubeam , angle = angle , verbose = verbose , plot = plot ; +#nubeam_geometry ; + Calculates the FIDASIM beam geometry from the beam geometry variables in the TRANSP / NUBEAM namelist ; +*** ; +## Arguments ; + ** NUBEAM **: Structure containing the following ; + ; + ** NUBEAM . NAME **: Ion source name ; + ; + ** NUBEAM . NBSHAP **: Ion source shape 1 = rectangular , 2 = circular ; + ; + ** NUBEAM . FOCLZ **: Vertical focal length [ cm ] ; + ; + ** NUBEAM . FOCLR **: Horizontal focal length [ cm ] ; + ; + ** NUBEAM . DIVZ **: Vertical divergence [ rad ] ; + ; + ** NUBEAM . DIVR **: Horizontal divergence [ rad ] ; + ; + ** NUBEAM . BMWIDZ **: Ion source half height [ cm ] ; + ; + ** NUBEAM . BMWIDR **: Ion source half width [ cm ] ; + ; + ** NUBEAM . RTCENA **: Radius of tangency point [ cm ] ; + ; + ** NUBEAM . XLBTNA **: Distance from center of beam source grid to tangency point [ cm ] ; + ; + ** NUBEAM . XBZETA **: Torodial angle [ deg ] Positive angles defined to be in the counter - clockwise direction ; + ; + ** NUBEAM . XYBSCA **: Elevation above / below vacuum vessel midplane of center of beam source grid [ cm ] ; + ; + ** NUBEAM . NLJCCW **: Orientation of Ip . 1 for True / Counter - clockwise current , 0 or - 1 for False / Clock - wise current ; + ; + ** NUBEAM . NLCO **: 1 for Co - beam , 0 or - 1 for Counter - beam ; + ; + ** NUBEAM . NBAPSHA **: Vector of aperture shapes 1 = rectangular , 2 = circular ; + ; + ** NUBEAM . XLBAPA **: Vector of distances from center of beam source grid to the aperture plane [ cm ] ; + ; + ** NUBEAM . XYBAPA **: Vector of elevation above / below vacuum vessel midplane of beam centerline at aperture [ cm ] ; + ; + ** NUBEAM . RAPEDGA **: Vector of aperture half - widths [ cm ] ; + ; + ** NUBEAM . XZPEDGA **: Vector of aperture half - heights [ cm ] ; + ; + ** NUBEAM . XRAPOFFA **: Vector of horizontal ( y ) offsets relative to the + x aligned beam centerline [ cm ] ; + ; + ** NUBEAM . XZAPOFFA **: Vector of vertical ( z ) offsets relative to the + x aligned beam centerline [ cm ] ; + ; +## Keyword Arguments ; + **angle**: Angle to add to XBZETA to rotate the beams into correct coordinates [ deg ] ; + ; + **verbose**: Print out positions ; + ; + **plot**: Plot the beam ; + ; +## Return Value ; + Neutral beam structure ; + ; +## Example Usage ; + ``` idl ; + IDL > nbi = nubeam_geometry ( nubeam ) ; + ``` if not keyword_set ( angle ) then angle = 0 if nubeam . nlco eq 0 then nubeam . nlco = - 1 if where ( tag_names ( nubeam ) eq 'NLJCCW' ) ge 0 then begin if nubeam . nljccw eq 0 then nubeam . nljccw = - 1 endif else begin warn , 'Current orientation not specified. Assuming Counter-clockwise.' nubeam = create_struct ( nubeam , 'NLJCCW' , 1 ) endelse phi_s= ( nubeam . XBZETA + angle ) * ! DPI / 180.0 zs = nubeam . XYBSCA za = nubeam . XYBAPA [ 0 ] alpha = asin (( zs - za ) / nubeam . XLBAPA [ 0 ]) pdst = nubeam . XLBTNA * cos ( alpha ) rs = sqrt ( nubeam . RTCENA &#94; 2.0 + pdst&#94; 2.0 ) dat = nubeam . XLBTNA - nubeam . XLBAPA [ 0 ] pdat = dat * cos ( alpha ) ra = sqrt ( nubeam . RTCENA &#94; 2.0 + pdat&#94; 2.0 ) beta_s = acos ( nubeam . RTCENA / rs ) beta_a = acos ( nubeam . RTCENA / ra ) phi_a = phi_s + nubeam . NLJCCW * nubeam . NLCO * ( beta_s - beta_a ) src = [ rs * cos ( phi_s ), rs * sin ( phi_s ), zs ] aper_src = [ ra * cos ( phi_a ), ra * sin ( phi_a ), za ] axis= ( aper_src - src ) axis = axis / sqrt ( total ( axis&#94; 2 )) pos = src + axis * nubeam . XLBTNA if keyword_set ( verbose ) then begin print , 'Source position: ' , src print , '1st Aperture position: ' , aper_src print , 'Tangency position: ' , pos endif if keyword_set ( plot ) then begin plot ,[ src [ 0 ], pos [ 0 ]],[ src [ 1 ], pos [ 1 ]] endif nbi = { data_source: \"TRANSP/NUBEAM namelist\" , name : nubeam . name , $ shape : nubeam . nbshap , src : src , axis : axis , $ focy : double ( nubeam . foclr ), focz : double ( nubeam . foclz ), $ divy : replicate ( double ( nubeam . divr ), 3 ), $ divz : replicate ( double ( nubeam . divz ), 3 ), $ widy : double ( nubeam . bmwidr ), widz : double ( nubeam . bmwidz ), $ naperture : fix ( n_elements ( nubeam . nbapsha )), ashape : nubeam . nbapsha , $ awidy : double ( nubeam . rapedga ), awidz : double ( nubeam . xzpedga ), $ aoffy : double ( nubeam . xrapoffa ), aoffz : double ( nubeam . xzapoffa ), $ adist : double ( nubeam . xlbapa ) } return , nbi END","tags":"","loc":"sourcefile/nubeam_geometry.pro.html","title":"nubeam_geometry.pro – FIDASIM"},{"text":"error Print a error message Arguments str : message Keyword Arguments halt : Halt program execution Example Usage IDL > error, \"=(\" Contents Source Code error.pro Source Code PRO error , str , halt = halt ; +#error ; + Print a error message ; +*** ; +## Arguments ; + **str**: message ; + ; +## Keyword Arguments ; + **halt**: Halt program execution ; + ; +## Example Usage ; + ``` idl ; + IDL > error , \"=(\" ; + ``` if keyword_set ( halt ) then begin message , colored ( str , c='r' ), level=- 1 endif else begin print , colored ( 'ERROR: ' + str , c='r' ) endelse END","tags":"","loc":"sourcefile/error.pro.html","title":"error.pro – FIDASIM"},{"text":"vars_to_struct Creates a structure containing the variables in the callers scope Keyword Arguments vars : List of variables to store in the output structure. Defaults to all variables in the callers scope. level : Relative scope. Defaults to the callers scope (-1) Return Value Structure containing variables from the callers scope Example Usage IDL > a = 1 IDL > b = \"hello\" IDL > s = vars_to_struct() ; structure containing `a` & `b` Contents Source Code vars_to_struct.pro Source Code FUNCTION vars_to_struct , vars = vars , level = level ; +#vars_to_struct ; + Creates a structure containing the variables in the callers scope ; + ; +## Keyword Arguments ; + **vars**: List of variables to store in the output structure . Defaults to all variables in the callers scope . ; + ; + **level**: Relative scope . Defaults to the callers scope ( - 1 ) ; + ; +## Return Value ; + Structure containing variables from the callers scope ; + ; +## Example Usage ; + ``` idl ; + IDL > a = 1 ; + IDL > b = \"hello\" ; + IDL > s = vars_to_struct () ; structure containing ` a ` & ` b ` ; + ``` if not keyword_set ( level ) then level=- 1 if not keyword_set ( vars ) then vars = scope_varname ( level = level ) nvars = n_elements ( vars ) for i = 0 , nvars - 1 do begin catch , err_status if err_status ne 0 then begin catch , / cancel continue endif var = scope_varfetch ( vars [ i ], level = level ) if n_elements ( var ) ne 0 then begin if i eq 0 then begin s = create_struct ( vars [ i ], var ) endif else begin s = create_struct ( s , vars [ i ], var ) endelse endif endfor if nvars eq 1 and size ( s .( 0 ), / tname ) eq 'STRUCT' then begin s = s .( 0 ) endif return , s END","tags":"","loc":"sourcefile/vars_to_struct.pro.html","title":"vars_to_struct.pro – FIDASIM"},{"text":"check_spec Check if spectral geometry structure is valid Input Arguments inputs : input structure chords : spectral geometry structure Example Usage IDL > check_spec, inputs, chords Contents Source Code check_spec.pro Source Code PRO check_spec , inp , chords ; +#check_spec ; + Check if spectral geometry structure is valid ; +*** ; +## Input Arguments ; + **inputs**: input structure ; + ; + **chords**: spectral geometry structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_spec , inputs , chords ; + ``` err_status = 0 info , 'Checking FIDA/BES inputs...' w = where ( \"nchan\" eq strlowcase ( TAG_NAMES ( chords )), nw ) if nw eq 0 then begin error , '\"nchan\" is missing from the FIDA/BES geometry' err_status = 1 goto , GET_OUT endif nchan = chords . nchan zero_string = { dims : 0 , type : 'STRING' } zero_long = { dims : 0 , type : 'LONG' } nchan_double = { dims :[ nchan ], type : 'DOUBLE' } nchan_string = { dims :[ nchan ], type : 'STRING' } schema = { data_source:zero_string , $ nchan : zero_long , $ system : zero_string , $ id : nchan_string , $ lens :{ dims :[ 3 , nchan ], type : 'DOUBLE' }, $ axis :{ dims :[ 3 , nchan ], type : 'DOUBLE' }, $ sigma_pi:nchan_double , $ spot_size:nchan_double , $ radius : nchan_double } check_struct_schema , schema , chords , err_status , desc= \"FIDA/BES geometry\" if err_status eq 1 then begin goto , GET_OUT endif err_arr = intarr ( nchan ) cross_arr = intarr ( nchan ) uvw_lens = chords . lens uvw_axis = chords . axis ;; ROTATE CHORDS INTO BEAM GRID COORDINATES xyz_lens = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma , uvw_lens , origin = inp . origin ) xyz_axis = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma , uvw_axis ) ;; Calculate grid center rc and sides length dr dr = [ inp . xmax - inp . xmin , inp . ymax - inp . ymin , inp . zmax - inp . zmin ] rc = [ inp . xmin , inp . ymin , inp . zmin ] + 0.5 * dr for i = 0 , nchan - 1 do begin chan_str = strcompress ( string ( i ), / remove_all ) if abs ( total ( uvw_axis [ * , i ] &#94; 2.0 ) - 1.0 ) gt 1 d - 5 then begin error , 'Invalid optical axis for chord \"' + chords . id [ i ] +'\". Expected norm(axis) == 1' print , total ( uvw_axis [ * , i ] &#94; 2.0 ) - 1.0 err_arr [ i ] = 1 endif ;; Check if viewing chord intersects beam grid aabb_intersect , rc , dr , xyz_lens [ * , i ], xyz_axis [ * , i ], length , r_enter , r_exit if length le 0.0 then begin warn , 'Chord \"' + chords . id [ i ] +'\" does not cross the beam grid' cross_arr [ i ] = 1 endif endfor w = where ( cross_arr eq 0.0 , nw , complement = ww , ncomplement = nww ) print , f='(i3,\" out of \",i3,\" chords crossed the beam grid\")' , nw , nchan if nw eq 0 then begin error , 'No channels intersect the beam grid' err_status = 1 endif GET_OUT : if err_status ne 0 then begin error , 'Invalid FIDA/BES geometry. Exiting...' , / halt endif else begin success , 'FIDA/BES geometry is valid' endelse END","tags":"","loc":"sourcefile/check_spec.pro.html","title":"check_spec.pro – FIDASIM"},{"text":"write_hdf5 Writes HDF5 files from variables in the local scope or a structure Arguments vars : List of variables or a structure Keyword Arguments atts : Attributes to write filename : Filename of output HDF5 file clobber : Overwrite exisiting HDF5 file compress : Compression level(0-9). Defaults to 9 Example Usage IDL > a = [ 1 , 2 , 3 ]\nIDL > write_hdf5, \"a\" ,atts = {attribute,obj : \"/a\" ,name : \"description\" ,data : \"example variable\" }\nIDL > s = {a : 1 ,b : {a : 2 }}\nIDL > write_hdf5,s, / clobber Contents Source Code write_hdf5.pro Source Code FUNCTION vars_to_struct , vars = vars , level = level ;; struct_from_list ;; creates structure from list of variables in specified scope ;; if vars not set then use all valid variables in specified scope if not keyword_set ( level ) then level=- 1 if not keyword_set ( vars ) then vars = scope_varname ( level = level ) nvars = n_elements ( vars ) for i = 0 , nvars - 1 do begin catch , err_status if err_status ne 0 then begin catch , / cancel continue endif var = scope_varfetch ( vars [ i ], level = level ) if n_elements ( var ) ne 0 then begin if i eq 0 then begin s = create_struct ( vars [ i ], var ) endif else begin s = create_struct ( s , vars [ i ], var ) endelse endif endfor if nvars eq 1 and size ( s .( 0 ), / tname ) eq 'STRUCT' then begin s = s .( 0 ) endif return , s END PRO hdf5_write_struct , id , struct , compress = compress ntags = n_tags ( struct ) if ntags eq 0 then goto , GET_OUT if not keyword_set ( compress ) then compress = 9 tags = strlowcase ( TAG_NAMES ( struct )) for i = 0 , ntags - 1 do begin var = struct .( i ) varInfo = size ( var , / structure ) typeName = varInfo . type_name if typeName eq 'STRUCT' then begin gid = h5g_create ( id , tags [ i ]) hdf5_write_struct , gid , var , compress = compress h5g_close , gid endif else begin data = var ndim = size ( data , / n_dim ) dims = size ( data , / dim ) if ndim eq 0 L then begin datatype_id = h5t_idl_create ( data ) dataspace_id = h5s_create_scalar () dataset_id = h5d_create ( id , tags [ i ], datatype_id , dataspace_id ) endif else begin if size ( data , / tname ) eq \"STRING\" then begin strmax = max ( strlen ( data ), nw ) datatype_id = h5t_idl_create ( data [ nw ]) endif else begin datatype_id = h5t_idl_create ( data ) endelse dataspace_id = h5s_create_simple ( dims ) dataset_id = h5d_create ( id , tags [ i ], datatype_id , dataspace_id , $ chunk_dimensions = dims , gzip = compress , / shuffle ) endelse h5d_write , dataset_id , data h5d_close , dataset_id h5s_close , dataspace_id h5t_close , datatype_id endelse endfor GET_OUT : END FUNCTION valid_attribute , att tags = [ \"obj\" , \"name\" , \"data\" ] att_tags = strlowcase ( TAG_NAMES ( att )) is_valid = 1 for i = 0 , n_elements ( tags ) - 1 do begin w = where ( tags [ i ] eq att_tags , nw ) if nw eq 0 then begin print , 'ERROR: Structure tag \"' + tags [ i ] +'\" missing from attribute definition' is_valid = 0 endif endfor if is_valid eq 0 then begin help , att goto , GET_OUT endif value_info = size ( att . data , / structure ) if value_info . type_name eq 'STRUCT' then begin print , 'ERROR: attribute value cannot be a structure' is_valid = 0 endif GET_OUT : return , is_valid END PRO hdf5_write_att_data , id , name , data data_info = size ( data , / structure ) type_name = data_info . type_name if type_name eq 'STRING' then begin value = strjoin ( data , \", \" , / single ) endif else begin value = data endelse dims = size ( value , / dim ) ndims = size ( value , / n_dim ) datatype_id = h5t_idl_create ( value ) if ndims eq 0 L then begin dataspace_id = h5s_create_scalar () endif else begin dataspace_id = h5s_create_simple ( dims ) endelse att_id = h5a_create ( id , name , datatype_id , dataspace_id ) h5a_write , att_id , value h5a_close , att_id END PRO hdf5_write_attributes , id , atts natts = n_elements ( atts ) for i = 0 , natts - 1 do begin if not valid_attribute ( atts [ i ]) then continue object_info = h5g_get_objinfo ( id , atts [ i ]. obj ) CASE object_info . type OF 'LINK': print , 'ERROR: Can not handle an attribute of a reference' 'GROUP': BEGIN gid = h5g_open ( id , atts [ i ]. obj ) hdf5_write_att_data , gid , atts [ i ]. name , atts [ i ]. data h5g_close , gid END 'DATASET': BEGIN did = h5d_open ( id , atts [ i ]. obj ) hdf5_write_att_data , did , atts [ i ]. name , atts [ i ]. data h5d_close , did END 'TYPE': BEGIN tid = h5t_open ( id , atts [ i ]. obj ) hdf5_write_att_data , tid , atts [ i ]. name , atts [ i ]. data h5t_close , tid END ELSE : print , 'ERROR: Unknown object' ENDCASE endfor END PRO write_hdf5 , vars , atts = atts , filename = filename , clobber = clobber , compress = compress ; +#write_hdf5 ; + Writes HDF5 files from variables in the local scope or a structure ; +*** ; +## Arguments ; + **vars**: List of variables or a structure ; + ; +## Keyword Arguments ; + **atts**: Attributes to write ; + ; + **filename**: Filename of output HDF5 file ; + ; + **clobber**: Overwrite exisiting HDF5 file ; + ; + **compress**: Compression level ( 0 - 9 ). Defaults to 9 ; + ; +## Example Usage ; + ``` idl ; + IDL > a = [ 1 , 2 , 3 ] ; + IDL > write_hdf5 , \"a\" , atts= { attribute , obj : \"/a\" , name : \"description\" , data : \"example variable\" } ; + IDL > s = { a : 1 , b :{ a : 2 }} ; + IDL > write_hdf5 , s , / clobber ; + ``` if not keyword_set ( filename ) then filename = 'idlsave.h5' if file_test ( filename ) and not keyword_set ( clobber ) then begin print , \"File already exists. Use clobber keyword to overwrite\" goto , GET_OUT endif if not keyword_set ( compress ) then compress = 9 nvars = n_elements ( vars ) if nvars eq 0 then goto , GET_OUT type = size ( vars , / tname ) if type ne 'STRUCT' and type ne 'STRING' then begin print , \"Invalid argument type. Expected STRING or STRUCT\" print , type goto , GET_OUT endif if nvars ne 1 and type eq 'STRUCT' then begin print , \"Invalid argument type. Arrays of structs not permitted\" goto , GET_OUT endif if nvars eq 1 and type eq 'STRUCT' then begin var_struct = vars endif else begin var_struct = vars_to_struct ( vars = vars , level=- 2 ) end file_id = h5f_create ( filename ) hdf5_write_struct , file_id , var_struct , compress = compress if keyword_set ( atts ) then begin hdf5_write_attributes , file_id , atts endif h5f_close , file_id GET_OUT : END","tags":"","loc":"sourcefile/write_hdf5.pro.html","title":"write_hdf5.pro – FIDASIM"},{"text":"tile_array(arr, ncol, nrow) Creates a tiled matrix out of an array or matrix Arguments arr : Array or Matrix of size (nx,ny) to be tiled ncol : Number of columns in the tile nrow : Number of rows in the tile Return Value Tiled array of size (ncol nx,nrow ny) Example Usage IDL > arr = indgen ( 2 , 2 )\nIDL > print , arr 0 1 2 3 IDL > tiled_arr = tile_array(arr, 2 , 2 )\nIDL > print , tiled_arr 0 1 0 1 2 3 2 3 0 1 0 1 2 3 2 3 Contents Source Code tile_array.pro Source Code FUNCTION tile_array , arr , ncol , nrow ; +## ` tile_array ( arr , ncol , nrow ) ` ; + Creates a tiled matrix out of an array or matrix ; +### Arguments ; + **arr**: Array or Matrix of size ( nx , ny ) to be tiled ; + ; + **ncol**: Number of columns in the tile ; + ; + **nrow**: Number of rows in the tile ; + ; +### Return Value ; + Tiled array of size ( ncol * nx , nrow * ny ) ; + ; +### Example Usage ; + ``` idl ; + IDL > arr = indgen ( 2 , 2 ) ; + IDL > print , arr ; + 0 1 ; + 2 3 ; + IDL > tiled_arr = tile_array ( arr , 2 , 2 ) ; + IDL > print , tiled_arr ; + 0 1 0 1 ; + 2 3 2 3 ; + 0 1 0 1 ; + 2 3 2 3 ; + ``` s = size ( arr , / dim ) if n_elements ( s ) eq 1 then s = [ s , 1 ] new_arr = make_array ( s [ 0 ] * ncol , s [ 1 ] * nrow , type = size ( arr , / type )) new_arr [ 0 , 0 ] = arr if nrow gt 1 then begin for i = 1 , nrow - 1 do begin new_arr [ 0 , i * s [ 1 ]] = arr endfor endif if ncol gt 1 then begin rarr = new_arr [ 0 :s [ 0 ] - 1 , * ] for j = 1 , ncol - 1 do begin new_arr [( j * s [ 0 ]), 0 ] = rarr endfor endif return , new_arr END","tags":"","loc":"sourcefile/tile_array.pro.html","title":"tile_array.pro – FIDASIM"},{"text":"If the input string variable is equal to one of IDL's reserved\nwords, replace it with a similar name with an underscore\nat the end. Contents Source Code read_nl.pro Source Code ; 9 / 12 / 2016 ; ************************************************************************ ; + ; NAME : ; READ_NL ; ; PURPOSE : ; Reads Fortran style namelists , returns data as a structure . ; ; CATEGORY : ; I / O ; ; CALLING SEQUENCE : ; result = read_nl ( filename ) ; ; INPUTS : ; filename - the name of a Fortran namelist file . ; ; KEYWORD PARAMETERS : ; DBL - returns double precision floating point . Default is ; float . ; MODEL - if a ; structure is passed in with the keyword \"model\" that is the ; structure used as the starting point for the structure which will ; be returned by this function . Data in the namelist file are added to ; this structure or used to overwrite data already in the ; structure . This model can be used to define an array . Then , ; entries in the namelist that only modify certain array elements ; can exist without the array having been previously defined at its ; full size somewhere else in the namelist . ; ERROR - returned equal to 0 unless the file cannot be opened ; in which case 1 is returned . ; ; OUTPUTS : ; An IDL structure . The HEADER tagname includes lines ( usually ; description ) in the file before the first namelist . Each namelist ; is a sub - structure . The namelist name and variable names appear ; as the tagnames . If the number of varilabes of one namelist ; exceeds maximum tags ( 251 ) allowed in an IDL structure , the namelist ; will be split into two sub - structures ( the second has _ ext attached ; to the tagname ). ; ; COMMON BLOCKS : ; None . ; ; SIDE EFFECTS : ; ; RESTRICTIONS : ; ; PROCEDURE : ; ; EXAMPLE : ; ; HISTORY : ; 02 - 12 - 96 B . Rice - created ; ?? - change the line b = strarr ( 8000 ) to handle larger files ; - each namelist structure is limited to 251 tag names , ; additional names will be put in a separate _ ext namelist ; - quotes are left on strings to distinguish from boolean ; variables ; 08 - 25 - 98 - IDL 5.1 allows more than 128 tag names , so code has been ; modified to take advantage of this . Tag_name limit has ; been increased to 251 ; 10 - 09 - 97 - changed reading of strings to preserve white space ; - also , embedded commas and double quotes '' are preserved ; 05 - 31 - 99 QP - fixed a bug that caused infinite looping when parameters ; are separated by ',' instead of ' ' . ; 09 - 12 - 00 JRF expand the capability to specify values for certain ; elements of an array . First , the format y ( 1 ) = 0.0 is allowed ; ; i . e . there can be spaces within the parentheses . Second , if a ; structure is passed in with the keyword \"model\" that is the ; structure used initially . Data in the namelist file are added to ; this structure or used to overwrite data already in the ; structure . This model can be used to define an array . Then , ; entries in the namelist that only modify certain array elements ; can exist without the array having been previously defined at its ; full size somewhere else in the namelist . ; Finally , the array can be multidimensional . This is ; only possible if the array is previously defined multidimensional ; in the model . Up to 3 dimensions are allowed . The format , for ; example , y ( 1 , 1 ) = 0.0 can be used . ; ; Also , a bug was fixed : the array element number should match ; Fortran style with element numbers ; starting at 1. Previously , if element \"1\" ; was specified , the second element of the ; array was modified . ; ; Also , an empty namelist is handled . ; Also , lines beginning with an exclamation point (!) are ; ignored . These are comment lines . ; 08 - 01 - 02 QP - F90 on HP generates namelist using ( &name , / ) instead of ; the old ( $ name , $ end ), also strings are not in quotes ; ; Modified to read both the old and new format . ; 08 - 23 - 02 QP - For F90 namelist , get rid of lines after the last / , ; the old style did it naturally with splitting around $ . ; 08 - 26 - 02 QP - convert array [ 1 ] to scalar after str_sep ( sd ,...). In IDL5 .5 , ; struct . array [ 1 ] is not treated as scalar as in 5.4 thus ; needs be subscripted to be used as a scalar . ; 03 - 18 - 03 QP - fixed a bug that removed one char from the last var instead ; of the intended last '/' . ; 06 - 05 - 03 QP - made it compatiable with Linux F90 namelist where all vars ; in one namelist are concatenated into one line . ; 06 - 09 - 03 QP - fixed bugs introduced last time ; 10 - 01 - 04 QP - fixed a bug that read 1 e - 8 as 1 ( checked '.' only for float ) ; now check both '.' and 'e'/'E' ; 06 - 17 - 05 QP - for tag name with parentheses , if it is in form of name ( 1 ), ; strip out ( 1 ), otherwise , encode using ; create_struct_h ; 02 - 10 - 06 JRF - In new format namelists which end with a / , ; allow for the possibility that there are characters ; following the /. Apparently , some compilers allow ; the namelist name to be there . ; Comment out the debug printout : ; print , 'converting ' , origparam , ' to ' , param ; 02 - 14 - 06 JRF - Handle the case where the file isn't empty but ;                  there is no namelist in the file. Also, fix a bug ;                  that occurred when a namelist entry like \"name = 1\" ;                  was encountered when the output structure already had a ;                  tag \"name\" and that tag was an array.  The namelist ;                  entry should assign the value to the first element ;                  of the array.  However, because of the way IDL ;                  treats assignment to an array in a structure, all ;                  elements of the array were being altered. ;   08-4-06 JRF - Remove the conversion of the file text to lower ;                  case that was being done at the initial file read. ;                  This conversion was changing strings.  Then, when ;                  determining if a value is boolean, do the ;                  comparison in lower case so that, for instance, ;                  both t and T are allowed. ;   02-9-07 JRF - Merge the versions of this file from the PCS and ;                 hydra. This was done by adding the 08-4-06 change to ;                 the PCS version. ;                 Added the ERROR keyword to return a flag if the file ;                 cannot be opened. ;   10-8-07 JRF - 1. Add the comment_character keyword which works as follows: ;                 By default, any lines beginning with an ;                 exclamation point are ignored (this default behavior ;                 is retained for backward compatibility). In ;                 addition, the comment_character keyword can be set ;                 equal to a string with a single character.  This ;                 character is treated as a comment character. The ;                 portions of a line following this ;                 character are ignored. However, if the comment ;                 character is between quotes or apostrophes then it ;                 is ignored. ;                 2. If the keyword print_tokens is set, some ;                 debugging information is printed.  As the code ;                 processes the characters in the namelist file it ;                 splits the characters into strings separated by ;                 equals signs.  This keyword causes the individual ;                 strings to be printed as each one is processed. ;                 When the code chokes on some unexpected new format, ;                 this keyword allows the problem string to be identified. ; ;                 Fix a bunch of bugs: ;                 1.  The \"header\" was always being returned as a null ;                 string.  Now, the header will be a string array ;                 containing the lines in the namelist file that ;                 precede the first line that begins a namelist. ;                 2.  The length of each namelist was being limited to ;                 100000 characters.  There wasn't any fundamental ; reason for this and this limitation was removed . ; 3. The code that determined whether a namelist ; contained more than 250 variables was confused by ; multiple references to the same variable in the ; namelist file . This was corrected . ; ; Add some comments to the code . ; 4 - 15 - 08 JRF - In the function quoted_reverse_find , replaced the ; function rstrpos with strpos (..., / reverse_search ). ; The function rstrpos seemed to be choking on long ; strings ( e . g . the problem occurred on a string with ; more than 203000 characters ). The IDL documentation ; says that rstrpos is obsolete anyway . ; 4 - 21 - 09 JRF - Define n_line as a long so that the number of lines ; in the file can be larger than the largest positive ; value an integer variable can hold . ; 9 - 02 - 09 JRF - Added the keyword line_count_estimate . This value can ; be an estimate of the number of lines that are in ; the namelist file that needs to be read . The value ; is used to initialize an array of strings that will ; hold each of the lines in the file . If this keyword ; is not specified , the default value is 8000. If the ; file contains significantly more than 8000 lines the ; process of reading the file goes very slowly . The ; file will be read much more quickly if the initial ; array of strings is close to or larger than is ; necessary to hold ; the file . So , if it is expected that the input ; namelist file will have significantly more than 8000 ; lines , use this keyword . ; 2 - 21 - 12 JRF - In a case where the input is a string variable , ; allow for a repeat count ( e . g . 6 *'test' ). ; 6 - 16 - 15 JRF - Fix a couple of issues that were revealed by quirks ; in a particular namelist file . ; 1. Handle the case where the last character in a ; line of values is not a comma or a space and the ; next line in the file begins in the first column . ; 2. Handle the case where there are tab characters ; following the name of the first namelist . ( Now ; tab characters will be removed from all lines of ; the file before processing ( except for the ; header ), replaced by a space if necessary . ; 9 - 12 - 16 JRF - IDL gets very unhappy if an attempt is made to ; assign a tag name in a structure to one of IDL 's ;                 reserved words (e.g.'ne'). Similarly to what is done ;                 in read_nc.pro, if a tag name needs to be equal to ;                 one of the reserved words, add one an ;                 underscore to the end of the tag in order to avoid ;                 conflict with the reserved word and with any other ;                 tags in the structure. ; ; ;- ;************************************************************************ ;If the input string variable is equal to one of IDL's reserved ; words , replace it with a similar name with an underscore ; at the end . ; function replace_reserved , name new_name = name switch strupcase ( name ) of 'AND': 'BEGIN': 'BREAK': 'CASE': 'COMMON': 'COMPILE_OPT': 'CONTINUE': 'DO': 'ELSE': 'END': 'ENDCASE': 'ENDELSE': 'ENDFOR': 'ENDIF': 'ENDREP': 'ENDSWITCH': 'ENDWHILE': 'EQ': 'FOR': 'FORWARD_FUNCTION': 'FUNCTION': 'GE': 'GOTO': 'GT': 'IF': 'INHERITS': 'LE': 'LT': 'MOD': 'NE': 'NOT': 'OF': 'ON_IOERROR': 'OR': 'PRO': 'REPEAT': 'SWITCH': 'THEN': 'UNTIL': 'WHILE': 'XOR': begin new_name = name + '_' break end endswitch return , new_name end PRO nl_remove_comments , input , comment_character , output ; ; From the string \"input\" , remove all characters that follow the first ; instance of the character specified by comment_character . However , any ; instances of comment_character between quotes or apostrophes are ignored . start = 0 length = strlen ( input ) quote_started = 0 apostrophe_started = 0 WHILE ( 1 ) DO BEGIN IF ( start EQ length ) THEN BEGIN output = input return ENDIF a = strmid ( input , start , 1 ) IF ( ( a EQ comment_character ) AND ( quote_started EQ 0 ) AND $ ( apostrophe_started EQ 0 )) THEN BEGIN output = strmid ( input , 0 , start ) return ENDIF ELSE IF ( a EQ '\"' ) THEN BEGIN IF ( quote_started EQ 0 ) THEN BEGIN quote_started = 1 ENDIF ELSE BEGIN quote_started = 0 ENDELSE ENDIF ELSE IF ( a EQ \"'\" ) THEN BEGIN IF ( apostrophe_started EQ 0 ) THEN BEGIN apostrophe_started = 1 ENDIF ELSE BEGIN apostrophe_started = 0 ENDELSE ENDIF start = start + 1 ENDWHILE return END FUNCTION quoted_reverse_find , string , target ; This function calls rstrpos , but , if the string searched for ; is located between a pair of parentheses , it is ignored and the ; next target string is located . We assume here that there is only ; one pair of parentheses at most . ; length = strlen ( string ) i = strpos ( string , target , / reverse_search ) k1 = strpos ( string , \")\" , / reverse_search ) k2 = strpos ( string , \"(\" , / reverse_search ) IF ( ( k1 NE - 1 ) AND ( k2 NE - 1 ) ) THEN BEGIN IF ( ( i GT k2 ) AND ( i LT k1 ) ) THEN BEGIN substring = strmid ( string , 0 , k2 ) i = strpos ( substring , target , / reverse_search ) ENDIF ENDIF return , i END function read_nl , fname , dbl = dbl , debug = debug , model = model , error = error_out , $ comment_character = comment_character_in , $ print_tokens = print_tokens , $ line_count_estimate = line_count_estimate dbl = keyword_set ( dbl ) x='' error_out = 0 if ( keyword_set ( debug )) then error = 0 else catch , error if ( error ne 0 ) then begin message , / info , 'Error reading namelist file: ' + fname message , / info ,! ERROR_STATE . msg message , / info ,! ERROR_STATE . sys_msg if ( n_elements ( lun ) gt 0 ) then free_lun , lun return , x endif k = file_search ( fname , count = count ) if count eq 0 then begin if ( keyword_set ( debug )) then print , 'File not found: ' + fname error_out = 1 return , x endif openr , lun , fname , / get_lun ; ; Read the file and create a string array with one element per line in ; the file . The initial array size of nmax is just an initial ; allocation . If file is longer than this number of lines , the array ; will be extended . ; if ( n_elements ( line_count_estimate ) ne 0 ) then begin nmax = line_count_estimate endif else begin nmax = 8000 ; assume < 8000 lines endelse b = strarr ( nmax ) n_line = long ( 0 ) oneline='' ; ; By default , ignore any lines beginning with an exclamation point ; ( this default behavior is retained for backward compatibility ). ; In addition , if the comment_character ; keyword is specified , ignore the portions ; of a line following the specified comment character . ; while ( not ( eof ( lun ))) do begin readf , lun , oneline IF ( n_elements ( comment_character_in ) NE 0 ) THEN BEGIN FOR i = 0 , n_elements ( comment_character_in ) - 1 DO begin nl_remove_comments , oneline , comment_character_in [ i ], oneline ENDFOR ENDIF IF ( strpos ( oneline , \"!\" ) ne 0 ) THEN begin if ( n_line lt nmax ) then $ b [ n_line ] = oneline else b = [ b , oneline ] n_line = n_line + 1 ENDIF endwhile free_lun , lun if ( n_line eq 0 ) then message , 'empty namelist file' ; b = strlowcase ( b [ 0 :n_line - 1 ]) ; Find the first line that starts a namelist . Any lines prior to this ; line are returned as the header . istart = min ( where ( strpos ( b , '$' ) ne - 1 )) if istart eq - 1 then begin ; f90 namelist istart = min ( where ( strpos ( b , '&' ) ne - 1 )) if ( istart ne - 1 ) then begin index = where ( strcompress ( b , / remove ) eq '/' , count ) if count ne 0 then n_line = index [ count - 1 ] + 1 ; will rm lines after last / endif endif if ( istart eq - 1 ) then message , 'File does not contain a namelist.' IF ( istart GT 0 ) THEN header = b [ 0 :istart - 1 ] ELSE header = '' ; ; Concatenate all of the lines into a single string beginning with the ; first line that starts a namelist . For economy of storage , compress ; blocks of white space except in lines that contain a string ; variable . ; ; Treat the \"new line\" character at the end of every line as white ; space by adding a space at the end of every line . The compression ; operation will take out this space if it is not needed . However , ; the space will be useful to make certain that lines that begin in the ; first column are separated from the previous line . ( Without this , the ; code that handles an array of strings can get into an infinite loop ; if the line previous to the string array doesn't end in a comma and ; the next line begins in the first column.) ; s = strcompress(b(istart)) for i=istart+1,n_line-1 DO BEGIN ;put all lines into one string IF (strpos(b[i],\"' \") EQ -1) THEN s=s+strcompress(b(i) + ' ')  $ ELSE s = s+b(i) + ' ' endfor ; ; Separate the single string into an array of strings, one for each ; namelist.  In the process, the dollar sign or ampersand that begins ; the namelist is removed and the $end or / that ends the namelist is ; also removed. Determine the count of namelists. ; s=strtrim(s,2)               ;remove leading and trailing blanks s=str_sep(s,'$')             ;separate into namelists if n_elements(s) eq 1 then begin s=str_sep(s,'&') \t\t;f90 namelist on HP newnl = 1 endif else newnl = 0 if not newnl then begin nl=(n_elements(s)-1)/2    ;number of lists w=indgen(nl)*2+1 s=s(w)                    ;remove $end from string array s=strtrim(s,2) endif else begin \t\t;f90 namelist on HP nl=n_elements(s)-1\t;number of lists s=s[1:nl]\t\t\t;remove initial string which should be null s=strtrim(s,2) for i=0,nl-1 do begin\t;remove / and any following characters ;from the end of each namelist ;string. Apparently some compilers ;accept ;the namelist name after the /. temp = strpos(s[i],'/',/reverse_search) if(temp ne -1) then s[i] = strmid(s[i],0,temp) endfor end ; ; At this point, the variable s is a string array with one element per ; namelist.  Each string begins with the namelist name. Determine the ; names by finding the portion of each string that precedes the first space. ; k=strpos(s,' ') lst_nm=strarr(nl) for j=0,nl-1 do BEGIN IF(k[j] EQ -1) THEN BEGIN lst_nm[j] =  s[j] s[j] =  \"\" ENDIF ELSE BEGIN lst_nm[j]=strmid(s[j],0,k[j]) ;extract list name s[j]=strmid(s[j],k[j]) ;eliminate list name from string ENDELSE endfor ; ; Loop through each of the namelists. ; final_structure_created =  0 for j=0,nl-1 do begin        ;namelist loop ; ; If a model structure was provided, look for a model for the namelist ; currently being processed.  If a model exists, use it as the ; structure that will be filled in here.  Otherwise, create a ; placeholder structure and set a flag indicating that a structure ; needs to be initialized when the first tag name is evaluated. ; IF(n_elements(model) GT 0) THEN BEGIN a =  where(strupcase(tag_names(model)) EQ strupcase(lst_nm[j]),count) IF(count EQ 1) THEN BEGIN new_structure =  0 x1 =  model.(a(0)) ENDIF ELSE BEGIN new_structure =  1 x1 =  {empty_namelist:long(0)} ; default if namelist is empty ENDELSE ENDIF else BEGIN new_structure =  1 x1 =  {empty_namelist:long(0)} ; default if namelist is empty ENDELSE ; ; Divide the single namelist string into an array of strings, breaking ; the string at each equals sign. ; s1=s[j] s_sep=str_sep(s1,'=') s_sep=strtrim(s_sep,2) ns=n_elements(s_sep)-1 k=0 ; ; Each element in the new array should contain a variable name and a ; variable value.  Process each of the elements in the string array. ; for i=1,ns do BEGIN       ;loop to extract each variable in nl IF(keyword_set(print_tokens)) THEN print,'' ;for debugging IF(keyword_set(print_tokens)) THEN print,'***previous token: ',s_sep[i-1] ;for debugging IF(keyword_set(print_tokens)) THEN print,'***current token: ',s_sep[i] ;for debugging param=strtrim(strmid(s_sep[i-1],k,1000),2) ;get parameter name IF (i eq ns) then begin k=quoted_reverse_find(s_sep[i],'/') if k ne -1 then begin if quoted_reverse_find(s_sep[i],' ') gt k then begin ; Linux style ; f90 linux namelist has one namelist on one line, ending / needs ; be trimmed for the last namelistg s_sep[i] = strmid(s_sep[i],0,k) ;print,param+\" = '\",s_sep[i]+\"' \" endif endif s_sep[i]=s_sep[i]+' ' ;bug fix, add end space ENDIF ;    print,j,i,k,'   ',param ; 20030605 - previously checked here if vars are separated by ' ' first, then ','. ; Now check if vars are separated by ',' first then ' ', which fixes ; the problem with Linux f90 nl where the var name would be extracted ; with leading ',' if the previous var is a string with ending spaces. ; 20030609 - either order fails for certain files. Now check both and ; take the last one as the separator. k1=quoted_reverse_find(s_sep[i],',') ; vars separated by ',' k2=quoted_reverse_find(s_sep[i],' ') ; vars separated by ' ' k=max([k1,k2]) ; whichever comes last should be the separator if k ne -1 and k eq k1 then k=k+1 if k eq -1 then k=strlen(s_sep[i]) ;last value in string sd=strmid(s_sep[i],0,k) ;extract data IF(keyword_set(print_tokens)) THEN print,'***data: ',sd kk = 0 q0 = -1 q1=strpos(sd,\" '\") q2=strpos(sd,\"' \",q1+1) q2k = q2 q3 = strpos(sd,\" '\",q2+1) if (q1 ge 0) and (q2 ge 0) then begin ;This is a string ; ;            print,' 1 : ','q1 , q2 , q3=',q1,q2,q3 ;            jcount = 0   ;used to debug an infinite loop problem ; REPEAT BEGIN WHILE q3 EQ q2k+1 DO BEGIN ;look for double quotes (JRF,huh?) q2k = q3 q3 = strpos(sd,\"' \",q2k+1) q2 = q3 ENDWHILE ;               print,'2: ','jcount,q0,q1,q2,q3=',jcount,q0,q1,q2,q3 if(q1 - q0 - 1 gt 0) then begin ;Allow for input of the form: 6*'test','hello',3*'goodbye' ; extra = strmid(sd,q0 + 1,q1 - q0 - 1) if(strmid(extra,0,1) eq ',') then strput,extra,' ',0 extra = strtrim(strcompress(extra,/remove_all),2) temp = strlen(extra) if( (temp gt 0) and $ (strmid(extra,temp - 1,1) eq '*') ) then begin temp = long(strmid(extra,0,temp - 1)) IF(kk EQ 0) then begin sd1 = replicate(strmid(sd,q1,q2-q1+1),temp) endif else begin sd1 = [sd1,replicate(strmid(sd,q1,q2-q1+1),temp)] endelse endif else begin IF(kk EQ 0) then begin sd1 = strmid(sd,q1,q2-q1+1) endif else begin sd1 = [sd1,strmid(sd,q1,q2-q1+1)] endelse endelse endif else begin IF kk EQ 0 THEN sd1 = strmid(sd,q1,q2-q1+1)  $ ELSE sd1 = [sd1,strmid(sd,q1,q2-q1+1)] endelse q0 = q2 kk = 1 q1=strpos(sd,\" '\",q2+1) q2=strpos(sd,\"' \",q1+1) q2k = q2 q3 = strpos(sd,\" '\",q2+1) ;look for double quotes ;               print,' 3 : ','jcount , q0 , q1 , q2 , q3=',jcount,q0,q1,q2,q3 ;               jcount = jcount + 1 ;               if(jcount gt 50) then stop ENDREP UNTIL q1 EQ -1 sd = sd1 ;            print,' sd : ',sd ;            stop endif else BEGIN       ;must be float, integer, or boolean repeat begin        ;remove commas if present kk=0 kk=strpos(sd,' , ',kk+1) if kk ne -1 then strput,sd,' ',kk endrep until kk eq -1 sd=str_sep(strtrim(strcompress(sd),2),' ') if n_elements(sd) eq 1 then sd=sd[0] ; convert array[1] to scalar c1=strmid(sd[0],0,1)+strmid(sd[0],strlen(sd[0])-1,1) ;check 1st/last char if c1 ne \"..\" and strlowcase(c1) ne \"ff\" and strlowcase(c1) ne \"tt\" then begin if max(strpos(sd,'*')) ne -1 then begin ;split * into array for kk=0,n_elements(sd)-1 do begin y=str_sep(sd[kk],'*') if n_elements(y) eq 1 then begin if dbl then s1=double(y) else s1=float(y) if strpos(y[0],' . ') eq -1 then s1=long(s1) endif else begin if dbl then y1=double(y[1]) else y1=float(y[1]) if strpos(y[1],' . ') eq -1 then y1=long(y1) s1=replicate(y1,y[0]) endelse if kk eq 0 then s2=s1 else s2=[s2,s1] endfor sd=s2 endif else begin on_ioerror,STRING\t; handle type conversion error if max(strpos(sd,' . ')) eq -1 and $ max(strpos(strlowcase(sd),'e')) eq -1 then begin ;check for float sd=long(sd) \t; convert to long goto,NULL endif else begin if dbl then sd=double(sd) else sd=float(sd) ;convert to float goto,NULL endelse STRING:sd=\"' \"+sd+\" '\" ; convert to string NULL:on_ioerror,NULL endelse endif ;; will be .T or .F or T or F etc. endelse ; if param is in form of name(1), strip out (1)  QP 17JUN05 if (pos = strpos(strcompress(param,/re),' ( 1 ) ')) ge 0 then begin origparam = param param = strmid(param,0,pos) ;\t    print,'converting ',origparam,' to ',param endif IF(keyword_set(print_tokens)) THEN print,'*** param : ',param skip = 0 ;;; NEW CODE to handle subscripting into existing array for param=\"foo(x)\" if (strpos(param,' ( ') ge 0) then BEGIN subpieces = str_sep(param,' ( ') temp = replace_reserved(strtrim(subpieces[0],2)) subindex = (where(tag_names(x1) eq $ strupcase(temp),subnindex))[0] if (subnindex eq 1) then BEGIN skip = 1\t\t; process here, skip in later part ;             print,\"new code\" subpieces =  str_sep(subpieces[1],' ) ') subpieces =  str_sep(subpieces[0],' , ') subpieces =  strtrim(subpieces,2) subelements = long(subpieces) - 1 subdata = x1.(subindex) ; Need a test here to make certain ; that the number of dimensions in the ; array subdata matches the number of ; elements in subelements. IF(n_elements(subelements) EQ 1) THEN $ for subi=0,n_elements(sd)-1 do $ subdata[subi+subelements[0]] = sd[subi] IF(n_elements(subelements) EQ 2) THEN $ for subi=0,n_elements(sd)-1 do $ subdata[subi+subelements[0],subelements[1]] = sd[subi] IF(n_elements(subelements) EQ 3) THEN $ for subi=0,n_elements(sd)-1 do $ subdata[subi+subelements[0],subelements[1],subelements[2]] = $ sd[subi] x1.(subindex) = subdata endif ;else message,/info,' Attempt to subscript into non - existent tag : '+subpieces[0] endif ;;; END NEW CODE if skip eq 0 then begin if (new_structure EQ 1) then begin ;make structure ;              print,\"old code 1\" if (strpos(param,' ( ') ge 0) then begin x1=create_struct_h(param,sd) endif else begin param = replace_reserved(param) x1=create_struct(param,sd) endelse new_structure =  0 endif else begin ;If param contains an \"(\" it won't ; match any of the reserved words . param = replace_reserved ( param ) ; If param contains an \"(\" it won't ;match any of the existing tags. w=where(strupcase(param) eq tag_names(x1)) if w[0] eq -1 then begin ;                print,\"old code 2\" if (strpos(param,' ( ') ge 0) then begin ;If param contains an \"(\" and a ;corresponding tag does not already ;exist (this would have been detected ;above in the \"new code\"), then create ;the  new structure element with a ;unique hex encoded name because ;there is no way to fill in an array ;element in an array that doesn't ; exist yet . x1 = create_struct_h ( x1 , param , sd ) endif else begin ; param was already compared to the ; reserved words above . x1 = create_struct ( x1 , param , sd ) endelse endif else begin ; overwrite duplicates ; print , \"old code 3\" ; We know at this point that there is ; no \"(\" within param because that ; would have been handled in the \"new ;code\" above . if n_elements ( sd ) eq 1 then x1 .( w [ 0 ])[ 0 ] = sd [ 0 ] else x1 .( w [ 0 ]) = sd endelse endelse if n_elements ( tag_names ( x1 )) eq 250 then begin ; 250 tag name limit , need to start another name if final_structure_created eq 0 then begin ; make namelist struct x = create_struct ( 'header' , header , lst_nm [ j ], x1 ) final_structure_created = 1 endif else begin x = create_struct ( x , lst_nm [ j ], x1 ) endelse lst_nm [ j ] = lst_nm [ j ] +'_ext' endif endif ; skip == 0 endfor ; i loop if ( final_structure_created eq 0 ) then begin ; make namelist struct x = create_struct ( 'header' , header , lst_nm [ j ], x1 ) final_structure_created = 1 endif else begin x = create_struct ( x , lst_nm [ j ], x1 ) endelse endfor ; j loop jump1: ; print , 'systime = ' , systime ( 1 ) - stime return , x end","tags":"","loc":"sourcefile/read_nl.pro.html","title":"read_nl.pro – FIDASIM"},{"text":"read_ncdf Reads a flat NetCDF file Arguments file : NetCDF file Keyword Arguments vars : List of variables to read Return Value Structure containing NetCDF variables Example Usage IDL > a = read_ncdf( \"./123324H01_fi_1.cdf\" ) Contents Source Code read_ncdf.pro Source Code FUNCTION read_ncdf , file , vars = vars ; +#read_ncdf ; + Reads a flat NetCDF file ; +*** ; +## Arguments ; + **file**: NetCDF file ; + ; +## Keyword Arguments ; + **vars**: List of variables to read ; + ; +## Return Value ; + Structure containing NetCDF variables ; + ; +## Example Usage ; + ``` idl ; + IDL > a = read_ncdf ( \"./123324H01_fi_1.cdf\" ) ; + ``` ;; List of reserved names reserved = [ 'AND' , 'BEGIN' , 'BREAK' , 'CASE' , 'COMMON' , 'COMPILE_OPT' , $ 'CONTINUE' , 'DO' , 'ELSE' , 'END' , 'ENDCASE' , 'ENDELSE' , $ 'ENDFOR' , 'ENDFOREACH' , 'ENDIF' , 'ENDREP' , 'ENDSWITCH' , 'ENDWHILE' , $ 'EQ' , 'FOR' , 'FOREACH' , 'FORWARD_FUNCTION' , 'FUNCTION' , 'GE' , $ 'GOTO' , 'GT' , 'IF' , 'INHERITS' , 'LE' , 'LT' , 'MOD' , 'NE' , 'NOT' , 'OF' , $ 'ON_IOERROR' , 'OR' , 'PRO' , 'REPEAT' , 'SWITCH' , 'THEN' , 'UNTIL' , $ 'WHILE' , 'X0R' ] d= { err : 1 } if file_test ( file ) then begin d . err = 0 ncid = ncdf_open ( file , / nowrite ) info = ncdf_inquire ( ncid ) if keyword_set ( vars ) then nvars = n_elements ( vars ) else nvars = info . nvars for i = 0 , nvars - 1 do begin if keyword_set ( vars ) then begin name = vars [ i ] CATCH , err_status if err_status ne 0 then begin CATCH , / CANCEL continue endif ncdf_varget , ncid , name , tmp endif else begin var_info = ncdf_varinq ( ncid , i ) name = strjoin ( strsplit ( var_info . name , \".\" , / extract ), \"_\" ) ncdf_varget , ncid , i , tmp endelse if total ( strmatch ( reserved , name , / FOLD_CASE )) gt 0 then name+='_' d = create_struct ( d , name , tmp ) endfor ncdf_close , ncid endif else message , 'FILE DOES NOT EXIST: ' + file return , d END","tags":"","loc":"sourcefile/read_ncdf.pro.html","title":"read_ncdf.pro – FIDASIM"},{"text":"line_basis Calculates basis from a line with +x in the direction of line Arguments r0 : Starting point of line [cm] v0 : Direction of line Keyword Arguments inv_basis : Set this to a named variable that recieves the inverse basis Example Usage IDL > basis = line_basis([ 0 , 0 , 0 ],[ 0 , - 1 , 0 ])\nIDL > x = basis ## [ 1 , 1 , 0 ] ;Transforms a point in line - space ([ 1 , 1 , 0 ]) to real space\nIDL > print ,x\n[ 1 , - 1 , 0 ] Contents Source Code line_basis.pro Source Code FUNCTION line_basis , r0 , v0 , inv_basis = inv_basis ; +#line_basis ; + Calculates basis from a line with + x in the direction of line ; +*** ; +## Arguments ; + **r0**: Starting point of line [ cm ] ; + ; + **v0**: Direction of line ; + ; +## Keyword Arguments ; + **inv_basis**: Set this to a named variable that recieves the inverse basis ; + ; +## Example Usage ; + ``` idl ; + IDL > basis = line_basis ([ 0 , 0 , 0 ],[ 0 , - 1 , 0 ]) ; + IDL > x = basis## [ 1 , 1 , 0 ] ; Transforms a point in line - space ([ 1 , 1 , 0 ]) to real space ; + IDL > print , x ; + [ 1 , - 1 , 0 ] ; + ``` rf = r0 + v0 dis = sqrt ( total ( v0&#94; 2.0 )) beta = asin (( r0 [ 2 ] - rf [ 2 ]) / dis ) alpha = atan (( rf [ 1 ] - r0 [ 1 ]),( rf [ 0 ] - r0 [ 0 ])) R = tb_zyx ( alpha , beta , 0.0 ) inv_basis = transpose ( R ) return , R END","tags":"","loc":"sourcefile/line_basis.pro.html","title":"line_basis.pro – FIDASIM"},{"text":"aabb_intersect Calculates intersection length of a ray and an axis aligned bounding box (AABB) Input Arguments rc : Center of AABB dr : [length, width, height] of AABB r0 : starting point of ray d0 : direction of ray Output Arguments intersect : Intersection length of ray and AABB ri : Optional, ray enterence point rf : Optional, ray exit point Example Usage IDL > aabb_intersect, [ 0 , 0 , 0 ], [ 1 , 1 , 1 ], [ - 1 , 0 , 0 ], [ 1 , 0 , 0 ], intersect, ri, rf\nIDL > print , intersect 1.0 IDL > print , ri - 0.5 0.0 0.0 IDL > print , rf 0.5 0.0 0.0 Contents Source Code aabb_intersect.pro Source Code PRO aabb_intersect , rc , dr , r0 , d0 , intersect , r_enter , r_exit ; +#aabb_intersect ; + Calculates intersection length of a ray and an axis aligned bounding box ( AABB ) ; +*** ; +## Input Arguments ; + **rc**: Center of AABB ; + ; + **dr**: [ length , width , height ] of AABB ; + ; + **r0**: starting point of ray ; + ; + **d0**: direction of ray ; + ; +## Output Arguments ; + **intersect**: Intersection length of ray and AABB ; + ; + **ri**: Optional , ray enterence point ; + ; + **rf**: Optional , ray exit point ; + ; +## Example Usage ; + ``` idl ; + IDL > aabb_intersect , [ 0 , 0 , 0 ], [ 1 , 1 , 1 ], [ - 1 , 0 , 0 ], [ 1 , 0 , 0 ], intersect , ri , rf ; + IDL > print , intersect ; + 1.0 ; + IDL > print , ri ; + - 0.5 0.0 0.0 ; + IDL > print , rf ; + 0.5 0.0 0.0 ; + ``` v0 = d0 / sqrt ( total ( d0 * d0 )) ;; There are 6 sides to a cube / grid side_inter = dblarr ( 6 ) ;; Intersection points of ray with planes defined by grid ipnts = dblarr ( 3 , 6 ) ;; Find whether ray intersects each side for i = 0 L , 5 do begin j = fix ( floor ( i / 2 )) ind = where ([ 0 , 1 , 2 ] ne j ) if abs ( v0 [ j ]) gt 0 then begin ;; Intersection point with plane ipnts [ * , i ] = r0 + v0* ( ( ( rc [ j ] + ( ( i mod 2 ) - 0.5 ) * dr [ j ] ) - r0 [ j ]) / v0 [ j ] ) ;; Check if point on plane is within grid side if abs ( ipnts [ ind [ 0 ], i ] - rc [ ind [ 0 ]]) le 0.5 * dr [ ind [ 0 ]] and $ abs ( ipnts [ ind [ 1 ], i ] - rc [ ind [ 1 ]]) le 0.5 * dr [ ind [ 1 ]] then side_inter [ i ] = 1 endif endfor intersect = 0.0 r_enter = r0 r_exit = r0 w = where ( side_inter ne 0 , nw ) if nw ge 2 then begin ;; Find two unique intersection points nunique = 0 for i = 0 , nw - 2 do begin if total ( ipnts [ * , w [ 0 ]] eq ipnts [ * , w [ i + 1 ]]) ne 3 then begin w = [ w [ 0 ], w [ i + 1 ]] nunique = 2 break end end if nunique eq 2 then begin vi = ipnts [ * , w [ 1 ]] - ipnts [ * , w [ 0 ]] vi = vi / sqrt ( total ( vi * vi )) dot_prod = total ( v0 * vi ) if dot_prod gt 0.0 then begin r_enter = ipnts [ * , w [ 0 ]] r_exit = ipnts [ * , w [ 1 ]] endif else begin r_enter = ipnts [ * , w [ 1 ]] r_exit = ipnts [ * , w [ 0 ]] endelse ;; Calculate intersection length intersect = sqrt ( total (( r_exit - r_enter ) &#94; 2.0 )) endif endif END","tags":"","loc":"sourcefile/aabb_intersect.pro.html","title":"aabb_intersect.pro – FIDASIM"},{"text":"check_inputs Checks if input structure is valid Input Arguments inputs : input structure Example Usage IDL > check_inputs, inputs Contents Source Code check_inputs.pro Source Code PRO check_inputs , inputs ; +#check_inputs ; + Checks if input structure is valid ; +*** ; +## Input Arguments ; + **inputs**: input structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_inputs , inputs ; + ``` info , 'Checking simulation settings...' err_status = 0 zero_string = { dims : 0 , type : 'STRING' } zero_int = { dims : 0 , type : 'INT' } zero_long = { dims : 0 , type : 'LONG' } zero_double = { dims : 0 , type : 'DOUBLE' } three_double = { dims :[ 3 ], type : 'DOUBLE' } schema = { comment : zero_string , $ shot : zero_long , time : zero_double , $ runid : zero_string , device : zero_string , $ tables_file:zero_string , result_dir:zero_string , $ nlambda : zero_int , lambdamin : zero_double , lambdamax : zero_double , $ nx : zero_int , ny : zero_int , nz : zero_int , $ alpha : zero_double , beta : zero_double , gamma : zero_double , $ origin : three_double , xmin : zero_double , xmax : zero_double , $ ymin : zero_double , ymax : zero_double , zmin : zero_double , zmax : zero_double , $ ab : zero_double , ai : zero_double , current_fractions:three_double , $ pinj : zero_double , einj : zero_double , impurity_charge:zero_int , $ n_fida:zero_long , n_pfida:zero_long , n_nbi:zero_long , n_dcx:zero_long , $ n_npa:zero_long , n_pnpa:zero_long , n_halo:zero_long , n_birth:zero_long , $ ne_wght:zero_int , np_wght:zero_int , nphi_wght:zero_int , $ emax_wght:zero_double , nlambda_wght:zero_int , $ lambdamin_wght:zero_double , lambdamax_wght:zero_double , $ calc_npa:zero_int , calc_fida:zero_int , calc_bes:zero_int , $ calc_dcx:zero_int , calc_halo:zero_int , calc_cold:zero_int , $ calc_pnpa:zero_int , calc_pfida:zero_int , $ calc_brems:zero_int , calc_birth:zero_int , calc_neutron:zero_int , $ calc_fida_wght:zero_int , calc_npa_wght:zero_int } check_struct_schema , schema , inputs , err_status , desc= \"simulation settings\" if err_status eq 1 then begin goto , GET_OUT endif ; Normalize File Paths inputs . result_dir = expand_path ( inputs . result_dir ) if inputs . alpha gt 2 * ! DPI or $ inputs . beta gt 2 * ! DPI or $ inputs . gamma gt 2 * ! DPI then begin error , 'Angles must be in radians' err_status = 1 endif if inputs . lambdamin ge inputs . lambdamax then begin error , 'Invalid wavelength range. Expected lambdamin < lamdbdamax' err_status = 1 endif if inputs . lambdamin_wght ge inputs . lambdamax_wght then begin error , 'Invalid wavelength range. Expected lambdamin_wght < lamdbdamax_wght' err_status = 1 endif if inputs . xmin ge inputs . xmax then begin error , 'Invalid x range. Expected xmin < xmax' err_status = 1 endif if inputs . ymin ge inputs . ymax then begin error , 'Invalid y range. Expected ymin < ymax' err_status = 1 endif if inputs . zmin ge inputs . zmax then begin error , 'Invalid z range. Expected zmin < zmax' err_status = 1 endif if inputs . pinj le 0. or inputs . einj le 0.0 then begin error , 'The selected source is not on' print , 'einj = ' , inputs . einj print , 'pinj = ' , inputs . pinj err_status = 1 endif if abs ( total ( inputs . current_fractions ) - 1.0 ) gt 1. d - 3 then begin error , 'current_fractions do not sum to 1.0' print , 'sum(current_fractions) = ' , total ( inputs . current_fractions ) err_status = 1 endif if inputs . impurity_charge le 1 then begin error , 'Invalid impurity charge. Expected impurity charge > 1' err_status = 1 endif ps = path_sep () input_file = inputs . result_dir + ps + inputs . runid+'_inputs.dat' equilibrium_file = inputs . result_dir + ps + inputs . runid+'_equilibrium.h5' geometry_file = inputs . result_dir + ps + inputs . runid+'_geometry.h5' distribution_file = inputs . result_dir + ps + inputs . runid+'_distribution.h5' neutrals_file = inputs . result_dir + ps + inputs . runid+'_neutrals.h5' inputs = create_struct ( inputs , 'input_file' , input_file , $ 'equilibrium_file' , equilibrium_file , $ 'geometry_file' , geometry_file , $ 'distribution_file' , distribution_file , $ 'load_neutrals' , 0 , $ 'flr' , 2 , $ 'verbose' , 1 , $ 'seed' , - 1 , $ 'neutrals_file' , neutrals_file ) GET_OUT : if err_status ne 0 then begin error , 'Invalid simulation settings. Exiting...' , / halt endif else begin success , 'Simulation settings are valid' endelse END","tags":"","loc":"sourcefile/check_inputs.pro.html","title":"check_inputs.pro – FIDASIM"},{"text":"extract_transp_plasma Extracts plasma structure from a TRANSP run Arguments filename : TRANSP output file e.g. [TRANSP_RUNID].CDF intime : Time of interest [s] grid : Interpolation grid rhogrid : sqrt(normalized torodial flux) mapped onto the interpolation grid Keyword Arguments doplot : Plot profiles profiles : Set this keyword to a named variable to recieve the plasma profiles as a function of rho s(ne|te|ti|imp|rot|nn) : Smooth profiles dn0out : Wall Neutral density value dn0out variable in transp namelist scrapeoff : scrapeoff decay length rho_scrapeoff : scrapeoff length, default = 0.1 Example Usage IDL > plasma = extract_transp_plasma( \"./142332H01.CDF\" , 1.2 , grid, rho) Contents Source Code extract_transp_plasma.pro Source Code FUNCTION extract_transp_plasma , filename , intime , grid , rhogrid , $ doplot = doplot , profiles = profiles , dn0out = dn0out , $ scrapeoff = scrapeoff , rho_scrapeoff = rho_scrapeoff , $ sne = sne , ste = ste , sti = sti , simp = simp , srot = srot , snn = snn ; +#extract_transp_plasma ; + Extracts ` plasma ` structure from a TRANSP run ; +*** ; +## Arguments ; + **filename**: TRANSP output file e . g . [ TRANSP_RUNID ]. CDF ; + ; + **intime**: Time of interest [ s ] ; + ; + **grid**: Interpolation grid ; + ; + **rhogrid**: sqrt ( normalized torodial flux ) mapped onto the interpolation grid ; + ; +## Keyword Arguments ; + **doplot**: Plot profiles ; + ; + **profiles**: Set this keyword to a named variable to recieve the plasma profiles as a function of rho ; + ; + ** s ( ne | te | ti | imp | rot | nn ) **: Smooth profiles ; + ; + **dn0out**: Wall Neutral density value ` dn0out ` variable in transp namelist ; + ; + **scrapeoff**: scrapeoff decay length ; + ; + **rho_scrapeoff**: scrapeoff length , default = 0.1 ; + ; +## Example Usage ; + ``` idl ; + IDL > plasma = extract_transp_plasma ( \"./142332H01.CDF\" , 1.2 , grid , rho ) ; + ``` var_list = [ \"X\" , \"TRFLX\" , \"TFLUX\" , \"TIME\" , \"NE\" , \"TE\" , \"TI\" , \"ZEFFI\" , \"OMEGA\" , \"DN0WD\" ] zz = read_ncdf ( filename , vars = var_list ) t = zz . time dummy = min ( abs ( t - intime ), idx ) time = double ( t [ idx ]) print , ' * Selecting profiles at :' , time , ' s' ; pick the closest timeslice to TOI transp_ne = zz . ne_ [ * , idx ] ; cm&#94;- 3 transp_te = zz . te [ * , idx ] * 1. d - 3 ; kev transp_ti = zz . ti [ * , idx ] * 1. d - 3 ; kev transp_nn = zz . dn0wd [ * , idx ] ; cm&#94;- 3 transp_zeff = zz . zeffi [ * , idx ] rho_cb = sqrt ( zz . trflx [ * , idx ] / zz . tflux [ idx ]) ; center each rho b / c toroidal flux is at cell boundary rho = 0. d0 * rho_cb rho [ 0 ] = 0.5 * rho_cb [ 0 ] for i = 1 , n_elements ( rho_cb ) - 1 do begin rho [ i ] = rho_cb [ i ] - 0.5 * ( rho_cb [ i ] - rho_cb [ i - 1 ]) endfor if total ( strmatch ( tag_names ( zz ), 'OMEGA' , / fold_case )) eq 0 then begin warn , 'OMEGA not found in TRANSP file. Assuming no plasma rotation' transp_omega = 0.0 * transp_te endif else begin transp_omega = zz . omega [ * , idx ] ; rad / s endelse if not keyword_set ( dn0out ) then dn0out = transp_nn [ - 1 ] if not keyword_set ( scrapeoff ) then scrapeoff = 0.0 if not keyword_set ( rho_scrapeoff ) then rho_scrapeoff = 0.1 if scrapeoff gt 0.0 then begin drho = abs ( rho [ - 1 ] - rho [ - 2 ]) rho_sc = rho [ - 1 ] + drho* ( dindgen ( ceil ( rho_scrapeoff / drho )) + 1 ) sc = exp ( - ( rho_sc - rho [ - 1 ]) / scrapeoff ) transp_ne = [ transp_ne , transp_ne [ - 1 ] * sc ] transp_te = [ transp_te , transp_te [ - 1 ] * sc ] transp_ti = [ transp_ti , transp_ti [ - 1 ] * sc ] transp_nn = [ transp_nn , 0 * sc + dn0out ] transp_zeff = [ transp_zeff , ( transp_zeff [ - 1 ] - 1 ) * sc + 1 ] transp_omega = [ transp_omega , transp_omega [ - 1 ] * sc ] rho = [ rho , rho_sc ] endif if keyword_set ( doplot ) then begin ! p . charsize = 2 & ! x . minor=- 1 & ! y . minor=- 1 loadct , 13 & ! p . color = 100 & ! p . multi = [ 0 , 2 , 3 ] & ! p . psym = 1 & ! p . thick = 1 device , decompose = 0 window , 0 , retain = 2 , xs = 600 , ys = 800 if keyword_set ( sne ) then begin z = smooth ( transp_ne , sne ) plot , x , transp_ne , title='Ne' oplot , x , z , psym = 0 , color = 100 transp_ne = z end if keyword_set ( simp ) then begin z = smooth ( transp_zeff , simp ) plot , x , transp_zeff , title='Zeff' oplot , x , z , psym = 0 , color = 100 transp_zeff = z end if keyword_set ( ste ) then begin z = smooth ( transp_te , ste ) plot , x , transp_te , title='Te' oplot , x , z , psym = 0 , color = 100 transp_te = z end if keyword_set ( sti ) then begin z = smooth ( transp_ti , sti ) plot , x , transp_ti , title='Ti' oplot , x , z , psym = 0 , color = 100 transp_ti = z end if keyword_set ( srot ) then begin z = smooth ( transp_omega , srot ) plot , x , transp_omega , title='Omega' oplot , x , z , psym = 0 , color = 100 transp_omega = z end if keyword_set ( snn ) then begin z = smooth ( transp_nn , snn ) plot , x , transp_nn , title='Omega' oplot , x , z , psym = 0 , color = 100 transp_nn = z end ! p . color = 220 & ! p . multi = [ 0 , 2 , 3 ] & ! p . psym = 0 & ! p . thick = 2 window , 1 , retain = 2 , xs = 600 , ys = 800 plot , x , transp_ne , ytitle=' x E13 cm-3' , title='Ne  ' plot , x , transp_zeff , ytitle = 'x E13 cm-3' , title='Zeff' plot , x , transp_te , ytitle=' keV' , title='Te' plot , x , transp_ti , xtitle='rho' , ytitle=' keV' , title='Ti' plot , x , transp_omega , xtitle='rho' , ytitle='rad/s' , title='Omega' plot , x , transp_nn , ytitle='cm-3' , title='Nn' endif profiles = { rho : rho , $ dene : transp_ne > 0.0 , $ denn : transp_nn > 0.0 , $ te : transp_te > 0.0 , $ ti : transp_ti > 0.0 , $ zeff : transp_zeff > 1.0 , $ omega : transp_omega } ;; Interpolate onto r - z grid dene = interpol ( transp_ne , rho , rhogrid ) > 0.0 denn= ( 10. d0&#94; interpol ( alog10 ( transp_nn ), rho , rhogrid )) > 0.0 te = interpol ( transp_te , rho , rhogrid ) > 0.0 ti = interpol ( transp_ti , rho , rhogrid ) > 0.0 zeff = interpol ( transp_zeff , rho , rhogrid ) > 1.0 vt = double ( grid . r2d * interpol ( transp_omega , rho , rhogrid )) vr = double ( replicate ( 0.0 , grid . nr , grid . nz )) vz = double ( replicate ( 0.0 , grid . nr , grid . nz )) max_rho = max ( abs ( rho )) s = size ( rhogrid , / dim ) mask = intarr ( s [ 0 ], s [ 1 ]) w = where ( rhogrid le max_rho ) ; where we have profiles mask [ w ] = 1 ;; SAVE IN PROFILES STRUCTURE plasma= { data_source: file_expand_path ( filename ), time : time , mask : mask , $ dene : dene , denn : denn , te : te , ti : ti , vr : vr , vt : vt , vz : vz , zeff : zeff } return , plasma END","tags":"","loc":"sourcefile/extract_transp_plasma.pro.html","title":"extract_transp_plasma.pro – FIDASIM"},{"text":"read_geqdsk Reads an EFIT GEQDSK file Arguments filename : GEQDSK file grid : Interpolation grid Keyword Arguments rho : Set this keyword to a named variable to receive the\nsqrt(normalized torodial flux) (rho) mapped onto the interpolation grid g : Set this keyword to a named variable to recieve the geqdsk structure btipsign : Set this keyword to a named variable to recieve the bt-ip sign poloidal : Return rho_p (sqrt(normalized poloidal flux)) instead of rho (sqrt(normalized toroidal flux)) Return Value Electronmagnetic fields structure Example Usage IDL > fields = read_geqdsk( \"./g133223.00200\" ,grid,rho = rho) Contents Source Code read_geqdsk.pro Source Code ; ====================================================================== ; $ Id : calculate_bfield . pro , v 1.3 2008 / 06 / 14 18 : 51 : 54 liud Exp $ ; ====================================================================== ; WWH removed requirement for a eqdsk from Jong 's calculate_bfields ; Include sign of current so br & bz go in right direction for ; standard (r,phi,z) coordinates ; NAME: ;     CALCULATE_BFIELD ; ; PURPOSE: ;     Calculate the poloidal, toroidal, vertical and radial magnetic ;     field components ; ; CALLING SEQUENCE: ;     calculate_bfields,bp,br,bt,bz,a,g ; ; INPUT PARAMETERS: ;     a:      - structure containing A0 parameters ;     g:      - structure containing G0 parameters ; ; ; OPTIONAL INPUT PARAMETERS: ; ;     NONE ; ; KEYWORDS: ; ;     NONE ; ; OUTPUTS: ;      bp     2-D array containing the poloidal field at refit,zefit ;      br     2-D array containing the radial field at refit,zefit ;      bt     2-D array containing the toroidal field at refit,zefit ;      bz     2-D array containing the vertical field at refit,zefit ; ; COMMON BLOCKS: ; ;     NONE ; ; SIDE EFFECTS: ; ;     NONE ; ; RESTRICTIONS: ;     Prior to this using this function, you must have first read in ;     the EFIT data to fill the a and g structures. ; ; PROCEDURE: ;     The program uses a simple differentiation using a 3 point ;     Lagrangian interpolation. ; ; CODE TYPE: modeling, analysis ; ; CODE SUBJECT:  edge, transport, equilibrium ; ; EASE OF USE: can be used with existing documentation ; ; OPERATING SYSTEMS:  Unix Of All Flavors ; ; EXTERNAL CALLS:  NONE ; ; RESPONSIBLE PERSON: Ray Jong ; ; DATE OF LAST MODIFICATION:  09/24/98 ; ; MODIFICATION HISTORY: ; ;     Created by Gary D. Porter, LLNL ;     1994.02.16     Michael D. Brown ;                    Optimized for IDL ;     1998.02.17:    Gary D. Porter ;                    Modified to use new EFIT routines and a and g structures. ;                    No longer uses efitcommon. ;- PRO calculate_bfield,bp,br,bt,bz,g compile_opt defint32,strictarr,strictarrsubs mw=g.mw & mh=g.mh bp=fltarr(mw,mh) & bt=fltarr(mw,mh) & br=fltarr(mw,mh) & bz=fltarr(mw,mh) dpsidx = fltarr(mw,mh) dpsidy = fltarr(mw,mh) ; calculate vertical derivative of psi for i = 0,mw-1 do begin dpsidy[i,*] = Deriv(g.z[0:mh-1],g.psirz[i,0:mh-1]) endfor ; calculate horizontal derivative of psi for j = 0,mh-1 do begin dpsidx[*,j] = Deriv(g.r[0:mw-1],g.psirz[0:mw-1,j]) endfor ; calculate array of Br, Bz, and Bp for j = 0,mh-1 do begin br[*,j] = dpsidy[0:mw-1,j]/g.r[0:mw-1] bz[*,j] = -dpsidx[0:mw-1,j]/g.r[0:mw-1] endfor bp = sqrt(br*br+bz*bz) ; WWH get right sign if g.cpasma lt 0. then begin br=-br & bz=-bz end ; Calculate toroidal field ; Original coding was from gfield.for by Peter Politzer, ;   translated to IDL by Gary Porter (see BFIELD.PRO). ; The code below has be optimized for IDL by Michael D. Brown, 2/16/94 dpsi = (g.ssibry-g.ssimag)/float(mw-1) ; first order Bt value. for j=0,mh-1 do bt[0:mw-1,j]=g.bcentr*g.rzero/g.r[0:mw-1] k = long((g.psirz - g.ssimag)/dpsi) iw=where(k ge 0 and k lt mw-1,n)  ; 1-d indexes where k is a valid index. if n gt 0 then begin iwr = iw mod mw  ; map matrix 1-d selected indexes to an refit row index. bt[iw] = ( g.fpol[k[iw]]+(g.fpol[k[iw]+1]-g.fpol[k[iw]])* $ (g.psirz[iw]-(k[iw]*dpsi+g.ssimag))/dpsi ) / g.r[iwr] endif return end FUNCTION read_geqdsk,filename,grid,rho=rho,g=g,btipsign=btipsign, poloidal = poloidal ;+#read_geqdsk ;+Reads an EFIT GEQDSK file ;+*** ;+##Arguments ;+    **filename**: GEQDSK file ;+ ;+    **grid**: Interpolation grid ;+ ;+##Keyword Arguments ;+    **rho**: Set this keyword to a named variable to receive the ;+              sqrt(normalized torodial flux) (rho) mapped onto the interpolation grid ;+ ;+    **g**: Set this keyword to a named variable to recieve the geqdsk structure ;+ ;+    **btipsign**: Set this keyword to a named variable to recieve the bt-ip sign ;+ ;+    **poloidal**: Return rho_p (sqrt(normalized poloidal flux)) instead of rho (sqrt(normalized toroidal flux)) ;+ ;+##Return Value ;+Electronmagnetic fields structure ;+ ;+##Example Usage ;+```idl ;+IDL> fields = read_geqdsk(\"./g133223.00200\",grid,rho=rho) ;+``` equil={err:1} ;; Get eqdsk g=readg(filename) btipsign = signum(g.bcentr*g.cpasma) time = double(g.time) if not keyword_set(poloidal) then begin rhogrid=double(rho_rz(g,grid.r2d/100.,grid.z2d/100.,/do_linear,/norm)) endif else begin r = g.r dr = abs(r[1]-r[0]) z = g.z dz = abs(z[1]-z[0]) rhogrid = interpolate(g.psirz,(grid.r2d/100-r[0])/dr,(grid.z2d/100 -z[0])/dz,cubic=-0.5) rhogrid = sqrt((rhogrid - g.ssimag)/(g.ssibry - g.ssimag)) end calculate_bfield,bp,br,bphi,bz1,g ;; Get radial electric field on efit's grid from potential ;; epoten is on a grid of equally spaced points in psi from g . ssimag to g . ssibry dpsi= ( g . ssibry - g . ssimag ) / ( n_elements ( g . epoten ) - 1 ) psi = g . ssimag + dpsi * findgen ( n_elements ( g . epoten )) npot = n_elements ( g . epoten ) epot = replicate ( g . epoten [ npot - 1 ], n_elements ( g . r ), n_elements ( g . z )) for i = 0 l , n_elements ( g . r ) - 1 do begin for j = 0 l , n_elements ( g . z ) - 1 do begin psi1 = g . psirz [ i , j ] dum = min ( abs ( psi1 - psi ), kpsi ) if kpsi ne npot - 1 then epot [ i , j ] = spline ( psi , g . epoten ,[ psi1 ]) endfor endfor ; E = - grad ( Phi ) EFIT units should be V / m er=- ( shift ( epot , - 1 , 0 ) - shift ( epot , 1 , 0 )) / ( g . r [ 2 ] - g . r [ 0 ]) ez1=- ( shift ( epot , 0 , - 1 ) - shift ( epot , 0 , 1 )) / ( g . z [ 2 ] - g . z [ 0 ]) ;; Interpolate cylindrical fields onto ( r , w , phi ) mesh b_r = dblarr ( grid . nr , grid . nz , grid . nphi ) & b_t = b_r & b_z = b_r e_r = dblarr ( grid . nr , grid . nz , grid . nphi ) & e_t = e_r & e_z = e_r for i = 0 L , grid . nr - 1 do for j = 0 L , grid . nz - 1 do begin rgrid= ( .01 * grid . r2d [ i , j ] - g . r [ 0 ]) / ( g . r [ 1 ] - g . r [ 0 ]) ; in grid units zgrid= ( .01 * grid . z2d [ i , j ] - g . z [ 0 ]) / ( g . z [ 1 ] - g . z [ 0 ]) ; WWH 3 / 31 / 07 b_r [ i , j , * ] = interpolate ( br ,[ rgrid ],[ zgrid ]) e_r [ i , j , * ] = interpolate ( er ,[ rgrid ],[ zgrid ]) b_t [ i , j , * ] = interpolate ( bphi ,[ rgrid ],[ zgrid ]) e_z [ i , j , * ] = interpolate ( ez1 ,[ rgrid ],[ zgrid ]) b_z [ i , j , * ] = interpolate ( bz1 ,[ rgrid ],[ zgrid ]) endfor rho = rhogrid mask = in_vessel ( 100 * g . lim [ 0 , * ], 100 * g . lim [ 1 , * ], grid . r2d , grid . z2d ) mask = rebin ( mask , grid . nr , grid . nz , grid . nphi ) equil= { time : time , data_source: file_expand_path ( filename ), mask : mask , $ br : b_r , bt : b_t , bz : b_z , er : e_r , et : e_t , ez : e_z } GET_OUT : return , equil END","tags":"","loc":"sourcefile/read_geqdsk.pro.html","title":"read_geqdsk.pro – FIDASIM"},{"text":"check_beam Checks if neutral beam geometry structure is valid Input Arguments inputs : input structure nbi : neutral beam geometry structure Example Usage IDL > check_beam, inputs, nbi Contents Source Code check_beam.pro Source Code PRO check_beam , inp , nbi ; +#check_beam ; + Checks if neutral beam geometry structure is valid ; +*** ; +## Input Arguments ; + **inputs**: input structure ; + ; + **nbi**: neutral beam geometry structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_beam , inputs , nbi ; + ``` err_status = 0 info , 'Checking beam geometry...' na = nbi . naperture zero_string = { dims : 0 , type : 'STRING' } zero_int = { dims : 0 , type : 'INT' } zero_double = { dims : 0 , type : 'DOUBLE' } three_double = { dims :[ 3 ], type : 'DOUBLE' } na_double = { dims :[ na ], type : 'DOUBLE' } na_int = { dims :[ na ], type : 'INT' } schema = { data_source:zero_string , $ name : zero_string , shape : zero_int , $ src : three_double , axis : three_double , $ divy : three_double , divz : three_double , $ focy : zero_double , focz : zero_double , $ widz : zero_double , widy : zero_double , $ naperture : zero_int , ashape : na_int , $ awidy : na_double , awidz : na_double , $ aoffy : na_double , aoffz : na_double , $ adist : na_double } check_struct_schema , schema , nbi , err_status , desc= \"beam geometry\" if err_status eq 1 then begin goto , GET_OUT endif if abs ( total ( nbi . axis&#94; 2.0 ) - 1.0 ) gt 1 d - 5 then begin error , 'Invalid source axis. Expected norm(axis) == 1' err_status = 1 endif if nbi . focz le 0.0 then begin error , 'focz cannot be in the range (-Inf,0.0]' err_status = 1 endif if nbi . focy le 0.0 then begin error , 'focy cannot be in the range (-Inf,0.0]' err_status = 1 endif if nbi . shape gt 2 or nbi . shape eq 0 then begin error , 'Invalid source shape. Expected 1 (rectagular) or 2 (circular)' err_status = 1 endif if nbi . widz lt 0 then begin error , 'Invalid widz. Expected widz > 0' err_status = 1 endif if nbi . widy lt 0 then begin error , 'Invalid widy. Expected widy > 0' err_status = 1 endif w = where ( nbi . ashape gt 2 or nbi . ashape eq 0 , nw ) if nw gt 0 then begin error , 'Invalid aperture shape. Expected 1 (rectangular) or 2 (circular)' err_status = 1 endif w = where ( nbi . awidy lt 0 , nw ) if nw gt 0 then begin error , 'Invalid awidy. Expected awidy >= 0.0' err_status = 1 endif w = where ( nbi . awidz lt 0 , nw ) if nw gt 0 then begin error , 'Invalid awidz. Expected awidz >= 0.0' err_status = 1 endif origin = inp . origin uvw_src = nbi . src uvw_axis = nbi . axis if nbi . naperture eq 0 then begin uvw_pos = uvw_src + 100 * uvw_axis endif else begin uvw_pos = uvw_src + nbi . adist [ 0 ] * uvw_axis endelse xyz_src = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma , uvw_src , origin = origin ) xyz_axis = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma , uvw_axis ) xyz_pos = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma , uvw_pos , origin = origin ) xyz_center = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma ,[ 0.0 , 0.0 , 0.0 ], origin = origin ) dis = sqrt ( total (( xyz_src - xyz_pos ) &#94; 2.0 )) BETA = double ( asin (( xyz_src [ 2 ] - xyz_pos [ 2 ]) / dis )) ALPHA = double ( atan (( xyz_pos [ 1 ] - xyz_src [ 1 ]),( xyz_pos [ 0 ] - xyz_src [ 0 ]))) print , 'Machine center in beam grid coordinates' print , f='(\"    [\",F9.3,\",\",F9.3,\",\",F9.3,\"]\")' , xyz_center print , 'Beam injection start point in machine coordinates' print , f='(\"    [\",F9.3,\",\",F9.3,\",\",F9.3,\"]\")' , uvw_src print , 'Beam injection start point in beam grid coordinates' print , f='(\"    [\",F9.3,\",\",F9.3,\",\",F9.3,\"]\")' , xyz_src if nbi . naperture ne 0 then begin print , 'First aperture position in machine coordinates' print , f='(\"    [\",F9.3,\",\",F9.3,\",\",F9.3,\"]\")' , uvw_pos print , 'First aperture position in beam grid coordinates' print , f='(\"    [\",F9.3,\",\",F9.3,\",\",F9.3,\"]\")' , xyz_pos endif else begin print , 'Position of point 100cm along beam centerline in machine coordinates' print , f='(\"    [\",F9.3,\",\",F9.3,\",\",F9.3,\"]\")' , uvw_pos print , 'Position of point 100cm along beam centerline in beam grid coordinates' print , f='(\"    [\",F9.3,\",\",F9.3,\",\",F9.3,\"]\")' , xyz_pos endelse print , 'Beam grid rotation angles that would align it with the beam centerline' print , ALPHA / ! DPI * 180 , FORMAT ='(\"    alpha = \",F14.10,\"°\")' print , BETA / ! DPI * 180 , FORMAT ='(\"    beta = \",F14.10,\"°\")' ;; Calculate grid center rc and sides length dr dr = [ inp . xmax - inp . xmin , inp . ymax - inp . ymin , inp . zmax - inp . zmin ] rc = [ inp . xmin , inp . ymin , inp . zmin ] + 0.5 * dr ;; Check if beam centerline intersects beam grid aabb_intersect , rc , dr , xyz_src , xyz_axis , length , r_enter , r_exit print , 'Beam centerline - grid intersection length' print , f='(\"    length = \",F8.3)' , length if length le 10.0 then begin error , 'Beam centerline does not intersect grid' err_status = 1 endif GET_OUT : if err_status ne 0 then begin error , 'Invalid beam geometry. Exiting...' , / halt endif else begin success , 'Beam geometry is valid' endelse END","tags":"","loc":"sourcefile/check_beam.pro.html","title":"check_beam.pro – FIDASIM"},{"text":"This file contains the procedure to read SPIRAL fast-ion distribution file read_spiral Reads SPIRAL guiding center fast-ion distribution file Arguments file : SPIRAL output file Keyword Arguments time : Time [s] ntotal : Total number of fast-ions e_range : Energy range of particles to consider p_range : Pitch range of particles to consider particle_weight : Set particle/marker weight such that sum(particle_weights) = ntotal: Defaults to ntotal /nparticles btipsign : Sign of the dot product between the current and magnetic field (Required) Return Value Distribution structure Example Usage IDL > dist = read_spiral( \"./mc_159243H06_9\" ,ntotal = 1e19,btipsign =- 1 ) Contents Source Code read_spiral.pro Source Code FUNCTION read_spiral_header , file openr , lun , file , / get_lun npart = 0 weight = 0.0 gc = 0 err = 0 nheader = 0 line = '' header = '' readf , lun , line while strmid ( line , 0 , 1 ) eq ';' do begin nheader = nheader + 1 header = header + line + string ( 10 B ) if stregex ( line , \"particle weight\" , / fold_case ) ne - 1 then begin weight = float ( stregex ( line , \" [ -+ ] ? [ 0 - 9 ] *\\.? [ 0 - 9 ] + ([ eE ][ -+ ] ? [ 0 - 9 ] + ) ? \",/extract)) endif if stregex(line,\" number \",/fold_case) ne -1 then begin npart = long(stregex(line,\" [ 0 - 9 ] + \",/extract)) endif if stregex(line,\" guiding center \",/fold_case) ne -1 then begin gc = 1 endif if stregex(line,\" R_ [ m ] \",/fold_case) ne -1 then begin if n_elements(strsplit(line)) ne 6 then begin err = 1 endif endif line = '' readf, lun, line endwhile free_lun,lun if gc eq 0 then begin error,'Not a guiding center distribution',/halt endif if npart eq 0 then begin error,'Number of particles le 0',/halt endif return, {nheader:nheader, npart:npart, header:header,weight:weight} END FUNCTION finite_struct, s n = N_TAGS(s) for i=0,n-1 do begin if finite(s.(i)) ne 1 then return, 0 endfor return, 1 END ;+ This file contains the procedure to read SPIRAL fast-ion distribution file FUNCTION read_spiral,file, time=time, ntotal=ntotal, e_range=e_range, p_range=p_range, $ particle_weight=particle_weight, btipsign=btipsign ;+#read_spiral ;+Reads SPIRAL guiding center fast-ion distribution file ;+*** ;+##Arguments ;+    **file**: SPIRAL output file ;+ ;+##Keyword Arguments ;+    **time**: Time [s] ;+ ;+    **ntotal**: Total number of fast-ions ;+ ;+    **e_range**: Energy range of particles to consider ;+ ;+    **p_range**: Pitch range of particles to consider ;+ ;+    **particle_weight**: Set particle/marker weight such that sum(particle_weights) = ntotal: Defaults to `ntotal`/nparticles ;+ ;+    **btipsign**: Sign of the dot product between the current and magnetic field (Required) ;+ ;+##Return Value ;+Distribution structure ;+ ;+##Example Usage ;+```idl ;+IDL> dist = read_spiral(\" . / mc_159243H06_9 \" , ntotal = 1 e19 , btipsign=- 1 ) ; + ``` if not keyword_set ( btipsign ) then begin error , 'btipsign is not set.' , / halt endif if not file_test ( file ) then begin error , 'Nonexistent file: ' + file , / halt endif if not keyword_set ( time ) then begin print , 'WARNING: Time is not set for SPIRAL distribution. Setting to 0.0 [s]' time = 0. d0 endif header = read_spiral_header ( file ) npart = header . npart nhead = header . nheader pweight = header . weight openr , unit , file , / get_lun ; Read header head = strarr ( nhead ) readf , unit , head ; Read in data r = dblarr ( npart ) z = dblarr ( npart ) phi = dblarr ( npart ) energy = dblarr ( npart ) pitch = dblarr ( npart ) cnt = 0 L for i = 0 , npart - 1 do begin s = { r : double ( 0 ), phi : double ( 0 ), z : double ( 0 ), energy : double ( 0 ), pitch : double ( 0 )} readf , unit , s if not finite_struct ( s ) then begin continue endif else begin r [ cnt ] = s . r * 100 phi [ cnt ] = s . phi z [ cnt ] = s . z * 100 energy [ cnt ] = s . energy pitch [ cnt ] = s . pitch * btipsign ; SPIRAL pitch is defined relative to current cnt = cnt + 1 endelse endfor free_lun , unit npart = cnt r = r [ 0 :npart - 1 ] z = z [ 0 :npart - 1 ] phi = phi [ 0 :npart - 1 ] energy = energy [ 0 :npart - 1 ] pitch = pitch [ 0 :npart - 1 ] orbit_class = replicate ( 1 , npart ) if pweight ne 0.0 then begin weight = replicate ( pweight , npart ) endif else begin if not keyword_set ( particle_weight ) then begin if not keyword_set ( ntotal ) then begin print , 'WARNING: ntotal is not set. Setting arbitrarily to 1e19' ntotal = 1. d19 endif weight = replicate ( Ntotal / float ( npart ), npart ) endif else begin weight = replicate ( particle_weight , npart ) endelse endelse if not keyword_set ( e_range ) then begin e_range = [ min ( energy ), max ( energy )] endif if not keyword_set ( p_range ) then begin p_range = [ min ( pitch ), max ( pitch )] endif ww = where ( energy ge e_range [ 0 ] and energy le e_range [ 1 ], nw ) if nw eq 0 then begin error , 'No particles fall in requested energy range' , / halt endif wwp = where ( pitch [ ww ] ge p_range [ 0 ] and pitch [ ww ] le p_range [ 1 ], nwp ) if nwp eq 0 then begin error , 'No particles fall in the requested pitch range' , / halt endif ww = ww [ wwp ] nw = n_elements ( ww ) print , 'Number of markers: ' , npart print , 'Number of markers in phase space: ' , nw dist_struct = { type : 2 , time : time , data_source: file_expand_path ( file ), $ nparticle : long ( nw ), nclass : 1 , r : r [ ww ], z : z [ ww ], phi : phi [ ww ], $ energy : energy [ ww ], pitch : pitch [ ww ], class : orbit_class [ ww ], $ weight : weight [ ww ]} return , dist_struct END","tags":"","loc":"sourcefile/read_spiral.pro.html","title":"read_spiral.pro – FIDASIM"},{"text":"read_mc_nubeam Reads guiding center Monte Carlo NUBEAM fast-ion distribution file Arguments infile : NUBEAM Monte Carlo distribution file Keyword Arguments ntotal : Total number of fast-ions e_range : Energy range of particles to consider p_range : Pitch range of particles to consider particle_weight : Set particle/marker weight such that sum(particle_weights) = ntotal: Defaults to ntotal /nparticles btipsign : Sign of the dot product between the current and magnetic field (Required) Return Value Distribution structure Example Usage IDL > dist = read_spiral( \"./spiral_file.TXT\" ,time = 1.0 , ntotal = 1e19) Contents Source Code read_mc_nubeam.pro Source Code FUNCTION read_mc_nubeam , infile , ntotal = ntotal , e_range = e_range , p_range = p_range , particle_weight = particle_weight , btipsign = btipsign ; +#read_mc_nubeam ; + Reads guiding center Monte Carlo NUBEAM fast - ion distribution file ; +*** ; +## Arguments ; + **infile**: NUBEAM Monte Carlo distribution file ; + ; +## Keyword Arguments ; + **ntotal**: Total number of fast - ions ; + ; + **e_range**: Energy range of particles to consider ; + ; + **p_range**: Pitch range of particles to consider ; + ; + **particle_weight**: Set particle / marker weight such that sum ( particle_weights ) = ntotal : Defaults to ` ntotal ` / nparticles ; + ; + **btipsign**: Sign of the dot product between the current and magnetic field ( Required ) ; + ; +## Return Value ; + Distribution structure ; + ; +## Example Usage ; + ``` idl ; + IDL > dist = read_spiral ( \"./spiral_file.TXT\" , time = 1.0 , ntotal = 1 e19 ) ; + ``` if not keyword_set ( btipsign ) then begin error , 'btipsign is not set.' , / halt endif if not keyword_set ( ntotal ) and not keyword_set ( particle_weight ) then begin warn , 'Ntotal not set. Setting arbitrarily to 1e19' ntotal = 1. d19 endif zzz = FINDFILE ( infile ) if zzz eq '' then begin error , 'Nonexistent file: ' + infile , / halt endif openr , unit , infile , / get_lun line=' ' readf , unit , line ; read string readf , unit , line pos = strpos ( line , 'N=' ) if pos eq - 1 then begin error , 'Second line is missing the number of points' , / halt endif w = stregex ( line , 'N *= *([0-9]*)' , / sub , / extract ) npts = long ( w [ 1 ]) if npts lt 5 then begin error , 'Too few points ' + strtrim ( npts , 2 ), / halt endif ; Get time readf , unit , line parts = str_sep ( line , ' ' ) w = where ( parts eq 'TIME' , nw ) if nw eq 0 then begin error , 'Time not found on 3rd line' , / halt endif i = 1 while 1 do begin s = parts [ w [ 0 ] + i ] if s ne '' and s ne '=' then begin time = float ( s ) break endif i = i + 1 endwhile data = fltarr ( 4 , npts ) ready = 0 while not ready do begin readf , unit , line ; Description line pos = strpos ( line , 'R(cm)' ) if pos gt - 1 then ready = 1 endwhile for i = 0 L , npts - 1 do begin readf , unit , line ; read string line = strcompress ( line ) parts = str_sep ( line , ' ' ) & np = n_elements ( parts ) if parts ( 0 ) eq '' then parts = shift ( parts , - 1 ) ; accommodate blank before 1 st while parts ( np - 1 ) eq '' do np = np - 1 if np ne 4 then begin error , 'Wrong number of entries on line: ' + line endif else begin data [ * , i ] = parts [ 0 :np - 1 ] endelse print , format='(f7.2,\"%\",A,$)' , 100.0 * ( i + 1 ) / float ( npts ), string ( 13 b ) endfor free_lun , unit r = double ( reform ( data [ 0 , 0 :npts - 1 ])) w = double ( reform ( data [ 1 , 0 :npts - 1 ])) pitch = double ( reform ( data [ 2 , 0 :npts - 1 ])) * btipsign energy = reform ( data [ 3 , 0 :npts - 1 ]) * 1. d - 3 ; keV orbit_class = replicate ( 1 , npts ) if not keyword_set ( particle_weight ) then begin particle_weight = ntotal / float ( npts ) endif weight = replicate ( particle_weight , npts ) if not keyword_set ( e_range ) then begin e_range = [ min ( energy ), max ( energy )] endif if not keyword_set ( p_range ) then begin p_range = [ min ( pitch ), max ( pitch )] endif ww = where ( energy ge e_range [ 0 ] and energy le e_range [ 1 ], nw ) if nw eq 0 then begin error , 'No particles fall in requested energy range' , / halt endif wwp = where ( pitch [ ww ] ge p_range [ 0 ] and pitch [ ww ] le p_range [ 1 ], nwp ) if nwp eq 0 then begin error , 'No particles fall in the requested pitch range' , / halt endif ww = ww [ wwp ] nw = n_elements ( ww ) print , 'Time: ' , time print , 'Number of markers: ' , npts print , 'Number of markers in phase space: ' , nw print , 'Total Number of Fast-ions in phase space: ' , particle_weight * nw fbm_struct = { type : 2 , time : double ( time ), data_source: file_expand_path ( infile ), $ nparticle : long ( nw ), nclass : 1 , r : r [ ww ], z : w [ ww ], $ energy : energy [ ww ], pitch : pitch [ ww ], class : orbit_class [ ww ], $ weight : weight [ ww ]} return , fbm_struct END","tags":"","loc":"sourcefile/read_mc_nubeam.pro.html","title":"read_mc_nubeam.pro – FIDASIM"},{"text":"check_distribution Checks if distribution structure is valid Input Arguments inputs : Input structure grid : Interpolation grid structure dist : Fast-ion distribution structure Example Usage IDL > check_distribution, inputs, grid, dist Contents Source Code check_distribution.pro Source Code PRO check_distribution , inp , grid , dist ; +#check_distribution ; + Checks if distribution structure is valid ; +*** ; +## Input Arguments ; + **inputs**: Input structure ; + ; + **grid**: Interpolation grid structure ; + ; + **dist**: Fast - ion distribution structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_distribution , inputs , grid , dist ; + ``` err_status = 0 info , 'Checking fast-ion distribution' w = where ( \"type\" eq strlowcase ( TAG_names ( dist )), nw ) if nw eq 0 then begin error , '\"type\" is missing from the fast-ion distribution' err_status = 1 goto , GET_OUT endif dist_type = dist . type CASE dist_type OF 1 : BEGIN print , 'Using a Guiding Center Fast-ion Density Function' w = where ( \"nenergy\" eq strlowcase ( TAG_names ( dist )), nw ) if nw eq 0 then begin error , '\"nenergy\" is missing from the fast-ion distribution' err_status = 1 goto , GET_OUT endif w = where ( \"npitch\" eq strlowcase ( TAG_names ( dist )), nw ) if nw eq 0 then begin error , '\"npitch\" is missing from the fast-ion distribution' err_status = 1 goto , GET_OUT endif np = dist . npitch nen = dist . nenergy nr = grid . nr nz = grid . nz w = where ( \"nphi\" eq strlowcase ( TAG_NAMES ( grid )), nw ) if nw eq 0 then begin info , '\"nphi\" is missing from the fast-ion distribution, assuming axisymmetry' nphi = 1 endif else begin nphi = grid . nphi endelse zero_string = { dims : 0 , type : 'STRING' } zero_int = { dims : 0 , type : 'INT' } zero_double = { dims : 0 , type : 'DOUBLE' } nrnznphi_double = { dims :[ nr , nz , nphi ], type : 'DOUBLE' } schema = { type : zero_int , $ nenergy : zero_int , $ npitch : zero_int , $ energy :{ dims :[ nen ], type : 'DOUBLE' }, $ pitch :{ dims :[ np ], type : 'DOUBLE' }, $ denf : nrnznphi_double , $ f :{ dims :[ nen , np , nr , nz , nphi ], type : 'DOUBLE' }, $ time : zero_double , $ data_source:zero_string } check_struct_schema , schema , dist , err_status , desc= \"fast-ion distribution\" if err_status eq 1 then begin goto , GET_OUT endif dist = create_struct ( dist , grid ) END 2 : BEGIN print , 'Using Guiding Center Monte Carlo fast-ion distribution' w = where ( \"nparticle\" eq strlowcase ( TAG_names ( dist )), nw ) if nw eq 0 then begin error , '\"nparticle\" is missing from the fast-ion distribution' err_status = 1 goto , GET_OUT endif npart = dist . nparticle zero_int = { dims : 0 , type : 'INT' } zero_long = { dims : 0 , type : 'LONG' } zero_string = { dims : 0 , type : 'STRING' } zero_double = { dims : 0 , type : 'DOUBLE' } npart_double = { dims :[ npart ], type : 'DOUBLE' } npart_int = { dims :[ npart ], type : 'INT' } schema = { type : zero_int , $ nparticle : zero_long , $ nclass : zero_int , $ time : zero_double , $ energy : npart_double , $ pitch : npart_double , $ r : npart_double , $ z : npart_double , $ weight : npart_double , $ class : npart_int , $ data_source:zero_string } check_struct_schema , schema , dist , err_status , desc= \"fast-ion distribution\" if err_status eq 1 then begin goto , GET_OUT endif print , 'Number of MC particles: ' , npart END 3 : BEGIN print , 'Using Full Orbit Monte Carlo fast-ion distribution' w = where ( \"nparticle\" eq strlowcase ( TAG_names ( dist )), nw ) if nw eq 0 then begin error , '\"nparticle\" is missing from the fast-ion distribution' err_status = 1 goto , GET_OUT endif npart = dist . nparticle zero_int = { dims : 0 , type : 'INT' } zero_long = { dims : 0 , type : 'LONG' } zero_string = { dims : 0 , type : 'STRING' } zero_double = { dims : 0 , type : 'DOUBLE' } npart_double = { dims :[ npart ], type : 'DOUBLE' } npart_int = { dims :[ npart ], type : 'INT' } schema = { type : zero_int , $ nparticle : zero_long , $ nclass : zero_int , $ time : zero_double , $ vr : npart_double , $ vt : npart_double , $ vz : npart_double , $ r : npart_double , $ z : npart_double , $ weight : npart_double , $ class : npart_int , $ data_source:zero_string } check_struct_schema , schema , dist , err_status , desc= \"fast-ion distribution\" if err_status eq 1 then begin goto , GET_OUT endif print , 'Number of MC particles: ' , npart END ELSE : BEGIN error , 'Invalid distribution type. Expected ' + $ '1 (Guiding Center Density Function), ' + $ '2 (Guiding Center Monte Carlo), or ' + $ '3 (Full Orbit Monte Carlo)' err_status = 1 goto , GET_OUT END ENDCASE if dist . data_source eq '' then begin error , 'Invalid data source. An empty string is not a data source.' err_status = 1 endif if abs ( dist . time - inp . time ) gt 0.02 then begin warn , 'Distribution time and input time do not match' print , 'Input time: ' , inp . time print , 'Distribution time: ' , dist . time endif GET_OUT : if err_status ne 0 then begin error , 'Invalid fast-ion distribution. Exiting...' , / halt endif else begin success , 'Fast-ion distribution is valid' endelse END","tags":"","loc":"sourcefile/check_distribution.pro.html","title":"check_distribution.pro – FIDASIM"},{"text":"check_npa Checks if NPA geometry structure is valid Input Arguments inputs : input structure npa : NPA geometry structure Example Usage IDL > check_npa, inputs, npa Contents Source Code check_npa.pro Source Code PRO check_npa , inp , npa ; +#check_npa ; + Checks if NPA geometry structure is valid ; +*** ; +## Input Arguments ; + **inputs**: input structure ; + ; + **npa**: NPA geometry structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_npa , inputs , npa ; + ``` err_status = 0 info , 'Checking NPA geometry...' w = where ( \"nchan\" eq strlowcase ( TAG_NAMES ( npa )), nw ) if nw eq 0 then begin error , '\"nchan\" is missing from the NPA geometry' err_status = 1 goto , GET_OUT endif nchan = npa . nchan zero_string = { dims : 0 , type : 'STRING' } zero_long = { dims : 0 , type : 'LONG' } schema = { data_source:zero_string , $ nchan : zero_long , $ system : zero_string , $ id :{ dims :[ nchan ], type : 'STRING' }, $ a_shape: { dims :[ nchan ], type : 'INT' }, $ d_shape: { dims :[ nchan ], type : 'INT' }, $ a_tedge: { dims :[ 3 , nchan ], type : 'DOUBLE' }, $ a_redge: { dims :[ 3 , nchan ], type : 'DOUBLE' }, $ a_cent: { dims :[ 3 , nchan ], type : 'DOUBLE' }, $ d_tedge: { dims :[ 3 , nchan ], type : 'DOUBLE' }, $ d_redge: { dims :[ 3 , nchan ], type : 'DOUBLE' }, $ d_cent: { dims :[ 3 , nchan ], type : 'DOUBLE' }, $ radius :{ dims :[ nchan ], type : 'DOUBLE' } } check_struct_schema , schema , npa , err_status , desc= \"NPA geometry\" if err_status eq 1 then begin goto , GET_OUT endif ;; Check detector / aperture shape w = where ( npa . d_shape gt 2 or npa . d_shape eq 0 , nw ) if nw ne 0 then begin error , 'Invalid detector shape. Expected 1 (rectagular) or 2 (circular)' print , 'Invalid indices: ' , w err_status = 1 endif w = where ( npa . a_shape gt 2 or npa . a_shape eq 0 , nw ) if nw ne 0 then begin error , 'Invalid aperture shape. Expected 1 (rectagular) or 2 (circular)' print , 'Invalid indices: ' , w err_status = 1 endif ;; Calculate grid center rc and sides length dr dr = [ inp . xmax - inp . xmin , inp . ymax - inp . ymin , inp . zmax - inp . zmin ] rc = [ inp . xmin , inp . ymin , inp . zmin ] + 0.5 * dr err_arr = dblarr ( nchan ) for i = 0 , nchan - 1 do begin uvw_det = npa . d_cent [ * , i ] d_e1 = npa . d_redge [ * , i ] - uvw_det d_e2 = npa . d_tedge [ * , i ] - uvw_det uvw_aper = npa . a_cent [ * , i ] a_e1 = npa . a_redge [ * , i ] - uvw_aper a_e2 = npa . a_tedge [ * , i ] - uvw_aper uvw_dir = uvw_aper - uvw_det ;; Rotate chords into beam grid coordinates xyz_aper = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma , uvw_aper , origin = inp . origin ) xyz_det = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma , uvw_det , origin = inp . origin ) xyz_dir = xyz_aper - xyz_det xyz_dir = xyz_dir / sqrt ( total ( xyz_dir * xyz_dir )) ;; Check if npa chord intersects beam grid aabb_intersect , rc , dr , xyz_det , xyz_dir , length , r_enter , r_exit if length le 0.0 then begin err_arr [ i ] = 1 endif ;; Check if NPA detector is pointing in the right direction d_enter = sqrt ( total (( r_enter - xyz_aper ) &#94; 2 )) d_exit = sqrt ( total (( r_exit - xyz_aper ) &#94; 2 )) if d_exit lt d_enter then begin err_arr [ i ] = 1 endif ;; Check that the detector and aperture point in the right direction d_e3 = crossp ( d_e1 , d_e2 ) a_e3 = crossp ( a_e1 , a_e2 ) d_dp = total ( uvw_dir * d_e3 ) a_dp = total ( uvw_dir * a_e3 ) dp = total ( d_e3 * a_e3 ) if ( a_dp le 0.0 ) or ( d_dp le 0.0 ) or ( dp le 0.0 ) then begin error , 'The detector and/or aperture plane normal vectors are pointing in the wrong direction. The NPA definition is incorrect.' err_arr [ i ] = 1 endif endfor w = where ( err_arr eq 0.0 , nw , complement = ww , ncomplement = nww ) print , f='(i3,\" out of \",i3,\" channels crossed the beam grid\")' , nw , nchan if nw eq 0 then begin error , 'No channels intersect the beam grid' err_status = 1 endif if nww gt 0 then begin warn , 'Some channels did not intersect the beam grid' print , 'Number missed: ' , nww print , 'Missed channels:' print , '    ' , npa . id [ ww ] endif GET_OUT : if err_status ne 0 then begin error , 'Invalid NPA geometry. Exiting...' , / halt endif else begin success , 'NPA geometry is valid' endelse END","tags":"","loc":"sourcefile/check_npa.pro.html","title":"check_npa.pro – FIDASIM"},{"text":"check_fields Checks if electromagnetic fields structure is valid Input Arguments inputs : Input structure grid : Interpolation grid structure fields : Electromagnetic fields structure Example Usage IDL > check_fields, inputs, grid, fields Contents Source Code check_fields.pro Source Code PRO check_fields , inp , grid , fields ; +#check_fields ; + Checks if electromagnetic fields structure is valid ; +*** ; +## Input Arguments ; + **inputs**: Input structure ; + ; + **grid**: Interpolation grid structure ; + ; + **fields**: Electromagnetic fields structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_fields , inputs , grid , fields ; + ``` err_status = 0 info , 'Checking electromagnetic fields...' nr = grid . nr nz = grid . nz w = where ( \"nphi\" eq strlowcase ( TAG_NAMES ( grid )), nw ) if nw eq 0 then begin info , '\"nphi\" is missing from the fields, assuming axisymmetry' nphi = 1 endif else begin nphi = grid . nphi endelse zero_string = { dims : 0 , type : 'STRING' } zero_double = { dims : 0 , type : 'DOUBLE' } nrnznphi_double = { dims :[ nr , nz , nphi ], type : 'DOUBLE' } nrnznphi_int = { dims :[ nr , nz , nphi ], type : 'INT' } schema = { time : zero_double , $ br : nrnznphi_double , $ bt : nrnznphi_double , $ bz : nrnznphi_double , $ er : nrnznphi_double , $ et : nrnznphi_double , $ ez : nrnznphi_double , $ mask : nrnznphi_int , $ data_source:zero_string } check_struct_schema , schema , fields , err_status , desc = \"electromagnetic fields\" if err_status eq 1 then begin goto , GET_OUT endif if fields . data_source eq '' then begin error , 'Invalid data source. An empty string is not a data source.' err_status = 1 endif if abs ( fields . time - inp . time ) gt 0.02 then begin warn , 'Electromagnetic fields time and input time do not match' print , 'Input time: ' , inp . time print , 'Electromagnetic fields time: ' , fields . time endif fields = create_struct ( fields , grid ) GET_OUT : if err_status ne 0 then begin error , 'Invalid electromagnetic fields. Exiting...' , / halt endif else begin success , 'Electromagnetic fields are valid' endelse END","tags":"","loc":"sourcefile/check_fields.pro.html","title":"check_fields.pro – FIDASIM"},{"text":"success, str Print a success message Arguments str : message Example Usage IDL > success, \"Yay!!!\" Contents Source Code success.pro Source Code PRO success , str ; +## ` success , str ` ; + Print a success message ; +### Arguments ; + **str**: message ; + ; +### Example Usage ; + ``` idl ; + IDL > success , \"Yay!!!\" ; + ``` print , colored ( 'SUCCESS: ' + str , c='g' ) END","tags":"","loc":"sourcefile/success.pro.html","title":"success.pro – FIDASIM"},{"text":"read_nubeam Reads NUBEAM fast-ion distribution function Arguments filename : NUBEAM guiding center fast-ion distribution function file e.g. 159245H01_fi_1.cdf grid : Interpolation grid Keyword Arguments btipsign : Sign of the dot product of the magnetic field and plasma current e_range : Energy range to consider p_range : Pitch range to consider species : Fast-ion species number. Defaults to 1 Return Value Distribution structure Example Usage IDL > dist = read_nubeam( \"./159245H02_fi_1.cdf\" ,grid,btipsign =- 1 ) Contents Source Code read_nubeam.pro Source Code FUNCTION grid_fbm , r2d , z2d , fbm , fdens , rout , zout compile_opt idl2 , logical_predicate s = size ( fbm , / dim ) nenergy = s [ 0 ] npitch = s [ 1 ] nr = n_elements ( rout ) nz = n_elements ( zout ) nr2d = n_elements ( r2d ) dim = [ nr , nz ] delta = abs ([ rout [ 1 ] - rout [ 0 ], zout [ 1 ] - zout [ 0 ]]) start = [ min ( rout ), min ( zout )] triangulate , r2d , z2d , tr r2dt = r2d [ tr [ * ]] z2dt = z2d [ tr [ * ]] linTr = lindgen ( size ( tr , / dim )) index = lindgen ( n_elements ( tr )) / 3 * 3 tr_num = round ( griddata ( r2dt , z2dt , float ( index ), triangles = linTr , / linear , $ start = start , delta = delta , dimension = dim )) wts = ptrarr ( 3 ) for i = 0 , 2 do begin w = griddata ( r2dt , z2dt ,( lindgen ( n_elements ( r2dt )) mod 3 ) eq i , triangles = linTr , / linear , $ start = start , delta = delta , dimension = dim ) wts [ i ] = ptr_new ( w , / no_copy ) endfor denf = dblarr ( nr , nz ) for i = 0 , 2 do begin denf = denf + fdens [ tr [ tr_num + i ]] * ( * wts [ i ]) endfor denf = denf > 0 fbm_grid = dblarr ( nenergy , npitch , nr , nz ) for i = 0 , nenergy - 1 do begin for j = 0 , npitch - 1 do begin for k = 0 , 2 do begin fbm_grid [ i , j , * , * ] = fbm_grid [ i , j , * , * ] + fbm [ i , j , tr [ tr_num + k ]] * ( * wts [ k ]) endfor endfor endfor fbm_grid = fbm_grid > 0 ;; Catch points outside of triangulation tr_ind = fix ( griddata ( r2d , z2d , indgen ( nr2d ), triangles = tr , / nearest_neighbor , $ start = start , delta = delta , dimension = dim )) denf_nn = fdens [ tr_ind ] fbm_grid_nn = fbm [ * , * , tr_ind ] w = where ( denf le 0.0 , nw ) if nw ne 0 then begin denf [ w ] = denf_nn [ w ] inds = array_indices ( denf , w ) for i = 0 , nw - 1 do begin fbm_grid [ * , * , inds [ 0 , i ], inds [ 1 , i ]] = fbm_grid_nn [ * , * , w [ i ]] endfor end return , { denf : denf , fbm : fbm_grid } END FUNCTION read_nubeam , filename , grid , btipsign = btipsign , e_range = e_range , p_range = p_range , species = species ; +#read_nubeam ; + Reads NUBEAM fast - ion distribution function ; +*** ; +## Arguments ; + **filename**: NUBEAM guiding center fast - ion distribution function file e . g . 159245 H01_fi_1 . cdf ; + ; + **grid**: Interpolation grid ; + ; +## Keyword Arguments ; + **btipsign**: Sign of the dot product of the magnetic field and plasma current ; + ; + **e_range**: Energy range to consider ; + ; + **p_range**: Pitch range to consider ; + ; + **species**: Fast - ion species number . Defaults to 1 ; + ; +## Return Value ; + Distribution structure ; + ; +## Example Usage ; + ``` idl ; + IDL > dist = read_nubeam ( \"./159245H02_fi_1.cdf\" , grid , btipsign=- 1 ) ; + ``` if not keyword_set ( btipsign ) then btipsign = - 1 cdftest = findfile ( filename ) if cdftest [ 0 ] eq '' then begin err = 1 goto , GET_OUT endif if not keyword_set ( species ) then species = 1 sstr = string (( read_ncdf ( filename , vars = [ \"SPECIES_\" + strcompress ( species , / r )])).( 1 )) vars = read_ncdf ( filename , vars = [ \"TIME\" , \"R2D\" , \"Z2D\" , \"E_\" + sstr , \"A_\" + sstr , $ \"F_\" + sstr , \"RSURF\" , \"ZSURF\" , \"BMVOL\" ]) ngrid = n_elements ( vars . r2d ) ;; ------------- Convert eV-> keV time = vars . time r2d = vars . r2d z2d = vars . z2d rsurf = vars . rsurf zsurf = vars . zsurf index = where ( tag_names ( vars ) EQ \"A_\" + sstr ) pitch = vars .( index [ 0 ]) index = where ( tag_names ( vars ) EQ \"E_\" + sstr ) energy = vars .( index [ 0 ]) * 1.0 d - 3 ;; fidasim needs energy in kev index = where ( tag_names ( vars ) EQ \"F_\" + sstr ) fbm = vars .( index [ 0 ]) * 1.0 d3 ;; now , this needs to be corrected ;; as we now calculate with fast - ions / omega / keV / cm&#94; 3 ;; ------------ Convert d_omega --> pitch ;; Fast - ion distribution is given as a function of cm&#94; 3 , energy ;; and d_omega / 4 Pi . omega is the solild angle in 3 D velocity space . In ;; order to transform this to a function depending on pitch instead ;; of d_omega / 4 PI , one has to multiply by 0.5 ! fbm*= 0.5 ;; make sure that fbm is >= 0 : fbm >= 0. ;; loading finished ;; TRANSP defines the pitch along the current direction . In ;; contrast , FIDASIM uses pitch along the B - field ! Therefore , ;; reverse the pitch coordinate in fbm if B and J are anti - parallel ! if btipsign lt 0 then begin npitch = n_elements ( pitch ) index = npitch- ( indgen ( npitch ) + 1 ) fbm [ * , * , * ] = fbm [ * , index , * ] endif if not keyword_set ( e_range ) then begin e_range = [ min ( energy ), max ( energy )] endif if not keyword_set ( p_range ) then begin p_range = [ min ( pitch ), max ( pitch )] endif ;; ----------- select energy range ------- index = where ( energy ge e_range [ 0 ] and energy le e_range [ 1 ], nenergy ) energy = energy [ index ] fbm = fbm [ index , * , * ] dE = energy [ 1 ] - energy [ 0 ] emin= ( float ( energy [ 0 ]) - float ( 0.5 * dE )) > 0. emax = float ( energy [ nenergy - 1 ]) + float ( 0.5 * dE ) print , 'Energy min/max:' , emin , emax ;; --------- select Pitch range -------- index = where ( pitch ge p_range [ 0 ] and pitch le p_range [ 1 ], npitch ) pitch = pitch [ index ] fbm = fbm [ * , index , * ] dP = abs ( pitch [ 1 ] - pitch [ 0 ]) pmin= ( float ( pitch [ 0 ]) - float ( 0.5 * dP )) > ( - 1 ) pmax= ( float ( pitch [ npitch - 1 ]) + float ( 0.5 * dP )) < 1 print , 'Pitch  min/max:' , pmin , pmax ;; ------map fdens on FIDASIM grid and sort out ;; ------points outside the separatrix nr = grid . nr nz = grid . nz nphi = grid . nphi rgrid = grid . r zgrid = grid . z dr = abs ( rgrid [ 1 ] - rgrid [ 0 ]) dz = abs ( zgrid [ 1 ] - zgrid [ 0 ]) ;; FBM & DENF fdens = total ( reform ( total ( fbm , 1 )), 1 ) * dE * dP ntot = total ( fdens * vars . bmvol ) print , 'Ntotal in phase space: ' , ntot fstr = grid_fbm ( r2d , z2d , fbm , fdens , rgrid , zgrid ) denf = fstr . denf fbm_grid = fstr . fbm ;; sort out positions more than 2 cm outside the separatrix rmaxis = mean ( rsurf [ * , 0 ]) zmaxis = mean ( zsurf [ * , 0 ]) rsep = rsurf [ * ,( size ( rsurf ))[ 2 ] - 1 ] zsep = zsurf [ * ,( size ( rsurf ))[ 2 ] - 1 ] x_bdry = rsep - rmaxis y_bdry = zsep - zmaxis r_bdry = sqrt ( x_bdry&#94; 2 + y_bdry&#94; 2 ) theta = atan ( y_bdry , x_bdry ) ;; -- sort and remove identical values -- index = uniq ( theta , sort ( theta )) theta = theta [ index ] r = r_bdry [ index ] ;; --- make theta periodic n = n_elements ( r ) r_bdry = fltarr ( n + 2 ) theta_bdry = fltarr ( n + 2 ) theta_bdry [ 1 :n ] = theta r_bdry [ 1 :n ] = r r_bdry [ 0 ] = r [ n - 1 ] theta_bdry [ 0 ] = theta [ n - 1 ] - 2. * ! pi r_bdry [ n + 1 ] = r [ 0 ] theta_bdry [ n + 1 ] = theta [ 0 ] + 2. * ! pi ;; -- express ( r_pts , z_pts ) in ( r , theta ) coordinates -- x_pts = grid . r2d - rmaxis y_pts = grid . z2d - zmaxis r_pts = sqrt ( x_pts&#94; 2 + y_pts&#94; 2 ) theta_pts = atan ( y_pts , x_pts ) ;; -- interpolate to get the radial position of the boundary ;; evaluated at theta = theta_pts -- index = sort ( theta_pts ) mapped = interpol ( r_bdry , theta_bdry , theta_pts [ index ]) r_boundary = theta_pts * 0. d r_boundary [ index ] = mapped index = where ( r_pts gt r_boundary + 2. , nind ) if nind gt 0 then begin indices = array_indices ( r_pts , index ) for i = 0 ,( size ( indices ))[ 2 ] - 1 do begin fbm_grid [ * , * , indices [ 0 , i ], indices [ 1 , i ]] = 0. denf [ indices [ 0 , i ], indices [ 1 , i ]] = 0. endfor endif ;; enforce correct normalization ntot_denf = ( 2 * ! dpi * dr * dz ) * total ( rgrid * total ( denf , 2 )) denf = denf* ( ntot / ntot_denf ) ntot_fbm = ( 2 * ! dpi * dr * dz * dE * dP ) * total ( rgrid * total ( total ( total ( fbm_grid , 1 ), 1 ), 2 )) fbm_grid = fbm_grid* ( ntot / ntot_fbm ) denf = rebin ( denf , nr , nz , nphi ) fbm_grid = rebin ( fbm_grid , nenergy , npitch , nr , nz , nphi ) fbm_struct= { type : 1 , time : time , nenergy : fix ( nenergy ), energy : energy , npitch : fix ( npitch ), $ pitch : pitch , f : fbm_grid , denf : denf , data_source: file_expand_path ( filename )} return , fbm_struct GET_OUT : END","tags":"","loc":"sourcefile/read_nubeam.pro.html","title":"read_nubeam.pro – FIDASIM"},{"text":"read_hdf5 Reads HDF5 file variables and attributes Arguments filename : HDF5 file Keyword Arguments paths : Paths to variables to be read flatten : Flatten tree structure shallow : Performs a shallow read i.e. no dataset/group attributes Return Value Structure containing variables and attributes Example Usage IDL > a = read_hdf5( \"./test_1a_geometry.h5\" )\nIDL > b = read_hdf5( \"./test_1a_geometry.h5\" ,paths = \"/spec/lens\" , / flatten, / shallow) Contents Source Code read_hdf5.pro Source Code FUNCTION valid_name , name , bad_names = bad_names , post = post reserved = [ 'AND' , 'BEGIN' , 'BREAK' , 'CASE' , 'COMMON' , 'COMPILE_OPT' , $ 'CONTINUE' , 'DO' , 'ELSE' , 'END' , 'ENDCASE' , 'ENDELSE' , $ 'ENDFOR' , 'ENDFOREACH' , 'ENDIF' , 'ENDREP' , 'ENDSWITCH' , 'ENDWHILE' , $ 'EQ' , 'FOR' , 'FOREACH' , 'FORWARD_FUNCTION' , 'FUNCTION' , 'GE' , $ 'GOTO' , 'GT' , 'IF' , 'INHERITS' , 'LE' , 'LT' , 'MOD' , 'NE' , 'NOT' , 'OF' , $ 'ON_IOERROR' , 'OR' , 'PRO' , 'REPEAT' , 'SWITCH' , 'THEN' , 'UNTIL' , $ 'WHILE' , 'X0R' ] if not keyword_set ( bad_names ) then bad_names = '' if not keyword_set ( post ) then post = '' bad_names = [ reserved , bad_names ] if total ( strmatch ( bad_names , name , / fold_case )) ne 0 then begin valid_name = name + '_' + post endif else begin valid_name = name endelse ; added 2016 - 09 - 15 by NGB to fix invalid structure tags valid_name = idl_validname ( valid_name , / convert_all ) return , valid_name END FUNCTION create_nested_struct , path , data rpath = reverse ( strsplit ( path , '/' , / extract )) d = data for i = 0 , n_elements ( rpath ) - 1 do begin varname = valid_name ( rpath [ i ]) d = create_struct ( varname , d ) endfor return , d END FUNCTION hdf5_read_attributes , id , bad_names = bad_names ;; Get any attributes natts = h5a_get_num_attrs ( id ) atts = {} for i = 0 L , natts - 1 do begin ;; Open attribute id attribute_id = h5a_open_idx ( id , i ) ;; Get attribute name and make sure its valid attribute_name = h5a_get_name ( attribute_id ) attribute_name = valid_name ( attribute_name , $ bad_names = bad_names , $ post = strcompress ( string ( i ), / remove_all )) ;; Get the attribute data attribute_data = h5a_read ( attribute_id ) atts = create_struct ( atts , attribute_name , attribute_data ) ;; Close attribute id h5a_close , attribute_id endfor return , atts END FUNCTION hdf5_read_dataset , id , name , shallow = shallow ;; Get data dataset_id = h5d_open ( id , name ) data = h5d_read ( dataset_id ) ;; Get any attributes atts = hdf5_read_attributes ( dataset_id , bad_names= \"data\" ) ;; Close the dataset h5d_close , dataset_id if keyword_set ( shallow ) then begin return , data endif else begin return , create_struct ( atts , \"data\" , data ) endelse END FUNCTION hdf5_read_group , id , shallow = shallow FORWARD_FUNCTION hdf5_read_group nobjs = h5g_get_num_objs ( id ) d = {} for i = 0 , nobjs - 1 do begin obj_name = h5g_get_obj_name_by_idx ( id , i ) var_name = valid_name ( obj_name ) obj_info = h5g_get_objinfo ( id , obj_name ) obj_type = obj_info . type CASE obj_type OF 'GROUP': BEGIN gid = h5g_open ( id , obj_name ) var = hdf5_read_group ( gid , shallow = shallow ) h5g_close , gid if n_elements ( var ) ne 0 then begin d = create_struct ( d , var_name , var ) endif END 'DATASET': BEGIN var = hdf5_read_dataset ( id , obj_name , shallow = shallow ) if n_elements ( var ) ne 0 then begin d = create_struct ( d , var_name , var ) endif END 'TYPE': BEGIN tid = h5t_open ( id , obj_name ) var = hdf5_read_attributes ( tid ) h5t_close , tid if n_elements ( var ) ne 0 then begin d = create_struct ( d , var_name , var ) endif END ELSE : ENDCASE endfor if not keyword_set ( shallow ) then begin atts = hdf5_read_attributes ( id ) endif if n_elements ( atts ) ne 0 then begin return , create_struct ( d , atts ) endif else begin return , d endelse END FUNCTION hdf5_read_from_list , id , var_paths , flatten = flatten , shallow = shallow d = {} used_names = [] i = 0 L while i lt n_elements ( var_paths ) do begin catch , err_status if err_status ne 0 then begin print , 'Error reading ' + var_paths [ i ] print ,! ERROR_STATE . MSG catch , / cancel i = i + 1 continue endif path = var_paths [ i ] obj_info = h5g_get_objinfo ( id , path ) obj_type = obj_info . type CASE obj_type OF 'LINK': BEGIN var_name = h5g_get_linkval ( id , path ) var_paths = [ var_paths , var_name ] END 'GROUP': BEGIN gid = h5g_open ( id , path ) var = hdf5_read_group ( gid , shallow = shallow ) h5g_close , gid if n_elements ( var ) ne 0 then begin if keyword_set ( flatten ) then begin var_names = strsplit ( path , '/' , / extract ) var_name = valid_name ( var_names [ - 1 ], $ bad_names = used_names , $ post = strcompress ( string ( i ), / remove_all )) used_names = [ used_names , var_name ] d = create_struct ( d , var_name , var ) endif else begin d = create_struct ( d , create_nested_struct ( path , var )) endelse endif END 'DATASET': BEGIN var = hdf5_read_dataset ( id , path , shallow = shallow ) if n_elements ( var ) ne 0 then begin if keyword_set ( flatten ) then begin var_names = strsplit ( path , '/' , / extract ) var_name = valid_name ( var_names [ - 1 ], $ bad_names = used_names , $ post = strcompress ( string ( i ), / remove_all )) used_names = [ used_names , var_name ] d = create_struct ( d , var_name , var ) endif else begin d = create_struct ( d , create_nested_struct ( path , var )) endelse endif END 'TYPE': BEGIN tid = h5t_open ( id , path ) var = hdf5_read_attributes ( tid ) h5t_close , tid if n_elements ( var ) ne 0 then begin if keyword_set ( flatten ) then begin var_names = strsplit ( path , '/' , / extract ) var_name = valid_name ( var_names [ - 1 ], $ bad_names = used_names , $ post = strcompress ( string ( i ), / remove_all )) used_names = [ used_names , var_name ] d = create_struct ( d , var_name , var ) endif else begin d = create_struct ( d , create_nested_struct ( path , var )) endelse endif END ELSE : ENDCASE i = i + 1 endwhile return , d END FUNCTION read_hdf5 , filename , paths = paths , flatten = flatten , shallow = shallow ; +#read_hdf5 ; + Reads HDF5 file variables and attributes ; +*** ; +## Arguments ; + **filename**: HDF5 file ; + ; +## Keyword Arguments ; + **paths**: Paths to variables to be read ; + ; + **flatten**: Flatten tree structure ; + ; + **shallow**: Performs a shallow read i . e . no dataset / group attributes ; + ; +## Return Value ; + Structure containing variables and attributes ; + ; +## Example Usage ; + ``` idl ; + IDL > a = read_hdf5 ( \"./test_1a_geometry.h5\" ) ; + IDL > b = read_hdf5 ( \"./test_1a_geometry.h5\" , paths= \"/spec/lens\" , / flatten , / shallow ) ; + ``` if file_test ( filename ) then begin ;; Open file fid = h5f_open ( filename ) if not keyword_set ( paths ) then begin ;; Read group and sub - groups d = hdf5_read_group ( fid , shallow = shallow ) endif else begin ;; Read datasets from list d = hdf5_read_from_list ( fid , paths , flatten = flatten , shallow = shallow ) endelse ;; Close file h5f_close , fid endif else begin print , 'File does not exist' return , 0 endelse return , d END","tags":"","loc":"sourcefile/read_hdf5.pro.html","title":"read_hdf5.pro – FIDASIM"},{"text":"check_struct_schema Check structure s is formatted according to schema Input Arguments schema : structure schema s : structure to check Output Arguments err : error code Keyword Arguments desc : description of structure s Example usage IDL > s = {a : 0 , b : [ 1.d0 , 2.d0 ], c : \"example\" }\nIDL > schema = {a : {dims : 0 ,type : \"INT\" }, b : {dims : [ 2 ],type : \"DOUBLE\" }, c : {dims : 0 ,type : \"STRING\" }  }\n\nIDL > check_struct_schema, schema, s, err, desc = \"Example structure\" IDL > print , err 0 Contents Source Code check_struct_schema.pro Source Code PRO check_struct_schema , schema , s , err_status , desc = desc ; +#check_struct_schema ; + Check structure ` s ` is formatted according to ` schema ` ; +*** ; +## Input Arguments ; + **schema**: structure schema ; + ; + **s**: structure to check ; + ; +## Output Arguments ; + **err**: error code ; + ; +## Keyword Arguments ; + **desc**: description of structure ` s ` ; + ; +## Example usage ; + ``` idl ; + IDL > s = { a : 0 , b :[ 1. d0 , 2. d0 ], c : \"example\" } ; + IDL > schema = { a :{ dims : 0 , type : \"INT\" }, b :{ dims :[ 2 ], type : \"DOUBLE\" }, c :{ dims : 0 , type : \"STRING\" } } ; + ; + IDL > check_struct_schema , schema , s , err , desc= \"Example structure\" ; + IDL > print , err ; + 0 ; + ``` if not keyword_set ( struct_name ) then desc = 'structure' err_status = 0 schema_tags = strlowcase ( TAG_NAMES ( schema )) tags = strlowcase ( TAG_NAMES ( s )) for i = 0 , n_elements ( tags ) - 1 do begin w = where ( tags [ i ] eq schema_tags , nw ) if nw eq 0 then begin info , 'Extra variable \"' + tags [ i ] +'\" found in ' + desc endif endfor for i = 0 , n_elements ( schema_tags ) - 1 do begin w = where ( schema_tags [ i ] eq tags , nw ) if nw eq 0 then begin error , '\"' + schema_tags [ i ] +'\" is missing from the ' + desc err_status = 1 endif else begin ;; Check dimensions ww = where (( size ( s .( w ), / dim ) eq schema .( i ). dims ) ne 1 , nww ) if nww ne 0 then begin error , '\"' + schema_tags [ i ] +'\" has the wrong dimensions. Expected (' + $ strjoin ( strcompress ( string ( schema .( i ). dims ), / remove_all ), ',' ) +')' print , 'size(' + schema_tags [ i ] +') = ' , size ( s .( w ), / dim ) err_status = 1 endif ;; Check type tname = size ( s .( w ), / tname ) if tname ne schema .( i ). type then begin error , '\"' + schema_tags [ i ] +'\" has the wrong type. Expected ' + schema .( i ). type print , 'type(' + schema_tags [ i ] +') = ' + tname err_status = 1 endif ;; Check for NaNs or Inf if tname ne 'STRING' and tname ne 'STRUCT' then begin ww = where ( finite ( s .( w )) eq 0 , nww ) endif else nww = 0 if nww ne 0 then begin error , 'NaN or Infinity detected in \"' + schema_tags [ i ] +'\"' err_status = 1 endif endelse endfor END","tags":"","loc":"sourcefile/check_struct_schema.pro.html","title":"check_struct_schema.pro – FIDASIM"},{"text":"save_to_hdf5 Converts an IDL save file to a HDF5 file Arguments savefile : IDL save file Keyword Arguments filename : HDF5 file name defaults to IDL save file name Example Usage IDL > sav_to_hdf5, './dne159245.00500' Contents Source Code sav_to_hdf5.pro Source Code PRO sav_to_hdf5 , savefile , filename = filename ; +#save_to_hdf5 ; + Converts an IDL save file to a HDF5 file ; +*** ; +## Arguments ; + **savefile**: IDL save file ; + ; +## Keyword Arguments ; + **filename**: HDF5 file name defaults to IDL save file name ; + ; +## Example Usage ; + ``` idl ; + IDL > sav_to_hdf5 , './dne159245.00500' ; + ``` if not keyword_set ( filename ) then begin p = strsplit ( savefile , '.' , / extract ) if strlowcase ( p [ - 1 ]) eq 'sav' then c = 2 else c = 1 filename = strjoin ( p [ 0 : n_elements ( p ) - c ], '.' ) +'.h5' endif restore , savefile sObj = OBJ_NEW ( 'IDL_Savefile' , savefile ) vars = strlowcase ( sObj-> Names ()) write_hdf5 , vars , filename = filename END","tags":"","loc":"sourcefile/sav_to_hdf5.pro.html","title":"sav_to_hdf5.pro – FIDASIM"},{"text":"warn, str Print a warning message Arguments str : message Example Usage IDL > warn, \"This may be a problem\" Contents Source Code warn.pro Source Code PRO warn , str ; +## ` warn , str ` ; + Print a warning message ; +### Arguments ; + **str**: message ; + ; +### Example Usage ; + ``` idl ; + IDL > warn , \"This may be a problem\" ; + ``` print , colored ( 'WARNING: ' + str , c='y' ) END","tags":"","loc":"sourcefile/warn.pro.html","title":"warn.pro – FIDASIM"},{"text":"check_grid Checks if interpolation grid structure is valid Input Arguments grid : Interpolation grid structure Example Usage IDL > check_grid, grid Contents Source Code check_grid.pro Source Code PRO check_grid , grid ; +#check_grid ; + Checks if interpolation grid structure is valid ; +*** ; +## Input Arguments ; + **grid**: Interpolation grid structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_grid , grid ; + ``` err_status = 0 info , 'Checking interpolation grid...' w = where ( \"nr\" eq strlowcase ( TAG_NAMES ( grid )), nw ) if nw eq 0 then begin error , '\"nr\" is missing from the interpolation grid' err_status = 1 goto , GET_OUT endif w = where ( \"nz\" eq strlowcase ( TAG_NAMES ( grid )), nw ) if nw eq 0 then begin error , '\"nz\" is missing from the interpolation grid' err_status = 1 goto , GET_OUT endif w = where ( \"nphi\" eq strlowcase ( TAG_NAMES ( grid )), nw ) if nw eq 0 then begin info , '\"nphi\" is missing from the interpolation grid, assuming axisymmetry' nphi = 1 endif else begin nphi = grid . nphi endelse nr = grid . nr nz = grid . nz zero_int = { dims : 0 , type : 'INT' } schema = { nr : zero_int , nz : zero_int , nphi : zero_int , $ r2d: { dims :[ nr , nz ], type : 'DOUBLE' }, $ z2d: { dims :[ nr , nz ], type : 'DOUBLE' }, $ r :{ dims :[ nr ], type : 'DOUBLE' }, $ z :{ dims :[ nz ], type : 'DOUBLE' }, $ phi :{ dims :[ nphi ], type : 'DOUBLE' } } check_struct_schema , schema , grid , err_status , desc= \"interpolation grid\" if err_status eq 1 then begin goto , GET_OUT endif w = where (( indgen ( nr ) eq sort ( grid . r )) ne 1 , nw ) if nw ne 0 then begin error , 'r is not in ascending order' err_status = 1 endif w = where (( indgen ( nz ) eq sort ( grid . z )) ne 1 , nw ) if nw ne 0 then begin error , 'z is not in ascending order' err_status = 1 endif w = where (( indgen ( nphi ) eq sort ( phi )) ne 1 , nw ) if nw ne 0 then begin error , 'phi is not in ascending order' err_status = 1 endif w = where (( grid . r eq grid . r2d [ * , 0 ]) ne 1 , nw ) if nw ne 0 then begin error , 'r2d is defined incorrectly. Expected r == r2d[*,0]' err_status = 1 endif w = where (( grid . z eq grid . z2d [ 0 , * ]) ne 1 , nw ) if nw ne 0 then begin error , 'z2d is defined incorrectly. Expected z == z2d[0,*]' err_status = 1 endif GET_OUT : if err_status ne 0 then begin error , 'Invalid interpolation grid. Exiting...' , / halt endif else begin success , 'Interpolation grid is valid' endelse END","tags":"","loc":"sourcefile/check_grid.pro.html","title":"check_grid.pro – FIDASIM"},{"text":"in_vessel Calculates whether a given r,z is within the vessel Arguments rwall : r values of the wall zwall : z values of the wall r : r values z : z values Return Value 0 for false, 1 for true Example Usage IDL > inv = in_vessel(rwall,zwall,r,z) Contents Source Code in_vessel.pro Source Code FUNCTION is_left , p0 , p1 , p2 return , (( p1 [ 0 ] - p0 [ 0 ]) * ( p2 [ 1 ] - p0 [ 1 ]) - ( p2 [ 0 ] - p0 [ 0 ]) * ( p1 [ 1 ] - p0 [ 1 ])) END FUNCTION in_vessel , rwall , zwall , r , z ; +#in_vessel ; + Calculates whether a given r , z is within the vessel ; +*** ; +## Arguments ; + **rwall**: r values of the wall ; + ; + **zwall**: z values of the wall ; + ; + **r**: r values ; + ; + **z**: z values ; + ; +## Return Value ; + 0 for false , 1 for true ; + ; +## Example Usage ; + ``` idl ; + IDL > inv = in_vessel ( rwall , zwall , r , z ) ; + ``` if n_elements ( rwall ) ne n_elements ( zwall ) then begin error , \"rwall and zwall must have the same number of elements\" stop endif nv = n_elements ( rwall ) v = [[ reform ( rwall , nv )],[ reform ( zwall , nv )]] if n_elements ( r ) ne n_elements ( z ) then begin error , \"r and z must have the same number of elements\" stop endif np = n_elements ( r ) dims = size ( r , / d ) rr = reform ( r , np ) zz = reform ( z , np ) inv = intarr ( np ) for ip = 0 , np - 1 do begin p = [ rr [ ip ], zz [ ip ]] wn = 0 for i = 0 , nv - 1 do begin i1 = ( i + 1 ) mod nv if v [ i , 1 ] le p [ 1 ] then begin if v [ i1 , 1 ] gt p [ 1 ] then begin if is_left ( v [ i , * ], v [ i1 , * ], p ) gt 0.0 then begin wn = wn + 1 endif endif endif else begin if v [ i1 , 1 ] le p [ 1 ] then begin if is_left ( v [ i , * ], v [ i1 , * ], p ) lt 0.0 then begin wn = wn - 1 endif endif endelse endfor inv [ ip ] = wn ne 0 endfor return , reform ( inv , dims ) END","tags":"","loc":"sourcefile/in_vessel.pro.html","title":"in_vessel.pro – FIDASIM"},{"text":"read_json Reads a JSON file that can have YAML like comments Arguments file : JSON file Return Value Structure containg JSON values Example Usage IDL > json_struct = read_json( \"./file.json\" ) Contents Source Code read_json.pro Source Code FUNCTION tokenize , str , regex ;;; Splits string into tokens according to regex ;;; json = str group = [] start = [] finish = [] cnt = 0 while stregex ( json , regex , / BOOLEAN ) do begin pos = stregex ( json , regex , length = len ) tmp = strmid ( json , pos , len ) group = [ group , tmp ] if cnt eq 0 then begin start = [ start , pos ] finish = [ finish , pos + len ] endif else begin start = [ start , finish [ cnt - 1 ] + pos ] finish = [ finish , finish [ cnt - 1 ] + pos + len ] endelse json = strmid ( json , pos + len , strlen ( json )) cnt+= 1 endwhile return ,{ group : group , start : start , finish : finish } END FUNCTION json_minify , str ;;; Strips out C like comments out of JSON string ;;; ;;; Based of JSON . minify https : // github . com / getify / JSON . minify ;;; regex='\"|(#=)|(=#)|(#)|' + string ( 10 b ) +'|' + string ( 13 b ) slashes='(\\*$' in_string = 0 in_multi = 0 in_single = 0 new_str='' index = 0 tokenizer = tokenize ( str , regex ) for i = 0 , n_elements ( tokenizer . group ) - 1 do begin if not ( in_multi or in_single ) then begin tmp = strmid ( str , index , tokenizer . start [ i ] - index ) if not in_string then begin tmp = strcompress ( tmp , / remove_all ) tmp = strjoin ( strsplit ( tmp , string ( 10 b ), / extract , / regex ), '' ) tmp = strjoin ( strsplit ( tmp , string ( 13 b ), / extract , / regex ), '' ) endif new_str+=tmp endif index = tokenizer . finish [ i ] val = tokenizer . group [ i ] if val eq '\"' and not ( in_multi or in_single ) then begin escaped = stregex ( strmid ( str , 0 , tokenizer . start [ i ]), slashes , / EXTRACT ) if not in_string or ( escaped eq '' or strlen ( escaped ) mod 2 eq 0 ) then in_string = not in_string index-= 1 endif else if not ( in_string or in_multi or in_single ) then begin if val eq '#=' then in_multi = 1 else if val eq '#' then in_single = 1 endif else if val eq '=#' and in_multi and not ( in_string or in_single ) then begin in_multi = 0 endif else if ( stregex ( val , string ( 10 b ), / boolean ) or stregex ( val , string ( 13 b ), / boolean )) $ and not ( in_multi or in_string ) and in_single then begin in_single = 0 endif else if not (( in_multi or in_single ) or $ ( stregex ( val , string ( 10 b ), / boolean ) or $ stregex ( val , string ( 13 b ), / boolean ) or $ stregex ( val , string ( 9 b ), / boolean ) or $ stregex ( val , string ( 32 b ), / boolean ) )) then begin new_str+=val endif endfor new_str+= strmid ( str , index , strlen ( str ) - index ) return , new_str END FUNCTION read_json , file ; +#read_json ; + Reads a JSON file that can have YAML like comments ; +*** ; +## Arguments ; + **file**: JSON file ; + ; +## Return Value ; + Structure containg JSON values ; + ; +## Example Usage ; + ``` idl ; + IDL > json_struct = read_json ( \"./file.json\" ) ; + ``` openr , lun , file , / GET_LUN json='' tmp='' while not EOF ( lun ) do begin readf , lun , tmp json+=tmp json+= string ( 10 b ) endwhile free_lun , lun stripped_json = json_minify ( json ) return , json_parse ( stripped_json , / toarray , / tostruct ) END","tags":"","loc":"sourcefile/read_json.pro.html","title":"read_json.pro – FIDASIM"},{"text":"uvw_to_xyz(alpha, beta, gamma, uvw, origin=[0,0,0]) Express non-rotated coordinate uvw in rotated xyz coordinates Arguments alpha : Rotation angle about z [radians] beta : Rotation angle about y' [radians] gamma : Rotation angle about x\" [radians] xyz : Point in rotated coordinate system Keyword Arguments origin : Origin of rotated coordinate system in non-rotated (uvw) coordinates. Example Usage IDL > xyz = uvw_to_xyz(!DPI / 2 , 0.0 ,!DPI / 3 ,uvw) Contents Source Code uvw_to_xyz.pro Source Code FUNCTION uvw_to_xyz , alpha , beta , gamma , uvw , origin = origin ; +## ` uvw_to_xyz ( alpha , beta , gamma , uvw , origin = [ 0 , 0 , 0 ]) ` ; + Express non - rotated coordinate ` uvw ` in rotated ` xyz ` coordinates ; +### Arguments ; + **alpha**: Rotation angle about z [ radians ] ; + ; + **beta**: Rotation angle about y ' [ radians ] ; + ; + **gamma**: Rotation angle about x \" [ radians ] ; + ; + **xyz**: Point in rotated coordinate system ; + ; +### Keyword Arguments ; + **origin**: Origin of rotated coordinate system in non - rotated ( uvw ) coordinates . ; + ; +### Example Usage ; + ``` idl ; + IDL > xyz = uvw_to_xyz (! DPI / 2 , 0.0 ,! DPI / 3 , uvw ) ; + ``` if not keyword_set ( origin ) then origin = [ 0.0 , 0.0 , 0.0 ] s = size ( uvw , / dim ) if n_elements ( s ) ne 2 then s = [ s , 1 ] uvw_shifted = transpose ( uvw - tile_array ( origin , 1 , s [ 1 ])) R = transpose ( tb_zyx ( alpha , beta , gamma )) xyz = R ##uvw_shifted return , transpose ( xyz ) END","tags":"","loc":"sourcefile/uvw_to_xyz.pro.html","title":"uvw_to_xyz.pro – FIDASIM"},{"text":"rz_grid Creates interpolation grid Arguments rmin : Minimum radius [cm] rmax : Maximum radius [cm] nr : Number of radii zmin : Minimum Z value [cm] zmax : Maximum Z value [cm] nz : Number of z values Return Value Interpolation grid structure Example Usage IDL > grid = rz_grid( 100.d0 , 240.d0 , 70 , - 100.d0 , 100.d0 , 100 ,phimin =- !dpi / 6 ,phimax = !dpi / 6 ,nphi = 5 ) Contents Source Code rz_grid.pro Source Code FUNCTION rz_grid , rmin , rmax , nr , zmin , zmax , nz , phimin = phimin , phimax = phimax , nphi = nphi ; +#rz_grid ; + Creates interpolation grid ; +*** ; +## Arguments ; + **rmin**: Minimum radius [ cm ] ; + ; + **rmax**: Maximum radius [ cm ] ; + ; + **nr**: Number of radii ; + ; + **zmin**: Minimum Z value [ cm ] ; + ; + **zmax**: Maximum Z value [ cm ] ; + ; + **nz**: Number of z values ; + ; +## Return Value ; + Interpolation grid structure ; + ; +## Example Usage ; + ``` idl ; + IDL > grid = rz_grid ( 100. d0 , 240. d0 , 70 , - 100. d0 , 100. d0 , 100 , phimin=- ! dpi / 6 , phimax= ! dpi / 6 , nphi = 5 ) ; + ``` if not keyword_set ( phimin ) then phimin = 0.0 ; rad if not keyword_set ( phimax ) then phimax = 0.0 ; rad if not keyword_set ( nphi ) then nphi = 1 dr = double ( abs ( rmax - rmin )) / ( nr - 1 ) dz = double ( abs ( zmax - zmin )) / ( nz - 1 ) if nphi eq 1 then begin dphi = 0.0 endif else begin dphi = double ( abs ( phimax - phimin )) / ( nphi - 1 ) endelse r = rmin + dr * dindgen ( nr ) z = zmin + dz * dindgen ( nz ) phi = phimin + dphi * dindgen ( nphi ) r2d = r # replicate ( 1 , nz ) z2d = replicate ( 1 , nr ) # z grid = { r2d:r2d , z2d:z2d , r : r , z : z , phi : phi , nr : nr , nz : nz , nphi : nphi } return , grid END","tags":"","loc":"sourcefile/rz_grid.pro.html","title":"rz_grid.pro – FIDASIM"},{"text":"prefida Checks FIDASIM inputs and writes FIDASIM input files Input Arguments inputs : Inputs structure grid : Interpolation grid structure nbi : Neutral beam geometry structure plasma : Plasma parameters structure fields : Electromagnetic fields structure dist : Fast-ion distribution structure Keyword Arguments spec : Optional, Spectral geometry structure npa : Optional, NPA geometry structure Example Usage IDL > prefida, inputs, grid, nbi, plasma, fields, dist , spec = spec, npa = npa Contents Source Code prefida.pro Source Code PRO prefida , inputs , grid , nbi , plasma , fields , fbm , spec = spec , npa = npa ; +#prefida ; + Checks FIDASIM inputs and writes FIDASIM input files ; +*** ; +## Input Arguments ; + **inputs**: Inputs structure ; + ; + **grid**: Interpolation grid structure ; + ; + **nbi**: Neutral beam geometry structure ; + ; + **plasma**: Plasma parameters structure ; + ; + **fields**: Electromagnetic fields structure ; + ; + **dist**: Fast - ion distribution structure ; + ; +## Keyword Arguments ; + **spec**: Optional , Spectral geometry structure ; + ; + **npa**: Optional , NPA geometry structure ; + ; +## Example Usage ; + ``` idl ; + IDL > prefida , inputs , grid , nbi , plasma , fields , dist , spec = spec , npa = npa ; + ``` COMPILE_OPT DEFINT32 ;; CHECK INPUTS check_inputs , inputs ;; MAKE DIRECTORIES IF THEY DONT EXIST if file_test ( inputs . result_dir , / directory ) eq 0 then begin file_mkdir , inputs . result_dir endif ;; CHECK INTERPOLATION GRID check_grid , grid ;; CHECK BEAM INPUTS check_beam , inputs , nbi ;; CHECK PLASMA PARAMETERS check_plasma , inputs , grid , plasma ;; CHECK ELECTROMAGNETIC FIELDS check_fields , inputs , grid , fields ;; CHECK FAST - ION DISTRIBUTION check_distribution , inputs , grid , fbm ;; CHECK FIDA / BES if keyword_set ( spec ) then begin check_spec , inputs , spec endif ;; CHECK NPA if keyword_set ( npa ) then begin check_npa , inputs , npa endif ;; WRITE FIDASIM INPUT FILES write_namelist , inputs . input_file , inputs ;; WRITE GEOMETRY FILE write_geometry , inputs . geometry_file , nbi , spec = spec , npa = npa ;; WRITE EQUILIBRIUM FILE write_equilibrium , inputs . equilibrium_file , plasma , fields ;; WRITE DISTRIBUTION FILE write_distribution , inputs . distribution_file , fbm print , '' print , '' success , 'FIDASIM pre-processing completed' print , 'To run FIDASIM use the following command' print , get_fidasim_dir () +'/fidasim ' + inputs . result_dir+'/' + inputs . runid+'_inputs.dat' print , '' print , '' END","tags":"","loc":"sourcefile/prefida.pro.html","title":"prefida.pro – FIDASIM"},{"text":"beam_grid Calculates settings for a grid that aligns with the neutral beam. Arguments nbi : Neutral beam geometry structure rstart : Radial start position of beam grid [cm] Keyword Arguments dV : Cell volume [ cm&#94;3 ]: Defaults to 8.0 nx : Number of cells in length: Default determined by dV ny : Number of cells in width: Default determined by dV nz : Number of cells in height: Default determined by dV length : Length of grid along beam sightline. [cm]: Defaults to 100 cm width : Width of grid [cm]: Defaults to 50 cm height : Height of grid [cm]: Defaults to 50 cm Return Value Structure containing beam grid settings suitable for the Namelist File Example Usage IDL > grid = beam_grid(nbi, 200.0 ,nx = 100 ,ny = 50 ,nz = 50 ,length = 100 ,width = 50 ,height = 50 ) Contents Source Code beam_grid.pro Source Code FUNCTION beam_grid , nbi , rstart , $ nx = nx , ny = ny , nz = nz , dv = dv , $ length = length , width = width , height = height ; +#beam_grid ; + Calculates settings for a grid that aligns with the neutral beam . ; +*** ; +## Arguments ; + **nbi**: [ Neutral beam geometry structure ](| url | / page / 03 _ technical / 01 _ prefida_inputs . html#neutral - beam - geometry - structure ) ; + ; + **rstart**: Radial start position of beam grid [ cm ] ; + ; +## Keyword Arguments ; + **dV**: Cell volume [ \\ ( cm&#94; 3 \\ )] : Defaults to 8.0 ; + ; + **nx**: Number of cells in length : Default determined by ` dV ` ; + ; + **ny**: Number of cells in width : Default determined by ` dV ` ; + ; + **nz**: Number of cells in height : Default determined by ` dV ` ; + ; + **length**: Length of grid along beam sightline . [ cm ] : Defaults to 100 cm ; + ; + **width**: Width of grid [ cm ] : Defaults to 50 cm ; + ; + **height**: Height of grid [ cm ] : Defaults to 50 cm ; + ; +## Return Value ; + Structure containing beam grid settings suitable for the Namelist File ; + ; +## Example Usage ; + ``` idl ; + IDL > grid = beam_grid ( nbi , 200.0 , nx = 100 , ny = 50 , nz = 50 , length = 100 , width = 50 , height = 50 ) ; + ``` beam_grid = { err : 1 } if not keyword_set ( length ) then length = 100.0 ; cm if not keyword_set ( width ) then width = 80.0 ; cm if width lt nbi . widy then begin warning , \"Grid width is smaller then the source width\" print , \"width: \" , width print , \"source width: \" , nbi . widy endif if not keyword_set ( height ) then height = 80.0 ; cm if height lt nbi . widz then begin warning , \"Grid height is smaller then the source height\" print , \"height: \" , height print , \"source height: \" , nbi . widz endif if not keyword_set ( dv ) then dv = 8.0 ; cm&#94; 3 dv3 = dv&#94; ( 1.0 / 3.0 ) if not keyword_set ( nx ) then nx = round ( length / dv3 ) if not keyword_set ( ny ) then ny = round ( width / dv3 ) if not keyword_set ( nz ) then nz = round ( height / dv3 ) xmin = 0. d0 xmax = double ( length ) ymin = - width / 2. d0 ymax = width / 2. d0 zmin = - height / 2. d0 zmax = height / 2. d0 src = nbi . src axis = nbi . axis / sqrt ( total ( nbi . axis&#94; 2 )) pos = src + 100 * axis rsrc = sqrt ( src [ 0 ] &#94; 2 + src [ 1 ] &#94; 2 ) if sqrt ( src [ 0 ] &#94; 2 + src [ 1 ] &#94; 2 ) lt rstart then begin error , \"Source radius cannot be less then rstart\" goto , GET_OUT endif dis = sqrt ( total (( src - pos ) &#94; 2.0 )) beta = double ( asin (( src [ 2 ] - pos [ 2 ]) / dis )) alpha = double ( atan (( pos [ 1 ] - src [ 1 ]),( pos [ 0 ] - src [ 0 ]))) gamma = 0. d0 a = axis [ 0 ] &#94; 2 + axis [ 1 ] &#94; 2 b = 2 * ( src [ 0 ] * axis [ 0 ] + src [ 1 ] * axis [ 1 ]) c = src [ 0 ] &#94; 2 + src [ 1 ] &#94; 2 - rstart&#94; 2 t = ( - b - sqrt ( b&#94; 2 - 4 * a * c )) / ( 2 * a ) origin = src + t * axis beam_grid = { nx : fix ( nx ), ny : fix ( ny ), nz : fix ( nz ), $ xmin : xmin , xmax : xmax , $ ymin : ymin , ymax : ymax , $ zmin : zmin , zmax : zmax , $ alpha : alpha , beta : beta , gamma : gamma , $ origin : origin } GET_OUT : return , beam_grid END","tags":"","loc":"sourcefile/beam_grid.pro.html","title":"beam_grid.pro – FIDASIM"},{"text":"write_ncdf Writes variables in the local scope to a NetCDF file Arguments vars : Variables to write to file Keyword Arguments filename : Filename of NetCDF file merge_struct : Merge structures before writing clobber : Overwrite existing NetCDF file Example Usage IDL > a = 2 IDL > write_ncdf, \"a\" Contents Source Code write_ncdf.pro Source Code PRO write_ncdf , vars , filename = filename , merge_struct = merge_struct , clobber = clobber ; +#write_ncdf ; + Writes variables in the local scope to a NetCDF file ; +*** ; +## Arguments ; + **vars**: Variables to write to file ; + ; +## Keyword Arguments ; + **filename**: Filename of NetCDF file ; + ; + **merge_struct**: Merge structures before writing ; + ; + **clobber**: Overwrite existing NetCDF file ; + ; +## Example Usage ; + ``` idl ; + IDL > a = 2 ; + IDL > write_ncdf , \"a\" ; + ``` if not keyword_set ( filename ) then filename = 'idlsave.cdf' if file_test ( filename ) and not keyword_set ( clobber ) then begin print , 'File already exists. Use clobber keyword to overwrite' goto , GET_OUT endif if size ( vars , / tname ) ne 'STRING' then begin print , 'Invalid argument type. Expected STRING' goto , GET_OUT endif nVars = n_elements ( vars ) ncid = ncdf_create ( filename , / clobber ) varids = [] v = {} while n_elements ( vars ) ne 0 do begin ;; check to see if variable is set in local scope void = execute ( \"isSet = n_elements(\" + vars [ 0 ] + \")\" ) ;; if not set pull variable from above scope if isSet eq 0 then begin var = scope_varfetch ( vars [ 0 ], level=- 1 ) endif else begin void = execute ( \"var=\" + vars [ 0 ]) endelse varInfo = size ( var , / structure ) typeName = varInfo . type_name CASE typeName OF 'STRUCT': begin tagNames = strlowcase ( tag_names ( var )) if keyword_set ( merge_struct ) then begin varNames = tagNames endif else begin varNames = vars [ 0 ] +'_' + tagNames endelse for i = 0 , n_elements ( tagNames ) - 1 do begin void = execute ( varNames [ i ] + \"= var.\" + tagNames [ i ]) endfor if n_elements ( vars ) gt 1 then vars = vars [ 1 :- 1 ] else vars = [] vars = [ varNames , vars ] goto , SKIP end 'STRING': begin str_id = ncdf_dimdef ( ncid , vars [ 0 ] +'_dim' , n_elements ( var )) strmax_id = ncdf_dimdef ( ncid , vars [ 0 ] +'_strlen_dim' , max ( strlen ( var ))) dimids = [ strmax_id , str_id ] void = execute ( \"varids = [varids,ncdf_vardef(ncid,'\" + vars [ 0 ] + \"',dimids,/byte)]\" ) var = byte ( var ) end ELSE : begin if varInfo . n_dimensions gt 0 then begin dimids = [] for i = 0 , varInfo . n_dimensions - 1 do begin tmp = ncdf_dimdef ( ncid , vars [ 0 ] +'_dim' + strcompress ( string ( i + 1 ), / remove_all ), varInfo . dimensions [ i ]) dimids = [ dimids , tmp ] endfor endif else begin dimids = ncdf_dimdef ( ncid , vars [ 0 ] +'_dim' , 1 ) endelse if typeName eq \"INT\" then typeName = \"LONG\" void = execute ( \"varids = [varids,ncdf_vardef(ncid,'\" + vars [ 0 ] + \"',dimids,/\" + typeName + \")]\" ) end ENDCASE v = create_struct ( v , vars [ 0 ], var ) if n_elements ( vars ) gt 1 then vars = vars [ 1 :- 1 ] else vars = [] SKIP : endwhile ncdf_control , ncid , / ENDEF for i = 1 , N_TAGS ( v ) - 1 do begin ncdf_varput , ncid , varids [ i - 1 ], v .( i ) endfor ncdf_close , ncid GET_OUT : END","tags":"","loc":"sourcefile/write_ncdf.pro.html","title":"write_ncdf.pro – FIDASIM"},{"text":"info Print a informational message Arguments str : message Example Usage IDL > info, \"This is an informative message\" Contents Source Code info.pro Source Code PRO info , str ; +#info ; + Print a informational message ; +*** ; +## Arguments ; + **str**: message ; + ; +## Example Usage ; + ``` idl ; + IDL > info , \"This is an informative message\" ; + ``` print , colored ( 'INFO: ' + str , c='b' ) END","tags":"","loc":"sourcefile/info.pro.html","title":"info.pro – FIDASIM"},{"text":"write_namelist, filename, inputs Writes namelist file Input Arguments filename : Name of the namelist file inputs : Input structure Example Usage IDL > write_namelist, filename, inputs Contents Source Code write_namelist.pro Source Code PRO write_namelist , filename , inputs ; +## ` write_namelist , filename , inputs ` ; + Writes namelist file ; + ; +### Input Arguments ; + **filename**: Name of the namelist file ; + ; + **inputs**: Input structure ; + ; +### Example Usage ; + ``` idl ; + IDL > write_namelist , filename , inputs ; + ``` info , 'Writing namelist file...' fidasim_version = get_version ( get_fidasim_dir ()) openw , 55 , filename printf , 55 , '!! Created: ' , systime () printf , 55 , '!! FIDASIM version: ' + fidasim_version printf , 55 , '!! Comment: ' + inputs . comment printf , 55 , '&fidasim_inputs' printf , 55 , '' printf , 55 , '!! Shot Info' printf , 55 , f='(\"shot = \", i6 ,\"    !! Shot Number\")' , inputs . shot printf , 55 , f='(\"time = \", 1f8.5 ,\"    !! Time [s]\")' , inputs . time printf , 55 , \"runid = '\" + inputs . runid + \"'    !! runID\" printf , 55 , \"result_dir = '\" + inputs . result_dir+ \"'    !! Result Directory\" printf , 55 , '' printf , 55 , '!! Input Files' printf , 55 , \"tables_file = '\" + inputs . tables_file+ \"'    !! Atomic Tables File\" printf , 55 , \"equilibrium_file = '\" + inputs . equilibrium_file + \"'    !! File containing plasma parameters and fields\" printf , 55 , \"geometry_file = '\" + inputs . geometry_file + \"'    !! File containing NBI and diagnostic geometry\" printf , 55 , \"distribution_file = '\" + inputs . distribution_file + \"'    !! File containing fast-ion distribution\" printf , 55 , '' printf , 55 , '!! Simulation Switches' printf , 55 , f='(\"calc_bes = \",i2 , \"    !! Calculate NBI Spectra\")' , inputs . calc_bes printf , 55 , f='(\"calc_dcx = \",i2 , \"    !! Calculate Direct CX Spectra\")' , inputs . calc_dcx printf , 55 , f='(\"calc_halo = \",i2 , \"    !! Calculate Halo Spectra\")' , inputs . calc_halo printf , 55 , f='(\"calc_cold = \",i2 , \"    !! Calculate Cold D-alpha Spectra\")' , inputs . calc_cold printf , 55 , f='(\"calc_brems = \",i2 , \"    !! Calculate Bremsstrahlung\")' , inputs . calc_brems printf , 55 , f='(\"calc_fida = \",i2 , \"    !! Calculate Active FIDA Spectra\")' , inputs . calc_fida printf , 55 , f='(\"calc_npa = \",i2 , \"   !! Calculate Active NPA\")' , inputs . calc_npa printf , 55 , f='(\"calc_pfida = \",i2 , \"    !! Calculate Passive FIDA Spectra\")' , inputs . calc_pfida printf , 55 , f='(\"calc_pnpa = \",i2 , \"   !! Calculate Passive NPA\")' , inputs . calc_pnpa printf , 55 , f='(\"calc_neutron = \",i2 , \"   !! Calculate B-T Neutron Rate\")' , inputs . calc_neutron printf , 55 , f='(\"calc_birth = \",i2 , \"    !! Calculate Birth Profile\")' , inputs . calc_birth printf , 55 , f='(\"calc_fida_wght = \",i2 , \"    !! Calculate FIDA weights\")' , inputs . calc_fida_wght printf , 55 , f='(\"calc_npa_wght = \",i2 , \"    !! Calculate NPA weights\")' , inputs . calc_npa_wght printf , 55 , '' printf , 55 , '!! Debugging Switches' printf , 55 , f='(\"seed = \",i9,  \"    !! RNG Seed. If seed is negative a random seed is used\")' , inputs . seed printf , 55 , f='(\"flr = \",i2,\"    !! Turn on Finite Larmor Radius effects\")' , inputs . flr printf , 55 , f='(\"load_neutrals = \",i2,\"    !! Load neutrals from neutrals file\")' , inputs . load_neutrals printf , 55 , \"neutrals_file = '\" + inputs . neutrals_file + \"'    !! File containing the neutral density\" printf , 55 , f='(\"verbose = \",i2,\"    !! Verbose\")' , inputs . verbose printf , 55 , '' printf , 55 , '!! Monte Carlo Settings' printf , 55 , f='(\"n_fida = \",i9,\"    !! Number of Active FIDA mc particles\")' , inputs . n_fida printf , 55 , f='(\"n_pfida = \",i9,\"    !! Number of Passive FIDA mc particles\")' , inputs . n_pfida printf , 55 , f='(\"n_npa = \",i9,\"    !! Number of Active NPA mc particles\")' , inputs . n_npa printf , 55 , f='(\"n_pnpa = \",i9,\"    !! Number of Passive NPA mc particles\")' , inputs . n_pnpa printf , 55 , f='(\"n_nbi = \",i9,\"    !! Number of NBI mc particles\")' , inputs . n_nbi printf , 55 , f='(\"n_halo = \",i9,\"    !! Number of HALO mc particles\")' , inputs . n_halo printf , 55 , f='(\"n_dcx = \",i9,\"     !! Number of DCX mc particles\")' , inputs . n_dcx printf , 55 , f='(\"n_birth = \",i9,\"    !! Number of BIRTH mc particles\")' , inputs . n_birth printf , 55 , '' printf , 55 , '!! Neutral Beam Settings' printf , 55 , f='(\"ab = \",1f9.5,\"     !! Beam Species mass [amu]\")' , inputs . ab printf , 55 , f='(\"pinj = \",1f9.3,\"     !! Beam Power [MW]\")' , inputs . pinj printf , 55 , f='(\"einj = \",1f9.3,\"     !! Beam Energy [keV]\")' , inputs . einj printf , 55 , f='(\"current_fractions(1) = \",1f9.5,\" !! Current Fractions (Full component)\")' , inputs . current_fractions [ 0 ] printf , 55 , f='(\"current_fractions(2) = \",1f9.5,\" !! Current Fractions (Half component)\")' , inputs . current_fractions [ 1 ] printf , 55 , f='(\"current_fractions(3) = \",1f9.5,\" !! Current Fractions (Third component)\")' , inputs . current_fractions [ 2 ] printf , 55 , '' printf , 55 , '!! Plasma Settings' printf , 55 , f='(\"ai = \",1f9.5,\"     !! Ion Species mass [amu]\")' , inputs . ai printf , 55 , f='(\"impurity_charge = \",i3,\"     !! Impurity Charge\")' , inputs . impurity_charge printf , 55 , '' printf , 55 , '!! Beam Grid Settings' printf , 55 , f='(\"nx = \",i4,\"    !! Number of cells in X direction (Into Plasma)\")' , inputs . nx printf , 55 , f='(\"ny = \",i4,\"    !! Number of cells in Y direction\")' , inputs . ny printf , 55 , f='(\"nz = \",i4,\"    !! Number of cells in Z direction\")' , inputs . nz printf , 55 , f='(\"xmin = \",1f9.3,\"     !! Minimum X value [cm]\")' , inputs . xmin printf , 55 , f='(\"xmax = \",1f9.3,\"     !! Maximum X value [cm]\")' , inputs . xmax printf , 55 , f='(\"ymin = \",1f9.3,\"     !! Minimum Y value [cm]\")' , inputs . ymin printf , 55 , f='(\"ymax = \",1f9.3,\"     !! Maximum Y value [cm]\")' , inputs . ymax printf , 55 , f='(\"zmin = \",1f9.3,\"     !! Minimum Z value [cm]\")' , inputs . zmin printf , 55 , f='(\"zmax = \",1f9.3,\"     !! Maximum Z value [cm]\")' , inputs . zmax printf , 55 , '!! Tait-Bryan Angles for z-y`-x`` rotation' printf , 55 , f='(\"alpha = \",1f9.5,\"     !! Rotation about z-axis [rad]\")' , inputs . alpha printf , 55 , f='(\"beta  = \",1f9.5,\"     !! Rotation about y`-axis [rad]\")' , inputs . beta printf , 55 , f='(\"gamma = \",1f9.5,\"     !! Rotation about x``-axis [rad]\")' , inputs . gamma printf , 55 , '!! Beam Grid origin in machine coordinates (cartesian)' printf , 55 , f='(\"origin(1) = \",1f9.3,\"     !! U value [cm]\")' , inputs . origin [ 0 ] printf , 55 , f='(\"origin(2) = \",1f9.3,\"     !! V value [cm]\")' , inputs . origin [ 1 ] printf , 55 , f='(\"origin(3) = \",1f9.3,\"     !! W value [cm]\")' , inputs . origin [ 2 ] printf , 55 , '' printf , 55 , '!! Wavelength Grid Settings' printf , 55 , f='(\"nlambda = \",1i5,\"    !! Number of Wavelengths\")' , inputs . nlambda printf , 55 , f='(\"lambdamin = \",1f9.3,\"    !! Minimum Wavelength [nm]\")' , inputs . lambdamin printf , 55 , f='(\"lambdamax = \",1f9.3,\"    !! Maximum Wavelength [nm]\")' , inputs . lambdamax printf , 55 , '' printf , 55 , '!! Weight Function Settings' printf , 55 , f='(\"ne_wght = \",i9,\"    !! Number of Energies for Weights\")' , inputs . ne_wght printf , 55 , f='(\"np_wght = \",i9,\"    !! Number of Pitches for Weights\")' , inputs . np_wght printf , 55 , f='(\"nphi_wght = \",i9,\"    !! Number of Gyro-angles for Weights\")' , inputs . nphi_wght printf , 55 , f='(\"emax_wght = \",1f9.2,\"    !! Maximum Energy for Weights [keV]\")' , inputs . emax_wght printf , 55 , f='(\"nlambda_wght = \",1i5,\"    !! Number of Wavelengths for Weights \")' , $ inputs . nlambda_wght printf , 55 , f='(\"lambdamin_wght = \",1f9.3,\"    !! Minimum Wavelength for Weights [nm]\")' , $ inputs . lambdamin_wght printf , 55 , f='(\"lambdamax_wght = \",1f9.3,\"    !! Maximum Wavelength for Weights [nm]\")' , $ inputs . lambdamax_wght printf , 55 , '' printf , 55 , '/' printf , 55 , '' close , 55 success , 'Namelist file created: ' + filename END","tags":"","loc":"sourcefile/write_namelist.pro.html","title":"write_namelist.pro – FIDASIM"},{"text":"write_distribution, filename, dist Write fast-ion distribution to a HDF5 file Input Arguments filename : Name of the distribution file dist : Fast-ion distribution structure Example Usage IDL > write_distribution, filename, distri Contents Source Code write_distribution.pro Source Code PRO write_distribution , filename , distri ; +## ` write_distribution , filename , dist ` ; + Write fast - ion distribution to a HDF5 file ; + ; +### Input Arguments ; + **filename**: Name of the distribution file ; + ; + **dist**: Fast - ion distribution structure ; + ; +### Example Usage ; + ``` idl ; + IDL > write_distribution , filename , distri ; + ``` info , 'Writing fast-ion distribution file...' root_atts = { attribute , obj : '/' , $ name : 'description' , $ data : 'Fast-ion distribution for FIDASIM' } cs_desc = { attribute , obj : '/' , $ name : 'coordinate_system' , $ data : 'Cylindrical' } ds_desc = { attribute , obj : '/data_source' , $ name : 'description' , $ data : 'Source of the fast-ion distribution' } type_desc = { attribute , obj : '/type' , $ name : 'description' , $ data : 'Distribution type: ' + $ '1=\"Guiding Center Density Function\", ' + $ '2=\"Guiding Center Monte Carlo\", ' + $ '3=\"Full Orbit Monte Carlo\"' } time_desc = { attribute , obj : '/time' , $ name : 'description' , $ data : 'Distribution time' } time_unit = { attribute , obj : '/time' , $ name : 'units' , $ data : 's' } type = distri . type if type eq 1 then begin nen_desc = { attribute , obj : '/nenergy' , $ name : 'description' , $ data : 'Number of energy values' } np_desc = { attribute , obj : '/npitch' , $ name : 'description' , $ data : 'Number of pitch values' } energy_desc = { attribute , obj : '/energy' , $ name : 'description' , $ data : 'Energy' } energy_unit = { attribute , obj : '/energy' , $ name : 'units' , $ data : 'keV' } pitch_desc = { attribute , obj : '/pitch' , $ name : 'description' , $ data : 'Pitch: p = v_parallel/v  w.r.t. the magnetic field' } f_desc = { attribute , obj : '/f' , $ name : 'description' , $ data : 'Fast-ion density function: F(E,p,R,Z[,Phi])' } f_unit = { attribute , obj : '/f' , $ name : 'units' , $ data : 'fast-ions/(dE*dP*cm&#94;3)' } denf_desc = { attribute , obj : '/denf' , $ name : 'description' , $ data : 'Fast-ion density: Denf(r,z[,phi])' } denf_unit = { attribute , obj : '/denf' , $ name : 'units' , $ data : 'cm&#94;-3' } nr_desc = { attribute , obj : '/nr' , $ name : 'description' , $ data : 'Number of R values' } nz_desc = { attribute , obj : '/nz' , $ name : 'description' , $ data : 'Number of Z values' } nphi_desc = { attribute , obj : '/nphi' , $ name : 'description' , $ data : 'Number of Phi values' } r_desc = { attribute , obj : '/r' , $ name : 'description' , $ data : 'Radius' } r_unit = { attribute , obj : '/r' , $ name : 'units' , $ data : 'cm' } z_desc = { attribute , obj : '/z' , $ name : 'description' , $ data : 'Z' } z_unit = { attribute , obj : '/z' , $ name : 'units' , $ data : 'cm' } phi_desc = { attribute , obj : '/phi' , $ name : 'description' , $ data : 'Phi' } phi_unit = { attribute , obj : '/phi' , $ name : 'units' , $ data : 'rad' } r2d_desc = { attribute , obj : '/r2d' , $ name : 'description' , $ data : 'Radius grid: R(r,z)' } r2d_unit = { attribute , obj : '/r2d' , $ name : 'units' , $ data : 'cm' } z2d_desc = { attribute , obj : '/z2d' , $ name : 'description' , $ data : 'Z grid: Z(r,z)' } z2d_unit = { attribute , obj : '/z2d' , $ name : 'units' , $ data : 'cm' } atts = [ root_atts , cs_desc , ds_desc , $ type_desc , time_desc , time_unit , $ nen_desc , np_desc , $ energy_desc , energy_unit , $ pitch_desc , $ f_desc , f_unit , $ denf_desc , denf_unit , $ nr_desc , nz_desc , $ nphi_desc , $ r_desc , r_unit , $ z_desc , z_unit , $ phi_desc , phi_unit , $ r2d_desc , r2d_unit , $ z2d_desc , z2d_unit ] endif else begin np_desc = { attribute , obj : '/nparticle' , $ name : 'description' , $ data : 'Number of MC particles' } nc_desc = { attribute , obj : '/nclass' , $ name : 'description' , $ data : 'Number of orbit classes' } r_desc = { attribute , obj : '/r' , $ name : 'description' , $ data : 'R position of a MC particle' } r_unit = { attribute , obj : '/r' , $ name : 'units' , $ data : 'cm' } z_desc = { attribute , obj : '/z' , $ name : 'description' , $ data : 'Z position of a MC particle' } z_unit = { attribute , obj : '/z' , $ name : 'units' , $ data : 'cm' } phi_desc = { attribute , obj : '/phi' , $ name : 'description' , $ data : 'Phi position of a MC particle' } phi_unit = { attribute , obj : '/phi' , $ name : 'units' , $ data : 'rad' } w_desc = { attribute , obj : '/weight' , $ name : 'description' , $ data : 'Weight of a MC particle: sum(weight) = # of fast-ions ' } w_unit = { attribute , obj : '/weight' , $ name : 'units' , $ data : 'fast-ions/particle' } c_desc = { attribute , obj : '/class' , $ name : 'description' , $ data : 'Orbit class of a MC particle: class in Set(1:nclass)' } if type eq 2 then begin energy_desc = { attribute , obj : '/energy' , $ name : 'description' , $ data : 'Energy of a MC particle' } energy_unit = { attribute , obj : '/energy' , $ name : 'units' , $ data : 'keV' } pitch_desc = { attribute , obj : '/pitch' , $ name : 'description' , $ data : 'Pitch of a MC particle: p = v_parallel/v  w.r.t. the magnetic field' } type_atts = [ energy_desc , energy_unit , pitch_desc ] endif else begin vr_desc = { attribute , obj : '/vr' , $ name : 'description' , $ data : 'Radial velocity of a MC particle' } vr_unit = { attribute , obj : '/vr' , $ name : 'units' , $ data : 'cm/s' } vt_desc = { attribute , obj : '/vt' , $ name : 'description' , $ data : 'Torodial velocity of a MC particle' } vt_unit = { attribute , obj : '/vt' , $ name : 'units' , $ data : 'cm/s' } vz_desc = { attribute , obj : '/vz' , $ name : 'description' , $ data : 'Z velocity of a MC particle' } vz_unit = { attribute , obj : '/vz' , $ name : 'units' , $ data : 'cm/s' } type_atts = [ vr_desc , vr_unit , vt_desc , vt_unit , vz_desc , vz_unit ] endelse atts = [ root_atts , cs_desc , ds_desc , $ type_desc , time_desc , time_unit , $ np_desc , nc_desc , $ r_desc , r_unit , $ z_desc , z_unit , $ w_desc , w_unit , $ c_desc , type_atts ] w = where ( 'phi' eq strlowcase ( tag_names ( distri )), nw ) if nw ne 0 then begin atts = [ atts , phi_desc , phi_unit ] endif endelse write_hdf5 , distri , filename = filename , atts = atts , / clobber , compress = 4 if file_test ( filename ) then begin success , 'Distribution file created: ' + filename endif else begin error , 'Distribution file creation failed.' endelse END","tags":"","loc":"sourcefile/write_distribution.pro.html","title":"write_distribution.pro – FIDASIM"},{"text":"write_geometry Write geometry values to a HDF5 file Input Arguments filename : Name of the geometry file nbi : NBI geometry structure Keyword Arguments spec : Optional, Spectral geometry structure npa : Optional, NPA geometry structure Example Usage IDL > write_geometry, filename, nbi, spec = spec, npa = npa Contents Source Code write_geometry.pro Source Code PRO write_geometry , filename , nbi , spec = spec , npa = npa ; +#write_geometry ; + Write geometry values to a HDF5 file ; +*** ; +## Input Arguments ; + **filename**: Name of the geometry file ; + ; + **nbi**: NBI geometry structure ; + ; +## Keyword Arguments ; + **spec**: Optional , Spectral geometry structure ; + ; + **npa**: Optional , NPA geometry structure ; + ; +## Example Usage ; + ``` idl ; + IDL > write_geometry , filename , nbi , spec = spec , npa = npa ; + ``` info , 'Writing geometry file...' ;; Create attributes root_atts = { attribute , obj : '/' , $ name : 'description' , $ data : 'Geometric quantities for FIDASIM' } ;; NBI attributes nbi_desc = { attribute , obj : '/nbi' , $ name : 'description' , $ data : 'Neutral Beam Geometry' } nbi_cs = { attribute , obj : '/nbi' , $ name : 'coordinate_system' , $ data : 'Right-handed cartesian' } nbi_ds_desc = { attribute , obj : '/nbi/data_source' , $ name : 'description' , $ data : 'Source of the NBI geometry' } nbi_name_desc = { attribute , obj : '/nbi/name' , $ name : 'description' , $ data : 'Beam name' } nbi_src_desc = { attribute , obj : '/nbi/src' , $ name : 'description' , $ data : 'Position of the center of the beam source grid' } nbi_src_unit = { attribute , obj : '/nbi/src' , $ name : 'units' , $ data : 'cm' } nbi_axis_desc = { attribute , obj : '/nbi/axis' , $ name : 'description' , $ data : 'Axis of the beam centerline: Centerline(t) = src + axis*t ' } nbi_axis_unit = { attribute , obj : '/nbi/axis' , $ name : 'units' , $ data : 'cm' } nbi_focy_desc = { attribute , obj : '/nbi/focy' , $ name : 'description' , $ data : 'Horizonal focal length of the beam' } nbi_focy_unit = { attribute , obj : '/nbi/focy' , $ name : 'units' , $ data : 'cm' } nbi_focz_desc = { attribute , obj : '/nbi/focz' , $ name : 'description' , $ data : 'Vertical focal length of the beam' } nbi_focz_unit = { attribute , obj : '/nbi/focz' , $ name : 'units' , $ data : 'cm' } nbi_divy_desc = { attribute , obj : '/nbi/divy' , $ name : 'description' , $ data : 'Horizonal divergences of the beam. One for each energy component' } nbi_divy_unit = { attribute , obj : '/nbi/divy' , $ name : 'units' , $ data : 'radians' } nbi_divz_desc = { attribute , obj : '/nbi/divz' , $ name : 'description' , $ data : 'Vertical divergences of the beam. One for each energy component' } nbi_divz_unit = { attribute , obj : '/nbi/divz' , $ name : 'units' , $ data : 'radians' } nbi_widy_desc = { attribute , obj : '/nbi/widy' , $ name : 'description' , $ data : 'Half width of the beam source grid' } nbi_widy_unit = { attribute , obj : '/nbi/widy' , $ name : 'units' , $ data : 'cm' } nbi_widz_desc = { attribute , obj : '/nbi/widz' , $ name : 'description' , $ data : 'Half height of the beam source grid' } nbi_widz_unit = { attribute , obj : '/nbi/widz' , $ name : 'units' , $ data : 'cm' } nbi_shape_desc = { attribute , obj : '/nbi/shape' , $ name : 'description' , $ data : 'Shape of the beam source grid: 1=\"rectangular\", 2=\"circular\"' } nbi_naperture_desc = { attribute , obj : '/nbi/naperture' , $ name : 'description' , $ data : 'Number of apertures' } nbi_ashape_desc = { attribute , obj : '/nbi/ashape' , $ name : 'description' , $ data : 'Shape of the aperture(s): 1=\"rectangular\", 2=\"circular\"' } nbi_awidy_desc = { attribute , obj : '/nbi/awidy' , $ name : 'description' , $ data : 'Half width of the aperture(s)' } nbi_awidy_unit = { attribute , obj : '/nbi/awidy' , $ name : 'units' , $ data : 'cm' } nbi_awidz_desc = { attribute , obj : '/nbi/awidz' , $ name : 'description' , $ data : 'Half height of the aperture(s)' } nbi_awidz_unit = { attribute , obj : '/nbi/awidz' , $ name : 'units' , $ data : 'cm' } nbi_aoffy_desc = { attribute , obj : '/nbi/aoffy' , $ name : 'description' , $ data : 'Horizontal (y) offset of the aperture(s) relative to the +x aligned beam centerline' } nbi_aoffy_unit = { attribute , obj : '/nbi/aoffy' , $ name : 'units' , $ data : 'cm' } nbi_aoffz_desc = { attribute , obj : '/nbi/aoffz' , $ name : 'description' , $ data : 'Vertical (z) offset of the aperture(s) relative to the +x aligned beam centerline' } nbi_aoffz_unit = { attribute , obj : '/nbi/aoffz' , $ name : 'units' , $ data : 'cm' } nbi_adist_desc = { attribute , obj : '/nbi/adist' , $ name : 'description' , $ data : 'Distance from the center of the beam source grid to the aperture(s) plane' } nbi_adist_unit = { attribute , obj : '/nbi/adist' , $ name : 'units' , $ data : 'cm' } nbi_atts = [ nbi_desc , nbi_cs , nbi_ds_desc , nbi_name_desc , $ nbi_shape_desc , nbi_src_desc , nbi_src_unit , $ nbi_axis_desc , nbi_axis_unit , $ nbi_focy_desc , nbi_focy_unit , $ nbi_focz_desc , nbi_focz_unit , $ nbi_divy_desc , nbi_divy_unit , $ nbi_divz_desc , nbi_divz_unit , $ nbi_widy_desc , nbi_widy_unit , $ nbi_widz_desc , nbi_widz_unit , $ nbi_naperture_desc , nbi_ashape_desc , $ nbi_awidy_desc , nbi_awidy_unit , $ nbi_awidz_desc , nbi_awidz_unit , $ nbi_aoffy_desc , nbi_aoffy_unit , $ nbi_aoffz_desc , nbi_aoffz_unit , $ nbi_adist_desc , nbi_adist_unit ] ;; Spectroscopic attributes spec_desc = { attribute , obj : '/spec' , $ name : 'description' , $ data : 'FIDA/BES Chord Geometry' } spec_cs = { attribute , obj : '/spec' , $ name : 'coordinate_system' , $ data : 'Right-handed cartesian' } spec_ds_desc = { attribute , obj : '/spec/data_source' , $ name : 'description' , $ data : 'Source of the chord geometry' } spec_nchan_desc = { attribute , obj : '/spec/nchan' , $ name : 'description' , $ data : 'Number of channels' } spec_system_desc = { attribute , obj : '/spec/system' , $ name : 'description' , $ data : 'Names of the different spectrocopic systems' } spec_id_desc = { attribute , obj : '/spec/id' , $ name : 'description' , $ data : 'Line of sight ID' } spec_lens_desc = { attribute , obj : '/spec/lens' , $ name : 'description' , $ data : 'Positions of the lenses' } spec_lens_unit = { attribute , obj : '/spec/lens' , $ name : 'units' , $ data : 'cm' } spec_axis_desc = { attribute , obj : '/spec/axis' , $ name : 'description' , $ data : 'Optical axis of the lines of sight: LOS(t) = lens + axis*t ' } spec_axis_unit = { attribute , obj : '/spec/axis' , $ name : 'units' , $ data : 'cm' } spec_radius_desc = { attribute , obj : '/spec/radius' , $ name : 'description' , $ data : 'Line of sight radius at midplane or tangency point' } spec_radius_unit = { attribute , obj : '/spec/radius' , $ name : 'units' , $ data : 'cm' } spec_sigma_desc = { attribute , obj : '/spec/sigma_pi' , $ name : 'description' , $ data : 'Ratio of the intensities of the sigma and pi stark lines. Measured quantity' } spec_spot_desc = { attribute , obj : '/spec/spot_size' , $ name : 'description' , $ data : 'Radius of spot size' } spec_spot_unit = { attribute , obj : '/spec/spot_size' , $ name : 'units' , $ data : 'cm' } spec_atts = [ spec_desc , spec_cs , spec_ds_desc , $ spec_nchan_desc , spec_system_desc , $ spec_id_desc , $ spec_lens_desc , spec_lens_unit , $ spec_axis_desc , spec_axis_unit , $ spec_radius_desc , spec_radius_unit , $ spec_sigma_desc , $ spec_spot_desc , spec_spot_unit ] ;; NPA attributes npa_desc = { attribute , obj : '/npa' , $ name : 'description' , $ data : 'NPA Geometry' } npa_cs = { attribute , obj : '/npa' , $ name : 'coordinate_system' , $ data : 'Right-handed cartesian' } npa_ds_desc = { attribute , obj : '/npa/data_source' , $ name : 'description' , $ data : 'Source of the NPA geometry' } npa_nchan_desc = { attribute , obj : '/npa/nchan' , $ name : 'description' , $ data : 'Number of channels' } npa_system_desc = { attribute , obj : '/npa/system' , $ name : 'description' , $ data : 'Names of the different NPA systems' } npa_id_desc = { attribute , obj : '/npa/id' , $ name : 'description' , $ data : 'Line of sight ID' } npa_dshape_desc = { attribute , obj : '/npa/d_shape' , $ name : 'description' , $ data : 'Shape of the detector: 1=\"rectangular\", 2=\"circular\"' } npa_dcent_desc = { attribute , obj : '/npa/d_cent' , $ name : 'description' , $ data : 'Center of the detector' } npa_dcent_unit = { attribute , obj : '/npa/d_cent' , $ name : 'units' , $ data : 'cm' } npa_dtedge_desc = { attribute , obj : '/npa/d_tedge' , $ name : 'description' , $ data : 'Center of the detectors top edge' } npa_dtedge_unit = { attribute , obj : '/npa/d_tedge' , $ name : 'units' , $ data : 'cm' } npa_dredge_desc = { attribute , obj : '/npa/d_redge' , $ name : 'description' , $ data : 'Center of the detectors right edge' } npa_dredge_unit = { attribute , obj : '/npa/d_redge' , $ name : 'units' , $ data : 'cm' } npa_ashape_desc = { attribute , obj : '/npa/a_shape' , $ name : 'description' , $ data : 'Shape of the aperture: 1=\"rectangular\", 2=\"circular\"' } npa_acent_desc = { attribute , obj : '/npa/a_cent' , $ name : 'description' , $ data : 'Center of the aperture' } npa_acent_unit = { attribute , obj : '/npa/a_cent' , $ name : 'units' , $ data : 'cm' } npa_atedge_desc = { attribute , obj : '/npa/a_tedge' , $ name : 'description' , $ data : 'Center of the apertures top edge' } npa_atedge_unit = { attribute , obj : '/npa/a_tedge' , $ name : 'units' , $ data : 'cm' } npa_aredge_desc = { attribute , obj : '/npa/a_redge' , $ name : 'description' , $ data : 'Center of the apertures right edge' } npa_aredge_unit = { attribute , obj : '/npa/a_redge' , $ name : 'units' , $ data : 'cm' } npa_radius_desc = { attribute , obj : '/npa/radius' , $ name : 'description' , $ data : 'Line of sight radius at midplane or tangency point' } npa_radius_unit = { attribute , obj : '/npa/radius' , $ name : 'units' , $ data : 'cm' } npa_atts = [ npa_desc , npa_cs , npa_ds_desc , $ npa_nchan_desc , npa_system_desc , $ npa_id_desc , $ npa_dshape_desc , npa_ashape_desc , $ npa_dcent_desc , npa_dcent_unit , $ npa_acent_desc , npa_acent_unit , $ npa_dtedge_desc , npa_dtedge_unit , $ npa_atedge_desc , npa_atedge_unit , $ npa_dredge_desc , npa_dredge_unit , $ npa_aredge_desc , npa_aredge_unit , $ npa_radius_desc , npa_radius_unit ] atts = [ root_atts , nbi_atts ] geom = { nbi : nbi } if keyword_set ( spec ) then begin geom = create_struct ( geom , \"spec\" , spec ) atts = [ atts , spec_atts ] endif if keyword_set ( npa ) then begin geom = create_struct ( geom , \"npa\" , npa ) atts = [ atts , npa_atts ] endif write_hdf5 , geom , filename = filename , atts = atts , / clobber if file_test ( filename ) then begin success , 'Geometry file created: ' + filename endif else begin error , 'Geometry file creation failed.' endelse END","tags":"","loc":"sourcefile/write_geometry.pro.html","title":"write_geometry.pro – FIDASIM"},{"text":"Contents Source Code __init__.py Source Code from fidasim.preprocessing import prefida","tags":"","loc":"sourcefile/__init__.py.html","title":"__init__.py – FIDASIM"},{"text":"PREFIDA Source This file contains the source code for PREFIDA check_dict_schema Check dict dec is formatted according to schema Input Arguments schema : dict schema dic : dict to check Output Arguments err : error code Keyword Arguments desc : description of dict dic Example usage >>> dic = { 'a' : 0 , 'b' :[ 1. d0 , 2. d0 ], 'c' : \"example\" } >>> schema = { 'a' :{ 'dims' : 0 , 'type' :[ int ]}, 'b' :{ 'dims' :[ 2 ], 'type' :[ float , np . float64 ]}, 'c' :{ 'dims' : 0 , 'type' :[ str ]} } >>> err = check_dict_schema ( schema , dic , desc = \"Example dict\" ) >>> print ( err ) False check_inputs Checks if input dictionary is valid Input Arguments inputs : input dictionary Output Arguments inputs : Updated inputs dictionary Example Usage >>> inputs = check_inputs(inputs) check_grid Checks if interpolation grid structure is valid Input Arguments grid : Interpolation grid structure Example Usage >>> check_grid ( grid ) check_beam Checks if neutral beam geometry dictionary is valid. Converts lists to numpy ndarrays Input Arguments inputs : input dictionary nbi : neutral beam geometry dictionary Output Arguments nbi : Updated nbi dictionary Example Usage >>> nbi = check_beam ( inputs , nbi ) check_plasma Checks if plasma paramters dictionary is valid Input Arguments inputs : Input dictionary grid : Interpolation grid dictionary plasma : Plasma parameters dictionary Output Arguments plasma : Updated plasma dictionary Example Usage >>> plasma = check_plasma ( inputs , grid , plasma ) check_fields Checks if electromagnetic fields dictionary is valid Input Arguments inputs : Input dictionary grid : Interpolation grid dictionary fields : Electromagnetic fields dictionary Output Arguments fields : Updated fields dictionary Example Usage >>> fields = check_fields ( inputs , grid , fields ) check_distribution Checks if distribution dictionary is valid Input Arguments inputs : Input dictionary grid : Interpolation grid dictionary dist : Fast-ion distribution dictionary Output Arguments dist : Updated dist dictionary Example Usage >>> dist = check_distribution ( inputs , grid , dist ) check_spec Check if spectral geometry dictionary is valid Input Arguments inputs : input dictionary chords : spectral geometry dictionary Example Usage >>> check_spec ( inputs , chords ) check_npa Checks if NPA geometry dictionary is valid Input Arguments inputs : input dictionary npa : NPA geometry dictionary Example Usage >>> check_npa ( inputs , npa ) write_namelist Writes namelist file Input Arguments filename : Name of the namelist file inputs : Input dictionary Example Usage >>> write_namelist ( filename , inputs ) write_geometry Write geometry values to a HDF5 file Input Arguments filename : Name of the geometry file nbi : NBI geometry structure Keyword Arguments spec : Optional, Spectral geometry structure npa : Optional, NPA geometry structure Example Usage >>> write_geometry ( filename , nbi , spec = spec , npa = npa ) write_equilibrium Write MHD equilibrium values to a HDF5 file Input Arguments filename : Name of the equilibrium file plasma : Plasma dictionary fields : Electromagnetic fields dictionary Example Usage >>> write_equilibrium ( filename , plasma , fields ) write_distribution Write fast-ion distribution to a HDF5 file Input Arguments filename : Name of the distribution file dist : Fast-ion distribution distionary Example Usage >>> write_distribution(filename, distri) prefida Checks FIDASIM inputs and writes FIDASIM input files Input Arguments inputs : Inputs structure grid : Interpolation grid structure nbi : Neutral beam geometry structure plasma : Plasma parameters structure fields : Electromagnetic fields structure fbm : Fast-ion distribution structure Keyword Arguments spec : Optional, Spectral geometry structure npa : Optional, NPA geometry structure Example Usage >>> prefida ( inputs , grid , nbi , plasma , fields , fbm , spec = spec , npa = npa ) Contents Source Code preprocessing.py Source Code #!/usr/bin/env python # -*- coding: utf-8 -*- #+#PREFIDA Source #+ This file contains the source code for PREFIDA #+*** from __future__ import print_function import os import numpy as np import datetime import h5py from fidasim.utils import * def check_dict_schema ( schema , dic , desc = None ): \"\"\" #+#check_dict_schema #+ Check dict `dec` is formatted according to `schema` #+*** #+##Input Arguments #+     **schema**: dict schema #+ #+     **dic**: dict to check #+ #+##Output Arguments #+     **err**: error code #+ #+##Keyword Arguments #+     **desc**: description of dict `dic` #+ #+##Example usage #+```python #+>>> dic = {'a':0, 'b':[1.d0,2.d0], 'c':\"example\"} #+>>> schema = {'a':{'dims':0,'type':[int]}, 'b':{'dims':[2],'type':[float, np.float64]}, 'c':{'dims':0,'type':[str]}  } #+ #+>>> err = check_dict_schema(schema, dic, desc=\"Example dict\") #+>>> print(err) #+    False #+``` \"\"\" if desc is None : desc = 'dict' err = False schema_keys = list ( schema . keys ()) dic_keys = list ( dic . keys ()) # Note extra variables for key in dic_keys : if key not in schema_keys : info ( 'Extra variable \" {} \" found in \" {} \"' . format ( key , desc )) for key in schema_keys : # Note missing data if key not in dic_keys : error ( '\" {} \" is missing from \" {} \"' . format ( key , desc )) err = True else : # Check type if ( schema [ key ][ 'dims' ] == 0 ): if not isinstance ( dic [ key ], tuple ( schema [ key ][ 'type' ])): error ( '\" {} \" has the wrong type of {} . Expected {} ' . format ( key , type ( dic [ key ]), schema [ key ][ 'type' ])) err = True elif dic [ key ] . dtype . type not in schema [ key ][ 'type' ]: error ( '\" {} \" has the wrong type of {} . Expected {} ' . format ( key , dic [ key ] . dtype . type , schema [ key ][ 'type' ])) err = True # Check for NaNs or Inf if ( not isinstance ( dic [ key ], ( str , dict , float , int ))) and ( np . bytes_ not in schema [ key ][ 'type' ]): if ( dic [ key ][ np . isnan ( dic [ key ])] . size > 0 ) or ( dic [ key ][ np . isinf ( dic [ key ])] . size > 0 ): error ( 'NaN or Infinity detected in \" {} \"' . format ( key )) err = True # Check shape if not np . array_equal ( dic [ key ] . shape , schema [ key ][ 'dims' ]): error ( '\" {} \" has the wrong shape of {} . Expected ( {} )' . format ( key , dic [ key ] . shape , schema [ key ][ 'dims' ])) print ( 'ndim( {} ) = {} ' . format ( key , dic [ key ] . ndim )) err = True # Check shape if isinstance ( dic [ key ], ( str , int , float )): if ( schema [ key ][ 'dims' ] != 0 ) and ( schema [ key ][ 'dims' ] != [ 0 ]): error ( '\" {} \" has the wrong shape. Expected ( {} )' . format ( key , schema [ key ][ 'dims' ])) err = True return err def check_inputs ( inputs ): \"\"\" #+#check_inputs #+Checks if input dictionary is valid #+*** #+##Input Arguments #+     **inputs**: input dictionary #+ #+##Output Arguments #+     **inputs**: Updated inputs dictionary #+ #+##Example Usage #+```dist #+>>> inputs = check_inputs(inputs) #+``` \"\"\" info ( 'Checking simulation settings...' ) err = False zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_int = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_long = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_double = { 'dims' : 0 , 'type' : [ float , np . float64 ]} three_double = { 'dims' : [ 3 ], 'type' : [ float , np . float64 ]} schema = { 'comment' : zero_string , 'shot' : zero_long , 'time' : zero_double , 'runid' : zero_string , 'device' : zero_string , 'tables_file' : zero_string , 'result_dir' : zero_string , 'nlambda' : zero_int , 'lambdamin' : zero_double , 'lambdamax' : zero_double , 'nx' : zero_int , 'ny' : zero_int , 'nz' : zero_int , 'alpha' : zero_double , 'beta' : zero_double , 'gamma' : zero_double , 'origin' : three_double , 'xmin' : zero_double , 'xmax' : zero_double , 'ymin' : zero_double , 'ymax' : zero_double , 'zmin' : zero_double , 'zmax' : zero_double , 'ab' : zero_double , 'ai' : zero_double , 'current_fractions' : three_double , 'pinj' : zero_double , 'einj' : zero_double , 'impurity_charge' : zero_int , 'n_fida' : zero_long , 'n_nbi' : zero_long , 'n_pfida' : zero_long , 'n_pnpa' : zero_long , 'n_dcx' : zero_long , 'n_npa' : zero_long , 'n_halo' : zero_long , 'n_birth' : zero_long , 'ne_wght' : zero_int , 'np_wght' : zero_int , 'nphi_wght' : zero_int , 'emax_wght' : zero_double , 'nlambda_wght' : zero_int , 'lambdamin_wght' : zero_double , 'lambdamax_wght' : zero_double , 'calc_npa' : zero_int , 'calc_fida' : zero_int , 'calc_pnpa' : zero_int , 'calc_pfida' : zero_int , 'calc_bes' : zero_int , 'calc_dcx' : zero_int , 'calc_halo' : zero_int , 'calc_cold' : zero_int , 'calc_brems' : zero_int , 'calc_birth' : zero_int , 'calc_fida_wght' : zero_int , 'calc_npa_wght' : zero_int , 'calc_neutron' : zero_int } err = check_dict_schema ( schema , inputs , desc = \"simulation settings\" ) if err : error ( 'Invalid simulation settings. Exiting...' , halt = True ) # Normalize File Paths inputs [ 'result_dir' ] = os . path . abspath ( inputs [ 'result_dir' ]) if ( inputs [ 'alpha' ] > 2. * np . pi ) or ( inputs [ 'beta' ] > 2. * np . pi ) or ( inputs [ 'gamma' ] > 2. * np . pi ): error ( 'Angles must be in radians' ) err = True if inputs [ 'lambdamin' ] >= inputs [ 'lambdamax' ]: error ( 'Invalid wavelength range. Expected lambdamin < lamdbdamax' ) err = True if inputs [ 'lambdamin_wght' ] >= inputs [ 'lambdamax_wght' ]: error ( 'Invalid wavelength range. Expected lambdamin_wght < lamdbdamax_wght' ) err = True if inputs [ 'xmin' ] >= inputs [ 'xmax' ]: error ( 'Invalid x range. Expected xmin < xmax' ) err = True if inputs [ 'ymin' ] >= inputs [ 'ymax' ]: error ( 'Invalid y range. Expected ymin < ymax' ) err = True if inputs [ 'zmin' ] >= inputs [ 'zmax' ]: error ( 'Invalid z range. Expected zmin < zmax' ) err = True if ( inputs [ 'pinj' ] <= 0. ) or ( inputs [ 'einj' ] <= 0.0 ): error ( 'The selected source is not on' ) print ( 'einj = {} ' . format ( inputs [ 'einj' ])) print ( 'pinj = {} ' . format ( inputs [ 'pinj' ])) err = True if np . abs ( np . sum ( inputs [ 'current_fractions' ]) - 1.0 ) > 1e-3 : error ( 'current_fractions do not sum to 1.0' ) print ( 'sum(current_fractions) = {} ' . format ( np . sum ( inputs [ 'current_fractions' ]))) err = True if inputs [ 'impurity_charge' ] <= 1 : error ( 'Invalid impurity charge. Expected impurity charge > 1' ) err = True ps = os . path . sep input_file = inputs [ 'result_dir' ] + ps + inputs [ 'runid' ] + '_inputs.dat' equilibrium_file = inputs [ 'result_dir' ] + ps + inputs [ 'runid' ] + '_equilibrium.h5' geometry_file = inputs [ 'result_dir' ] + ps + inputs [ 'runid' ] + '_geometry.h5' distribution_file = inputs [ 'result_dir' ] + ps + inputs [ 'runid' ] + '_distribution.h5' neutrals_file = inputs [ 'result_dir' ] + ps + inputs [ 'runid' ] + '_neutrals.h5' inputs [ 'input_file' ] = input_file inputs [ 'equilibrium_file' ] = equilibrium_file inputs [ 'geometry_file' ] = geometry_file inputs [ 'distribution_file' ] = distribution_file inputs [ 'load_neutrals' ] = 0 inputs [ 'flr' ] = 2 inputs [ 'seed' ] = - 1 inputs [ 'verbose' ] = 1 inputs [ 'neutrals_file' ] = neutrals_file if err : error ( 'Invalid simulation settings. Exiting...' , halt = True ) else : success ( 'Simulation settings are valid' ) return inputs def check_grid ( grid ): \"\"\" #+#check_grid #+Checks if interpolation grid structure is valid #+*** #+##Input Arguments #+     **grid**: Interpolation grid structure #+ #+##Example Usage #+```python #+>>> check_grid(grid) #+``` \"\"\" err = False info ( 'Checking interpolation grid...' ) if 'nr' not in grid : error ( '\"nr\" is missing from the interpolation grid' ) error ( 'Invalid interpolation grid. Exiting...' , halt = True ) if 'nz' not in grid : error ( '\"nz\" is missing from the interpolation grid' ) error ( 'Invalid interpolation grid. Exiting...' , halt = True ) if 'nphi' not in grid : info ( '\"nphi\" is missing from the interpolation grid, assuming axisymmetry' ) nphi = 1 else : nphi = grid [ 'nphi' ] nr = grid [ 'nr' ] nz = grid [ 'nz' ] zero_int = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} nrnz_doub = { 'dims' : [ nr , nz ], 'type' : [ float , np . float64 ]} schema = { 'nr' : zero_int , 'nz' : zero_int , 'nphi' : zero_int , 'r2d' : nrnz_doub , 'z2d' : nrnz_doub , 'r' : { 'dims' : [ nr ], 'type' : [ float , np . float64 ]}, 'z' : { 'dims' : [ nz ], 'type' : [ float , np . float64 ]}, 'phi' : { 'dims' : [ nphi ], 'type' : [ float , np . float64 ]}} err = check_dict_schema ( schema , grid , desc = \"interpolation grid\" ) if err : error ( 'Invalid interpolation grid. Exiting...' , halt = True ) if not np . array_equal ( grid [ 'r' ], np . sort ( grid [ 'r' ])): error ( 'r is not in ascending order' ) err = True if not np . array_equal ( grid [ 'z' ], np . sort ( grid [ 'z' ])): error ( 'z is not in ascending order' ) err = True if not np . array_equal ( grid [ 'r' ], grid [ 'r2d' ][:, 0 ]): error ( 'r2d is defined incorrectly. Expected r == r2d[:, 0]' ) err = True if not np . array_equal ( grid [ 'z' ], grid [ 'z2d' ][ 0 , :]): error ( 'z2d is defined incorrectly. Expected z == z2d[0, :]' ) err = True if err : error ( 'Invalid interpolation grid. Exiting...' , halt = True ) else : success ( 'Interpolation grid is valid' ) def check_beam ( inputs , nbi ): \"\"\" #+#check_beam #+Checks if neutral beam geometry dictionary is valid. Converts lists to numpy ndarrays #+*** #+##Input Arguments #+     **inputs**: input dictionary #+ #+     **nbi**: neutral beam geometry dictionary #+ #+##Output Arguments #+     **nbi**: Updated nbi dictionary #+ #+##Example Usage #+```python #+>>> nbi = check_beam(inputs, nbi) #+``` \"\"\" err = False info ( 'Checking beam geometry...' ) na = nbi [ 'naperture' ] zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_int = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_double = { 'dims' : 0 , 'type' : [ float , np . float64 ]} three_double = { 'dims' : [ 3 ], 'type' : [ float , np . float64 ]} na_double = { 'dims' : [ na ], 'type' : [ float , np . float64 ]} na_int = { 'dims' : [ na ], 'type' : [ int , np . int32 , np . int64 ]} schema = { 'data_source' : zero_string , 'name' : zero_string , 'shape' : zero_int , 'src' : three_double , 'axis' : three_double , 'divy' : three_double , 'divz' : three_double , 'focy' : zero_double , 'focz' : zero_double , 'widz' : zero_double , 'widy' : zero_double } # Add to schema if aperatures are present if nbi [ 'naperture' ] > 0 : schema [ 'naperture' ] = zero_int schema [ 'ashape' ] = na_int schema [ 'awidy' ] = na_double schema [ 'awidz' ] = na_double schema [ 'aoffy' ] = na_double schema [ 'aoffz' ] = na_double schema [ 'adist' ] = na_double # Convert to np arrays for indexing nbi [ 'ashape' ] = np . array ( nbi [ 'ashape' ], dtype = int , ndmin = 1 ) nbi [ 'awidy' ] = np . array ( nbi [ 'awidy' ], dtype = float , ndmin = 1 ) nbi [ 'awidz' ] = np . array ( nbi [ 'awidz' ], dtype = float , ndmin = 1 ) nbi [ 'aoffy' ] = np . array ( nbi [ 'aoffy' ], dtype = float , ndmin = 1 ) nbi [ 'aoffz' ] = np . array ( nbi [ 'aoffz' ], dtype = float , ndmin = 1 ) nbi [ 'adist' ] = np . array ( nbi [ 'adist' ], dtype = float , ndmin = 1 ) err = check_dict_schema ( schema , nbi , desc = \"beam geometry\" ) if err : error ( 'Invalid beam geometry. Exiting...' , halt = True ) if np . abs ( np . sum ( nbi [ 'axis' ] ** 2. ) - 1. ) > 1e-5 : error ( 'Invalid source axis. Expected norm(axis) == 1' ) err = True if nbi [ 'focz' ] <= 0.0 : error ( 'focz cannot be in the range (-Inf,0.0]' ) err = True if nbi [ 'focy' ] <= 0.0 : error ( 'focy cannot be in the range (-Inf,0.0]' ) err = True if nbi [ 'shape' ] not in [ 1 , 2 ]: error ( 'Invalid source shape. Expected 1 (rectagular) or 2 (circular)' ) err = True if nbi [ 'widz' ] < 0. : error ( 'Invalid widz. Expected widz > 0' ) err = True if nbi [ 'widy' ] < 0 : error ( 'Invalid widy. Expected widy > 0' ) err = True if nbi [ 'naperture' ] > 0 : if nbi [ 'ashape' ] not in [ 1 , 2 ]: error ( 'Invalid aperture shape. Expected 1 (rectangular) or 2 (circular)' ) err = True w = nbi [ 'awidy' ] < 0 nw = len ( nbi [ 'awidy' ][ w ]) if nw > 0 : error ( 'Invalid awidy. Expected awidy >= 0.0' ) err = True w = nbi [ 'awidz' ] < 0 nw = len ( nbi [ 'awidz' ][ w ]) if nw > 0 : error ( 'Invalid awidz. Expected awidz >= 0.0' ) err = True # Machine coordinates origin = inputs [ 'origin' ] uvw_src = nbi [ 'src' ] uvw_axis = nbi [ 'axis' ] if nbi [ 'naperture' ] == 0 : uvw_pos = uvw_src + 100 * uvw_axis else : uvw_pos = uvw_src + nbi [ 'adist' ][ 0 ] # Convert to beam coordinates xyz_src = uvw_to_xyz ( inputs [ 'alpha' ], inputs [ 'beta' ], inputs [ 'gamma' ], uvw_src , origin = origin ) xyz_axis = uvw_to_xyz ( inputs [ 'alpha' ], inputs [ 'beta' ], inputs [ 'gamma' ], uvw_axis ) xyz_pos = uvw_to_xyz ( inputs [ 'alpha' ], inputs [ 'beta' ], inputs [ 'gamma' ], uvw_pos , origin = origin ) xyz_center = uvw_to_xyz ( inputs [ 'alpha' ], inputs [ 'beta' ], inputs [ 'gamma' ], [ 0. , 0. , 0. ], origin = origin ) dis = np . sqrt ( np . sum (( xyz_src - xyz_pos ) ** 2. )) alpha = np . arctan2 (( xyz_pos [ 1 ] - xyz_src [ 1 ]), ( xyz_pos [ 0 ] - xyz_src [ 0 ])) beta = np . arcsin (( xyz_src [ 2 ] - xyz_pos [ 2 ]) / dis ) print ( 'Machine center in beam grid coordinates' ) print ( xyz_center ) print ( 'Beam injection start point in machine coordinates' ) print ( uvw_src ) print ( 'Beam injection start point in beam grid coordinates' ) print ( xyz_src ) if nbi [ 'naperture' ] != 0 : print ( 'First aperture position in machine coordinates' ) print ( uvw_pos ) print ( 'First aperture position in beam grid coordinates' ) print ( xyz_pos ) else : print ( 'Position of point 100cm along beam centerline in machine coordinates' ) print ( uvw_pos ) print ( 'Position of point 100cm along beam centerline in beam grid coordinates' ) print ( xyz_pos ) print ( 'Beam grid rotation angles that would align it with the beam centerline' ) print ( 'alpha = {} deg.' . format ( alpha / np . pi * 180. )) print ( 'beta = {} deg.' . format ( beta / np . pi * 180. )) # Calculate grid center rc and sides length dr dr = np . array ([ inputs [ 'xmax' ] - inputs [ 'xmin' ], inputs [ 'ymax' ] - inputs [ 'ymin' ], inputs [ 'zmax' ] - inputs [ 'zmin' ]], dtype = np . float64 ) rc = np . array ([ inputs [ 'xmin' ], inputs [ 'ymin' ], inputs [ 'zmin' ]], dtype = np . float64 ) + 0.5 * dr # Check if beam centerline intersects beam grid length , r_enter , r_exit = aabb_intersect ( rc , dr , xyz_src , xyz_axis ) print ( 'Beam centerline - grid intersection length' ) print ( length ) if length <= 10.0 : error ( 'Beam centerline does not intersect grid' ) err = True if err : error ( 'Invalid beam geometry. Exiting...' , halt = True ) else : success ( 'Beam geometry is valid' ) return nbi def check_plasma ( inputs , grid , plasma ): \"\"\" #+#check_plasma #+Checks if plasma paramters dictionary is valid #+*** #+##Input Arguments #+     **inputs**: Input dictionary #+ #+     **grid**: Interpolation grid dictionary #+ #+     **plasma**: Plasma parameters dictionary #+ #+##Output Arguments #+     **plasma**: Updated plasma dictionary #+ #+##Example Usage #+```python #+>>> plasma = check_plasma(inputs, grid, plasma) #+``` \"\"\" err = False info ( 'Checking plasma parameters...' ) nr = grid [ 'nr' ] nz = grid [ 'nz' ] if 'nphi' not in grid : info ( '\"nphi\" is missing from the plasma, assuming axisymmetry' ) nphi = 1 else : nphi = grid [ 'nphi' ] zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_double = { 'dims' : 0 , 'type' : [ float , np . float64 ]} if nphi > 1 : nrnznphi_double = { 'dims' : [ nr , nz , nphi ], 'type' : [ float , np . float64 , np . float64 ]} nrnznphi_int = { 'dims' : [ nr , nz , nphi ], 'type' : [ np . int64 ]} else : nrnznphi_double = { 'dims' : [ nr , nz ], 'type' : [ float , np . float64 ]} nrnznphi_int = { 'dims' : [ nr , nz ], 'type' : [ np . int64 ]} schema = { 'time' : zero_double , 'vr' : nrnznphi_double , 'vt' : nrnznphi_double , 'vz' : nrnznphi_double , 'dene' : nrnznphi_double , 'denn' : nrnznphi_double , 'ti' : nrnznphi_double , 'te' : nrnznphi_double , 'zeff' : nrnznphi_double , 'mask' : nrnznphi_int , 'data_source' : zero_string } err = check_dict_schema ( schema , plasma , desc = \"plasma parameters\" ) if err : error ( 'Invalid plasma parameters. Exiting...' , halt = True ) if plasma [ 'data_source' ] == '' : error ( 'Invalid data source. An empty string is not a data source.' ) err = True # Electron density w = ( plasma [ 'dene' ] < 0. ) plasma [ 'dene' ][ w ] = 0. # Zeff w = ( plasma [ 'zeff' ] < 1. ) plasma [ 'zeff' ][ w ] = 1. # Electron temperature w = ( plasma [ 'te' ] < 0. ) plasma [ 'te' ][ w ] = 0. # Ion temperature w = ( plasma [ 'ti' ] < 0. ) plasma [ 'ti' ][ w ] = 0. if ( np . abs ( plasma [ 'time' ] - inputs [ 'time' ]) > 0.02 ): warn ( 'Plasma time and input time do not match' ) print ( 'Input time: ' , inputs [ 'time' ]) print ( 'Plasma time: ' , plasma [ 'time' ]) # Add grid elements to plasma dict plasma . update ( grid . copy ()) if err : error ( 'Invalid plasma parameters. Exiting...' , halt = True ) else : success ( 'Plasma parameters are valid' ) return plasma def check_fields ( inputs , grid , fields ): \"\"\" #+#check_fields #+Checks if electromagnetic fields dictionary is valid #+*** #+##Input Arguments #+     **inputs**: Input dictionary #+ #+     **grid**: Interpolation grid dictionary #+ #+     **fields**: Electromagnetic fields dictionary #+ #+##Output Arguments #+     **fields**: Updated fields dictionary #+ #+##Example Usage #+```python #+>>> fields = check_fields(inputs, grid, fields) #+``` \"\"\" err = False info ( 'Checking electromagnetic fields...' ) nr = grid [ 'nr' ] nz = grid [ 'nz' ] if 'nphi' not in grid : info ( '\"nphi\" is missing from the fields, assuming axisymmetry' ) nphi = 1 else : nphi = grid [ 'nphi' ] zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_double = { 'dims' : 0 , 'type' : [ float , np . float64 ]} if nphi > 1 : nrnznphi_double = { 'dims' : [ nr , nz , nphi ], 'type' : [ float , np . float64 , np . float64 ]} nrnznphi_int = { 'dims' : [ nr , nz , nphi ], 'type' : [ int , np . int32 , np . int64 ]} else : nrnznphi_double = { 'dims' : [ nr , nz ], 'type' : [ float , np . float64 ]} nrnznphi_int = { 'dims' : [ nr , nz ], 'type' : [ int , np . int32 ]} schema = { 'time' : zero_double , 'br' : nrnznphi_double , 'bt' : nrnznphi_double , 'bz' : nrnznphi_double , 'er' : nrnznphi_double , 'et' : nrnznphi_double , 'ez' : nrnznphi_double , 'mask' : nrnznphi_int , 'data_source' : zero_string } err = check_dict_schema ( schema , fields , desc = \"electromagnetic fields\" ) if err : error ( 'Invalid electromagnetic fields. Exiting...' , halt = True ) if fields [ 'data_source' ] == '' : error ( 'Invalid data source. An empty string is not a data source.' ) err = True if np . abs ( fields [ 'time' ] - inputs [ 'time' ]) > 0.02 : warn ( 'Electromagnetic fields time and input time do not match' ) print ( 'Input time: {} ' . format ( inputs [ 'time' ])) print ( 'Electromagnetic fields time: {} ' . format ( fields [ 'time' ])) # Add grid elements to fields dict fields . update ( grid . copy ()) if err : error ( 'Invalid electromagnetic fields. Exiting...' , halt = True ) else : success ( 'Electromagnetic fields are valid' ) return fields def check_distribution ( inputs , grid , dist ): \"\"\" #+#check_distribution #+Checks if distribution dictionary is valid #+*** #+##Input Arguments #+     **inputs**: Input dictionary #+ #+     **grid**: Interpolation grid dictionary #+ #+     **dist**: Fast-ion distribution dictionary #+ #+##Output Arguments #+     **dist**: Updated dist dictionary #+ #+##Example Usage #+```python #+>>> dist = check_distribution(inputs, grid, dist) #+``` \"\"\" err = False info ( 'Checking fast-ion distribution...' ) dist_keys = list ( dist . keys ()) if 'type' not in dist_keys : error ( '\"type\" is missing from the fast-ion distribution' ) error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) dist_type = dist [ 'type' ] if dist_type == 1 : print ( 'Using a Guiding Center Fast-ion Density Function' ) if 'nenergy' not in dist_keys : error ( '\"nenergy\" is missing from the fast-ion distribution' ) error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) if 'npitch' not in dist_keys : error ( '\"npitch\" is missing from the fast-ion distribution' ) error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) npitch = dist [ 'npitch' ] nen = dist [ 'nenergy' ] nr = grid [ 'nr' ] nz = grid [ 'nz' ] if 'nphi' not in grid : info ( '\"nphi\" is missing from the fast-ion distribution, assuming axisymmetry' ) nphi = 1 else : nphi = grid [ 'nphi' ] zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_int = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_double = { 'dims' : 0 , 'type' : [ float , np . float64 ]} if nphi > 1 : nrnznphi_double = { 'dims' : [ nr , nz , nphi ], 'type' : [ float , np . float64 , np . float64 ]} else : nrnznphi_double = { 'dims' : [ nr , nz ], 'type' : [ float , np . float64 ]} schema = { 'type' : zero_int , 'nenergy' : zero_int , 'npitch' : zero_int , 'energy' : { 'dims' : [ nen ], 'type' : [ float , np . float64 ]}, 'pitch' : { 'dims' : [ npitch ], 'type' : [ float , np . float64 ]}, 'denf' : nrnznphi_double , 'time' : zero_double , 'data_source' : zero_string } if nphi > 1 : schema [ 'f' ] = { 'dims' : [ nen , npitch , nr , nz , nphi ], 'type' : [ float , np . float64 ]} else : schema [ 'f' ] = { 'dims' : [ nen , npitch , nr , nz ], 'type' : [ float , np . float64 ]} err = check_dict_schema ( schema , dist , desc = \"fast-ion distribution\" ) if err : error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) # Add grid elements to plasma dict dist . update ( grid . copy ()) elif dist_type == 2 : print ( 'Using Guiding Center Monte Carlo fast-ion distribution' ) if 'nparticle' not in dist_keys : error ( '\"nparticle\" is missing from the fast-ion distribution' ) error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) npart = dist [ 'nparticle' ] zero_int = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_long = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_double = { 'dims' : 0 , 'type' :[ float , np . float64 ]} npart_double = { 'dims' : [ npart ], 'type' : [ float , np . float64 ]} npart_int = { 'dims' : [ npart ], 'type' : [ int , np . int32 , np . int64 ]} schema = { 'type' : zero_int , 'nparticle' : zero_long , 'nclass' : zero_int , 'time' : zero_double , 'energy' : npart_double , 'pitch' : npart_double , 'r' : npart_double , 'z' : npart_double , 'weight' : npart_double , 'class' : npart_int , 'data_source' : zero_string } err = check_dict_schema ( schema , dist , desc = \"fast-ion distribution\" ) if err : error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) print ( 'Number of MC particles: {} ' . format ( npart )) elif dist_type == 3 : print ( 'Using Full Orbit Monte Carlo fast-ion distribution' ) if 'nparticle' not in dist_keys : error ( '\"nparticle\" is missing from the fast-ion distribution' ) error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) npart = dist [ 'nparticle' ] zero_int = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_long = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_double = { 'dims' : 0 , 'type' : [ float , np . float64 ]} npart_double = { 'dims' : [ npart ], 'type' : [ float , np . float64 ]} npart_int = { 'dims' : [ npart ], 'type' : [ int , np . int32 , np . int64 ]} schema = { 'type' : zero_int , 'nparticle' : zero_long , 'nclass' : zero_int , 'time' : zero_double , 'vr' : npart_double , 'vt' : npart_double , 'vz' : npart_double , 'r' : npart_double , 'z' : npart_double , 'weight' : npart_double , 'class' : npart_int , 'data_source' : zero_string } err = check_dict_schema ( schema , dist , desc = \"fast-ion distribution\" ) if err : error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) print ( 'Number of MC particles: {} ' . format ( npart )) else : error ( 'Invalid distribution type. Expected ' + '1 (Guiding Center Density Function), ' + '2 (Guiding Center Monte Carlo), or ' + '3 (Full Orbit Monte Carlo)' ) error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) if dist [ 'data_source' ] == '' : error ( 'Invalid data source. An empty string is not a data source.' ) err = True if np . abs ( dist [ 'time' ] - inputs [ 'time' ]) > 0.02 : warn ( 'Distribution time and input time do not match' ) print ( 'Input time: {} ' . format ( inputs [ 'time' ])) print ( 'Distribution time: {} ' . format ( dist [ 'time' ])) if err : error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) else : success ( 'Fast-ion distribution is valid' ) return dist def check_spec ( inputs , chords ): \"\"\" #+#check_spec #+Check if spectral geometry dictionary is valid #+*** #+##Input Arguments #+     **inputs**: input dictionary #+ #+     **chords**: spectral geometry dictionary #+ #+##Example Usage #+```python #+>>> check_spec(inputs, chords) #+``` \"\"\" err = False info ( 'Checking FIDA/BES inputs...' ) chords_keys = list ( chords . keys ()) if 'nchan' not in chords_keys : error ( '\"nchan\" is missing from the FIDA/BES geometry' ) err = True error ( 'Invalid FIDA/BES geometry. Exiting...' , halt = True ) nchan = chords [ 'nchan' ] zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_long = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} nchan_double = { 'dims' : [ nchan ], 'type' : [ float , np . float64 ]} nchan_string = { 'dims' : [ nchan ], 'type' : [ np . bytes_ , str ]} three_nchan_float = { 'dims' : [ 3 , nchan ], 'type' : [ float , np . float64 ]} schema = { 'data_source' : zero_string , 'nchan' : zero_long , 'system' : zero_string , 'id' : nchan_string , 'lens' : three_nchan_float , 'axis' : three_nchan_float , 'sigma_pi' : nchan_double , 'spot_size' : nchan_double , 'radius' : nchan_double } err = check_dict_schema ( schema , chords , desc = \"FIDA/BES geometry\" ) if err : error ( 'Invalid FIDA/BES geometry. Exiting...' , halt = True ) cross_arr = np . zeros ( nchan , dtype = int ) uvw_lens = chords [ 'lens' ] uvw_axis = chords [ 'axis' ] # ROTATE CHORDS INTO BEAM GRID COORDINATES xyz_lens = uvw_to_xyz ( inputs [ 'alpha' ], inputs [ 'beta' ], inputs [ 'gamma' ], uvw_lens , origin = inputs [ 'origin' ]) xyz_axis = uvw_to_xyz ( inputs [ 'alpha' ], inputs [ 'beta' ], inputs [ 'gamma' ], uvw_axis ) # Calculate grid center rc and sides length dr dr = np . array ([ inputs [ 'xmax' ] - inputs [ 'xmin' ], inputs [ 'ymax' ] - inputs [ 'ymin' ], inputs [ 'zmax' ] - inputs [ 'zmin' ]], dtype = float ) rc = np . array ([ inputs [ 'xmin' ], inputs [ 'ymin' ], inputs [ 'zmin' ]], dtype = float ) + 0.5 * dr for i in range ( nchan ): if not np . isclose ( np . linalg . norm ( uvw_axis [:, i ]), 1 , rtol = 1e-03 ): error ( 'Invalid optical axis for chord \"' + str ( chords [ 'id' ][ i ]) + '\". Expected norm(axis) == 1' ) print ( np . sum ( uvw_axis [:, i ] ** 2. )) # Check if viewing chord intersects beam grid length , r_enter , r_exit = aabb_intersect ( rc , dr , xyz_lens [:, i ], xyz_axis [:, i ]) if length <= 0.0 : cross_arr [ i ] = 1 wbad = ( cross_arr == 1 ) nbad = cross_arr [ wbad ] . size if nbad > 0 : warn ( 'The following {} chords do not cross the beam grid:' . format ( nbad )) warn ( 'Chord ID: {} ' . format ( chords [ 'id' ][ wbad ])) wgood = ( cross_arr == 0 ) ngood = cross_arr [ wgood ] . size print ( ' {} out of {} chords crossed the beam grid' . format ( ngood , nchan )) if ngood == 0 : error ( 'No channels intersect the beam grid' ) err = True if err : error ( 'Invalid FIDA/BES geometry. Exiting...' , halt = True ) else : success ( 'FIDA/BES geometry is valid' ) def check_npa ( inp , npa ): \"\"\" #+#check_npa #+Checks if NPA geometry dictionary is valid #+*** #+##Input Arguments #+     **inputs**: input dictionary #+ #+     **npa**: NPA geometry dictionary #+ #+##Example Usage #+```python #+>>> check_npa(inputs, npa) #+``` \"\"\" err = False info ( 'Checking NPA geometry...' ) npa_keys = npa . keys () if 'nchan' not in npa_keys : error ( '\"nchan\" is missing from the NPA geometry' ) err = True error ( 'Invalid NPA geometry. Exiting...' , halt = True ) nchan = npa [ 'nchan' ] zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_long = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} three_float = { 'dims' : [ 3 , nchan ], 'type' : [ float , np . float64 ]} nchan_int = { 'dims' : [ nchan ], 'type' : [ int , np . int32 , np . int64 ]} nchan_float = { 'dims' : [ nchan ], 'type' : [ float , np . float64 ]} nchan_string = { 'dims' : [ nchan ], 'type' : [ np . bytes_ ]} schema = { 'data_source' : zero_string , 'nchan' : zero_long , 'system' : zero_string , 'id' : nchan_string , 'a_shape' : nchan_int , 'd_shape' : nchan_int , 'a_tedge' : three_float , 'a_redge' : three_float , 'a_cent' : three_float , 'd_tedge' : three_float , 'd_redge' : three_float , 'd_cent' : three_float , 'radius' : nchan_float } err = check_dict_schema ( schema , npa , desc = \"NPA geometry\" ) if err : error ( 'Invalid NPA geometry. Exiting...' , halt = True ) # Check detector/aperture shape w = np . logical_or ( npa [ 'd_shape' ] > 2 , npa [ 'd_shape' ] == 0 ) nw = len ( npa [ 'd_shape' ][ w ]) if nw != 0 : error ( 'Invalid detector shape. Expected 1 (rectagular) or 2 (circular)' ) print ( 'Invalid indices: {} ' . format ( np . arange ( len ( npa [ 'd_shape' ]))[ w ])) err = True w = np . logical_or ( npa [ 'a_shape' ] > 2 , npa [ 'a_shape' ] == 0 ) nw = len ( npa [ 'a_shape' ][ w ]) if nw != 0 : error ( 'Invalid aperture shape. Expected 1 (rectagular) or 2 (circular)' ) print ( 'Invalid indices: {} ' . format ( np . arange ( len ( npa [ 'a_shape' ]))[ w ])) err = True # Calculate grid center rc and sides length dr dr = np . array ([ inp [ 'xmax' ] - inp [ 'xmin' ], inp [ 'ymax' ] - inp [ 'ymin' ], inp [ 'zmax' ] - inp [ 'zmin' ]]) rc = np . array ([ inp [ 'xmin' ], inp [ 'ymin' ], inp [ 'zmin' ]]) + 0.5 * dr err_arr = np . zeros ( nchan , dtype = int ) for i in range ( nchan ): uvw_det = npa [ 'd_cent' ][:, i ] d_e1 = npa [ 'd_redge' ][:, i ] - uvw_det d_e2 = npa [ 'd_tedge' ][:, i ] - uvw_det uvw_aper = npa [ 'a_cent' ][:, i ] a_e1 = npa [ 'a_redge' ][:, i ] - uvw_aper a_e2 = npa [ 'a_tedge' ][:, i ] - uvw_aper uvw_dir = uvw_aper - uvw_det #Rotate chords into beam grid coordinates xyz_aper = uvw_to_xyz ( inp [ 'alpha' ], inp [ 'beta' ], inp [ 'gamma' ], uvw_aper , origin = inp [ 'origin' ]) xyz_det = uvw_to_xyz ( inp [ 'alpha' ], inp [ 'beta' ], inp [ 'gamma' ], uvw_det , origin = inp [ 'origin' ]) xyz_dir = xyz_aper - xyz_det xyz_dir = xyz_dir / np . sqrt ( np . sum ( xyz_dir * xyz_dir )) # Check if npa chord intersects beam grid length , r_enter , r_exit = aabb_intersect ( rc , dr , xyz_det , xyz_dir ) if length <= 0. : err_arr [ i ] = 1 # Check if NPA detector is pointing in the right direction d_enter = np . sqrt ( np . sum (( r_enter - xyz_aper ) ** 2 )) d_exit = np . sqrt ( np . sum (( r_exit - xyz_aper ) ** 2 )) if d_exit < d_enter : err_arr [ i ] = 1 # Check that the detector and aperture point in the same direction d_e3 = np . cross ( d_e1 , d_e2 ) a_e3 = np . cross ( a_e1 , a_e2 ) a_dp = np . sum ( uvw_dir * a_e3 ) d_dp = np . sum ( uvw_dir * d_e3 ) dp = np . sum ( d_e3 * a_e3 ) if ( dp <= 0. ) or ( a_dp <= 0. ) or ( d_dp <= 0. ): error ( 'The detector and/or aperture plane normal vectors are pointing in the wrong direction. The NPA definition is incorrect.' ) err_arr [ i ] = 1 w = ( err_arr == 0 ) nw = err_arr [ w ] . size ww = ( err_arr != 0 ) nww = err_arr [ ww ] . size print ( ' {} out of {} channels crossed the beam grid' . format ( nw , nchan )) if nw == 0 : error ( 'No channels intersect the beam grid' ) err = True if nww > 0 : warn ( 'Some channels did not intersect the beam grid' ) print ( 'Number missed: {} ' . format ( nww )) print ( 'Missed channels:' ) print ( ' {} ' . format ( npa [ 'id' ][ ww ])) if err : error ( 'Invalid NPA geometry. Exiting...' , halt = True ) else : success ( 'NPA geometry is valid' ) def write_namelist ( filename , inputs ): \"\"\" #+#write_namelist #+Writes namelist file #+*** #+##Input Arguments #+     **filename**: Name of the namelist file #+ #+     **inputs**: Input dictionary #+ #+##Example Usage #+```python #+>>> write_namelist(filename, inputs) #+``` \"\"\" info ( \"Writing namelist file...\" ) fidasim_version = get_version ( get_fidasim_dir ()) with open ( filename , \"w\" ) as f : f . write ( \"!! Created: {} \\n \" . format ( datetime . datetime . now ())) f . write ( \"!! FIDASIM version: {} \\n \" . format ( fidasim_version )) f . write ( \"!! Comment: {} \\n \" . format ( inputs [ 'comment' ])) f . write ( \"&fidasim_inputs \\n\\n \" ) f . write ( \"!! Shot Info \\n \" ) f . write ( \"shot = {:d} !! Shot Number \\n \" . format ( inputs [ 'shot' ])) f . write ( \"time = {:f} !! Time [s] \\n \" . format ( inputs [ 'time' ])) f . write ( \"runid = ' {} '   !! runID \\n \" . format ( inputs [ 'runid' ])) f . write ( \"result_dir = ' {} '    !! Result Directory \\n\\n \" . format ( inputs [ 'result_dir' ])) f . write ( \"!! Input Files \\n \" ) f . write ( \"tables_file = ' {} '   !! Atomic Tables File \\n \" . format ( inputs [ 'tables_file' ])) f . write ( \"equilibrium_file = '\" + inputs [ 'equilibrium_file' ] + \"'    !! File containing plasma parameters and fields \\n \" ) f . write ( \"geometry_file = '\" + inputs [ 'geometry_file' ] + \"'    !! File containing NBI and diagnostic geometry \\n \" ) f . write ( \"distribution_file = '\" + inputs [ 'distribution_file' ] + \"'    !! File containing fast-ion distribution \\n\\n \" ) f . write ( \"!! Simulation Switches \\n \" ) f . write ( \"calc_bes = {:d} !! Calculate NBI Spectra \\n \" . format ( inputs [ 'calc_bes' ])) f . write ( \"calc_dcx = {:d} !! Calculate Direct CX Spectra \\n \" . format ( inputs [ 'calc_dcx' ])) f . write ( \"calc_halo = {:d} !! Calculate Halo Spectra \\n \" . format ( inputs [ 'calc_halo' ])) f . write ( \"calc_cold = {:d} !! Calculate Cold D-alpha Spectra \\n \" . format ( inputs [ 'calc_cold' ])) f . write ( \"calc_brems = {:d} !! Calculate Bremsstrahlung \\n \" . format ( inputs [ 'calc_brems' ])) f . write ( \"calc_fida = {:d} !! Calculate FIDA Spectra \\n \" . format ( inputs [ 'calc_fida' ])) f . write ( \"calc_npa = {:d} !! Calculate NPA \\n \" . format ( inputs [ 'calc_npa' ])) f . write ( \"calc_pfida = {:d} !! Calculate Passive FIDA Spectra \\n \" . format ( inputs [ 'calc_pfida' ])) f . write ( \"calc_pnpa = {:d} !! Calculate Passive NPA \\n \" . format ( inputs [ 'calc_pnpa' ])) f . write ( \"calc_neutron = {:d} !! Calculate B-T Neutron Rate \\n \" . format ( inputs [ 'calc_neutron' ])) f . write ( \"calc_birth = {:d} !! Calculate Birth Profile \\n \" . format ( inputs [ 'calc_birth' ])) f . write ( \"calc_fida_wght = {:d} !! Calculate FIDA weights \\n \" . format ( inputs [ 'calc_fida_wght' ])) f . write ( \"calc_npa_wght = {:d} !! Calculate NPA weights \\n \" . format ( inputs [ 'calc_npa_wght' ])) f . write ( \"!! Debugging Switches \\n \" ) f . write ( \"seed = {:d} !! RNG Seed. If seed is negative a random seed is used \\n \" . format ( inputs [ 'seed' ])) f . write ( \"flr = {:d} !! Turn on Finite Larmor Radius corrections \\n \" . format ( inputs [ 'flr' ])) f . write ( \"load_neutrals = {:d} !! Load neutrals from neutrals file \\n \" . format ( inputs [ 'load_neutrals' ])) f . write ( \"neutrals_file = '\" + inputs [ 'neutrals_file' ] + \"'    !! File containing the neutral density \\n \" ) f . write ( \"verbose = {:d} !! Verbose \\n\\n \" . format ( inputs [ 'verbose' ])) f . write ( \"!! Monte Carlo Settings \\n \" ) f . write ( \"n_fida = {:d} !! Number of FIDA mc particles \\n \" . format ( inputs [ 'n_fida' ])) f . write ( \"n_npa = {:d} !! Number of NPA mc particles \\n \" . format ( inputs [ 'n_npa' ])) f . write ( \"n_pfida = {:d} !! Number of Passive FIDA mc particles \\n \" . format ( inputs [ 'n_pfida' ])) f . write ( \"n_pnpa = {:d} !! Number of Passive NPA mc particles \\n \" . format ( inputs [ 'n_pnpa' ])) f . write ( \"n_nbi = {:d} !! Number of NBI mc particles \\n \" . format ( inputs [ 'n_nbi' ])) f . write ( \"n_halo = {:d} !! Number of HALO mc particles \\n \" . format ( inputs [ 'n_halo' ])) f . write ( \"n_dcx = {:d} !! Number of DCX mc particles \\n \" . format ( inputs [ 'n_dcx' ])) f . write ( \"n_birth = {:d} !! Number of BIRTH mc particles \\n\\n \" . format ( inputs [ 'n_birth' ])) f . write ( \"!! Neutral Beam Settings \\n \" ) f . write ( \"ab = {:f} !! Beam Species mass [amu] \\n \" . format ( inputs [ 'ab' ])) f . write ( \"pinj = {:f} !! Beam Power [MW] \\n \" . format ( inputs [ 'pinj' ])) f . write ( \"einj = {:f} !! Beam Energy [keV] \\n \" . format ( inputs [ 'einj' ])) f . write ( \"current_fractions(1) = {:f} !! Current Fractions (Full component) \\n \" . format ( inputs [ 'current_fractions' ][ 0 ])) f . write ( \"current_fractions(2) = {:f} !! Current Fractions (Half component) \\n \" . format ( inputs [ 'current_fractions' ][ 1 ])) f . write ( \"current_fractions(3) = {:f} !! Current Fractions (Third component) \\n\\n \" . format ( inputs [ 'current_fractions' ][ 2 ])) f . write ( \"!! Plasma Settings \\n \" ) f . write ( \"ai = {:f} !! Ion Species mass [amu] \\n \" . format ( inputs [ 'ai' ])) f . write ( \"impurity_charge = {:d} !! Impurity Charge \\n\\n \" . format ( inputs [ 'impurity_charge' ])) f . write ( \"!! Beam Grid Settings \\n \" ) f . write ( \"nx = {:d} !! Number of cells in X direction (Into Plasma) \\n \" . format ( inputs [ 'nx' ])) f . write ( \"ny = {:d} !! Number of cells in Y direction \\n \" . format ( inputs [ 'ny' ])) f . write ( \"nz = {:d} !! Number of cells in Z direction \\n \" . format ( inputs [ 'nz' ])) f . write ( \"xmin = {:f} !! Minimum X value [cm] \\n \" . format ( inputs [ 'xmin' ])) f . write ( \"xmax = {:f} !! Maximum X value [cm] \\n \" . format ( inputs [ 'xmax' ])) f . write ( \"ymin = {:f} !! Minimum Y value [cm] \\n \" . format ( inputs [ 'ymin' ])) f . write ( \"ymax = {:f} !! Maximum Y value [cm] \\n \" . format ( inputs [ 'ymax' ])) f . write ( \"zmin = {:f} !! Minimum Z value [cm] \\n \" . format ( inputs [ 'zmin' ])) f . write ( \"zmax = {:f} !! Maximum Z value [cm] \\n\\n \" . format ( inputs [ 'zmax' ])) f . write ( \"!! Tait-Bryan Angles for z-y`-x`` rotation \\n \" ) f . write ( \"alpha = {:f} !! Rotation about z-axis [rad] \\n \" . format ( inputs [ 'alpha' ])) f . write ( \"beta  = {:f} !! Rotation about y`-axis [rad] \\n \" . format ( inputs [ 'beta' ])) f . write ( \"gamma = {:f} !! Rotation about x``-axis [rad] \\n\\n \" . format ( inputs [ 'gamma' ])) f . write ( \"!! Beam Grid origin in machine coordinates (cartesian) \\n \" ) f . write ( \"origin(1) = {:f} !! U value [cm] \\n \" . format ( inputs [ 'origin' ][ 0 ])) f . write ( \"origin(2) = {:f} !! V value [cm] \\n \" . format ( inputs [ 'origin' ][ 1 ])) f . write ( \"origin(3) = {:f} !! W value [cm] \\n\\n \" . format ( inputs [ 'origin' ][ 2 ])) f . write ( \"!! Wavelength Grid Settings \\n \" ) f . write ( \"nlambda = {:d} !! Number of Wavelengths \\n \" . format ( inputs [ 'nlambda' ])) f . write ( \"lambdamin = {:f} !! Minimum Wavelength [nm] \\n \" . format ( inputs [ 'lambdamin' ])) f . write ( \"lambdamax = {:f} !! Maximum Wavelength [nm] \\n\\n \" . format ( inputs [ 'lambdamax' ])) f . write ( \"!! Weight Function Settings \\n \" ) f . write ( \"ne_wght = {:d} !! Number of Energies for Weights \\n \" . format ( inputs [ 'ne_wght' ])) f . write ( \"np_wght = {:d} !! Number of Pitches for Weights \\n \" . format ( inputs [ 'np_wght' ])) f . write ( \"nphi_wght = {:d} !! Number of Gyro-angles for Weights \\n \" . format ( inputs [ 'nphi_wght' ])) f . write ( \"emax_wght = {:f} !! Maximum Energy for Weights [keV] \\n \" . format ( inputs [ 'emax_wght' ])) f . write ( \"nlambda_wght = {:d} !! Number of Wavelengths for Weights \\n \" . format ( inputs [ 'nlambda_wght' ])) f . write ( \"lambdamin_wght = {:f} !! Minimum Wavelength for Weights [nm] \\n \" . format ( inputs [ 'lambdamin_wght' ])) f . write ( \"lambdamax_wght = {:f} !! Maximum Wavelength for Weights [nm] \\n\\n \" . format ( inputs [ 'lambdamax_wght' ])) f . write ( \"/ \\n\\n \" ) success ( \"Namelist file created: {} \\n \" . format ( filename )) def write_geometry ( filename , nbi , spec = None , npa = None ): \"\"\" #+#write_geometry #+Write geometry values to a HDF5 file #+*** #+##Input Arguments #+     **filename**: Name of the geometry file #+ #+     **nbi**: NBI geometry structure #+ #+##Keyword Arguments #+     **spec**: Optional, Spectral geometry structure #+ #+     **npa**: Optional, NPA geometry structure #+ #+##Example Usage #+```python #+>>> write_geometry(filename, nbi, spec=spec, npa=npa) #+``` \"\"\" info ( 'Writing geometry file...' ) # Create and open h5 file with h5py . File ( filename , 'w' ) as hf : # File attributes hf . attrs [ 'description' ] = 'Geometric quantities for FIDASIM' # Create nbi group g_nbi = hf . create_group ( 'nbi' ) # nbi att g_nbi . attrs [ 'description' ] = 'Neutral Beam Geometry' g_nbi . attrs [ 'coordinate_system' ] = 'Right-handed cartesian' nbi_description = { 'data_source' : 'Source of the NBI geometry' , 'name' : 'Beam name' , 'src' : 'Position of the center of the beam source grid' , 'axis' : 'Axis of the beam centerline: Centerline(t) = src + axis*t ' , 'focy' : 'Horizonal focal length of the beam' , 'focz' : 'Vertical focal length of the beam' , 'divy' : 'Horizonal divergences of the beam. One for each energy component' , 'divz' : 'Vertical divergences of the beam. One for each energy component' , 'widy' : 'Half width of the beam source grid' , 'widz' : 'Half height of the beam source grid' , 'shape' : 'Shape of the beam source grid: 1=\"rectangular\", 2=\"circular\"' , 'naperture' : 'Number of apertures' , 'ashape' : 'Shape of the aperture(s): 1=\"rectangular\", 2=\"circular\"' , 'awidy' : 'Half width of the aperture(s)' , 'awidz' : 'Half height of the aperture(s)' , 'aoffy' : 'Horizontal (y) offset of the aperture(s) relative to the +x aligned beam centerline' , 'aoffz' : 'Vertical (z) offset of the aperture(s) relative to the +x aligned beam centerline' , 'adist' : 'Distance from the center of the beam source grid to the aperture(s) plane' } nbi_units = { 'src' : 'cm' , 'axis' : 'cm' , 'focy' : 'cm' , 'focz' : 'cm' , 'divy' : 'radians' , 'divz' : 'radians' , 'widy' : 'cm' , 'widz' : 'cm' , 'awidy' : 'cm' , 'awidz' : 'cm' , 'aoffy' : 'cm' , 'aoffz' : 'cm' , 'adist' : 'cm' } write_data ( g_nbi , nbi , desc = nbi_description , units = nbi_units , name = 'nbi' ) if spec is not None : # Create spec group g_spec = hf . create_group ( 'spec' ) # Spectroscopic attributes g_spec . attrs [ 'description' ] = 'FIDA/BES Chord Geometry' g_spec . attrs [ 'coordinate_system' ] = 'Right-handed cartesian' # Define description attributes spec_description = { 'data_source' : 'Source of the chord geometry' , 'nchan' : 'Number of channels' , 'system' : 'Names of the different spectrocopic systems' , 'id' : 'Line of sight ID' , 'lens' : 'Positions of the lenses' , 'axis' : 'Optical axis of the lines of sight: LOS(t) = lens + axis*t ' , 'radius' : 'Line of sight radius at midplane or tangency point' , 'sigma_pi' : 'Ratio of the intensities of the sigma and pi stark lines. Measured quantity' , 'spot_size' : 'Radius of spot size' } spec_units = { 'lens' : 'cm' , 'axis' : 'cm' , 'radius' : 'cm' , 'spot_size' : 'cm' } write_data ( g_spec , spec , desc = spec_description , units = spec_units , name = 'spec' ) if npa is not None : # Create npa group g_npa = hf . create_group ( 'npa' ) # Group attributes g_npa . attrs [ 'description' ] = 'NPA Geometry' g_npa . attrs [ 'coordinate_system' ] = 'Right-handed cartesian' # Dataset attributes npa_description = { 'data_source' : 'Source of the NPA geometry' , 'nchan' : 'Number of channels' , 'system' : 'Names of the different NPA systems' , 'id' : 'Line of sight ID' , 'd_shape' : 'Shape of the detector: 1=\"rectangular\", 2=\"circular\"' , 'd_cent' : 'Center of the detector' , 'd_tedge' : 'Center of the detectors top edge' , 'd_redge' : 'Center of the detectors right edge' , 'a_shape' : 'Shape of the aperture: 1=\"rectangular\", 2=\"circular\"' , 'a_cent' : 'Center of the aperture' , 'a_tedge' : 'Center of the apertures top edge' , 'a_redge' : 'Center of the apertures right edge' , 'radius' : 'Line of sight radius at midplane or tangency point' } npa_units = { 'd_cent' : 'cm' , 'd_tedge' : 'cm' , 'd_redge' : 'cm' , 'a_cent' : 'cm' , 'a_tedge' : 'cm' , 'radius' : 'cm' , 'a_redge' : 'cm' } write_data ( g_npa , npa , desc = npa_description , units = npa_units , name = 'npa' ) if os . path . isfile ( filename ): success ( 'Geometry file created: ' + filename ) else : error ( 'Geometry file creation failed.' ) def write_equilibrium ( filename , plasma , fields ): \"\"\" #+#write_equilibrium #+Write MHD equilibrium values to a HDF5 file #+*** #+##Input Arguments #+     **filename**: Name of the equilibrium file #+ #+     **plasma**: Plasma dictionary #+ #+     **fields**: Electromagnetic fields dictionary #+ #+##Example Usage #+```python #+>>> write_equilibrium(filename, plasma, fields) #+``` \"\"\" info ( 'Writing equilibrium file...' ) with h5py . File ( filename , 'w' ) as hf : # File attribute hf . attrs [ 'description' ] = 'Plasma Parameters and Electromagnetic Fields for FIDASIM' # Create plasma group g_plasma = hf . create_group ( 'plasma' ) # Plasma Attributes g_plasma . attrs [ 'description' ] = 'Plasma Parameters' g_plasma . attrs [ 'coordinate_system' ] = 'Cylindrical' # Dataset attributes plasma_description = { 'data_source' : 'Source of the plasma parameters' , 'time' : 'Time' , 'dene' : 'Electron Number Density: Dene(r,z)' , 'te' : 'Electron Temperature: Te(r,z)' , 'ti' : 'Ion Temperature: Ti(r,z)' , 'zeff' : 'Effective Nuclear Charge: Zeff(r,z)' , 'denn' : 'Cold/Edge neutral density: Denn(r,z)' , 'vr' : 'Bulk plasma flow in the r-direction: Vr(r,z)' , 'vt' : 'Bulk plasma flow in the theta/torodial-direction: Vt(r,z)' , 'vz' : 'Bulk plasma flow in the z-direction: Vz(r,z)' , 'nr' : 'Number of R values' , 'nz' : 'Number of Z values' , 'r' : 'Radius' , 'z' : 'Z' , 'r2d' : 'Radius grid: R(r,z)' , 'z2d' : 'Z grid: Z(r,z)' , 'mask' : 'Boolean mask that indicates where the plasma parameters are well defined' } plasma_units = { 'time' : 's' , 'dene' : 'cm&#94;-3' , 'denn' : 'cm&#94;-3' , 'te' : 'keV' , 'ti' : 'keV' , 'vr' : 'cm/s' , 'vt' : 'cm/s' , 'vz' : 'cm/s' , 'r' : 'cm' , 'z' : 'cm' , 'r2d' : 'cm' , 'z2d' : 'cm' } write_data ( g_plasma , plasma , desc = plasma_description , units = plasma_units , name = 'plasma' ) # Create fields group g_fields = hf . create_group ( 'fields' ) # Electromagnetic fields attributes g_fields . attrs [ 'description' ] = 'Electromagnetic Fields' g_fields . attrs [ 'coordinate_system' ] = 'Cylindrical' fields_description = { 'data_source' : 'Source of the EM equilibrium' , 'mask' : 'Boolean mask that indicates where the fields are well defined' , 'time' : 'Time' , 'br' : 'Magnetic field in the r-direction: Br(r,z)' , 'bt' : 'Magnetic field in the theta/torodial-direction: Bt(r,z)' , 'bz' : 'Magnetic field in the z-direction: Bz(r,z)' , 'er' : 'Electric field in the r-direction: Er(r,z)' , 'et' : 'Electric field in the theta/torodial-direction: Et(r,z)' , 'ez' : 'Electric field in the z-direction: Ez(r,z)' , 'nr' : 'Number of R values' , 'nz' : 'Number of Z values' , 'r' : 'Radius' , 'z' : 'Z' , 'r2d' : 'Radius grid: R(r,z)' , 'z2d' : 'Z grid: Z(r,z)' } fields_units = { 'time' : 's' , 'br' : 'T' , 'bt' : 'T' , 'bz' : 'T' , 'er' : 'V/m' , 'et' : 'V/m' , 'ez' : 'V/m' , 'nr' : 'V/m' , 'nz' : 'V/m' , 'r' : 'cm' , 'z' : 'cm' , 'r2d' : 'cm' , 'z2d' : 'cm' } write_data ( g_fields , fields , desc = fields_description , units = fields_units , name = 'fields' ) if os . path . isfile ( filename ): success ( 'Equilibrium file created: ' + filename ) else : error ( 'Equilibrium file creation failed.' ) def write_distribution ( filename , distri ): \"\"\" #+#write_distribution #+Write fast-ion distribution to a HDF5 file #+*** #+##Input Arguments #+     **filename**: Name of the distribution file #+ #+     **dist**: Fast-ion distribution distionary #+ #+##Example Usage #+```dist #+>>> write_distribution(filename, distri) #+``` \"\"\" info ( 'Writing fast-ion distribution file...' ) description = { 'data_source' : 'Source of the fast-ion distribution' , 'type' : 'Distribution type: 1=\"Guiding Center Density Function\", 2=\"Guiding Center ' \\ 'Monte Carlo\", 3=\"Full Orbit Monte Carlo\"' , 'time' : 'Distribution time' } units = { 'time' : 's' } if distri [ 'type' ] == 1 : description [ 'nenergy' ] = 'Number of energy values' description [ 'npitch' ] = 'Number of pitch values' description [ 'energy' ] = 'Energy' description [ 'pitch' ] = 'Pitch: p = v_parallel/v  w.r.t. the magnetic field' description [ 'f' ] = 'Fast-ion density function: F(E,p,R,Z)' description [ 'denf' ] = 'Fast-ion density: Denf(r,z)' description [ 'nr' ] = 'Number of R values' description [ 'nz' ] = 'Number of Z values' description [ 'r' ] = 'Radius' description [ 'z' ] = 'Z' description [ 'r2d' ] = 'Radius grid: R(r,z)' description [ 'z2d' ] = 'Z grid: Z(r,z)' units [ 'energy' ] = 'keV' units [ 'f' ] = 'fast-ions/(dE*dP*cm&#94;3)' units [ 'denf' ] = 'cm&#94;-3' units [ 'r' ] = 'cm' units [ 'z' ] = 'cm' units [ 'r2d' ] = 'cm' units [ 'z2d' ] = 'cm' else : description [ 'nparticle' ] = 'Number of MC particles' description [ 'nclass' ] = 'Number of orbit classes' description [ 'r' ] = 'R position of a MC particle' description [ 'z' ] = 'Z position of a MC particle' description [ 'weight' ] = 'Weight of a MC particle: sum(weight) = # of fast-ions ' description [ 'class' ] = 'Orbit class of a MC particle: class in Set(1:nclass)' units [ 'r' ] = 'cm' units [ 'z' ] = 'cm' units [ 'weight' ] = 'fast-ions/particle' if distri [ 'type' ] == 2 : description [ 'energy' ] = 'Energy of a MC particle' description [ 'pitch' ] = 'Pitch of a MC particle: p = v_parallel/v  w.r.t. the magnetic field' else : description [ 'vr' ] = 'Radial velocity of a MC particle' description [ 'vt' ] = 'Torodial velocity of a MC particle' description [ 'vz' ] = 'Z velocity of a MC particle' units [ 'vr' ] = 'cm/s' units [ 'vt' ] = 'cm/s' units [ 'vz' ] = 'cm/s' with h5py . File ( filename , 'w' ) as hf : # File attr hf . attrs [ 'description' ] = 'Fast-ion distribution for FIDASIM' hf . attrs [ 'coordinate_system' ] = 'Cylindrical' write_data ( hf , distri , desc = description , units = units , name = 'distribution' ) if os . path . isfile ( filename ): success ( 'Distribution file created: ' + filename ) else : error ( 'Distribution file creation failed.' ) def prefida ( inputs , grid , nbi , plasma , fields , fbm , spec = None , npa = None ): \"\"\" #+#prefida #+Checks FIDASIM inputs and writes FIDASIM input files #+*** #+##Input Arguments #+     **inputs**: Inputs structure #+ #+     **grid**: Interpolation grid structure #+ #+     **nbi**: Neutral beam geometry structure #+ #+     **plasma**: Plasma parameters structure #+ #+     **fields**: Electromagnetic fields structure #+ #+     **fbm**: Fast-ion distribution structure #+ #+##Keyword Arguments #+     **spec**: Optional, Spectral geometry structure #+ #+     **npa**: Optional, NPA geometry structure #+ #+##Example Usage #+```python #+>>> prefida(inputs, grid, nbi, plasma, fields, fbm, spec=spec, npa=npa) #+``` \"\"\" # CHECK INPUTS inputs = check_inputs ( inputs ) # MAKE DIRECTORIES IF THEY DONT EXIST if not os . path . isdir ( inputs [ 'result_dir' ]): os . makedirs ( inputs [ 'result_dir' ]) # CHECK INTERPOLATION GRID check_grid ( grid ) # CHECK BEAM INPUTS nbi = check_beam ( inputs , nbi ) # CHECK PLASMA PARAMETERS plasma = check_plasma ( inputs , grid , plasma ) # CHECK ELECTROMAGNETIC FIELDS fields = check_fields ( inputs , grid , fields ) # CHECK FAST-ION DISTRIBUTION fbm = check_distribution ( inputs , grid , fbm ) # CHECK FIDA/BES if spec is not None : check_spec ( inputs , spec ) # CHECK NPA if npa is not None : check_npa ( inputs , npa ) # WRITE FIDASIM INPUT FILES write_namelist ( inputs [ 'input_file' ], inputs ) # WRITE GEOMETRY FILE write_geometry ( inputs [ 'geometry_file' ], nbi , spec = spec , npa = npa ) # WRITE EQUILIBRIUM FILE write_equilibrium ( inputs [ 'equilibrium_file' ], plasma , fields ) # WRITE DISTRIBUTION FILE write_distribution ( inputs [ 'distribution_file' ], fbm ) print ( '' ) print ( '' ) success ( 'FIDASIM pre-processing completed' ) print ( 'To run FIDASIM use the following command' ) print ( get_fidasim_dir () + os . sep + 'fidasim ' + inputs [ 'result_dir' ] + os . sep + inputs [ 'runid' ] + '_inputs.dat' ) print ( '' ) print ( '' )","tags":"","loc":"sourcefile/preprocessing.py.html","title":"preprocessing.py – FIDASIM"},{"text":"FIDASIM Utilities This file contains useful FIDASIM utilities get_fidasim_dir Gets FIDASIM install directory Output Arguments directory : FIDASIM install directory. Example Usage >>> fida_dir = get_fidasim_dir () get_version Gets FIDASIM version number from git.\nFalls back to reading VERSION file when git is not available Input Arguments fidasim_dir : FIDASIM install directory Output Arguments version : FIDAIM version number. Example Usage >>> version = get_version ( get_fidasim_dir ()) aabb_intersect Calculates intersection length of a ray and an axis aligned bounding box (AABB) Input Arguments rc : Center of AABB dr : [length, width, height] of AABB r0 : starting point of ray d0 : direction of ray Output Arguments intersect : Intersection length of ray and AABB ri : Optional, ray enterence point rf : Optional, ray exit point Example Usage >>> intersect , r_enter , r_exit = aabb_intersect ([ 0 , 0 , 0 ], [ 1 , 1 , 1 ], [ - 1 , 0 , 0 ], [ 1 , 0 , 0 ]) >>> print ( intersect ) 1.0 >>> print ( r_enter ) - 0.5 0.0 0.0 >>> print ( r_exit ) 0.5 0.0 0.0 tb_zyx Calculates Tait-Bryan z-y'-x\" active rotation matrix given rotation angles alpha , beta , gamma in radians Arguments alpha : rotation angle about z [radians] beta : rotation angle about y' [radians] gamma : rotation angle about x\" [radians] Return Value Rotation Matrix prefida Example Usage >>> rot_mat = tb_zyx ( np . pi / 2 , 0.0 , np . pi / 3 ) uvw_to_xyz Express non-rotated coordinate uvw in rotated xyz coordinates Arguments alpha : Rotation angle about z [radians] beta : Rotation angle about y' [radians] gamma : Rotation angle about x\" [radians] uvw : Point in rotated coordinate system, (3, n) Keyword Arguments origin : Origin of rotated coordinate system in non-rotated (uvw) coordinates, (3) Output Arguments xyz : 'uvw' in 'xyz' coordinates Example Usage >>> xyz = uvw_to_xyz ( np . pi / 2. , 0.0 , np . pi / 3. , uvw , origin = [ . 1 , . 2 , 0. ]) xyz_to_uvw(alpha, beta, gamma, xyz, origin=[0,0,0]) Express rotated coordinate xyz in non-rotated uvw coordinates Arguments alpha : Rotation angle about z [radians] beta : Rotation angle about y' [radians] gamma : Rotation angle about x\" [radians] xyz : Point in rotated coordinate system Keyword Arguments origin : Origin of rotated coordinate system in non-rotated (uvw) coordinates. Example Usage >>> uvw = xyz_to_uvw ( np . pi / 2 , 0.0 , np . pi / 3 , xyz ) line_basis Calculates basis from a line with +x in the direction of line Arguments r0 : Starting point of line [cm] v0 : Direction of line Example Usage >>> basis = line_basis ([ 0 , 0 , 0 ],[ 0 , - 1 , 0 ]) >>> x = np . dot ( basis , np . array ([ 1 , 1 , 0 ])) ; Transforms a point in line - space ([ 1 , 1 , 0 ]) to real space >>> x [ 1 , - 1 , 0 ] rz_grid Creates interpolation grid Arguments rmin : Minimum radius [cm] rmax : Maximum radius [cm] nr : Number of radii zmin : Minimum Z value [cm] zmax : Maximum Z value [cm] nz : Number of Z values phimin : Minimum Phi value [rad] phimax : Maximum Phi value [rad] nphi : Number of Phi values Return Value Interpolation grid dictionary Example Usage >>> grid = rz_grid ( 0 , 200.0 , 200 , - 100 , 100 , 200 , phimin = 4 * np . pi / 3 , phimax = 5 * np . pi / 3 , nphi = 5 ) colored Return text string formatting for color in terminal Input Arguments text : String to be colored color : Desired color of string. Red, green, yellow, blue, magenta, cyan, or white. Output Arguments text : Text formated to have \"color\" in terminal. Example Usage >>> text = colored ( \"Text to be red\" , 'red' ) >>> print ( text ) info Print a informational message Arguments str : message Example Usage >>> info ( \"This is an informative message\" ) warn Print a warning message Arguments string : message Example Usage >>> warn ( \"This may be a problem\" ) error Print a error message Arguments string : message Keyword Arguments halt : Halt program execution Example Usage >>> error ( \"Error message\" ) success Print a success message Arguments string : message Example Usage >>> success ( \"Yay!!!\" ) beam_grid Calculates settings for a grid that aligns with the neutral beam. Arguments nbi : Neutral beam geometry structure rstart : Radial start position of beam grid [cm] Keyword Arguments dV : Cell volume [ cm&#94;3 ]: Defaults to 8.0 nx : Number of cells in length: Default determined by dV ny : Number of cells in width: Default determined by dV nz : Number of cells in height: Default determined by dV length : Length of grid along beam sightline. [cm]: Defaults to 100 cm width : Width of grid [cm]: Defaults to 100 cm height : Height of grid [cm]: Defaults 80 cm Return Value Structure containing beam grid settings suitable for the Namelist File Example Usage >>> grid = beam_grid ( nbi , 200.0 , nx = 100 , ny = 50 , nz = 50 , length = 100 , width = 50 , height = 50 ) write_data Write h5 datasets with attributes 'description' and 'units' Arguments h5_obj : An h5 file or group object from h5py dic : Dict of data to save as h5 datasets Keyword Arguments name : Name/description of dic for clarity in raising errors desc : Dict with same keys as dic describing each item in dic units : Dict with same keys as dic providing units of data in dic, doesn't have to be all keys of dic. Example Usage >>> write_data ( h5_obj , dic , desc , units ) read_geqdsk Reads an EFIT GEQDSK file Arguments filename : GEQDSK file grid : Interpolation grid Keyword Arguments poloidal : Return rho_p (sqrt(normalized poloidal flux)) instead of rho (sqrt(normalized toroidal flux)) Return Value Electronmagnetic fields structure, rho, btipsign Example Usage >>> fields , rho , btipsign = read_geqdsk ( \"./g133223.00200\" , grid ) read_ncdf Reads a flat NetCDF file Arguments filename : NetCDF file Keyword Arguments vars : List of variables to read Return Value Structure containing NetCDF variables Example Usage >>> a = read_ncdf ( \"./123324H01_fi_1.cdf\" ) extract_transp_plasma Extracts plasma structure from a TRANSP run Arguments filename : TRANSP output file e.g. [TRANSP_RUNID].CDF intime : Time of interest [s] grid : Interpolation grid rhogrid : sqrt(normalized torodial flux) mapped onto the interpolation grid Keyword Arguments dn0out : Wall Neutral density value dn0out variable in transp namelist scrapeoff : scrapeoff decay length rho_scrapeoff : scrapeoff length, default = 0.1 Example Usage >>> plasma = extract_transp_plasma ( \"./142332H01.CDF\" , 1.2 , grid , rho ) read_nubeam Reads NUBEAM fast-ion distribution function Arguments filename : NUBEAM guiding center fast-ion distribution function file e.g. 159245H01_fi_1.cdf grid : Interpolation grid Keyword Arguments btipsign : Sign of the dot product of the magnetic field and plasma current e_range : Energy range to consider p_range : Pitch range to consider species : Fast-ion species number. Defaults to 1 Return Value Distribution structure Example Usage >>> dist = read_nubeam ( \"./159245H02_fi_1.cdf\" , grid , btipsign =- 1 ) nubeam_geometry Calculates the FIDASIM beam geometry from the beam geometry variables in the TRANSP/NUBEAM namelist Arguments NUBEAM : Dictionary containing the following NUBEAM[\"NAME\"] : Ion source name NUBEAM[\"NBSHAP\"] : Ion source shape 1=rectangular, 2=circular NUBEAM[\"FOCLZ\"] : Vertical focal length [cm] NUBEAM[\"FOCLR\"] : Horizontal focal length [cm] NUBEAM[\"DIVZ\"] : Vertical divergence [rad] NUBEAM[\"DIVR\"] : Horizontal divergence [rad] NUBEAM[\"BMWIDZ\"] : Ion source half height [cm] NUBEAM[\"BMWIDR\"] : Ion source half width [cm] NUBEAM[\"RTCENA\"] : Radius of tangency point [cm] NUBEAM[\"XLBTNA\"] : Distance from center of beam source grid to tangency point [cm] NUBEAM[\"XBZETA\"] : Torodial angle [deg] Positive angles defined to be in the counter-clockwise direction NUBEAM[\"XYBSCA\"] : Elevation above/below vacuum vessel midplane of center of beam source grid [cm] NUBEAM[\"NLJCCW\"] : Orientation of Ip. 1 for True/Counter-clockwise current, 0 or -1 for False/Clock-wise current NUBEAM[\"NLCO\"] : 1 for Co-beam, 0 or -1 for Counter-beam NUBEAM[\"NBAPSHA\"] : Vector of aperture shapes 1=rectangular, 2=circular NUBEAM[\"XLBAPA\"] : Vector of distances from center of beam source grid to the aperture plane [cm] NUBEAM[\"XYBAPA\"] : Vector of elevation above/below vacuum vessel midplane of beam centerline at aperture [cm] NUBEAM[\"RAPEDGA\"] : Vector of aperture half-widths [cm] NUBEAM[\"XZPEDGA\"] : Vector of aperture half-heights [cm] NUBEAM[\"XRAPOFFA\"] : Vector of horizontal (y) offsets relative to the +x aligned beam centerline [cm] NUBEAM[\"XZAPOFFA\"] : Vector of vertical (z) offsets relative to the +x aligned beam centerline [cm] Keyword Arguments angle : Angle to add to XBZETA to rotate the beams into correct coordinates [deg] verbose : Print out positions Return Value Neutral beam structure Example Usage >>> nbi = nubeam_geometry ( nubeam ) Contents Source Code utils.py Source Code #!/usr/bin/env python # -*- coding: utf-8 -*- #+#FIDASIM Utilities #+This file contains useful FIDASIM utilities #+*** from __future__ import print_function import os from os.path import dirname import subprocess import platform import numpy as np import copy import h5py import efit from scipy.io import netcdf from scipy.interpolate import interp1d , interp2d , NearestNDInterpolator from scipy.spatial import Delaunay import matplotlib.pyplot as plt def get_fidasim_dir (): \"\"\" #+#get_fidasim_dir #+ Gets FIDASIM install directory #+*** #+##Output Arguments #+     **directory**: FIDASIM install directory. #+##Example Usage #+```python #+>>> fida_dir = get_fidasim_dir() #+``` \"\"\" directory = dirname ( dirname ( dirname ( dirname ( os . path . abspath ( __file__ ))))) return directory def get_version ( fidasim_dir ): \"\"\" #+#get_version #+ Gets FIDASIM version number from git. #+ Falls back to reading VERSION file when git is not available #+*** #+##Input Arguments #+    **fidasim_dir**: FIDASIM install directory #+ #+##Output Arguments #+     **version**: FIDAIM version number. #+ #+##Example Usage #+```python #+>>> version = get_version(get_fidasim_dir()) #+``` \"\"\" version = '' alt = False if platform . system () == 'Windows' : alt = True else : # Location of .git folder git_dir = r ' {}{} .git' . format ( fidasim_dir , os . path . sep ) # git is installed if git_file is a file proc = subprocess . Popen ( 'command -v git' , stdout = subprocess . PIPE , stderr = subprocess . PIPE , shell = True ) git_file = proc . communicate ()[ 0 ] . decode ( 'utf-8' ) git_file = git_file . replace ( ' \\n ' , '' ) # Check that .git folder is present and git is installed if os . path . isfile ( git_file ) and os . path . isdir ( git_dir ): try : version = subprocess . check_output ([ 'git' , '--git-dir= {} ' . format ( git_dir ), 'describe' , '--tags' , '--always' , '--dirty' ]) version = version . replace ( ' \\n ' , '' ) except : alt = True else : alt = True # If above didn't work, read version file if alt : # Git 'version' filepath ver_file = ' {}{} VERSION' . format ( fidasim_dir , os . path . sep ) if os . path . isfile ( ver_file ): with open ( ver_file ) as f : version = f . read () return version def aabb_intersect ( rc , dr , r0 , d0 ): \"\"\" #+#aabb_intersect #+Calculates intersection length of a ray and an axis aligned bounding box (AABB) #+*** #+##Input Arguments #+     **rc**: Center of AABB #+ #+     **dr**: [length, width, height] of AABB #+ #+     **r0**: starting point of ray #+ #+     **d0**: direction of ray #+ #+##Output Arguments #+     **intersect**: Intersection length of ray and AABB #+ #+     **ri**: Optional, ray enterence point #+ #+     **rf**: Optional, ray exit point #+ #+##Example Usage #+```python #+>>> intersect, r_enter, r_exit = aabb_intersect([0,0,0], [1,1,1], [-1,0,0], [1,0,0]) #+>>> print(intersect) #+    1.0 #+>>> print(r_enter) #+    -0.5  0.0  0.0 #+>>> print(r_exit) #+     0.5  0.0  0.0 #+``` \"\"\" v0 = d0 / np . sqrt ( np . sum ( d0 ** 2. )) # There are 6 sides to a cube/grid side_inter = np . zeros ( 6 ) # Intersection points of ray with planes defined by grid ipnts = np . zeros (( 3 , 6 )) # Find whether ray intersects each side for i in range ( 6 ): j = int ( np . floor ( i / 2 )) ind = np . arange ( 3 , dtype = int ) ind = ind [ ind != j ] if np . abs ( v0 [ j ]) > 0. : # just v0[j] != 0 right? # Intersection point with plane ipnts [:, i ] = r0 + v0 * ((( rc [ j ] + ( np . mod ( i , 2 ) - 0.5 ) * dr [ j ]) - r0 [ j ]) / v0 [ j ]) # Check if point on plane is within grid side if ( np . abs ( ipnts [ ind [ 0 ], i ] - rc [ ind [ 0 ]]) <= 0.5 * dr [ ind [ 0 ]]) and \\ ( np . abs ( ipnts [ ind [ 1 ], i ] - rc [ ind [ 1 ]]) <= 0.5 * dr [ ind [ 1 ]]): side_inter [ i ] = 1 intersect = 0.0 r_enter = copy . deepcopy ( r0 ) r_exit = copy . deepcopy ( r0 ) ind = np . arange ( side_inter . size ) ind = ind [ side_inter != 0 ] nw = side_inter [ ind ] . size if nw >= 2 : #Find two unique intersection points nunique = 0 for i in range ( nw - 1 ): if np . sum ( ipnts [:, ind [ 0 ]] == ipnts [:, ind [ i + 1 ]]) != 3 : ind = [ ind [ 0 ], ind [ i + 1 ]] nunique = 2 break if nunique == 2 : vi = ipnts [:, ind [ 1 ]] - ipnts [:, ind [ 0 ]] vi = vi / np . sqrt ( np . sum ( vi ** 2. )) dot_prod = np . sum ( v0 * vi ) if dot_prod > 0.0 : r_enter = ipnts [:, ind [ 0 ]] r_exit = ipnts [:, ind [ 1 ]] else : r_enter = ipnts [:, ind [ 1 ]] r_exit = ipnts [:, ind [ 0 ]] # Calculate intersection length intersect = np . sqrt ( np . sum (( r_exit - r_enter ) ** 2. )) return intersect , r_enter , r_exit def tb_zyx ( alpha , beta , gamma ): \"\"\" #+#tb_zyx #+Calculates Tait-Bryan z-y'-x\" active rotation matrix given rotation angles `alpha`,`beta`,`gamma` in radians #+*** #+##Arguments #+     **alpha**: rotation angle about z [radians] #+ #+     **beta**: rotation angle about y' [radians] #+ #+     **gamma**: rotation angle about x\" [radians] #+ #+##Return Value #+     Rotation Matrix [prefida](|url|/sourcefile/prefida.pro.html) #+ #+##Example Usage #+```python #+ >>> rot_mat = tb_zyx(np.pi/2, 0.0, np.pi/3) #+``` \"\"\" sa = np . sin ( alpha ) ca = np . cos ( alpha ) sb = np . sin ( beta ) cb = np . cos ( beta ) sg = np . sin ( gamma ) cg = np . cos ( gamma ) r = np . zeros (( 3 , 3 )) r [ 0 , 0 ] = ca * cb r [ 0 , 1 ] = ca * sb * sg - cg * sa r [ 0 , 2 ] = sa * sg + ca * cg * sb r [ 1 , 0 ] = cb * sa r [ 1 , 1 ] = ca * cg + sa * sb * sg r [ 1 , 2 ] = cg * sa * sb - ca * sg r [ 2 , 0 ] = - sb r [ 2 , 1 ] = cb * sg r [ 2 , 2 ] = cb * cg return r def uvw_to_xyz ( alpha , beta , gamma , uvw , origin = np . zeros ( 3 )): \"\"\" #+#uvw_to_xyz #+ Express non-rotated coordinate `uvw` in rotated `xyz` coordinates #+*** #+##Arguments #+     **alpha**: Rotation angle about z [radians] #+ #+     **beta**: Rotation angle about y' [radians] #+ #+     **gamma**: Rotation angle about x\" [radians] #+ #+     **uvw**: Point in rotated coordinate system, (3, n) #+ #+##Keyword Arguments #+     **origin**: Origin of rotated coordinate system in non-rotated (uvw) coordinates, (3) #+ #+##Output Arguments #+     **xyz**: 'uvw' in 'xyz' coordinates #+ #+##Example Usage #+```python #+>>> xyz = uvw_to_xyz(np.pi/2., 0.0, np.pi/3., uvw, origin=[.1, .2, 0.]) #+``` \"\"\" # Make np arrays uvw = np . array ( uvw , dtype = float ) origin = np . array ( origin , dtype = float ) # Do checks as this code does not allow multiple points to be entered (yet) if uvw . ndim == 2 : s = uvw . shape if s [ 0 ] != 3 : raise ValueError ( 'uvw must be (3, n), but it has shape {} ' . format ( uvw . shape )) n = s [ 1 ] elif uvw . ndim == 1 : if uvw . size != 3 : raise ValueError ( 'uvw must have length 3, but it has length {} ' . format ( uvw . size )) n = 1 else : raise ValueError ( 'uvw must be (3) or (3, n)' ) if origin . ndim != 1 : raise ValueError ( 'origin must be 1D, but it has shape {} ' . format ( origin . shape )) if origin . size != 3 : raise ValueError ( 'origin must have length 3, but it has length {} ' . format ( origin . size )) # Shift origin uvw_shifted = uvw - np . squeeze ( np . tile ( origin , ( n , 1 )) . T ) # Get rotation matrix r = tb_zyx ( alpha , beta , gamma ) # Apply rotation matrix xyz = np . dot ( r . T , uvw_shifted ) return xyz def xyz_to_uvw ( alpha , beta , gamma , xyz , origin = np . zeros ( 3 )): \"\"\" #+##`xyz_to_uvw(alpha, beta, gamma, xyz, origin=[0,0,0])` #+Express rotated coordinate `xyz` in non-rotated `uvw` coordinates #+###Arguments #+     **alpha**: Rotation angle about z [radians] #+ #+     **beta**: Rotation angle about y' [radians] #+ #+     **gamma**: Rotation angle about x\" [radians] #+ #+     **xyz**: Point in rotated coordinate system #+ #+###Keyword Arguments #+     **origin**: Origin of rotated coordinate system in non-rotated (uvw) coordinates. #+ #+###Example Usage #+```python #+>>> uvw = xyz_to_uvw(np.pi/2,0.0,np.pi/3,xyz) #+``` \"\"\" xyz = np . array ( xyz ) # Do checks as this code does not allow multiple points to be entered (yet) if xyz . ndim == 2 : s = xyz . shape if s [ 0 ] != 3 : raise ValueError ( 'xyz must be (3, n), but it has shape {} ' . format ( uvw . shape )) n = s [ 1 ] elif xyz . ndim == 1 : if xyz . size != 3 : raise ValueError ( 'xyz must have length 3, but it has length {} ' . format ( uvw . size )) n = 1 else : raise ValueError ( 'xyz must be (3) or (3, n)' ) if origin . ndim != 1 : raise ValueError ( 'origin must be 1D, but it has shape {} ' . format ( origin . shape )) if origin . size != 3 : raise ValueError ( 'origin must have length 3, but it has length {} ' . format ( origin . size )) R = tb_zyx ( alpha , beta , gamma ) uvw = np . dot ( R , xyz ) return uvw + np . squeeze ( np . tile ( origin , ( n , 1 )) . T ) def line_basis ( r0 , v0 ): \"\"\" #+#line_basis #+Calculates basis from a line with +x in the direction of line #+*** #+##Arguments #+    **r0**: Starting point of line [cm] #+ #+    **v0**: Direction of line #+ #+##Example Usage #+```python #+>>> basis = line_basis([0,0,0],[0,-1,0]) #+>>> x = np.dot(basis,np.array([1,1,0])) ;Transforms a point in line-space ([1,1,0]) to real space #+>>> x #+    [1, -1, 0] #+``` \"\"\" r0 = np . array ( r0 ) v0 = np . array ( v0 ) rf = r0 + v0 dis = np . sqrt ( np . sum ( v0 ** 2 )) beta = np . arcsin (( r0 [ 2 ] - rf [ 2 ]) / dis ) alpha = np . arctan2 (( rf [ 1 ] - r0 [ 1 ]),( rf [ 0 ] - r0 [ 0 ])) R = tb_zyx ( alpha , beta , 0.0 ) return R def rz_grid ( rmin , rmax , nr , zmin , zmax , nz , phimin = 0.0 , phimax = 0.0 , nphi = 1 ): \"\"\" #+#rz_grid #+Creates interpolation grid #+*** #+##Arguments #+    **rmin**: Minimum radius [cm] #+ #+    **rmax**: Maximum radius [cm] #+ #+    **nr**: Number of radii #+ #+    **zmin**: Minimum Z value [cm] #+ #+    **zmax**: Maximum Z value [cm] #+ #+    **nz**: Number of Z values #+ #+    **phimin**: Minimum Phi value [rad] #+ #+    **phimax**: Maximum Phi value [rad] #+ #+    **nphi**: Number of Phi values #+ #+##Return Value #+Interpolation grid dictionary #+ #+##Example Usage #+```python #+>>> grid = rz_grid(0,200.0,200,-100,100,200,phimin=4*np.pi/3,phimax=5*np.pi/3,nphi=5) #+``` \"\"\" dr = ( rmax - rmin ) / nr dz = ( zmax - zmin ) / nz dphi = ( phimax - phimin ) / nphi r = rmin + dr * np . arange ( nr , dtype = np . float64 ) z = zmin + dz * np . arange ( nz , dtype = np . float64 ) phi = phimin + dphi * np . arange ( nphi , dtype = np . float64 ) r2d = np . tile ( r , ( nz , 1 )) . T z2d = np . tile ( z , ( nr , 1 )) grid = { 'r2d' : r2d , 'z2d' : z2d , 'r' : r , 'z' : z , 'phi' : phi , 'nr' : nr , 'nz' : nz , 'nphi' : nphi } return grid def colored ( text , color ): #, on_color=None, attrs=None): \"\"\" #+#colored #+ Return text string formatting for color in terminal #+*** #+##Input Arguments #+     **text**: String to be colored #+ #+     **color**: Desired color of string. Red, green, yellow, blue, magenta, cyan, or white. #+ #+##Output Arguments #+     **text**: Text formated to have \"color\" in terminal. #+##Example Usage #+```python #+>>> text = colored(\"Text to be red\", 'red') #+>>> print(text) #+``` \"\"\" # Copyright (c) 2008-2011 Volvox Development Team # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # Author: Konstantin Lepa <konstantin.lepa@gmail.com> COLORS = dict ( list ( zip ([ 'grey' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' ,], list ( range ( 30 , 38 ))))) RESET = ' \\033 [0m' if os . getenv ( 'ANSI_COLORS_DISABLED' ) is None : fmt_str = ' \\033 [ %d m %s ' text = fmt_str % ( COLORS [ color ], text ) text += RESET return text def info ( string ): \"\"\" #+#info #+Print a informational message #+*** #+##Arguments #+     **str**: message #+ #+##Example Usage #+```python #+>>> info(\"This is an informative message\") #+``` \"\"\" print ( colored ( 'INFO: ' + string , 'cyan' )) def warn ( string ): \"\"\" #+#warn #+Print a warning message #+*** #+##Arguments #+     **string**: message #+ #+##Example Usage #+```python #+>>> warn(\"This may be a problem\") #+``` \"\"\" print ( colored ( 'WARNING: ' + string , 'magenta' )) def error ( string , halt = False ): \"\"\" #+#error #+Print a error message #+*** #+##Arguments #+     **string**: message #+ #+##Keyword Arguments #+     **halt**: Halt program execution #+ #+##Example Usage #+```python #+>>> error(\"Error message\") #+``` \"\"\" print ( colored ( 'ERROR: {} ' . format ( string ), 'red' )) if halt : raise Exception () def success ( string ): \"\"\" #+#success #+Print a success message #+*** #+##Arguments #+     **string**: message #+ #+##Example Usage #+```python #+>>> success(\"Yay!!!\") #+``` \"\"\" print ( colored ( 'SUCCESS: ' + string , 'green' )) def beam_grid ( nbi , rstart , nx = None , ny = None , nz = None , dv = 8.0 , length = 100.0 , width = 80.0 , height = 80.0 ): \"\"\" #+#beam_grid #+ Calculates settings for a grid that aligns with the neutral beam. #+*** #+##Arguments #+    **nbi**: [Neutral beam geometry structure](|url|/page/03_technical/01_prefida_inputs.html#neutral-beam-geometry-structure) #+ #+    **rstart**: Radial start position of beam grid [cm] #+ #+##Keyword Arguments #+    **dV**: Cell volume [cm&#94;3]: Defaults to 8.0 #+ #+    **nx**: Number of cells in length: Default determined by `dV` #+ #+    **ny**: Number of cells in width: Default determined by `dV` #+ #+    **nz**: Number of cells in height: Default determined by `dV` #+ #+    **length**: Length of grid along beam sightline. [cm]: Defaults to 100 cm #+ #+    **width**: Width of grid [cm]: Defaults to 100 cm #+ #+    **height**: Height of grid [cm]: Defaults 80 cm #+ #+##Return Value #+    Structure containing beam grid settings suitable for the Namelist File #+ #+##Example Usage #+```python #+>>> grid = beam_grid(nbi,200.0,nx=100,ny=50,nz=50,length=100,width=50,height=50) #+``` \"\"\" if width < nbi [ 'widy' ]: warn ( \"Grid width is smaller then the source width\" ) print ( \"width: {} \" . format ( width )) print ( \"source width: {} \" . format ( nbi [ 'widy' ])) if height < nbi [ 'widz' ]: warn ( \"Grid height is smaller then the source height\" ) print ( \"height: {} \" . format ( height )) print ( \"source height: {} \" . format ( nbi [ 'widz' ])) dv3 = dv ** ( 1. / 3. ) if nx is None : nx = round ( length / dv3 ) if ny is None : ny = round ( width / dv3 ) if nz is None : nz = round ( height / dv3 ) xmin = 0. xmax = length ymin = - width / 2. ymax = width / 2. zmin = - height / 2. zmax = height / 2. src = nbi [ 'src' ] axis = nbi [ 'axis' ] / np . sqrt ( np . sum ( nbi [ 'axis' ] ** 2 )) pos = src + 100. * axis if np . sqrt ( src [ 0 ] ** 2 + src [ 1 ] ** 2 ) < rstart : error ( \"Source radius cannot be less then rstart\" , halt = True ) dis = np . sqrt ( np . sum (( src - pos ) ** 2.0 )) beta = np . arcsin (( src [ 2 ] - pos [ 2 ]) / dis ) alpha = np . arctan2 (( pos [ 1 ] - src [ 1 ]), ( pos [ 0 ] - src [ 0 ])) gamma = 0. a = axis [ 0 ] ** 2 + axis [ 1 ] ** 2 b = 2. * ( src [ 0 ] * axis [ 0 ] + src [ 1 ] * axis [ 1 ]) c = src [ 0 ] ** 2 + src [ 1 ] ** 2 - rstart ** 2 t = ( - b - np . sqrt ( b ** 2 - 4. * a * c )) / ( 2. * a ) origin = src + t * axis beam_grid = { 'nx' : nx , 'ny' : ny , 'nz' : nz , 'xmin' : xmin , 'xmax' : xmax , 'ymin' : ymin , 'ymax' : ymax , 'zmin' : zmin , 'zmax' : zmax , 'alpha' : alpha , 'beta' : beta , 'gamma' : gamma , 'origin' : origin } return beam_grid def write_data ( h5_obj , dic , desc = dict (), units = dict (), name = '' ): \"\"\" #+#write_data #+ Write h5 datasets with attributes 'description' and 'units' #+*** #+##Arguments #+     **h5_obj**: An h5 file or group object from h5py #+ #+     **dic**: Dict of data to save as h5 datasets #+ #+##Keyword Arguments #+     **name**: Name/description of dic for clarity in raising errors #+ #+     **desc**: Dict with same keys as dic describing each item in dic #+ #+     **units**: Dict with same keys as dic providing units of data in dic, doesn't have to be all keys of dic. #+ #+##Example Usage #+```python #+>>> write_data(h5_obj, dic, desc, units) #+``` \"\"\" for key in dic : if isinstance ( dic [ key ], dict ): h5_grp = h5_obj . create_group ( key ) write_data ( h5_grp , dic [ key ]) continue # Transpose data to match expected by Fortran and historically provided by IDL if isinstance ( dic [ key ], np . ndarray ): if dic [ key ] . ndim >= 2 : dic [ key ] = dic [ key ] . T # Make strings of fixed length as required by Fortran. # See http://docs.h5py.org/en/latest/strings.html#fixed-length-ascii if isinstance ( dic [ key ], str ): dic [ key ] = np . string_ ( dic [ key ]) # Create dataset ds = h5_obj . create_dataset ( key , data = dic [ key ]) # Add descrption attribute if key in desc : ds . attrs [ 'description' ] = desc [ key ] # Add units attribute (if present) if key in units : ds . attrs [ 'units' ] = units [ key ] def read_geqdsk ( filename , grid , poloidal = False ): \"\"\" #+#read_geqdsk #+Reads an EFIT GEQDSK file #+*** #+##Arguments #+    **filename**: GEQDSK file #+ #+    **grid**: Interpolation grid #+ #+##Keyword Arguments #+    **poloidal**: Return rho_p (sqrt(normalized poloidal flux)) instead of rho (sqrt(normalized toroidal flux)) #+ #+##Return Value #+Electronmagnetic fields structure, rho, btipsign #+ #+##Example Usage #+```python #+>>> fields, rho, btipsign = read_geqdsk(\"./g133223.00200\",grid) #+``` \"\"\" dims = grid [ 'r2d' ] . shape r_pts = grid [ 'r2d' ] . flatten () / 100 z_pts = grid [ 'z2d' ] . flatten () / 100 g = efit . readg ( filename ) btipsign = np . sign ( g [ \"current\" ] * g [ \"bcentr\" ]) fpol = g [ \"fpol\" ] psiaxis = g [ \"ssimag\" ] psiwall = g [ \"ssibry\" ] r = g [ \"r\" ] z = g [ \"z\" ] psi_arr = np . linspace ( psiaxis , psiwall , len ( fpol )) fpol_itp = interp1d ( psi_arr , fpol , 'cubic' , fill_value = fpol [ - 1 ], bounds_error = False ) psirz_itp = interp2d ( r , z , g [ \"psirz\" ], 'cubic' ) if poloidal : rhogrid = np . array ([ psirz_itp ( rr , zz ) for ( rr , zz ) in zip ( r_pts , z_pts )]) . reshape ( dims ) rhogrid = np . sqrt (( rhogrid - g [ \"ssimag\" ]) / ( g [ \"ssibry\" ] - g [ \"ssimag\" ])) else : rhogrid = efit . rho_rz ( g , r_pts , z_pts , norm = True ) . reshape ( dims ) br = np . array ([ psirz_itp ( rr , zz , dy = 1 ) / rr for ( rr , zz ) in zip ( r_pts , z_pts )]) . reshape ( dims ) bz = np . array ([ - psirz_itp ( rr , zz , dx = 1 ) / rr for ( rr , zz ) in zip ( r_pts , z_pts )]) . reshape ( dims ) bt = np . array ([ fpol_itp ( psirz_itp ( rr , zz )) / rr for ( rr , zz ) in zip ( r_pts , z_pts )]) . reshape ( dims ) er = br * 0 ez = bz * 0 et = bt * 0 mask = np . ones ( dims , dtype = np . int32 ) equil = { \"time\" : 0.0 , \"data_source\" : os . path . abspath ( filename ), \"mask\" : mask , \"br\" : br , \"bt\" : bt , \"bz\" : bz , \"er\" : er , \"et\" : et , \"ez\" : ez } return equil , rhogrid , btipsign def read_ncdf ( filename , vars = None ): ''' #+#read_ncdf #+Reads a flat NetCDF file #+*** #+##Arguments #+    **filename**: NetCDF file #+ #+##Keyword Arguments #+    **vars**: List of variables to read #+ #+##Return Value #+Structure containing NetCDF variables #+ #+##Example Usage #+```python #+>>> a = read_ncdf(\"./123324H01_fi_1.cdf\") #+``` ''' d = dict () d [ 'err' ] = 1 if os . path . isfile ( filename ): d [ 'err' ] = 0 f = netcdf . netcdf_file ( filename , 'r' , mmap = False ) variables = f . variables if vars != None : for k in vars : # need to check case sensitibity if k in variables . keys (): v = variables [ k ] if tuple () == v . shape : d [ k ] = v . getValue () else : d [ k ] = v [:] else : for k , v in variables . items (): if tuple () == v . shape : d [ k ] = v . getValue () else : d [ k ] = v [:] f . close () else : error ( 'FILE DOES NOT EXIST: ' + filename ) return d def extract_transp_plasma ( filename , intime , grid , rhogrid , dn0out = None , scrapeoff = None , rho_scrapeoff = 0.1 ): ''' #+#extract_transp_plasma #+Extracts `plasma` structure from a TRANSP run #+*** #+##Arguments #+    **filename**: TRANSP output file e.g. [TRANSP_RUNID].CDF #+ #+    **intime**: Time of interest [s] #+ #+    **grid**: Interpolation grid #+ #+    **rhogrid**: sqrt(normalized torodial flux) mapped onto the interpolation grid #+ #+##Keyword Arguments #+    **dn0out**: Wall Neutral density value `dn0out` variable in transp namelist #+ #+    **scrapeoff**: scrapeoff decay length #+ #+    **rho_scrapeoff**: scrapeoff length, default = 0.1 #+ #+##Example Usage #+```python #+>>> plasma = extract_transp_plasma(\"./142332H01.CDF\", 1.2, grid, rho) #+``` ''' var_list = [ \"X\" , \"TRFLX\" , \"TFLUX\" , \"TIME\" , \"NE\" , \"TE\" , \"TI\" , \"ZEFFI\" , \"OMEGA\" , \"DN0WD\" ] zz = read_ncdf ( filename , vars = var_list ) t = zz [ 'TIME' ] idx = np . argmin ( abs ( t - intime )) time = t [ idx ] . astype ( 'float64' ) print ( ' * Selecting profiles at :' , time , ' s' ) #pick the closest timeslice to TOI transp_ne = zz [ 'NE' ][ idx ,:] #cm&#94;-3 transp_te = zz [ 'TE' ][ idx ,:] * 1.e-3 # kev transp_ti = zz [ 'TI' ][ idx ,:] * 1.e-3 # kev transp_nn = zz [ 'DN0WD' ][ idx ,:] #cm&#94;-3 transp_zeff = zz [ 'ZEFFI' ][ idx ,:] rho_cb = np . sqrt ( zz [ 'TRFLX' ][ idx ,:] / zz [ 'TFLUX' ][ idx ]) # center each rho b/c toroidal flux is at cell boundary rho = 0.e0 * rho_cb rho [ 0 ] = 0.5 * rho_cb [ 0 ] for i in range ( len ( rho_cb ) - 1 ): rho [ i + 1 ] = rho_cb [ i + 1 ] - 0.5 * ( rho_cb [ i + 1 ] - rho_cb [ i ]) if 'OMEGA' not in zz . keys (): error ( 'OMEGA not found in TRANSP file. Assuming no plasma rotation' ) transp_omega = 0.0 * transp_te else : transp_omega = zz [ 'OMEGA' ][ idx ,:] # rad/s if dn0out == None : dn0out = transp_nn [ - 1 ] if scrapeoff == None : scrapeoff = 0.0 if scrapeoff > 0.0 : drho = abs ( rho [ - 1 ] - rho [ - 2 ]) rho_sc = rho [ - 1 ] + drho * ( range ( np . ceil ( rho_scrapeoff / drho )) + 1 ) sc = np . exp ( - ( rho_sc - rho [ - 1 ]) / scrapeoff ) transp_ne = np . append ( transp_ne , transp_ne [ - 1 ] * sc ) transp_te = np . append ( transp_te , transp_te [ - 1 ] * sc ) transp_ti = np . append ( transp_ti , transp_ti [ - 1 ] * sc ) transp_nn = np . append ( transp_nn , 0 * sc + dn0out ) transp_zeff = np . append ( transp_zeff , ( transp_zeff [ - 1 ] - 1 ) * sc + 1 ) transp_omega = np . append ( transp_omega , transp_omega [ - 1 ] * sc ) rho = np . append ( rho , rho_sc ) profiles = { \"rho\" : rho , \"dene\" : np . where ( transp_ne > 0 , transp_ne , 0.0 ), \"denn\" : np . where ( transp_nn > 0 , transp_nn , 0.0 ), \"te\" : np . where ( transp_te > 0 , transp_te , 0.0 ), \"ti\" : np . where ( transp_ti > 0 , transp_ti , 0.0 ), \"zeff\" : np . where ( transp_zeff > 1.0 , transp_zeff , 1.0 ), \"omega\" : transp_omega } # Interpolate onto r-z grid dims = rhogrid . shape f_dene = interp1d ( rho , transp_ne , fill_value = 'extrapolate' ) dene = f_dene ( rhogrid ) dene = np . where ( dene > 0.0 , dene , 0.0 ) . astype ( 'float64' ) f_denn = interp1d ( rho , np . log ( transp_nn ), fill_value = np . nan , bounds_error = False ) log_denn = f_denn ( rhogrid ) denn = np . where ( ~ np . isnan ( log_denn ), np . exp ( log_denn ), 0.0 ) . astype ( 'float64' ) f_te = interp1d ( rho , transp_te , fill_value = 'extrapolate' ) te = f_te ( rhogrid ) te = np . where ( te > 0 , te , 0.0 ) . astype ( 'float64' ) f_ti = interp1d ( rho , transp_ti , fill_value = 'extrapolate' ) ti = f_ti ( rhogrid ) ti = np . where ( ti > 0 , ti , 0.0 ) . astype ( 'float64' ) f_zeff = interp1d ( rho , transp_zeff , fill_value = 1.0 , bounds_error = False ) zeff = f_zeff ( rhogrid ) zeff = np . where ( zeff > 1 , zeff , 1.0 ) . astype ( 'float64' ) f_omega = interp1d ( rho , transp_omega , fill_value = 'extrapolate' ) vt = grid [ 'r2d' ] * f_omega ( rhogrid ) . astype ( 'float64' ) vr = np . zeros ( dims , dtype = 'float64' ) vz = np . zeros ( dims , dtype = 'float64' ) max_rho = max ( abs ( rho )) mask = np . zeros ( dims , dtype = 'int' ) w = np . where ( rhogrid <= max_rho ) #where we have profiles mask [ w ] = 1 # SAVE IN PROFILES STRUCTURE plasma = { \"data_source\" : os . path . abspath ( filename ), \"time\" : time , \"profiles\" : profiles , \"mask\" : mask , \"dene\" : dene , \"denn\" : denn , \"te\" : te , \"ti\" : ti , \"vr\" : vr , \"vt\" : vt , \"vz\" : vz , \"zeff\" : zeff } return plasma def read_nubeam ( filename , grid , e_range = (), p_range = (), btipsign =- 1 , species = 1 ): \"\"\" #+#read_nubeam #+Reads NUBEAM fast-ion distribution function #+*** #+##Arguments #+    **filename**: NUBEAM guiding center fast-ion distribution function file e.g. 159245H01_fi_1.cdf #+ #+    **grid**: Interpolation grid #+ #+##Keyword Arguments #+    **btipsign**: Sign of the dot product of the magnetic field and plasma current #+ #+    **e_range**: Energy range to consider #+ #+    **p_range**: Pitch range to consider #+ #+    **species**: Fast-ion species number. Defaults to 1 #+ #+##Return Value #+Distribution structure #+ #+##Example Usage #+```python #+>>> dist = read_nubeam(\"./159245H02_fi_1.cdf\",grid,btipsign=-1) #+``` \"\"\" species_var = \"SPECIES_ {} \" . format ( species ) sstr = read_ncdf ( filename , vars = [ species_var ])[ species_var ] . tostring () . decode ( 'UTF-8' ) var = read_ncdf ( filename , vars = [ \"TIME\" , \"R2D\" , \"Z2D\" , \"E_\" + sstr , \"A_\" + sstr , \"F_\" + sstr , \"RSURF\" , \"ZSURF\" , \"BMVOL\" ]) ngrid = len ( var [ \"R2D\" ]) try : time = var [ \"TIME\" ][ 0 ] except : time = var [ \"TIME\" ] r2d = var [ \"R2D\" ] z2d = var [ \"Z2D\" ] rsurf = var [ \"RSURF\" ] . T zsurf = var [ \"ZSURF\" ] . T bmvol = var [ \"BMVOL\" ] pitch = var [ \"A_\" + sstr ] energy = var [ \"E_\" + sstr ] * 1e-3 fbm = var [ \"F_\" + sstr ] . T * 1e3 fbm = np . where ( fbm > 0.0 , 0.5 * fbm , 0.0 ) #0.5 to convert to pitch instead of solid angle d_omega/4pi if btipsign < 0 : fbm = fbm [:,:: - 1 ,:] #reverse pitch elements if not e_range : e_range = ( np . min ( energy ), np . max ( energy )) if not p_range : p_range = ( np . min ( pitch ), np . max ( pitch )) # Trim distribution according to e/p_range we = np . logical_and ( energy >= e_range [ 0 ], energy <= e_range [ 1 ]) wp = np . logical_and ( pitch >= p_range [ 0 ], pitch <= p_range [ 1 ]) energy = energy [ we ] nenergy = len ( energy ) pitch = pitch [ wp ] npitch = len ( pitch ) fbm = fbm [ we ,:,:] fbm = fbm [:, wp ,:] dE = np . abs ( energy [ 1 ] - energy [ 0 ]) dp = np . abs ( pitch [ 1 ] - pitch [ 0 ]) emin , emax = np . maximum ( np . min ( energy ) - 0.5 * dE , 0.0 ), np . max ( energy ) + 0.5 * dE pmin , pmax = np . maximum ( np . min ( pitch ) - 0.5 * dp , - 1.0 ), np . minimum ( np . max ( pitch ) + 0.5 * dp , 1.0 ) print ( 'Energy min/max: ' , emin , emax ) print ( 'Pitch min/max: ' , pmin , pmax ) nr = grid [ \"nr\" ] nz = grid [ \"nz\" ] r = grid [ \"r\" ] z = grid [ \"z\" ] rgrid = grid [ \"r2d\" ] zgrid = grid [ \"z2d\" ] dr = np . abs ( r [ 1 ] - r [ 0 ]) dz = np . abs ( z [ 1 ] - z [ 0 ]) fdens = np . sum ( fbm , axis = ( 0 , 1 )) * dE * dp ntot = np . sum ( fdens * bmvol ) print ( 'Ntotal in phase space: ' , ntot ) tri = Delaunay ( np . vstack (( r2d , z2d )) . T ) # Triangulation for barycentric interpolation pts = np . array ([ xx for xx in zip ( r2d , z2d )]) itp = NearestNDInterpolator ( pts , np . arange ( ngrid )) #to find indices outside simplices points = np . array ([ xx for xx in zip ( rgrid . flatten (), zgrid . flatten ())]) t = tri . find_simplex ( points ) denf = np . zeros (( nr , nz )) fbm_grid = np . zeros (( nenergy , npitch , nr , nz )) for ( ind , tt ) in enumerate ( t ): i , j = np . unravel_index ( ind ,( nr , nz )) if tt == - 1 : ii = int ( itp ( r [ i ], z [ j ])) denf [ i , j ] = fdens [ ii ] fbm_grid [:,:, i , j ] = fbm [:,:, ii ] else : b = tri . transform [ tt ,: 2 ] . dot ( np . transpose ( points [ ind ] - tri . transform [ tt , 2 ])) s = tri . simplices [ tt ,:] #perform barycentric linear interpolation denf [ i , j ] = b [ 0 ] * fdens [ s [ 0 ]] + b [ 1 ] * fdens [ s [ 1 ]] + ( 1 - np . sum ( b )) * fdens [ s [ 2 ]] fbm_grid [:,:, i , j ] = b [ 0 ] * fbm [:,:, s [ 0 ]] + b [ 1 ] * fbm [:,:, s [ 1 ]] + ( 1 - np . sum ( b )) * fbm [:,:, s [ 2 ]] denf [ denf < 0 ] = 0 # Correct for points outside of seperatrix rmaxis = np . mean ( rsurf [:, 0 ]) zmaxis = np . mean ( zsurf [:, 0 ]) r_sep = rsurf [:, - 1 ] z_sep = zsurf [:, - 1 ] #plt.triplot(r2d,z2d,tri.simplices.copy()) #plt.plot(r2d,z2d,'o') #plt.plot(r_sep,z_sep) #plt.show() x_bdry = r_sep - rmaxis y_bdry = z_sep - zmaxis r_bdry = np . sqrt ( x_bdry ** 2 + y_bdry ** 2 ) theta_bdry = np . arctan2 ( y_bdry , x_bdry ) theta_bdry = np . where ( theta_bdry < 0.0 , theta_bdry + 2 * np . pi , theta_bdry ) #[0,2pi] w = np . argsort ( theta_bdry ) theta_bdry = theta_bdry [ w ] r_bdry = r_bdry [ w ] theta_bdry , w = np . unique ( theta_bdry , return_index = True ) r_bdry = r_bdry [ w ] itp = interp1d ( theta_bdry , r_bdry , 'cubic' , fill_value = 'extrapolate' ) x_pts = grid [ \"r2d\" ] - rmaxis y_pts = grid [ \"z2d\" ] - zmaxis r_pts = np . sqrt ( x_pts ** 2 + y_pts ** 2 ) theta_pts = np . arctan2 ( y_pts , x_pts ) theta_pts = np . where ( theta_pts < 0.0 , theta_pts + 2 * np . pi , theta_pts ) #[0,2pi] r_bdry_itp = itp ( theta_pts ) w = r_pts >= r_bdry_itp + 2 denf [ w ] = 0.0 fbm_grid [:,:, w ] = 0.0 # enforce correct normalization ntot_denf = 2 * np . pi * dr * dz * np . sum ( r * np . sum ( denf , axis = 1 )) denf = denf * ( ntot / ntot_denf ) ntot_fbm = ( 2 * np . pi * dE * dp * dr * dz ) * np . sum ( r * np . sum ( fbm_grid , axis = ( 0 , 1 , 3 ))) fbm_grid = fbm_grid * ( ntot / ntot_denf ) fbm_dict = { \"type\" : 1 , \"time\" : time , \"nenergy\" : nenergy , \"energy\" : energy , \"npitch\" : npitch , \"pitch\" : pitch , \"f\" : fbm_grid , \"denf\" : denf , \"data_source\" : os . path . abspath ( filename )} return fbm_dict def nubeam_geometry ( nubeam , angle = 0.0 , verbose = False ): \"\"\" #+#nubeam_geometry #+Calculates the FIDASIM beam geometry from the beam geometry variables in the TRANSP/NUBEAM namelist #+*** #+##Arguments #+     **NUBEAM**: Dictionary containing the following #+ #+     **NUBEAM[\"NAME\"]**: Ion source name #+ #+     **NUBEAM[\"NBSHAP\"]**: Ion source shape 1=rectangular, 2=circular #+ #+     **NUBEAM[\"FOCLZ\"]**: Vertical focal length [cm] #+ #+     **NUBEAM[\"FOCLR\"]**: Horizontal focal length [cm] #+ #+     **NUBEAM[\"DIVZ\"]**: Vertical divergence [rad] #+ #+     **NUBEAM[\"DIVR\"]**: Horizontal divergence [rad] #+ #+     **NUBEAM[\"BMWIDZ\"]**: Ion source half height [cm] #+ #+     **NUBEAM[\"BMWIDR\"]**: Ion source half width [cm] #+ #+     **NUBEAM[\"RTCENA\"]**: Radius of tangency point [cm] #+ #+     **NUBEAM[\"XLBTNA\"]**: Distance from center of beam source grid to tangency point [cm] #+ #+     **NUBEAM[\"XBZETA\"]**: Torodial angle [deg] Positive angles defined to be in the counter-clockwise direction #+ #+     **NUBEAM[\"XYBSCA\"]**: Elevation above/below vacuum vessel midplane of center of beam source grid [cm] #+ #+     **NUBEAM[\"NLJCCW\"]**: Orientation of Ip. 1 for True/Counter-clockwise current, 0 or -1 for False/Clock-wise current #+ #+     **NUBEAM[\"NLCO\"]**: 1 for Co-beam, 0 or -1 for Counter-beam #+ #+     **NUBEAM[\"NBAPSHA\"]**: Vector of aperture shapes 1=rectangular, 2=circular #+ #+     **NUBEAM[\"XLBAPA\"]**: Vector of distances from center of beam source grid to the aperture plane [cm] #+ #+     **NUBEAM[\"XYBAPA\"]**: Vector of elevation above/below vacuum vessel midplane of beam centerline at aperture [cm] #+ #+     **NUBEAM[\"RAPEDGA\"]**: Vector of aperture half-widths [cm] #+ #+     **NUBEAM[\"XZPEDGA\"]**: Vector of aperture half-heights [cm] #+ #+     **NUBEAM[\"XRAPOFFA\"]**: Vector of horizontal (y) offsets relative to the +x aligned beam centerline [cm] #+ #+     **NUBEAM[\"XZAPOFFA\"]**: Vector of vertical (z) offsets relative to the +x aligned beam centerline [cm] #+ #+##Keyword Arguments #+     **angle**: Angle to add to XBZETA to rotate the beams into correct coordinates [deg] #+ #+     **verbose**: Print out positions #+ #+##Return Value #+ Neutral beam structure #+ #+##Example Usage #+```python #+>>> nbi = nubeam_geometry(nubeam) #+``` \"\"\" if nubeam [ \"NLCO\" ] == 0 : nubeam [ \"NLCO\" ] = - 1 if \"NLJCCW\" in nubeam : if nubeam [ \"NLJCCW\" ] == 0 : nubeam [ \"NLJCCW\" ] = - 1 else : warn ( \"Current orientation not specified. Assuming Counter-clockwise.\" ) nubeam [ \"NLJCCW\" ] = 1 phi_s = ( nubeam [ \"XBZETA\" ] + angle ) * np . pi / 180.0 zs = nubeam [ \"XYBSCA\" ] za = nubeam [ \"XYBAPA\" ][ 0 ] alpha = np . arcsin (( zs - za ) / nubeam [ \"XLBAPA\" ][ 0 ]) pdst = nubeam [ \"XLBTNA\" ] * np . cos ( alpha ) rs = np . sqrt ( nubeam [ \"RTCENA\" ] ** 2 + pdst ** 2 ) dat = nubeam [ \"XLBTNA\" ] - nubeam [ \"XLBAPA\" ][ 0 ] pdat = dat * np . cos ( alpha ) ra = np . sqrt ( nubeam [ \"RTCENA\" ] ** 2 + pdat ** 2.0 ) beta_s = np . arccos ( nubeam [ \"RTCENA\" ] / rs ) beta_a = np . arccos ( nubeam [ \"RTCENA\" ] / ra ) phi_a = phi_s + nubeam [ \"NLCO\" ] * nubeam [ \"NLCO\" ] * ( beta_s - beta_a ) src = np . array ([ rs * np . cos ( phi_s ), rs * np . sin ( phi_s ), zs ]) aper_src = np . array ([ ra * np . cos ( phi_a ), ra * np . sin ( phi_a ), za ]) axis = ( aper_src - src ) axis = axis / np . sqrt ( np . sum ( axis ** 2 )) pos = src + axis * nubeam [ \"XLBTNA\" ] if verbose : print ( 'Source position: ' , src ) print ( '1st Aperture position: ' , aper_src ) print ( 'Tangency position: ' , pos ) nbi = { \"data_source\" : \"TRANSP/NUBEAM namelist\" , \"name\" : nubeam [ \"NAME\" ], \"shape\" : nubeam [ \"NBSHAP\" ], \"src\" : src , \"axis\" : axis , \"focy\" : nubeam [ \"FOCLR\" ], \"focz\" : nubeam [ \"FOCLZ\" ], \"divy\" : np . repeat ( nubeam [ \"DIVR\" ], 3 ), \"divz\" : np . repeat ( nubeam [ \"DIVZ\" ], 3 ), \"widy\" : nubeam [ \"BMWIDR\" ], \"widz\" : nubeam [ \"BMWIDZ\" ], \"naperture\" : len ( nubeam [ \"NBAPSHA\" ]), \"ashape\" : nubeam [ \"NBAPSHA\" ], \"awidy\" : nubeam [ \"RAPEDGA\" ], \"awidz\" : nubeam [ \"XZPEDGA\" ], \"aoffy\" : nubeam [ \"XRAPOFFA\" ], \"aoffz\" : nubeam [ \"XZAPOFFA\" ], \"adist\" : nubeam [ \"XLBAPA\" ] } return nbi","tags":"","loc":"sourcefile/utils.py.html","title":"utils.py – FIDASIM"},{"text":"type, public :: InterpolCoeffs1D Linear Interpolation Coefficients and indices Contents Variables i b1 b2 Source Code InterpolCoeffs1D Components Type Visibility Attributes Name Initial integer, public :: i = 0 Index of position right before xout real(kind=Float64), public :: b1 = 0.d0 Coefficient for y(i) term real(kind=Float64), public :: b2 = 0.d0 Coefficient for y(i+1) term Source Code type InterpolCoeffs1D !+ Linear Interpolation Coefficients and indices integer :: i = 0 !+ Index of position right before `xout` real ( Float64 ) :: b1 = 0.d0 !+ Coefficient for y(i) term real ( Float64 ) :: b2 = 0.d0 !+ Coefficient for y(i+1) term end type InterpolCoeffs1D","tags":"","loc":"type/interpolcoeffs1d.html","title":"InterpolCoeffs1D – FIDASIM "},{"text":"type, public :: InterpolCoeffs2D 2D Linear Interpolation Coefficients and indices Contents Variables i j b11 b12 b21 b22 Source Code InterpolCoeffs2D Components Type Visibility Attributes Name Initial integer, public :: i = 0 Index of abscissa before xout integer, public :: j = 0 Index of ordinate before yout real(kind=Float64), public :: b11 = 0.d0 Coefficient for z(i,j) term real(kind=Float64), public :: b12 = 0.d0 Coefficient for z(i,j+1) term real(kind=Float64), public :: b21 = 0.d0 Coefficient for z(i+1,j) term real(kind=Float64), public :: b22 = 0.d0 Coefficient for z(i+1,j+1) term Source Code type InterpolCoeffs2D !+ 2D Linear Interpolation Coefficients and indices integer :: i = 0 !+ Index of abscissa before `xout` integer :: j = 0 !+ Index of ordinate before `yout` real ( Float64 ) :: b11 = 0.d0 !+ Coefficient for z(i,j) term real ( Float64 ) :: b12 = 0.d0 !+ Coefficient for z(i,j+1) term real ( Float64 ) :: b21 = 0.d0 !+ Coefficient for z(i+1,j) term real ( Float64 ) :: b22 = 0.d0 !+ Coefficient for z(i+1,j+1) term end type InterpolCoeffs2D","tags":"","loc":"type/interpolcoeffs2d.html","title":"InterpolCoeffs2D – FIDASIM "},{"text":"type, public :: InterpolCoeffs3D 3D Cylindrical Interpolation Coefficients and indices Inherited by type~~interpolcoeffs3d~~InheritedByGraph type~interpolcoeffs3d InterpolCoeffs3D type~localprofiles LocalProfiles type~localprofiles->type~interpolcoeffs3d b type~localemfields LocalEMFields type~localemfields->type~interpolcoeffs3d b Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables i j k b111 b121 b112 b122 b211 b212 b221 b222 Source Code InterpolCoeffs3D Components Type Visibility Attributes Name Initial integer, public :: i = 0 Index of R before rout integer, public :: j = 0 Index of Z before zout integer, public :: k = 0 Index of Phi before phiout real(kind=Float64), public :: b111 = 0.d0 Coefficient for z(i,j,k) term real(kind=Float64), public :: b121 = 0.d0 Coefficient for z(i,j+1,k) term real(kind=Float64), public :: b112 = 0.d0 Coefficient for z(i,j,k+1) term real(kind=Float64), public :: b122 = 0.d0 Coefficient for z(i,j+1,k+1) term real(kind=Float64), public :: b211 = 0.d0 Coefficient for z(i+1,j,k) term real(kind=Float64), public :: b212 = 0.d0 Coefficient for z(i+1,j,k+1) term real(kind=Float64), public :: b221 = 0.d0 Coefficient for z(i+1,j+1,k) term real(kind=Float64), public :: b222 = 0.d0 Coefficient for z(i+1,j+1,k+1) term Source Code type InterpolCoeffs3D !+ 3D Cylindrical Interpolation Coefficients and indices integer :: i = 0 !+ Index of R before `rout` integer :: j = 0 !+ Index of Z before `zout` integer :: k = 0 !+ Index of Phi before `phiout` real ( Float64 ) :: b111 = 0.d0 !+ Coefficient for z(i,j,k) term real ( Float64 ) :: b121 = 0.d0 !+ Coefficient for z(i,j+1,k) term real ( Float64 ) :: b112 = 0.d0 !+ Coefficient for z(i,j,k+1) term real ( Float64 ) :: b122 = 0.d0 !+ Coefficient for z(i,j+1,k+1) term real ( Float64 ) :: b211 = 0.d0 !+ Coefficient for z(i+1,j,k) term real ( Float64 ) :: b212 = 0.d0 !+ Coefficient for z(i+1,j,k+1) term real ( Float64 ) :: b221 = 0.d0 !+ Coefficient for z(i+1,j+1,k) term real ( Float64 ) :: b222 = 0.d0 !+ Coefficient for z(i+1,j+1,k+1) term end type InterpolCoeffs3D","tags":"","loc":"type/interpolcoeffs3d.html","title":"InterpolCoeffs3D – FIDASIM "},{"text":"type, public :: BeamGrid Defines a 3D grid for neutral beam calculations Contents Variables nx ny nz xmin xmax ymin ymax zmin zmax alpha beta gamma drmin dv volume ntrack ngrid dims origin center dr lwh basis inv_basis xc yc zc Source Code BeamGrid Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nx Number of cells in the x direction integer(kind=Int32), public :: ny Number of cells in the y direction integer(kind=Int32), public :: nz Number of cells in the z direction real(kind=Float64), public :: xmin Minimum x value real(kind=Float64), public :: xmax Maximum x value real(kind=Float64), public :: ymin Minimum y value real(kind=Float64), public :: ymax Maximum y value real(kind=Float64), public :: zmin Minimum z value real(kind=Float64), public :: zmax Maximum z value real(kind=Float64), public :: alpha Tait-Bryan angle for a rotation about z [radians] real(kind=Float64), public :: beta Tait-Bryan angle for a rotation about y' [radians] real(kind=Float64), public :: gamma Tait-Bryan angle for a rotation about x\" [radians] real(kind=Float64), public :: drmin Minimum cell spacing: min(dx,dy,dz) real(kind=Float64), public :: dv Cell volume [ cm&#94;3 ] real(kind=Float64), public :: volume Grid volume [ cm&#94;3 ] integer(kind=Int32), public :: ntrack Maximum number of cell for particle tracking integer(kind=Int32), public :: ngrid Number of cells integer(kind=Int32), public, dimension(3) :: dims Dimensions of beam grid real(kind=Float64), public, dimension(3) :: origin Origin of beam grid in machine coordinates real(kind=Float64), public, dimension(3) :: center Center of beam grid in beam coordinates real(kind=Float64), public, dimension(3) :: dr Cell spacings [dx, dy, dz] real(kind=Float64), public, dimension(3) :: lwh Grid [length(x), width(y), height(z)] real(kind=Float64), public, dimension(3,3) :: basis Beam grid basis for converting from beam coordinates(xyz)\nto machine coordinates(uvw): (\\uvw = B*xyz + origin) real(kind=Float64), public, dimension(3,3) :: inv_basis Inverse basis for reverse transformation: (\\xyz = B&#94;{-1}*(uvw - origin)) real(kind=Float64), public, dimension(:), allocatable :: xc x positions of cell centers real(kind=Float64), public, dimension(:), allocatable :: yc y positions of cell centers real(kind=Float64), public, dimension(:), allocatable :: zc z positions of cell centers Source Code type BeamGrid !+ Defines a 3D grid for neutral beam calculations integer ( Int32 ) :: nx !+ Number of cells in the x direction integer ( Int32 ) :: ny !+ Number of cells in the y direction integer ( Int32 ) :: nz !+ Number of cells in the z direction real ( Float64 ) :: xmin !+ Minimum x value real ( Float64 ) :: xmax !+ Maximum x value real ( Float64 ) :: ymin !+ Minimum y value real ( Float64 ) :: ymax !+ Maximum y value real ( Float64 ) :: zmin !+ Minimum z value real ( Float64 ) :: zmax !+ Maximum z value real ( Float64 ) :: alpha !+ Tait-Bryan angle for a rotation about z [radians] real ( Float64 ) :: beta !+ Tait-Bryan angle for a rotation about y' [radians] real ( Float64 ) :: gamma !+ Tait-Bryan angle for a rotation about x\" [radians] real ( Float64 ) :: drmin !+ Minimum cell spacing: `min(dx,dy,dz)` real ( Float64 ) :: dv !+ Cell volume [cm&#94;3] real ( Float64 ) :: volume !+ Grid volume [cm&#94;3] integer ( Int32 ) :: ntrack !+ Maximum number of cell for particle tracking integer ( Int32 ) :: ngrid !+ Number of cells integer ( Int32 ), dimension ( 3 ) :: dims !+ Dimensions of beam grid real ( Float64 ), dimension ( 3 ) :: origin !+ Origin of beam grid in machine coordinates real ( Float64 ), dimension ( 3 ) :: center !+ Center of beam grid in beam coordinates real ( Float64 ), dimension ( 3 ) :: dr !+ Cell spacings [dx, dy, dz] real ( Float64 ), dimension ( 3 ) :: lwh !+ Grid [length(x), width(y), height(z)] real ( Float64 ), dimension ( 3 , 3 ) :: basis !+Beam grid basis for converting from beam coordinates(xyz) !+to machine coordinates(uvw): (\\uvw = B*xyz + origin real ( Float64 ), dimension ( 3 , 3 ) :: inv_basis !+Inverse basis for reverse transformation: (\\xyz = B&#94;{-1}*(uvw - origin) real ( Float64 ), dimension (:), allocatable :: xc !+ x positions of cell centers real ( Float64 ), dimension (:), allocatable :: yc !+ y positions of cell centers real ( Float64 ), dimension (:), allocatable :: zc !+ z positions of cell centers end type BeamGrid","tags":"","loc":"type/beamgrid.html","title":"BeamGrid – FIDASIM "},{"text":"type, public :: InterpolationGrid Defines a 3D R-Z-phi grid for interpolating plasma parameters and fields Contents Variables nr nz nphi dr dz dphi da dv dims r z phi ntrack ngrid Source Code InterpolationGrid Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nr Number of Radii integer(kind=Int32), public :: nz Number of Z values integer(kind=Int32), public :: nphi Number of phi values real(kind=Float64), public :: dr Radial spacing [cm] real(kind=Float64), public :: dz Vertical spacing [cm] real(kind=Float64), public :: dphi Angular spacing [rad] real(kind=Float64), public :: da Grid element area [ cm&#94;2 ] real(kind=Float64), public :: dv dr dz dphi [ rad*cm&#94;2 ] integer(kind=Int32), public :: dims (3) Dimension of the interpolation grid real(kind=Float64), public, dimension(:), allocatable :: r Radii values [cm] real(kind=Float64), public, dimension(:), allocatable :: z Z values [cm] real(kind=Float64), public, dimension(:), allocatable :: phi Angular values [rad] integer(kind=Int32), public :: ntrack Maximum number of cells for particle tracking integer(kind=Int32), public :: ngrid Number of cells Source Code type InterpolationGrid !+ Defines a 3D R-Z-phi grid for interpolating plasma parameters and fields integer ( Int32 ) :: nr !+ Number of Radii integer ( Int32 ) :: nz !+ Number of Z values integer ( Int32 ) :: nphi !+ Number of phi values real ( Float64 ) :: dr !+ Radial spacing [cm] real ( Float64 ) :: dz !+ Vertical spacing [cm] real ( Float64 ) :: dphi !+ Angular spacing [rad] real ( Float64 ) :: da !+ Grid element area [cm&#94;2] real ( Float64 ) :: dv !+ dr*dz*dphi [rad*cm&#94;2] integer ( Int32 ) :: dims ( 3 ) !+ Dimension of the interpolation grid real ( Float64 ), dimension (:), allocatable :: r !+ Radii values [cm] real ( Float64 ), dimension (:), allocatable :: z !+ Z values [cm] real ( Float64 ), dimension (:), allocatable :: phi !+ Angular values [rad] integer ( Int32 ) :: ntrack !+ Maximum number of cells for particle tracking integer ( Int32 ) :: ngrid !+ Number of cells end type InterpolationGrid","tags":"","loc":"type/interpolationgrid.html","title":"InterpolationGrid – FIDASIM "},{"text":"type, public :: Profiles Torodial symmetric plasma parameters at a given R-Z Inherited by type~~profiles~~InheritedByGraph type~profiles Profiles type~localprofiles LocalProfiles type~localprofiles->type~profiles type~equilibrium Equilibrium type~equilibrium->type~profiles plasma Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables dene denp denimp denf te ti zeff vr vt vz denn Source Code Profiles Components Type Visibility Attributes Name Initial real(kind=Float64), public :: dene = 0.d0 Electron density [ cm&#94;{-3} ] real(kind=Float64), public :: denp = 0.d0 Ion density [ cm&#94;{-3} ] real(kind=Float64), public :: denimp = 0.d0 Impurity density [ cm&#94;{-3} ] real(kind=Float64), public :: denf = 0.d0 Fast-ion density [ cm&#94;{-3} ] real(kind=Float64), public :: te = 0.d0 Electron temperature [kev] real(kind=Float64), public :: ti = 0.d0 Ion temperature [kev] real(kind=Float64), public :: zeff = 0.d0 Effective Nuclear Charge real(kind=Float64), public :: vr = 0.d0 Plasma rotation in radial direction real(kind=Float64), public :: vt = 0.d0 Plasma rotation in torodial/phi direction real(kind=Float64), public :: vz = 0.d0 Plasma rotation in z direction real(kind=Float64), public :: denn (nlevs) = 0.d0 Cold neutral density [ cm&#94;{-3} ] Source Code type Profiles !+ Torodial symmetric plasma parameters at a given R-Z real ( Float64 ) :: dene = 0.d0 !+ Electron density [cm&#94;{-3}] real ( Float64 ) :: denp = 0.d0 !+ Ion density [cm&#94;{-3}] real ( Float64 ) :: denimp = 0.d0 !+ Impurity density [cm&#94;{-3}] real ( Float64 ) :: denf = 0.d0 !+ Fast-ion density [cm&#94;{-3}] real ( Float64 ) :: te = 0.d0 !+ Electron temperature [kev] real ( Float64 ) :: ti = 0.d0 !+ Ion temperature [kev] real ( Float64 ) :: zeff = 0.d0 !+ Effective Nuclear Charge real ( Float64 ) :: vr = 0.d0 !+ Plasma rotation in radial direction real ( Float64 ) :: vt = 0.d0 !+ Plasma rotation in torodial/phi direction real ( Float64 ) :: vz = 0.d0 !+ Plasma rotation in z direction real ( Float64 ) :: denn ( nlevs ) = 0.d0 !+ Cold neutral density [cm&#94;{-3}] end type Profiles","tags":"","loc":"type/profiles.html","title":"Profiles – FIDASIM "},{"text":"type, public, extends( Profiles ) :: LocalProfiles Plasma parameters at given position Inherits type~~localprofiles~~InheritsGraph type~localprofiles LocalProfiles type~profiles Profiles type~localprofiles->type~profiles type~interpolcoeffs3d InterpolCoeffs3D type~localprofiles->type~interpolcoeffs3d b Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables dene denp denimp denf te ti zeff vr vt vz denn in_plasma coords pos uvw vrot vrot_uvw b Source Code LocalProfiles Components Type Visibility Attributes Name Initial real(kind=Float64), public :: dene = 0.d0 Electron density [ cm&#94;{-3} ] real(kind=Float64), public :: denp = 0.d0 Ion density [ cm&#94;{-3} ] real(kind=Float64), public :: denimp = 0.d0 Impurity density [ cm&#94;{-3} ] real(kind=Float64), public :: denf = 0.d0 Fast-ion density [ cm&#94;{-3} ] real(kind=Float64), public :: te = 0.d0 Electron temperature [kev] real(kind=Float64), public :: ti = 0.d0 Ion temperature [kev] real(kind=Float64), public :: zeff = 0.d0 Effective Nuclear Charge real(kind=Float64), public :: vr = 0.d0 Plasma rotation in radial direction real(kind=Float64), public :: vt = 0.d0 Plasma rotation in torodial/phi direction real(kind=Float64), public :: vz = 0.d0 Plasma rotation in z direction real(kind=Float64), public :: denn (nlevs) = 0.d0 Cold neutral density [ cm&#94;{-3} ] logical, public :: in_plasma = .False. Indicates whether plasma parameters are valid/known integer, public :: coords = 0 Indicates coordinate system of vectors. Beam grid (0), machine (1) and cylindrical (2) real(kind=Float64), public, dimension(3) :: pos = 0.d0 Position in beam grid coordinates real(kind=Float64), public, dimension(3) :: uvw = 0.d0 Position in machine coordinates real(kind=Float64), public, dimension(3) :: vrot = 0.d0 Plasma rotation in beam grid coordinates real(kind=Float64), public, dimension(3) :: vrot_uvw = 0.d0 Plasma rotation in machine coordinates type( InterpolCoeffs3D ), public :: b Cylindrical Interpolation Coefficients and indicies for interpolation at pos Source Code type , extends ( Profiles ) :: LocalProfiles !+ Plasma parameters at given position logical :: in_plasma = . False . !+ Indicates whether plasma parameters are valid/known integer :: coords = 0 !+ Indicates coordinate system of vectors. Beam grid (0), machine (1) and cylindrical (2) real ( Float64 ), dimension ( 3 ) :: pos = 0.d0 !+ Position in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: uvw = 0.d0 !+ Position in machine coordinates real ( Float64 ), dimension ( 3 ) :: vrot = 0.d0 !+ Plasma rotation in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: vrot_uvw = 0.d0 !+ Plasma rotation in machine coordinates type ( InterpolCoeffs3D ) :: b !+ Cylindrical Interpolation Coefficients and indicies for interpolation at `pos` end type LocalProfiles","tags":"","loc":"type/localprofiles.html","title":"LocalProfiles – FIDASIM "},{"text":"type, public :: EMFields Torodial symmetric electro-magnetic fields at given R-Z Inherited by type~~emfields~~InheritedByGraph type~emfields EMFields type~localemfields LocalEMFields type~localemfields->type~emfields type~equilibrium Equilibrium type~equilibrium->type~emfields fields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables br bt bz er et ez dbr_dr dbr_dphi dbr_dz dbt_dr dbt_dphi dbt_dz dbz_dr dbz_dphi dbz_dz Source Code EMFields Components Type Visibility Attributes Name Initial real(kind=Float64), public :: br = 0.d0 Radial magnetic field [T] real(kind=Float64), public :: bt = 0.d0 Torodial magnetic field [T] real(kind=Float64), public :: bz = 0.d0 Vertical magnetic field [T] real(kind=Float64), public :: er = 0.d0 Radial electric field [V/m] real(kind=Float64), public :: et = 0.d0 Torodial electric field [V/m] real(kind=Float64), public :: ez = 0.d0 Vertical electric field [V/m] real(kind=Float64), public :: dbr_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbr_dphi = 0.d0 Angular derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbr_dz = 0.d0 Vertical derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbt_dr = 0.d0 Radial derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbt_dphi = 0.d0 Angular derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbt_dz = 0.d0 Vertical derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbz_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbz_dphi = 0.d0 Angular derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbz_dz = 0.d0 Vertical derivative of the vertical magnetic field [T/m] Source Code type EMFields !+ Torodial symmetric electro-magnetic fields at given R-Z real ( Float64 ) :: br = 0.d0 !+ Radial magnetic field [T] real ( Float64 ) :: bt = 0.d0 !+ Torodial magnetic field [T] real ( Float64 ) :: bz = 0.d0 !+ Vertical magnetic field [T] real ( Float64 ) :: er = 0.d0 !+ Radial electric field [V/m] real ( Float64 ) :: et = 0.d0 !+ Torodial electric field [V/m] real ( Float64 ) :: ez = 0.d0 !+ Vertical electric field [V/m] real ( Float64 ) :: dbr_dr = 0.d0 !+ Radial derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbr_dphi = 0.d0 !+ Angular derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbr_dz = 0.d0 !+ Vertical derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbt_dr = 0.d0 !+ Radial derivative of the torodial magnetic field [T/m] real ( Float64 ) :: dbt_dphi = 0.d0 !+ Angular derivative of the torodial magnetic field [T/m] real ( Float64 ) :: dbt_dz = 0.d0 !+ Vertical derivative of the torodial magnetic field [T/m] real ( Float64 ) :: dbz_dr = 0.d0 !+ Radial derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbz_dphi = 0.d0 !+ Angular derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbz_dz = 0.d0 !+ Vertical derivative of the vertical magnetic field [T/m] end type EMFields","tags":"","loc":"type/emfields.html","title":"EMFields – FIDASIM "},{"text":"type, public, extends( EMFields ) :: LocalEMFields Electro-magnetic fields at given position Inherits type~~localemfields~~InheritsGraph type~localemfields LocalEMFields type~emfields EMFields type~localemfields->type~emfields type~interpolcoeffs3d InterpolCoeffs3D type~localemfields->type~interpolcoeffs3d b Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables br bt bz er et ez dbr_dr dbr_dphi dbr_dz dbt_dr dbt_dphi dbt_dz dbz_dr dbz_dphi dbz_dz in_plasma coords b_abs e_abs pos uvw b_norm a_norm c_norm e_norm b Source Code LocalEMFields Components Type Visibility Attributes Name Initial real(kind=Float64), public :: br = 0.d0 Radial magnetic field [T] real(kind=Float64), public :: bt = 0.d0 Torodial magnetic field [T] real(kind=Float64), public :: bz = 0.d0 Vertical magnetic field [T] real(kind=Float64), public :: er = 0.d0 Radial electric field [V/m] real(kind=Float64), public :: et = 0.d0 Torodial electric field [V/m] real(kind=Float64), public :: ez = 0.d0 Vertical electric field [V/m] real(kind=Float64), public :: dbr_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbr_dphi = 0.d0 Angular derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbr_dz = 0.d0 Vertical derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbt_dr = 0.d0 Radial derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbt_dphi = 0.d0 Angular derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbt_dz = 0.d0 Vertical derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbz_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbz_dphi = 0.d0 Angular derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbz_dz = 0.d0 Vertical derivative of the vertical magnetic field [T/m] logical, public :: in_plasma = .False. Indicates whether fields are valid/known integer, public :: coords = 0 Indicates coordinate system of vectors. Beam grid (0), machine (1) and cylindrical (2) real(kind=Float64), public :: b_abs = 0.d0 Magnitude of magnetic field real(kind=Float64), public :: e_abs = 0.d0 Magnitude of electrin field real(kind=Float64), public, dimension(3) :: pos = 0.d0 Position in beam grid coordinates real(kind=Float64), public, dimension(3) :: uvw = 0.d0 Position in machine coordinates real(kind=Float64), public, dimension(3) :: b_norm = 0.d0 Direction of magnetic field in beam grid coordinates real(kind=Float64), public, dimension(3) :: a_norm = 0.d0 Vector perpendicular to b_norm and c_norm real(kind=Float64), public, dimension(3) :: c_norm = 0.d0 Vector perpendicular to b_norm and a_norm real(kind=Float64), public, dimension(3) :: e_norm = 0.d0 Direction of electric field in beam grid coordinates type( InterpolCoeffs3D ), public :: b Cylindrical Interpolation Coefficients and indicies for interpolation at pos Source Code type , extends ( EMFields ) :: LocalEMFields !+ Electro-magnetic fields at given position logical :: in_plasma = . False . !+ Indicates whether fields are valid/known integer :: coords = 0 !+ Indicates coordinate system of vectors. Beam grid (0), machine (1) and cylindrical (2) real ( Float64 ) :: b_abs = 0.d0 !+ Magnitude of magnetic field real ( Float64 ) :: e_abs = 0.d0 !+ Magnitude of electrin field real ( Float64 ), dimension ( 3 ) :: pos = 0.d0 !+ Position in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: uvw = 0.d0 !+ Position in machine coordinates real ( Float64 ), dimension ( 3 ) :: b_norm = 0.d0 !+ Direction of magnetic field in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: a_norm = 0.d0 !+ Vector perpendicular to `b_norm` and `c_norm` real ( Float64 ), dimension ( 3 ) :: c_norm = 0.d0 !+ Vector perpendicular to `b_norm` and `a_norm` real ( Float64 ), dimension ( 3 ) :: e_norm = 0.d0 !+ Direction of electric field in beam grid coordinates type ( InterpolCoeffs3D ) :: b !+ Cylindrical Interpolation Coefficients and indicies for interpolation at `pos` end type LocalEMFields","tags":"","loc":"type/localemfields.html","title":"LocalEMFields – FIDASIM "},{"text":"type, public :: Equilibrium MHD Equilbrium Inherits type~~equilibrium~~InheritsGraph type~equilibrium Equilibrium type~profiles Profiles type~equilibrium->type~profiles plasma type~emfields EMFields type~equilibrium->type~emfields fields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables fields plasma mask Source Code Equilibrium Components Type Visibility Attributes Name Initial type( EMFields ), public, dimension(:,:,:), allocatable :: fields Electro-magnetic fields at points defined in inter_grid type( Profiles ), public, dimension(:,:,:), allocatable :: plasma Plasma parameters at points defined in inter_grid real(kind=Float64), public, dimension(:,:,:), allocatable :: mask Indicates whether fields and plasma are well-defined at points defined in inter_grid Source Code type Equilibrium !+MHD Equilbrium type ( EMFields ), dimension (:,:,:), allocatable :: fields !+ Electro-magnetic fields at points defined in [[libfida:inter_grid]] type ( Profiles ), dimension (:,:,:), allocatable :: plasma !+ Plasma parameters at points defined in [[libfida:inter_grid]] real ( Float64 ), dimension (:,:,:), allocatable :: mask !+ Indicates whether fields and plasma are well-defined at points defined in [[libfida:inter_grid]] end type Equilibrium","tags":"","loc":"type/equilibrium.html","title":"Equilibrium – FIDASIM "},{"text":"type, public :: FastIonDistribution Defines a Guiding Center Fast-ion Distribution Function: F(E,p,R,Z,Phi) Contents Variables nenergy npitch nr nz nphi dE dp dr dz dphi emin emax e_range pmin pmax p_range rmin rmax r_range zmin zmax z_range phimin phimax phi_range n_tot energy pitch r z phi denf f Source Code FastIonDistribution Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nenergy Number of energies integer(kind=Int32), public :: npitch Number of pitches integer(kind=Int32), public :: nr Number of radii integer(kind=Int32), public :: nz Number of z values integer(kind=Int32), public :: nphi Number of phi values real(kind=Float64), public :: dE Energy spacing [keV] real(kind=Float64), public :: dp Pitch spacing real(kind=Float64), public :: dr Radial spacing [cm] real(kind=Float64), public :: dz Z spacing [cm] real(kind=Float64), public :: dphi Angular spacing [rad] real(kind=Float64), public :: emin Minimum energy [keV] real(kind=Float64), public :: emax Maximum energy [keV] real(kind=Float64), public :: e_range Energy interval length [keV] real(kind=Float64), public :: pmin Minimum pitch real(kind=Float64), public :: pmax Maximum pitch real(kind=Float64), public :: p_range Pitch interval length real(kind=Float64), public :: rmin Minimum radius [cm] real(kind=Float64), public :: rmax Maximum radius [cm] real(kind=Float64), public :: r_range Radius interval length [cm] real(kind=Float64), public :: zmin Minimum Z [cm] real(kind=Float64), public :: zmax Maximum Z [cm] real(kind=Float64), public :: z_range Z interval length [cm] real(kind=Float64), public :: phimin Minimum Phi [rad] real(kind=Float64), public :: phimax Maximum Phi [rad] real(kind=Float64), public :: phi_range Phi interval length [rad] real(kind=Float64), public :: n_tot = 0.d0 Total Number of fast-ions real(kind=Float64), public, dimension(:), allocatable :: energy Energy values [keV] real(kind=Float64), public, dimension(:), allocatable :: pitch Pitch w.r.t. the magnetic field real(kind=Float64), public, dimension(:), allocatable :: r Radius [cm] real(kind=Float64), public, dimension(:), allocatable :: z Z [cm] real(kind=Float64), public, dimension(:), allocatable :: phi Angles [rad] real(kind=Float64), public, dimension(:,:,:), allocatable :: denf Fast-ion density defined on the inter_grid : denf(R,Z,Phi) real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: f Fast-ion distribution function defined on the inter_grid : F(E,p,R,Z,Phi) Source Code type FastIonDistribution !+ Defines a Guiding Center Fast-ion Distribution Function: F(E,p,R,Z,Phi) integer ( Int32 ) :: nenergy !+ Number of energies integer ( Int32 ) :: npitch !+ Number of pitches integer ( Int32 ) :: nr !+ Number of radii integer ( Int32 ) :: nz !+ Number of z values integer ( Int32 ) :: nphi !+ Number of phi values real ( Float64 ) :: dE !+ Energy spacing [keV] real ( Float64 ) :: dp !+ Pitch spacing real ( Float64 ) :: dr !+ Radial spacing [cm] real ( Float64 ) :: dz !+ Z spacing [cm] real ( Float64 ) :: dphi !+ Angular spacing [rad] real ( Float64 ) :: emin !+ Minimum energy [keV] real ( Float64 ) :: emax !+ Maximum energy [keV] real ( Float64 ) :: e_range !+ Energy interval length [keV] real ( Float64 ) :: pmin !+ Minimum pitch real ( Float64 ) :: pmax !+ Maximum pitch real ( Float64 ) :: p_range !+ Pitch interval length real ( Float64 ) :: rmin !+ Minimum radius [cm] real ( Float64 ) :: rmax !+ Maximum radius [cm] real ( Float64 ) :: r_range !+ Radius interval length [cm] real ( Float64 ) :: zmin !+ Minimum Z [cm] real ( Float64 ) :: zmax !+ Maximum Z [cm] real ( Float64 ) :: z_range !+ Z interval length [cm] real ( Float64 ) :: phimin !+ Minimum Phi [rad] real ( Float64 ) :: phimax !+ Maximum Phi [rad] real ( Float64 ) :: phi_range !+ Phi interval length [rad] real ( Float64 ) :: n_tot = 0.d0 !+ Total Number of fast-ions real ( Float64 ), dimension (:), allocatable :: energy !+ Energy values [keV] real ( Float64 ), dimension (:), allocatable :: pitch !+ Pitch w.r.t. the magnetic field real ( Float64 ), dimension (:), allocatable :: r !+ Radius [cm] real ( Float64 ), dimension (:), allocatable :: z !+ Z [cm] real ( Float64 ), dimension (:), allocatable :: phi !+ Angles [rad] real ( Float64 ), dimension (:,:,:), allocatable :: denf !+ Fast-ion density defined on the [[libfida:inter_grid]]: denf(R,Z,Phi) real ( Float64 ), dimension (:,:,:,:,:), allocatable :: f !+ Fast-ion distribution function defined on the [[libfida:inter_grid]]: F(E,p,R,Z,Phi) end type FastIonDistribution","tags":"","loc":"type/fastiondistribution.html","title":"FastIonDistribution – FIDASIM "},{"text":"type, public :: FastIon Defines a fast-ion Inherited by type~~fastion~~InheritedByGraph type~fastion FastIon type~fastionparticles FastIonParticles type~fastionparticles->type~fastion fast_ion Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables beam_grid_cross_grid r phi z beam_grid_phi_enter delta_phi energy pitch vabs vr vt vz weight class Source Code FastIon Components Type Visibility Attributes Name Initial logical, public :: beam_grid_cross_grid = .False. Indicates whether the fast-ion crosses the beam_grid real(kind=Float64), public :: r = 0.d0 Radial position of fast-ion [cm] real(kind=Float64), public :: phi = 0.d0 Angular position of fast-ion [rad] real(kind=Float64), public :: z = 0.d0 Vertical position of fast-ion [cm] real(kind=Float64), public :: beam_grid_phi_enter = 0.d0 Torodial/phi position where fast-ion enters the beam_grid [radians] real(kind=Float64), public :: delta_phi = 2*pi Angle subtended by the beam_grid at (r,z) real(kind=Float64), public :: energy = 0.d0 Energy [keV] real(kind=Float64), public :: pitch = 0.d0 Pitch w.r.t. the magnetic field real(kind=Float64), public :: vabs = 0.d0 Speed [cm/s] real(kind=Float64), public :: vr = 0.d0 Radial velocity [cm/s] real(kind=Float64), public :: vt = 0.d0 Torodial velocity [cm/s] real(kind=Float64), public :: vz = 0.d0 Z velocity [cm/s] real(kind=Float64), public :: weight = 0.d0 Particle weight: How many fast-ions does particle represent. integer(kind=Int32), public :: class = 0 Orbit class id Source Code type FastIon !+ Defines a fast-ion logical :: beam_grid_cross_grid = . False . !+ Indicates whether the fast-ion crosses the [[libfida:beam_grid]] real ( Float64 ) :: r = 0.d0 !+ Radial position of fast-ion [cm] real ( Float64 ) :: phi = 0.d0 !+ Angular position of fast-ion [rad] real ( Float64 ) :: z = 0.d0 !+ Vertical position of fast-ion [cm] real ( Float64 ) :: beam_grid_phi_enter = 0.d0 !+ Torodial/phi position where fast-ion enters the [[libfida:beam_grid]] [radians] real ( Float64 ) :: delta_phi = 2 * pi !+ Angle subtended by the [[libfida:beam_grid]] at (r,z) real ( Float64 ) :: energy = 0.d0 !+ Energy [keV] real ( Float64 ) :: pitch = 0.d0 !+ Pitch w.r.t. the magnetic field real ( Float64 ) :: vabs = 0.d0 !+ Speed [cm/s] real ( Float64 ) :: vr = 0.d0 !+ Radial velocity [cm/s] real ( Float64 ) :: vt = 0.d0 !+ Torodial velocity [cm/s] real ( Float64 ) :: vz = 0.d0 !+ Z velocity [cm/s] real ( Float64 ) :: weight = 0.d0 !+ Particle weight: How many fast-ions does particle represent. integer ( Int32 ) :: class = 0 !+ Orbit class id end type FastIon","tags":"","loc":"type/fastion.html","title":"FastIon – FIDASIM "},{"text":"type, public :: FastIonParticles Collection of fast-ion particles Inherits type~~fastionparticles~~InheritsGraph type~fastionparticles FastIonParticles type~fastion FastIon type~fastionparticles->type~fastion fast_ion Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nparticle nclass axisym fast_ion Source Code FastIonParticles Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nparticle = 0 Number of particles integer(kind=Int32), public :: nclass = 1 Number of orbit classes logical, public :: axisym = .True. Indicates whether distribution function is axisymmetric type( FastIon ), public, dimension(:), allocatable :: fast_ion Fast-ion particles Source Code type FastIonParticles !+ Collection of fast-ion particles integer ( Int32 ) :: nparticle = 0 !+ Number of particles integer ( Int32 ) :: nclass = 1 !+ Number of orbit classes logical :: axisym = . True . !+ Indicates whether distribution function is axisymmetric type ( FastIon ), dimension (:), allocatable :: fast_ion !+ Fast-ion particles end type FastIonParticles","tags":"","loc":"type/fastionparticles.html","title":"FastIonParticles – FIDASIM "},{"text":"type, public :: NeutralBeam Defines a neutral beam with +x defined to be into the plasma Contents Variables name shape widy widz focy focz einj pinj vinj alpha beta divy divz current_fractions src axis naperture ashape awidy awidz aoffy aoffz adist basis inv_basis Source Code NeutralBeam Components Type Visibility Attributes Name Initial character(len=25), public :: name = '' Beam name integer, public :: shape Beam source shape 1=\"rectangular\", 2=\"circular\" real(kind=Float64), public :: widy Half width of source in y direction real(kind=Float64), public :: widz Half height of source in z direction real(kind=Float64), public :: focy Focal length in y direction real(kind=Float64), public :: focz Focal length in z direction real(kind=Float64), public :: einj NBI voltage  [kV] real(kind=Float64), public :: pinj NBI power    [MW] real(kind=Float64), public :: vinj NBI velocity [cm/s] real(kind=Float64), public :: alpha Z rotation not same as beam_grid alpha real(kind=Float64), public :: beta Tilt rotation not same as beam_grid beta real(kind=Float64), public, dimension(3) :: divy Energy dependent divergence in y direction real(kind=Float64), public, dimension(3) :: divz Energy dependent divergence in z direction real(kind=Float64), public, dimension(3) :: current_fractions Fractions of full, half, and third energy neutrals real(kind=Float64), public, dimension(3) :: src Position of source in beam grid coordinates [cm] real(kind=Float64), public, dimension(3) :: axis Beam centerline integer, public :: naperture Number of beam apertures integer, public, dimension(:), allocatable :: ashape Aperture shape 1=\"rectangular\", 2=\"circular\" real(kind=Float64), public, dimension(:), allocatable :: awidy Half width of the aperture(s) in y direction real(kind=Float64), public, dimension(:), allocatable :: awidz Half height of the aperture(s) in z direction real(kind=Float64), public, dimension(:), allocatable :: aoffy Horizontal (y) offset of the aperture(s) relative to the beam centerline [cm] real(kind=Float64), public, dimension(:), allocatable :: aoffz Vertical (z) offset of the aperture(s) relative to the beam centerline [cm] real(kind=Float64), public, dimension(:), allocatable :: adist Distance from the center of the beam source grid to the aperture(s) plane [cm] real(kind=Float64), public, dimension(3,3) :: basis Beam basis for converting from centerline coordinates to beam grid coordinates real(kind=Float64), public, dimension(3,3) :: inv_basis Inverse basis for reverse transfomation Source Code type NeutralBeam !+ Defines a neutral beam with +x defined to be into the plasma character ( 25 ) :: name = '' !+ Beam name integer :: shape !+ Beam source shape 1=\"rectangular\", 2=\"circular\" real ( Float64 ) :: widy !+ Half width of source in y direction real ( Float64 ) :: widz !+ Half height of source in z direction real ( Float64 ) :: focy !+ Focal length in y direction real ( Float64 ) :: focz !+ Focal length in z direction real ( Float64 ) :: einj !+ NBI voltage  [kV] real ( Float64 ) :: pinj !+ NBI power    [MW] real ( Float64 ) :: vinj !+ NBI velocity [cm/s] real ( Float64 ) :: alpha !+ Z rotation not same as [[libfida:beam_grid]] alpha real ( Float64 ) :: beta !+ Tilt rotation not same as [[libfida:beam_grid]] beta real ( Float64 ), dimension ( 3 ) :: divy !+ Energy dependent divergence in y direction real ( Float64 ), dimension ( 3 ) :: divz !+ Energy dependent divergence in z direction real ( Float64 ), dimension ( 3 ) :: current_fractions !+ Fractions of full, half, and third energy neutrals real ( Float64 ), dimension ( 3 ) :: src !+ Position of source in beam grid coordinates [cm] real ( Float64 ), dimension ( 3 ) :: axis !+ Beam centerline integer :: naperture !+ Number of beam apertures integer , dimension (:), allocatable :: ashape !+ Aperture shape 1=\"rectangular\", 2=\"circular\" real ( Float64 ), dimension (:), allocatable :: awidy !+ Half width of the aperture(s) in y direction real ( Float64 ), dimension (:), allocatable :: awidz !+ Half height of the aperture(s) in z direction real ( Float64 ), dimension (:), allocatable :: aoffy !+ Horizontal (y) offset of the aperture(s) relative to the beam centerline [cm] real ( Float64 ), dimension (:), allocatable :: aoffz !+ Vertical (z) offset of the aperture(s) relative to the beam centerline [cm] real ( Float64 ), dimension (:), allocatable :: adist !+ Distance from the center of the beam source grid to the aperture(s) plane [cm] real ( Float64 ), dimension ( 3 , 3 ) :: basis !+ Beam basis for converting from centerline coordinates to beam grid coordinates real ( Float64 ), dimension ( 3 , 3 ) :: inv_basis !+ Inverse basis for reverse transfomation end type NeutralBeam","tags":"","loc":"type/neutralbeam.html","title":"NeutralBeam – FIDASIM "},{"text":"type, public :: AtomicCrossSection Defines a n/m-resolved atomic cross section table Inherited by type~~atomiccrosssection~~InheritedByGraph type~atomiccrosssection AtomicCrossSection type~atomictables AtomicTables type~atomictables->type~atomiccrosssection H_H_cx_cross Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nenergy logemin logemax n_max m_max dlogE minlog_cross log_cross Source Code AtomicCrossSection Components Type Visibility Attributes Name Initial integer, public :: nenergy = 1 Number of beam energies real(kind=Float64), public :: logemin = 0.d0 Log-10 minimum energy real(kind=Float64), public :: logemax = 0.d0 Log-10 maximum energy integer, public :: n_max = nlevs Number of initial atomic energy levels integer, public :: m_max = nlevs Number of final atomic energy levels real(kind=Float64), public :: dlogE = 0.d0 Log-10 energy spacing real(kind=Float64), public :: minlog_cross Log-10 minimum cross section real(kind=Float64), public, dimension(:,:,:), allocatable :: log_cross Log-10 cross sections Source Code type AtomicCrossSection !+ Defines a n/m-resolved atomic cross section table integer :: nenergy = 1 !+ Number of beam energies real ( Float64 ) :: logemin = 0.d0 !+ Log-10 minimum energy real ( Float64 ) :: logemax = 0.d0 !+ Log-10 maximum energy integer :: n_max = nlevs !+ Number of initial atomic energy levels integer :: m_max = nlevs !+ Number of final atomic energy levels real ( Float64 ) :: dlogE = 0.d0 !+ Log-10 energy spacing real ( Float64 ) :: minlog_cross !+ Log-10 minimum cross section real ( Float64 ), dimension (:,:,:), allocatable :: log_cross !+ Log-10 cross sections end type AtomicCrossSection","tags":"","loc":"type/atomiccrosssection.html","title":"AtomicCrossSection – FIDASIM "},{"text":"type, public :: AtomicRates Defines a n/m-resolved atomic cross section table Inherited by type~~atomicrates~~InheritedByGraph type~atomicrates AtomicRates type~atomictables AtomicTables type~atomictables->type~atomicrates H_H_cx_rate Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nenergy logemin logemax ntemp logtmin logtmax n_max m_max dlogE dlogT minlog_rate ab log_rate Source Code AtomicRates Components Type Visibility Attributes Name Initial integer, public :: nenergy = 1 Number of beam energies real(kind=Float64), public :: logemin = 0.d0 Log-10 minimum energy real(kind=Float64), public :: logemax = 0.d0 Log-10 maximum energy integer, public :: ntemp = 1 Number of target temperatures real(kind=Float64), public :: logtmin = 0.d0 Log-10 minimum temperature real(kind=Float64), public :: logtmax = 0.d0 Log-10 maximum temperature integer, public :: n_max = nlevs Number of initial atomic energy levels integer, public :: m_max = nlevs Number of final atomic energy levels real(kind=Float64), public :: dlogE = 0.d0 Log-10 energy spacing real(kind=Float64), public :: dlogT = 0.d0 Log-10 temperature spacing real(kind=Float64), public :: minlog_rate = 0.d0 Log-10 minimum reaction rate real(kind=Float64), public, dimension(2) :: ab = 0.d0 Atomic mass of beam and thermal ions respectively [amu] real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: log_rate Log-10 beam-target rates Source Code type AtomicRates !+ Defines a n/m-resolved atomic cross section table integer :: nenergy = 1 !+ Number of beam energies real ( Float64 ) :: logemin = 0.d0 !+ Log-10 minimum energy real ( Float64 ) :: logemax = 0.d0 !+ Log-10 maximum energy integer :: ntemp = 1 !+ Number of target temperatures real ( Float64 ) :: logtmin = 0.d0 !+ Log-10 minimum temperature real ( Float64 ) :: logtmax = 0.d0 !+ Log-10 maximum temperature integer :: n_max = nlevs !+ Number of initial atomic energy levels integer :: m_max = nlevs !+ Number of final atomic energy levels real ( Float64 ) :: dlogE = 0.d0 !+ Log-10 energy spacing real ( Float64 ) :: dlogT = 0.d0 !+ Log-10 temperature spacing real ( Float64 ) :: minlog_rate = 0.d0 !+ Log-10 minimum reaction rate real ( Float64 ), dimension ( 2 ) :: ab = 0.d0 !+ Atomic mass of beam and thermal ions respectively [amu] real ( Float64 ), dimension (:,:,:,:,:), allocatable :: log_rate !+ Log-10 beam-target rates end type AtomicRates","tags":"","loc":"type/atomicrates.html","title":"AtomicRates – FIDASIM "},{"text":"type, public :: AtomicTransitions Defines an atomic table for populating and de-populating reaction rates Inherited by type~~atomictransitions~~InheritedByGraph type~atomictransitions AtomicTransitions type~atomictables AtomicTables type~atomictables->type~atomictransitions H_H, H_e, H_Aq Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nenergy logemin logemax ntemp logtmin logtmax n_max m_max dlogE dlogT minlog_pop minlog_depop ab log_pop log_depop Source Code AtomicTransitions Components Type Visibility Attributes Name Initial integer, public :: nenergy = 1 Number of beam energies real(kind=Float64), public :: logemin = 0.d0 Log-10 minimum energy real(kind=Float64), public :: logemax = 0.d0 Log-10 maximum energy integer, public :: ntemp = 1 Number of target temperatures real(kind=Float64), public :: logtmin = 0.d0 Log-10 minimum temperature real(kind=Float64), public :: logtmax = 0.d0 Log-10 maximum temperature integer, public :: n_max = nlevs Number of initial atomic energy levels integer, public :: m_max = nlevs Number of final atomic energy levels real(kind=Float64), public :: dlogE = 0.d0 Log-10 energy spacing real(kind=Float64), public :: dlogT = 0.d0 Log-10 temperature spacing real(kind=Float64), public :: minlog_pop = 0.d0 Log-10 minimum reaction rates for populating transistions real(kind=Float64), public :: minlog_depop = 0.d0 Log-10 minimum reaction rates for de-populating transistions real(kind=Float64), public, dimension(2) :: ab = 0.d0 Atomic mass of beam and thermal ions respectively [amu] real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: log_pop Log-10 reaction rates for populating transistions real(kind=Float64), public, dimension(:,:,:,:), allocatable :: log_depop Log-10 reaction rates for de-populating transistions Source Code type AtomicTransitions !+ Defines an atomic table for populating and de-populating reaction rates integer :: nenergy = 1 !+ Number of beam energies real ( Float64 ) :: logemin = 0.d0 !+ Log-10 minimum energy real ( Float64 ) :: logemax = 0.d0 !+ Log-10 maximum energy integer :: ntemp = 1 !+ Number of target temperatures real ( Float64 ) :: logtmin = 0.d0 !+ Log-10 minimum temperature real ( Float64 ) :: logtmax = 0.d0 !+ Log-10 maximum temperature integer :: n_max = nlevs !+ Number of initial atomic energy levels integer :: m_max = nlevs !+ Number of final atomic energy levels real ( Float64 ) :: dlogE = 0.d0 !+ Log-10 energy spacing real ( Float64 ) :: dlogT = 0.d0 !+ Log-10 temperature spacing real ( Float64 ) :: minlog_pop = 0.d0 !+ Log-10 minimum reaction rates for populating transistions real ( Float64 ) :: minlog_depop = 0.d0 !+ Log-10 minimum reaction rates for de-populating transistions real ( Float64 ), dimension ( 2 ) :: ab = 0.d0 !+ Atomic mass of beam and thermal ions respectively [amu] real ( Float64 ), dimension (:,:,:,:,:), allocatable :: log_pop !+ Log-10 reaction rates for populating transistions real ( Float64 ), dimension (:,:,:,:), allocatable :: log_depop !+ Log-10 reaction rates for de-populating transistions end type AtomicTransitions","tags":"","loc":"type/atomictransitions.html","title":"AtomicTransitions – FIDASIM "},{"text":"type, public :: NuclearRates Nuclear reaction rates Inherited by type~~nuclearrates~~InheritedByGraph type~nuclearrates NuclearRates type~atomictables AtomicTables type~atomictables->type~nuclearrates D_D Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nbranch nenergy logemin logemax ntemp logtmin logtmax dlogE dlogT minlog_rate bt_amu log_rate Source Code NuclearRates Components Type Visibility Attributes Name Initial integer, public :: nbranch = 1 Number of reaction branches integer, public :: nenergy = 1 Number of beam energies real(kind=Float64), public :: logemin = 0.d0 Log-10 minimum energy real(kind=Float64), public :: logemax = 0.d0 Log-10 maximum energy integer, public :: ntemp = 1 Number of target temperatures real(kind=Float64), public :: logtmin = 0.d0 Log-10 minimum temperature real(kind=Float64), public :: logtmax = 0.d0 Log-10 maximum temperature real(kind=Float64), public :: dlogE = 0.d0 Log-10 energy spacing real(kind=Float64), public :: dlogT = 0.d0 Log-10 temperature spacing real(kind=Float64), public :: minlog_rate = 0.d0 Log-10 minimum reaction rate real(kind=Float64), public, dimension(2) :: bt_amu = 0.d0 Isotope mass of beam and thermal ions respectively [amu] real(kind=Float64), public, dimension(:,:,:), allocatable :: log_rate Log-10 reaction rates: log_rate(energy, temperature, branch) Source Code type NuclearRates !+ Nuclear reaction rates integer :: nbranch = 1 !+ Number of reaction branches integer :: nenergy = 1 !+ Number of beam energies real ( Float64 ) :: logemin = 0.d0 !+ Log-10 minimum energy real ( Float64 ) :: logemax = 0.d0 !+ Log-10 maximum energy integer :: ntemp = 1 !+ Number of target temperatures real ( Float64 ) :: logtmin = 0.d0 !+ Log-10 minimum temperature real ( Float64 ) :: logtmax = 0.d0 !+ Log-10 maximum temperature real ( Float64 ) :: dlogE = 0.d0 !+ Log-10 energy spacing real ( Float64 ) :: dlogT = 0.d0 !+ Log-10 temperature spacing real ( Float64 ) :: minlog_rate = 0.d0 !+ Log-10 minimum reaction rate real ( Float64 ), dimension ( 2 ) :: bt_amu = 0.d0 !+ Isotope mass of beam and thermal ions respectively [amu] real ( Float64 ), dimension (:,:,:), allocatable :: log_rate !+ Log-10 reaction rates: log_rate(energy, temperature, branch) end type NuclearRates","tags":"","loc":"type/nuclearrates.html","title":"NuclearRates – FIDASIM "},{"text":"type, public :: AtomicTables Atomic tables for various types of interactions Inherits type~~atomictables~~InheritsGraph type~atomictables AtomicTables type~atomictransitions AtomicTransitions type~atomictables->type~atomictransitions H_H, H_e, H_Aq type~atomicrates AtomicRates type~atomictables->type~atomicrates H_H_cx_rate type~nuclearrates NuclearRates type~atomictables->type~nuclearrates D_D type~atomiccrosssection AtomicCrossSection type~atomictables->type~atomiccrosssection H_H_cx_cross Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables H_H_cx_cross H_H_cx_rate H_H H_e H_Aq einstein D_D Source Code AtomicTables Components Type Visibility Attributes Name Initial type( AtomicCrossSection ), public :: H_H_cx_cross Hydrogen-Hydrogen charge exchange n/m-resolved cross sections type( AtomicRates ), public :: H_H_cx_rate Hydrogen-Hydrogen charge exchange n/m-resolved beam-target rates type( AtomicTransitions ), public :: H_H Hydrogen-Hydrogen atomic transitions type( AtomicTransitions ), public :: H_e Hydrogen-Electron atomic transitions type( AtomicTransitions ), public :: H_Aq Hydrogen-Impurity atomic transitions real(kind=Float64), public, dimension(nlevs,nlevs) :: einstein Einstein coefficients for spontaneous emission type( NuclearRates ), public :: D_D Deuterium-Deuterium reaction rates Source Code type AtomicTables !+ Atomic tables for various types of interactions type ( AtomicCrossSection ) :: H_H_cx_cross !+ Hydrogen-Hydrogen charge exchange n/m-resolved cross sections type ( AtomicRates ) :: H_H_cx_rate !+ Hydrogen-Hydrogen charge exchange n/m-resolved beam-target rates type ( AtomicTransitions ) :: H_H !+ Hydrogen-Hydrogen atomic transitions type ( AtomicTransitions ) :: H_e !+ Hydrogen-Electron atomic transitions type ( AtomicTransitions ) :: H_Aq !+ Hydrogen-Impurity atomic transitions real ( Float64 ), dimension ( nlevs , nlevs ) :: einstein !+ Einstein coefficients for spontaneous emission type ( NuclearRates ) :: D_D !+ Deuterium-Deuterium reaction rates end type AtomicTables","tags":"","loc":"type/atomictables.html","title":"AtomicTables – FIDASIM "},{"text":"type, public :: LineOfSight Defines a line of sight Inherited by type~~lineofsight~~InheritedByGraph type~lineofsight LineOfSight type~spectralchords SpectralChords type~spectralchords->type~lineofsight los Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables sigma_pi spot_size lens axis lens_uvw axis_uvw Source Code LineOfSight Components Type Visibility Attributes Name Initial real(kind=Float64), public :: sigma_pi = 1.d0 Ratio of sigma to pi line intensity real(kind=Float64), public :: spot_size = 0.d0 Radius of spot size [cm] real(kind=Float64), public, dimension(3) :: lens = 0.d0 Lens location in beam grid coordinates real(kind=Float64), public, dimension(3) :: axis = 0.d0 Optical axis in beam grid coordinates real(kind=Float64), public, dimension(3) :: lens_uvw = 0.d0 Lens location in machine coordinates real(kind=Float64), public, dimension(3) :: axis_uvw = 0.d0 Optical axis in machine coordinates Source Code type LineOfSight !+ Defines a line of sight real ( Float64 ) :: sigma_pi = 1.d0 !+ Ratio of sigma to pi line intensity real ( Float64 ) :: spot_size = 0.d0 !+ Radius of spot size [cm] real ( Float64 ), dimension ( 3 ) :: lens = 0.d0 !+ Lens location in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: axis = 0.d0 !+ Optical axis in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: lens_uvw = 0.d0 !+ Lens location in machine coordinates real ( Float64 ), dimension ( 3 ) :: axis_uvw = 0.d0 !+ Optical axis in machine coordinates end type LineOfSight","tags":"","loc":"type/lineofsight.html","title":"LineOfSight – FIDASIM "},{"text":"type, public :: LOSElement Defines a element of a line of sight and cell intersection Inherited by type~~loselement~~InheritedByGraph type~loselement LOSElement type~losinters LOSInters type~losinters->type~loselement los_elem type~spectralchords SpectralChords type~spectralchords->type~losinters inter, cyl_inter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables id length Source Code LOSElement Components Type Visibility Attributes Name Initial integer, public :: id Line of sight index real(kind=Float64), public :: length Length of crossing Source Code type LOSElement !+ Defines a element of a line of sight and cell intersection integer :: id !+ Line of sight index real ( Float64 ) :: length !+ Length of crossing end type LOSElement","tags":"","loc":"type/loselement.html","title":"LOSElement – FIDASIM "},{"text":"type, public :: LOSInters Defines the channels that intersect a cell Inherits type~~losinters~~InheritsGraph type~losinters LOSInters type~loselement LOSElement type~losinters->type~loselement los_elem Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~losinters~~InheritedByGraph type~losinters LOSInters type~spectralchords SpectralChords type~spectralchords->type~losinters inter, cyl_inter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nchan los_elem Source Code LOSInters Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 Number of channels that intersect type( LOSElement ), public, dimension(:), allocatable :: los_elem Array of crossing Source Code type LOSInters !+ Defines the channels that intersect a cell integer :: nchan = 0 !+ Number of channels that intersect type ( LOSElement ), dimension (:), allocatable :: los_elem !+ Array of crossing end type LOSInters","tags":"","loc":"type/losinters.html","title":"LOSInters – FIDASIM "},{"text":"type, public :: SpectralChords Defines an spectral diagnostic system Inherits type~~spectralchords~~InheritsGraph type~spectralchords SpectralChords type~losinters LOSInters type~spectralchords->type~losinters inter, cyl_inter type~lineofsight LineOfSight type~spectralchords->type~lineofsight los type~loselement LOSElement type~losinters->type~loselement los_elem Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nchan ncell cyl_ncell los radius inter cyl_inter cell cyl_cell Source Code SpectralChords Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 Number of channels integer, public :: ncell = 0 Number of beam_grid cells with intersections integer, public :: cyl_ncell = 0 Number of pass_grid cells with intersections type( LineOfSight ), public, dimension(:), allocatable :: los Line of sight array real(kind=Float64), public, dimension(:), allocatable :: radius Radius of each line of sight type( LOSInters ), public, dimension(:,:,:), allocatable :: inter Array of LOS intersections with beam_grid type( LOSInters ), public, dimension(:,:,:), allocatable :: cyl_inter Array of LOS intersections with pass_grid integer, public, dimension(:), allocatable :: cell Linear indices of beam_grid that have intersections integer, public, dimension(:), allocatable :: cyl_cell Linear indices of pass_grid that have intersections Source Code type SpectralChords !+ Defines an spectral diagnostic system integer :: nchan = 0 !+ Number of channels integer :: ncell = 0 !+ Number of beam_grid cells with intersections integer :: cyl_ncell = 0 !+ Number of pass_grid cells with intersections type ( LineOfSight ), dimension (:), allocatable :: los !+ Line of sight array real ( Float64 ), dimension (:), allocatable :: radius !+ Radius of each line of sight type ( LOSInters ), dimension (:,:,:), allocatable :: inter !+ Array of LOS intersections with [[libfida:beam_grid]] type ( LOSInters ), dimension (:,:,:), allocatable :: cyl_inter !+ Array of LOS intersections with [[libfida:pass_grid]] integer , dimension (:), allocatable :: cell !+ Linear indices of beam_grid that have intersections integer , dimension (:), allocatable :: cyl_cell !+ Linear indices of pass_grid that have intersections end type SpectralChords","tags":"","loc":"type/spectralchords.html","title":"SpectralChords – FIDASIM "},{"text":"type, public :: BoundedPlane Defines a plane with a circular or rectangular boundary Inherited by type~~boundedplane~~InheritedByGraph type~boundedplane BoundedPlane type~npadetector NPADetector type~npadetector->type~boundedplane detector, aperture type~npachords NPAChords type~npachords->type~npadetector det Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables shape hh hw origin basis inv_basis Source Code BoundedPlane Components Type Visibility Attributes Name Initial integer, public :: shape = 0 Boundary shape 1=\"Rectangular\", 2=\"circular\" real(kind=Float64), public :: hh = 0.d0 Half height of boundary [cm] real(kind=Float64), public :: hw = 0.d0 Half width of boundary [cm] real(kind=Float64), public, dimension(3) :: origin = 0.d0 Origin of plane in machine coordinates real(kind=Float64), public, dimension(3,3) :: basis = 0.d0 Basis vectors basis(:,1) = u_1 is plane normal real(kind=Float64), public, dimension(3,3) :: inv_basis = 0.d0 Inverse basis Source Code type BoundedPlane !+ Defines a plane with a circular or rectangular boundary integer :: shape = 0 !+ Boundary shape 1=\"Rectangular\", 2=\"circular\" real ( Float64 ) :: hh = 0.d0 !+ Half height of boundary [cm] real ( Float64 ) :: hw = 0.d0 !+ Half width of boundary [cm] real ( Float64 ), dimension ( 3 ) :: origin = 0.d0 !+ Origin of plane in machine coordinates real ( Float64 ), dimension ( 3 , 3 ) :: basis = 0.d0 !+ Basis vectors basis(:,1) = u_1 is plane normal real ( Float64 ), dimension ( 3 , 3 ) :: inv_basis = 0.d0 !+ Inverse basis end type BoundedPlane","tags":"","loc":"type/boundedplane.html","title":"BoundedPlane – FIDASIM "},{"text":"type, public :: NPADetector Defines a NPA detector Inherits type~~npadetector~~InheritsGraph type~npadetector NPADetector type~boundedplane BoundedPlane type~npadetector->type~boundedplane detector, aperture Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~npadetector~~InheritedByGraph type~npadetector NPADetector type~npachords NPAChords type~npachords->type~npadetector det Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables detector aperture Source Code NPADetector Components Type Visibility Attributes Name Initial type( BoundedPlane ), public :: detector Detecting plane of NPA detector type( BoundedPlane ), public :: aperture Aperture plane of NPA detector Source Code type NPADetector !+ Defines a NPA detector type ( BoundedPlane ) :: detector !+ Detecting plane of NPA detector type ( BoundedPlane ) :: aperture !+ Aperture plane of NPA detector end type NPADetector","tags":"","loc":"type/npadetector.html","title":"NPADetector – FIDASIM "},{"text":"type, public :: NPAProbability Type to contain the probability of hitting a NPA detector Inherited by type~~npaprobability~~InheritedByGraph type~npaprobability NPAProbability type~npachords NPAChords type~npachords->type~npaprobability phit Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables p pitch eff_rd dir Source Code NPAProbability Components Type Visibility Attributes Name Initial real(kind=Float64), public :: p = 0.d0 Hit probability real(kind=Float64), public :: pitch = -2.d0 Pitch real(kind=Float64), public, dimension(3) :: eff_rd = 0.d0 Effective position of detector real(kind=Float64), public, dimension(3) :: dir = 0.d0 Trajectory direction Source Code type NPAProbability !+ Type to contain the probability of hitting a NPA detector real ( Float64 ) :: p = 0.d0 !+ Hit probability real ( Float64 ) :: pitch = - 2.d0 !+ Pitch real ( Float64 ), dimension ( 3 ) :: eff_rd = 0.d0 !+ Effective position of detector real ( Float64 ), dimension ( 3 ) :: dir = 0.d0 !+ Trajectory direction end type NPAProbability","tags":"","loc":"type/npaprobability.html","title":"NPAProbability – FIDASIM "},{"text":"type, public :: NPAChords Defines a NPA system Inherits type~~npachords~~InheritsGraph type~npachords NPAChords type~npaprobability NPAProbability type~npachords->type~npaprobability phit type~npadetector NPADetector type~npachords->type~npadetector det type~boundedplane BoundedPlane type~npadetector->type~boundedplane detector, aperture Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nchan det radius hit phit Source Code NPAChords Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 Number of channels type( NPADetector ), public, dimension(:), allocatable :: det NPA detector array real(kind=Float64), public, dimension(:), allocatable :: radius Radius [cm] logical, public, dimension(:,:,:), allocatable :: hit Indicates whether a particle can hit any NPA detector from a grid cell: hit(x,y,z) type( NPAProbability ), public, dimension(:,:,:,:), allocatable :: phit Probability of hitting a detector from a grid cell: phit(x,y,z,chan) Source Code type NPAChords !+ Defines a NPA system integer :: nchan = 0 !+ Number of channels type ( NPADetector ), dimension (:), allocatable :: det !+ NPA detector array real ( Float64 ), dimension (:), allocatable :: radius !+ Radius [cm] logical , dimension (:,:,:), allocatable :: hit !+ Indicates whether a particle can hit any NPA detector from a grid cell: hit(x,y,z) type ( NPAProbability ), dimension (:,:,:,:), allocatable :: phit !+ Probability of hitting a detector from a grid cell: phit(x,y,z,chan) end type NPAChords","tags":"","loc":"type/npachords.html","title":"NPAChords – FIDASIM "},{"text":"type, public :: NPAParticle Defines a NPA particle Inherited by type~~npaparticle~~InheritedByGraph type~npaparticle NPAParticle type~nparesults NPAResults type~nparesults->type~npaparticle part Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables detector class xi yi zi xf yf zf weight energy pitch Source Code NPAParticle Components Type Visibility Attributes Name Initial integer, public :: detector = 0 Detector NPA particle hit integer(kind=Int32), public :: class = 0 Orbit class id real(kind=Float64), public :: xi = 0.d0 Initial x position real(kind=Float64), public :: yi = 0.d0 Initial y position real(kind=Float64), public :: zi = 0.d0 Initial z position real(kind=Float64), public :: xf = 0.d0 Final x position real(kind=Float64), public :: yf = 0.d0 Final y position real(kind=Float64), public :: zf = 0.d0 Final z position real(kind=Float64), public :: weight = 0.d0 NPA particle weight real(kind=Float64), public :: energy = 0.d0 Birth Energy [keV] real(kind=Float64), public :: pitch = 0.d0 Birth Pitch Source Code type NPAParticle !+ Defines a NPA particle integer :: detector = 0 !+ Detector NPA particle hit integer ( Int32 ) :: class = 0 !+ Orbit class id real ( Float64 ) :: xi = 0.d0 !+ Initial x position real ( Float64 ) :: yi = 0.d0 !+ Initial y position real ( Float64 ) :: zi = 0.d0 !+ Initial z position real ( Float64 ) :: xf = 0.d0 !+ Final x position real ( Float64 ) :: yf = 0.d0 !+ Final y position real ( Float64 ) :: zf = 0.d0 !+ Final z position real ( Float64 ) :: weight = 0.d0 !+ NPA particle weight real ( Float64 ) :: energy = 0.d0 !+ Birth Energy [keV] real ( Float64 ) :: pitch = 0.d0 !+ Birth Pitch end type NPAParticle","tags":"","loc":"type/npaparticle.html","title":"NPAParticle – FIDASIM "},{"text":"type, public :: NPAResults MC NPA result structure Inherits type~~nparesults~~InheritsGraph type~nparesults NPAResults type~npaparticle NPAParticle type~nparesults->type~npaparticle part Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nchan npart nmax nenergy part energy flux Source Code NPAResults Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nchan = 0 Number of NPA channels integer(kind=Int32), public :: npart = 0 Number of particles that hit a detector integer(kind=Int32), public :: nmax = 1000000 Maximum allowed number of particles grows if necessary integer(kind=Int32), public :: nenergy = 122 Number of energy values type( NPAParticle ), public, dimension(:), allocatable :: part Array of NPA particles real(kind=Float64), public, dimension(:), allocatable :: energy Energy array [keV] real(kind=Float64), public, dimension(:,:,:), allocatable :: flux Neutral particle flux: flux(energy,chan, orbit_type) [neutrals/(s*dE)] Source Code type NPAResults !+ MC NPA result structure integer ( Int32 ) :: nchan = 0 !+ Number of NPA channels integer ( Int32 ) :: npart = 0 !+ Number of particles that hit a detector integer ( Int32 ) :: nmax = 1000000 !+ Maximum allowed number of particles grows if necessary integer ( Int32 ) :: nenergy = 122 !+ Number of energy values type ( NPAParticle ), dimension (:), allocatable :: part !+ Array of NPA particles real ( Float64 ), dimension (:), allocatable :: energy !+ Energy array [keV] real ( Float64 ), dimension (:,:,:), allocatable :: flux !+ Neutral particle flux: flux(energy,chan, orbit_type) [neutrals/(s*dE)] end type NPAResults","tags":"","loc":"type/nparesults.html","title":"NPAResults – FIDASIM "},{"text":"type, public :: BirthParticle Defines a Birth particle Inherited by type~~birthparticle~~InheritedByGraph type~birthparticle BirthParticle type~birthprofile BirthProfile type~birthprofile->type~birthparticle part Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables neut_type ind ri vi ri_gc weight energy pitch Source Code BirthParticle Components Type Visibility Attributes Name Initial integer, public :: neut_type = 0 Birth type (1=Full, 2=Half, 3=Third) integer(kind=Int32), public, dimension(3) :: ind = 0 Initial beam_grid indices real(kind=Float64), public, dimension(3) :: ri = 0.d0 Initial position in beam grid coordinates [cm] real(kind=Float64), public, dimension(3) :: vi = 0.d0 Initial velocity in beam grid coordinates [cm/s] real(kind=Float64), public, dimension(3) :: ri_gc = 0.d0 Initial guiding-center position in beam grid coordinates [cm] real(kind=Float64), public :: weight = 0.d0 NPA particle weight [fast-ions/s] real(kind=Float64), public :: energy = 0.d0 Birth Energy [keV] real(kind=Float64), public :: pitch = 0.d0 Birth Pitch w.r.t. the magnetic field Source Code type BirthParticle !+ Defines a Birth particle integer :: neut_type = 0 !+ Birth type (1=Full, 2=Half, 3=Third) integer ( Int32 ), dimension ( 3 ) :: ind = 0 !+ Initial [[libfida:beam_grid]] indices real ( Float64 ), dimension ( 3 ) :: ri = 0.d0 !+ Initial position in beam grid coordinates [cm] real ( Float64 ), dimension ( 3 ) :: vi = 0.d0 !+ Initial velocity in beam grid coordinates [cm/s] real ( Float64 ), dimension ( 3 ) :: ri_gc = 0.d0 !+ Initial guiding-center position in beam grid coordinates [cm] real ( Float64 ) :: weight = 0.d0 !+ NPA particle weight [fast-ions/s] real ( Float64 ) :: energy = 0.d0 !+ Birth Energy [keV] real ( Float64 ) :: pitch = 0.d0 !+ Birth Pitch w.r.t. the magnetic field end type BirthParticle","tags":"","loc":"type/birthparticle.html","title":"BirthParticle – FIDASIM "},{"text":"type, public :: BirthProfile Birth profile structure Inherits type~~birthprofile~~InheritsGraph type~birthprofile BirthProfile type~birthparticle BirthParticle type~birthprofile->type~birthparticle part Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables cnt part dens Source Code BirthProfile Components Type Visibility Attributes Name Initial integer, public :: cnt = 1 Particle counter type( BirthParticle ), public, dimension(:), allocatable :: part Array of birth particles real(kind=Float64), public, dimension(:,:,:,:), allocatable :: dens Birth density: dens(neutral_type,x,y,z) [fast-ions/(s*cm&#94;3)] Source Code type BirthProfile !+ Birth profile structure integer :: cnt = 1 !+ Particle counter type ( BirthParticle ), dimension (:), allocatable :: part !+ Array of birth particles real ( Float64 ), dimension (:,:,:,:), allocatable :: dens !+ Birth density: dens(neutral_type,x,y,z) [fast-ions/(s*cm&#94;3)] end type BirthProfile","tags":"","loc":"type/birthprofile.html","title":"BirthProfile – FIDASIM "},{"text":"type, public :: Spectra Spectra storage structure Contents Variables brems full half third dcx halo cold fida pfida Source Code Spectra Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:), allocatable :: brems Bremsstruhlung: brems(lambda,chan) real(kind=Float64), public, dimension(:,:), allocatable :: full Full energy beam emission: full(lambda,chan) real(kind=Float64), public, dimension(:,:), allocatable :: half Half energy beam emission: half(lambda,chan) real(kind=Float64), public, dimension(:,:), allocatable :: third Third energy beam emission: third(lambda,chan) real(kind=Float64), public, dimension(:,:), allocatable :: dcx Direct CX emission: dcx(lambda,chan) real(kind=Float64), public, dimension(:,:), allocatable :: halo Thermal halo emission: halo(lambda,chan) real(kind=Float64), public, dimension(:,:), allocatable :: cold Cold D-alpha emission: cold(lambda,chan) real(kind=Float64), public, dimension(:,:,:), allocatable :: fida Active FIDA emission: fida(lambda,chan,orbit_type) real(kind=Float64), public, dimension(:,:,:), allocatable :: pfida Passive FIDA emission: pfida(lambda,chan,orbit_type) Source Code type Spectra !+ Spectra storage structure real ( Float64 ), dimension (:,:), allocatable :: brems !+ Bremsstruhlung: brems(lambda,chan) real ( Float64 ), dimension (:,:), allocatable :: full !+ Full energy beam emission: full(lambda,chan) real ( Float64 ), dimension (:,:), allocatable :: half !+ Half energy beam emission: half(lambda,chan) real ( Float64 ), dimension (:,:), allocatable :: third !+ Third energy beam emission: third(lambda,chan) real ( Float64 ), dimension (:,:), allocatable :: dcx !+ Direct CX emission: dcx(lambda,chan) real ( Float64 ), dimension (:,:), allocatable :: halo !+ Thermal halo emission: halo(lambda,chan) real ( Float64 ), dimension (:,:), allocatable :: cold !+ Cold D-alpha emission: cold(lambda,chan) real ( Float64 ), dimension (:,:,:), allocatable :: fida !+ Active FIDA emission: fida(lambda,chan,orbit_type) real ( Float64 ), dimension (:,:,:), allocatable :: pfida !+ Passive FIDA emission: pfida(lambda,chan,orbit_type) end type Spectra","tags":"","loc":"type/spectra.html","title":"Spectra – FIDASIM "},{"text":"type, public :: NeutronRate Neutron storage structure Contents Variables rate weight emis Source Code NeutronRate Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:), allocatable :: rate Neutron rate: rate(orbit_type) [neutrons/sec] real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: weight Neutron rate weight: weight(E,p,R,Z,Phi) real(kind=Float64), public, dimension(:,:,:), allocatable :: emis Neutron emissivity: emis(R,Z,Phi) Source Code type NeutronRate !+ Neutron storage structure real ( Float64 ), dimension (:), allocatable :: rate !+ Neutron rate: rate(orbit_type) [neutrons/sec] real ( Float64 ), dimension (:,:,:,:,:), allocatable :: weight !+ Neutron rate weight: weight(E,p,R,Z,Phi) real ( Float64 ), dimension (:,:,:), allocatable :: emis !+ Neutron emissivity: emis(R,Z,Phi) end type NeutronRate","tags":"","loc":"type/neutronrate.html","title":"NeutronRate – FIDASIM "},{"text":"type, public :: NeutralDensity Neutral density structure Contents Variables full half third dcx halo Source Code NeutralDensity Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:,:,:), allocatable :: full Full energy neutral density: full(lev,x,y,z) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: half Half energy neutral density: half(lev,x,y,z) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: third Third energy neutral density: third(lev,x,y,z) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: dcx Direct CX neutral density: dcx(lev,x,y,z) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: halo Thermal halo neutral density: dens(lev,x,y,z) Source Code type NeutralDensity !+ Neutral density structure real ( Float64 ), dimension (:,:,:,:), allocatable :: full !+ Full energy neutral density: full(lev,x,y,z) real ( Float64 ), dimension (:,:,:,:), allocatable :: half !+ Half energy neutral density: half(lev,x,y,z) real ( Float64 ), dimension (:,:,:,:), allocatable :: third !+ Third energy neutral density: third(lev,x,y,z) real ( Float64 ), dimension (:,:,:,:), allocatable :: dcx !+ Direct CX neutral density: dcx(lev,x,y,z) real ( Float64 ), dimension (:,:,:,:), allocatable :: halo !+ Thermal halo neutral density: dens(lev,x,y,z) end type NeutralDensity","tags":"","loc":"type/neutraldensity.html","title":"NeutralDensity – FIDASIM "},{"text":"type, public :: FIDAWeights FIDA weights structure Contents Variables mean_f weight Source Code FIDAWeights Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:,:), allocatable :: mean_f Estimate of mean fast-ion distribution function \"seen\" by LOS: mean_f(E,p,chan) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: weight FIDA weight function: weight(lambda,E,p,chan) Source Code type FIDAWeights !+ FIDA weights structure real ( Float64 ), dimension (:,:,:), allocatable :: mean_f !+ Estimate of mean fast-ion distribution function \"seen\" by LOS: mean_f(E,p,chan) real ( Float64 ), dimension (:,:,:,:), allocatable :: weight !+ FIDA weight function: weight(lambda,E,p,chan) end type FIDAWeights","tags":"","loc":"type/fidaweights.html","title":"FIDAWeights – FIDASIM "},{"text":"type, public :: NPAWeights NPA weights structure Contents Variables attenuation cx emissivity weight flux Source Code NPAWeights Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: attenuation Attenuation fraction: attenuation(E,x,y,z,chan) real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: cx Charge Exchange reaction rates: cx(E,x,y,z,chan) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: emissivity Emissivity: emissivity(x,y,z,chan) [neutrals/(s*dV)] real(kind=Float64), public, dimension(:,:,:), allocatable :: weight NPA weight function: weight(E,p,chan) [neutrals/(s fast-ion dE*dP)] real(kind=Float64), public, dimension(:,:), allocatable :: flux Neutral particle flux: flux(E,chan) [neutrals/(s*dE)] Source Code type NPAWeights !+ NPA weights structure real ( Float64 ), dimension (:,:,:,:,:), allocatable :: attenuation !+ Attenuation fraction: attenuation(E,x,y,z,chan) real ( Float64 ), dimension (:,:,:,:,:), allocatable :: cx !+ Charge Exchange reaction rates: cx(E,x,y,z,chan) real ( Float64 ), dimension (:,:,:,:), allocatable :: emissivity !+ Emissivity: emissivity(x,y,z,chan) [neutrals/(s*dV)] real ( Float64 ), dimension (:,:,:), allocatable :: weight !+ NPA weight function: weight(E,p,chan) [neutrals/(s*fast-ion*dE*dP)] real ( Float64 ), dimension (:,:), allocatable :: flux !+ Neutral particle flux: flux(E,chan) [neutrals/(s*dE)] end type NPAWeights","tags":"","loc":"type/npaweights.html","title":"NPAWeights – FIDASIM "},{"text":"type, public :: SimulationInputs Simulation settings structure Contents Variables shot_number time runid result_dir tables_file geometry_file equilibrium_file distribution_file neutrals_file seed n_fida n_pfida n_npa n_pnpa n_nbi n_dcx n_halo n_birth calc_spec calc_beam calc_nbi_dens calc_dcx_dens calc_halo_dens calc_brems calc_bes calc_dcx calc_halo calc_cold calc_fida calc_pfida tot_spectra load_neutrals calc_npa calc_pnpa calc_fida_wght calc_npa_wght calc_birth calc_neutron flr split verbose ab impurity_charge ai dist_type nlambda dlambda lambdamin lambdamax ne_wght np_wght nphi_wght nlambda_wght emax_wght lambdamin_wght lambdamax_wght Source Code SimulationInputs Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: shot_number Shot Number real(kind=Float64), public :: time Shot time [s] character(len=charlim), public :: runid = '' FIDASIM run ID character(len=charlim), public :: result_dir = '' Result directory character(len=charlim), public :: tables_file = '' Atomic tables file character(len=charlim), public :: geometry_file = '' FIDASIM input file containing geometric quantities character(len=charlim), public :: equilibrium_file = '' FIDASIM input file containing the plasma parameters and fields character(len=charlim), public :: distribution_file = '' FIDASIM input file containing the fast-ion distribution character(len=charlim), public :: neutrals_file = '' FIDASIM output/input file containing beam neutral density.\n Used when load_neutrals is set. integer, public :: seed Random number generator seed integer(kind=Int64), public :: n_fida Number of Active FIDA mc markers integer(kind=Int64), public :: n_pfida Number of Passive FIDA mc markers integer(kind=Int64), public :: n_npa Number of Passiv NPA mc markers integer(kind=Int64), public :: n_pnpa Number of Passive NPA mc markers integer(kind=Int64), public :: n_nbi Number of neutral beam mc markers integer(kind=Int64), public :: n_dcx Number of direct charge exchange (DCX) mc markers integer(kind=Int64), public :: n_halo Number of halo mc markers integer(kind=Int64), public :: n_birth Number of birth particles per n_nbi integer(kind=Int32), public :: calc_spec Calculate spectra: 0 = off, 1=on integer(kind=Int32), public :: calc_beam Calculate beam densities: 0 = off, 1=on integer(kind=Int32), public :: calc_nbi_dens Calculate neutral beam density: 0 = off, 1=on integer(kind=Int32), public :: calc_dcx_dens Calculate Direct Charge Exchange (DCX) density: 0 = off, 1=on integer(kind=Int32), public :: calc_halo_dens Calculate Thermal Halo density: 0 = off, 1=on integer(kind=Int32), public :: calc_brems Calculate bremmstruhlung: 0 = off, 1=on integer(kind=Int32), public :: calc_bes Calculate NBI: 0 = off, 1=on integer(kind=Int32), public :: calc_dcx Calculate DCX: 0 = off, 1=on integer(kind=Int32), public :: calc_halo Calculate Halo: 0 = off, 1=on integer(kind=Int32), public :: calc_cold Calculate Cold D-alpha: 0 = off, 1=on integer(kind=Int32), public :: calc_fida Calculate Active FIDA: 0 = off, 1=on integer(kind=Int32), public :: calc_pfida Calculate Passive FIDA: 0 = off, 1=on integer(kind=Int32), public :: tot_spectra Total number of spectral switches on integer(kind=Int32), public :: load_neutrals Load neutrals from file: 0 = off, 1=on integer(kind=Int32), public :: calc_npa Calculate Active NPA: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: calc_pnpa Calculate Passive NPA: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: calc_fida_wght Calculate FIDA weight: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: calc_npa_wght Calculate NPA weights: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: calc_birth Calculate birth profile: 0 = off, 1=on integer(kind=Int32), public :: calc_neutron Calculate neutron flux: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: flr FLR correction: 0=off, 1=1st order(vxb/omega), 2=2nd order correction integer(kind=Int32), public :: split Split signals by fast ion class: 0=off, 1=on integer(kind=Int32), public :: verbose real(kind=Float64), public :: ab Atomic mass of beam neutrals integer(kind=Int32), public :: impurity_charge Impurity proton number real(kind=Float64), public :: ai Atomic mass of thermal ions integer(kind=Int32), public :: dist_type Type of fast-ion distribution integer(kind=Int32), public :: nlambda Number of wavelength to calculate real(kind=Float64), public :: dlambda Wavelength spacing [nm] real(kind=Float64), public :: lambdamin Minimum wavelength [nm] real(kind=Float64), public :: lambdamax Maximum wavelength [nm] integer(kind=Int32), public :: ne_wght Number of energies in weight functions integer(kind=Int32), public :: np_wght Number of pitches in weight functions integer(kind=Int32), public :: nphi_wght Number of gyro-angles to average over in weight functions integer(kind=Int32), public :: nlambda_wght Number of wavelength to calculate in weight functions real(kind=Float64), public :: emax_wght Maximum energy in weight functions [keV] real(kind=Float64), public :: lambdamin_wght Minimum wavelength in weight functions [nm] real(kind=Float64), public :: lambdamax_wght Maximum wavelength in weight functions [nm] Source Code type SimulationInputs !+ Simulation settings structure integer ( Int32 ) :: shot_number !+ Shot Number real ( Float64 ) :: time !+ Shot time [s] character ( charlim ) :: runid = '' !+ FIDASIM run ID character ( charlim ) :: result_dir = '' !+ Result directory character ( charlim ) :: tables_file = '' !+ Atomic tables file character ( charlim ) :: geometry_file = '' !+ FIDASIM input file containing geometric quantities character ( charlim ) :: equilibrium_file = '' !+ FIDASIM input file containing the plasma parameters and fields character ( charlim ) :: distribution_file = '' !+ FIDASIM input file containing the fast-ion distribution character ( charlim ) :: neutrals_file = '' !+ FIDASIM output/input file containing beam neutral density. !+ Used when [[SimulationInputs:load_neutrals]] is set. !! Random Number Generator Settings integer :: seed !+ Random number generator seed !! Monte Carlo settings integer ( Int64 ) :: n_fida !+ Number of Active FIDA mc markers integer ( Int64 ) :: n_pfida !+ Number of Passive FIDA mc markers integer ( Int64 ) :: n_npa !+ Number of Passiv NPA mc markers integer ( Int64 ) :: n_pnpa !+ Number of Passive NPA mc markers integer ( Int64 ) :: n_nbi !+ Number of neutral beam mc markers integer ( Int64 ) :: n_dcx !+ Number of direct charge exchange (DCX) mc markers integer ( Int64 ) :: n_halo !+ Number of halo mc markers integer ( Int64 ) :: n_birth !+ Number of birth particles per [[SimulationInputs:n_nbi]] !! Simulation switches integer ( Int32 ) :: calc_spec !+ Calculate spectra: 0 = off, 1=on integer ( Int32 ) :: calc_beam !+ Calculate beam densities: 0 = off, 1=on integer ( Int32 ) :: calc_nbi_dens !+ Calculate neutral beam density: 0 = off, 1=on integer ( Int32 ) :: calc_dcx_dens !+ Calculate Direct Charge Exchange (DCX) density: 0 = off, 1=on integer ( Int32 ) :: calc_halo_dens !+ Calculate Thermal Halo density: 0 = off, 1=on integer ( Int32 ) :: calc_brems !+ Calculate bremmstruhlung: 0 = off, 1=on integer ( Int32 ) :: calc_bes !+ Calculate NBI: 0 = off, 1=on integer ( Int32 ) :: calc_dcx !+ Calculate DCX: 0 = off, 1=on integer ( Int32 ) :: calc_halo !+ Calculate Halo: 0 = off, 1=on integer ( Int32 ) :: calc_cold !+ Calculate Cold D-alpha: 0 = off, 1=on integer ( Int32 ) :: calc_fida !+ Calculate Active FIDA: 0 = off, 1=on integer ( Int32 ) :: calc_pfida !+ Calculate Passive FIDA: 0 = off, 1=on integer ( Int32 ) :: tot_spectra !+ Total number of spectral switches on integer ( Int32 ) :: load_neutrals !+ Load neutrals from file: 0 = off, 1=on integer ( Int32 ) :: calc_npa !+ Calculate Active NPA: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: calc_pnpa !+ Calculate Passive NPA: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: calc_fida_wght !+ Calculate FIDA weight: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: calc_npa_wght !+ Calculate NPA weights: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: calc_birth !+ Calculate birth profile: 0 = off, 1=on integer ( Int32 ) :: calc_neutron !+ Calculate neutron flux: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: flr !+ FLR correction: 0=off, 1=1st order(vxb/omega), 2=2nd order correction integer ( Int32 ) :: split !+ Split signals by fast ion class: 0=off, 1=on integer ( Int32 ) :: verbose !+ Verbosity: <0 = off++, 0 = off, 1=on, 2=on++ !! Neutral Beam Settings real ( Float64 ) :: ab !+ Atomic mass of beam neutrals !! Plasma parameters integer ( Int32 ) :: impurity_charge !+ Impurity proton number real ( Float64 ) :: ai !+ Atomic mass of thermal ions !! Distribution settings integer ( Int32 ) :: dist_type !+ Type of fast-ion distribution !! Spectrum parameters integer ( Int32 ) :: nlambda !+ Number of wavelength to calculate real ( Float64 ) :: dlambda !+ Wavelength spacing [nm] real ( Float64 ) :: lambdamin !+ Minimum wavelength [nm] real ( Float64 ) :: lambdamax !+ Maximum wavelength [nm] !! Weight function settings integer ( Int32 ) :: ne_wght !+ Number of energies in weight functions integer ( Int32 ) :: np_wght !+ Number of pitches in weight functions integer ( Int32 ) :: nphi_wght !+ Number of gyro-angles to average over in weight functions integer ( Int32 ) :: nlambda_wght !+ Number of wavelength to calculate in weight functions real ( Float64 ) :: emax_wght !+ Maximum energy in weight functions [keV] real ( Float64 ) :: lambdamin_wght !+ Minimum wavelength in weight functions [nm] real ( Float64 ) :: lambdamax_wght !+ Maximum wavelength in weight functions [nm] end type SimulationInputs","tags":"","loc":"type/simulationinputs.html","title":"SimulationInputs – FIDASIM "},{"text":"type, public :: ParticleTrack Stores properties seen when traveling through a 3D grid Contents Variables time flux ind pos Source Code ParticleTrack Components Type Visibility Attributes Name Initial real(kind=Float64), public :: time = 0.d0 Time/distance/... in cell real(kind=Float64), public :: flux = 0.d0 Flux/density/... in cell integer(kind=Int32), public, dimension(3) :: ind = 0 Indices of cell real(kind=Float64), public, dimension(3) :: pos = 0.d0 Midpoint of track in cell [cm] Source Code type ParticleTrack !+ Stores properties seen when traveling through a 3D grid real ( Float64 ) :: time = 0.d0 !+ Time/distance/... in cell real ( Float64 ) :: flux = 0.d0 !+ Flux/density/... in cell integer ( Int32 ), dimension ( 3 ) :: ind = 0 !+ Indices of cell real ( Float64 ), dimension ( 3 ) :: pos = 0.d0 !+ Midpoint of track in cell [cm] end type ParticleTrack","tags":"","loc":"type/particletrack.html","title":"ParticleTrack – FIDASIM "},{"text":"type, public :: GyroSurface Surface containing the fast-ion velocity vectors for all values of the\n gyro-angle. It takes the form of a hyperboloid (x(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(cos(\\gamma + \\pi/2) - \\omega_i t sin(\\gamma + \\pi/2)) (y(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(sin(\\gamma + \\pi/2) + \\omega_i t cos(\\gamma + \\pi/2)) (z(\\gamma,t) = \\alpha \\omega_i \\rm{pitch} t where \\gamma is the gyro-angle, \\omega_i is the ion\n gyro-frequency and \\alpha = V/\\omega_i Contents Variables v omega axes center A basis Source Code GyroSurface Components Type Visibility Attributes Name Initial real(kind=Float64), public :: v = 0.d0 Particle speed real(kind=Float64), public :: omega = 0.d0 Ion gyro-frequency real(kind=Float64), public, dimension(3) :: axes = 0.d0 Semi-axes of the hyperboloid, i.e. a, b, c coefficients real(kind=Float64), public, dimension(3) :: center = 0.d0 Center of the gyrosurface real(kind=Float64), public, dimension(3,3) :: A = 0.d0 Coefficients of quartic surface i.e. basis*diagm(1/a&#94;2,1/b&#94;2,1/c&#94;2)*basis' real(kind=Float64), public, dimension(3,3) :: basis = 0.d0 Basis of coordinate system of gyrosurface Source Code type GyroSurface !+ Surface containing the fast-ion velocity vectors for all values of the !+ gyro-angle. It takes the form of a hyperboloid !+ (x(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(cos(\\gamma + \\pi/2) - \\omega_i t sin(\\gamma + \\pi/2))  !+ (y(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(sin(\\gamma + \\pi/2) + \\omega_i t cos(\\gamma + \\pi/2))  !+ (z(\\gamma,t) = \\alpha \\omega_i \\rm{pitch} t !+ where \\gamma is the gyro-angle, \\omega_i is the ion !+ gyro-frequency and \\alpha = V/\\omega_i  real ( Float64 ) :: v = 0.d0 !+ Particle speed real ( Float64 ) :: omega = 0.d0 !+ Ion gyro-frequency real ( Float64 ), dimension ( 3 ) :: axes = 0.d0 !+ Semi-axes of the hyperboloid, i.e. a, b, c coefficients real ( Float64 ), dimension ( 3 ) :: center = 0.d0 !+ Center of the gyrosurface real ( Float64 ), dimension ( 3 , 3 ) :: A = 0.d0 !+ Coefficients of quartic surface i.e. `basis*diagm(1/a&#94;2,1/b&#94;2,1/c&#94;2)*basis'` real ( Float64 ), dimension ( 3 , 3 ) :: basis = 0.d0 !+ Basis of coordinate system of gyrosurface end type GyroSurface","tags":"","loc":"type/gyrosurface.html","title":"GyroSurface – FIDASIM "},{"text":"type, public :: rng_type Random Number Generator Derived Type Contents Variables seed state Source Code rng_type Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: seed integer(kind=Int32), public, dimension(ns) :: state Source Code type :: rng_type !+ Random Number Generator Derived Type integer ( Int32 ) :: seed integer ( Int32 ), dimension ( ns ) :: state end type rng_type","tags":"","loc":"type/rng_type.html","title":"rng_type – FIDASIM "},{"text":"type, public :: SparseArray Contents Variables nnz nd dims inds vals Source Code SparseArray Components Type Visibility Attributes Name Initial integer, public :: nnz = 0 Number of non-zero elements integer, public :: nd = 0 Number of dimensions integer, public, dimension(:), allocatable :: dims Dimensions of array integer, public, dimension(:), allocatable :: inds Linear index of non-zero elements real(kind=Float64), public, dimension(:), allocatable :: vals Array values Source Code type SparseArray integer :: nnz = 0 !+ Number of non-zero elements integer :: nd = 0 !+ Number of dimensions integer , dimension (:), allocatable :: dims !+ Dimensions of array integer , dimension (:), allocatable :: inds !+ Linear index of non-zero elements real ( Float64 ), dimension (:), allocatable :: vals !+ Array values end type SparseArray","tags":"","loc":"type/sparsearray.html","title":"SparseArray – FIDASIM "},{"text":"public recursive function my_rank() result(n) Arguments None Return Value integer Called by proc~~my_rank~~CalledByGraph proc~my_rank my_rank proc~write_birth_profile write_birth_profile proc~write_birth_profile->proc~my_rank proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~my_rank proc~get_nlaunch get_nlaunch proc~fida_weights_mc->proc~get_nlaunch proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~my_rank proc~neutron_mc neutron_mc proc~neutron_mc->proc~my_rank proc~rng_init rng_init proc~rng_init->proc~my_rank program~fidasim fidasim program~fidasim->proc~my_rank program~fidasim->proc~write_birth_profile program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~neutron_mc proc~write_npa write_npa program~fidasim->proc~write_npa proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~read_inputs read_inputs program~fidasim->proc~read_inputs proc~pnpa_f pnpa_f program~fidasim->proc~pnpa_f proc~dcx dcx program~fidasim->proc~dcx proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~halo halo program~fidasim->proc~halo proc~pfida_f pfida_f program~fidasim->proc~pfida_f proc~write_npa->proc~my_rank proc~neutron_f->proc~my_rank proc~npa_weights->proc~my_rank proc~read_inputs->proc~my_rank proc~get_nlaunch->proc~rng_init proc~get_nlaunch_pass_grid get_nlaunch_pass_grid proc~get_nlaunch_pass_grid->proc~rng_init proc~pnpa_f->proc~get_nlaunch_pass_grid proc~dcx->proc~get_nlaunch proc~fida_f->proc~get_nlaunch proc~npa_f->proc~get_nlaunch proc~halo->proc~get_nlaunch proc~pfida_f->proc~get_nlaunch_pass_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/my_rank.html","title":"my_rank – FIDASIM"},{"text":"public recursive function num_ranks() result(n) Arguments None Return Value integer Called by proc~~num_ranks~~CalledByGraph proc~num_ranks num_ranks proc~write_birth_profile write_birth_profile proc~write_birth_profile->proc~num_ranks program~fidasim fidasim program~fidasim->proc~num_ranks program~fidasim->proc~write_birth_profile proc~write_npa write_npa program~fidasim->proc~write_npa proc~write_npa->proc~num_ranks Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/num_ranks.html","title":"num_ranks – FIDASIM"},{"text":"public subroutine init_mpi() Uses mpi proc~~init_mpi~~UsesGraph proc~init_mpi init_mpi mpi mpi proc~init_mpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~init_mpi~~CallsGraph proc~init_mpi init_mpi mpi_comm_size mpi_comm_size proc~init_mpi->mpi_comm_size mpi_init_thread mpi_init_thread proc~init_mpi->mpi_init_thread mpi_comm_rank mpi_comm_rank proc~init_mpi->mpi_comm_rank mpi_init mpi_init proc~init_mpi->mpi_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~init_mpi~~CalledByGraph proc~init_mpi init_mpi program~fidasim fidasim program~fidasim->proc~init_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_mpi.html","title":"init_mpi – FIDASIM"},{"text":"public subroutine cleanup_mpi() Uses mpi proc~~cleanup_mpi~~UsesGraph proc~cleanup_mpi cleanup_mpi mpi mpi proc~cleanup_mpi->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~cleanup_mpi~~CallsGraph proc~cleanup_mpi cleanup_mpi mpi_finalize mpi_finalize proc~cleanup_mpi->mpi_finalize mpi_barrier mpi_barrier proc~cleanup_mpi->mpi_barrier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~cleanup_mpi~~CalledByGraph proc~cleanup_mpi cleanup_mpi program~fidasim fidasim program~fidasim->proc~cleanup_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cleanup_mpi.html","title":"cleanup_mpi – FIDASIM"},{"text":"public recursive subroutine parallel_sum_d0(A) Uses mpi proc~~parallel_sum_d0~~UsesGraph proc~parallel_sum_d0 parallel_sum_d0 mpi mpi proc~parallel_sum_d0->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout) :: A Calls proc~~parallel_sum_d0~~CallsGraph proc~parallel_sum_d0 parallel_sum_d0 mpi_allreduce mpi_allreduce proc~parallel_sum_d0->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~parallel_sum_d0~~CalledByGraph proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum parallel_sum interface~parallel_sum->proc~parallel_sum_d0 proc~pnpa_f pnpa_f proc~pnpa_f->interface~parallel_sum proc~dcx_spec dcx_spec proc~dcx_spec->interface~parallel_sum proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->interface~parallel_sum proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~parallel_sum proc~npa_mc npa_mc proc~npa_mc->interface~parallel_sum proc~ndmc ndmc proc~ndmc->interface~parallel_sum proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~parallel_sum proc~nbi_spec nbi_spec proc~nbi_spec->interface~parallel_sum proc~npa_weights npa_weights proc~npa_weights->interface~parallel_sum proc~fida_mc fida_mc proc~fida_mc->interface~parallel_sum proc~pfida_f pfida_f proc~pfida_f->interface~parallel_sum proc~pnpa_mc pnpa_mc proc~pnpa_mc->interface~parallel_sum proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~parallel_sum proc~halo halo proc~halo->interface~parallel_sum proc~write_npa write_npa proc~write_npa->interface~parallel_sum proc~pfida_mc pfida_mc proc~pfida_mc->interface~parallel_sum proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~parallel_sum proc~dcx dcx proc~dcx->interface~parallel_sum proc~fida_weights_los fida_weights_los proc~fida_weights_los->interface~parallel_sum proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~parallel_sum proc~fida_f fida_f proc~fida_f->interface~parallel_sum proc~neutron_mc neutron_mc proc~neutron_mc->interface~parallel_sum proc~npa_f npa_f proc~npa_f->interface~parallel_sum proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~parallel_sum proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~parallel_sum proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~parallel_sum proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~parallel_sum proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~parallel_sum proc~halo_spec halo_spec proc~halo_spec->interface~parallel_sum proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->interface~parallel_sum proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~parallel_sum proc~cold_spec cold_spec proc~cold_spec->interface~parallel_sum proc~neutron_f neutron_f proc~neutron_f->interface~parallel_sum proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~parallel_sum program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_mc program~fidasim->proc~ndmc program~fidasim->proc~nbi_spec program~fidasim->proc~npa_weights program~fidasim->proc~fida_mc program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_mc program~fidasim->proc~halo program~fidasim->proc~write_npa program~fidasim->proc~pfida_mc program~fidasim->proc~dcx program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~npa_f program~fidasim->proc~write_birth_profile program~fidasim->proc~fida_weights_mc program~fidasim->proc~halo_spec program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~cold_spec program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/parallel_sum_d0.html","title":"parallel_sum_d0 – FIDASIM"},{"text":"public recursive subroutine parallel_sum_d1(A) Uses mpi iso_c_binding proc~~parallel_sum_d1~~UsesGraph proc~parallel_sum_d1 parallel_sum_d1 iso_c_binding iso_c_binding proc~parallel_sum_d1->iso_c_binding mpi mpi proc~parallel_sum_d1->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:) :: A Calls proc~~parallel_sum_d1~~CallsGraph proc~parallel_sum_d1 parallel_sum_d1 mpi_allreduce mpi_allreduce proc~parallel_sum_d1->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~parallel_sum_d1~~CalledByGraph proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum parallel_sum interface~parallel_sum->proc~parallel_sum_d1 proc~pnpa_f pnpa_f proc~pnpa_f->interface~parallel_sum proc~dcx_spec dcx_spec proc~dcx_spec->interface~parallel_sum proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->interface~parallel_sum proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~parallel_sum proc~npa_mc npa_mc proc~npa_mc->interface~parallel_sum proc~ndmc ndmc proc~ndmc->interface~parallel_sum proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~parallel_sum proc~nbi_spec nbi_spec proc~nbi_spec->interface~parallel_sum proc~npa_weights npa_weights proc~npa_weights->interface~parallel_sum proc~fida_mc fida_mc proc~fida_mc->interface~parallel_sum proc~pfida_f pfida_f proc~pfida_f->interface~parallel_sum proc~pnpa_mc pnpa_mc proc~pnpa_mc->interface~parallel_sum proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~parallel_sum proc~halo halo proc~halo->interface~parallel_sum proc~write_npa write_npa proc~write_npa->interface~parallel_sum proc~pfida_mc pfida_mc proc~pfida_mc->interface~parallel_sum proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~parallel_sum proc~dcx dcx proc~dcx->interface~parallel_sum proc~fida_weights_los fida_weights_los proc~fida_weights_los->interface~parallel_sum proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~parallel_sum proc~fida_f fida_f proc~fida_f->interface~parallel_sum proc~neutron_mc neutron_mc proc~neutron_mc->interface~parallel_sum proc~npa_f npa_f proc~npa_f->interface~parallel_sum proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~parallel_sum proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~parallel_sum proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~parallel_sum proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~parallel_sum proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~parallel_sum proc~halo_spec halo_spec proc~halo_spec->interface~parallel_sum proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->interface~parallel_sum proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~parallel_sum proc~cold_spec cold_spec proc~cold_spec->interface~parallel_sum proc~neutron_f neutron_f proc~neutron_f->interface~parallel_sum proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~parallel_sum program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_mc program~fidasim->proc~ndmc program~fidasim->proc~nbi_spec program~fidasim->proc~npa_weights program~fidasim->proc~fida_mc program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_mc program~fidasim->proc~halo program~fidasim->proc~write_npa program~fidasim->proc~pfida_mc program~fidasim->proc~dcx program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~npa_f program~fidasim->proc~write_birth_profile program~fidasim->proc~fida_weights_mc program~fidasim->proc~halo_spec program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~cold_spec program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/parallel_sum_d1.html","title":"parallel_sum_d1 – FIDASIM"},{"text":"public recursive subroutine parallel_sum_d2(A) Uses mpi iso_c_binding proc~~parallel_sum_d2~~UsesGraph proc~parallel_sum_d2 parallel_sum_d2 iso_c_binding iso_c_binding proc~parallel_sum_d2->iso_c_binding mpi mpi proc~parallel_sum_d2->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:), target :: A Calls proc~~parallel_sum_d2~~CallsGraph proc~parallel_sum_d2 parallel_sum_d2 mpi_allreduce mpi_allreduce proc~parallel_sum_d2->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~parallel_sum_d2~~CalledByGraph proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum parallel_sum interface~parallel_sum->proc~parallel_sum_d2 proc~pnpa_f pnpa_f proc~pnpa_f->interface~parallel_sum proc~dcx_spec dcx_spec proc~dcx_spec->interface~parallel_sum proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->interface~parallel_sum proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~parallel_sum proc~npa_mc npa_mc proc~npa_mc->interface~parallel_sum proc~ndmc ndmc proc~ndmc->interface~parallel_sum proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~parallel_sum proc~nbi_spec nbi_spec proc~nbi_spec->interface~parallel_sum proc~npa_weights npa_weights proc~npa_weights->interface~parallel_sum proc~fida_mc fida_mc proc~fida_mc->interface~parallel_sum proc~pfida_f pfida_f proc~pfida_f->interface~parallel_sum proc~pnpa_mc pnpa_mc proc~pnpa_mc->interface~parallel_sum proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~parallel_sum proc~halo halo proc~halo->interface~parallel_sum proc~write_npa write_npa proc~write_npa->interface~parallel_sum proc~pfida_mc pfida_mc proc~pfida_mc->interface~parallel_sum proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~parallel_sum proc~dcx dcx proc~dcx->interface~parallel_sum proc~fida_weights_los fida_weights_los proc~fida_weights_los->interface~parallel_sum proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~parallel_sum proc~fida_f fida_f proc~fida_f->interface~parallel_sum proc~neutron_mc neutron_mc proc~neutron_mc->interface~parallel_sum proc~npa_f npa_f proc~npa_f->interface~parallel_sum proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~parallel_sum proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~parallel_sum proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~parallel_sum proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~parallel_sum proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~parallel_sum proc~halo_spec halo_spec proc~halo_spec->interface~parallel_sum proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->interface~parallel_sum proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~parallel_sum proc~cold_spec cold_spec proc~cold_spec->interface~parallel_sum proc~neutron_f neutron_f proc~neutron_f->interface~parallel_sum proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~parallel_sum program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_mc program~fidasim->proc~ndmc program~fidasim->proc~nbi_spec program~fidasim->proc~npa_weights program~fidasim->proc~fida_mc program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_mc program~fidasim->proc~halo program~fidasim->proc~write_npa program~fidasim->proc~pfida_mc program~fidasim->proc~dcx program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~npa_f program~fidasim->proc~write_birth_profile program~fidasim->proc~fida_weights_mc program~fidasim->proc~halo_spec program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~cold_spec program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/parallel_sum_d2.html","title":"parallel_sum_d2 – FIDASIM"},{"text":"public recursive subroutine parallel_sum_d3(A) Uses mpi iso_c_binding proc~~parallel_sum_d3~~UsesGraph proc~parallel_sum_d3 parallel_sum_d3 iso_c_binding iso_c_binding proc~parallel_sum_d3->iso_c_binding mpi mpi proc~parallel_sum_d3->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:,:), target :: A Calls proc~~parallel_sum_d3~~CallsGraph proc~parallel_sum_d3 parallel_sum_d3 mpi_allreduce mpi_allreduce proc~parallel_sum_d3->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~parallel_sum_d3~~CalledByGraph proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum parallel_sum interface~parallel_sum->proc~parallel_sum_d3 proc~pnpa_f pnpa_f proc~pnpa_f->interface~parallel_sum proc~dcx_spec dcx_spec proc~dcx_spec->interface~parallel_sum proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->interface~parallel_sum proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~parallel_sum proc~npa_mc npa_mc proc~npa_mc->interface~parallel_sum proc~ndmc ndmc proc~ndmc->interface~parallel_sum proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~parallel_sum proc~nbi_spec nbi_spec proc~nbi_spec->interface~parallel_sum proc~npa_weights npa_weights proc~npa_weights->interface~parallel_sum proc~fida_mc fida_mc proc~fida_mc->interface~parallel_sum proc~pfida_f pfida_f proc~pfida_f->interface~parallel_sum proc~pnpa_mc pnpa_mc proc~pnpa_mc->interface~parallel_sum proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~parallel_sum proc~halo halo proc~halo->interface~parallel_sum proc~write_npa write_npa proc~write_npa->interface~parallel_sum proc~pfida_mc pfida_mc proc~pfida_mc->interface~parallel_sum proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~parallel_sum proc~dcx dcx proc~dcx->interface~parallel_sum proc~fida_weights_los fida_weights_los proc~fida_weights_los->interface~parallel_sum proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~parallel_sum proc~fida_f fida_f proc~fida_f->interface~parallel_sum proc~neutron_mc neutron_mc proc~neutron_mc->interface~parallel_sum proc~npa_f npa_f proc~npa_f->interface~parallel_sum proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~parallel_sum proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~parallel_sum proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~parallel_sum proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~parallel_sum proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~parallel_sum proc~halo_spec halo_spec proc~halo_spec->interface~parallel_sum proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->interface~parallel_sum proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~parallel_sum proc~cold_spec cold_spec proc~cold_spec->interface~parallel_sum proc~neutron_f neutron_f proc~neutron_f->interface~parallel_sum proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~parallel_sum program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_mc program~fidasim->proc~ndmc program~fidasim->proc~nbi_spec program~fidasim->proc~npa_weights program~fidasim->proc~fida_mc program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_mc program~fidasim->proc~halo program~fidasim->proc~write_npa program~fidasim->proc~pfida_mc program~fidasim->proc~dcx program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~npa_f program~fidasim->proc~write_birth_profile program~fidasim->proc~fida_weights_mc program~fidasim->proc~halo_spec program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~cold_spec program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/parallel_sum_d3.html","title":"parallel_sum_d3 – FIDASIM"},{"text":"public recursive subroutine parallel_sum_d4(A) Uses mpi iso_c_binding proc~~parallel_sum_d4~~UsesGraph proc~parallel_sum_d4 parallel_sum_d4 iso_c_binding iso_c_binding proc~parallel_sum_d4->iso_c_binding mpi mpi proc~parallel_sum_d4->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:,:,:), target :: A Calls proc~~parallel_sum_d4~~CallsGraph proc~parallel_sum_d4 parallel_sum_d4 mpi_allreduce mpi_allreduce proc~parallel_sum_d4->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~parallel_sum_d4~~CalledByGraph proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum parallel_sum interface~parallel_sum->proc~parallel_sum_d4 proc~pnpa_f pnpa_f proc~pnpa_f->interface~parallel_sum proc~dcx_spec dcx_spec proc~dcx_spec->interface~parallel_sum proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->interface~parallel_sum proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~parallel_sum proc~npa_mc npa_mc proc~npa_mc->interface~parallel_sum proc~ndmc ndmc proc~ndmc->interface~parallel_sum proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~parallel_sum proc~nbi_spec nbi_spec proc~nbi_spec->interface~parallel_sum proc~npa_weights npa_weights proc~npa_weights->interface~parallel_sum proc~fida_mc fida_mc proc~fida_mc->interface~parallel_sum proc~pfida_f pfida_f proc~pfida_f->interface~parallel_sum proc~pnpa_mc pnpa_mc proc~pnpa_mc->interface~parallel_sum proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~parallel_sum proc~halo halo proc~halo->interface~parallel_sum proc~write_npa write_npa proc~write_npa->interface~parallel_sum proc~pfida_mc pfida_mc proc~pfida_mc->interface~parallel_sum proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~parallel_sum proc~dcx dcx proc~dcx->interface~parallel_sum proc~fida_weights_los fida_weights_los proc~fida_weights_los->interface~parallel_sum proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~parallel_sum proc~fida_f fida_f proc~fida_f->interface~parallel_sum proc~neutron_mc neutron_mc proc~neutron_mc->interface~parallel_sum proc~npa_f npa_f proc~npa_f->interface~parallel_sum proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~parallel_sum proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~parallel_sum proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~parallel_sum proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~parallel_sum proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~parallel_sum proc~halo_spec halo_spec proc~halo_spec->interface~parallel_sum proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->interface~parallel_sum proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~parallel_sum proc~cold_spec cold_spec proc~cold_spec->interface~parallel_sum proc~neutron_f neutron_f proc~neutron_f->interface~parallel_sum proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~parallel_sum program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_mc program~fidasim->proc~ndmc program~fidasim->proc~nbi_spec program~fidasim->proc~npa_weights program~fidasim->proc~fida_mc program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_mc program~fidasim->proc~halo program~fidasim->proc~write_npa program~fidasim->proc~pfida_mc program~fidasim->proc~dcx program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~npa_f program~fidasim->proc~write_birth_profile program~fidasim->proc~fida_weights_mc program~fidasim->proc~halo_spec program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~cold_spec program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/parallel_sum_d4.html","title":"parallel_sum_d4 – FIDASIM"},{"text":"public recursive subroutine parallel_sum_d5(A) Uses mpi iso_c_binding proc~~parallel_sum_d5~~UsesGraph proc~parallel_sum_d5 parallel_sum_d5 iso_c_binding iso_c_binding proc~parallel_sum_d5->iso_c_binding mpi mpi proc~parallel_sum_d5->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:,:,:,:), target :: A Calls proc~~parallel_sum_d5~~CallsGraph proc~parallel_sum_d5 parallel_sum_d5 mpi_allreduce mpi_allreduce proc~parallel_sum_d5->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~parallel_sum_d5~~CalledByGraph proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum parallel_sum interface~parallel_sum->proc~parallel_sum_d5 proc~pnpa_f pnpa_f proc~pnpa_f->interface~parallel_sum proc~dcx_spec dcx_spec proc~dcx_spec->interface~parallel_sum proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->interface~parallel_sum proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~parallel_sum proc~npa_mc npa_mc proc~npa_mc->interface~parallel_sum proc~ndmc ndmc proc~ndmc->interface~parallel_sum proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~parallel_sum proc~nbi_spec nbi_spec proc~nbi_spec->interface~parallel_sum proc~npa_weights npa_weights proc~npa_weights->interface~parallel_sum proc~fida_mc fida_mc proc~fida_mc->interface~parallel_sum proc~pfida_f pfida_f proc~pfida_f->interface~parallel_sum proc~pnpa_mc pnpa_mc proc~pnpa_mc->interface~parallel_sum proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~parallel_sum proc~halo halo proc~halo->interface~parallel_sum proc~write_npa write_npa proc~write_npa->interface~parallel_sum proc~pfida_mc pfida_mc proc~pfida_mc->interface~parallel_sum proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~parallel_sum proc~dcx dcx proc~dcx->interface~parallel_sum proc~fida_weights_los fida_weights_los proc~fida_weights_los->interface~parallel_sum proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~parallel_sum proc~fida_f fida_f proc~fida_f->interface~parallel_sum proc~neutron_mc neutron_mc proc~neutron_mc->interface~parallel_sum proc~npa_f npa_f proc~npa_f->interface~parallel_sum proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~parallel_sum proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~parallel_sum proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~parallel_sum proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~parallel_sum proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~parallel_sum proc~halo_spec halo_spec proc~halo_spec->interface~parallel_sum proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->interface~parallel_sum proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~parallel_sum proc~cold_spec cold_spec proc~cold_spec->interface~parallel_sum proc~neutron_f neutron_f proc~neutron_f->interface~parallel_sum proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~parallel_sum program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_mc program~fidasim->proc~ndmc program~fidasim->proc~nbi_spec program~fidasim->proc~npa_weights program~fidasim->proc~fida_mc program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_mc program~fidasim->proc~halo program~fidasim->proc~write_npa program~fidasim->proc~pfida_mc program~fidasim->proc~dcx program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~npa_f program~fidasim->proc~write_birth_profile program~fidasim->proc~fida_weights_mc program~fidasim->proc~halo_spec program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~cold_spec program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/parallel_sum_d5.html","title":"parallel_sum_d5 – FIDASIM"},{"text":"public recursive subroutine parallel_sum_i0(A) Uses mpi proc~~parallel_sum_i0~~UsesGraph proc~parallel_sum_i0 parallel_sum_i0 mpi mpi proc~parallel_sum_i0->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: A Calls proc~~parallel_sum_i0~~CallsGraph proc~parallel_sum_i0 parallel_sum_i0 mpi_allreduce mpi_allreduce proc~parallel_sum_i0->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~parallel_sum_i0~~CalledByGraph proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum parallel_sum interface~parallel_sum->proc~parallel_sum_i0 proc~pnpa_f pnpa_f proc~pnpa_f->interface~parallel_sum proc~dcx_spec dcx_spec proc~dcx_spec->interface~parallel_sum proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->interface~parallel_sum proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~parallel_sum proc~npa_mc npa_mc proc~npa_mc->interface~parallel_sum proc~ndmc ndmc proc~ndmc->interface~parallel_sum proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~parallel_sum proc~nbi_spec nbi_spec proc~nbi_spec->interface~parallel_sum proc~npa_weights npa_weights proc~npa_weights->interface~parallel_sum proc~fida_mc fida_mc proc~fida_mc->interface~parallel_sum proc~pfida_f pfida_f proc~pfida_f->interface~parallel_sum proc~pnpa_mc pnpa_mc proc~pnpa_mc->interface~parallel_sum proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~parallel_sum proc~halo halo proc~halo->interface~parallel_sum proc~write_npa write_npa proc~write_npa->interface~parallel_sum proc~pfida_mc pfida_mc proc~pfida_mc->interface~parallel_sum proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~parallel_sum proc~dcx dcx proc~dcx->interface~parallel_sum proc~fida_weights_los fida_weights_los proc~fida_weights_los->interface~parallel_sum proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~parallel_sum proc~fida_f fida_f proc~fida_f->interface~parallel_sum proc~neutron_mc neutron_mc proc~neutron_mc->interface~parallel_sum proc~npa_f npa_f proc~npa_f->interface~parallel_sum proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~parallel_sum proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~parallel_sum proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~parallel_sum proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~parallel_sum proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~parallel_sum proc~halo_spec halo_spec proc~halo_spec->interface~parallel_sum proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->interface~parallel_sum proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~parallel_sum proc~cold_spec cold_spec proc~cold_spec->interface~parallel_sum proc~neutron_f neutron_f proc~neutron_f->interface~parallel_sum proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~parallel_sum program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_mc program~fidasim->proc~ndmc program~fidasim->proc~nbi_spec program~fidasim->proc~npa_weights program~fidasim->proc~fida_mc program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_mc program~fidasim->proc~halo program~fidasim->proc~write_npa program~fidasim->proc~pfida_mc program~fidasim->proc~dcx program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~npa_f program~fidasim->proc~write_birth_profile program~fidasim->proc~fida_weights_mc program~fidasim->proc~halo_spec program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~cold_spec program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/parallel_sum_i0.html","title":"parallel_sum_i0 – FIDASIM"},{"text":"public recursive subroutine parallel_sum_i1(A) Uses mpi iso_c_binding proc~~parallel_sum_i1~~UsesGraph proc~parallel_sum_i1 parallel_sum_i1 iso_c_binding iso_c_binding proc~parallel_sum_i1->iso_c_binding mpi mpi proc~parallel_sum_i1->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: A Calls proc~~parallel_sum_i1~~CallsGraph proc~parallel_sum_i1 parallel_sum_i1 mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~parallel_sum_i1~~CalledByGraph proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum parallel_sum interface~parallel_sum->proc~parallel_sum_i1 proc~pnpa_f pnpa_f proc~pnpa_f->interface~parallel_sum proc~dcx_spec dcx_spec proc~dcx_spec->interface~parallel_sum proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->interface~parallel_sum proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~parallel_sum proc~npa_mc npa_mc proc~npa_mc->interface~parallel_sum proc~ndmc ndmc proc~ndmc->interface~parallel_sum proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~parallel_sum proc~nbi_spec nbi_spec proc~nbi_spec->interface~parallel_sum proc~npa_weights npa_weights proc~npa_weights->interface~parallel_sum proc~fida_mc fida_mc proc~fida_mc->interface~parallel_sum proc~pfida_f pfida_f proc~pfida_f->interface~parallel_sum proc~pnpa_mc pnpa_mc proc~pnpa_mc->interface~parallel_sum proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~parallel_sum proc~halo halo proc~halo->interface~parallel_sum proc~write_npa write_npa proc~write_npa->interface~parallel_sum proc~pfida_mc pfida_mc proc~pfida_mc->interface~parallel_sum proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~parallel_sum proc~dcx dcx proc~dcx->interface~parallel_sum proc~fida_weights_los fida_weights_los proc~fida_weights_los->interface~parallel_sum proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~parallel_sum proc~fida_f fida_f proc~fida_f->interface~parallel_sum proc~neutron_mc neutron_mc proc~neutron_mc->interface~parallel_sum proc~npa_f npa_f proc~npa_f->interface~parallel_sum proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~parallel_sum proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~parallel_sum proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~parallel_sum proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~parallel_sum proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~parallel_sum proc~halo_spec halo_spec proc~halo_spec->interface~parallel_sum proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->interface~parallel_sum proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~parallel_sum proc~cold_spec cold_spec proc~cold_spec->interface~parallel_sum proc~neutron_f neutron_f proc~neutron_f->interface~parallel_sum proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~parallel_sum program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_mc program~fidasim->proc~ndmc program~fidasim->proc~nbi_spec program~fidasim->proc~npa_weights program~fidasim->proc~fida_mc program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_mc program~fidasim->proc~halo program~fidasim->proc~write_npa program~fidasim->proc~pfida_mc program~fidasim->proc~dcx program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~npa_f program~fidasim->proc~write_birth_profile program~fidasim->proc~fida_weights_mc program~fidasim->proc~halo_spec program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~cold_spec program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/parallel_sum_i1.html","title":"parallel_sum_i1 – FIDASIM"},{"text":"public recursive subroutine parallel_sum_i2(A) Uses mpi iso_c_binding proc~~parallel_sum_i2~~UsesGraph proc~parallel_sum_i2 parallel_sum_i2 iso_c_binding iso_c_binding proc~parallel_sum_i2->iso_c_binding mpi mpi proc~parallel_sum_i2->mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:,:), target :: A Calls proc~~parallel_sum_i2~~CallsGraph proc~parallel_sum_i2 parallel_sum_i2 mpi_allreduce mpi_allreduce proc~parallel_sum_i2->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~parallel_sum_i2~~CalledByGraph proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum parallel_sum interface~parallel_sum->proc~parallel_sum_i2 proc~pnpa_f pnpa_f proc~pnpa_f->interface~parallel_sum proc~dcx_spec dcx_spec proc~dcx_spec->interface~parallel_sum proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->interface~parallel_sum proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~parallel_sum proc~npa_mc npa_mc proc~npa_mc->interface~parallel_sum proc~ndmc ndmc proc~ndmc->interface~parallel_sum proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~parallel_sum proc~nbi_spec nbi_spec proc~nbi_spec->interface~parallel_sum proc~npa_weights npa_weights proc~npa_weights->interface~parallel_sum proc~fida_mc fida_mc proc~fida_mc->interface~parallel_sum proc~pfida_f pfida_f proc~pfida_f->interface~parallel_sum proc~pnpa_mc pnpa_mc proc~pnpa_mc->interface~parallel_sum proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~parallel_sum proc~halo halo proc~halo->interface~parallel_sum proc~write_npa write_npa proc~write_npa->interface~parallel_sum proc~pfida_mc pfida_mc proc~pfida_mc->interface~parallel_sum proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~parallel_sum proc~dcx dcx proc~dcx->interface~parallel_sum proc~fida_weights_los fida_weights_los proc~fida_weights_los->interface~parallel_sum proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~parallel_sum proc~fida_f fida_f proc~fida_f->interface~parallel_sum proc~neutron_mc neutron_mc proc~neutron_mc->interface~parallel_sum proc~npa_f npa_f proc~npa_f->interface~parallel_sum proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~parallel_sum proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~parallel_sum proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~parallel_sum proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~parallel_sum proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~parallel_sum proc~halo_spec halo_spec proc~halo_spec->interface~parallel_sum proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->interface~parallel_sum proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~parallel_sum proc~cold_spec cold_spec proc~cold_spec->interface~parallel_sum proc~neutron_f neutron_f proc~neutron_f->interface~parallel_sum proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~parallel_sum program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_mc program~fidasim->proc~ndmc program~fidasim->proc~nbi_spec program~fidasim->proc~npa_weights program~fidasim->proc~fida_mc program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_mc program~fidasim->proc~halo program~fidasim->proc~write_npa program~fidasim->proc~pfida_mc program~fidasim->proc~dcx program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~npa_f program~fidasim->proc~write_birth_profile program~fidasim->proc~fida_weights_mc program~fidasim->proc~halo_spec program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~cold_spec program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/parallel_sum_i2.html","title":"parallel_sum_i2 – FIDASIM"},{"text":"public interface parallel_sum Calls interface~~parallel_sum~~CallsGraph interface~parallel_sum parallel_sum proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~parallel_sum~~CalledByGraph interface~parallel_sum parallel_sum proc~pnpa_f pnpa_f proc~pnpa_f->interface~parallel_sum proc~dcx_spec dcx_spec proc~dcx_spec->interface~parallel_sum proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->interface~parallel_sum proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~parallel_sum proc~npa_mc npa_mc proc~npa_mc->interface~parallel_sum proc~ndmc ndmc proc~ndmc->interface~parallel_sum proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~parallel_sum proc~nbi_spec nbi_spec proc~nbi_spec->interface~parallel_sum proc~npa_weights npa_weights proc~npa_weights->interface~parallel_sum proc~fida_mc fida_mc proc~fida_mc->interface~parallel_sum proc~pfida_f pfida_f proc~pfida_f->interface~parallel_sum proc~pnpa_mc pnpa_mc proc~pnpa_mc->interface~parallel_sum proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~parallel_sum proc~halo halo proc~halo->interface~parallel_sum proc~write_npa write_npa proc~write_npa->interface~parallel_sum proc~pfida_mc pfida_mc proc~pfida_mc->interface~parallel_sum proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~parallel_sum proc~dcx dcx proc~dcx->interface~parallel_sum proc~fida_weights_los fida_weights_los proc~fida_weights_los->interface~parallel_sum proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~parallel_sum proc~fida_f fida_f proc~fida_f->interface~parallel_sum proc~neutron_mc neutron_mc proc~neutron_mc->interface~parallel_sum proc~npa_f npa_f proc~npa_f->interface~parallel_sum proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~parallel_sum proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~parallel_sum proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~parallel_sum proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~parallel_sum proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~parallel_sum proc~halo_spec halo_spec proc~halo_spec->interface~parallel_sum proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->interface~parallel_sum proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~parallel_sum proc~cold_spec cold_spec proc~cold_spec->interface~parallel_sum proc~neutron_f neutron_f proc~neutron_f->interface~parallel_sum proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~parallel_sum program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~bremsstrahlung program~fidasim->proc~npa_mc program~fidasim->proc~ndmc program~fidasim->proc~nbi_spec program~fidasim->proc~npa_weights program~fidasim->proc~fida_mc program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_mc program~fidasim->proc~halo program~fidasim->proc~write_npa program~fidasim->proc~pfida_mc program~fidasim->proc~dcx program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~npa_f program~fidasim->proc~write_birth_profile program~fidasim->proc~fida_weights_mc program~fidasim->proc~halo_spec program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~cold_spec program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures parallel_sum_d0 parallel_sum_d1 parallel_sum_d2 parallel_sum_d3 parallel_sum_d4 parallel_sum_d5 parallel_sum_i0 parallel_sum_i1 parallel_sum_i2 Module Procedures public recursive subroutine parallel_sum_d0 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout) :: A public recursive subroutine parallel_sum_d1 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:) :: A public recursive subroutine parallel_sum_d2 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:), target :: A public recursive subroutine parallel_sum_d3 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:,:), target :: A public recursive subroutine parallel_sum_d4 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:,:,:), target :: A public recursive subroutine parallel_sum_d5 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:,:,:,:), target :: A public recursive subroutine parallel_sum_i0 (A) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: A public recursive subroutine parallel_sum_i1 (A) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: A public recursive subroutine parallel_sum_i2 (A) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:,:), target :: A","tags":"","loc":"interface/parallel_sum.html","title":"parallel_sum – FIDASIM"},{"text":"public function pp_add(p1, p2) result(p3) Defines how to add two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) Called by proc~~pp_add~~CalledByGraph proc~pp_add pp_add interface~operator(+) operator(+) interface~operator(+)->proc~pp_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pp_add Source Code function pp_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[Profiles]] types type ( Profiles ), intent ( in ) :: p1 , p2 type ( Profiles ) :: p3 p3 % dene = p1 % dene + p2 % dene p3 % ti = p1 % ti + p2 % ti p3 % te = p1 % te + p2 % te p3 % denp = p1 % denp + p2 % denp p3 % denf = p1 % denf + p2 % denf p3 % denimp = p1 % denimp + p2 % denimp p3 % zeff = p1 % zeff + p2 % zeff p3 % vr = p1 % vr + p2 % vr p3 % vt = p1 % vt + p2 % vt p3 % vz = p1 % vz + p2 % vz p3 % denn = p1 % denn + p2 % denn end function pp_add","tags":"","loc":"proc/pp_add.html","title":"pp_add – FIDASIM"},{"text":"public function pp_subtract(p1, p2) result(p3) Defines how to subtract two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) Called by proc~~pp_subtract~~CalledByGraph proc~pp_subtract pp_subtract interface~operator(-) operator(-) interface~operator(-)->proc~pp_subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pp_subtract Source Code function pp_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[Profiles]] types type ( Profiles ), intent ( in ) :: p1 , p2 type ( Profiles ) :: p3 p3 % dene = p1 % dene - p2 % dene p3 % ti = p1 % ti - p2 % ti p3 % te = p1 % te - p2 % te p3 % denp = p1 % denp - p2 % denp p3 % denf = p1 % denf - p2 % denf p3 % denimp = p1 % denimp - p2 % denimp p3 % zeff = p1 % zeff - p2 % zeff p3 % vr = p1 % vr - p2 % vr p3 % vt = p1 % vt - p2 % vt p3 % vz = p1 % vz - p2 % vz p3 % denn = p1 % denn - p2 % denn end function pp_subtract","tags":"","loc":"proc/pp_subtract.html","title":"pp_subtract – FIDASIM"},{"text":"public function lplp_add(p1, p2) result(p3) Defines how to add two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) Called by proc~~lplp_add~~CalledByGraph proc~lplp_add lplp_add interface~operator(+) operator(+) interface~operator(+)->proc~lplp_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lplp_add Source Code function lplp_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[LocalProfiles]] types type ( LocalProfiles ), intent ( in ) :: p1 , p2 type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos + p2 % pos p3 % uvw = p1 % uvw + p2 % uvw p3 % dene = p1 % dene + p2 % dene p3 % ti = p1 % ti + p2 % ti p3 % te = p1 % te + p2 % te p3 % denp = p1 % denp + p2 % denp p3 % denf = p1 % denf + p2 % denf p3 % denimp = p1 % denimp + p2 % denimp p3 % zeff = p1 % zeff + p2 % zeff p3 % vr = p1 % vr + p2 % vr p3 % vt = p1 % vt + p2 % vt p3 % vz = p1 % vz + p2 % vz p3 % denn = p1 % denn + p2 % denn p3 % vrot = p1 % vrot + p2 % vrot end function lplp_add","tags":"","loc":"proc/lplp_add.html","title":"lplp_add – FIDASIM"},{"text":"public function lplp_subtract(p1, p2) result(p3) Defines how to subtract two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) Called by proc~~lplp_subtract~~CalledByGraph proc~lplp_subtract lplp_subtract interface~operator(-) operator(-) interface~operator(-)->proc~lplp_subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lplp_subtract Source Code function lplp_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[LocalProfiles]] types type ( LocalProfiles ), intent ( in ) :: p1 , p2 type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos - p2 % pos p3 % uvw = p1 % uvw - p2 % uvw p3 % dene = p1 % dene - p2 % dene p3 % ti = p1 % ti - p2 % ti p3 % te = p1 % te - p2 % te p3 % denp = p1 % denp - p2 % denp p3 % denf = p1 % denf - p2 % denf p3 % denimp = p1 % denimp - p2 % denimp p3 % zeff = p1 % zeff - p2 % zeff p3 % vr = p1 % vr - p2 % vr p3 % vt = p1 % vt - p2 % vt p3 % vz = p1 % vz - p2 % vz p3 % denn = p1 % denn - p2 % denn p3 % vrot = p1 % vrot - p2 % vrot end function lplp_subtract","tags":"","loc":"proc/lplp_subtract.html","title":"lplp_subtract – FIDASIM"},{"text":"public function ps_multiply(p1, real_scalar) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) Called by proc~~ps_multiply~~CalledByGraph proc~ps_multiply ps_multiply interface~operator(*) operator(*) interface~operator(*)->proc~ps_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ps_multiply Source Code function ps_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[Profiles]] types by a scalar type ( Profiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 % dene = p1 % dene * real_scalar p3 % ti = p1 % ti * real_scalar p3 % te = p1 % te * real_scalar p3 % denp = p1 % denp * real_scalar p3 % denf = p1 % denf * real_scalar p3 % denimp = p1 % denimp * real_scalar p3 % zeff = p1 % zeff * real_scalar p3 % vr = p1 % vr * real_scalar p3 % vt = p1 % vt * real_scalar p3 % vz = p1 % vz * real_scalar p3 % denn = p1 % denn * real_scalar end function ps_multiply","tags":"","loc":"proc/ps_multiply.html","title":"ps_multiply – FIDASIM"},{"text":"public function sp_multiply(real_scalar, p1) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( Profiles ), intent(in) :: p1 Return Value type( Profiles ) Called by proc~~sp_multiply~~CalledByGraph proc~sp_multiply sp_multiply interface~operator(*) operator(*) interface~operator(*)->proc~sp_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sp_multiply Source Code function sp_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[Profiles]] types by a scalar type ( Profiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 = p1 * real_scalar end function sp_multiply","tags":"","loc":"proc/sp_multiply.html","title":"sp_multiply – FIDASIM"},{"text":"public function ps_divide(p1, real_scalar) result(p3) Defines how to divide Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) Called by proc~~ps_divide~~CalledByGraph proc~ps_divide ps_divide interface~operator(SLASH) operator(/) interface~operator(SLASH)->proc~ps_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ps_divide Source Code function ps_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[Profiles]] types by a scalar type ( Profiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function ps_divide","tags":"","loc":"proc/ps_divide.html","title":"ps_divide – FIDASIM"},{"text":"public function lps_multiply(p1, real_scalar) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) Called by proc~~lps_multiply~~CalledByGraph proc~lps_multiply lps_multiply interface~operator(*) operator(*) interface~operator(*)->proc~lps_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lps_multiply Source Code function lps_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[LocalProfiles]] types by a scalar type ( LocalProfiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos * real_scalar p3 % uvw = p1 % uvw * real_scalar p3 % dene = p1 % dene * real_scalar p3 % ti = p1 % ti * real_scalar p3 % te = p1 % te * real_scalar p3 % denp = p1 % denp * real_scalar p3 % denf = p1 % denf * real_scalar p3 % denimp = p1 % denimp * real_scalar p3 % zeff = p1 % zeff * real_scalar p3 % vr = p1 % vr * real_scalar p3 % vt = p1 % vt * real_scalar p3 % vz = p1 % vz * real_scalar p3 % denn = p1 % denn * real_scalar p3 % vrot = p1 % vrot * real_scalar end function lps_multiply","tags":"","loc":"proc/lps_multiply.html","title":"lps_multiply – FIDASIM"},{"text":"public function slp_multiply(real_scalar, p1) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalProfiles ), intent(in) :: p1 Return Value type( LocalProfiles ) Called by proc~~slp_multiply~~CalledByGraph proc~slp_multiply slp_multiply interface~operator(*) operator(*) interface~operator(*)->proc~slp_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code slp_multiply Source Code function slp_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[LocalProfiles]] types by a scalar type ( LocalProfiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 = p1 * real_scalar end function slp_multiply","tags":"","loc":"proc/slp_multiply.html","title":"slp_multiply – FIDASIM"},{"text":"public function lps_divide(p1, real_scalar) result(p3) Defines how to divide LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) Called by proc~~lps_divide~~CalledByGraph proc~lps_divide lps_divide interface~operator(SLASH) operator(/) interface~operator(SLASH)->proc~lps_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lps_divide Source Code function lps_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[LocalProfiles]] types by a scalar type ( LocalProfiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function lps_divide","tags":"","loc":"proc/lps_divide.html","title":"lps_divide – FIDASIM"},{"text":"public function ff_add(p1, p2) result(p3) Defines how to add two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) Called by proc~~ff_add~~CalledByGraph proc~ff_add ff_add interface~operator(+) operator(+) interface~operator(+)->proc~ff_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ff_add Source Code function ff_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[EMFields]] types type ( EMFields ), intent ( in ) :: p1 , p2 type ( EMFields ) :: p3 p3 % br = p1 % br + p2 % br p3 % bt = p1 % bt + p2 % bt p3 % bz = p1 % bz + p2 % bz p3 % er = p1 % er + p2 % er p3 % et = p1 % et + p2 % et p3 % ez = p1 % ez + p2 % ez p3 % dbr_dr = p1 % dbr_dr + p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz + p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr + p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz + p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr + p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz + p2 % dbz_dz end function ff_add","tags":"","loc":"proc/ff_add.html","title":"ff_add – FIDASIM"},{"text":"public function ff_subtract(p1, p2) result(p3) Defines how to subtract two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) Called by proc~~ff_subtract~~CalledByGraph proc~ff_subtract ff_subtract interface~operator(-) operator(-) interface~operator(-)->proc~ff_subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ff_subtract Source Code function ff_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[EMFields]] types type ( EMFields ), intent ( in ) :: p1 , p2 type ( EMFields ) :: p3 p3 % br = p1 % br - p2 % br p3 % bt = p1 % bt - p2 % bt p3 % bz = p1 % bz - p2 % bz p3 % er = p1 % er - p2 % er p3 % et = p1 % et - p2 % et p3 % ez = p1 % ez - p2 % ez p3 % dbr_dr = p1 % dbr_dr - p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz - p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr - p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz - p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr - p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz - p2 % dbz_dz end function ff_subtract","tags":"","loc":"proc/ff_subtract.html","title":"ff_subtract – FIDASIM"},{"text":"public function fs_multiply(p1, real_scalar) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) Called by proc~~fs_multiply~~CalledByGraph proc~fs_multiply fs_multiply interface~operator(*) operator(*) interface~operator(*)->proc~fs_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fs_multiply Source Code function fs_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[EMFields]] types by a scalar type ( EMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 % br = p1 % br * real_scalar p3 % bt = p1 % bt * real_scalar p3 % bz = p1 % bz * real_scalar p3 % er = p1 % er * real_scalar p3 % et = p1 % et * real_scalar p3 % ez = p1 % ez * real_scalar p3 % dbr_dr = p1 % dbr_dr * real_scalar p3 % dbr_dz = p1 % dbr_dz * real_scalar p3 % dbt_dr = p1 % dbt_dr * real_scalar p3 % dbt_dz = p1 % dbt_dz * real_scalar p3 % dbz_dr = p1 % dbz_dr * real_scalar p3 % dbz_dz = p1 % dbz_dz * real_scalar end function fs_multiply","tags":"","loc":"proc/fs_multiply.html","title":"fs_multiply – FIDASIM"},{"text":"public function sf_multiply(real_scalar, p1) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( EMFields ), intent(in) :: p1 Return Value type( EMFields ) Called by proc~~sf_multiply~~CalledByGraph proc~sf_multiply sf_multiply interface~operator(*) operator(*) interface~operator(*)->proc~sf_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sf_multiply Source Code function sf_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[EMFields]] types by a scalar type ( EMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 = p1 * real_scalar end function sf_multiply","tags":"","loc":"proc/sf_multiply.html","title":"sf_multiply – FIDASIM"},{"text":"public function fs_divide(p1, real_scalar) result(p3) Defines how to divide EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) Called by proc~~fs_divide~~CalledByGraph proc~fs_divide fs_divide interface~operator(SLASH) operator(/) interface~operator(SLASH)->proc~fs_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fs_divide Source Code function fs_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[EMFields]] types by a scalar type ( EMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function fs_divide","tags":"","loc":"proc/fs_divide.html","title":"fs_divide – FIDASIM"},{"text":"public function lflf_add(p1, p2) result(p3) Defines how to add two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) Calls proc~~lflf_add~~CallsGraph proc~lflf_add lflf_add proc~calc_perp_vectors calc_perp_vectors proc~lflf_add->proc~calc_perp_vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~lflf_add~~CalledByGraph proc~lflf_add lflf_add interface~operator(+) operator(+) interface~operator(+)->proc~lflf_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lflf_add Source Code function lflf_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[LocalEMFields]] types type ( LocalEMFields ), intent ( in ) :: p1 , p2 type ( LocalEMFields ) :: p3 real ( Float64 ), dimension ( 3 ) :: bfield , efield p3 % pos = p1 % pos + p2 % pos p3 % uvw = p1 % uvw + p2 % uvw p3 % br = p1 % br + p2 % br p3 % bt = p1 % bt + p2 % bt p3 % bz = p1 % bz + p2 % bz p3 % er = p1 % er + p2 % er p3 % et = p1 % et + p2 % et p3 % ez = p1 % ez + p2 % ez bfield = p1 % b_abs * p1 % b_norm + p2 % b_abs * p2 % b_norm p3 % b_abs = norm2 ( bfield ) if ( p3 % b_abs . gt . 0.d0 ) then p3 % b_norm = bfield / p3 % b_abs call calc_perp_vectors ( p3 % b_norm , p3 % a_norm , p3 % c_norm ) endif efield = p1 % e_abs * p1 % e_norm + p2 % e_abs * p2 % e_norm p3 % e_abs = norm2 ( efield ) if ( p3 % e_abs . gt . 0.d0 ) p3 % e_norm = efield / p3 % e_abs p3 % dbr_dr = p1 % dbr_dr + p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz + p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr + p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz + p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr + p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz + p2 % dbz_dz end function lflf_add","tags":"","loc":"proc/lflf_add.html","title":"lflf_add – FIDASIM"},{"text":"public function lflf_subtract(p1, p2) result(p3) Defines how to subtract two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) Calls proc~~lflf_subtract~~CallsGraph proc~lflf_subtract lflf_subtract proc~calc_perp_vectors calc_perp_vectors proc~lflf_subtract->proc~calc_perp_vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~lflf_subtract~~CalledByGraph proc~lflf_subtract lflf_subtract interface~operator(-) operator(-) interface~operator(-)->proc~lflf_subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lflf_subtract Source Code function lflf_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[LocalEMFields]] types type ( LocalEMFields ), intent ( in ) :: p1 , p2 type ( LocalEMFields ) :: p3 real ( Float64 ), dimension ( 3 ) :: bfield , efield p3 % pos = p1 % pos - p2 % pos p3 % uvw = p1 % uvw - p2 % uvw p3 % br = p1 % br - p2 % br p3 % bt = p1 % bt - p2 % bt p3 % bz = p1 % bz - p2 % bz p3 % er = p1 % er - p2 % er p3 % et = p1 % et - p2 % et p3 % ez = p1 % ez - p2 % ez bfield = p1 % b_abs * p1 % b_norm - p2 % b_abs * p2 % b_norm p3 % b_abs = norm2 ( bfield ) if ( p3 % b_abs . gt . 0.d0 ) then p3 % b_norm = bfield / p3 % b_abs call calc_perp_vectors ( p3 % b_norm , p3 % a_norm , p3 % c_norm ) endif efield = p1 % e_abs * p1 % e_norm - p2 % e_abs * p2 % e_norm p3 % e_abs = norm2 ( efield ) if ( p3 % e_abs . gt . 0.d0 ) p3 % e_norm = efield / p3 % e_abs p3 % dbr_dr = p1 % dbr_dr - p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz - p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr - p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz - p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr - p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz - p2 % dbz_dz end function lflf_subtract","tags":"","loc":"proc/lflf_subtract.html","title":"lflf_subtract – FIDASIM"},{"text":"public function lfs_multiply(p1, real_scalar) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields ) Called by proc~~lfs_multiply~~CalledByGraph proc~lfs_multiply lfs_multiply interface~operator(*) operator(*) interface~operator(*)->proc~lfs_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lfs_multiply Source Code function lfs_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[LocalEMFields]] types by a scalar type ( LocalEMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 % pos = p1 % pos * real_scalar p3 % uvw = p1 % uvw * real_scalar p3 % br = p1 % br * real_scalar p3 % bt = p1 % bt * real_scalar p3 % bz = p1 % bz * real_scalar p3 % er = p1 % er * real_scalar p3 % et = p1 % et * real_scalar p3 % ez = p1 % ez * real_scalar p3 % b_abs = p1 % b_abs * real_scalar p3 % e_abs = p1 % e_abs * real_scalar p3 % a_norm = p1 % a_norm p3 % b_norm = p1 % b_norm p3 % c_norm = p1 % c_norm p3 % e_norm = p1 % e_norm p3 % dbr_dr = p1 % dbr_dr * real_scalar p3 % dbr_dz = p1 % dbr_dz * real_scalar p3 % dbt_dr = p1 % dbt_dr * real_scalar p3 % dbt_dz = p1 % dbt_dz * real_scalar p3 % dbz_dr = p1 % dbz_dr * real_scalar p3 % dbz_dz = p1 % dbz_dz * real_scalar end function lfs_multiply","tags":"","loc":"proc/lfs_multiply.html","title":"lfs_multiply – FIDASIM"},{"text":"public function slf_multiply(real_scalar, p1) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalEMFields ), intent(in) :: p1 Return Value type( LocalEMFields ) Called by proc~~slf_multiply~~CalledByGraph proc~slf_multiply slf_multiply interface~operator(*) operator(*) interface~operator(*)->proc~slf_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code slf_multiply Source Code function slf_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[LocalEMFields]] types by a scalar type ( LocalEMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 = p1 * real_scalar end function slf_multiply","tags":"","loc":"proc/slf_multiply.html","title":"slf_multiply – FIDASIM"},{"text":"public function lfs_divide(p1, real_scalar) result(p3) Defines how to divide LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields ) Called by proc~~lfs_divide~~CalledByGraph proc~lfs_divide lfs_divide interface~operator(SLASH) operator(/) interface~operator(SLASH)->proc~lfs_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lfs_divide Source Code function lfs_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[LocalEMFields]] types by a scalar type ( LocalEMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function lfs_divide","tags":"","loc":"proc/lfs_divide.html","title":"lfs_divide – FIDASIM"},{"text":"public function approx_eq(x, y, tol) result(a) Inexact equality comparison: x ~= y true if abs(x-y) <= tol else false Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: x First value in comparison real(kind=Float64), intent(in) :: y Second value in comparison real(kind=Float64), intent(in) :: tol Equality tolerance Return Value logical Called by proc~~approx_eq~~CalledByGraph proc~approx_eq approx_eq proc~circle_grid_intersect circle_grid_intersect proc~circle_grid_intersect->proc~approx_eq proc~in_grid in_grid proc~circle_grid_intersect->proc~in_grid proc~grid_intersect grid_intersect proc~circle_grid_intersect->proc~grid_intersect proc~npa_gyro_range npa_gyro_range proc~npa_gyro_range->proc~approx_eq proc~approx_le approx_le proc~approx_le->proc~approx_eq proc~approx_ge approx_ge proc~approx_ge->proc~approx_eq proc~pnpa_f pnpa_f proc~pnpa_f->proc~npa_gyro_range proc~read_mc read_mc proc~read_mc->proc~circle_grid_intersect proc~read_mc->proc~in_grid proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~npa_gyro_range proc~npa_f npa_f proc~npa_f->proc~npa_gyro_range proc~in_grid->proc~approx_le proc~in_grid->proc~approx_ge proc~npa_mc npa_mc proc~npa_mc->proc~npa_gyro_range proc~in_passive_grid in_passive_grid proc~in_passive_grid->proc~approx_le proc~in_passive_grid->proc~approx_ge proc~read_distribution read_distribution proc~read_distribution->proc~read_mc program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f program~fidasim->proc~npa_mc program~fidasim->proc~read_distribution proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~make_diagnostic_grids make_diagnostic_grids program~fidasim->proc~make_diagnostic_grids proc~ndmc ndmc program~fidasim->proc~ndmc proc~grid_intersect->proc~in_passive_grid proc~fida_weights_los->proc~grid_intersect proc~mc_nbi mc_nbi proc~mc_nbi->proc~grid_intersect proc~make_diagnostic_grids->proc~grid_intersect proc~ndmc->proc~mc_nbi var panprocapprox_eqCalledByGraph = svgPanZoom('#procapprox_eqCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code approx_eq Source Code function approx_eq ( x , y , tol ) result ( a ) !+ Inexact equality comparison: `x ~= y` true if `abs(x-y) <= tol` else false real ( Float64 ), intent ( in ) :: x !+First value in comparison real ( Float64 ), intent ( in ) :: y !+Second value in comparison real ( Float64 ), intent ( in ) :: tol !+Equality tolerance logical :: a a = abs ( x - y ). le . tol end function approx_eq","tags":"","loc":"proc/approx_eq.html","title":"approx_eq – FIDASIM"},{"text":"public function approx_ge(x, y, tol) result(a) Inexact greater than or equal to comparison: x >~= y Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: x First value in comparison real(kind=Float64), intent(in) :: y Second value in comparison real(kind=Float64), intent(in) :: tol Equality tolerance Return Value logical Calls proc~~approx_ge~~CallsGraph proc~approx_ge approx_ge proc~approx_eq approx_eq proc~approx_ge->proc~approx_eq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~approx_ge~~CalledByGraph proc~approx_ge approx_ge proc~in_passive_grid in_passive_grid proc~in_passive_grid->proc~approx_ge proc~in_grid in_grid proc~in_grid->proc~approx_ge proc~circle_grid_intersect circle_grid_intersect proc~circle_grid_intersect->proc~in_grid proc~grid_intersect grid_intersect proc~circle_grid_intersect->proc~grid_intersect proc~read_mc read_mc proc~read_mc->proc~in_grid proc~read_mc->proc~circle_grid_intersect proc~grid_intersect->proc~in_passive_grid proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~grid_intersect proc~mc_nbi mc_nbi proc~mc_nbi->proc~grid_intersect proc~read_distribution read_distribution proc~read_distribution->proc~read_mc proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~grid_intersect proc~ndmc ndmc proc~ndmc->proc~mc_nbi program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_distribution program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~ndmc var panprocapprox_geCalledByGraph = svgPanZoom('#procapprox_geCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code approx_ge Source Code function approx_ge ( x , y , tol ) result ( a ) !+ Inexact greater than or equal to comparison: `x >~= y` real ( Float64 ), intent ( in ) :: x !+First value in comparison real ( Float64 ), intent ( in ) :: y !+Second value in comparison real ( Float64 ), intent ( in ) :: tol !+Equality tolerance logical :: a a = ( x . gt . y ). or .( approx_eq ( x , y , tol )) end function approx_ge","tags":"","loc":"proc/approx_ge.html","title":"approx_ge – FIDASIM"},{"text":"public function approx_le(x, y, tol) result(a) Inexact less then or equal to comparison: x <~= y Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: x First value in comparison real(kind=Float64), intent(in) :: y Second value in comparison real(kind=Float64), intent(in) :: tol Equality tolerance Return Value logical Calls proc~~approx_le~~CallsGraph proc~approx_le approx_le proc~approx_eq approx_eq proc~approx_le->proc~approx_eq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~approx_le~~CalledByGraph proc~approx_le approx_le proc~in_passive_grid in_passive_grid proc~in_passive_grid->proc~approx_le proc~in_grid in_grid proc~in_grid->proc~approx_le proc~circle_grid_intersect circle_grid_intersect proc~circle_grid_intersect->proc~in_grid proc~grid_intersect grid_intersect proc~circle_grid_intersect->proc~grid_intersect proc~read_mc read_mc proc~read_mc->proc~in_grid proc~read_mc->proc~circle_grid_intersect proc~grid_intersect->proc~in_passive_grid proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~grid_intersect proc~mc_nbi mc_nbi proc~mc_nbi->proc~grid_intersect proc~read_distribution read_distribution proc~read_distribution->proc~read_mc proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~grid_intersect proc~ndmc ndmc proc~ndmc->proc~mc_nbi program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_distribution program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~ndmc var panprocapprox_leCalledByGraph = svgPanZoom('#procapprox_leCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code approx_le Source Code function approx_le ( x , y , tol ) result ( a ) !+ Inexact less then or equal to comparison: `x <~= y` real ( Float64 ), intent ( in ) :: x !+First value in comparison real ( Float64 ), intent ( in ) :: y !+Second value in comparison real ( Float64 ), intent ( in ) :: tol !+Equality tolerance logical :: a a = ( x . lt . y ). or .( approx_eq ( x , y , tol )) end function approx_le","tags":"","loc":"proc/approx_le.html","title":"approx_le – FIDASIM"},{"text":"public function cross_product(u, v) result(s) Calculates the cross product of two vectors: u x v Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: u real(kind=Float64), intent(in), dimension(3) :: v Return Value real(kind=Float64),\n  dimension(3) Called by proc~~cross_product~~CalledByGraph proc~cross_product cross_product proc~gyro_step gyro_step proc~gyro_step->proc~cross_product proc~plane_basis plane_basis proc~plane_basis->proc~cross_product proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~plane_basis proc~gyro_radius gyro_radius proc~gyro_radius->proc~gyro_step proc~ndmc ndmc proc~ndmc->proc~gyro_step proc~gyro_correction gyro_correction proc~gyro_correction->proc~gyro_step proc~read_npa read_npa proc~read_npa->proc~plane_basis proc~npa_weights npa_weights proc~npa_weights->proc~gyro_step proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~gyro_correction proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~track_cylindrical proc~fida_f fida_f proc~fida_f->proc~gyro_correction proc~neutron_mc neutron_mc proc~neutron_mc->proc~gyro_correction program~fidasim fidasim program~fidasim->proc~ndmc program~fidasim->proc~read_npa program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_mc program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc proc~pfida_mc pfida_mc program~fidasim->proc~pfida_mc proc~pfida_f pfida_f program~fidasim->proc~pfida_f proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~pfida_mc->proc~track_cylindrical proc~pfida_mc->proc~gyro_correction proc~pfida_f->proc~track_cylindrical proc~pfida_f->proc~gyro_correction proc~neutron_f->proc~gyro_correction proc~fida_mc->proc~gyro_correction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code cross_product Source Code function cross_product ( u , v ) result ( s ) !+ Calculates the cross product of two vectors: `u`x`v` real ( Float64 ), dimension ( 3 ), intent ( in ) :: u real ( Float64 ), dimension ( 3 ), intent ( in ) :: v real ( Float64 ), dimension ( 3 ) :: s s ( 1 ) = u ( 2 ) * v ( 3 ) - u ( 3 ) * v ( 2 ) s ( 2 ) = u ( 3 ) * v ( 1 ) - u ( 1 ) * v ( 3 ) s ( 3 ) = u ( 1 ) * v ( 2 ) - u ( 2 ) * v ( 1 ) end function cross_product","tags":"","loc":"proc/cross_product.html","title":"cross_product – FIDASIM"},{"text":"public function in_boundary(bplane, p) result(in_b) Indicator function for determining if a point on a plane is within the plane boundary Arguments Type Intent Optional Attributes Name type( BoundedPlane ), intent(in) :: bplane Plane with boundary real(kind=Float64), intent(in), dimension(3) :: p Point on plane Return Value logical Called by proc~~in_boundary~~CalledByGraph proc~in_boundary in_boundary proc~hit_npa_detector hit_npa_detector proc~hit_npa_detector->proc~in_boundary proc~gyro_range gyro_range proc~gyro_range->proc~in_boundary proc~pnpa_f pnpa_f proc~pnpa_f->proc~hit_npa_detector proc~npa_gyro_range npa_gyro_range proc~pnpa_f->proc~npa_gyro_range proc~npa_gyro_range->proc~gyro_range proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~hit_npa_detector proc~pnpa_mc->proc~npa_gyro_range proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~hit_npa_detector proc~npa_f npa_f proc~npa_f->proc~hit_npa_detector proc~npa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~hit_npa_detector proc~npa_mc->proc~npa_gyro_range proc~npa_weights npa_weights proc~npa_weights->proc~hit_npa_detector program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~npa_f program~fidasim->proc~npa_mc program~fidasim->proc~npa_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code in_boundary Source Code function in_boundary ( bplane , p ) result ( in_b ) !+ Indicator function for determining if a point on a plane is within the plane boundary type ( BoundedPlane ), intent ( in ) :: bplane !+ Plane with boundary real ( Float64 ), dimension ( 3 ), intent ( in ) :: p !+ Point on plane logical :: in_b real ( Float64 ), dimension ( 3 ) :: pp real ( Float64 ) :: hh , hw hh = bplane % hh hw = bplane % hw pp = matmul ( bplane % inv_basis , p - bplane % origin ) in_b = . False . SELECT CASE ( bplane % shape ) CASE ( 1 ) !Rectangular boundary if (( abs ( pp ( 1 )). le . hw ). and . & ( abs ( pp ( 2 )). le . hh )) then in_b = . True . endif CASE ( 2 ) !Circular/Ellipsoidal boundary if ((( hh * pp ( 1 )) ** 2 + ( hw * pp ( 2 )) ** 2 ). le .(( hh * hw ) ** 2 )) then in_b = . True . endif CASE DEFAULT if ( inputs % verbose . ge . 0 ) then write ( * , '(\"IN_BOUNDARY: Unknown boundary shape: \",i2)' ) bplane % shape endif stop END SELECT end function in_boundary","tags":"","loc":"proc/in_boundary.html","title":"in_boundary – FIDASIM"},{"text":"public function in_gyro_surface(gs, p) result(in_gs) Indicator function for determining if a point is inside the gyro_surface Arguments Type Intent Optional Attributes Name type( GyroSurface ), intent(in) :: gs Gyro-surface real(kind=Float64), intent(in), dimension(3) :: p Point Return Value logical Called by proc~~in_gyro_surface~~CalledByGraph proc~in_gyro_surface in_gyro_surface proc~gyro_range gyro_range proc~gyro_range->proc~in_gyro_surface proc~npa_gyro_range npa_gyro_range proc~npa_gyro_range->proc~gyro_range proc~pnpa_f pnpa_f proc~pnpa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~npa_gyro_range proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~npa_gyro_range proc~npa_f npa_f proc~npa_f->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~npa_mc program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code in_gyro_surface Source Code function in_gyro_surface ( gs , p ) result ( in_gs ) !+ Indicator function for determining if a point is inside the gyro_surface type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-surface real ( Float64 ), dimension ( 3 ), intent ( in ) :: p !+ Point logical :: in_gs real ( Float64 ), dimension ( 3 ) :: pp pp = p - gs % center in_gs = dot_product ( pp , matmul ( gs % A , pp )). le . 1.d0 end function in_gyro_surface","tags":"","loc":"proc/in_gyro_surface.html","title":"in_gyro_surface – FIDASIM"},{"text":"public function in_grid(xyz) result(ing) Determines if a position pos is in the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: xyz Position in beam grid coordinates [cm] Return Value logical Indicates whether the position is in the beam grid Calls proc~~in_grid~~CallsGraph proc~in_grid in_grid proc~approx_le approx_le proc~in_grid->proc~approx_le proc~approx_ge approx_ge proc~in_grid->proc~approx_ge proc~approx_eq approx_eq proc~approx_le->proc~approx_eq proc~approx_ge->proc~approx_eq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~in_grid~~CalledByGraph proc~in_grid in_grid proc~circle_grid_intersect circle_grid_intersect proc~circle_grid_intersect->proc~in_grid proc~read_mc read_mc proc~read_mc->proc~in_grid proc~read_mc->proc~circle_grid_intersect proc~read_distribution read_distribution proc~read_distribution->proc~read_mc program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/in_grid.html","title":"in_grid – FIDASIM"},{"text":"public function in_passive_grid(uvw) result(ing) Determines if a position pos is in the pass_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: uvw Position in machine coordinates [cm] Return Value logical Indicates whether the position is in the passive neutral grid Calls proc~~in_passive_grid~~CallsGraph proc~in_passive_grid in_passive_grid proc~uvw_to_cyl uvw_to_cyl proc~in_passive_grid->proc~uvw_to_cyl proc~approx_le approx_le proc~in_passive_grid->proc~approx_le proc~approx_ge approx_ge proc~in_passive_grid->proc~approx_ge proc~approx_eq approx_eq proc~approx_le->proc~approx_eq proc~approx_ge->proc~approx_eq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~in_passive_grid~~CalledByGraph proc~in_passive_grid in_passive_grid proc~grid_intersect grid_intersect proc~grid_intersect->proc~in_passive_grid proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~grid_intersect proc~circle_grid_intersect circle_grid_intersect proc~circle_grid_intersect->proc~grid_intersect proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~grid_intersect proc~mc_nbi mc_nbi proc~mc_nbi->proc~grid_intersect proc~read_mc read_mc proc~read_mc->proc~circle_grid_intersect proc~ndmc ndmc proc~ndmc->proc~mc_nbi program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~ndmc proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~read_distribution->proc~read_mc var panprocin_passive_gridCalledByGraph = svgPanZoom('#procin_passive_gridCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/in_passive_grid.html","title":"in_passive_grid – FIDASIM"},{"text":"public function gyro_radius(fields, energy, pitch) result(gyro_rad) Calculates mean gyro-radius Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: fields Electromagnetic fields at guiding center real(kind=Float64), intent(in) :: energy Energy of particle real(kind=Float64), intent(in) :: pitch Particle pitch w.r.t the magnetic field Return Value real(kind=Float64) Mean gyro-radius Calls proc~~gyro_radius~~CallsGraph proc~gyro_radius gyro_radius proc~pitch_to_vec pitch_to_vec proc~gyro_radius->proc~pitch_to_vec proc~gyro_step gyro_step proc~gyro_radius->proc~gyro_step proc~cross_product cross_product proc~gyro_step->proc~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code gyro_radius Source Code function gyro_radius ( fields , energy , pitch ) result ( gyro_rad ) !+ Calculates mean gyro-radius type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields at guiding center real ( Float64 ), intent ( in ) :: energy !+ Energy of particle real ( Float64 ), intent ( in ) :: pitch !+ Particle pitch w.r.t the magnetic field real ( Float64 ) :: gyro_rad !+ Mean gyro-radius real ( Float64 ), dimension ( 3 ) :: vi_norm , r_step real ( Float64 ) :: vabs , phi integer :: i , n vabs = sqrt ( energy / ( v2_to_E_per_amu * inputs % ab )) gyro_rad = 0.d0 n = 6 do i = 1 , n phi = i * 2 * pi / n call pitch_to_vec ( pitch , phi , fields , vi_norm ) call gyro_step ( vabs * vi_norm , fields , r_step ) gyro_rad = gyro_rad + norm2 ( r_step ) / n enddo end function gyro_radius","tags":"","loc":"proc/gyro_radius.html","title":"gyro_radius – FIDASIM"},{"text":"public subroutine print_banner() Prints FIDASIM banner Arguments None Called by proc~~print_banner~~CalledByGraph proc~print_banner print_banner program~fidasim fidasim program~fidasim->proc~print_banner Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code print_banner Source Code subroutine print_banner () !+ Prints FIDASIM banner write ( * , '(a)' ) \"   ____ ____ ___   ___    ____ ____ __  ___\" write ( * , '(a)' ) \"  / __//  _// _ \\ / _ |  / __//  _//  |/  /\" write ( * , '(a)' ) \" / _/ _/ / / // // __ | _\\ \\ _/ / / /|_/ / \" write ( * , '(a)' ) \"/_/  /___//____//_/ |_|/___//___//_/  /_/  \" write ( * , '(a)' ) \"                                           \" if ( version . ne . \"\" ) then write ( * , '(a,a)' ) \"Version: \" , trim ( version ) endif write ( * , '(a)' ) \"\" write ( * , '(a)' ) \"FIDASIM is released as open source code under the MIT Licence.\" write ( * , '(a)' ) \"For more information visit http://d3denergetic.github.io/FIDASIM/\" write ( * , '(a)' ) \"\" #ifdef _DEBUG write ( * , '(a)' ) \"########################### ATTENTION ###########################\" write ( * , '(a)' ) \"# Running in debug mode. All optimizations have been turned off #\" write ( * , '(a)' ) \"#################################################################\" write ( * , '(a)' ) \"\" #endif #ifdef _PROF write ( * , '(a)' ) \"########################### ATTENTION ###########################\" write ( * , '(a)' ) \"#                   Running in profiling mode                   #\" write ( * , '(a)' ) \"#################################################################\" write ( * , '(a)' ) \"\" #endif #ifndef _OMP #ifndef _MPI write ( * , '(a)' ) \"########################### ATTENTION ###########################\" write ( * , '(a)' ) \"#              OpenMP threading has been disabled               #\" write ( * , '(a)' ) \"#################################################################\" write ( * , '(a)' ) \"\" #endif #endif #ifndef _MPI #ifndef _OMP write ( * , '(a)' ) \"########################### ATTENTION ###########################\" write ( * , '(a)' ) \"#                     MPI has been disabled                     #\" write ( * , '(a)' ) \"#################################################################\" write ( * , '(a)' ) \"\" #endif #endif end subroutine print_banner","tags":"","loc":"proc/print_banner.html","title":"print_banner – FIDASIM"},{"text":"public subroutine fast_ion_assign(p1, p2) Defines how to assign FastIon types to eachother Arguments Type Intent Optional Attributes Name type( FastIon ), intent(out) :: p1 type( FastIon ), intent(in) :: p2 Called by proc~~fast_ion_assign~~CalledByGraph proc~fast_ion_assign fast_ion_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~fast_ion_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fast_ion_assign Source Code subroutine fast_ion_assign ( p1 , p2 ) !+ Defines how to assign [[FastIon]] types to eachother type ( FastIon ), intent ( in ) :: p2 type ( FastIon ), intent ( out ) :: p1 p1 % beam_grid_cross_grid = p2 % beam_grid_cross_grid p1 % r = p2 % r p1 % z = p2 % z p1 % phi = p2 % phi p1 % beam_grid_phi_enter = p2 % beam_grid_phi_enter p1 % delta_phi = p2 % delta_phi p1 % energy = p2 % energy p1 % pitch = p2 % pitch p1 % vabs = p2 % vabs p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % weight = p2 % weight p1 % class = p2 % class end subroutine fast_ion_assign","tags":"","loc":"proc/fast_ion_assign.html","title":"fast_ion_assign – FIDASIM"},{"text":"public subroutine npa_part_assign(p1, p2) Defines how to assign NPAParticle types to eachother Arguments Type Intent Optional Attributes Name type( NPAParticle ), intent(out) :: p1 type( NPAParticle ), intent(in) :: p2 Called by proc~~npa_part_assign~~CalledByGraph proc~npa_part_assign npa_part_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~npa_part_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code npa_part_assign Source Code subroutine npa_part_assign ( p1 , p2 ) !+ Defines how to assign [[NPAParticle]] types to eachother type ( NPAParticle ), intent ( in ) :: p2 type ( NPAParticle ), intent ( out ) :: p1 p1 % xi = p2 % xi p1 % yi = p2 % yi p1 % zi = p2 % zi p1 % xf = p2 % xf p1 % yf = p2 % yf p1 % zf = p2 % zf p1 % weight = p2 % weight p1 % energy = p2 % energy p1 % pitch = p2 % pitch p1 % detector = p2 % detector end subroutine npa_part_assign","tags":"","loc":"proc/npa_part_assign.html","title":"npa_part_assign – FIDASIM"},{"text":"public subroutine birth_part_assign(p1, p2) Defines how to assign BirthParticle types to eachother Arguments Type Intent Optional Attributes Name type( BirthParticle ), intent(out) :: p1 type( BirthParticle ), intent(in) :: p2 Called by proc~~birth_part_assign~~CalledByGraph proc~birth_part_assign birth_part_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~birth_part_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code birth_part_assign Source Code subroutine birth_part_assign ( p1 , p2 ) !+ Defines how to assign [[BirthParticle]] types to eachother type ( BirthParticle ), intent ( in ) :: p2 type ( BirthParticle ), intent ( out ) :: p1 p1 % neut_type = p2 % neut_type p1 % ind = p2 % ind p1 % ri = p2 % ri p1 % vi = p2 % vi p1 % ri_gc = p2 % ri_gc p1 % weight = p2 % weight p1 % energy = p2 % energy p1 % pitch = p2 % pitch end subroutine birth_part_assign","tags":"","loc":"proc/birth_part_assign.html","title":"birth_part_assign – FIDASIM"},{"text":"public subroutine pp_assign(p1, p2) Defines how to assign Profiles types to eachother Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 Called by proc~~pp_assign~~CalledByGraph proc~pp_assign pp_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~pp_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pp_assign Source Code subroutine pp_assign ( p1 , p2 ) !+ Defines how to assign [[Profiles]] types to eachother type ( Profiles ), intent ( in ) :: p2 type ( Profiles ), intent ( inout ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % denn = p2 % denn end subroutine pp_assign","tags":"","loc":"proc/pp_assign.html","title":"pp_assign – FIDASIM"},{"text":"public subroutine lpp_assign(p1, p2) Defines how to assign a Profiles type to a LocalProfiles type Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 Called by proc~~lpp_assign~~CalledByGraph proc~lpp_assign lpp_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~lpp_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lpp_assign Source Code subroutine lpp_assign ( p1 , p2 ) !+ Defines how to assign a [[Profiles]] type to a [[LocalProfiles]] type type ( Profiles ), intent ( in ) :: p2 type ( LocalProfiles ), intent ( inout ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % denn = p2 % denn end subroutine lpp_assign","tags":"","loc":"proc/lpp_assign.html","title":"lpp_assign – FIDASIM"},{"text":"public subroutine plp_assign(p1, p2) Defines how to assign a LocalProfiles type to a Profiles type Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 Called by proc~~plp_assign~~CalledByGraph proc~plp_assign plp_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~plp_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code plp_assign Source Code subroutine plp_assign ( p1 , p2 ) !+ Defines how to assign a [[LocalProfiles]] type to a [[Profiles]] type type ( LocalProfiles ), intent ( in ) :: p2 type ( Profiles ), intent ( inout ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % denn = p2 % denn end subroutine plp_assign","tags":"","loc":"proc/plp_assign.html","title":"plp_assign – FIDASIM"},{"text":"public subroutine lplp_assign(p1, p2) Defines how to assign LocalProfiles types to eachother Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 Called by proc~~lplp_assign~~CalledByGraph proc~lplp_assign lplp_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~lplp_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lplp_assign Source Code subroutine lplp_assign ( p1 , p2 ) !+ Defines how to assign [[LocalProfiles]] types to eachother type ( LocalProfiles ), intent ( in ) :: p2 type ( LocalProfiles ), intent ( inout ) :: p1 p1 % pos = p2 % pos p1 % uvw = p2 % uvw p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % denn = p2 % denn p1 % vrot = p2 % vrot end subroutine lplp_assign","tags":"","loc":"proc/lplp_assign.html","title":"lplp_assign – FIDASIM"},{"text":"public subroutine ff_assign(p1, p2) Defines how to assign EMFields types to eachother Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 Called by proc~~ff_assign~~CalledByGraph proc~ff_assign ff_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~ff_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ff_assign Source Code subroutine ff_assign ( p1 , p2 ) !+ Defines how to assign [[EMFields]] types to eachother type ( EMFields ), intent ( in ) :: p2 type ( EMFields ), intent ( inout ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine ff_assign","tags":"","loc":"proc/ff_assign.html","title":"ff_assign – FIDASIM"},{"text":"public subroutine lff_assign(p1, p2) Defines how to assign a EMFields type to a LocalEMFields type Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 Called by proc~~lff_assign~~CalledByGraph proc~lff_assign lff_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~lff_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lff_assign Source Code subroutine lff_assign ( p1 , p2 ) !+ Defines how to assign a [[EMFields]] type to a [[LocalEMFields]] type type ( EMFields ), intent ( in ) :: p2 type ( LocalEMFields ), intent ( inout ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine lff_assign","tags":"","loc":"proc/lff_assign.html","title":"lff_assign – FIDASIM"},{"text":"public subroutine flf_assign(p1, p2) Defines how to assign a LocalEMFields type to a EMFields type Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 Called by proc~~flf_assign~~CalledByGraph proc~flf_assign flf_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~flf_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code flf_assign Source Code subroutine flf_assign ( p1 , p2 ) !+ Defines how to assign a [[LocalEMFields]] type to a [[EMFields]] type type ( LocalEMFields ), intent ( in ) :: p2 type ( EMFields ), intent ( inout ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine flf_assign","tags":"","loc":"proc/flf_assign.html","title":"flf_assign – FIDASIM"},{"text":"public subroutine lflf_assign(p1, p2) Defines how to assign LocalEMFields types to eachother Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 Called by proc~~lflf_assign~~CalledByGraph proc~lflf_assign lflf_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~lflf_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code lflf_assign Source Code subroutine lflf_assign ( p1 , p2 ) !+ Defines how to assign [[LocalEMFields]] types to eachother type ( LocalEMFields ), intent ( in ) :: p2 type ( LocalEMFields ), intent ( inout ) :: p1 p1 % pos = p2 % pos p1 % uvw = p2 % uvw p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % b_abs = p2 % b_abs p1 % e_abs = p2 % e_abs p1 % a_norm = p2 % a_norm p1 % b_norm = p2 % b_norm p1 % c_norm = p2 % c_norm p1 % e_norm = p2 % e_norm p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine lflf_assign","tags":"","loc":"proc/lflf_assign.html","title":"lflf_assign – FIDASIM"},{"text":"public subroutine read_inputs() Reads input namelist file and stores the results into inputs , nbi , and beam_grid 20 for suffixes and seperators e.g. /, _npa.h5, ... Arguments None Calls proc~~read_inputs~~CallsGraph proc~read_inputs read_inputs proc~rng_seed rng_seed proc~read_inputs->proc~rng_seed proc~my_rank my_rank proc~read_inputs->proc~my_rank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_inputs~~CalledByGraph proc~read_inputs read_inputs program~fidasim fidasim program~fidasim->proc~read_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_inputs Source Code subroutine read_inputs !+ Reads input namelist file and stores the results into [[libfida:inputs]], !+ [[libfida:nbi]], and [[libfida:beam_grid]] character ( charlim ) :: runid , result_dir , tables_file character ( charlim ) :: distribution_file , equilibrium_file character ( charlim ) :: geometry_file , neutrals_file integer :: pathlen , calc_neutron , seed integer :: calc_brems , calc_dcx , calc_halo , calc_cold , calc_bes integer :: calc_fida , calc_pfida , calc_npa , calc_pnpa integer :: calc_birth , calc_fida_wght , calc_npa_wght integer :: load_neutrals , verbose , flr , split integer ( Int64 ) :: n_fida , n_pfida , n_npa , n_pnpa , n_nbi , n_halo , n_dcx , n_birth integer ( Int32 ) :: shot , nlambda , ne_wght , np_wght , nphi_wght , nlambda_wght real ( Float64 ) :: time , lambdamin , lambdamax , emax_wght real ( Float64 ) :: lambdamin_wght , lambdamax_wght real ( Float64 ) :: ai , ab , pinj , einj , current_fractions ( 3 ) integer ( Int32 ) :: impurity_charge integer ( Int32 ) :: nx , ny , nz real ( Float64 ) :: xmin , xmax , ymin , ymax , zmin , zmax real ( Float64 ) :: alpha , beta , gamma , origin ( 3 ) logical :: exis , error integer :: calc_nbi , no_flr !TODO Remove before release NAMELIST / fidasim_inputs / result_dir , tables_file , distribution_file , & geometry_file , equilibrium_file , neutrals_file , shot , time , runid , & calc_brems , calc_dcx , calc_halo , calc_cold , calc_fida , calc_bes ,& calc_pfida , calc_npa , calc_pnpa , calc_birth , seed , flr , split , & calc_fida_wght , calc_npa_wght , load_neutrals , verbose , & calc_neutron , n_fida , n_pfida , n_npa , n_pnpa , n_nbi , n_halo , n_dcx , n_birth , & ab , pinj , einj , current_fractions , ai , impurity_charge , & nx , ny , nz , xmin , xmax , ymin , ymax , zmin , zmax , & origin , alpha , beta , gamma , & ne_wght , np_wght , nphi_wght , & nlambda , lambdamin , lambdamax , emax_wght , & nlambda_wght , lambdamin_wght , lambdamax_wght , & calc_nbi , no_flr !TODO remove before release inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'READ_INPUTS: Input file does not exist: ' , trim ( namelist_file ) stop endif ! variables that are not changed not be auto-initalized ! provide reasonable defaults here result_dir = \".\" tables_file = \".\" distribution_file = \".\" geometry_file = \".\" equilibrium_file = \".\" neutrals_file = \".\" shot = 0 time = 0 runid = \"0\" seed = - 1 calc_brems = 0 calc_bes = 0 calc_dcx = 0 calc_halo = 0 calc_cold = 0 calc_fida = 0 calc_pfida = 0 calc_npa = 0 calc_pnpa = 0 calc_birth = 0 flr = 2 split = 1 calc_fida_wght = 0 calc_npa_wght = 0 load_neutrals = 0 verbose = 0 calc_neutron = 0 n_fida = 0 n_pfida = 0 n_npa = 0 n_pnpa = 0 n_nbi = 0 n_halo = 0 n_dcx = 0 n_birth = 0 ab = 0 pinj = 0 einj = 0 current_fractions = 0 ai = 0 impurity_charge = 0 nx = 0 ny = 0 nz = 0 xmin = 0 xmax = 0 ymin = 0 ymax = 0 zmin = 0 zmax = 0 origin = 0 alpha = 0 beta = 0 gamma = 0 ne_wght = 0 np_wght = 0 nphi_wght = 0 nlambda = 0 lambdamin = 0 lambdamax = 0 emax_wght = 0 nlambda_wght = 0 lambdamin_wght = 0 lambdamax_wght = 0 !TODO remove before release calc_nbi = 0 no_flr = 0 open ( 13 , file = namelist_file ) read ( 13 , NML = fidasim_inputs ) close ( 13 ) !!TODO remove before release if ( calc_nbi . gt . 0 ) calc_bes = 1 if ( no_flr . ge . 1 ) flr = 0 !!General Information inputs % shot_number = shot inputs % time = time inputs % runid = runid inputs % result_dir = result_dir !!Input Files inputs % tables_file = tables_file inputs % geometry_file = geometry_file inputs % equilibrium_file = equilibrium_file inputs % distribution_file = distribution_file inputs % neutrals_file = neutrals_file !! RNG seed inputs % seed = seed if ( inputs % seed . lt . 0 ) inputs % seed = rng_seed () !!Simulation Switches if (( calc_brems + calc_bes + calc_dcx + calc_halo + & calc_cold + calc_fida + calc_pfida ). gt . 0 ) then inputs % calc_spec = 1 inputs % tot_spectra = calc_brems + calc_bes + calc_dcx + calc_halo + & calc_cold + calc_fida + calc_pfida else inputs % calc_spec = 0 inputs % tot_spectra = 0 endif inputs % calc_beam = 0 if (( calc_bes + calc_birth + calc_dcx + & calc_halo + calc_fida + calc_npa + & calc_fida_wght + calc_npa_wght ). gt . 0 ) then inputs % calc_nbi_dens = 1 inputs % calc_beam = 1 else inputs % calc_nbi_dens = 0 endif if (( calc_dcx + calc_halo + calc_fida + calc_npa + & calc_fida_wght + calc_npa_wght ). gt . 0 ) then inputs % calc_dcx_dens = 1 inputs % calc_beam = 1 else inputs % calc_dcx_dens = 0 endif if (( calc_halo + calc_fida + calc_npa + & calc_fida_wght + calc_npa_wght ). gt . 0 ) then inputs % calc_halo_dens = 1 inputs % calc_beam = 1 else inputs % calc_halo_dens = 0 endif inputs % calc_brems = calc_brems inputs % calc_bes = calc_bes inputs % calc_dcx = calc_dcx inputs % calc_halo = calc_halo inputs % calc_cold = calc_cold inputs % calc_fida = calc_fida inputs % calc_pfida = calc_pfida inputs % calc_npa = calc_npa inputs % calc_pnpa = calc_pnpa inputs % calc_birth = calc_birth inputs % calc_fida_wght = calc_fida_wght inputs % calc_npa_wght = calc_npa_wght inputs % calc_neutron = calc_neutron inputs % load_neutrals = load_neutrals inputs % verbose = verbose inputs % flr = flr inputs % split = split !!Monte Carlo Settings inputs % n_fida = max ( 10 , n_fida ) inputs % n_pfida = max ( 10 , n_pfida ) inputs % n_npa = max ( 10 , n_npa ) inputs % n_pnpa = max ( 10 , n_pnpa ) inputs % n_nbi = max ( 10 , n_nbi ) inputs % n_halo = max ( 10 , n_halo ) inputs % n_dcx = max ( 10 , n_dcx ) inputs % n_birth = max ( 1 , nint ( n_birth / real ( n_nbi ))) !!Plasma Settings inputs % ai = ai inputs % impurity_charge = impurity_charge !!Neutral Beam Settings inputs % ab = ab nbi % current_fractions = current_fractions nbi % einj = einj nbi % pinj = pinj !!Weight Function Settings inputs % ne_wght = ne_wght inputs % np_wght = np_wght inputs % nphi_wght = nphi_wght inputs % emax_wght = emax_wght inputs % nlambda_wght = nlambda_wght inputs % lambdamin_wght = lambdamin_wght inputs % lambdamax_wght = lambdamax_wght !!Wavelength Grid Settings inputs % nlambda = nlambda inputs % lambdamin = lambdamin inputs % lambdamax = lambdamax inputs % dlambda = ( inputs % lambdamax - inputs % lambdamin ) / inputs % nlambda !!Beam Grid Settings beam_grid % nx = nx beam_grid % ny = ny beam_grid % nz = nz beam_grid % xmin = xmin beam_grid % xmax = xmax beam_grid % ymin = ymin beam_grid % ymax = ymax beam_grid % zmin = zmin beam_grid % zmax = zmax beam_grid % alpha = alpha beam_grid % beta = beta beam_grid % gamma = gamma beam_grid % origin = origin #ifdef _MPI if ( my_rank (). ne . 0 ) inputs % verbose = 0 #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Shot settings ----\" write ( * , '(T2,\"Shot: \",i8)' ) inputs % shot_number write ( * , '(T2,\"Time: \",i4,\" [ms]\")' ) int ( inputs % time * 1.d3 ) write ( * , '(T2,\"Runid: \",a)' ) trim ( adjustl ( inputs % runid )) write ( * , * ) '' write ( * , '(a)' ) \"---- Input files ----\" endif error = . False . inquire ( file = inputs % tables_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Tables file: \",a)' ) trim ( inputs % tables_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Tables file does not exist: ' , & trim ( inputs % tables_file ) endif error = . True . endif inquire ( file = inputs % geometry_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Geometry file: \",a)' ) trim ( inputs % geometry_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Geometry file does not exist: ' , & trim ( inputs % geometry_file ) endif error = . True . endif inquire ( file = inputs % equilibrium_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Equilibrium file: \",a)' ) trim ( inputs % equilibrium_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Equilibrium file does not exist: ' , & trim ( inputs % equilibrium_file ) endif error = . True . endif inquire ( file = inputs % distribution_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Distribution file: \",a)' ) trim ( inputs % distribution_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Distribution file does not exist: ' , & trim ( inputs % distribution_file ) endif error = . True . endif pathlen = len_trim ( inputs % result_dir ) + len_trim ( inputs % runid ) + 20 !+20 for suffixes and seperators e.g. /, _npa.h5, ... if ( pathlen . gt . charlim ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,i3,a,i3)' ) 'READ_INPUTS: Result directory path + runID use too many characters: ' , & pathlen - 20 , '>' , charlim - 20 endif error = . True . endif if ( inputs % verbose . ge . 1 ) then write ( * , * ) '' endif if ( error ) then stop endif end subroutine read_inputs","tags":"","loc":"proc/read_inputs.html","title":"read_inputs – FIDASIM"},{"text":"public subroutine make_beam_grid() Makes [[libfida:beam_grid] from user defined inputs Arguments None Calls proc~~make_beam_grid~~CallsGraph proc~make_beam_grid make_beam_grid proc~in_plasma in_plasma proc~make_beam_grid->proc~in_plasma proc~tb_zyx tb_zyx proc~make_beam_grid->proc~tb_zyx proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocmake_beam_gridCallsGraph = svgPanZoom('#procmake_beam_gridCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~make_beam_grid~~CalledByGraph proc~make_beam_grid make_beam_grid program~fidasim fidasim program~fidasim->proc~make_beam_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code make_beam_grid Source Code subroutine make_beam_grid !+ Makes [[libfida:beam_grid] from user defined inputs integer ( Int32 ) :: i , j , k , n real ( Float64 ) :: dx , dy , dz , ri ( 3 ) logical :: inp allocate ( beam_grid % xc ( beam_grid % nx ), & beam_grid % yc ( beam_grid % ny ), & beam_grid % zc ( beam_grid % nz )) dx = ( beam_grid % xmax - beam_grid % xmin ) / beam_grid % nx dy = ( beam_grid % ymax - beam_grid % ymin ) / beam_grid % ny dz = ( beam_grid % zmax - beam_grid % zmin ) / beam_grid % nz do i = 1 , beam_grid % nx beam_grid % xc ( i ) = beam_grid % xmin + ( i - 0.5 ) * dx enddo do i = 1 , beam_grid % ny beam_grid % yc ( i ) = beam_grid % ymin + ( i - 0.5 ) * dy enddo do i = 1 , beam_grid % nz beam_grid % zc ( i ) = beam_grid % zmin + ( i - 0.5 ) * dz enddo beam_grid % dr ( 1 ) = abs ( beam_grid % xc ( 2 ) - beam_grid % xc ( 1 )) beam_grid % dr ( 2 ) = abs ( beam_grid % yc ( 2 ) - beam_grid % yc ( 1 )) beam_grid % dr ( 3 ) = abs ( beam_grid % zc ( 2 ) - beam_grid % zc ( 1 )) beam_grid % lwh ( 1 ) = abs ( beam_grid % xc ( beam_grid % nx ) - beam_grid % xc ( 1 )) + beam_grid % dr ( 1 ) beam_grid % lwh ( 2 ) = abs ( beam_grid % yc ( beam_grid % ny ) - beam_grid % yc ( 1 )) + beam_grid % dr ( 2 ) beam_grid % lwh ( 3 ) = abs ( beam_grid % zc ( beam_grid % nz ) - beam_grid % zc ( 1 )) + beam_grid % dr ( 3 ) beam_grid % volume = beam_grid % lwh ( 1 ) * beam_grid % lwh ( 2 ) * beam_grid % lwh ( 3 ) beam_grid % center ( 1 ) = ( minval ( beam_grid % xc ) - 0.5 * beam_grid % dr ( 1 )) + 0.5 * beam_grid % lwh ( 1 ) beam_grid % center ( 2 ) = ( minval ( beam_grid % yc ) - 0.5 * beam_grid % dr ( 2 )) + 0.5 * beam_grid % lwh ( 2 ) beam_grid % center ( 3 ) = ( minval ( beam_grid % zc ) - 0.5 * beam_grid % dr ( 3 )) + 0.5 * beam_grid % lwh ( 3 ) beam_grid % drmin = minval ( beam_grid % dr ) beam_grid % dv = beam_grid % dr ( 1 ) * beam_grid % dr ( 2 ) * beam_grid % dr ( 3 ) beam_grid % ntrack = beam_grid % nx + beam_grid % ny + beam_grid % nz beam_grid % ngrid = beam_grid % nx * beam_grid % ny * beam_grid % nz beam_grid % dims ( 1 ) = beam_grid % nx beam_grid % dims ( 2 ) = beam_grid % ny beam_grid % dims ( 3 ) = beam_grid % nz call tb_zyx ( beam_grid % alpha , beam_grid % beta , beam_grid % gamma , & beam_grid % basis , beam_grid % inv_basis ) !! Check if beam grid is in the plasma n = 0 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ri = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] call in_plasma ( ri , inp ) if ( inp ) n = n + 1 enddo enddo enddo if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Beam grid settings ----\" write ( * , '(T2,\"Nx: \", i3)' ) beam_grid % nx write ( * , '(T2,\"Ny: \", i3)' ) beam_grid % ny write ( * , '(T2,\"Nz: \", i3)' ) beam_grid % nz write ( * , '(T2,\"dV: \", f5.2,\" [cm&#94;3]\")' ) beam_grid % dv write ( * , '(T2,\"alpha: \",f5.2,\" [rad]\")' ) beam_grid % alpha write ( * , '(T2,\"beta:  \",f5.2,\" [rad]\")' ) beam_grid % beta write ( * , '(T2,\"gamma: \",f5.2,\" [rad]\")' ) beam_grid % gamma write ( * , '(T2,\"origin: [\",f7.2,\",\",f7.2,\",\",f7.2,\"] [cm]\")' ) beam_grid % origin write ( * , '(T2,\"Number of cells in plasma: \",i8)' ) n write ( * , * ) '' endif if ( n . le .( 0.1 * beam_grid % ngrid )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"MAKE_BEAM_GRID: Beam grid definition is poorly defined. & &Less than 10% of the beam grid cells fall within the plasma.\" endif stop endif end subroutine make_beam_grid","tags":"","loc":"proc/make_beam_grid.html","title":"make_beam_grid – FIDASIM"},{"text":"public subroutine make_passive_grid() Makes [[libfida:pass_grid] from user defined inputs Arguments None Calls proc~~make_passive_grid~~CallsGraph proc~make_passive_grid make_passive_grid proc~get_plasma_extrema get_plasma_extrema proc~make_passive_grid->proc~get_plasma_extrema proc~in_plasma in_plasma proc~get_plasma_extrema->proc~in_plasma proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocmake_passive_gridCallsGraph = svgPanZoom('#procmake_passive_gridCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~make_passive_grid~~CalledByGraph proc~make_passive_grid make_passive_grid proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~make_passive_grid program~fidasim fidasim program~fidasim->proc~make_diagnostic_grids Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code make_passive_grid Source Code subroutine make_passive_grid !+ Makes [[libfida:pass_grid] from user defined inputs real ( Float64 ), dimension ( 3 , spec_chords % nchan + npa_chords % nchan ) :: r0_arr , v0_arr real ( Float64 ), dimension ( 2 , spec_chords % nchan + npa_chords % nchan ) :: xy_enter , xy_exit logical , dimension ( 8 + 2 * ( spec_chords % nchan + npa_chords % nchan )) :: yle , ygt logical , dimension ( spec_chords % nchan + npa_chords % nchan ) :: skip real ( Float64 ), dimension (:), allocatable :: xarr , yarr real ( Float64 ), dimension ( 3 , 8 ) :: vertices_xyz , vertices_uvw real ( Float64 ), dimension ( 2 , 3 ) :: extrema real ( Float64 ), dimension ( 3 , 3 ) :: xyz_axis real ( Float64 ), dimension ( 3 ) :: r0 , vi real ( Float64 ), dimension ( 8 ) :: xarr_beam_grid , yarr_beam_grid real ( Float64 ) :: xmin , ymin , xmax , ymax , zmin , zmax , max_length real ( Float64 ) :: dlength = 3.0 !cm integer :: i , iin , iout , dim_le , dim_gt , dim logical :: inp , phi_pos !! Get beam grid boundaries ! Convert vertices_xyz to vertices_uvw ! Note: vertices_xyz has the following coordinate definitions: ! 111 = 1, 222 = 2, 112 = 3, 211 = 4, 121 = 5, 212 = 6, 122 = 7, 221 = 8 xmin = beam_grid % xmin ; xmax = beam_grid % xmax ymin = beam_grid % ymin ; ymax = beam_grid % ymax zmin = beam_grid % zmin ; zmax = beam_grid % zmax !Initialize minimum and maximum vertices vertices_xyz ( 1 , 1 ) = xmin ; vertices_xyz ( 2 , 1 ) = ymin ; vertices_xyz ( 3 , 1 ) = zmin vertices_xyz ( 1 , 2 ) = xmax ; vertices_xyz ( 2 , 2 ) = ymax ; vertices_xyz ( 3 , 2 ) = zmax !Initialize vertices_xyz (:, 3 ) = vertices_xyz (:, 1 ) vertices_xyz (:, 4 ) = vertices_xyz (:, 1 ) vertices_xyz (:, 5 ) = vertices_xyz (:, 1 ) !Update vertices_xyz ( 3 , 3 ) = zmax vertices_xyz ( 1 , 4 ) = xmax vertices_xyz ( 2 , 5 ) = ymax !Initialize vertices_xyz (:, 7 ) = vertices_xyz (:, 2 ) vertices_xyz (:, 8 ) = vertices_xyz (:, 2 ) vertices_xyz (:, 6 ) = vertices_xyz (:, 2 ) !Update vertices_xyz ( 1 , 7 ) = xmin vertices_xyz ( 3 , 8 ) = zmin vertices_xyz ( 2 , 6 ) = ymin do i = 1 , 8 call xyz_to_uvw ( vertices_xyz (:, i ), vertices_uvw (:, i )) xarr_beam_grid ( i ) = vertices_uvw ( 1 , i ) yarr_beam_grid ( i ) = vertices_uvw ( 2 , i ) enddo !! Next consider passive diagnostic extrema relative to the plasma if (( inputs % calc_pfida . gt . 0 ). and .( inputs % calc_pnpa . gt . 0 )) then do i = 1 ,( spec_chords % nchan ) r0_arr (:, i ) = spec_chords % los ( i )% lens_uvw v0_arr (:, i ) = spec_chords % los ( i )% axis_uvw enddo do i = 1 , npa_chords % nchan call xyz_to_uvw ( npa_chords % det ( i )% detector % origin , r0_arr (:, i + spec_chords % nchan )) xyz_axis = npa_chords % det ( i )% detector % basis v0_arr (:, i + spec_chords % nchan ) = matmul ( beam_grid % basis , xyz_axis (:, 3 )) enddo else if ( inputs % calc_pfida . gt . 0 ) then do i = 1 , spec_chords % nchan r0_arr (:, i ) = spec_chords % los ( i )% lens_uvw v0_arr (:, i ) = spec_chords % los ( i )% axis_uvw enddo else !pnpa>=1 case do i = 1 , npa_chords % nchan call xyz_to_uvw ( npa_chords % det ( i )% detector % origin , r0_arr (:, i )) xyz_axis = npa_chords % det ( i )% detector % basis v0_arr (:, i ) = matmul ( beam_grid % basis , xyz_axis (:, 3 )) enddo endif call get_plasma_extrema ( r0_arr , v0_arr , extrema , xarr_beam_grid , yarr_beam_grid ) !! Store the passive neutral grid pass_grid % dr = inter_grid % dr pass_grid % dz = inter_grid % dz pass_grid % nr = inter_grid % nr pass_grid % nz = inter_grid % nz allocate ( pass_grid % r ( pass_grid % nr ), pass_grid % z ( pass_grid % nz )) pass_grid % r = inter_grid % r pass_grid % z = inter_grid % z pass_grid % da = pass_grid % dr * pass_grid % dz pass_grid % dphi = 0.1 pass_grid % nphi = int ( ceiling (( extrema ( 2 , 3 ) - extrema ( 1 , 3 )) / pass_grid % dphi )) if ( pass_grid % nphi . gt . 20 ) then !! Avoid large memory allocation pass_grid % nphi = 20 pass_grid % dphi = ( extrema ( 2 , 3 ) - extrema ( 1 , 3 )) / pass_grid % nphi endif allocate ( pass_grid % phi ( pass_grid % nphi )) do i = 1 , pass_grid % nphi pass_grid % phi ( i ) = extrema ( 1 , 3 ) + ( i - 1 ) * pass_grid % dphi enddo pass_grid % dv = pass_grid % dr * pass_grid % dphi * pass_grid % dz pass_grid % dims = [ pass_grid % nr , pass_grid % nz , pass_grid % nphi ] pass_grid % ntrack = pass_grid % nr + pass_grid % nz + pass_grid % nphi pass_grid % ngrid = pass_grid % nr * pass_grid % nz * pass_grid % nphi if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Passive neutral grid settings ----\" write ( * , '(T2,\"Nr: \", i3)' ) pass_grid % nr write ( * , '(T2,\"Nz: \", i3)' ) pass_grid % nz write ( * , '(T2,\"Nphi: \", i3)' ) pass_grid % nphi write ( * , '(T2,\"R  range = [\",f6.2,\",\",f6.2,\"]\")' ) & pass_grid % r ( 1 ), pass_grid % r ( pass_grid % nr ) write ( * , '(T2,\"Z  range = [\",f7.2,\",\",f6.2,\"]\")' ) & pass_grid % z ( 1 ), pass_grid % z ( pass_grid % nz ) write ( * , '(T2,\"Phi  range = [\",f5.2,\",\",f5.2,\"]\")' ) & pass_grid % phi ( 1 ), pass_grid % phi ( pass_grid % nphi ) write ( * , '(T2,\"dA: \", f5.2,\" [cm&#94;3]\")' ) pass_grid % da write ( * , * ) '' endif end subroutine make_passive_grid","tags":"","loc":"proc/make_passive_grid.html","title":"make_passive_grid – FIDASIM"},{"text":"public subroutine make_diagnostic_grids() Makes [[libfida:pass_grid] from user defined inputs, and stores the quantities in spec_chords and npa_chords Arguments None Calls proc~~make_diagnostic_grids~~CallsGraph proc~make_diagnostic_grids make_diagnostic_grids proc~get_fields get_fields proc~make_diagnostic_grids->proc~get_fields proc~track_cylindrical track_cylindrical proc~make_diagnostic_grids->proc~track_cylindrical proc~hit_npa_detector hit_npa_detector proc~make_diagnostic_grids->proc~hit_npa_detector proc~ind2sub ind2sub proc~make_diagnostic_grids->proc~ind2sub proc~grid_intersect grid_intersect proc~make_diagnostic_grids->proc~grid_intersect proc~track track proc~make_diagnostic_grids->proc~track interface~randu randu proc~make_diagnostic_grids->interface~randu interface~parallel_sum parallel_sum proc~make_diagnostic_grids->interface~parallel_sum proc~line_basis line_basis proc~make_diagnostic_grids->proc~line_basis proc~make_passive_grid make_passive_grid proc~make_diagnostic_grids->proc~make_passive_grid proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~track_cylindrical->proc~get_fields proc~plane_basis plane_basis proc~track_cylindrical->proc~plane_basis proc~cyl_to_uvw cyl_to_uvw proc~track_cylindrical->proc~cyl_to_uvw proc~get_passive_grid_indices get_passive_grid_indices proc~track_cylindrical->proc~get_passive_grid_indices proc~track_cylindrical->proc~in_plasma proc~doppler_stark doppler_stark proc~track_cylindrical->proc~doppler_stark proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector->proc~line_plane_intersect proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~in_passive_grid in_passive_grid proc~grid_intersect->proc~in_passive_grid proc~track->proc~get_fields proc~get_indices get_indices proc~track->proc~get_indices proc~track->proc~in_plasma proc~track->proc~doppler_stark proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~tb_zyx tb_zyx proc~line_basis->proc~tb_zyx proc~get_plasma_extrema get_plasma_extrema proc~make_passive_grid->proc~get_plasma_extrema proc~cross_product cross_product proc~plane_basis->proc~cross_product mpi_allreduce mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~in_plasma->proc~cyl_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~get_plasma_extrema->proc~in_plasma proc~uvw_to_cyl uvw_to_cyl proc~in_passive_grid->proc~uvw_to_cyl proc~approx_le approx_le proc~in_passive_grid->proc~approx_le proc~approx_ge approx_ge proc~in_passive_grid->proc~approx_ge proc~approx_eq approx_eq proc~approx_le->proc~approx_eq proc~approx_ge->proc~approx_eq proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocmake_diagnostic_gridsCallsGraph = svgPanZoom('#procmake_diagnostic_gridsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~make_diagnostic_grids~~CalledByGraph proc~make_diagnostic_grids make_diagnostic_grids program~fidasim fidasim program~fidasim->proc~make_diagnostic_grids Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code make_diagnostic_grids Source Code subroutine make_diagnostic_grids !+ Makes [[libfida:pass_grid] from user defined inputs, and stores the quantities in !+ [[libfida:spec_chords]] and [[libfida:npa_chords]] real ( Float64 ), dimension (:,:,:), allocatable :: dlength type ( LOSElement ), dimension (:), allocatable :: los_elem type ( ParticleTrack ), dimension (:), allocatable :: tracks real ( Float64 ) :: r0 ( 3 ), v0 ( 3 ), r_enter ( 3 ), r_exit ( 3 ), r0_cyl ( 3 ), ri ( 3 ) real ( Float64 ), dimension ( 3 , 3 ) :: basis real ( Float64 ), dimension ( 2 ) :: randomu real ( Float64 ) :: theta , sqrt_rho , dl , length character ( len = 20 ) :: system = '' real ( Float64 ), dimension (:), allocatable :: probs real ( Float64 ), dimension (:,:), allocatable :: eff_rds real ( Float64 ), parameter :: inv_4pi = ( 4.d0 * pi ) ** ( - 1 ) real ( Float64 ), dimension ( 3 ) :: eff_rd , rd , rd_d , r0_d real ( Float64 ), dimension ( 3 , 3 ) :: inv_basis real ( Float64 ), dimension (:), allocatable :: xd , yd type ( LocalEMFields ) :: fields real ( Float64 ) :: total_prob , hh , hw , dprob , dx , dy , r , pitch integer :: ichan , k , id , ix , iy , d_index , nd , ind_d ( 2 ) integer :: i , j , ic , nc , ntrack , ind ( 3 ), ii , jj , kk integer :: error if ( inputs % calc_pfida + inputs % calc_pnpa . gt . 0 ) then if ( inter_grid % nphi . gt . 1 ) then pass_grid = inter_grid else call make_passive_grid () endif endif !! Spectral line-of-sight passive neutral grid intersection calculations allocate ( spec_chords % cyl_inter ( pass_grid % nr , pass_grid % nz , pass_grid % nphi )) if ( inputs % calc_pfida . gt . 0 ) then allocate ( tracks ( pass_grid % ntrack )) allocate ( dlength ( pass_grid % nr , & pass_grid % nz , & pass_grid % nphi ) ) pass_grid_chan_loop : do i = 1 , spec_chords % nchan r0 = spec_chords % los ( i )% lens_uvw v0 = spec_chords % los ( i )% axis_uvw v0 = v0 / norm2 ( v0 ) call line_basis ( r0 , v0 , basis ) call grid_intersect ( r0 , v0 , length , r_enter , r_exit , passive = . True .) if ( length . le . 0.d0 ) then if ( inputs % verbose . ge . 1 ) then WRITE ( * , '(\"Channel \",i5,\" missed the passive neutral grid or starts inside the plasma\")' ) i endif cycle pass_grid_chan_loop endif if ( spec_chords % los ( i )% spot_size . le . 0.d0 ) then nc = 1 else nc = 100 endif dlength = 0.d0 !$OMP PARALLEL DO schedule(guided) private(ic,randomu,sqrt_rho,theta,r0, & !$OMP& length, r_enter, r_exit, j, tracks, ntrack, ind) do ic = 1 , nc ! Uniformally sample within spot size call randu ( randomu ) sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) r0 ( 1 ) = 0.d0 r0 ( 2 ) = spec_chords % los ( i )% spot_size * sqrt_rho * cos ( theta ) r0 ( 3 ) = spec_chords % los ( i )% spot_size * sqrt_rho * sin ( theta ) r0 = matmul ( basis , r0 ) + spec_chords % los ( i )% lens_uvw call grid_intersect ( r0 , v0 , length , r_enter , r_exit , passive = . True .) call track_cylindrical ( r_enter , v0 , tracks , ntrack ) pass_grid_track_loop : do j = 1 , ntrack ind = tracks ( j )% ind !inds can repeat so add rather than assign !$OMP ATOMIC UPDATE dlength ( ind ( 1 ), ind ( 2 ), ind ( 3 )) = & dlength ( ind ( 1 ), ind ( 2 ), ind ( 3 )) + tracks ( j )% time / real ( nc ) !time == distance !$OMP END ATOMIC enddo pass_grid_track_loop enddo !$OMP END PARALLEL DO do kk = 1 , pass_grid % nphi do jj = 1 , pass_grid % nz rloop : do ii = 1 , pass_grid % nr if ( dlength ( ii , jj , kk ). ne . 0.d0 ) then dl = dlength ( ii , jj , kk ) nc = spec_chords % cyl_inter ( ii , jj , kk )% nchan + 1 if ( nc . eq . 1 ) then allocate ( spec_chords % cyl_inter ( ii , jj , kk )% los_elem ( nc )) spec_chords % cyl_inter ( ii , jj , kk )% los_elem ( nc ) = LOSElement ( i , dl ) else allocate ( los_elem ( nc )) los_elem ( 1 :( nc - 1 )) = spec_chords % cyl_inter ( ii , jj , kk )% los_elem los_elem ( nc ) = LOSElement ( i , dl ) deallocate ( spec_chords % cyl_inter ( ii , jj , kk )% los_elem ) call move_alloc ( los_elem , spec_chords % cyl_inter ( ii , jj , kk )% los_elem ) endif spec_chords % cyl_inter ( ii , jj , kk )% nchan = nc endif enddo rloop enddo enddo enddo pass_grid_chan_loop spec_chords % cyl_ncell = count ( spec_chords % cyl_inter % nchan . gt . 0 ) allocate ( spec_chords % cyl_cell ( spec_chords % cyl_ncell )) nc = 0 do ic = 1 , pass_grid % ngrid call ind2sub ( pass_grid % dims , ic , ind ) ii = ind ( 1 ) ; jj = ind ( 2 ) ; kk = ind ( 3 ) if ( spec_chords % cyl_inter ( ii , jj , kk )% nchan . gt . 0 ) then nc = nc + 1 spec_chords % cyl_cell ( nc ) = ic endif enddo deallocate ( dlength , tracks ) endif !! Spectral line-of-sight beam grid intersection calculations if (( inputs % tot_spectra + inputs % calc_fida_wght - inputs % calc_pfida ). gt . 0 ) then allocate ( dlength ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz ) ) allocate ( tracks ( beam_grid % ntrack )) spec_chan_loop : do i = 1 , spec_chords % nchan r0 = spec_chords % los ( i )% lens v0 = spec_chords % los ( i )% axis v0 = v0 / norm2 ( v0 ) call line_basis ( r0 , v0 , basis ) call grid_intersect ( r0 , v0 , length , r_enter , r_exit ) if ( length . le . 0.d0 ) then if ( inputs % verbose . ge . 1 ) then WRITE ( * , '(\"Channel \",i5,\" missed the beam grid\")' ) i endif cycle spec_chan_loop endif if ( spec_chords % los ( i )% spot_size . le . 0.d0 ) then nc = 1 else nc = 100 endif dlength = 0.d0 !$OMP PARALLEL DO schedule(guided) private(ic,randomu,sqrt_rho,theta,r0, & !$OMP& length, r_enter, r_exit, j, tracks, ntrack, ind) do ic = 1 , nc ! Uniformally sample within spot size call randu ( randomu ) sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) r0 ( 1 ) = 0.d0 r0 ( 2 ) = spec_chords % los ( i )% spot_size * sqrt_rho * cos ( theta ) r0 ( 3 ) = spec_chords % los ( i )% spot_size * sqrt_rho * sin ( theta ) r0 = matmul ( basis , r0 ) + spec_chords % los ( i )% lens call grid_intersect ( r0 , v0 , length , r_enter , r_exit ) call track ( r_enter , v0 , tracks , ntrack ) track_loop : do j = 1 , ntrack ind = tracks ( j )% ind !inds can repeat so add rather than assign !$OMP ATOMIC UPDATE dlength ( ind ( 1 ), ind ( 2 ), ind ( 3 )) = & dlength ( ind ( 1 ), ind ( 2 ), ind ( 3 )) + tracks ( j )% time / real ( nc ) !time == distance !$OMP END ATOMIC enddo track_loop enddo !$OMP END PARALLEL DO do kk = 1 , beam_grid % nz do jj = 1 , beam_grid % ny xloop : do ii = 1 , beam_grid % nx if ( dlength ( ii , jj , kk ). ne . 0.d0 ) then dl = dlength ( ii , jj , kk ) nc = spec_chords % inter ( ii , jj , kk )% nchan + 1 if ( nc . eq . 1 ) then allocate ( spec_chords % inter ( ii , jj , kk )% los_elem ( nc )) spec_chords % inter ( ii , jj , kk )% los_elem ( nc ) = LOSElement ( i , dl ) else allocate ( los_elem ( nc )) los_elem ( 1 :( nc - 1 )) = spec_chords % inter ( ii , jj , kk )% los_elem los_elem ( nc ) = LOSElement ( i , dl ) deallocate ( spec_chords % inter ( ii , jj , kk )% los_elem ) call move_alloc ( los_elem , spec_chords % inter ( ii , jj , kk )% los_elem ) endif spec_chords % inter ( ii , jj , kk )% nchan = nc endif enddo xloop enddo enddo enddo spec_chan_loop spec_chords % ncell = count ( spec_chords % inter % nchan . gt . 0 ) allocate ( spec_chords % cell ( spec_chords % ncell )) nc = 0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) ii = ind ( 1 ) ; jj = ind ( 2 ) ; kk = ind ( 3 ) if ( spec_chords % inter ( ii , jj , kk )% nchan . gt . 0 ) then nc = nc + 1 spec_chords % cell ( nc ) = ic endif enddo endif !! NPA probability calculations allocate ( xd ( 50 ), yd ( 50 )) allocate ( probs ( beam_grid % ngrid )) allocate ( eff_rds ( 3 , beam_grid % ngrid )) allocate ( npa_chords % phit ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan ) ) allocate ( npa_chords % hit ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz ) ) npa_chords % hit = . False . npa_chan_loop : do ichan = 1 , npa_chords % nchan v0 = npa_chords % det ( ichan )% aperture % origin - npa_chords % det ( ichan )% detector % origin v0 = v0 / norm2 ( v0 ) call grid_intersect ( npa_chords % det ( ichan )% detector % origin , v0 , length , r0 , r0_d ) if ( length . le . 0.0 ) then if ( inputs % verbose . ge . 0 ) then WRITE ( * , '(\"Channel \",i3,\" centerline missed the beam grid\")' ) ichan endif endif if ( inputs % calc_npa_wght . ge . 1 ) then hw = npa_chords % det ( ichan )% detector % hw hh = npa_chords % det ( ichan )% detector % hh nd = size ( xd ) do i = 1 , nd xd ( i ) = - hw + 2 * hw * ( i - 0.5 ) / real ( nd ) yd ( i ) = - hh + 2 * hh * ( i - 0.5 ) / real ( nd ) enddo dx = abs ( xd ( 2 ) - xd ( 1 )) dy = abs ( yd ( 2 ) - yd ( 1 )) basis = npa_chords % det ( ichan )% detector % basis inv_basis = npa_chords % det ( ichan )% detector % inv_basis eff_rds = 0.d0 probs = 0.d0 ! For each grid point find the probability of hitting the detector given an isotropic source !$OMP PARALLEL DO schedule(guided) private(ic,i,j,k,ix,iy,total_prob,eff_rd,r0,r0_d, & !$OMP& rd_d,rd,d_index,v0,dprob,r,fields,id,ind_d,ind) do ic = istart , beam_grid % ngrid , istep call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) r0 = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] r0_d = matmul ( inv_basis , r0 - npa_chords % det ( ichan )% detector % origin ) do id = 1 , nd * nd call ind2sub ([ nd , nd ], id , ind_d ) ix = ind_d ( 1 ) ; iy = ind_d ( 2 ) rd_d = [ xd ( ix ), yd ( iy ), 0.d0 ] rd = matmul ( basis , rd_d ) + npa_chords % det ( ichan )% detector % origin v0 = rd - r0 d_index = 0 call hit_npa_detector ( r0 , v0 , d_index , det = ichan ) if ( d_index . ne . 0 ) then r = norm2 ( rd_d - r0_d ) ** 2 dprob = ( dx * dy ) * inv_4pi * r0_d ( 3 ) / ( r * sqrt ( r )) eff_rds (:, ic ) = eff_rds (:, ic ) + dprob * rd probs ( ic ) = probs ( ic ) + dprob endif enddo enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( eff_rds ) call parallel_sum ( probs ) #endif do ic = 1 , beam_grid % ngrid if ( probs ( ic ). gt . 0.0 ) then call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) r0 = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] eff_rd = eff_rds (:, ic ) / probs ( ic ) call get_fields ( fields , pos = r0 ) v0 = ( eff_rd - r0 ) / norm2 ( eff_rd - r0 ) npa_chords % phit ( i , j , k , ichan )% pitch = dot_product ( fields % b_norm , v0 ) npa_chords % phit ( i , j , k , ichan )% p = probs ( ic ) npa_chords % phit ( i , j , k , ichan )% dir = v0 npa_chords % phit ( i , j , k , ichan )% eff_rd = eff_rd npa_chords % hit ( i , j , k ) = . True . endif enddo total_prob = sum ( probs ) if ( total_prob . le . 0.d0 ) then if ( inputs % verbose . ge . 0 ) then WRITE ( * , '(\"Channel \",i3,\" missed the beam grid\")' ) ichan endif cycle npa_chan_loop endif endif enddo npa_chan_loop deallocate ( probs , eff_rds , xd , yd ) end subroutine make_diagnostic_grids","tags":"","loc":"proc/make_diagnostic_grids.html","title":"make_diagnostic_grids – FIDASIM"},{"text":"public subroutine read_beam() Reads neutral beam geometry and stores the quantities in nbi Arguments None Calls proc~~read_beam~~CallsGraph proc~read_beam read_beam h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_beam->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_beam->h5ltread_dataset_int_f h5close_f h5close_f proc~read_beam->h5close_f h5gopen_f h5gopen_f proc~read_beam->h5gopen_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_beam->proc~h5ltread_dataset_double_scalar_f h5ltpath_valid_f h5ltpath_valid_f proc~read_beam->h5ltpath_valid_f h5gclose_f h5gclose_f proc~read_beam->h5gclose_f proc~uvw_to_xyz uvw_to_xyz proc~read_beam->proc~uvw_to_xyz proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_beam->proc~h5ltread_dataset_int_scalar_f h5open_f h5open_f proc~read_beam->h5open_f h5ltread_dataset_string_f h5ltread_dataset_string_f proc~read_beam->h5ltread_dataset_string_f proc~tb_zyx tb_zyx proc~read_beam->proc~tb_zyx h5fclose_f h5fclose_f proc~read_beam->h5fclose_f h5fopen_f h5fopen_f proc~read_beam->h5fopen_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_beam Source Code subroutine read_beam !+ Reads neutral beam geometry and stores the quantities in [[libfida:nbi]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 1 ) :: dims real ( Float64 ), dimension ( 3 ) :: uvw_src , uvw_axis , pos real ( Float64 ) :: dis logical :: path_valid integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDONLY_F , fid , error ) !!Check if SPEC group exists call h5ltpath_valid_f ( fid , \"/nbi\" , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_BEAM: NBI geometry is not in the geometry file' endif stop endif !!Open NBI group call h5gopen_f ( fid , \"/nbi\" , gid , error ) !!Read in beam definitions call h5ltread_dataset_string_f ( gid , \"/nbi/name\" , nbi % name , error ) dims ( 1 ) = 3 call h5ltread_dataset_double_f ( gid , \"/nbi/src\" , uvw_src , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/axis\" , uvw_axis , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/divy\" , nbi % divy , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/divz\" , nbi % divz , dims , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/nbi/shape\" , nbi % shape , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/focy\" , nbi % focy , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/focz\" , nbi % focz , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/widy\" , nbi % widy , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/widz\" , nbi % widz , error ) !!Read in aperture definitions !! Check for naperture for compatibility with old runs call h5ltpath_valid_f ( gid , \"/nbi/naperture\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltread_dataset_int_scalar_f ( gid , \"/nbi/naperture\" , nbi % naperture , error ) else nbi % naperture = 0 endif if ( nbi % naperture . gt . 0 ) then allocate ( nbi % ashape ( nbi % naperture ), nbi % adist ( nbi % naperture ), & nbi % awidy ( nbi % naperture ), nbi % awidz ( nbi % naperture ), & nbi % aoffy ( nbi % naperture ), nbi % aoffz ( nbi % naperture ) ) dims ( 1 ) = nbi % naperture call h5ltread_dataset_int_f ( gid , \"/nbi/ashape\" , nbi % ashape , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/awidy\" , nbi % awidy , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/awidz\" , nbi % awidz , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/aoffy\" , nbi % aoffy , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/aoffz\" , nbi % aoffz , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/adist\" , nbi % adist , dims , error ) endif !!Close NBI group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) !!Convert to beam grid coordinates call uvw_to_xyz ( uvw_src , nbi % src ) nbi % axis = matmul ( beam_grid % inv_basis , uvw_axis ) nbi % vinj = sqrt ( 2.d0 * nbi % einj * 1.d3 * e0 / ( inputs % ab * mass_u )) * 1.d2 !! [cm/s] pos = nbi % src + 20 0.0 * nbi % axis dis = sqrt ( sum (( pos - nbi % src ) ** 2 )) nbi % beta = asin (( nbi % src ( 3 ) - pos ( 3 )) / dis ) nbi % alpha = atan2 ( pos ( 2 ) - nbi % src ( 2 ), pos ( 1 ) - nbi % src ( 1 )) call tb_zyx ( nbi % alpha , nbi % beta , 0.d0 , nbi % basis , nbi % inv_basis ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Neutral beam settings ----' write ( * , '(T2,\"Beam: \",a)' ) nbi % name write ( * , '(T2,\"Power:   \",f5.2,\" [MW]\")' ) nbi % pinj write ( * , '(T2,\"Voltage: \",f6.2,\" [keV]\")' ) nbi % einj write ( * , * ) '' endif end subroutine read_beam","tags":"","loc":"proc/read_beam.html","title":"read_beam – FIDASIM"},{"text":"public subroutine read_chords() Reads the spectral geometry and stores the quantities in spec_chords Arguments None Calls proc~~read_chords~~CallsGraph proc~read_chords read_chords h5ltread_dataset_string_f h5ltread_dataset_string_f proc~read_chords->h5ltread_dataset_string_f h5close_f h5close_f proc~read_chords->h5close_f h5gopen_f h5gopen_f proc~read_chords->h5gopen_f h5ltpath_valid_f h5ltpath_valid_f proc~read_chords->h5ltpath_valid_f h5gclose_f h5gclose_f proc~read_chords->h5gclose_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_chords->proc~h5ltread_dataset_int_scalar_f h5open_f h5open_f proc~read_chords->h5open_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_chords->h5ltread_dataset_double_f h5fclose_f h5fclose_f proc~read_chords->h5fclose_f h5fopen_f h5fopen_f proc~read_chords->h5fopen_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_chords~~CalledByGraph proc~read_chords read_chords program~fidasim fidasim program~fidasim->proc~read_chords Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_chords Source Code subroutine read_chords !+ Reads the spectral geometry and stores the quantities in [[libfida:spec_chords]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 2 ) :: dims logical :: path_valid real ( Float64 ), dimension (:,:), allocatable :: lenses real ( Float64 ), dimension (:,:), allocatable :: axes real ( Float64 ) :: xyz_lens ( 3 ), xyz_axis ( 3 ) character ( len = 20 ) :: system = '' integer :: i integer :: error if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- FIDA/BES settings ----' endif !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDONLY_F , fid , error ) !!Check if SPEC group exists call h5ltpath_valid_f ( fid , \"/spec\" , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) 'FIDA/BES geometry is not in the geometry file' write ( * , '(a)' ) 'Continuing without spectral diagnostics' endif inputs % calc_spec = 0 inputs % tot_spectra = 0 inputs % calc_fida = 0 inputs % calc_pfida = 0 inputs % calc_bes = 0 inputs % calc_dcx = 0 inputs % calc_halo = 0 inputs % calc_cold = 0 inputs % calc_brems = 0 inputs % calc_fida_wght = 0 call h5fclose_f ( fid , error ) call h5close_f ( error ) return endif !!Open SPEC group call h5gopen_f ( fid , \"/spec\" , gid , error ) call h5ltread_dataset_string_f ( gid , \"/spec/system\" , system , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/spec/nchan\" , spec_chords % nchan , error ) allocate ( lenses ( 3 , spec_chords % nchan )) allocate ( axes ( 3 , spec_chords % nchan )) allocate ( spec_chords % los ( spec_chords % nchan )) allocate ( spec_chords % radius ( spec_chords % nchan )) dims = [ 3 , spec_chords % nchan ] call h5ltread_dataset_double_f ( gid , \"/spec/lens\" , lenses , dims , error ) call h5ltread_dataset_double_f ( gid , \"/spec/axis\" , axes , dims , error ) call h5ltread_dataset_double_f ( gid , \"/spec/spot_size\" , spec_chords % los % spot_size , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/spec/sigma_pi\" , spec_chords % los % sigma_pi , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/spec/radius\" , spec_chords % radius , dims ( 2 : 2 ), error ) !!Close SPEC group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) chan_loop : do i = 1 , spec_chords % nchan call uvw_to_xyz ( lenses (:, i ), xyz_lens ) xyz_axis = matmul ( beam_grid % inv_basis , axes (:, i )) spec_chords % los ( i )% lens = xyz_lens spec_chords % los ( i )% axis = xyz_axis spec_chords % los ( i )% lens_uvw = lenses (:, i ) spec_chords % los ( i )% axis_uvw = axes (:, i ) enddo chan_loop if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"FIDA/BES System: \",a)' ) trim ( adjustl ( system )) write ( * , '(T2,\"Number of channels: \",i5)' ) spec_chords % nchan write ( * , * ) '' endif deallocate ( lenses , axes ) end subroutine read_chords","tags":"","loc":"proc/read_chords.html","title":"read_chords – FIDASIM"},{"text":"public subroutine read_npa() Reads the NPA geometry and stores the quantities in npa_chords Arguments None Calls proc~~read_npa~~CallsGraph proc~read_npa read_npa h5ltread_dataset_string_f h5ltread_dataset_string_f proc~read_npa->h5ltread_dataset_string_f h5close_f h5close_f proc~read_npa->h5close_f h5gopen_f h5gopen_f proc~read_npa->h5gopen_f proc~plane_basis plane_basis proc~read_npa->proc~plane_basis h5ltpath_valid_f h5ltpath_valid_f proc~read_npa->h5ltpath_valid_f h5gclose_f h5gclose_f proc~read_npa->h5gclose_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_npa->proc~h5ltread_dataset_int_scalar_f h5open_f h5open_f proc~read_npa->h5open_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_npa->h5ltread_dataset_double_f h5fclose_f h5fclose_f proc~read_npa->h5fclose_f h5fopen_f h5fopen_f proc~read_npa->h5fopen_f proc~cross_product cross_product proc~plane_basis->proc~cross_product h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_npa~~CalledByGraph proc~read_npa read_npa program~fidasim fidasim program~fidasim->proc~read_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_npa Source Code subroutine read_npa !+ Reads the NPA geometry and stores the quantities in [[libfida:npa_chords]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 2 ) :: dims logical :: path_valid real ( Float64 ), dimension (:,:), allocatable :: a_tedge , a_redge , a_cent real ( Float64 ), dimension (:,:), allocatable :: d_tedge , d_redge , d_cent character ( len = 20 ) :: system = '' real ( Float64 ), dimension ( 3 ) :: xyz_a_tedge , xyz_a_redge , xyz_a_cent real ( Float64 ), dimension ( 3 ) :: xyz_d_tedge , xyz_d_redge , xyz_d_cent real ( Float64 ), dimension ( 3 , 3 ) :: basis , inv_basis real ( Float64 ) :: hh , hw integer :: ichan integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDWR_F , fid , error ) !!Check if NPA group exists call h5ltpath_valid_f ( fid , \"/npa\" , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'NPA geometry is not in the geometry file' write ( * , '(a)' ) 'Continuing without NPA diagnostics' endif inputs % calc_npa = 0 inputs % calc_pnpa = 0 inputs % calc_npa_wght = 0 call h5fclose_f ( fid , error ) call h5close_f ( error ) return endif !!Open NPA group call h5gopen_f ( fid , \"/npa\" , gid , error ) call h5ltread_dataset_string_f ( gid , \"/npa/system\" , system , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/npa/nchan\" , npa_chords % nchan , error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- NPA settings ----\" write ( * , '(T2,\"NPA System: \", a)' ) trim ( adjustl ( system )) write ( * , '(T2,\"Number of channels: \",i3)' ) npa_chords % nchan endif allocate ( a_tedge ( 3 , npa_chords % nchan )) allocate ( a_redge ( 3 , npa_chords % nchan )) allocate ( a_cent ( 3 , npa_chords % nchan )) allocate ( d_tedge ( 3 , npa_chords % nchan )) allocate ( d_redge ( 3 , npa_chords % nchan )) allocate ( d_cent ( 3 , npa_chords % nchan )) allocate ( npa_chords % radius ( npa_chords % nchan )) allocate ( npa_chords % det ( npa_chords % nchan )) dims = [ 3 , spec_chords % nchan ] call h5ltread_dataset_double_f ( gid , \"/npa/radius\" , npa_chords % radius , dims ( 2 : 2 ), error ) call h5ltread_dataset_int_f ( gid , \"/npa/a_shape\" , npa_chords % det % aperture % shape , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_tedge\" , a_tedge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_redge\" , a_redge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_cent\" , a_cent , dims , error ) call h5ltread_dataset_int_f ( gid , \"/npa/d_shape\" , npa_chords % det % detector % shape , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_tedge\" , d_tedge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_redge\" , d_redge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_cent\" , d_cent , dims , error ) !!Close NPA group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) chan_loop : do ichan = 1 , npa_chords % nchan ! Convert to beam grid coordinates call uvw_to_xyz ( a_cent (:, ichan ), xyz_a_cent ) call uvw_to_xyz ( a_redge (:, ichan ), xyz_a_redge ) call uvw_to_xyz ( a_tedge (:, ichan ), xyz_a_tedge ) call uvw_to_xyz ( d_cent (:, ichan ), xyz_d_cent ) call uvw_to_xyz ( d_redge (:, ichan ), xyz_d_redge ) call uvw_to_xyz ( d_tedge (:, ichan ), xyz_d_tedge ) ! Define detector/aperture hh/hw npa_chords % det ( ichan )% detector % hw = norm2 ( xyz_d_redge - xyz_d_cent ) npa_chords % det ( ichan )% aperture % hw = norm2 ( xyz_a_redge - xyz_a_cent ) npa_chords % det ( ichan )% detector % hh = norm2 ( xyz_d_tedge - xyz_d_cent ) npa_chords % det ( ichan )% aperture % hh = norm2 ( xyz_a_tedge - xyz_a_cent ) ! Define detector/aperture origin npa_chords % det ( ichan )% detector % origin = xyz_d_cent npa_chords % det ( ichan )% aperture % origin = xyz_a_cent ! Define detector/aperture basis call plane_basis ( xyz_d_cent , xyz_d_redge , xyz_d_tedge , & npa_chords % det ( ichan )% detector % basis , & npa_chords % det ( ichan )% detector % inv_basis ) call plane_basis ( xyz_a_cent , xyz_a_redge , xyz_a_tedge , & npa_chords % det ( ichan )% aperture % basis , & npa_chords % det ( ichan )% aperture % inv_basis ) enddo chan_loop if ( inputs % verbose . ge . 1 ) write ( * , '(50X,a)' ) \"\" deallocate ( a_cent , a_redge , a_tedge ) deallocate ( d_cent , d_redge , d_tedge ) end subroutine read_npa","tags":"","loc":"proc/read_npa.html","title":"read_npa – FIDASIM"},{"text":"public subroutine read_equilibrium() Reads in the interpolation grid, plasma parameters, and fields\n and stores the quantities in inter_grid and equil Arguments None Calls proc~~read_equilibrium~~CallsGraph proc~read_equilibrium read_equilibrium h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_equilibrium->h5ltread_dataset_int_f proc~ind2sub ind2sub proc~read_equilibrium->proc~ind2sub h5gopen_f h5gopen_f proc~read_equilibrium->h5gopen_f h5ltpath_valid_f h5ltpath_valid_f proc~read_equilibrium->h5ltpath_valid_f h5gclose_f h5gclose_f proc~read_equilibrium->h5gclose_f proc~colrad colrad proc~read_equilibrium->proc~colrad proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_equilibrium->proc~h5ltread_dataset_int_scalar_f h5open_f h5open_f proc~read_equilibrium->h5open_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_equilibrium->h5ltread_dataset_double_f interface~randn randn proc~read_equilibrium->interface~randn interface~deriv deriv proc~read_equilibrium->interface~deriv h5close_f h5close_f proc~read_equilibrium->h5close_f h5fclose_f h5fclose_f proc~read_equilibrium->h5fclose_f h5fopen_f h5fopen_f proc~read_equilibrium->h5fopen_f proc~eigen eigen proc~colrad->proc~eigen proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~linsolve linsolve proc~colrad->proc~linsolve proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~balback balback proc~eigen->proc~balback proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balance balance proc~eigen->proc~balance interface~interpol_coeff interpol_coeff proc~get_rate_matrix->interface~interpol_coeff proc~matinv matinv proc~linsolve->proc~matinv dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocread_equilibriumCallsGraph = svgPanZoom('#procread_equilibriumCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_equilibrium~~CalledByGraph proc~read_equilibrium read_equilibrium program~fidasim fidasim program~fidasim->proc~read_equilibrium Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_equilibrium Source Code subroutine read_equilibrium !+ Reads in the interpolation grid, plasma parameters, and fields !+ and stores the quantities in [[libfida:inter_grid]] and [[libfida:equil]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 3 ) :: dims integer :: impc , ic , ir , iz , iphi , it , ind ( 3 ), i type ( LocalProfiles ) :: plasma real ( Float64 ) :: photons real ( Float64 ), dimension ( nlevs ) :: rates , denn , rates_avg real ( Float64 ), dimension ( 3 ) :: vi , random3 integer :: error integer :: n = 50 logical :: path_valid integer , dimension (:,:,:), allocatable :: p_mask , f_mask real ( Float64 ), dimension (:,:,:), allocatable :: denn3d !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % equilibrium_file , H5F_ACC_RDONLY_F , fid , error ) !!Open PLASMA group call h5gopen_f ( fid , \"/plasma\" , gid , error ) !!Read in interpolation grid call h5ltread_dataset_int_scalar_f ( gid , \"/plasma/nr\" , inter_grid % nr , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/plasma/nz\" , inter_grid % nz , error ) call h5ltpath_valid_f ( gid , \"/plasma/nphi\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltread_dataset_int_scalar_f ( gid , \"/plasma/nphi\" , inter_grid % nphi , error ) else inter_grid % nphi = 1 endif inter_grid % dims = [ inter_grid % nr , inter_grid % nz , inter_grid % nphi ] allocate ( inter_grid % r ( inter_grid % nr ), inter_grid % z ( inter_grid % nz ), inter_grid % phi ( inter_grid % nphi )) allocate ( p_mask ( inter_grid % nr , inter_grid % nz , inter_grid % nphi )) allocate ( f_mask ( inter_grid % nr , inter_grid % nz , inter_grid % nphi )) allocate ( denn3d ( inter_grid % nr , inter_grid % nz , inter_grid % nphi )) dims = [ inter_grid % nr , inter_grid % nz , inter_grid % nphi ] call h5ltread_dataset_double_f ( gid , \"/plasma/r\" , inter_grid % r , dims ( 1 : 1 ), error ) call h5ltread_dataset_double_f ( gid , \"/plasma/z\" , inter_grid % z , dims ( 2 : 2 ), error ) if ( path_valid ) then call h5ltread_dataset_double_f ( gid , \"/plasma/phi\" , inter_grid % phi , dims ( 3 : 3 ), error ) else inter_grid % phi = 0.d0 endif inter_grid % dr = abs ( inter_grid % r ( 2 ) - inter_grid % r ( 1 )) inter_grid % dz = abs ( inter_grid % z ( 2 ) - inter_grid % z ( 1 )) inter_grid % da = inter_grid % dr * inter_grid % dz if ( inter_grid % nphi . eq . 1 ) then inter_grid % dphi = 2 * pi else inter_grid % dphi = abs ( inter_grid % phi ( 2 ) - inter_grid % phi ( 1 )) endif inter_grid % dv = inter_grid % dr * inter_grid % dphi * inter_grid % dz inter_grid % ntrack = inter_grid % nr + inter_grid % nz + inter_grid % nphi inter_grid % ngrid = inter_grid % nr * inter_grid % nz * inter_grid % nphi if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Interpolation grid settings ----' write ( * , '(T2,\"Nr: \",i3)' ) inter_grid % nr write ( * , '(T2,\"Nz: \",i3)' ) inter_grid % nz if ( inter_grid % nphi . gt . 1 ) then write ( * , '(T2,\"Nphi: \",i3)' ) inter_grid % nphi endif write ( * , '(T2,\"dA: \", f5.2,\" [cm&#94;2]\")' ) inter_grid % da write ( * , * ) '' endif !!Read in plasma parameters allocate ( equil % plasma ( inter_grid % nr , inter_grid % nz , inter_grid % nphi )) call h5ltread_dataset_double_f ( gid , \"/plasma/dene\" , equil % plasma % dene , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/te\" , equil % plasma % te , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/ti\" , equil % plasma % ti , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/zeff\" , equil % plasma % zeff , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vr\" , equil % plasma % vr , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vt\" , equil % plasma % vt , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vz\" , equil % plasma % vz , dims , error ) call h5ltread_dataset_int_f ( gid , \"/plasma/mask\" , p_mask , dims , error ) impc = inputs % impurity_charge where ( equil % plasma % zeff . lt . 1.0 ) equil % plasma % zeff = 1 endwhere where ( equil % plasma % zeff . gt . impc ) equil % plasma % zeff = impc endwhere where ( equil % plasma % dene . lt . 0.0 ) equil % plasma % dene = 0.0 endwhere where ( equil % plasma % te . lt . 0.0 ) equil % plasma % te = 0.0 endwhere where ( equil % plasma % ti . lt . 0.0 ) equil % plasma % ti = 0.0 endwhere equil % plasma % denimp = (( equil % plasma % zeff - 1.d0 ) / ( impc * ( impc - 1.d0 ))) * equil % plasma % dene equil % plasma % denp = equil % plasma % dene - impc * equil % plasma % denimp call h5ltpath_valid_f ( fid , \"/plasma/denn\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltread_dataset_double_f ( gid , \"/plasma/denn\" , denn3d , dims , error ) where ( denn3d . lt . 0.0 ) denn3d = 0.0 endwhere else if (( inputs % calc_pnpa + inputs % calc_pfida + inputs % calc_cold ). gt . 0 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"READ_EQUILIBRIUM: Cold neutral density was not provided\" write ( * , '(a)' ) \"Continuing without passive calculations\" endif endif inputs % calc_pnpa = 0 inputs % calc_pfida = 0 inputs % calc_cold = 0 endif loop_over_cells : do ic = 1 , inter_grid % nr * inter_grid % nz * inter_grid % nphi call ind2sub ( inter_grid % dims , ic , ind ) ir = ind ( 1 ) ; iz = ind ( 2 ) ; iphi = ind ( 3 ) if ( p_mask ( ir , iz , iphi ). lt . 0.5 ) cycle loop_over_cells if ( denn3d ( ir , iz , iphi ). le . 0.0 ) cycle loop_over_cells plasma = equil % plasma ( ir , iz , iphi ) plasma % vrot = [ plasma % vr , plasma % vt , plasma % vz ] plasma % in_plasma = . True . rates_avg = 0.0 do it = 1 , n rates = 0.0 rates ( 1 ) = 1.d19 call randn ( random3 ) vi = plasma % vrot + sqrt ( plasma % ti * 0.5 / ( v2_to_E_per_amu * inputs % ai )) * random3 call colrad ( plasma , thermal_ion , vi , 1.0d-7 , rates , denn , photons ) rates_avg = rates_avg + rates / n enddo if ( sum ( rates_avg ). le . 0.0 ) cycle loop_over_cells equil % plasma ( ir , iz , iphi )% denn = denn3d ( ir , iz , iphi ) * ( rates_avg ) / sum ( rates_avg ) enddo loop_over_cells !!Close PLASMA group call h5gclose_f ( gid , error ) !!Open FIELDS group call h5gopen_f ( fid , \"/fields\" , gid , error ) allocate ( equil % fields ( inter_grid % nr , inter_grid % nz , inter_grid % nphi )) !!Read in electromagnetic fields call h5ltread_dataset_double_f ( gid , \"/fields/br\" , equil % fields % br , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/bt\" , equil % fields % bt , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/bz\" , equil % fields % bz , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/er\" , equil % fields % er , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/et\" , equil % fields % et , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/ez\" , equil % fields % ez , dims , error ) call h5ltread_dataset_int_f ( gid , \"/fields/mask\" , f_mask , dims , error ) !!Calculate B field derivatives call deriv ( inter_grid % r , inter_grid % z , inter_grid % phi , equil % fields % br , & equil % fields % dbr_dr , equil % fields % dbr_dz , equil % fields % dbr_dphi ) call deriv ( inter_grid % r , inter_grid % z , inter_grid % phi , equil % fields % bt , & equil % fields % dbt_dr , equil % fields % dbt_dz , equil % fields % dbt_dphi ) call deriv ( inter_grid % r , inter_grid % z , inter_grid % phi , equil % fields % bz , & equil % fields % dbz_dr , equil % fields % dbz_dz , equil % fields % dbz_dphi ) !!Close FIELDS group call h5gclose_f ( gid , error ) !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) allocate ( equil % mask ( inter_grid % nr , inter_grid % nz , inter_grid % nphi )) equil % mask = 0.d0 where (( p_mask . eq . 1 ). and .( f_mask . eq . 1 )) equil % mask = 1.d0 if ( sum ( equil % mask ). le . 0.d0 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"READ_EQUILIBRIUM: Plasma and/or fields are not well defined anywhere\" endif stop endif end subroutine read_equilibrium","tags":"","loc":"proc/read_equilibrium.html","title":"read_equilibrium – FIDASIM"},{"text":"public subroutine read_f(fid, error) Reads in the fast-ion distribution function and stores the quantities in fbm Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: fid HDF5 file ID integer, intent(out) :: error Error code Calls proc~~read_f~~CallsGraph proc~read_f read_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_f->proc~h5ltread_dataset_int_scalar_f h5ltpath_valid_f h5ltpath_valid_f proc~read_f->h5ltpath_valid_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_f~~CalledByGraph proc~read_f read_f proc~read_distribution read_distribution proc~read_distribution->proc~read_f program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_f Source Code subroutine read_f ( fid , error ) !+ Reads in the fast-ion distribution function and stores the quantities in [[libfida:fbm]] integer ( HID_T ), intent ( inout ) :: fid !+ HDF5 file ID integer , intent ( out ) :: error !+ Error code integer ( HSIZE_T ), dimension ( 5 ) :: dims real ( Float64 ) :: denp_tot integer :: ir logical :: path_valid if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Fast-ion distribution settings ----' endif call h5ltread_dataset_int_scalar_f ( fid , \"/nenergy\" , fbm % nenergy , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/npitch\" , fbm % npitch , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/nr\" , fbm % nr , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/nz\" , fbm % nz , error ) call h5ltpath_valid_f ( fid , \"/nphi\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltread_dataset_int_scalar_f ( fid , \"/nphi\" , fbm % nphi , error ) else fbm % nphi = 1 endif if ((( fbm % nr . ne . inter_grid % nr ). or .( fbm % nz . ne . inter_grid % nz )). or .( fbm % nphi . ne . inter_grid % nphi )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"READ_F: Distribution file has incompatable grid dimensions\" endif stop endif if ( fbm % nphi . eq . 1 ) then allocate ( fbm % energy ( fbm % nenergy ), fbm % pitch ( fbm % npitch ), fbm % r ( fbm % nr ), fbm % z ( fbm % nz ), fbm % phi ( 1 )) allocate ( fbm % denf ( fbm % nr , fbm % nz , 1 )) allocate ( fbm % f ( fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz , 1 )) else allocate ( fbm % energy ( fbm % nenergy ), fbm % pitch ( fbm % npitch ), fbm % r ( fbm % nr ), fbm % z ( fbm % nz ), fbm % phi ( fbm % nphi )) allocate ( fbm % denf ( fbm % nr , fbm % nz , fbm % nphi )) allocate ( fbm % f ( fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz , fbm % nphi )) endif if ( fbm % nphi . eq . 1 ) then dims = [ fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz , 1 ] call h5ltread_dataset_double_f ( fid , \"/denf\" , fbm % denf , dims ( 3 : 4 ), error ) call h5ltread_dataset_double_f ( fid , \"/f\" , fbm % f , dims ( 1 : 4 ), error ) else dims = [ fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz , fbm % nphi ] call h5ltread_dataset_double_f ( fid , \"/denf\" , fbm % denf , dims ( 3 : 5 ), error ) call h5ltread_dataset_double_f ( fid , \"/f\" , fbm % f , dims ( 1 : 5 ), error ) endif call h5ltread_dataset_double_f ( fid , \"/energy\" , fbm % energy , dims ( 1 : 1 ), error ) call h5ltread_dataset_double_f ( fid , \"/pitch\" , fbm % pitch , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( fid , \"/r\" , fbm % r , dims ( 3 : 3 ), error ) call h5ltread_dataset_double_f ( fid , \"/z\" , fbm % z , dims ( 4 : 4 ), error ) call h5ltpath_valid_f ( fid , \"/phi\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltread_dataset_double_f ( fid , \"/phi\" , fbm % phi , dims ( 5 : 5 ), error ) else fbm % phi = 0.d0 endif equil % plasma % denf = fbm % denf fbm % dE = abs ( fbm % energy ( 2 ) - fbm % energy ( 1 )) fbm % dp = abs ( fbm % pitch ( 2 ) - fbm % pitch ( 1 )) fbm % dr = abs ( fbm % r ( 2 ) - fbm % r ( 1 )) fbm % dz = abs ( fbm % z ( 2 ) - fbm % z ( 1 )) if ( fbm % nphi . eq . 1 ) then fbm % dphi = 2 * pi else fbm % dphi = abs ( fbm % phi ( 2 ) - fbm % phi ( 1 )) endif fbm % emin = minval ( fbm % energy , 1 ) fbm % emax = maxval ( fbm % energy , 1 ) fbm % e_range = fbm % emax - fbm % emin fbm % pmin = minval ( fbm % pitch , 1 ) fbm % pmax = maxval ( fbm % pitch , 1 ) fbm % p_range = fbm % pmax - fbm % pmin fbm % rmin = minval ( fbm % r , 1 ) fbm % rmax = maxval ( fbm % r , 1 ) fbm % r_range = fbm % rmax - fbm % rmin fbm % zmin = minval ( fbm % z , 1 ) fbm % zmax = maxval ( fbm % z , 1 ) fbm % z_range = fbm % zmax - fbm % zmin fbm % phimin = minval ( fbm % phi , 1 ) fbm % phimax = maxval ( fbm % phi , 1 ) fbm % phi_range = fbm % phimax - fbm % phimin denp_tot = 0.0 do ir = 1 , fbm % nr fbm % n_tot = fbm % n_tot + fbm % dphi * fbm % dr * fbm % dz * sum ( fbm % denf ( ir ,:,:)) * fbm % r ( ir ) denp_tot = denp_tot + fbm % dphi * fbm % dr * fbm % dz * sum ( equil % plasma ( ir ,:,:)% denp ) * fbm % r ( ir ) enddo if ( fbm % n_tot . ge . denp_tot ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,\" (\",ES10.3,\" >=\",ES10.3,\")\")' ) & \"READ_F: The total of number of fast ions exceeded the total number of thermal ions.\" , & fbm % n_tot , denp_tot write ( * , '(a)' ) \"This is usually caused by zeff being incorrect.\" endif stop endif if ( inputs % verbose . ge . 1 ) then if ( fbm % nphi . gt . 1 ) then write ( * , '(T2,\"Distribution type: \",a)' ) \"Non-axisymmetric Fast-ion Density Function F(energy,pitch,R,Z,Phi)\" else write ( * , '(T2,\"Distribution type: \",a)' ) \"Axisymmetric Fast-ion Density Function F(energy,pitch,R,Z)\" endif write ( * , '(T2,\"Nenergy = \",i3)' ) fbm % nenergy write ( * , '(T2,\"Npitch  = \",i3)' ) fbm % npitch write ( * , '(T2,\"Nr  = \",i3)' ) fbm % nr write ( * , '(T2,\"Nz  = \",i3)' ) fbm % nz if ( fbm % nphi . gt . 1 ) then write ( * , '(T2,\"Nphi  = \",i3)' ) fbm % nphi endif write ( * , '(T2,\"Energy range = [\",f5.2,\",\",f6.2,\"]\")' ) fbm % emin , fbm % emax write ( * , '(T2,\"Pitch  range = [\",f5.2,\",\",f5.2,\"]\")' ) fbm % pmin , fbm % pmax write ( * , '(T2,\"R  range = [\",f6.2,\",\",f6.2,\"]\")' ) fbm % rmin , fbm % rmax write ( * , '(T2,\"Z  range = [\",f7.2,\",\",f6.2,\"]\")' ) fbm % zmin , fbm % zmax if ( fbm % nphi . gt . 1 ) then write ( * , '(T2,\"Phi  range = [\",f5.2,\",\",f5.2,\"]\")' ) fbm % phimin , fbm % phimax endif write ( * , '(T2,\"Ntotal = \",ES10.3)' ) fbm % n_tot write ( * , * ) '' endif end subroutine read_f","tags":"","loc":"proc/read_f.html","title":"read_f – FIDASIM"},{"text":"public subroutine read_mc(fid, error) Reads in a MC particle fast-ion distribution and puts them in particles Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: fid HDF5 file ID integer, intent(out) :: error Error code Calls proc~~read_mc~~CallsGraph proc~read_mc read_mc proc~circle_grid_intersect circle_grid_intersect proc~read_mc->proc~circle_grid_intersect h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_mc->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_mc->h5ltread_dataset_int_f h5ltpath_valid_f h5ltpath_valid_f proc~read_mc->h5ltpath_valid_f proc~in_plasma in_plasma proc~read_mc->proc~in_plasma proc~uvw_to_xyz uvw_to_xyz proc~read_mc->proc~uvw_to_xyz proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_mc->proc~h5ltread_dataset_int_scalar_f proc~in_grid in_grid proc~read_mc->proc~in_grid proc~circle_grid_intersect->proc~in_grid proc~approx_eq approx_eq proc~circle_grid_intersect->proc~approx_eq proc~grid_intersect grid_intersect proc~circle_grid_intersect->proc~grid_intersect interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~approx_le approx_le proc~in_grid->proc~approx_le proc~approx_ge approx_ge proc~in_grid->proc~approx_ge proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~approx_le->proc~approx_eq proc~approx_ge->proc~approx_eq proc~in_passive_grid in_passive_grid proc~grid_intersect->proc~in_passive_grid proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~in_passive_grid->proc~approx_le proc~in_passive_grid->proc~approx_ge proc~uvw_to_cyl uvw_to_cyl proc~in_passive_grid->proc~uvw_to_cyl proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocread_mcCallsGraph = svgPanZoom('#procread_mcCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_mc~~CalledByGraph proc~read_mc read_mc proc~read_distribution read_distribution proc~read_distribution->proc~read_mc program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_mc Source Code subroutine read_mc ( fid , error ) !+ Reads in a MC particle fast-ion distribution and puts them in [[libfida:particles]] integer ( HID_T ), intent ( inout ) :: fid !+ HDF5 file ID integer , intent ( out ) :: error !+ Error code integer ( HSIZE_T ), dimension ( 1 ) :: dims integer ( Int32 ) :: i , j , ii , ir , iz , iphi , nphi real ( Float64 ) :: phi , beam_grid_phi_enter , beam_grid_phi_exit , delta_phi , xp , yp , zp real ( Float64 ), dimension ( 3 ) :: uvw , xyz , ri , vi , e1_xyz , e2_xyz , C_xyz , dum real ( Float64 ), dimension (:), allocatable :: weight type ( LocalEMFields ) :: fields integer :: cnt , num logical :: inp , path_valid character ( len = 50 ) :: dist_type_name = '' if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Fast-ion distribution settings ----' endif call h5ltread_dataset_int_scalar_f ( fid , \"/nparticle\" , particles % nparticle , error ) !!ALLOCATE SPACE allocate ( particles % fast_ion ( particles % nparticle )) allocate ( weight ( particles % nparticle )) dims ( 1 ) = particles % nparticle call h5ltread_dataset_double_f ( fid , \"/r\" , particles % fast_ion % r , dims , error ) call h5ltread_dataset_double_f ( fid , \"/z\" , particles % fast_ion % z , dims , error ) call h5ltpath_valid_f ( fid , \"/phi\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltread_dataset_double_f ( fid , \"/phi\" , particles % fast_ion % phi , dims , error ) particles % axisym = . False . endif call h5ltread_dataset_int_f ( fid , \"/class\" , particles % fast_ion % class , dims , error ) if ( any ( particles % fast_ion % class . le . 0 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_MC: Orbit class ID must be greater than 0' endif stop endif if ( inputs % split . ge . 1 ) then call h5ltread_dataset_int_scalar_f ( fid , \"/nclass\" , particles % nclass , error ) if ( any ( particles % fast_ion % class . gt . particles % nclass )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_MC: Orbit class ID greater than the number of classes' endif stop endif endif if ( inputs % dist_type . eq . 2 ) then if ( particles % axisym ) then dist_type_name = \"Axisymmetric Guiding Center Monte Carlo\" else dist_type_name = \"Non-axisymmetric Guiding Center Monte Carlo\" endif call h5ltread_dataset_double_f ( fid , \"/energy\" , particles % fast_ion % energy , dims , error ) call h5ltread_dataset_double_f ( fid , \"/pitch\" , particles % fast_ion % pitch , dims , error ) particles % fast_ion % vabs = sqrt ( particles % fast_ion % energy / ( v2_to_E_per_amu * inputs % ab )) else if ( particles % axisym ) then dist_type_name = \"Axisymmetric Full Orbit Monte Carlo\" else dist_type_name = \"Non-axisymmetric Full Orbit Monte Carlo\" endif call h5ltread_dataset_double_f ( fid , \"/vr\" , particles % fast_ion % vr , dims , error ) call h5ltread_dataset_double_f ( fid , \"/vt\" , particles % fast_ion % vt , dims , error ) call h5ltread_dataset_double_f ( fid , \"/vz\" , particles % fast_ion % vz , dims , error ) particles % fast_ion % vabs = sqrt ( particles % fast_ion % vr ** 2 + & particles % fast_ion % vt ** 2 + & particles % fast_ion % vz ** 2 ) particles % fast_ion % energy = v2_to_E_per_amu * inputs % ab * particles % fast_ion % vabs ** 2 endif call h5ltread_dataset_double_f ( fid , \"/weight\" , weight , dims , error ) cnt = 0 e1_xyz = matmul ( beam_grid % inv_basis ,[ 1.0 , 0.0 , 0.0 ]) e2_xyz = matmul ( beam_grid % inv_basis ,[ 0.0 , 1.0 , 0.0 ]) !$OMP PARALLEL DO schedule(guided) private(i,ii,j,ir,iz,iphi,fields,uvw,phi,ri,vi, & !$OMP& delta_phi,beam_grid_phi_enter,beam_grid_phi_exit,C_xyz,xyz,xp,yp,zp,dum,inp) particle_loop : do i = 1 , particles % nparticle if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt / real ( particles % nparticle ) * 100 , char ( 13 ) endif if ( particles % axisym ) then uvw = [ particles % fast_ion ( i )% r , 0.d0 , particles % fast_ion ( i )% z ] else xp = particles % fast_ion ( i )% r * cos ( particles % fast_ion ( i )% phi ) yp = particles % fast_ion ( i )% r * sin ( particles % fast_ion ( i )% phi ) zp = particles % fast_ion ( i )% z uvw = [ xp , yp , zp ] endif call in_plasma ( uvw , inp , input_coords = 1 ) if (. not . inp ) cycle particle_loop if ( particles % axisym ) then beam_grid_phi_enter = 0.0 beam_grid_phi_exit = 0.0 dum = [ 0.d0 , 0.d0 , particles % fast_ion ( i )% z ] call uvw_to_xyz ( dum , C_xyz ) call circle_grid_intersect ( C_xyz , e1_xyz , e2_xyz , particles % fast_ion ( i )% r , beam_grid_phi_enter , beam_grid_phi_exit ) delta_phi = beam_grid_phi_exit - beam_grid_phi_enter if ( delta_phi . gt . 0 ) then particles % fast_ion ( i )% beam_grid_cross_grid = . True . else particles % fast_ion ( i )% beam_grid_cross_grid = . False . delta_phi = 2 * pi endif particles % fast_ion ( i )% beam_grid_phi_enter = beam_grid_phi_enter else delta_phi = 2 * pi call uvw_to_xyz ( uvw , xyz ) particles % fast_ion ( i )% beam_grid_cross_grid = in_grid ( xyz ) particles % fast_ion ( i )% beam_grid_phi_enter = particles % fast_ion ( i )% phi endif particles % fast_ion ( i )% delta_phi = delta_phi particles % fast_ion ( i )% weight = weight ( i ) ir = minloc ( abs ( inter_grid % r - particles % fast_ion ( i )% r ), 1 ) iphi = minloc ( abs ( inter_grid % phi - particles % fast_ion ( i )% phi ), 1 ) iz = minloc ( abs ( inter_grid % z - particles % fast_ion ( i )% z ), 1 ) !$OMP ATOMIC UPDATE equil % plasma ( ir , iz , iphi )% denf = equil % plasma ( ir , iz , iphi )% denf + weight ( i ) / & ( particles % fast_ion ( i )% r * inter_grid % dv ) !$OMP END ATOMIC cnt = cnt + 1 enddo particle_loop !$OMP END PARALLEL DO num = count ( particles % fast_ion % beam_grid_cross_grid ) if ( num . le . 0 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_MC: No mc particles in beam grid' endif stop endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Distribution type: \",a)' ) dist_type_name write ( * , '(T2,\"Number of mc particles: \",i10)' ) particles % nparticle write ( * , '(T2,\"Number of orbit classes: \",i6)' ) particles % nclass write ( * , * ) '' endif end subroutine read_mc","tags":"","loc":"proc/read_mc.html","title":"read_mc – FIDASIM"},{"text":"public subroutine read_distribution() Reads in the fast-ion distribution Arguments None Calls proc~~read_distribution~~CallsGraph proc~read_distribution read_distribution proc~read_f read_f proc~read_distribution->proc~read_f proc~read_mc read_mc proc~read_distribution->proc~read_mc proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_distribution->proc~h5ltread_dataset_int_scalar_f h5open_f h5open_f proc~read_distribution->h5open_f h5close_f h5close_f proc~read_distribution->h5close_f h5fclose_f h5fclose_f proc~read_distribution->h5fclose_f h5fopen_f h5fopen_f proc~read_distribution->h5fopen_f proc~read_f->proc~h5ltread_dataset_int_scalar_f h5ltpath_valid_f h5ltpath_valid_f proc~read_f->h5ltpath_valid_f proc~read_mc->proc~h5ltread_dataset_int_scalar_f proc~circle_grid_intersect circle_grid_intersect proc~read_mc->proc~circle_grid_intersect h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_mc->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_mc->h5ltread_dataset_int_f proc~read_mc->h5ltpath_valid_f proc~in_plasma in_plasma proc~read_mc->proc~in_plasma proc~uvw_to_xyz uvw_to_xyz proc~read_mc->proc~uvw_to_xyz proc~in_grid in_grid proc~read_mc->proc~in_grid proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~circle_grid_intersect->proc~in_grid proc~approx_eq approx_eq proc~circle_grid_intersect->proc~approx_eq proc~grid_intersect grid_intersect proc~circle_grid_intersect->proc~grid_intersect interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~approx_le approx_le proc~in_grid->proc~approx_le proc~approx_ge approx_ge proc~in_grid->proc~approx_ge proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~approx_le->proc~approx_eq proc~approx_ge->proc~approx_eq proc~in_passive_grid in_passive_grid proc~grid_intersect->proc~in_passive_grid proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~in_passive_grid->proc~approx_le proc~in_passive_grid->proc~approx_ge proc~uvw_to_cyl uvw_to_cyl proc~in_passive_grid->proc~uvw_to_cyl proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocread_distributionCallsGraph = svgPanZoom('#procread_distributionCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_distribution~~CalledByGraph proc~read_distribution read_distribution program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_distribution Source Code subroutine read_distribution !+ Reads in the fast-ion distribution integer ( HID_T ) :: fid integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % distribution_file , H5F_ACC_RDONLY_F , fid , error ) !!Get distribution type call h5ltread_dataset_int_scalar_f ( fid , \"/type\" , inputs % dist_type , error ) if ( inputs % dist_type . eq . 1 ) then call read_f ( fid , error ) else !2 or 3 call read_mc ( fid , error ) endif !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) end subroutine read_distribution","tags":"","loc":"proc/read_distribution.html","title":"read_distribution – FIDASIM"},{"text":"public subroutine read_atomic_cross(fid, grp, cross) Reads in a cross section table from file\n and puts it into a AtomicCrossSection type Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid HDF5 file ID character(len=*), intent(in) :: grp HDF5 group to read from type( AtomicCrossSection ), intent(inout) :: cross Atomic cross section Calls proc~~read_atomic_cross~~CallsGraph proc~read_atomic_cross read_atomic_cross proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_atomic_cross->proc~h5ltread_dataset_int_scalar_f h5ltpath_valid_f h5ltpath_valid_f proc~read_atomic_cross->h5ltpath_valid_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_atomic_cross->h5ltread_dataset_double_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_atomic_cross->proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_atomic_cross~~CalledByGraph proc~read_atomic_cross read_atomic_cross proc~read_tables read_tables proc~read_tables->proc~read_atomic_cross program~fidasim fidasim program~fidasim->proc~read_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_atomic_cross Source Code subroutine read_atomic_cross ( fid , grp , cross ) !+ Reads in a cross section table from file !+ and puts it into a [[AtomicCrossSection]] type integer ( HID_T ), intent ( in ) :: fid !+ HDF5 file ID character ( len =* ), intent ( in ) :: grp !+ HDF5 group to read from type ( AtomicCrossSection ), intent ( inout ) :: cross !+ Atomic cross section integer ( HSIZE_T ), dimension ( 3 ) :: dim3 real ( Float64 ) :: emin , emax , rmin integer :: i , n_max , m_max , error real ( Float64 ), dimension (:,:,:), allocatable :: dummy3 logical :: path_valid call h5ltpath_valid_f ( fid , grp , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_ATOMIC_CROSS: Unknown atomic interaction: ' , trim ( grp ) endif stop endif call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , cross % nenergy , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/m_max\" , m_max , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , cross % dlogE , error ) cross % logemin = log10 ( emin ) cross % logemax = log10 ( emax ) allocate ( dummy3 ( n_max , m_max , cross % nenergy )) allocate ( cross % log_cross ( cross % m_max , cross % n_max , cross % nenergy )) dim3 = [ n_max , m_max , cross % nenergy ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy3 , dim3 , error ) rmin = minval ( dummy3 , dummy3 . gt . 0.d0 ) where ( dummy3 . le . 0.0 ) dummy3 = 0.9 * rmin end where cross % minlog_cross = log10 ( rmin ) do i = 1 , cross % nenergy cross % log_cross (:,:, i ) = log10 ( transpose ( dummy3 ( 1 : nlevs , 1 : nlevs , i ))) enddo deallocate ( dummy3 ) end subroutine read_atomic_cross","tags":"","loc":"proc/read_atomic_cross.html","title":"read_atomic_cross – FIDASIM"},{"text":"public subroutine read_atomic_rate(fid, grp, b_amu, t_amu, rates) Reads in a atomic rate table from file\n and puts it into a AtomicRates type Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid HDF5 file ID character(len=*), intent(in) :: grp HDF5 group to read from real(kind=Float64), intent(in), dimension(2) :: b_amu Atomic masses of \"beam\" species (beam ion and thermal ion) real(kind=Float64), intent(in) :: t_amu Atomic mass of \"target\" species (thermal ion) type( AtomicRates ), intent(inout) :: rates Atomic reaction rates Calls proc~~read_atomic_rate~~CallsGraph proc~read_atomic_rate read_atomic_rate h5ltpath_valid_f h5ltpath_valid_f proc~read_atomic_rate->h5ltpath_valid_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_atomic_rate->proc~h5ltread_dataset_int_scalar_f h5ltget_dataset_ndims_f h5ltget_dataset_ndims_f proc~read_atomic_rate->h5ltget_dataset_ndims_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_atomic_rate->h5ltread_dataset_double_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_atomic_rate->proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_atomic_rate~~CalledByGraph proc~read_atomic_rate read_atomic_rate proc~read_tables read_tables proc~read_tables->proc~read_atomic_rate program~fidasim fidasim program~fidasim->proc~read_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_atomic_rate Source Code subroutine read_atomic_rate ( fid , grp , b_amu , t_amu , rates ) !+ Reads in a atomic rate table from file !+ and puts it into a [[AtomicRates]] type integer ( HID_T ), intent ( in ) :: fid !+ HDF5 file ID character ( len =* ), intent ( in ) :: grp !+ HDF5 group to read from real ( Float64 ), dimension ( 2 ), intent ( in ) :: b_amu !+ Atomic masses of \"beam\" species (beam ion and thermal ion) real ( Float64 ), intent ( in ) :: t_amu !+ Atomic mass of \"target\" species (thermal ion) type ( AtomicRates ), intent ( inout ) :: rates !+ Atomic reaction rates integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 logical :: path_valid integer :: i , j , n , n_max , m_max , error integer :: n_bt_amu , tt_ind , bt_ind , drank real ( Float64 ) :: emin , emax , tmin , tmax , rmin real ( Float64 ) :: bt_min , tt_min , tt_dum , bt_dum real ( Float64 ), dimension ( 2 ) :: bt_amu , tt_amu real ( Float64 ), dimension (:,:), allocatable :: dummy2 real ( Float64 ), dimension (:,:,:,:), allocatable :: dummy4 real ( Float64 ), dimension (:,:,:,:,:), allocatable :: dummy5 call h5ltpath_valid_f ( fid , grp , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_ATOMIC_RATE: Unknown atomic interaction: ' , trim ( grp ) endif stop endif call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_bt_amu\" , n_bt_amu , error ) allocate ( dummy2 ( 2 , n_bt_amu )) dim2 = [ 2 , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/bt_amu\" , dummy2 , dim2 , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/m_max\" , m_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , rates % nenergy , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , rates % dlogE , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/ntemp\" , rates % ntemp , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmin\" , tmin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmax\" , tmax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogT\" , rates % dlogT , error ) rates % logemin = log10 ( emin ) rates % logemax = log10 ( emax ) rates % logtmin = log10 ( tmin ) rates % logtmax = log10 ( tmax ) bt_ind = 1 tt_ind = 1 bt_amu = [ b_amu ( 1 ), t_amu ] tt_amu = [ b_amu ( 2 ), t_amu ] bt_min = norm2 ( bt_amu - dummy2 (:, 1 )) tt_min = norm2 ( tt_amu - dummy2 (:, 1 )) do i = 2 , n_bt_amu bt_dum = norm2 ( bt_amu - dummy2 (:, i )) tt_dum = norm2 ( tt_amu - dummy2 (:, i )) if ( bt_dum . lt . bt_min ) then bt_min = bt_dum bt_ind = i endif if ( tt_dum . lt . tt_min ) then tt_min = tt_dum tt_ind = i endif enddo rates % ab ( 1 ) = dummy2 ( 1 , bt_ind ) rates % ab ( 2 ) = dummy2 ( 1 , tt_ind ) deallocate ( dummy2 ) allocate ( rates % log_rate (& rates % m_max , & rates % n_max , & rates % nenergy , & rates % ntemp , 2 )) rates % log_rate = 0.d0 !!Read CX call h5ltpath_valid_f ( fid , grp // \"/cx\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltget_dataset_ndims_f ( fid , grp // \"/cx\" , drank , error ) if ( drank . eq . 5 ) then allocate ( dummy5 ( n_max , m_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim5 = [ n_max , m_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy5 , dim5 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy rates % log_rate (:,:, i , j , 1 ) = transpose ( dummy5 ( 1 : nlevs , 1 : nlevs , i , j , bt_ind )) rates % log_rate (:,:, i , j , 2 ) = transpose ( dummy5 ( 1 : nlevs , 1 : nlevs , i , j , tt_ind )) enddo enddo deallocate ( dummy5 ) else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_ATOMIC_RATE: Unsupported atomic interaction: ' , trim ( grp ) endif stop endif endif rmin = minval ( rates % log_rate , rates % log_rate . gt . 0.d0 ) where ( rates % log_rate . le . 0.d0 ) rates % log_rate = 0.9 * rmin end where rates % minlog_rate = log10 ( rmin ) rates % log_rate = log10 ( rates % log_rate ) end subroutine read_atomic_rate","tags":"","loc":"proc/read_atomic_rate.html","title":"read_atomic_rate – FIDASIM"},{"text":"public subroutine read_atomic_transitions(fid, grp, b_amu, t_amu, rates) Reads in a atomic transitions table from file\n and puts it into a AtomicTransitions type Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid HDF5 file ID character(len=*), intent(in) :: grp HDF5 group to read from real(kind=Float64), intent(in), dimension(2) :: b_amu Atomic masses of \"beam\" species (beam ion and thermal ion) real(kind=Float64), intent(in) :: t_amu Atomic mass of \"target\" species (thermal ion) type( AtomicTransitions ), intent(inout) :: rates Atomic transitions Calls proc~~read_atomic_transitions~~CallsGraph proc~read_atomic_transitions read_atomic_transitions h5ltpath_valid_f h5ltpath_valid_f proc~read_atomic_transitions->h5ltpath_valid_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_atomic_transitions->proc~h5ltread_dataset_int_scalar_f h5ltget_dataset_ndims_f h5ltget_dataset_ndims_f proc~read_atomic_transitions->h5ltget_dataset_ndims_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_atomic_transitions->h5ltread_dataset_double_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_atomic_transitions->proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_atomic_transitions~~CalledByGraph proc~read_atomic_transitions read_atomic_transitions proc~read_tables read_tables proc~read_tables->proc~read_atomic_transitions program~fidasim fidasim program~fidasim->proc~read_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_atomic_transitions Source Code subroutine read_atomic_transitions ( fid , grp , b_amu , t_amu , rates ) !+ Reads in a atomic transitions table from file !+ and puts it into a [[AtomicTransitions]] type integer ( HID_T ), intent ( in ) :: fid !+ HDF5 file ID character ( len =* ), intent ( in ) :: grp !+ HDF5 group to read from real ( Float64 ), dimension ( 2 ), intent ( in ) :: b_amu !+ Atomic masses of \"beam\" species (beam ion and thermal ion) real ( Float64 ), intent ( in ) :: t_amu !+ Atomic mass of \"target\" species (thermal ion) type ( AtomicTransitions ), intent ( inout ) :: rates !+ Atomic transitions integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 logical :: path_valid integer :: i , j , n , n_max , m_max , error integer :: n_bt_amu , tt_ind , bt_ind , drank real ( Float64 ) :: emin , emax , tmin , tmax , rmin real ( Float64 ) :: bt_min , tt_min , tt_dum , bt_dum real ( Float64 ), dimension ( 2 ) :: bt_amu , tt_amu real ( Float64 ), dimension (:,:), allocatable :: dummy2 real ( Float64 ), dimension (:,:,:,:), allocatable :: dummy4 real ( Float64 ), dimension (:,:,:,:,:), allocatable :: dummy5 call h5ltpath_valid_f ( fid , grp , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_ATOMIC_TRANSITIONS: Unknown atomic interaction: ' , trim ( grp ) endif stop endif call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_bt_amu\" , n_bt_amu , error ) allocate ( dummy2 ( 2 , n_bt_amu )) dim2 = [ 2 , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/bt_amu\" , dummy2 , dim2 , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/m_max\" , m_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , rates % nenergy , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , rates % dlogE , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/ntemp\" , rates % ntemp , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmin\" , tmin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmax\" , tmax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogT\" , rates % dlogT , error ) rates % logemin = log10 ( emin ) rates % logemax = log10 ( emax ) rates % logtmin = log10 ( tmin ) rates % logtmax = log10 ( tmax ) bt_ind = 1 tt_ind = 1 bt_amu = [ b_amu ( 1 ), t_amu ] tt_amu = [ b_amu ( 2 ), t_amu ] bt_min = norm2 ( bt_amu - dummy2 (:, 1 )) tt_min = norm2 ( tt_amu - dummy2 (:, 1 )) do i = 2 , n_bt_amu bt_dum = norm2 ( bt_amu - dummy2 (:, i )) tt_dum = norm2 ( tt_amu - dummy2 (:, i )) if ( bt_dum . lt . bt_min ) then bt_min = bt_dum bt_ind = i endif if ( tt_dum . lt . tt_min ) then tt_min = tt_dum tt_ind = i endif enddo rates % ab ( 1 ) = dummy2 ( 1 , bt_ind ) rates % ab ( 2 ) = dummy2 ( 1 , tt_ind ) deallocate ( dummy2 ) allocate ( rates % log_pop (& rates % m_max , & rates % n_max , & rates % nenergy , & rates % ntemp , 2 )) allocate ( rates % log_depop (& rates % n_max , & rates % nenergy , & rates % ntemp , 2 )) rates % log_pop = 0.d0 rates % log_depop = 0.d0 !!Read CX call h5ltpath_valid_f ( fid , grp // \"/cx\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltget_dataset_ndims_f ( fid , grp // \"/cx\" , drank , error ) if ( drank . eq . 4 ) then allocate ( dummy4 ( n_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim4 = [ n_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy4 , dim4 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = dummy4 ( n , i , j , bt_ind ) rates % log_depop ( n , i , j , 2 ) = dummy4 ( n , i , j , tt_ind ) enddo enddo enddo deallocate ( dummy4 ) endif if ( drank . eq . 5 ) then allocate ( dummy5 ( n_max , m_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim5 = [ n_max , m_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy5 , dim5 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = sum ( dummy5 ( n ,:, i , j , bt_ind )) rates % log_depop ( n , i , j , 2 ) = sum ( dummy5 ( n ,:, i , j , tt_ind )) enddo enddo enddo deallocate ( dummy5 ) endif endif !!Read ionization call h5ltpath_valid_f ( fid , grp // \"/ionization\" , . True ., path_valid , error ) if ( path_valid ) then allocate ( dummy4 ( n_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim4 = [ n_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/ionization\" , dummy4 , dim4 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = rates % log_depop ( n , i , j , 1 ) + & dummy4 ( n , i , j , bt_ind ) rates % log_depop ( n , i , j , 2 ) = rates % log_depop ( n , i , j , 2 ) + & dummy4 ( n , i , j , tt_ind ) enddo enddo enddo deallocate ( dummy4 ) endif !!Read excitation call h5ltpath_valid_f ( fid , grp // \"/excitation\" , . True ., path_valid , error ) if ( path_valid ) then allocate ( dummy5 ( n_max , m_max ,& rates % nenergy , & rates % ntemp , n_bt_amu )) dim5 = [ n_max , m_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/excitation\" , dummy5 , dim5 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy rates % log_pop (:,:, i , j , 1 ) = transpose ( dummy5 ( 1 : nlevs , 1 : nlevs , i , j , bt_ind )) rates % log_pop (:,:, i , j , 2 ) = transpose ( dummy5 ( 1 : nlevs , 1 : nlevs , i , j , tt_ind )) do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = rates % log_depop ( n , i , j , 1 ) + & sum ( dummy5 ( n ,:, i , j , bt_ind )) rates % log_depop ( n , i , j , 2 ) = rates % log_depop ( n , i , j , 2 ) + & sum ( dummy5 ( n ,:, i , j , tt_ind )) enddo enddo enddo deallocate ( dummy5 ) endif rmin = minval ( rates % log_depop , rates % log_depop . gt . 0.d0 ) where ( rates % log_depop . le . 0.d0 ) rates % log_depop = 0.9 * rmin end where rates % minlog_depop = log10 ( rmin ) rates % log_depop = log10 ( rates % log_depop ) rmin = minval ( rates % log_pop , rates % log_pop . gt . 0.d0 ) where ( rates % log_pop . le . 0.d0 ) rates % log_pop = 0.9 * rmin end where rates % minlog_pop = log10 ( rmin ) rates % log_pop = log10 ( rates % log_pop ) end subroutine read_atomic_transitions","tags":"","loc":"proc/read_atomic_transitions.html","title":"read_atomic_transitions – FIDASIM"},{"text":"public subroutine read_nuclear_rates(fid, grp, rates) Reads in a nuclear reaction rates table from file\n and puts it into a NuclearRates type Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid HDF5 file ID character(len=*), intent(in) :: grp HDF5 group to read from type( NuclearRates ), intent(inout) :: rates Atomic reaction rates Calls proc~~read_nuclear_rates~~CallsGraph proc~read_nuclear_rates read_nuclear_rates proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_nuclear_rates->proc~h5ltread_dataset_int_scalar_f h5ltpath_valid_f h5ltpath_valid_f proc~read_nuclear_rates->h5ltpath_valid_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_nuclear_rates->h5ltread_dataset_double_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_nuclear_rates->proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_nuclear_rates~~CalledByGraph proc~read_nuclear_rates read_nuclear_rates proc~read_tables read_tables proc~read_tables->proc~read_nuclear_rates program~fidasim fidasim program~fidasim->proc~read_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_nuclear_rates Source Code subroutine read_nuclear_rates ( fid , grp , rates ) !+ Reads in a nuclear reaction rates table from file !+ and puts it into a [[NuclearRates]] type integer ( HID_T ), intent ( in ) :: fid !+ HDF5 file ID character ( len =* ), intent ( in ) :: grp !+ HDF5 group to read from type ( NuclearRates ), intent ( inout ) :: rates !+ Atomic reaction rates integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 logical :: path_valid , err integer :: i , j , error real ( Float64 ) :: emin , emax , tmin , tmax , rmin err = . False . call h5ltpath_valid_f ( fid , grp , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_NUCLEAR_RATES: Unknown nuclear interaction: ' , trim ( grp ) write ( * , '(a)' ) 'Continuing without neutron calculation' endif inputs % calc_neutron = 0 return endif dim1 = [ 2 ] call h5ltread_dataset_double_f ( fid , grp // \"/bt_amu\" , rates % bt_amu , dim1 , error ) if ( abs ( inputs % ab - rates % bt_amu ( 1 )). gt . 0.2 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,f6.3,a,f6.3,a)' ) 'READ_NUCLEAR_RATES: Unexpected beam species mass. Expected ' ,& rates % bt_amu ( 1 ), ' amu got ' , inputs % ab , ' amu' endif err = . True . endif if ( abs ( inputs % ai - rates % bt_amu ( 2 )). gt . 0.2 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,f6.3,a,f6.3,a)' ) 'READ_NUCLEAR_RATES: Unexpected thermal species mass. Expected ' ,& rates % bt_amu ( 2 ), ' amu got ' , inputs % ai , ' amu' endif err = . True . endif if ( err ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'Continuing without neutron calculation' endif inputs % calc_neutron = 0 return endif call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nbranch\" , rates % nbranch , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , rates % nenergy , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , rates % dlogE , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/ntemp\" , rates % ntemp , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmin\" , tmin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmax\" , tmax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogT\" , rates % dlogT , error ) rates % logemin = log10 ( emin ) rates % logemax = log10 ( emax ) rates % logtmin = log10 ( tmin ) rates % logtmax = log10 ( tmax ) allocate ( rates % log_rate ( rates % nenergy , & rates % ntemp , & rates % nbranch )) dim3 = [ rates % nenergy , rates % ntemp , rates % nbranch ] call h5ltread_dataset_double_f ( fid , grp // \"/fusion\" , rates % log_rate , dim3 , error ) rmin = minval ( rates % log_rate , rates % log_rate . gt . 0.d0 ) where ( rates % log_rate . le . 0.d0 ) rates % log_rate = 0.9 * rmin end where rates % minlog_rate = log10 ( rmin ) rates % log_rate = log10 ( rates % log_rate ) end subroutine read_nuclear_rates","tags":"","loc":"proc/read_nuclear_rates.html","title":"read_nuclear_rates – FIDASIM"},{"text":"public subroutine read_tables() Reads in atomic tables from file and stores them in tables Arguments None Calls proc~~read_tables~~CallsGraph proc~read_tables read_tables h5close_f h5close_f proc~read_tables->h5close_f proc~read_nuclear_rates read_nuclear_rates proc~read_tables->proc~read_nuclear_rates proc~read_atomic_rate read_atomic_rate proc~read_tables->proc~read_atomic_rate proc~read_atomic_transitions read_atomic_transitions proc~read_tables->proc~read_atomic_transitions h5open_f h5open_f proc~read_tables->h5open_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_tables->h5ltread_dataset_double_f proc~read_atomic_cross read_atomic_cross proc~read_tables->proc~read_atomic_cross proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_tables->proc~h5ltread_dataset_int_scalar_f h5fclose_f h5fclose_f proc~read_tables->h5fclose_f h5fopen_f h5fopen_f proc~read_tables->h5fopen_f proc~read_nuclear_rates->h5ltread_dataset_double_f proc~read_nuclear_rates->proc~h5ltread_dataset_int_scalar_f h5ltpath_valid_f h5ltpath_valid_f proc~read_nuclear_rates->h5ltpath_valid_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_nuclear_rates->proc~h5ltread_dataset_double_scalar_f proc~read_atomic_rate->h5ltread_dataset_double_f proc~read_atomic_rate->proc~h5ltread_dataset_int_scalar_f h5ltget_dataset_ndims_f h5ltget_dataset_ndims_f proc~read_atomic_rate->h5ltget_dataset_ndims_f proc~read_atomic_rate->h5ltpath_valid_f proc~read_atomic_rate->proc~h5ltread_dataset_double_scalar_f proc~read_atomic_transitions->h5ltread_dataset_double_f proc~read_atomic_transitions->proc~h5ltread_dataset_int_scalar_f proc~read_atomic_transitions->h5ltget_dataset_ndims_f proc~read_atomic_transitions->h5ltpath_valid_f proc~read_atomic_transitions->proc~h5ltread_dataset_double_scalar_f proc~read_atomic_cross->h5ltread_dataset_double_f proc~read_atomic_cross->proc~h5ltread_dataset_int_scalar_f proc~read_atomic_cross->h5ltpath_valid_f proc~read_atomic_cross->proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_tables~~CalledByGraph proc~read_tables read_tables program~fidasim fidasim program~fidasim->proc~read_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_tables Source Code subroutine read_tables !+ Reads in atomic tables from file and stores them in [[libfida:tables]] integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: error integer :: n_max , m_max character ( len = 4 ) :: impname real ( Float64 ) :: imp_amu real ( Float64 ), dimension ( 2 ) :: b_amu real ( Float64 ), dimension (:,:), allocatable :: dummy2 if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Atomic tables settings ----\" endif !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % tables_file , H5F_ACC_RDONLY_F , fid , error ) !!Read Hydrogen-Hydrogen CX Cross Sections call read_atomic_cross ( fid , \"/cross/H_H\" , tables % H_H_cx_cross ) !!Read Hydrogen-Hydrogen CX Rates b_amu = [ inputs % ab , inputs % ai ] call read_atomic_rate ( fid , \"/rates/H_H\" , b_amu , inputs % ai , tables % H_H_cx_rate ) !!Read Hydrogen-Hydrogen Transitions call read_atomic_transitions ( fid , \"/rates/H_H\" , b_amu , inputs % ai , tables % H_H ) inputs % ab = tables % H_H % ab ( 1 ) inputs % ai = tables % H_H % ab ( 2 ) !!Read Hydrogen-Electron Transitions call read_atomic_transitions ( fid , \"/rates/H_e\" , b_amu , e_amu , tables % H_e ) !!Read Hydrogen-Impurity Transitions impname = '' select case ( inputs % impurity_charge ) case ( 5 ) impname = \"B5\" imp_amu = B5_amu case ( 6 ) impname = \"C6\" imp_amu = C6_amu case DEFAULT impname = \"Aq\" imp_amu = 2.d0 * inputs % impurity_charge end select call read_atomic_transitions ( fid , \"/rates/H_\" // trim ( adjustl ( impname )), b_amu , imp_amu , tables % H_Aq ) !!Read Einstein coefficients call h5ltread_dataset_int_scalar_f ( fid , \"/rates/spontaneous/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/rates/spontaneous/m_max\" , m_max , error ) allocate ( dummy2 ( n_max , m_max )) dim2 = [ n_max , m_max ] call h5ltread_dataset_double_f ( fid , \"/rates/spontaneous/einstein\" , dummy2 , dim2 , error ) tables % einstein (:,:) = transpose ( dummy2 ( 1 : nlevs , 1 : nlevs )) deallocate ( dummy2 ) !!Read nuclear Deuterium-Deuterium rates if ( inputs % calc_neutron . ge . 1 ) then call read_nuclear_rates ( fid , \"/rates/D_D\" , tables % D_D ) endif !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Maximum n/m: \",i2)' ) nlevs write ( * , '(T2,\"Beam/Fast-ion mass: \",f6.3,\" [amu]\")' ) inputs % ab write ( * , '(T2,\"Thermal/Bulk-ion mass: \",f6.3,\" [amu]\")' ) inputs % ai write ( * , '(T2,\"Impurity mass: \",f6.3,\" [amu]\")' ) imp_amu write ( * , * ) '' endif end subroutine read_tables","tags":"","loc":"proc/read_tables.html","title":"read_tables – FIDASIM"},{"text":"public subroutine write_beam_grid(id, error) Write beam_grid to an HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file ID integer, intent(out) :: error Error code Calls proc~~write_beam_grid~~CallsGraph proc~write_beam_grid write_beam_grid h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_beam_grid->h5ltset_attribute_string_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f proc~xyz_to_uvw xyz_to_uvw proc~write_beam_grid->proc~xyz_to_uvw proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f var panprocwrite_beam_gridCallsGraph = svgPanZoom('#procwrite_beam_gridCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_beam_grid~~CalledByGraph proc~write_beam_grid write_beam_grid proc~write_neutrals write_neutrals proc~write_neutrals->proc~write_beam_grid proc~write_birth_profile write_birth_profile proc~write_birth_profile->proc~write_beam_grid proc~write_npa_weights write_npa_weights proc~write_npa_weights->proc~write_beam_grid proc~npa_weights npa_weights proc~npa_weights->proc~write_npa_weights program~fidasim fidasim program~fidasim->proc~write_neutrals program~fidasim->proc~write_birth_profile program~fidasim->proc~npa_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_beam_grid Source Code subroutine write_beam_grid ( id , error ) !+ Write [[libfida:beam_grid]] to an HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file ID integer , intent ( out ) :: error !+ Error code integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 3 ) :: dims real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: u_grid , v_grid , w_grid real ( Float64 ) :: xyz ( 3 ), uvw ( 3 ) integer :: i , j , k !Create uvw grids do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx xyz = [ beam_grid % xc ( i ), & beam_grid % yc ( j ), & beam_grid % zc ( k )] call xyz_to_uvw ( xyz , uvw ) u_grid ( i , j , k ) = uvw ( 1 ) v_grid ( i , j , k ) = uvw ( 2 ) w_grid ( i , j , k ) = uvw ( 3 ) enddo enddo enddo !Create grid group call h5gcreate_f ( id , \"grid\" , gid , error ) !Write variables dims ( 1 ) = 1 call h5ltmake_dataset_int_f ( gid , \"nx\" , 0 , dims ( 1 : 1 ), [ beam_grid % nx ], error ) call h5ltmake_dataset_int_f ( gid , \"ny\" , 0 , dims ( 1 : 1 ), [ beam_grid % ny ], error ) call h5ltmake_dataset_int_f ( gid , \"nz\" , 0 , dims ( 1 : 1 ), [ beam_grid % nz ], error ) dims = [ beam_grid % nx , beam_grid % ny , beam_grid % nz ] call h5ltmake_compressed_dataset_double_f ( gid , \"x\" , 1 , dims ( 1 : 1 ), beam_grid % xc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"y\" , 1 , dims ( 2 : 2 ), beam_grid % yc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"z\" , 1 , dims ( 3 : 3 ), beam_grid % zc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"x_grid\" , 3 , dims , u_grid , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"y_grid\" , 3 , dims , v_grid , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"z_grid\" , 3 , dims , w_grid , error ) !Write attributes call h5ltset_attribute_string_f ( gid , \"nx\" , \"description\" , & \"Number of cells in the X direction\" , error ) call h5ltset_attribute_string_f ( gid , \"ny\" , \"description\" , & \"Number of cells in the Y direction\" , error ) call h5ltset_attribute_string_f ( gid , \"nz\" , \"description\" , & \"Number of cells in the Z direction\" , error ) call h5ltset_attribute_string_f ( gid , \"x\" , \"description\" , & \"X value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"x\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"y\" , \"description\" , & \"Y value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"y\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"z\" , \"description\" , & \"Z value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"z\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"x_grid\" , \"description\" , & \"X value of cell center in machine coordinates: x_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"x_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"y_grid\" , \"description\" , & \"Y value of cell center in machine coordinates: y_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"y_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"z_grid\" , \"description\" , & \"Z value of cell center in machine coordinates: z_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"z_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( id , \"grid\" , \"coordinate_system\" , & \"Right-handed cartesian\" , error ) !Close grid group call h5gclose_f ( gid , error ) end subroutine write_beam_grid","tags":"","loc":"proc/write_beam_grid.html","title":"write_beam_grid – FIDASIM"},{"text":"public subroutine write_birth_profile() Writes birth to a HDF5 file Arguments None Calls proc~~write_birth_profile~~CallsGraph proc~write_birth_profile write_birth_profile h5fcreate_f h5fcreate_f proc~write_birth_profile->h5fcreate_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~num_ranks num_ranks proc~write_birth_profile->proc~num_ranks h5open_f h5open_f proc~write_birth_profile->h5open_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_birth_profile->h5ltset_attribute_string_f interface~parallel_sum parallel_sum proc~write_birth_profile->interface~parallel_sum h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_birth_profile->h5ltmake_dataset_int_f h5close_f h5close_f proc~write_birth_profile->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~my_rank my_rank proc~write_birth_profile->proc~my_rank h5fclose_f h5fclose_f proc~write_birth_profile->h5fclose_f proc~xyz_to_uvw xyz_to_uvw proc~write_birth_profile->proc~xyz_to_uvw proc~write_beam_grid->h5ltset_attribute_string_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->proc~xyz_to_uvw h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f mpi_allreduce mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~h5ltmake_compressed_dataset_int_f_2->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dcreate_f proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f var panprocwrite_birth_profileCallsGraph = svgPanZoom('#procwrite_birth_profileCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_birth_profile~~CalledByGraph proc~write_birth_profile write_birth_profile program~fidasim fidasim program~fidasim->proc~write_birth_profile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_birth_profile Source Code subroutine write_birth_profile !+ Writes [[libfida:birth]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error , i , c , npart , start_index , end_index character ( charlim ) :: filename type ( LocalEMFields ) :: fields type ( BirthParticle ) :: part real ( Float64 ), dimension (:,:), allocatable :: ri , ri_gc real ( Float64 ), dimension (:,:), allocatable :: vi real ( Float64 ), dimension (:), allocatable :: energy , pitch , weight integer , dimension (:,:), allocatable :: inds integer , dimension (:), allocatable :: neut_types real ( Float64 ), dimension ( 3 ) :: xyz , v_xyz , uvw , v_uvw , r_gyro , uvw_gc logical :: do_write #ifdef _MPI integer :: rank integer , dimension (:), allocatable :: npart_image #endif npart = birth % cnt - 1 #ifdef _MPI call parallel_sum ( npart ) #endif allocate ( ri ( 3 , npart )) allocate ( vi ( 3 , npart )) allocate ( ri_gc ( 3 , npart )) allocate ( energy ( npart ), pitch ( npart ), weight ( npart )) allocate ( inds ( 3 , npart )) allocate ( neut_types ( npart )) ri = 0.d0 vi = 0.d0 ri_gc = 0.d0 energy = 0.d0 pitch = 0.d0 weight = 0.d0 inds = 0 neut_types = 0 c = 0 #ifdef _MPI rank = my_rank () allocate ( npart_image ( 0 : num_ranks () - 1 )) npart_image (:) = 0 npart_image ( rank ) = birth % cnt - 1 call parallel_sum ( npart_image ) do i = 0 , rank - 1 c = c + npart_image ( i ) enddo deallocate ( npart_image ) #endif start_index = 1 + c end_index = birth % cnt - 1 + c c = 1 do i = start_index , end_index part = birth % part ( c ) ! Convert position to rzphi xyz = part % ri v_xyz = part % vi inds (:, i ) = part % ind neut_types ( i ) = part % neut_type energy ( i ) = part % energy weight ( i ) = part % weight ! Get guiding center positions pitch ( i ) = part % pitch call xyz_to_uvw ( part % ri_gc , uvw_gc ) ri_gc ( 1 , i ) = sqrt ( uvw_gc ( 1 ) * uvw_gc ( 1 ) + uvw_gc ( 2 ) * uvw_gc ( 2 )) ri_gc ( 2 , i ) = uvw_gc ( 3 ) ri_gc ( 3 , i ) = atan2 ( uvw_gc ( 2 ), uvw_gc ( 1 )) ! Get position in cylindrical call xyz_to_uvw ( xyz , uvw ) ri ( 1 , i ) = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) ri ( 2 , i ) = uvw ( 3 ) ri ( 3 , i ) = atan2 ( uvw ( 2 ), uvw ( 1 )) ! Convert velocity to cylindrical v_uvw = matmul ( beam_grid % basis , v_xyz ) vi ( 1 , i ) = v_uvw ( 1 ) * cos ( ri ( 3 , i )) + v_uvw ( 2 ) * sin ( ri ( 3 , i )) vi ( 2 , i ) = v_uvw ( 3 ) vi ( 3 , i ) = - v_uvw ( 1 ) * sin ( ri ( 3 , i )) + v_uvw ( 2 ) * cos ( ri ( 3 , i )) c = c + 1 enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_birth.h5\" do_write = . True . #ifdef _MPI call parallel_sum ( ri_gc ) call parallel_sum ( energy ) call parallel_sum ( pitch ) call parallel_sum ( weight ) call parallel_sum ( ri ) call parallel_sum ( vi ) call parallel_sum ( inds ) call parallel_sum ( neut_types ) if ( my_rank (). ne . 0 ) do_write = . False . #endif if ( do_write ) then !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables call write_beam_grid ( fid , error ) d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/n_birth\" , 0 , d , [ npart ], error ) dim4 = shape ( birth % dens ) call h5ltmake_compressed_dataset_double_f ( fid , \"/dens\" , 4 , dim4 , birth % dens , error ) dim2 = [ 3 , npart ] call h5ltmake_compressed_dataset_double_f ( fid , \"/ri_gc\" , 2 , dim2 , ri_gc , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/ri\" , 2 , dim2 , ri , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vi\" , 2 , dim2 , vi , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/ind\" , 2 , dim2 , inds , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim2 ( 2 : 2 ), energy , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , dim2 ( 2 : 2 ), pitch , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 1 , dim2 ( 2 : 2 ), weight , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/type\" , 1 , dim2 ( 2 : 2 ), neut_types , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/n_birth\" , \"description\" , & \"Number of birth mc particles deposited\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"description\" , & \"Birth density: dens(beam_component,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"units\" , & \"fast-ions/(s*cm&#94;3)\" , error ) call h5ltset_attribute_string_f ( fid , \"/ri_gc\" , \"description\" , & \"Fast-ion guiding-center birth position in R-Z-Phi: ri_gc([r,z,phi],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/ri_gc\" , \"units\" , \"cm, radians\" , error ) call h5ltset_attribute_string_f ( fid , \"/ri\" , \"description\" , & \"Fast-ion birth position in R-Z-Phi: ri([r,z,phi],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/ri\" , \"units\" , \"cm, radians\" , error ) call h5ltset_attribute_string_f ( fid , \"/vi\" , \"description\" , & \"Fast-ion birth velocity in R-Z-Phi: vi([r,z,phi],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/vi\" , \"units\" , \"cm/s\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Fast-ion birth energy: energy(particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"Fast-ion birth weight: weight(particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , \"fast-ions/s\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Fast-ion birth pitch w.r.t. the magnetic field: pitch(particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/ind\" , \"description\" , & \"Fast-ion birth beam grid indices: ind([i,j,k],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/type\" , \"description\" , & \"Fast-ion birth type (1=Full, 2=Half, 3=Third)\" , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"coordinate_system\" , & \"Cylindrical (R,Z,Phi)\" , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Birth density and particles calculated by FIDASIM\" , error ) !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) endif ! Deallocate arrays since they aren't needed anymore deallocate ( ri , vi , ri_gc , energy , pitch , neut_types , inds ) deallocate ( birth % dens , birth % part ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'birth profile written to: ' , trim ( filename ) endif end subroutine write_birth_profile","tags":"","loc":"proc/write_birth_profile.html","title":"write_birth_profile – FIDASIM"},{"text":"public subroutine write_neutrals() Writes neut to a HDF5 file Arguments None Calls proc~~write_neutrals~~CallsGraph proc~write_neutrals write_neutrals h5fcreate_f h5fcreate_f proc~write_neutrals->h5fcreate_f proc~write_beam_grid write_beam_grid proc~write_neutrals->proc~write_beam_grid h5open_f h5open_f proc~write_neutrals->h5open_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_neutrals->h5ltset_attribute_string_f h5close_f h5close_f proc~write_neutrals->h5close_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_neutrals->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_neutrals->h5fclose_f proc~write_beam_grid->h5ltset_attribute_string_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f proc~xyz_to_uvw xyz_to_uvw proc~write_beam_grid->proc~xyz_to_uvw proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f var panprocwrite_neutralsCallsGraph = svgPanZoom('#procwrite_neutralsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_neutrals~~CalledByGraph proc~write_neutrals write_neutrals program~fidasim fidasim program~fidasim->proc~write_neutrals Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_neutrals Source Code subroutine write_neutrals !+ Writes [[libfida:neut]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dims integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error character ( charlim ) :: filename filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_neutrals.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables call write_beam_grid ( fid , error ) dims = [ nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz ] d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nlevel\" , 0 , d , [ nlevs ], error ) call h5ltset_attribute_string_f ( fid , \"/nlevel\" , \"description\" , & \"Number of atomic energy levels\" , error ) if ( inputs % calc_nbi_dens . ge . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/fdens\" , 4 , dims , & neut % full , error ) call h5ltset_attribute_string_f ( fid , \"/fdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/hdens\" , 4 , dims , & neut % half , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/tdens\" , 4 , dims , & neut % third , error ) call h5ltset_attribute_string_f ( fid , \"/fdens\" , \"description\" , & \"Neutral density for the full energy component of the beam: fdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/hdens\" , \"description\" , & \"Neutral density for the half energy component of the beam: hdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/hdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/tdens\" , \"description\" , & \"Neutral density for the third energy component of the beam: tdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/tdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) endif if ( inputs % calc_dcx_dens . ge . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/dcxdens\" , 4 , dims , & neut % dcx , error ) call h5ltset_attribute_string_f ( fid , \"/dcxdens\" , \"description\" , & \"Direct Charge Exchange (DCX) neutral density: dcxdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/dcxdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) endif if ( inputs % calc_halo_dens . ge . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/halodens\" , 4 , dims , & neut % halo , error ) call h5ltset_attribute_string_f ( fid , \"/halodens\" , \"description\" , & \"Neutral density of the beam halo: halodens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/halodens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Beam neutral density calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'neutral density written to: ' , trim ( filename ) endif end subroutine write_neutrals","tags":"","loc":"proc/write_neutrals.html","title":"write_neutrals – FIDASIM"},{"text":"public subroutine write_npa() Writes npa to a HDF5 file Arguments None Calls proc~~write_npa~~CallsGraph proc~write_npa write_npa interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_npa->interface~h5ltmake_compressed_dataset_double_f h5fcreate_f h5fcreate_f proc~write_npa->h5fcreate_f interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f proc~write_npa->interface~h5ltmake_compressed_dataset_int_f h5gclose_f h5gclose_f proc~write_npa->h5gclose_f proc~num_ranks num_ranks proc~write_npa->proc~num_ranks h5open_f h5open_f proc~write_npa->h5open_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_npa->h5ltset_attribute_string_f interface~parallel_sum parallel_sum proc~write_npa->interface~parallel_sum h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_npa->h5ltmake_dataset_int_f h5close_f h5close_f proc~write_npa->h5close_f h5gcreate_f h5gcreate_f proc~write_npa->h5gcreate_f proc~my_rank my_rank proc~write_npa->proc~my_rank h5fclose_f h5fclose_f proc~write_npa->h5fclose_f proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f mpi_allreduce mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~h5ltmake_compressed_dataset_int_f_2->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dcreate_f proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dcreate_f var panprocwrite_npaCallsGraph = svgPanZoom('#procwrite_npaCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_npa~~CalledByGraph proc~write_npa write_npa program~fidasim fidasim program~fidasim->proc~write_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_npa Source Code subroutine write_npa !+ Writes [[libfida:npa]] to a HDF5 file integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error integer , dimension (:), allocatable :: dcount real ( Float64 ), dimension (:,:), allocatable :: ri , rf real ( Float64 ), dimension (:), allocatable :: weight , energy , pitch integer , dimension (:), allocatable :: det , orbit_type integer :: i , npart , c , start_index , end_index character ( charlim ) :: filename = '' logical :: do_write = . True . #ifdef _MPI integer :: rank integer , dimension (:), allocatable :: npart_image rank = my_rank () allocate ( npart_image ( 0 : num_ranks () - 1 )) #endif #ifdef _MPI if ( my_rank (). ne . 0 ) do_write = . False . #endif filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_npa.h5\" if ( do_write ) then !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) endif !! Active allocate ( dcount ( npa_chords % nchan )) npart = npa % npart if ( npart . gt . 0 ) then do i = 1 , npa_chords % nchan dcount ( i ) = count ( npa % part % detector . eq . i ) enddo else dcount = 0 endif #ifdef _MPI call parallel_sum ( dcount ) call parallel_sum ( npart ) #endif c = 0 #ifdef _MPI npart_image (:) = 0 npart_image ( rank ) = npa % npart call parallel_sum ( npart_image ) do i = 0 , rank - 1 c = c + npart_image ( i ) enddo #endif start_index = 1 + c end_index = npa % npart + c if ( npart . gt . 0 ) then allocate ( ri ( 3 , npart ), rf ( 3 , npart )) allocate ( weight ( npart ), energy ( npart ), pitch ( npart )) allocate ( det ( npart ), orbit_type ( npart )) ri = 0.d0 ; rf = 0.d0 weight = 0.d0 ; energy = 0.d0 pitch = 0.d0 ; det = 0 orbit_type = 0 c = 1 do i = start_index , end_index ri ( 1 , i ) = npa % part ( c )% xi ri ( 2 , i ) = npa % part ( c )% yi ri ( 3 , i ) = npa % part ( c )% zi rf ( 1 , i ) = npa % part ( c )% xf rf ( 2 , i ) = npa % part ( c )% yf rf ( 3 , i ) = npa % part ( c )% zf weight ( i ) = npa % part ( c )% weight energy ( i ) = npa % part ( c )% energy pitch ( i ) = npa % part ( c )% pitch det ( i ) = npa % part ( c )% detector orbit_type ( i ) = npa % part ( c )% class c = c + 1 enddo #ifdef _MPI call parallel_sum ( ri ) call parallel_sum ( rf ) call parallel_sum ( weight ) call parallel_sum ( energy ) call parallel_sum ( pitch ) call parallel_sum ( det ) call parallel_sum ( orbit_type ) #endif endif if ( do_write . and .( inputs % calc_npa . ge . 1 )) then !Write Active Flux d ( 1 ) = 1 dim2 = [ npa % nenergy , npa % nchan ] dim3 = [ npa % nenergy , npa % nchan , particles % nclass ] if ( particles % nclass . gt . 1 ) then call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , d , [ particles % nclass ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/flux\" , 3 , dim3 , npa % flux , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"description\" , & \"Active Neutral flux: flux(energy,chan,class)\" , error ) else call h5ltmake_compressed_dataset_double_f ( fid , \"/flux\" , 2 , dim3 ( 1 : 2 ), npa % flux (:,:, 1 ), error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"description\" , & \"Active Neutral flux: flux(energy,chan)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/flux\" , \"units\" , \"neutrals/(s*dE)\" , error ) call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , d , [ npa % nenergy ], error ) call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ npa % nchan ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim2 ( 1 : 1 ),& npa % energy , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dim2 ( 2 : 2 ),& npa_chords % radius , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/count\" , 1 , dim2 ( 2 : 2 ), dcount , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"NPA flux calculated by FIDASIM\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" ,& \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" ,& \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Detector line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/count\" , \"description\" , & \"Number of particles that hit the detector: count(chan)\" , error ) if (( npart . gt . 0 ). and .( inputs % calc_npa . ge . 2 )) then !Create Group call h5gcreate_f ( fid , \"/particles\" , gid , error ) call h5ltmake_dataset_int_f ( gid , \"nparticle\" , 0 , d , [ npart ], error ) d ( 1 ) = npart dim2 = [ 3 , npart ] call h5ltmake_compressed_dataset_double_f ( gid , \"ri\" , 2 , dim2 , ri , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"rf\" , 2 , dim2 , rf , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"pitch\" , 1 , d , pitch , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , d , energy , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"weight\" , 1 , d , weight , error ) call h5ltmake_compressed_dataset_int_f ( gid , \"detector\" , 1 , d , det , error ) call h5ltmake_compressed_dataset_int_f ( gid , \"class\" , 1 , d , orbit_type , error ) !Add attributes call h5ltset_attribute_string_f ( gid , \"nparticle\" , \"description\" , & \"Number of particles that hit a detector\" , error ) call h5ltset_attribute_string_f ( gid , \"ri\" , \"description\" , & \"Neutral particle's birth position in machine coordinates: ri([x,y,z],particle)\" , error ) call h5ltset_attribute_string_f ( gid , \"ri\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"rf\" , \"description\" , & \"Neutral particle's hit position in machine coordinates: rf([x,y,z],particle)\" , error ) call h5ltset_attribute_string_f ( gid , \"rf\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"pitch\" , \"description\" , & \"Pitch value of the neutral particle: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy value of the neutral particle\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"weight\" , \"description\" , & \"Neutral particle's contribution to the flux\" , error ) call h5ltset_attribute_string_f ( gid , \"weight\" , \"units\" , \"neutrals/s\" , error ) call h5ltset_attribute_string_f ( gid , \"detector\" , \"description\" , & \"Detector that the neutral particle hit\" , error ) call h5ltset_attribute_string_f ( gid , \"class\" , \"description\" , & \"Class of the neutral particle\" , error ) call h5ltset_attribute_string_f ( fid , \"/particles\" , \"coordinate_system\" , & \"Right-handed cartesian\" , error ) call h5ltset_attribute_string_f ( fid , \"/particles\" , \"description\" , & \"Active NPA Monte Carlo particles\" , error ) !Close group call h5gclose_f ( gid , error ) endif endif deallocate ( dcount ) if ( npart . gt . 0 ) then deallocate ( ri , rf ) deallocate ( energy , pitch , weight , det , orbit_type ) endif !! Passive allocate ( dcount ( npa_chords % nchan )) npart = pnpa % npart if ( npart . gt . 0 ) then do i = 1 , npa_chords % nchan dcount ( i ) = count ( pnpa % part % detector . eq . i ) enddo else dcount = 0 endif #ifdef _MPI call parallel_sum ( dcount ) call parallel_sum ( npart ) #endif c = 0 #ifdef _MPI npart_image (:) = 0 npart_image ( rank ) = pnpa % npart call parallel_sum ( npart_image ) do i = 0 , rank - 1 c = c + npart_image ( i ) enddo #endif start_index = 1 + c end_index = pnpa % npart + c if ( npart . gt . 0 ) then allocate ( ri ( 3 , npart ), rf ( 3 , npart )) allocate ( weight ( npart ), energy ( npart ), pitch ( npart )) allocate ( det ( npart ), orbit_type ( npart )) ri = 0.d0 ; rf = 0.d0 weight = 0.d0 ; energy = 0.d0 pitch = 0.d0 ; det = 0 orbit_type = 0 c = 1 do i = start_index , end_index ri ( 1 , i ) = pnpa % part ( c )% xi ri ( 2 , i ) = pnpa % part ( c )% yi ri ( 3 , i ) = pnpa % part ( c )% zi rf ( 1 , i ) = pnpa % part ( c )% xf rf ( 2 , i ) = pnpa % part ( c )% yf rf ( 3 , i ) = pnpa % part ( c )% zf weight ( i ) = pnpa % part ( c )% weight energy ( i ) = pnpa % part ( c )% energy pitch ( i ) = pnpa % part ( c )% pitch det ( i ) = pnpa % part ( c )% detector orbit_type ( i ) = pnpa % part ( c )% class c = c + 1 enddo #ifdef _MPI call parallel_sum ( ri ) call parallel_sum ( rf ) call parallel_sum ( weight ) call parallel_sum ( energy ) call parallel_sum ( pitch ) call parallel_sum ( det ) call parallel_sum ( orbit_type ) #endif endif if ( do_write . and .( inputs % calc_pnpa . ge . 1 )) then !Write Passive Flux d ( 1 ) = 1 dim2 = [ pnpa % nenergy , pnpa % nchan ] dim3 = [ pnpa % nenergy , pnpa % nchan , particles % nclass ] if ( particles % nclass . gt . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/pflux\" , 3 , dim3 , pnpa % flux , error ) call h5ltset_attribute_string_f ( fid , \"/pflux\" , \"description\" , & \"Passive Neutral flux: pflux(energy,chan,class)\" , error ) else call h5ltmake_compressed_dataset_double_f ( fid , \"/pflux\" , 2 , dim3 ( 1 : 2 ), pnpa % flux (:,:, 1 ), error ) call h5ltset_attribute_string_f ( fid , \"/pflux\" , \"description\" , & \"Passive Neutral flux: pflux(energy,chan)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/pflux\" , \"units\" , \"neutrals/(s*dE)\" , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/pcount\" , 1 , dim2 ( 2 : 2 ), dcount , error ) call h5ltset_attribute_string_f ( fid , \"/pcount\" , \"description\" , & \"Number of passive particles that hit the detector: pcount(chan)\" , error ) if ( inputs % calc_npa . le . 0 ) then call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , d , [ pnpa % nenergy ], error ) call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ pnpa % nchan ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim2 ( 1 : 1 ),& pnpa % energy , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dim2 ( 2 : 2 ),& npa_chords % radius , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"NPA flux calculated by FIDASIM\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" ,& \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" ,& \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Detector line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) endif if (( npart . gt . 0 ). and .( inputs % calc_pnpa . ge . 2 )) then !Create Group call h5gcreate_f ( fid , \"/passive_particles\" , gid , error ) call h5ltmake_dataset_int_f ( gid , \"nparticle\" , 0 , d , [ npart ], error ) d ( 1 ) = npart dim2 = [ 3 , npart ] call h5ltmake_compressed_dataset_double_f ( gid , \"ri\" , 2 , dim2 , ri , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"rf\" , 2 , dim2 , rf , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"pitch\" , 1 , d , pitch , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , d , energy , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"weight\" , 1 , d , weight , error ) call h5ltmake_compressed_dataset_int_f ( gid , \"detector\" , 1 , d , det , error ) call h5ltmake_compressed_dataset_int_f ( gid , \"class\" , 1 , d , orbit_type , error ) !Add attributes call h5ltset_attribute_string_f ( gid , \"nparticle\" , \"description\" , & \"Number of particles that hit a detector\" , error ) call h5ltset_attribute_string_f ( gid , \"ri\" , \"description\" , & \"Neutral particle's birth position in machine coordinates: ri([x,y,z],particle)\" , error ) call h5ltset_attribute_string_f ( gid , \"ri\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"rf\" , \"description\" , & \"Neutral particle's hit position in machine coordinates: rf([x,y,z],particle)\" , error ) call h5ltset_attribute_string_f ( gid , \"rf\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"pitch\" , \"description\" , & \"Pitch value of the neutral particle: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy value of the neutral particle\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"weight\" , \"description\" , & \"Neutral particle's contribution to the flux\" , error ) call h5ltset_attribute_string_f ( gid , \"weight\" , \"units\" , \"neutrals/s\" , error ) call h5ltset_attribute_string_f ( gid , \"detector\" , \"description\" , & \"Detector that the neutral particle hit\" , error ) call h5ltset_attribute_string_f ( gid , \"class\" , \"description\" , & \"Class of the neutral particle\" , error ) call h5ltset_attribute_string_f ( fid , \"/passive_particles\" , \"coordinate_system\" , & \"Right-handed cartesian\" , error ) call h5ltset_attribute_string_f ( fid , \"/passive_particles\" , \"description\" , & \"Passive NPA Monte Carlo particles\" , error ) !Close group call h5gclose_f ( gid , error ) endif endif if ( do_write ) then !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'NPA data written to: ' , trim ( filename ) endif #ifdef _MPI deallocate ( npart_image ) #endif end subroutine write_npa","tags":"","loc":"proc/write_npa.html","title":"write_npa – FIDASIM"},{"text":"public subroutine write_spectra() Writes Spectra to a HDF5 file Arguments None Calls proc~~write_spectra~~CallsGraph proc~write_spectra write_spectra h5fcreate_f h5fcreate_f proc~write_spectra->h5fcreate_f h5open_f h5open_f proc~write_spectra->h5open_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_spectra->h5ltset_attribute_string_f h5close_f h5close_f proc~write_spectra->h5close_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_spectra->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_spectra->h5fclose_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f var panprocwrite_spectraCallsGraph = svgPanZoom('#procwrite_spectraCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_spectra~~CalledByGraph proc~write_spectra write_spectra program~fidasim fidasim program~fidasim->proc~write_spectra Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_spectra Source Code subroutine write_spectra !+ Writes [[libfida:spectra]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 3 ) :: dims integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error character ( charlim ) :: filename integer :: i real ( Float64 ) :: factor real ( Float64 ), dimension (:), allocatable :: lambda_arr allocate ( lambda_arr ( inputs % nlambda )) do i = 1 , inputs % nlambda lambda_arr ( i ) = ( i - 0.5 ) * inputs % dlambda + inputs % lambdamin enddo !! convert [Ph/(s*wavel_bin*cm&#94;2*all_directions)] to [Ph/(s*nm*sr*m&#94;2)]! factor = 1.d0 / ( inputs % dlambda ) / ( 4.d0 * pi ) * 1.d4 !! write to file filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_spectra.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ spec_chords % nchan ], error ) call h5ltmake_dataset_int_f ( fid , \"/nlambda\" , 0 , d , [ inputs % nlambda ], error ) dims ( 1 ) = inputs % nlambda dims ( 2 ) = spec_chords % nchan dims ( 3 ) = particles % nclass call h5ltmake_compressed_dataset_double_f ( fid , \"/lambda\" , 1 , dims ( 1 : 1 ), & lambda_arr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dims ( 2 : 2 ), & spec_chords % radius , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nlambda\" , \"description\" , & \"Number of wavelengths\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"description\" , & \"Wavelength array\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"units\" , \"nm\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) if ( inputs % calc_brems . ge . 1 ) then spec % brems = factor * spec % brems !Write variables call h5ltmake_compressed_dataset_double_f ( fid , \"/brems\" , 2 , & dims ( 1 : 2 ), spec % brems , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/brems\" , \"description\" , & \"Visible Bremsstrahlung: brems(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/brems\" , \"units\" ,& \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_bes . ge . 1 ) then spec % full = factor * spec % full spec % half = factor * spec % half spec % third = factor * spec % third !Write variables call h5ltmake_compressed_dataset_double_f ( fid , \"/full\" , 2 , dims ( 1 : 2 ), & spec % full , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/half\" , 2 , dims ( 1 : 2 ), & spec % half , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/third\" , 2 , dims ( 1 : 2 ),& spec % third , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/full\" , \"description\" , & \"Full energy component of the beam emmision: full(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/full\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/half\" , \"description\" , & \"Half energy component of the beam emmision: half(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/half\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/third\" , \"description\" , & \"Third energy component of the beam emmision: third(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/third\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_dcx . ge . 1 ) then spec % dcx = factor * spec % dcx call h5ltmake_compressed_dataset_double_f ( fid , \"/dcx\" , 2 , dims ( 1 : 2 ), & spec % dcx , error ) call h5ltset_attribute_string_f ( fid , \"/dcx\" , \"description\" , & \"Direct Charge Exchange (DCX) emission: dcx(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/dcx\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_halo . ge . 1 ) then spec % halo = factor * spec % halo call h5ltmake_compressed_dataset_double_f ( fid , \"/halo\" , 2 , dims ( 1 : 2 ), & spec % halo , error ) call h5ltset_attribute_string_f ( fid , \"/halo\" , \"description\" , & \"Halo component of the beam emmision: halo(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/halo\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_cold . ge . 1 ) then spec % cold = factor * spec % cold call h5ltmake_compressed_dataset_double_f ( fid , \"/cold\" , 2 , dims ( 1 : 2 ), & spec % cold , error ) call h5ltset_attribute_string_f ( fid , \"/cold\" , \"description\" , & \"Cold D-alpha emission: cold(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/cold\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_fida . ge . 1 ) then spec % fida = factor * spec % fida !Write variables if ( particles % nclass . le . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 2 , & dims ( 1 : 2 ), spec % fida (:,:, 1 ), error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Active Fast-ion D-alpha (FIDA) emmision: fida(lambda,chan)\" , error ) else call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , d , [ particles % nclass ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 3 , & dims , spec % fida , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Active Fast-ion D-alpha (FIDA) emmision: fida(lambda,chan,class)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/fida\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_pfida . ge . 1 ) then spec % pfida = factor * spec % pfida !Write variables if ( particles % nclass . le . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/pfida\" , 2 , & dims ( 1 : 2 ), spec % pfida (:,:, 1 ), error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/pfida\" , \"description\" , & \"Passive Fast-ion D-alpha (p-FIDA) emmision: pfida(lambda,chan)\" , error ) else if ( inputs % calc_fida . le . 0 ) then call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , d , [ particles % nclass ], error ) endif call h5ltmake_compressed_dataset_double_f ( fid , \"/pfida\" , 3 , & dims , spec % pfida , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/pfida\" , \"description\" , & \"Passive Fast-ion D-alpha (p-FIDA) emmision: pfida(lambda,chan,class)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/pfida\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" ,& \"Spectra calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'Spectra written to: ' , trim ( filename ) endif end subroutine write_spectra","tags":"","loc":"proc/write_spectra.html","title":"write_spectra – FIDASIM"},{"text":"public subroutine write_neutrons() Writes neutron to a HDF5 file Arguments None Calls proc~~write_neutrons~~CallsGraph proc~write_neutrons write_neutrons h5fcreate_f h5fcreate_f proc~write_neutrons->h5fcreate_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_neutrons->h5ltmake_dataset_double_f h5open_f h5open_f proc~write_neutrons->h5open_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_neutrons->h5ltset_attribute_string_f h5close_f h5close_f proc~write_neutrons->h5close_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_neutrons->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_neutrons->h5fclose_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f var panprocwrite_neutronsCallsGraph = svgPanZoom('#procwrite_neutronsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_neutrons~~CalledByGraph proc~write_neutrons write_neutrons proc~neutron_mc neutron_mc proc~neutron_mc->proc~write_neutrons proc~neutron_f neutron_f proc~neutron_f->proc~write_neutrons program~fidasim fidasim program~fidasim->proc~neutron_mc program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_neutrons Source Code subroutine write_neutrons !+ Writes [[libfida:neutron]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: error character ( charlim ) :: filename !! write to file filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_neutrons.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables if ( particles % nclass . gt . 1 ) then dim1 ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , dim1 , [ particles % nclass ], error ) dim1 ( 1 ) = particles % nclass call h5ltmake_compressed_dataset_double_f ( fid , \"/rate\" , 1 , dim1 , neutron % rate , error ) call h5ltset_attribute_string_f ( fid , \"/rate\" , \"description\" , & \"Neutron rate: rate(orbit_class)\" , error ) else dim1 ( 1 ) = 1 call h5ltmake_dataset_double_f ( fid , \"/rate\" , 0 , dim1 , neutron % rate , error ) call h5ltset_attribute_string_f ( fid , \"/rate\" , \"description\" , & \"Neutron rate\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/rate\" , \"units\" , \"neutrons/s\" , error ) if (( inputs % dist_type . eq . 1 ). and .( inputs % calc_neutron . ge . 2 )) then dim1 ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , dim1 ,[ fbm % nenergy ], error ) call h5ltmake_dataset_int_f ( fid , \"/npitch\" , 0 , dim1 ,[ fbm % npitch ], error ) call h5ltmake_dataset_int_f ( fid , \"/nr\" , 0 , dim1 ,[ fbm % nr ], error ) call h5ltmake_dataset_int_f ( fid , \"/nz\" , 0 , dim1 ,[ fbm % nz ], error ) dim5 = shape ( neutron % weight ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 5 , dim5 , neutron % weight , error ) dim3 = shape ( neutron % emis ) call h5ltmake_compressed_dataset_double_f ( fid , \"/emissivity\" , 3 , dim3 , neutron % emis , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim5 ( 1 : 1 ), fbm % energy , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , dim5 ( 2 : 2 ), fbm % pitch , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/r\" , 1 , dim5 ( 3 : 3 ), fbm % r , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/z\" , 1 , dim5 ( 4 : 4 ), fbm % z , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/phi\" , 1 , dim5 ( 5 : 5 ), fbm % phi , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/npitch\" , \"description\" , & \"Number of pitch values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nr\" , \"description\" , & \"Number of R values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nz\" , \"description\" , & \"Number of Z values\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"Neutron Weight Function: weight(E,p,R,Z,Phi), rate = sum(f*weight)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , \"neutrons*cm&#94;3*dE*dp/fast-ion*s\" , error ) call h5ltset_attribute_string_f ( fid , \"/emissivity\" , \"description\" , & \"Neutron Emissivity: emissivity(R,Z,Phi), rate = sum(emissivity)\" , error ) call h5ltset_attribute_string_f ( fid , \"/emissivity\" , \"units\" , \"neutrons*cm&#94;3/fast-ion*s\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Pitch array: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( fid , \"/r\" , \"description\" , & \"Radius array\" , error ) call h5ltset_attribute_string_f ( fid , \"/r\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/z\" , \"description\" , & \"Z array\" , error ) call h5ltset_attribute_string_f ( fid , \"/z\" , \"units\" , \"cm\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" ,& \"Neutron rate calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'Neutrons written to: ' , trim ( filename ) endif end subroutine write_neutrons","tags":"","loc":"proc/write_neutrons.html","title":"write_neutrons – FIDASIM"},{"text":"public subroutine write_fida_weights() Writes fweight to a HDF5 file Arguments None Calls proc~~write_fida_weights~~CallsGraph proc~write_fida_weights write_fida_weights h5fcreate_f h5fcreate_f proc~write_fida_weights->h5fcreate_f h5open_f h5open_f proc~write_fida_weights->h5open_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_fida_weights->h5ltset_attribute_string_f h5close_f h5close_f proc~write_fida_weights->h5close_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_fida_weights->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_fida_weights->h5fclose_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f var panprocwrite_fida_weightsCallsGraph = svgPanZoom('#procwrite_fida_weightsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_fida_weights~~CalledByGraph proc~write_fida_weights write_fida_weights proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~write_fida_weights proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~write_fida_weights program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_weights_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_fida_weights Source Code subroutine write_fida_weights !+ Writes [[libfida:fweight]] to a HDF5 file !! HDF5 variables integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer :: error character ( charlim ) :: filename integer :: i , ie , ip , ic , iwav real ( Float64 ), dimension (:), allocatable :: lambda_arr real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr real ( Float64 ), dimension (:,:), allocatable :: jacobian , e_grid , p_grid real ( Float64 ), dimension (:,:), allocatable :: vpa_grid , vpe_grid , fida real ( Float64 ) :: dlambda , wtot , dE , dP dlambda = ( inputs % lambdamax_wght - inputs % lambdamin_wght ) / inputs % nlambda_wght allocate ( lambda_arr ( inputs % nlambda_wght )) do i = 1 , inputs % nlambda_wght lambda_arr ( i ) = ( i - 0.5 ) * dlambda + inputs % lambdamin_wght enddo !! define arrays !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) !! define 2d grids !! define energy grid allocate ( e_grid ( inputs % ne_wght , inputs % np_wght )) do i = 1 , inputs % ne_wght e_grid ( i ,:) = ebarr ( i ) enddo !! define pitch grid allocate ( p_grid ( inputs % ne_wght , inputs % np_wght )) do i = 1 , inputs % np_wght p_grid (:, i ) = ptcharr ( i ) enddo !! define velocity space grid allocate ( vpe_grid ( inputs % ne_wght , inputs % np_wght )) !! V perpendicular allocate ( vpa_grid ( inputs % ne_wght , inputs % np_wght )) !! V parallel vpa_grid = 100 * sqrt (((( 2.0d3 ) * e0 ) / ( mass_u * inputs % ab )) * e_grid ) * p_grid ! [cm/s] vpe_grid = 100 * sqrt (((( 2.0d3 ) * e0 ) / ( mass_u * inputs % ab )) * e_grid * ( 1.0 - p_grid ** 2 )) ![cm/s] !! define jacobian to convert between E-p to velocity allocate ( jacobian ( inputs % ne_wght , inputs % np_wght )) jacobian = (( inputs % ab * mass_u ) / ( e0 * 1.0d3 )) * vpe_grid / sqrt ( vpa_grid ** 2 + vpe_grid ** 2 ) !! normalize mean_f do ic = 1 , spec_chords % nchan do ip = 1 , inputs % np_wght do ie = 1 , inputs % ne_wght wtot = sum ( fweight % weight (:, ie , ip , ic )) if (( wtot . gt . 0.d0 )) then fweight % mean_f ( ie , ip , ic ) = fweight % mean_f ( ie , ip , ic ) / wtot endif enddo enddo enddo !! Calculate FIDA estimate allocate ( fida ( inputs % nlambda_wght , spec_chords % nchan )) do iwav = 1 , size ( fida , 1 ) fida ( iwav ,:) = ( dE * dP * 1 d4 ) * sum ( sum ( fweight % mean_f (:,:,:) * fweight % weight ( iwav ,:,:,:), 1 ), 1 ) enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_fida_weights.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) dim1 ( 1 ) = 1 dim2 = [ inputs % nlambda_wght , spec_chords % nchan ] dim4 = [ inputs % nlambda_wght , inputs % ne_wght , inputs % np_wght , spec_chords % nchan ] call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , dim1 ,[ inputs % ne_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/npitch\" , 0 , dim1 ,[ inputs % np_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , dim1 ,[ spec_chords % nchan ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 4 , dim4 , fweight % weight , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 2 , dim2 , fida , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/mean_f\" , 3 , dim4 ( 2 : 4 ), fweight % mean_f , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/lambda\" , 1 , dim4 ( 1 : 1 ), lambda_arr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim4 ( 2 : 2 ), ebarr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , dim4 ( 3 : 3 ), ptcharr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dim4 ( 4 : 4 ), spec_chords % radius , error ) dim2 = [ inputs % ne_wght , inputs % np_wght ] call h5ltmake_compressed_dataset_double_f ( fid , \"/jacobian\" , 2 , dim2 , jacobian , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vpe_grid\" , 2 , dim2 , vpe_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vpa_grid\" , 2 , dim2 , vpa_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/e_grid\" , 2 , dim2 , e_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/p_grid\" , 2 , dim2 , p_grid , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) if ( inputs % calc_fida_wght . eq . 1 ) then call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Line of Sight averaged FIDA E-p space sensitivity/weights \" // & \"and spectra calculated by FIDASIM\" , error ) else call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Full FIDA E-p space sensitivity/weights and spectra calculated \" // & \"by FIDASIM via Monte Carlo method\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"E-p space sensivity/weight of FIDA diagnostic: weight(lambda,energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , & \"(Ph*cm)/(s*nm*sr*fast-ion*dE*dP)\" , error ) call h5ltset_attribute_string_f ( fid , \"/fida\" , \"units\" , & \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Estimate of Fast-ion D-alpha (FIDA) emmision calculated by 1e4*weight*mean_f*dEdP: fida(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/mean_f\" , \"description\" , & \"Estimated mean fast-ion distribution function seen by los: mean_f(energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/mean_f\" , \"units\" , & \"fast-ion/(dE*dP*cm&#94;3)\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"description\" , & \"Wavelength array\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"units\" , \"nm\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/npitch\" , \"description\" , & \"Number of pitch value\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Pitch array: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/jacobian\" , \"description\" , & \"Jacobian used to convert from E-p space to velocity space\" , error ) call h5ltset_attribute_string_f ( fid , \"/jacobian\" , \"units\" , & \"(dE*dP)/(dvpa*dvpe)\" , error ) call h5ltset_attribute_string_f ( fid , \"/e_grid\" , \"description\" , & \"2D energy grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/e_grid\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/p_grid\" , \"description\" , & \"2D pitch grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpe_grid\" , \"description\" , & \"2D perpendicular velocity grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpe_grid\" , \"units\" , \"cm/s\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpa_grid\" , \"description\" , & \"2D parallel velocity grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpa_grid\" , \"units\" , \"cm/s\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'FIDA weights written to: ' , trim ( filename ) endif end subroutine write_fida_weights","tags":"","loc":"proc/write_fida_weights.html","title":"write_fida_weights – FIDASIM"},{"text":"public subroutine write_npa_weights() Writes nweight to a HDF5 file Arguments None Calls proc~~write_npa_weights~~CallsGraph proc~write_npa_weights write_npa_weights h5fcreate_f h5fcreate_f proc~write_npa_weights->h5fcreate_f proc~write_beam_grid write_beam_grid proc~write_npa_weights->proc~write_beam_grid h5open_f h5open_f proc~write_npa_weights->h5open_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_npa_weights->h5ltset_attribute_string_f h5close_f h5close_f proc~write_npa_weights->h5close_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_npa_weights->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_npa_weights->h5fclose_f proc~write_beam_grid->h5ltset_attribute_string_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f proc~xyz_to_uvw xyz_to_uvw proc~write_beam_grid->proc~xyz_to_uvw proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f var panprocwrite_npa_weightsCallsGraph = svgPanZoom('#procwrite_npa_weightsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_npa_weights~~CalledByGraph proc~write_npa_weights write_npa_weights proc~npa_weights npa_weights proc~npa_weights->proc~write_npa_weights program~fidasim fidasim program~fidasim->proc~npa_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_npa_weights Source Code subroutine write_npa_weights !+ Writes [[libfida:nweight]] to a HDF5 file character ( charlim ) :: filename integer :: i real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr !! HDF5 variables integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_npa_weights.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables d ( 1 ) = 1 dim2 = [ inputs % ne_wght , npa_chords % nchan ] dim3 = [ inputs % ne_wght , inputs % np_wght , npa_chords % nchan ] dim5 = [ inputs % ne_wght , beam_grid % nx , beam_grid % ny , beam_grid % nz , npa_chords % nchan ] call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ npa_chords % nchan ], error ) call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , d , [ inputs % ne_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/npitch\" , 0 , d , [ inputs % np_wght ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , & dim2 ( 2 : 2 ), npa_chords % radius , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , & dim2 ( 1 : 1 ), ebarr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , & dim3 ( 2 : 2 ), ptcharr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/flux\" , 2 , & dim2 , nweight % flux , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 3 , & dim3 , nweight % weight , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"NPA E-p space sensitivity/weights and Flux calculated by FIDASIM\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/npitch\" , \"description\" , & \"Number of pitch value\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Pitch array: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"description\" , & \"Neutral flux: flux(energy,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"units\" , & \"neutrals/(s*dE)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"E-p space sensivity/weight of NPA diagnostics: weight(energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , & \"neutrals/(s*fast-ion*dE*dP)\" , error ) if ( inputs % calc_npa_wght . ge . 2 ) then !Write diagnostic variables call write_beam_grid ( fid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/emissivity\" , 4 , & dim5 ( 2 : 5 ), nweight % emissivity , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/attenuation\" , 5 , & dim5 , nweight % attenuation , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/cx\" , 5 , & dim5 , nweight % cx , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/phit\" , 4 , & dim5 ( 2 : 5 ), npa_chords % phit % p , error ) call h5ltset_attribute_string_f ( fid , \"/emissivity\" , \"description\" , & \"Neutral emissivity: emissivity(x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/emissivity\" , \"units\" , & \"neutrals/(s*dV)\" , error ) call h5ltset_attribute_string_f ( fid , \"/cx\" , \"description\" , & \"Charge-exchange rate: cx(energy,x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/cx\" , \"units\" , \"s&#94;(-1)\" , error ) call h5ltset_attribute_string_f ( fid , \"/attenuation\" , \"description\" , & \"Attenuation factor i.e. survival probability: attenuation(energy,x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/phit\" , \"description\" , & \"Probability of hitting the detector given an isotropic source: phit(x,y,z,chan)\" , error ) endif !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'NPA weights written to: ' , trim ( filename ) endif end subroutine write_npa_weights","tags":"","loc":"proc/write_npa_weights.html","title":"write_npa_weights – FIDASIM"},{"text":"public subroutine read_neutrals() Reads neutral density from file and puts it in neut Arguments None Calls proc~~read_neutrals~~CallsGraph proc~read_neutrals read_neutrals h5close_f h5close_f proc~read_neutrals->h5close_f h5gopen_f h5gopen_f proc~read_neutrals->h5gopen_f h5ltpath_valid_f h5ltpath_valid_f proc~read_neutrals->h5ltpath_valid_f h5gclose_f h5gclose_f proc~read_neutrals->h5gclose_f h5open_f h5open_f proc~read_neutrals->h5open_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_neutrals->h5ltread_dataset_double_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_neutrals->proc~h5ltread_dataset_int_scalar_f h5fclose_f h5fclose_f proc~read_neutrals->h5fclose_f h5fopen_f h5fopen_f proc~read_neutrals->h5fopen_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_neutrals~~CalledByGraph proc~read_neutrals read_neutrals program~fidasim fidasim program~fidasim->proc~read_neutrals Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code read_neutrals Source Code subroutine read_neutrals !+ Reads neutral density from file and puts it in [[libfida:neut]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 4 ) :: dims integer :: error , nx , ny , nz logical :: exis , fatal_error if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- loading neutrals ----' endif inquire ( file = inputs % neutrals_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Neutrals file: \",a)' ) trim ( inputs % neutrals_file ) write ( * , * ) '' endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_NEUTRALS: Neutrals file does not exist: ' , inputs % neutrals_file endif stop endif !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fopen_f ( inputs % neutrals_file , H5F_ACC_RDONLY_F , fid , error ) call h5gopen_f ( fid , \"/grid\" , gid , error ) call h5ltread_dataset_int_scalar_f ( gid , \"nx\" , nx , error ) call h5ltread_dataset_int_scalar_f ( gid , \"ny\" , ny , error ) call h5ltread_dataset_int_scalar_f ( gid , \"nz\" , nz , error ) call h5gclose_f ( gid , error ) fatal_error = . False . if (( nx . ne . beam_grid % nx ). or . & ( ny . ne . beam_grid % ny ). or . & ( nz . ne . beam_grid % nz )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_NEUTRALS: Neutrals file has incompatable grid dimensions' endif fatal_error = . True . endif !Check to make sure the neutrals file has all the needed neutrals call h5ltpath_valid_f ( fid , \"/fdens\" , . True ., exis , error ) if ((. not . exis ). and .( inputs % calc_nbi_dens . ge . 1 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_NEUTRALS: Full energy neutral density is not in the neutrals file' endif fatal_error = . True . endif call h5ltpath_valid_f ( fid , \"/hdens\" , . True ., exis , error ) if ((. not . exis ). and .( inputs % calc_nbi_dens . ge . 1 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_NEUTRALS: Half energy neutral density is not in the neutrals file' endif fatal_error = . True . endif call h5ltpath_valid_f ( fid , \"/tdens\" , . True ., exis , error ) if ((. not . exis ). and .( inputs % calc_nbi_dens . ge . 1 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_NEUTRALS: Third energy neutral density is not in the neutrals file' endif fatal_error = . True . endif call h5ltpath_valid_f ( fid , \"/dcxdens\" , . True ., exis , error ) if ((. not . exis ). and .( inputs % calc_dcx_dens . ge . 1 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_NEUTRALS: Direct Charge Exchange (DCX) neutral density is not in the neutrals file' endif fatal_error = . True . endif call h5ltpath_valid_f ( fid , \"/halodens\" , . True ., exis , error ) if ((. not . exis ). and .( inputs % calc_halo_dens . ge . 1 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_NEUTRALS: Thermal Halo neutral density is not in the neutrals file' endif fatal_error = . True . endif if ( fatal_error ) stop dims = [ nlevs , nx , ny , nz ] if ( inputs % calc_nbi_dens . ge . 1 ) then call h5ltread_dataset_double_f ( fid , \"/fdens\" , & neut % full , dims , error ) call h5ltread_dataset_double_f ( fid , \"/hdens\" , & neut % half , dims , error ) call h5ltread_dataset_double_f ( fid , \"/tdens\" , & neut % third , dims , error ) endif if ( inputs % calc_dcx_dens . ge . 1 ) then call h5ltread_dataset_double_f ( fid , \"/dcxdens\" , & neut % dcx , dims , error ) endif if ( inputs % calc_halo_dens . ge . 1 ) then call h5ltread_dataset_double_f ( fid , \"/halodens\" , & neut % halo , dims , error ) endif !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) end subroutine read_neutrals","tags":"","loc":"proc/read_neutrals.html","title":"read_neutrals – FIDASIM"},{"text":"public subroutine tb_zyx(alpha, beta, gamma, basis, inv_basis) Creates active rotation matrix for z-y'-x\" rotation given Tait-Bryan angles Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: alpha Angle of rotation about z real(kind=Float64), intent(in) :: beta Angle of rotation about y' real(kind=Float64), intent(in) :: gamma Angle of rotation about x\" real(kind=Float64), intent(out), dimension(3,3) :: basis Rotation matrix/basis for transforming from rotated to non-rotated coordinates real(kind=Float64), intent(out), optional dimension(3,3) :: inv_basis Inverse basis for reverse transformation Called by proc~~tb_zyx~~CalledByGraph proc~tb_zyx tb_zyx proc~line_basis line_basis proc~line_basis->proc~tb_zyx proc~make_beam_grid make_beam_grid proc~make_beam_grid->proc~tb_zyx proc~read_beam read_beam proc~read_beam->proc~tb_zyx proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~line_basis program~fidasim fidasim program~fidasim->proc~make_beam_grid program~fidasim->proc~bremsstrahlung proc~make_diagnostic_grids make_diagnostic_grids program~fidasim->proc~make_diagnostic_grids proc~make_diagnostic_grids->proc~line_basis Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code tb_zyx Source Code subroutine tb_zyx ( alpha , beta , gamma , basis , inv_basis ) !+ Creates active rotation matrix for z-y'-x\" rotation given Tait-Bryan angles real ( Float64 ), intent ( in ) :: alpha !+ Angle of rotation about z real ( Float64 ), intent ( in ) :: beta !+ Angle of rotation about y' real ( Float64 ), intent ( in ) :: gamma !+ Angle of rotation about x\" real ( Float64 ), dimension ( 3 , 3 ), intent ( out ) :: basis !+ Rotation matrix/basis for transforming from rotated to non-rotated coordinates real ( Float64 ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis !+ Inverse basis for reverse transformation real ( Float64 ) :: sa , sb , sg , ca , cb , cg sa = sin ( alpha ) ; sb = sin ( beta ) ; sg = sin ( gamma ) ca = cos ( alpha ) ; cb = cos ( beta ) ; cg = cos ( gamma ) basis ( 1 , 1 ) = ca * cb ; basis ( 1 , 2 ) = ca * sb * sg - cg * sa ; basis ( 1 , 3 ) = sa * sg + ca * cg * sb basis ( 2 , 1 ) = cb * sa ; basis ( 2 , 2 ) = ca * cg + sa * sb * sg ; basis ( 2 , 3 ) = cg * sa * sb - ca * sg basis ( 3 , 1 ) = - sb ; basis ( 3 , 2 ) = cb * sg ; basis ( 3 , 3 ) = cb * cg if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine tb_zyx","tags":"","loc":"proc/tb_zyx.html","title":"tb_zyx – FIDASIM"},{"text":"public subroutine line_basis(r0, v0, basis, inv_basis) Calculates basis from a line with +x in the direction of line Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Starting point of line [cm] real(kind=Float64), intent(in), dimension(3) :: v0 Direction of line real(kind=Float64), intent(out), dimension(3,3) :: basis Basis for transforming from line coordinates to cartesian real(kind=Float64), intent(out), optional dimension(3,3) :: inv_basis Inverse basis for the reverse transformation cartesian to line Calls proc~~line_basis~~CallsGraph proc~line_basis line_basis proc~tb_zyx tb_zyx proc~line_basis->proc~tb_zyx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~line_basis~~CalledByGraph proc~line_basis line_basis proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~line_basis proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~line_basis program~fidasim fidasim program~fidasim->proc~bremsstrahlung program~fidasim->proc~make_diagnostic_grids Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code line_basis Source Code subroutine line_basis ( r0 , v0 , basis , inv_basis ) !+ Calculates basis from a line with +x in the direction of line real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Starting point of line [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Direction of line real ( Float64 ), dimension ( 3 , 3 ), intent ( out ) :: basis !+ Basis for transforming from line coordinates to cartesian real ( Float64 ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis !+ Inverse basis for the reverse transformation cartesian to line real ( Float64 ), dimension ( 3 ) :: rf real ( Float64 ) :: alpha , beta , dis rf = r0 + v0 dis = sqrt ( sum (( rf - r0 ) ** 2 )) beta = asin (( r0 ( 3 ) - rf ( 3 )) / dis ) alpha = atan2 ( rf ( 2 ) - r0 ( 2 ), rf ( 1 ) - r0 ( 1 )) call tb_zyx ( alpha , beta , 0.d0 , basis ) if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine line_basis","tags":"","loc":"proc/line_basis.html","title":"line_basis – FIDASIM"},{"text":"public subroutine plane_basis(center, redge, tedge, basis, inv_basis) Calculates basis from 3 points on a plane with +z being the plane normal Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: center Plane origin real(kind=Float64), intent(in), dimension(3) :: redge Right edge of plane real(kind=Float64), intent(in), dimension(3) :: tedge Top edge of plane real(kind=Float64), intent(out), dimension(3,3) :: basis Basis for transforming from plane to cartesian coordinates real(kind=Float64), intent(out), optional dimension(3,3) :: inv_basis Inverse basis for the reverse transformation cartesian to plane Calls proc~~plane_basis~~CallsGraph proc~plane_basis plane_basis proc~cross_product cross_product proc~plane_basis->proc~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~plane_basis~~CalledByGraph proc~plane_basis plane_basis proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~plane_basis proc~read_npa read_npa proc~read_npa->proc~plane_basis proc~pfida_mc pfida_mc proc~pfida_mc->proc~track_cylindrical proc~pfida_f pfida_f proc~pfida_f->proc~track_cylindrical program~fidasim fidasim program~fidasim->proc~read_npa program~fidasim->proc~pfida_mc program~fidasim->proc~pfida_f proc~make_diagnostic_grids make_diagnostic_grids program~fidasim->proc~make_diagnostic_grids proc~make_diagnostic_grids->proc~track_cylindrical Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code plane_basis Source Code subroutine plane_basis ( center , redge , tedge , basis , inv_basis ) !+ Calculates basis from 3 points on a plane with +z being the plane normal real ( Float64 ), dimension ( 3 ), intent ( in ) :: center !+ Plane origin real ( Float64 ), dimension ( 3 ), intent ( in ) :: redge !+ Right edge of plane real ( Float64 ), dimension ( 3 ), intent ( in ) :: tedge !+ Top edge of plane real ( Float64 ), dimension ( 3 , 3 ), intent ( out ) :: basis !+ Basis for transforming from plane to cartesian coordinates real ( Float64 ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis !+ Inverse basis for the reverse transformation cartesian to plane real ( Float64 ), dimension ( 3 ) :: u1 , u2 , u3 u1 = ( redge - center ) u1 = u1 / norm2 ( u1 ) u2 = ( tedge - center ) u2 = u2 / norm2 ( u2 ) u3 = cross_product ( u1 , u2 ) u3 = u3 / norm2 ( u3 ) basis (:, 1 ) = u1 basis (:, 2 ) = u2 basis (:, 3 ) = u3 if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine plane_basis","tags":"","loc":"proc/plane_basis.html","title":"plane_basis – FIDASIM"},{"text":"public subroutine line_plane_intersect(l0, l, p0, n, p, t) Calculates the intersection of a line and a plane Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: l0 Point on line real(kind=Float64), intent(in), dimension(3) :: l Ray of line real(kind=Float64), intent(in), dimension(3) :: p0 Point on plane real(kind=Float64), intent(in), dimension(3) :: n Normal vector of plane real(kind=Float64), intent(out), dimension(3) :: p Line-plane intersect point real(kind=Float64), intent(out) :: t \"time\" to intersect Called by proc~~line_plane_intersect~~CalledByGraph proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector hit_npa_detector proc~hit_npa_detector->proc~line_plane_intersect proc~gyro_range gyro_range proc~gyro_range->proc~line_plane_intersect proc~pnpa_f pnpa_f proc~pnpa_f->proc~hit_npa_detector proc~npa_gyro_range npa_gyro_range proc~pnpa_f->proc~npa_gyro_range proc~npa_gyro_range->proc~gyro_range proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~hit_npa_detector proc~pnpa_mc->proc~npa_gyro_range proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~hit_npa_detector proc~npa_f npa_f proc~npa_f->proc~hit_npa_detector proc~npa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~hit_npa_detector proc~npa_mc->proc~npa_gyro_range proc~npa_weights npa_weights proc~npa_weights->proc~hit_npa_detector program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~npa_f program~fidasim->proc~npa_mc program~fidasim->proc~npa_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code line_plane_intersect Source Code subroutine line_plane_intersect ( l0 , l , p0 , n , p , t ) !+ Calculates the intersection of a line and a plane real ( Float64 ), dimension ( 3 ), intent ( in ) :: l0 !+ Point on line real ( Float64 ), dimension ( 3 ), intent ( in ) :: l !+ Ray of line real ( Float64 ), dimension ( 3 ), intent ( in ) :: p0 !+ Point on plane real ( Float64 ), dimension ( 3 ), intent ( in ) :: n !+ Normal vector of plane real ( Float64 ), dimension ( 3 ), intent ( out ) :: p !+ Line-plane intersect point real ( Float64 ), intent ( out ) :: t !+ \"time\" to intersect real ( Float64 ) :: ldotn ldotn = dot_product ( l , n ) if ( ldotn . eq . 0.0 ) then t = 0.0 else t = dot_product ( p0 - l0 , n ) / ldotn endif p = l0 + t * l end subroutine line_plane_intersect","tags":"","loc":"proc/line_plane_intersect.html","title":"line_plane_intersect – FIDASIM"},{"text":"public subroutine line_cylinder_intersect(l0, l, p0, p, t) Calculates the intersection of a line and a cylinder Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: l0 Point on line real(kind=Float64), intent(in), dimension(3) :: l Ray of line real(kind=Float64), intent(in), dimension(3) :: p0 Point on cylinder real(kind=Float64), intent(out), dimension(3) :: p Line-cylinder intersect point real(kind=Float64), intent(out) :: t \"time\" to intersect Contents Source Code line_cylinder_intersect Source Code subroutine line_cylinder_intersect ( l0 , l , p0 , p , t ) !+ Calculates the intersection of a line and a cylinder real ( Float64 ), dimension ( 3 ), intent ( in ) :: l0 !+ Point on line real ( Float64 ), dimension ( 3 ), intent ( in ) :: l !+ Ray of line real ( Float64 ), dimension ( 3 ), intent ( in ) :: p0 !+ Point on cylinder real ( Float64 ), dimension ( 3 ), intent ( out ) :: p !+ Line-cylinder intersect point real ( Float64 ), intent ( out ) :: t !+ \"time\" to intersect real ( Float64 ), dimension ( 2 ) :: times logical , dimension ( 2 ) :: mask real ( Float64 ) :: r , vx , vy , x0 , y0 real ( Float64 ) :: radicand , npos r = sqrt ( p0 ( 1 ) * p0 ( 1 ) + p0 ( 2 ) * p0 ( 2 )) x0 = l0 ( 1 ) ; y0 = l0 ( 2 ) vx = l ( 1 ) ; vy = l ( 2 ) if (( vx . eq . 0.d0 ). and .( vy . eq . 0.d0 )) then t = 0.d0 ! Parallel to a plane tangent to the cylinder else radicand = r ** 2 * ( vx ** 2 + vy ** 2 ) - ( vy * x0 - vx * y0 ) ** 2 if ( radicand . lt . 0 ) then t = 0.d0 ! Parallel to a plane tangent to the cylinder else times ( 1 ) = ( - vx * x0 - vy * y0 - sqrt ( radicand )) / ( vx ** 2 + vy ** 2 ) times ( 2 ) = ( - vx * x0 - vy * y0 + sqrt ( radicand )) / ( vx ** 2 + vy ** 2 ) mask = times . gt . 0 npos = count ( mask ) if ( npos . gt . 0 ) then t = minval ( times , mask = times . gt . 0 ) else t = maxval ( times , mask = times . le . 0 ) endif endif endif p = l0 + l * t end subroutine line_cylinder_intersect","tags":"","loc":"proc/line_cylinder_intersect.html","title":"line_cylinder_intersect – FIDASIM"},{"text":"public subroutine boundary_edge(bplane, bedge, nb) Returns 3 x nb array containing points along the BoundedPlane's boundary edge Arguments Type Intent Optional Attributes Name type( BoundedPlane ), intent(in) :: bplane Bounded plane real(kind=Float64), intent(out), dimension(:,:) :: bedge Boundary edge points of bounded plane integer, intent(out) :: nb Number of points in boundary edge Called by proc~~boundary_edge~~CalledByGraph proc~boundary_edge boundary_edge proc~gyro_range gyro_range proc~gyro_range->proc~boundary_edge proc~npa_gyro_range npa_gyro_range proc~npa_gyro_range->proc~gyro_range proc~pnpa_f pnpa_f proc~pnpa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~npa_gyro_range proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~npa_gyro_range proc~npa_f npa_f proc~npa_f->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~npa_mc program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code boundary_edge Source Code subroutine boundary_edge ( bplane , bedge , nb ) !+ Returns 3 x `nb` array containing points along the BoundedPlane's boundary edge type ( BoundedPlane ), intent ( in ) :: bplane !+ Bounded plane real ( Float64 ), dimension (:,:), intent ( out ) :: bedge !+ Boundary edge points of bounded plane integer , intent ( out ) :: nb !+ Number of points in boundary edge integer :: i real ( Float64 ) :: th , dth , x , y real ( Float64 ), dimension ( 4 ) :: xx , yy select case ( bplane % shape ) case ( 1 ) !Rectangular boundary nb = 4 if ( nb . gt . size ( bedge , 2 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(\"BOUNDARY_EDGE: Incompatible boundary edge array : \",i2,\" > \",i2)' ) nb , size ( bedge , 2 ) endif stop endif xx = [ - bplane % hw , - bplane % hw , bplane % hw , bplane % hw ] yy = [ - bplane % hh , bplane % hh , bplane % hh , - bplane % hh ] do i = 1 , nb bedge (:, i ) = matmul ( bplane % basis ,[ xx ( i ), yy ( i ), 0.d0 ]) + bplane % origin enddo case ( 2 ) nb = 50 if ( nb . gt . size ( bedge , 2 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(\"BOUNDARY_EDGE: Incompatible boundary edge array : \",i2,\" > \",i2)' ) nb , size ( bedge , 2 ) endif stop endif dth = 2 * pi / nb do i = 1 , nb th = i * dth x = bplane % hw * cos ( th ) y = bplane % hh * sin ( th ) bedge (:, i ) = matmul ( bplane % basis ,[ x , y , 0.d0 ]) + bplane % origin enddo case default if ( inputs % verbose . ge . 0 ) then write ( * , '(\"BOUNDARY_EDGE: Unknown boundary shape: \",i2)' ) bplane % shape endif stop end select end subroutine boundary_edge","tags":"","loc":"proc/boundary_edge.html","title":"boundary_edge – FIDASIM"},{"text":"public subroutine gyro_surface(fields, energy, pitch, gs) Calculates the surface of all possible trajectories Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: fields Electromagnetic fields at guiding center real(kind=Float64), intent(in) :: energy Energy of particle real(kind=Float64), intent(in) :: pitch Particle pitch w.r.t the magnetic field type( GyroSurface ), intent(out) :: gs Gyro-surface Called by proc~~gyro_surface~~CalledByGraph proc~gyro_surface gyro_surface proc~pnpa_f pnpa_f proc~pnpa_f->proc~gyro_surface proc~npa_mc npa_mc proc~npa_mc->proc~gyro_surface proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~gyro_surface proc~npa_f npa_f proc~npa_f->proc~gyro_surface program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~npa_mc program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code gyro_surface Source Code subroutine gyro_surface ( fields , energy , pitch , gs ) !+ Calculates the surface of all possible trajectories type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields at guiding center real ( Float64 ), intent ( in ) :: energy !+ Energy of particle real ( Float64 ), intent ( in ) :: pitch !+ Particle pitch w.r.t the magnetic field type ( GyroSurface ), intent ( out ) :: gs !+ Gyro-surface integer :: i real ( Float64 ) :: alpha , vabs , omega real ( Float64 ), dimension ( 3 , 3 ) :: s vabs = sqrt ( energy / ( v2_to_E_per_amu * inputs % ab )) omega = ( fields % b_abs * e0 ) / ( inputs % ab * mass_u ) alpha = vabs / omega gs % omega = omega gs % v = vabs gs % axes ( 1 ) = alpha * sqrt ( 1 - pitch ** 2 ) gs % axes ( 2 ) = alpha * sqrt ( 1 - pitch ** 2 ) gs % axes ( 3 ) = pitch * alpha s = 0.d0 s ( 1 , 1 ) = gs % axes ( 1 ) ** ( - 2 ) s ( 2 , 2 ) = gs % axes ( 2 ) ** ( - 2 ) s ( 3 , 3 ) = - gs % axes ( 3 ) ** ( - 2 ) gs % center = fields % pos gs % basis (:, 1 ) = fields % a_norm gs % basis (:, 2 ) = fields % c_norm gs % basis (:, 3 ) = fields % b_norm gs % A = matmul ( gs % basis , matmul ( s , transpose ( gs % basis ))) end subroutine gyro_surface","tags":"","loc":"proc/gyro_surface.html","title":"gyro_surface – FIDASIM"},{"text":"public subroutine line_gyro_surface_intersect(r0, v0, gs, t) Calculates the times of intersection of a line and a gyro-surface Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Point on line real(kind=Float64), intent(in), dimension(3) :: v0 Direction of line type( GyroSurface ), intent(in) :: gs Gyro-surface real(kind=Float64), intent(out), dimension(2) :: t \"time\" to intersect Called by proc~~line_gyro_surface_intersect~~CalledByGraph proc~line_gyro_surface_intersect line_gyro_surface_intersect proc~gyro_range gyro_range proc~gyro_range->proc~line_gyro_surface_intersect proc~npa_gyro_range npa_gyro_range proc~npa_gyro_range->proc~gyro_range proc~pnpa_f pnpa_f proc~pnpa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~npa_gyro_range proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~npa_gyro_range proc~npa_f npa_f proc~npa_f->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~npa_mc program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code line_gyro_surface_intersect Source Code subroutine line_gyro_surface_intersect ( r0 , v0 , gs , t ) !+ Calculates the times of intersection of a line and a gyro-surface real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Point on line real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Direction of line type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-surface real ( Float64 ), dimension ( 2 ), intent ( out ) :: t !+ \"time\" to intersect real ( Float64 ), dimension ( 3 ) :: rr real ( Float64 ) :: a , b , c , d , tp , tm rr = r0 - gs % center a = dot_product ( v0 , matmul ( gs % A , v0 )) b = dot_product ( rr , matmul ( gs % A , v0 )) + dot_product ( v0 , matmul ( gs % A , rr )) c = dot_product ( rr , matmul ( gs % A , rr )) - 1.0 d = b ** 2 - 4 * a * c if ( d . lt . 0.0 ) then t = 0.0 return endif t ( 1 ) = ( - b - sqrt ( d )) / ( 2 * a ) t ( 2 ) = ( - b + sqrt ( d )) / ( 2 * a ) end subroutine line_gyro_surface_intersect","tags":"","loc":"proc/line_gyro_surface_intersect.html","title":"line_gyro_surface_intersect – FIDASIM"},{"text":"public subroutine gyro_surface_coordinates(gs, p, u) Calculates the parametric coordinates, u , of point p on the gyro_surface Arguments Type Intent Optional Attributes Name type( GyroSurface ), intent(in) :: gs Gyro_surface real(kind=Float64), intent(in), dimension(3) :: p Point on gyro_surface real(kind=Float64), intent(out), dimension(2) :: u Parametric coordinates (gyro-angle, t) Called by proc~~gyro_surface_coordinates~~CalledByGraph proc~gyro_surface_coordinates gyro_surface_coordinates proc~gyro_range gyro_range proc~gyro_range->proc~gyro_surface_coordinates proc~npa_gyro_range npa_gyro_range proc~npa_gyro_range->proc~gyro_range proc~pnpa_f pnpa_f proc~pnpa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~npa_gyro_range proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~npa_gyro_range proc~npa_f npa_f proc~npa_f->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~npa_mc program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code gyro_surface_coordinates Source Code subroutine gyro_surface_coordinates ( gs , p , u ) !+ Calculates the parametric coordinates, `u`, of point `p` on the gyro_surface type ( GyroSurface ), intent ( in ) :: gs !+ Gyro_surface real ( Float64 ), dimension ( 3 ), intent ( in ) :: p !+ Point on gyro_surface real ( Float64 ), dimension ( 2 ), intent ( out ) :: u !+ Parametric coordinates (gyro-angle, t) real ( Float64 ), dimension ( 3 ) :: pp real ( Float64 ) :: t , a , b , c , d , thm , thp , dp , dm , th integer :: i pp = matmul ( transpose ( gs % basis ), p - gs % center ) t = pp ( 3 ) / gs % axes ( 3 ) a = gs % axes ( 1 ) + gs % axes ( 2 ) * t b = gs % axes ( 2 ) - gs % axes ( 1 ) * t d = pp ( 1 ) + pp ( 2 ) c = max ( min ( d / sqrt ( a ** 2 + b ** 2 ), 1.d0 ), - 1.d0 ) thm = - acos ( c ) + atan2 ( b , a ) thp = acos ( c ) + atan2 ( b , a ) dm = norm2 ([ gs % axes ( 1 ) * ( cos ( thm ) - t * sin ( thm )), & gs % axes ( 2 ) * ( sin ( thm ) + t * cos ( thm )), & gs % axes ( 3 ) * t ] - pp ) dp = norm2 ([ gs % axes ( 1 ) * ( cos ( thp ) - t * sin ( thp )), & gs % axes ( 2 ) * ( sin ( thp ) + t * cos ( thp )), & gs % axes ( 3 ) * t ] - pp ) th = thm - pi / 2 if ( dp . le . dm ) th = thp - pi / 2 if ( th . lt . 0.0 ) th = th + 2 * pi u = [ th , t / gs % omega ] end subroutine gyro_surface_coordinates","tags":"","loc":"proc/gyro_surface_coordinates.html","title":"gyro_surface_coordinates – FIDASIM"},{"text":"public subroutine gyro_trajectory(gs, theta, ri, vi) Calculate particle trajectory for a given gyro-angle and gyro-surface Arguments Type Intent Optional Attributes Name type( GyroSurface ), intent(in) :: gs Gyro-Surface real(kind=Float64), intent(in) :: theta Gyro-angle real(kind=Float64), dimension(3) :: ri Particle position real(kind=Float64), dimension(3) :: vi Particle Velocity Called by proc~~gyro_trajectory~~CalledByGraph proc~gyro_trajectory gyro_trajectory proc~pnpa_f pnpa_f proc~pnpa_f->proc~gyro_trajectory proc~npa_mc npa_mc proc~npa_mc->proc~gyro_trajectory proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~gyro_trajectory proc~npa_f npa_f proc~npa_f->proc~gyro_trajectory program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~npa_mc program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code gyro_trajectory Source Code subroutine gyro_trajectory ( gs , theta , ri , vi ) !+ Calculate particle trajectory for a given gyro-angle and gyro-surface type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-Surface real ( Float64 ), intent ( in ) :: theta !+ Gyro-angle real ( Float64 ), dimension ( 3 ) :: ri !+ Particle position real ( Float64 ), dimension ( 3 ) :: vi !+ Particle Velocity real ( Float64 ) :: a , b , c , th a = gs % axes ( 1 ) b = gs % axes ( 2 ) c = gs % axes ( 3 ) th = theta + pi / 2 ri = matmul ( gs % basis , [ a * cos ( th ), b * sin ( th ), 0.d0 ]) + gs % center vi = gs % omega * matmul ( gs % basis , [ - a * sin ( th ), b * cos ( th ), c ]) end subroutine gyro_trajectory","tags":"","loc":"proc/gyro_trajectory.html","title":"gyro_trajectory – FIDASIM"},{"text":"public subroutine gyro_range(b, gs, gyrange, nrange) Calculates the range(s) of gyro-angles that would land within a bounded plane Arguments Type Intent Optional Attributes Name type( BoundedPlane ), intent(in) :: b Bounded Plane type( GyroSurface ), intent(in) :: gs Gyro-surface real(kind=Float64), intent(out), dimension(2,4) :: gyrange (theta, dtheta) values integer, intent(out) :: nrange Number of ranges. 1 <= nrange <= 4 Calls proc~~gyro_range~~CallsGraph proc~gyro_range gyro_range proc~boundary_edge boundary_edge proc~gyro_range->proc~boundary_edge proc~line_gyro_surface_intersect line_gyro_surface_intersect proc~gyro_range->proc~line_gyro_surface_intersect proc~line_plane_intersect line_plane_intersect proc~gyro_range->proc~line_plane_intersect proc~gyro_surface_coordinates gyro_surface_coordinates proc~gyro_range->proc~gyro_surface_coordinates proc~in_boundary in_boundary proc~gyro_range->proc~in_boundary proc~in_gyro_surface in_gyro_surface proc~gyro_range->proc~in_gyro_surface Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gyro_range~~CalledByGraph proc~gyro_range gyro_range proc~npa_gyro_range npa_gyro_range proc~npa_gyro_range->proc~gyro_range proc~pnpa_f pnpa_f proc~pnpa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~npa_gyro_range proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~npa_gyro_range proc~npa_f npa_f proc~npa_f->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~npa_mc program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code gyro_range Source Code subroutine gyro_range ( b , gs , gyrange , nrange ) !+ Calculates the range(s) of gyro-angles that would land within a bounded plane type ( BoundedPlane ), intent ( in ) :: b !+ Bounded Plane type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-surface real ( Float64 ), dimension ( 2 , 4 ), intent ( out ) :: gyrange !+ (theta, dtheta) values integer , intent ( out ) :: nrange !+ Number of ranges. `1 <= nrange <= 4` integer :: nb , i , j , ninter logical :: in_gs logical , dimension ( 8 ) :: cross = . False . real ( Float64 ) :: t_p , th1 , th2 , dth real ( Float64 ), dimension ( 2 ) :: u_cur , t_i real ( Float64 ), dimension ( 3 ) :: rc , p_pre , p_cur , v0 , ri real ( Float64 ), dimension ( 2 , 8 ) :: u real ( Float64 ), dimension ( 3 , 50 ) :: bedge nrange = 0 gyrange = 0.d0 call line_plane_intersect ( gs % center , gs % basis (:, 3 ), b % origin , b % basis (:, 3 ), rc , t_p ) if ( t_p . eq . 0.0 ) return call boundary_edge ( b , bedge , nb ) p_pre = bedge (:, 1 ) in_gs = in_gyro_surface ( gs , p_pre ) ninter = 0 u = 0.d0 boundary_loop : do i = 1 , nb p_cur = bedge (:, modulo ( i , nb ) + 1 ) v0 = p_cur - p_pre call line_gyro_surface_intersect ( p_pre , v0 , gs , t_i ) do j = 1 , 2 if (( t_i ( j ). gt . 0.0 ). and .( t_i ( j ). lt . 1.0 )) then ri = p_pre + t_i ( j ) * v0 call gyro_surface_coordinates ( gs , ri , u_cur ) if ( u_cur ( 2 ). gt . 0.0 ) then in_gs = . not . in_gs ninter = ninter + 1 cross ( ninter ) = in_gs u (:, ninter ) = u_cur endif endif enddo p_pre = p_cur enddo boundary_loop if ( ninter . eq . 0 ) then if ( in_boundary ( b , rc )) then nrange = 1 gyrange (:, 1 ) = [ 0.d0 , 2 * pi ] endif return endif do i = 1 , ninter if ( cross ( i )) then th1 = u ( 1 , i ) j = modulo ( i , ninter ) + 1 th2 = u ( 1 , j ) dth = th2 - th1 nrange = nrange + 1 if ( dth . gt . 0.0 ) then gyrange (:, nrange ) = [ th1 , dth ] else gyrange (:, nrange ) = [ th2 , - dth ] endif endif !! OpenMP with multiple threads is duplicating gyro-ranges for some markers !! causing double counting and I don't know why. !! It should be very unlikely for multiple gyro-ranges to occur so for !! now I'm including this cludge to force only one gyro-range when using !! OpenMP. #ifdef _OMP if ( nrange . eq . 1 ) exit #endif enddo end subroutine gyro_range","tags":"","loc":"proc/gyro_range.html","title":"gyro_range – FIDASIM"},{"text":"public subroutine npa_gyro_range(ichan, gs, gyrange, nrange) Calculates range of gyro-angles that would hit the NPA detector Arguments Type Intent Optional Attributes Name integer, intent(in) :: ichan Index of NPA detector type( GyroSurface ), intent(in) :: gs real(kind=Float64), intent(out), dimension(2,4) :: gyrange integer, intent(out) :: nrange Calls proc~~npa_gyro_range~~CallsGraph proc~npa_gyro_range npa_gyro_range proc~approx_eq approx_eq proc~npa_gyro_range->proc~approx_eq proc~gyro_range gyro_range proc~npa_gyro_range->proc~gyro_range proc~boundary_edge boundary_edge proc~gyro_range->proc~boundary_edge proc~line_gyro_surface_intersect line_gyro_surface_intersect proc~gyro_range->proc~line_gyro_surface_intersect proc~line_plane_intersect line_plane_intersect proc~gyro_range->proc~line_plane_intersect proc~gyro_surface_coordinates gyro_surface_coordinates proc~gyro_range->proc~gyro_surface_coordinates proc~in_boundary in_boundary proc~gyro_range->proc~in_boundary proc~in_gyro_surface in_gyro_surface proc~gyro_range->proc~in_gyro_surface Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~npa_gyro_range~~CalledByGraph proc~npa_gyro_range npa_gyro_range proc~pnpa_f pnpa_f proc~pnpa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~npa_gyro_range proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~npa_gyro_range proc~npa_f npa_f proc~npa_f->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~npa_mc program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code npa_gyro_range Source Code subroutine npa_gyro_range ( ichan , gs , gyrange , nrange ) !+ Calculates range of gyro-angles that would hit the NPA detector integer , intent ( in ) :: ichan !+ Index of NPA detector type ( GyroSurface ), intent ( in ) :: gs real ( Float64 ), dimension ( 2 , 4 ), intent ( out ) :: gyrange integer , intent ( out ) :: nrange type ( LocalEMFields ) :: fields integer :: i , j , a_nrange , d_nrange real ( Float64 ) :: a0 , a , b , c , d real ( Float64 ), dimension ( 2 , 4 ) :: a_gyrange , d_gyrange nrange = 0 gyrange = 0.d0 call gyro_range ( npa_chords % det ( ichan )% aperture , gs , a_gyrange , a_nrange ) if ( a_nrange . eq . 0 ) return call gyro_range ( npa_chords % det ( ichan )% detector , gs , d_gyrange , d_nrange ) if ( d_nrange . eq . 0 ) return if (( a_nrange . eq . 1 ). and . approx_eq ( a_gyrange ( 2 , 1 ), 2 * pi , 1 d - 6 )) then gyrange = d_gyrange nrange = d_nrange return endif if (( d_nrange . eq . 1 ). and . approx_eq ( d_gyrange ( 2 , 1 ), 2 * pi , 1 d - 6 )) then gyrange = a_gyrange nrange = a_nrange return endif do i = 1 , a_nrange do j = 1 , d_nrange a0 = 0.d0 if ( d_gyrange ( 1 , j ). gt . a_gyrange ( 1 , i )) then a0 = a_gyrange ( 1 , i ) a = 0.d0 b = modulo ( a_gyrange ( 1 , i ) + a_gyrange ( 2 , i ) - a0 , 2 * pi ) c = modulo ( d_gyrange ( 1 , j ) - a0 , 2 * pi ) d = modulo ( d_gyrange ( 1 , j ) + d_gyrange ( 2 , j ) - a0 , 2 * pi ) else a0 = d_gyrange ( 1 , j ) a = 0.d0 b = modulo ( d_gyrange ( 1 , j ) + d_gyrange ( 2 , j ) - a0 , 2 * pi ) c = modulo ( a_gyrange ( 1 , i ) - a0 , 2 * pi ) d = modulo ( a_gyrange ( 1 , i ) + a_gyrange ( 2 , i ) - a0 , 2 * pi ) endif if (( c . lt . b ). or .( d . lt . c )) then if ( c . lt . d ) then nrange = nrange + 1 gyrange (:, nrange ) = [ a0 + c , min ( d - c , b - c )] else nrange = nrange + 1 gyrange (:, nrange ) = [ a0 , d ] nrange = nrange + 1 gyrange (:, nrange ) = [ a0 + c , b - c ] endif endif enddo enddo end subroutine npa_gyro_range","tags":"","loc":"proc/npa_gyro_range.html","title":"npa_gyro_range – FIDASIM"},{"text":"public subroutine hit_npa_detector(r0, v0, d_index, rd, det) Routine to check if a particle will hit a NPA detector Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Starting point of particle real(kind=Float64), intent(in), dimension(3) :: v0 Particle velocity integer, intent(out) :: d_index Index of NPA detector. Zero if particle doesn't hit real(kind=Float64), intent(out), optional dimension(3) :: rd Point where particle hit detector integer, intent(in), optional :: det Index of NPA detector to check Calls proc~~hit_npa_detector~~CallsGraph proc~hit_npa_detector hit_npa_detector proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector->proc~line_plane_intersect proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~hit_npa_detector~~CalledByGraph proc~hit_npa_detector hit_npa_detector proc~pnpa_f pnpa_f proc~pnpa_f->proc~hit_npa_detector proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~hit_npa_detector proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~hit_npa_detector proc~npa_f npa_f proc~npa_f->proc~hit_npa_detector proc~npa_mc npa_mc proc~npa_mc->proc~hit_npa_detector proc~npa_weights npa_weights proc~npa_weights->proc~hit_npa_detector program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~npa_f program~fidasim->proc~npa_mc program~fidasim->proc~npa_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code hit_npa_detector Source Code subroutine hit_npa_detector ( r0 , v0 , d_index , rd , det ) !+ Routine to check if a particle will hit a NPA detector real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Starting point of particle real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Particle velocity integer , intent ( out ) :: d_index !+ Index of NPA detector. Zero if particle doesn't hit real ( Float64 ), dimension ( 3 ), intent ( out ), optional :: rd !+ Point where particle hit detector integer , intent ( in ), optional :: det !+ Index of NPA detector to check real ( Float64 ), dimension ( 3 ) :: d , a real ( Float64 ) :: t_a , t_d integer :: i , s , ndet if ( present ( det )) then s = det ndet = det else s = 1 ndet = npa_chords % nchan endif d_index = 0 detector_loop : do i = s , ndet !! Find where trajectory crosses detector plane call line_plane_intersect ( r0 , v0 , npa_chords % det ( i )% detector % origin , & npa_chords % det ( i )% detector % basis (:, 3 ), d , t_d ) !! Find where trajectory crosses aperture plane call line_plane_intersect ( r0 , v0 , npa_chords % det ( i )% aperture % origin , & npa_chords % det ( i )% aperture % basis (:, 3 ), a , t_a ) !! If both points are in plane boundaries and the !! particle is heading toward the detector then its a hit if ( in_boundary ( npa_chords % det ( i )% aperture , a ) . and . & in_boundary ( npa_chords % det ( i )% detector , d ) . and . & ( t_d . gt . 0.0 ) ) then d_index = i exit detector_loop endif enddo detector_loop if ( present ( rd )) rd = d end subroutine hit_npa_detector","tags":"","loc":"proc/hit_npa_detector.html","title":"hit_npa_detector – FIDASIM"},{"text":"public subroutine xyz_to_uvw(xyz, uvw) Convert beam coordinate xyz to machine coordinate uvw Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: xyz real(kind=Float64), intent(out), dimension(3) :: uvw Called by proc~~xyz_to_uvw~~CalledByGraph proc~xyz_to_uvw xyz_to_uvw proc~get_fields get_fields proc~get_fields->proc~xyz_to_uvw proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~write_birth_profile write_birth_profile proc~write_birth_profile->proc~xyz_to_uvw proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~store_npa store_npa proc~store_npa->proc~xyz_to_uvw proc~store_npa->proc~get_fields proc~write_beam_grid->proc~xyz_to_uvw proc~get_plasma get_plasma proc~get_plasma->proc~xyz_to_uvw proc~get_plasma->proc~in_plasma proc~in_plasma->proc~xyz_to_uvw proc~xyz_to_cyl xyz_to_cyl proc~xyz_to_cyl->proc~xyz_to_uvw proc~get_ep_denf get_ep_denf proc~get_ep_denf->proc~xyz_to_uvw proc~get_distribution get_distribution proc~get_distribution->proc~xyz_to_uvw proc~pnpa_f pnpa_f proc~pnpa_f->proc~store_npa proc~pnpa_f->proc~get_plasma proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~pnpa_f->proc~mc_fastion_pass_grid proc~attenuate attenuate proc~pnpa_f->proc~attenuate proc~dcx_spec dcx_spec proc~dcx_spec->proc~get_plasma proc~dcx_spec->proc~in_plasma proc~store_photons store_photons proc~dcx_spec->proc~store_photons proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~mc_fastion_pass_grid->proc~get_fields proc~mc_fastion_pass_grid->proc~get_distribution proc~attenuate->proc~get_plasma proc~ndmc ndmc proc~ndmc->proc~get_fields proc~track track proc~ndmc->proc~track proc~mc_nbi mc_nbi proc~ndmc->proc~mc_nbi proc~pfida_f pfida_f proc~pfida_f->proc~get_plasma proc~pfida_f->proc~mc_fastion_pass_grid proc~track_cylindrical track_cylindrical proc~pfida_f->proc~track_cylindrical proc~track->proc~get_fields proc~track->proc~in_plasma proc~nbi_spec nbi_spec proc~nbi_spec->proc~in_plasma proc~nbi_spec->proc~store_photons program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~bremsstrahlung program~fidasim->proc~ndmc program~fidasim->proc~pfida_f program~fidasim->proc~nbi_spec proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~write_neutrals write_neutrals program~fidasim->proc~write_neutrals proc~make_beam_grid make_beam_grid program~fidasim->proc~make_beam_grid proc~pnpa_mc pnpa_mc program~fidasim->proc~pnpa_mc proc~halo halo program~fidasim->proc~halo proc~pfida_mc pfida_mc program~fidasim->proc~pfida_mc proc~dcx dcx program~fidasim->proc~dcx proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~fida_f fida_f program~fidasim->proc~fida_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~halo_spec halo_spec program~fidasim->proc~halo_spec proc~make_diagnostic_grids make_diagnostic_grids program~fidasim->proc~make_diagnostic_grids proc~cold_spec cold_spec program~fidasim->proc~cold_spec proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~npa_weights->proc~get_fields proc~npa_weights->proc~attenuate proc~get_beam_cx_rate get_beam_cx_rate proc~npa_weights->proc~get_beam_cx_rate proc~write_npa_weights write_npa_weights proc~npa_weights->proc~write_npa_weights proc~fida_mc->proc~get_fields proc~fida_mc->proc~track proc~write_neutrals->proc~write_beam_grid proc~make_beam_grid->proc~in_plasma proc~store_photons->proc~get_fields proc~track_cylindrical->proc~get_fields proc~track_cylindrical->proc~in_plasma proc~pnpa_mc->proc~get_fields proc~pnpa_mc->proc~store_npa proc~pnpa_mc->proc~get_plasma proc~pnpa_mc->proc~attenuate proc~halo->proc~get_plasma proc~halo->proc~track proc~mc_halo mc_halo proc~halo->proc~mc_halo proc~pfida_mc->proc~get_fields proc~pfida_mc->proc~get_plasma proc~pfida_mc->proc~track_cylindrical proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~in_plasma proc~fida_weights_los->proc~track proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~neutron_mc->proc~get_fields proc~neutron_mc->proc~get_plasma proc~mc_halo->proc~get_plasma proc~npa_f->proc~store_npa proc~npa_f->proc~get_plasma proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_rate proc~npa_f->proc~mc_fastion proc~npa_mc->proc~get_fields proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_rate proc~get_beam_cx_rate->proc~get_plasma proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~track proc~mc_nbi->proc~in_plasma proc~halo_spec->proc~get_plasma proc~halo_spec->proc~in_plasma proc~halo_spec->proc~store_photons proc~write_npa_weights->proc~write_beam_grid proc~make_diagnostic_grids->proc~get_fields proc~make_diagnostic_grids->proc~track proc~make_diagnostic_grids->proc~track_cylindrical proc~make_passive_grid make_passive_grid proc~make_diagnostic_grids->proc~make_passive_grid proc~cold_spec->proc~get_plasma proc~cold_spec->proc~store_photons proc~get_plasma_extrema get_plasma_extrema proc~get_plasma_extrema->proc~in_plasma proc~neutron_f->proc~get_fields proc~neutron_f->proc~get_plasma proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~make_passive_grid->proc~get_plasma_extrema proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons proc~read_distribution->proc~read_mc var panprocxyz_to_uvwCalledByGraph = svgPanZoom('#procxyz_to_uvwCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code xyz_to_uvw Source Code subroutine xyz_to_uvw ( xyz , uvw ) !+ Convert beam coordinate `xyz` to machine coordinate `uvw` real ( Float64 ), dimension ( 3 ), intent ( in ) :: xyz real ( Float64 ), dimension ( 3 ), intent ( out ) :: uvw real ( Float64 ), dimension ( 3 ) :: origin real ( Float64 ), dimension ( 3 , 3 ) :: basis origin = beam_grid % origin basis = beam_grid % basis uvw = matmul ( basis , xyz ) uvw = uvw + origin end subroutine xyz_to_uvw","tags":"","loc":"proc/xyz_to_uvw.html","title":"xyz_to_uvw – FIDASIM"},{"text":"public subroutine xyz_to_cyl(xyz, cyl) Convert beam coordinate xyz to cylindrical coordinate cyl Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: xyz real(kind=Float64), intent(out), dimension(3) :: cyl Calls proc~~xyz_to_cyl~~CallsGraph proc~xyz_to_cyl xyz_to_cyl proc~uvw_to_cyl uvw_to_cyl proc~xyz_to_cyl->proc~uvw_to_cyl proc~xyz_to_uvw xyz_to_uvw proc~xyz_to_cyl->proc~xyz_to_uvw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code xyz_to_cyl Source Code subroutine xyz_to_cyl ( xyz , cyl ) !+ Convert beam coordinate `xyz` to cylindrical coordinate `cyl` real ( Float64 ), dimension ( 3 ), intent ( in ) :: xyz real ( Float64 ), dimension ( 3 ), intent ( out ) :: cyl real ( Float64 ), dimension ( 3 ) :: uvw call xyz_to_uvw ( xyz , uvw ) call uvw_to_cyl ( uvw , cyl ) end subroutine xyz_to_cyl","tags":"","loc":"proc/xyz_to_cyl.html","title":"xyz_to_cyl – FIDASIM"},{"text":"public subroutine uvw_to_xyz(uvw, xyz) Convert machine coordinate uvw to beam coordinate xyz Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: uvw real(kind=Float64), intent(out), dimension(3) :: xyz Called by proc~~uvw_to_xyz~~CalledByGraph proc~uvw_to_xyz uvw_to_xyz proc~get_fields get_fields proc~get_fields->proc~uvw_to_xyz proc~store_photons store_photons proc~store_photons->proc~uvw_to_xyz proc~store_photons->proc~get_fields proc~cyl_to_xyz cyl_to_xyz proc~cyl_to_xyz->proc~uvw_to_xyz proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~uvw_to_xyz proc~pnpa_mc->proc~get_fields proc~get_plasma get_plasma proc~pnpa_mc->proc~get_plasma proc~store_npa store_npa proc~pnpa_mc->proc~store_npa proc~attenuate attenuate proc~pnpa_mc->proc~attenuate proc~npa_mc npa_mc proc~npa_mc->proc~uvw_to_xyz proc~npa_mc->proc~get_fields proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~get_beam_cx_rate get_beam_cx_rate proc~npa_mc->proc~get_beam_cx_rate proc~get_plasma->proc~uvw_to_xyz proc~get_position get_position proc~get_plasma->proc~get_position proc~read_beam read_beam proc~read_beam->proc~uvw_to_xyz proc~read_mc read_mc proc~read_mc->proc~uvw_to_xyz proc~fida_mc fida_mc proc~fida_mc->proc~uvw_to_xyz proc~fida_mc->proc~get_fields proc~track track proc~fida_mc->proc~track proc~pnpa_f pnpa_f proc~pnpa_f->proc~get_plasma proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~pnpa_f->proc~mc_fastion_pass_grid proc~pnpa_f->proc~store_npa proc~pnpa_f->proc~attenuate proc~dcx_spec dcx_spec proc~dcx_spec->proc~store_photons proc~dcx_spec->proc~get_plasma proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~mc_fastion_pass_grid->proc~get_fields proc~ndmc ndmc proc~ndmc->proc~get_fields proc~ndmc->proc~track proc~pfida_f pfida_f proc~pfida_f->proc~get_plasma proc~pfida_f->proc~mc_fastion_pass_grid proc~track_cylindrical track_cylindrical proc~pfida_f->proc~track_cylindrical proc~track->proc~get_fields proc~nbi_spec nbi_spec proc~nbi_spec->proc~store_photons program~fidasim fidasim program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_mc program~fidasim->proc~fida_mc program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~bremsstrahlung program~fidasim->proc~ndmc program~fidasim->proc~pfida_f program~fidasim->proc~nbi_spec proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~halo halo program~fidasim->proc~halo proc~pfida_mc pfida_mc program~fidasim->proc~pfida_mc proc~dcx dcx program~fidasim->proc~dcx proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~fida_f fida_f program~fidasim->proc~fida_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~halo_spec halo_spec program~fidasim->proc~halo_spec proc~make_diagnostic_grids make_diagnostic_grids program~fidasim->proc~make_diagnostic_grids proc~cold_spec cold_spec program~fidasim->proc~cold_spec proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~npa_weights->proc~get_fields proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_rate proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons proc~read_distribution->proc~read_mc proc~mc_halo mc_halo proc~mc_halo->proc~get_plasma proc~track_cylindrical->proc~get_fields proc~get_position->proc~cyl_to_xyz proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~pfida_mc->proc~get_fields proc~pfida_mc->proc~get_plasma proc~pfida_mc->proc~track_cylindrical proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~store_npa->proc~get_fields proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~track proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~neutron_mc->proc~get_fields proc~neutron_mc->proc~get_plasma proc~npa_f->proc~get_plasma proc~npa_f->proc~store_npa proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_rate proc~npa_f->proc~mc_fastion proc~attenuate->proc~get_plasma proc~get_beam_cx_rate->proc~get_plasma proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~halo_spec->proc~store_photons proc~halo_spec->proc~get_plasma proc~make_diagnostic_grids->proc~get_fields proc~make_diagnostic_grids->proc~track proc~make_diagnostic_grids->proc~track_cylindrical proc~cold_spec->proc~store_photons proc~cold_spec->proc~get_plasma proc~neutron_f->proc~get_fields proc~neutron_f->proc~get_plasma proc~mc_fastion->proc~get_fields var panprocuvw_to_xyzCalledByGraph = svgPanZoom('#procuvw_to_xyzCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code uvw_to_xyz Source Code subroutine uvw_to_xyz ( uvw , xyz ) !+ Convert machine coordinate `uvw` to beam coordinate `xyz` real ( Float64 ), dimension ( 3 ), intent ( in ) :: uvw real ( Float64 ), dimension ( 3 ), intent ( out ) :: xyz real ( Float64 ), dimension ( 3 ) :: origin , uvw_p real ( Float64 ), dimension ( 3 , 3 ) :: basis origin = beam_grid % origin basis = beam_grid % inv_basis uvw_p = uvw - origin xyz = matmul ( basis , uvw_p ) end subroutine uvw_to_xyz","tags":"","loc":"proc/uvw_to_xyz.html","title":"uvw_to_xyz – FIDASIM"},{"text":"public subroutine cyl_to_uvw(cyl, uvw) Convert cylindrical coordinate cyl to machine coordinate uvw Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: cyl real(kind=Float64), intent(out), dimension(3) :: uvw Called by proc~~cyl_to_uvw~~CalledByGraph proc~cyl_to_uvw cyl_to_uvw proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~cyl_to_uvw proc~in_plasma in_plasma proc~track_cylindrical->proc~in_plasma proc~get_fields get_fields proc~track_cylindrical->proc~get_fields proc~cyl_to_xyz cyl_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~mc_fastion_pass_grid->proc~cyl_to_uvw proc~mc_fastion_pass_grid->proc~get_fields proc~get_fields->proc~in_plasma proc~make_beam_grid make_beam_grid proc~make_beam_grid->proc~in_plasma proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~in_plasma proc~fida_weights_los->proc~get_fields proc~get_plasma get_plasma proc~fida_weights_los->proc~get_plasma proc~track track proc~fida_weights_los->proc~track proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~get_plasma->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~dcx_spec dcx_spec proc~dcx_spec->proc~in_plasma proc~dcx_spec->proc~get_plasma proc~store_photons store_photons proc~dcx_spec->proc~store_photons proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~track_cylindrical proc~make_diagnostic_grids->proc~get_fields proc~make_diagnostic_grids->proc~track proc~make_passive_grid make_passive_grid proc~make_diagnostic_grids->proc~make_passive_grid proc~track->proc~in_plasma proc~track->proc~get_fields proc~get_position->proc~cyl_to_xyz proc~nbi_spec nbi_spec proc~nbi_spec->proc~in_plasma proc~nbi_spec->proc~store_photons proc~get_plasma_extrema get_plasma_extrema proc~get_plasma_extrema->proc~in_plasma proc~pfida_mc pfida_mc proc~pfida_mc->proc~track_cylindrical proc~pfida_mc->proc~get_fields proc~pfida_mc->proc~get_plasma proc~pfida_f pfida_f proc~pfida_f->proc~track_cylindrical proc~pfida_f->proc~mc_fastion_pass_grid proc~pfida_f->proc~get_plasma proc~halo_spec halo_spec proc~halo_spec->proc~in_plasma proc~halo_spec->proc~get_plasma proc~halo_spec->proc~store_photons proc~pnpa_f pnpa_f proc~pnpa_f->proc~mc_fastion_pass_grid proc~pnpa_f->proc~get_plasma proc~store_npa store_npa proc~pnpa_f->proc~store_npa proc~attenuate attenuate proc~pnpa_f->proc~attenuate proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~read_distribution read_distribution proc~read_distribution->proc~read_mc proc~npa_mc npa_mc proc~npa_mc->proc~get_fields proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~get_beam_cx_rate get_beam_cx_rate proc~npa_mc->proc~get_beam_cx_rate proc~ndmc ndmc proc~ndmc->proc~get_fields proc~ndmc->proc~mc_nbi proc~ndmc->proc~track program~fidasim fidasim program~fidasim->proc~make_beam_grid program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx_spec program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~nbi_spec program~fidasim->proc~pfida_mc program~fidasim->proc~pfida_f program~fidasim->proc~halo_spec program~fidasim->proc~pnpa_f program~fidasim->proc~bremsstrahlung program~fidasim->proc~read_distribution program~fidasim->proc~npa_mc program~fidasim->proc~ndmc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~pnpa_mc pnpa_mc program~fidasim->proc~pnpa_mc proc~halo halo program~fidasim->proc~halo proc~dcx dcx program~fidasim->proc~dcx proc~fida_f fida_f program~fidasim->proc~fida_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~cold_spec cold_spec program~fidasim->proc~cold_spec proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~npa_weights->proc~get_fields proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_rate proc~fida_mc->proc~get_fields proc~fida_mc->proc~track proc~mc_halo mc_halo proc~mc_halo->proc~get_plasma proc~pnpa_mc->proc~get_fields proc~pnpa_mc->proc~get_plasma proc~pnpa_mc->proc~store_npa proc~pnpa_mc->proc~attenuate proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~store_npa->proc~get_fields proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~neutron_mc->proc~get_fields proc~neutron_mc->proc~get_plasma proc~store_photons->proc~get_fields proc~npa_f->proc~get_plasma proc~npa_f->proc~store_npa proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_rate proc~npa_f->proc~mc_fastion proc~attenuate->proc~get_plasma proc~get_beam_cx_rate->proc~get_plasma proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~cold_spec->proc~get_plasma proc~cold_spec->proc~store_photons proc~neutron_f->proc~get_fields proc~neutron_f->proc~get_plasma proc~make_passive_grid->proc~get_plasma_extrema proc~mc_fastion->proc~get_fields proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons var panproccyl_to_uvwCalledByGraph = svgPanZoom('#proccyl_to_uvwCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code cyl_to_uvw Source Code subroutine cyl_to_uvw ( cyl , uvw ) !+ Convert cylindrical coordinate `cyl` to machine coordinate `uvw` real ( Float64 ), dimension ( 3 ), intent ( in ) :: cyl real ( Float64 ), dimension ( 3 ), intent ( out ) :: uvw uvw ( 1 ) = cyl ( 1 ) * cos ( cyl ( 3 )) uvw ( 2 ) = cyl ( 1 ) * sin ( cyl ( 3 )) uvw ( 3 ) = cyl ( 2 ) end subroutine cyl_to_uvw","tags":"","loc":"proc/cyl_to_uvw.html","title":"cyl_to_uvw – FIDASIM"},{"text":"public subroutine cyl_to_xyz(cyl, xyz) Convert cylindrical coordinate cyl to beam coordinate xyz Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: cyl real(kind=Float64), intent(out), dimension(3) :: xyz Calls proc~~cyl_to_xyz~~CallsGraph proc~cyl_to_xyz cyl_to_xyz proc~uvw_to_xyz uvw_to_xyz proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_uvw cyl_to_uvw proc~cyl_to_xyz->proc~cyl_to_uvw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~cyl_to_xyz~~CalledByGraph proc~cyl_to_xyz cyl_to_xyz proc~get_position get_position proc~get_position->proc~cyl_to_xyz proc~get_plasma get_plasma proc~get_plasma->proc~get_position proc~pnpa_f pnpa_f proc~pnpa_f->proc~get_plasma proc~attenuate attenuate proc~pnpa_f->proc~attenuate proc~dcx_spec dcx_spec proc~dcx_spec->proc~get_plasma proc~dcx dcx proc~dcx->proc~get_plasma proc~mc_halo mc_halo proc~dcx->proc~mc_halo proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_plasma proc~pfida_mc pfida_mc proc~pfida_mc->proc~get_plasma proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~get_plasma proc~pnpa_mc->proc~attenuate proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_plasma proc~mc_halo->proc~get_plasma proc~npa_f npa_f proc~npa_f->proc~get_plasma proc~npa_f->proc~attenuate proc~get_beam_cx_rate get_beam_cx_rate proc~npa_f->proc~get_beam_cx_rate proc~cold_spec cold_spec proc~cold_spec->proc~get_plasma proc~pfida_f pfida_f proc~pfida_f->proc~get_plasma proc~attenuate->proc~get_plasma proc~neutron_f neutron_f proc~neutron_f->proc~get_plasma proc~get_beam_cx_rate->proc~get_plasma proc~halo_spec halo_spec proc~halo_spec->proc~get_plasma proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~mc_halo proc~npa_weights npa_weights proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_rate program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~dcx program~fidasim->proc~bremsstrahlung program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~pfida_mc program~fidasim->proc~pnpa_mc program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~npa_f program~fidasim->proc~cold_spec program~fidasim->proc~pfida_f program~fidasim->proc~neutron_f program~fidasim->proc~halo_spec program~fidasim->proc~halo program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_rate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code cyl_to_xyz Source Code subroutine cyl_to_xyz ( cyl , xyz ) !+ Convert cylindrical coordinate `cyl` to beam coordinate `xyz` real ( Float64 ), dimension ( 3 ), intent ( in ) :: cyl real ( Float64 ), dimension ( 3 ), intent ( out ) :: xyz real ( Float64 ), dimension ( 3 ) :: uvw call cyl_to_uvw ( cyl , uvw ) call uvw_to_xyz ( uvw , xyz ) end subroutine cyl_to_xyz","tags":"","loc":"proc/cyl_to_xyz.html","title":"cyl_to_xyz – FIDASIM"},{"text":"public subroutine uvw_to_cyl(uvw, cyl) Convert machine coordinate uvw to cylindrical coordinate cyl Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: uvw real(kind=Float64), intent(out), dimension(3) :: cyl Called by proc~~uvw_to_cyl~~CalledByGraph proc~uvw_to_cyl uvw_to_cyl proc~in_passive_grid in_passive_grid proc~in_passive_grid->proc~uvw_to_cyl proc~xyz_to_cyl xyz_to_cyl proc~xyz_to_cyl->proc~uvw_to_cyl proc~grid_intersect grid_intersect proc~grid_intersect->proc~in_passive_grid proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~grid_intersect proc~circle_grid_intersect circle_grid_intersect proc~circle_grid_intersect->proc~grid_intersect proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~grid_intersect proc~mc_nbi mc_nbi proc~mc_nbi->proc~grid_intersect proc~read_mc read_mc proc~read_mc->proc~circle_grid_intersect proc~ndmc ndmc proc~ndmc->proc~mc_nbi program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~ndmc proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~read_distribution->proc~read_mc var panprocuvw_to_cylCalledByGraph = svgPanZoom('#procuvw_to_cylCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code uvw_to_cyl Source Code subroutine uvw_to_cyl ( uvw , cyl ) !+ Convert machine coordinate `uvw` to cylindrical coordinate `cyl` real ( Float64 ), dimension ( 3 ), intent ( in ) :: uvw real ( Float64 ), dimension ( 3 ), intent ( out ) :: cyl cyl ( 1 ) = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) cyl ( 2 ) = uvw ( 3 ) cyl ( 3 ) = atan2 ( uvw ( 2 ), uvw ( 1 )) end subroutine uvw_to_cyl","tags":"","loc":"proc/uvw_to_cyl.html","title":"uvw_to_cyl – FIDASIM"},{"text":"public subroutine grid_intersect(r0, v0, length, r_enter, r_exit, center_in, lwh_in, passive) Calculates a particles intersection length with the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Initial position of particle [cm] real(kind=Float64), intent(in), dimension(3) :: v0 Velocity of particle [cm/s] real(kind=Float64), intent(out) :: length Intersection length [cm] real(kind=Float64), intent(out), dimension(3) :: r_enter Point where particle enters real(kind=Float64), intent(out), dimension(3) :: r_exit Point where particle exits real(kind=Float64), intent(in), optional dimension(3) :: center_in Alternative grid center real(kind=Float64), intent(in), optional dimension(3) :: lwh_in Alternative grid [length,width,height] logical, intent(in), optional :: passive Calculates a particles intersection length with the pass_grid Calls proc~~grid_intersect~~CallsGraph proc~grid_intersect grid_intersect proc~in_passive_grid in_passive_grid proc~grid_intersect->proc~in_passive_grid proc~uvw_to_cyl uvw_to_cyl proc~in_passive_grid->proc~uvw_to_cyl proc~approx_le approx_le proc~in_passive_grid->proc~approx_le proc~approx_ge approx_ge proc~in_passive_grid->proc~approx_ge proc~approx_eq approx_eq proc~approx_le->proc~approx_eq proc~approx_ge->proc~approx_eq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~grid_intersect~~CalledByGraph proc~grid_intersect grid_intersect proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~grid_intersect proc~circle_grid_intersect circle_grid_intersect proc~circle_grid_intersect->proc~grid_intersect proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~grid_intersect proc~mc_nbi mc_nbi proc~mc_nbi->proc~grid_intersect proc~read_mc read_mc proc~read_mc->proc~circle_grid_intersect proc~ndmc ndmc proc~ndmc->proc~mc_nbi program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~ndmc proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~read_distribution->proc~read_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code grid_intersect Source Code subroutine grid_intersect ( r0 , v0 , length , r_enter , r_exit , center_in , lwh_in , passive ) !+ Calculates a particles intersection length with the [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Initial position of particle [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Velocity of particle [cm/s] real ( Float64 ), intent ( out ) :: length !+ Intersection length [cm] real ( Float64 ), dimension ( 3 ), intent ( out ) :: r_enter !+ Point where particle enters real ( Float64 ), dimension ( 3 ), intent ( out ) :: r_exit !+ Point where particle exits real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: center_in !+ Alternative grid center real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: lwh_in !+ Alternative grid [length,width,height] logical , intent ( in ), optional :: passive !+ Calculates a particles intersection length with the [[libfida:pass_grid]] real ( Float64 ), dimension ( 3 , 6 ) :: ipnts real ( Float64 ), dimension ( 3 ) :: ri , vi real ( Float64 ), dimension ( 3 ) :: center real ( Float64 ), dimension ( 3 ) :: lwh integer , dimension ( 6 ) :: side_inter integer , dimension ( 2 ) :: ind integer :: i , j , nunique , ind1 , ind2 real ( Float64 ) :: dlength , max_length logical :: ing , pas pas = . False . if ( present ( passive )) pas = passive if ( pas ) then ing = in_passive_grid ( r0 ) if ( ing ) then length = 0.d0 return endif ri = r0 ; vi = v0 dlength = 2.0 !cm max_length = 0.0 do while (. not . ing ) ri = ri + vi * dlength ! move dlength ing = in_passive_grid ( ri ) max_length = max_length + dlength if ( max_length . gt . 1 d3 ) then length = 0.d0 return endif enddo r_enter = ri do while ( ing ) ri = ri + vi * dlength ing = in_passive_grid ( ri ) enddo r_exit = ri length = sqrt ( sum (( r_exit - r_enter ) ** 2 )) else if ( present ( center_in )) then center = center_in else center = beam_grid % center endif if ( present ( lwh_in )) then lwh = lwh_in else lwh = beam_grid % lwh endif side_inter = 0 ipnts = 0.d0 do i = 1 , 6 j = int ( ceiling ( i / 2.0 )) if ( j . eq . 1 ) ind = [ 2 , 3 ] if ( j . eq . 2 ) ind = [ 1 , 3 ] if ( j . eq . 3 ) ind = [ 1 , 2 ] if ( abs ( v0 ( j )). gt . 0.d0 ) then ipnts (:, i ) = r0 + v0 * ( ( ( center ( j ) + & ( mod ( i , 2 ) - 0.5 ) * lwh ( j )) - r0 ( j )) / v0 ( j ) ) if (( abs ( ipnts ( ind ( 1 ), i ) - center ( ind ( 1 ))). le .( 0.5 * lwh ( ind ( 1 )))). and . & ( abs ( ipnts ( ind ( 2 ), i ) - center ( ind ( 2 ))). le .( 0.5 * lwh ( ind ( 2 ))))) then side_inter ( i ) = 1 endif endif enddo length = 0.d0 r_enter = r0 r_exit = r0 ind1 = 0 ind2 = 0 if ( sum ( side_inter ). ge . 2 ) then ! Find first intersection side i = 1 do while ( i . le . 6 ) if ( side_inter ( i ). eq . 1 ) exit i = i + 1 enddo ind1 = i !Find number of unique points nunique = 0 do i = ind1 + 1 , 6 if ( side_inter ( i ). ne . 1 ) cycle if ( sqrt ( sum ( ( ipnts (:, i ) - ipnts (:, ind1 ) ) ** 2 ) ). gt . 0.001 ) then ind2 = i nunique = 2 exit endif enddo if ( nunique . eq . 2 ) then vi = ipnts (:, ind2 ) - ipnts (:, ind1 ) if ( dot_product ( v0 , vi ). gt . 0.0 ) then r_enter = ipnts (:, ind1 ) r_exit = ipnts (:, ind2 ) else r_enter = ipnts (:, ind2 ) r_exit = ipnts (:, ind1 ) endif length = sqrt ( sum (( r_exit - r_enter ) ** 2 )) endif endif endif end subroutine grid_intersect","tags":"","loc":"proc/grid_intersect.html","title":"grid_intersect – FIDASIM"},{"text":"public subroutine circle_grid_intersect(r0, e1, e2, radius, beam_grid_phi_enter, beam_grid_phi_exit) Calculates the intersection arclength of a circle with the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Position of center enter of the circle in beam grid coordinates [cm] real(kind=Float64), intent(in), dimension(3) :: e1 Unit vector pointing towards (R, 0) (r,phi) position of the circle in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: e2 Unit vector pointing towards (R, pi/2) (r,phi) position of the circle in beam grid coordinates real(kind=Float64), intent(in) :: radius Radius of circle [cm] real(kind=Float64), intent(out) :: beam_grid_phi_enter Phi value where the circle entered the beam_grid [rad] real(kind=Float64), intent(out) :: beam_grid_phi_exit Phi value where the circle exits the beam_grid [rad] Calls proc~~circle_grid_intersect~~CallsGraph proc~circle_grid_intersect circle_grid_intersect proc~approx_eq approx_eq proc~circle_grid_intersect->proc~approx_eq proc~in_grid in_grid proc~circle_grid_intersect->proc~in_grid proc~grid_intersect grid_intersect proc~circle_grid_intersect->proc~grid_intersect proc~approx_le approx_le proc~in_grid->proc~approx_le proc~approx_ge approx_ge proc~in_grid->proc~approx_ge proc~in_passive_grid in_passive_grid proc~grid_intersect->proc~in_passive_grid proc~in_passive_grid->proc~approx_le proc~in_passive_grid->proc~approx_ge proc~uvw_to_cyl uvw_to_cyl proc~in_passive_grid->proc~uvw_to_cyl proc~approx_le->proc~approx_eq proc~approx_ge->proc~approx_eq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~circle_grid_intersect~~CalledByGraph proc~circle_grid_intersect circle_grid_intersect proc~read_mc read_mc proc~read_mc->proc~circle_grid_intersect proc~read_distribution read_distribution proc~read_distribution->proc~read_mc program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code circle_grid_intersect Source Code subroutine circle_grid_intersect ( r0 , e1 , e2 , radius , beam_grid_phi_enter , beam_grid_phi_exit ) !+ Calculates the intersection arclength of a circle with the [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Position of center enter of the circle in beam grid coordinates [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: e1 !+ Unit vector pointing towards (R, 0) (r,phi) position of the circle in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: e2 !+ Unit vector pointing towards (R, pi/2) (r,phi) position of the circle in beam grid coordinates real ( Float64 ), intent ( in ) :: radius !+ Radius of circle [cm] real ( Float64 ), intent ( out ) :: beam_grid_phi_enter !+ Phi value where the circle entered the [[libfida:beam_grid]] [rad] real ( Float64 ), intent ( out ) :: beam_grid_phi_exit !+ Phi value where the circle exits the [[libfida:beam_grid]] [rad] real ( Float64 ), dimension ( 3 ) :: i1_p , i1_n , i2_p , i2_n real ( Float64 ), dimension ( 4 ) :: d real ( Float64 ), dimension ( 6 ) :: p , gams real ( Float64 ), dimension ( 4 , 6 ) :: phi logical , dimension ( 4 , 6 ) :: inter integer , dimension ( 6 ) :: n integer :: i real ( Float64 ) :: alpha , beta , delta , sinx1 , cosx1 , sinx2 , cosx2 , tmp real ( Float64 ) :: tol = 1.0d-10 logical :: r0_ing p = [ beam_grid % xmin , beam_grid % xmax , & beam_grid % ymin , beam_grid % ymax , & beam_grid % zmin , beam_grid % zmax ] n = [ 1 , 1 , 2 , 2 , 3 , 3 ] inter = . False . phi = 0.d0 r0_ing = in_grid ( r0 ) do i = 1 , 6 alpha = e2 ( n ( i )) beta = e1 ( n ( i )) if (( alpha . eq . 0.0 ). and .( beta . eq . 0.0 )) cycle gams ( i ) = ( p ( i ) - r0 ( n ( i ))) / radius delta = alpha ** 4 + ( alpha ** 2 ) * ( beta ** 2 - gams ( i ) ** 2 ) if ( delta . ge . 0.0 ) then cosx1 = ( gams ( i ) * beta + sqrt ( delta )) / ( alpha ** 2 + beta ** 2 ) if (( cosx1 ** 2 ). le . 1.0 ) then sinx1 = sqrt ( 1 - cosx1 ** 2 ) i1_p = r0 + radius * cosx1 * e1 + radius * sinx1 * e2 i1_n = r0 + radius * cosx1 * e1 - radius * sinx1 * e2 if ( approx_eq ( i1_p ( n ( i )), p ( i ), tol ). and . in_grid ( i1_p )) then inter ( 1 , i ) = . True . phi ( 1 , i ) = atan2 ( sinx1 , cosx1 ) endif if ( approx_eq ( i1_n ( n ( i )), p ( i ), tol ). and . in_grid ( i1_n )) then inter ( 2 , i ) = . True . phi ( 2 , i ) = atan2 ( - sinx1 , cosx1 ) endif endif if ( delta . gt . 0.0 ) then cosx2 = ( gams ( i ) * beta - sqrt ( delta )) / ( alpha ** 2 + beta ** 2 ) if (( cosx2 ** 2 ). le . 1.0 ) then sinx2 = sqrt ( 1 - cosx2 ** 2 ) i2_p = r0 + radius * cosx2 * e1 + radius * sinx2 * e2 i2_n = r0 + radius * cosx2 * e1 - radius * sinx2 * e2 if ( approx_eq ( i2_p ( n ( i )), p ( i ), tol ). and . in_grid ( i2_p )) then inter ( 3 , i ) = . True . phi ( 3 , i ) = atan2 ( sinx2 , cosx2 ) endif if ( approx_eq ( i2_n ( n ( i )), p ( i ), tol ). and . in_grid ( i2_n )) then inter ( 4 , i ) = . True . phi ( 4 , i ) = atan2 ( - sinx2 , cosx2 ) endif endif endif endif enddo beam_grid_phi_enter = 0.d0 beam_grid_phi_exit = 0.d0 if ( count ( inter ). gt . 2 ) then write ( * , '(\"CIRCLE_GRID_INTERSECT: Circle intersects grid more than 2 times: \",i2)' ) count ( inter ) return endif if ( any ( inter )) then beam_grid_phi_enter = minval ( phi , inter ) beam_grid_phi_exit = maxval ( phi , inter ) if ( r0_ing . and . any ( count ( inter , 1 ). ge . 2 )) then if (( beam_grid_phi_exit - beam_grid_phi_enter ) . lt . pi ) then tmp = beam_grid_phi_enter beam_grid_phi_enter = beam_grid_phi_exit beam_grid_phi_exit = tmp + 2 * pi endif else if (( beam_grid_phi_exit - beam_grid_phi_enter ) . gt . pi ) then tmp = beam_grid_phi_enter beam_grid_phi_enter = beam_grid_phi_exit beam_grid_phi_exit = tmp + 2 * pi endif endif if ( approx_eq ( beam_grid_phi_exit - beam_grid_phi_enter , pi , tol ). and . r0_ing ) then beam_grid_phi_enter = 0.0 beam_grid_phi_exit = 2 * pi endif else if ( r0_ing ) then call grid_intersect ( r0 , e1 , tmp , i1_n , i1_p ) call grid_intersect ( r0 , e2 , tmp , i2_n , i2_p ) d ( 1 ) = norm2 ( r0 - i1_n ) / radius d ( 2 ) = norm2 ( r0 - i1_p ) / radius d ( 3 ) = norm2 ( r0 - i2_n ) / radius d ( 4 ) = norm2 ( r0 - i2_p ) / radius if ( all ( d . ge . 1.0 )) then beam_grid_phi_enter = 0.d0 beam_grid_phi_exit = 2.d0 * pi endif endif endif end subroutine circle_grid_intersect","tags":"","loc":"proc/circle_grid_intersect.html","title":"circle_grid_intersect – FIDASIM"},{"text":"public subroutine get_indices(pos, ind) Find closests beam_grid indices ind to position pos Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position [cm] integer(kind=Int32), intent(out), dimension(3) :: ind Closest indices to position Called by proc~~get_indices~~CalledByGraph proc~get_indices get_indices proc~track track proc~track->proc~get_indices proc~store_photons store_photons proc~store_photons->proc~get_indices proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_indices proc~npa_f npa_f proc~npa_f->proc~get_indices proc~npa_mc npa_mc proc~npa_mc->proc~get_indices proc~dcx_spec dcx_spec proc~dcx_spec->proc~store_photons proc~dcx dcx proc~dcx->proc~track proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~track proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~track proc~cold_spec cold_spec proc~cold_spec->proc~store_photons proc~ndmc ndmc proc~ndmc->proc~track proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~track proc~fida_f fida_f proc~fida_f->proc~track proc~halo_spec halo_spec proc~halo_spec->proc~store_photons proc~nbi_spec nbi_spec proc~nbi_spec->proc~store_photons proc~halo halo proc~halo->proc~track program~fidasim fidasim program~fidasim->proc~npa_f program~fidasim->proc~npa_mc program~fidasim->proc~dcx_spec program~fidasim->proc~dcx program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~cold_spec program~fidasim->proc~ndmc program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~fida_f program~fidasim->proc~halo_spec program~fidasim->proc~nbi_spec program~fidasim->proc~halo proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons proc~fida_mc->proc~track Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_indices Source Code subroutine get_indices ( pos , ind ) !+ Find closests [[libfida:beam_grid]] indices `ind` to position `pos` real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position [cm] integer ( Int32 ), dimension ( 3 ), intent ( out ) :: ind !+ Closest indices to position real ( Float64 ), dimension ( 3 ) :: mini integer ( Int32 ), dimension ( 3 ) :: maxind integer :: i maxind ( 1 ) = beam_grid % nx maxind ( 2 ) = beam_grid % ny maxind ( 3 ) = beam_grid % nz mini ( 1 ) = minval ( beam_grid % xc ) - 0.5 * beam_grid % dr ( 1 ) mini ( 2 ) = minval ( beam_grid % yc ) - 0.5 * beam_grid % dr ( 2 ) mini ( 3 ) = minval ( beam_grid % zc ) - 0.5 * beam_grid % dr ( 3 ) do i = 1 , 3 ind ( i ) = floor (( pos ( i ) - mini ( i )) / beam_grid % dr ( i )) + 1 if ( ind ( i ). gt . maxind ( i )) ind ( i ) = maxind ( i ) if ( ind ( i ). lt . 1 ) ind ( i ) = 1 enddo end subroutine get_indices","tags":"","loc":"proc/get_indices.html","title":"get_indices – FIDASIM"},{"text":"public subroutine get_passive_grid_indices(pos, ind, input_coords) Find closest pass_grid indices ind to position pos Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position [cm] integer(kind=Int32), intent(out), dimension(3) :: ind Closest indices to position integer, intent(in), optional :: input_coords Indicates coordinate system of pos . Beam grid (0), machine (1) and cylindrical (2) Called by proc~~get_passive_grid_indices~~CalledByGraph proc~get_passive_grid_indices get_passive_grid_indices proc~store_photons store_photons proc~store_photons->proc~get_passive_grid_indices proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~get_passive_grid_indices proc~dcx_spec dcx_spec proc~dcx_spec->proc~store_photons proc~halo_spec halo_spec proc~halo_spec->proc~store_photons proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~track_cylindrical proc~cold_spec cold_spec proc~cold_spec->proc~store_photons proc~nbi_spec nbi_spec proc~nbi_spec->proc~store_photons proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~pfida_mc pfida_mc proc~pfida_mc->proc~track_cylindrical proc~pfida_f pfida_f proc~pfida_f->proc~track_cylindrical proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons program~fidasim fidasim program~fidasim->proc~dcx_spec program~fidasim->proc~halo_spec program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~cold_spec program~fidasim->proc~nbi_spec program~fidasim->proc~pfida_mc program~fidasim->proc~pfida_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_passive_grid_indices Source Code subroutine get_passive_grid_indices ( pos , ind , input_coords ) !+ Find closest [[libfida:pass_grid]] indices `ind` to position `pos` real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position [cm] integer ( Int32 ), dimension ( 3 ), intent ( out ) :: ind !+ Closest indices to position integer , intent ( in ), optional :: input_coords !+ Indicates coordinate system of `pos`. Beam grid (0), machine (1) and cylindrical (2) real ( Float64 ), dimension ( 3 ) :: mini , differentials , loc integer ( Int32 ), dimension ( 3 ) :: maxind integer :: i , ics if ( present ( input_coords )) then ics = input_coords else ics = 2 endif if ( ics . eq . 1 ) then loc ( 1 ) = sqrt ( pos ( 1 ) * pos ( 1 ) + pos ( 2 ) * pos ( 2 )) loc ( 2 ) = pos ( 3 ) loc ( 3 ) = atan2 ( pos ( 2 ), pos ( 1 )) endif if ( ics . eq . 2 ) then loc ( 1 ) = pos ( 1 ) loc ( 2 ) = pos ( 2 ) loc ( 3 ) = pos ( 3 ) endif maxind ( 1 ) = pass_grid % nr maxind ( 2 ) = pass_grid % nz maxind ( 3 ) = pass_grid % nphi mini ( 1 ) = minval ( pass_grid % r ) mini ( 2 ) = minval ( pass_grid % z ) mini ( 3 ) = minval ( pass_grid % phi ) differentials ( 1 ) = pass_grid % dr differentials ( 2 ) = pass_grid % dz differentials ( 3 ) = pass_grid % dphi do i = 1 , 3 ind ( i ) = floor (( loc ( i ) - mini ( i )) / differentials ( i )) + 1 if ( ind ( i ). gt . maxind ( i )) ind ( i ) = maxind ( i ) if ( ind ( i ). lt . 1 ) ind ( i ) = 1 enddo end subroutine get_passive_grid_indices","tags":"","loc":"proc/get_passive_grid_indices.html","title":"get_passive_grid_indices – FIDASIM"},{"text":"public subroutine get_plasma_extrema(r0, v0, extrema, x0, y0) Returns extrema points where line(s) parametrized by r0 and v0 intersect the plasma boudnary Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:) :: r0 Arrays the define line(s) in machine coordinates real(kind=Float64), intent(in), dimension(:,:) :: v0 Arrays the define line(s) in machine coordinates real(kind=Float64), intent(out), dimension(2,3) :: extrema Minimum and maximumm R, Z, and Phi points real(kind=Float64), intent(in), optional dimension(:) :: x0 Additional x and y points to consider real(kind=Float64), intent(in), optional dimension(:) :: y0 Additional x and y points to consider Calls proc~~get_plasma_extrema~~CallsGraph proc~get_plasma_extrema get_plasma_extrema proc~in_plasma in_plasma proc~get_plasma_extrema->proc~in_plasma proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocget_plasma_extremaCallsGraph = svgPanZoom('#procget_plasma_extremaCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_plasma_extrema~~CalledByGraph proc~get_plasma_extrema get_plasma_extrema proc~make_passive_grid make_passive_grid proc~make_passive_grid->proc~get_plasma_extrema proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~make_passive_grid program~fidasim fidasim program~fidasim->proc~make_diagnostic_grids Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_plasma_extrema Source Code subroutine get_plasma_extrema ( r0 , v0 , extrema , x0 , y0 ) !+ Returns extrema points where line(s) parametrized by `r0` and `v0` intersect the plasma boudnary real ( Float64 ), dimension (:,:), intent ( in ) :: r0 , v0 !+ Arrays the define line(s) in machine coordinates real ( Float64 ), dimension ( 2 , 3 ), intent ( out ) :: extrema !+ Minimum and maximumm R, Z, and Phi points real ( Float64 ), dimension (:), intent ( in ), optional :: x0 , y0 !+ Additional x and y points to consider real ( Float64 ), dimension (:,:), allocatable :: xy_in , xy_out real ( Float64 ), dimension (:,:), allocatable :: cyl_in , cyl_out real ( Float64 ), dimension (:), allocatable :: x , y , xlo , xhi real ( Float64 ), dimension (:), allocatable :: r , z , phi logical , dimension (:), allocatable :: skip real ( Float64 ), dimension ( 3 ) :: ri , vi real ( Float64 ) :: max_length , dlength integer :: i , iin , iout , ilo , ihi , dlo , dhi , dim , nlines , d logical :: inp nlines = size ( r0 ( 1 ,:)) allocate ( xy_in ( 2 , nlines ), xy_out ( 2 , nlines )) allocate ( cyl_in ( 3 , nlines ), cyl_out ( 3 , nlines )) allocate ( skip ( nlines )) dlength = 3.0 !cm skip = . False . loop_over_channels : do i = 1 , nlines ri = r0 (:, i ) vi = v0 (:, i ) vi = vi / norm2 ( vi ) ! Find the position that the los first intersects the plasma call in_plasma ( ri , inp , input_coords = 1 ) max_length = 0.0 do while (. not . inp ) ri = ri + vi * dlength ! move dlength call in_plasma ( ri , inp , input_coords = 1 ) max_length = max_length + dlength if ( max_length . gt . 1 d9 ) then skip ( i ) = . True . !used below to skip los that do not intersect the plasma cycle loop_over_channels endif enddo xy_in ( 1 , i ) = ri ( 1 ) ; xy_in ( 2 , i ) = ri ( 2 ) call uvw_to_cyl ( ri , cyl_in (:, i )) ! Find the position that the los intersects upon exiting the plasma do while ( inp ) ri = ri + vi * dlength call in_plasma ( ri , inp , input_coords = 1 ) enddo xy_out ( 1 , i ) = ri ( 1 ) ; xy_out ( 2 , i ) = ri ( 2 ) call uvw_to_cyl ( ri , cyl_out (:, i )) enddo loop_over_channels dim = 2 * count (. not . skip ) ! 2 for enter and exit d = 0 if ( present ( x0 ). and . present ( y0 )) then d = size ( x0 ) if ( size ( x0 ). ne . size ( y0 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(\"GET_PLASMA_EXTREMA: Sizes of X and Y input arrays are not identical\")' ) stop endif endif endif allocate ( x ( dim + d ), y ( dim + d ), r ( dim ), z ( dim ), phi ( dim )) iin = 1 ; iout = 2 do i = 1 , nlines if (. not . skip ( i )) then x ( iin ) = xy_in ( 1 , i ) ; x ( iout ) = xy_out ( 1 , i ) y ( iin ) = xy_in ( 2 , i ) ; y ( iout ) = xy_out ( 2 , i ) r ( iin ) = cyl_in ( 1 , i ) ; r ( iout ) = cyl_out ( 1 , i ) z ( iin ) = cyl_in ( 2 , i ) ; z ( iout ) = cyl_out ( 2 , i ) iin = iin + 2 ; iout = iout + 2 endif enddo extrema ( 1 , 1 ) = minval ( r ) ; extrema ( 2 , 1 ) = maxval ( r ) extrema ( 1 , 2 ) = minval ( z ) ; extrema ( 2 , 2 ) = maxval ( z ) ! Append extra x and y points if ( d . gt . 0 ) then x ( dim + 1 : dim + d ) = x0 y ( dim + 1 : dim + d ) = y0 endif !! Domain is between 0 and 2 pi if all x points are left of the line x=0 !! Else domain is between -pi and pi dlo = count ( y . le . 0 ) ; dhi = count ( y . gt . 0 ) allocate ( xlo ( dlo ), xhi ( dhi )) ilo = 0 ; ihi = 0 do i = 1 , size ( x ) if ( y ( i ). le . 0.d10 ) then ilo = ilo + 1 xlo ( ilo ) = x ( i ) else ihi = ihi + 1 xhi ( ihi ) = x ( i ) endif enddo phi = atan2 ( y , x ) if ( all ( x . le . 0 ) & !none in quadrant 1 and 4 . or .( all ( xlo . le . 0 ). and .( size ( x ). ne . size ( xhi ))) & !quadrant 3 . or .( all ( xhi . le . 0 ). and .( size ( x ). ne . size ( xlo )))) then !quadrant 2 phi = modulo ( phi , 2 * pi ) endif extrema ( 1 , 3 ) = minval ( phi ) ; extrema ( 2 , 3 ) = maxval ( phi ) end subroutine get_plasma_extrema","tags":"","loc":"proc/get_plasma_extrema.html","title":"get_plasma_extrema – FIDASIM"},{"text":"public subroutine get_position(ind, pos, input_coords) Get position pos given indices ind Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind Indices real(kind=Float64), intent(out), dimension(3) :: pos Position in beam_grid coordinates [cm] integer, intent(in), optional :: input_coords Indicates coordinate system of ind . Beam grid (0) and cylindrical (2) Calls proc~~get_position~~CallsGraph proc~get_position get_position proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~uvw_to_xyz uvw_to_xyz proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_uvw cyl_to_uvw proc~cyl_to_xyz->proc~cyl_to_uvw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_position~~CalledByGraph proc~get_position get_position proc~get_plasma get_plasma proc~get_plasma->proc~get_position proc~pnpa_f pnpa_f proc~pnpa_f->proc~get_plasma proc~attenuate attenuate proc~pnpa_f->proc~attenuate proc~dcx_spec dcx_spec proc~dcx_spec->proc~get_plasma proc~dcx dcx proc~dcx->proc~get_plasma proc~mc_halo mc_halo proc~dcx->proc~mc_halo proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_plasma proc~pfida_mc pfida_mc proc~pfida_mc->proc~get_plasma proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~get_plasma proc~pnpa_mc->proc~attenuate proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_plasma proc~mc_halo->proc~get_plasma proc~npa_f npa_f proc~npa_f->proc~get_plasma proc~npa_f->proc~attenuate proc~get_beam_cx_rate get_beam_cx_rate proc~npa_f->proc~get_beam_cx_rate proc~cold_spec cold_spec proc~cold_spec->proc~get_plasma proc~pfida_f pfida_f proc~pfida_f->proc~get_plasma proc~attenuate->proc~get_plasma proc~neutron_f neutron_f proc~neutron_f->proc~get_plasma proc~get_beam_cx_rate->proc~get_plasma proc~halo_spec halo_spec proc~halo_spec->proc~get_plasma proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~mc_halo proc~npa_weights npa_weights proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_rate program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~dcx program~fidasim->proc~bremsstrahlung program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~pfida_mc program~fidasim->proc~pnpa_mc program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~npa_f program~fidasim->proc~cold_spec program~fidasim->proc~pfida_f program~fidasim->proc~neutron_f program~fidasim->proc~halo_spec program~fidasim->proc~halo program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_rate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_position Source Code subroutine get_position ( ind , pos , input_coords ) !+ Get position `pos` given indices `ind` integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ Indices real ( Float64 ), dimension ( 3 ), intent ( out ) :: pos !+ Position in [[libfida:beam_grid]] coordinates [cm] integer , intent ( in ), optional :: input_coords !+ Indicates coordinate system of `ind`. Beam grid (0) and cylindrical (2) real ( Float64 ), dimension ( 3 ) :: pos_temp1 , pos_temp2 integer :: ics , ocs if ( present ( input_coords )) then ics = input_coords else ics = 0 endif if ( ics . eq . 0 ) then pos ( 1 ) = beam_grid % xc ( ind ( 1 )) pos ( 2 ) = beam_grid % yc ( ind ( 2 )) pos ( 3 ) = beam_grid % zc ( ind ( 3 )) endif if ( ics . eq . 2 ) then pos_temp1 ( 1 ) = inter_grid % r ( ind ( 1 )) pos_temp1 ( 2 ) = inter_grid % z ( ind ( 2 )) pos_temp1 ( 3 ) = inter_grid % phi ( ind ( 3 )) call cyl_to_xyz ( pos_temp1 , pos ) endif end subroutine get_position","tags":"","loc":"proc/get_position.html","title":"get_position – FIDASIM"},{"text":"public subroutine track(rin, vin, tracks, ntrack, los_intersect) Computes the path of a neutral through the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: rin Initial position of particle real(kind=Float64), intent(in), dimension(3) :: vin Initial velocity of particle type( ParticleTrack ), intent(inout), dimension(:) :: tracks Array of ParticleTrack type integer(kind=Int32), intent(out) :: ntrack Number of cells that a particle crosses logical, intent(out), optional :: los_intersect Indicator whether particle intersects a LOS in spec_chords Calls proc~~track~~CallsGraph proc~track track proc~get_indices get_indices proc~track->proc~get_indices proc~get_fields get_fields proc~track->proc~get_fields proc~doppler_stark doppler_stark proc~track->proc~doppler_stark proc~in_plasma in_plasma proc~track->proc~in_plasma proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~in_plasma->proc~xyz_to_uvw proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panproctrackCallsGraph = svgPanZoom('#proctrackCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~track~~CalledByGraph proc~track track proc~dcx dcx proc~dcx->proc~track proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~track proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~track proc~ndmc ndmc proc~ndmc->proc~track proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~track proc~fida_f fida_f proc~fida_f->proc~track proc~halo halo proc~halo->proc~track proc~fida_mc fida_mc proc~fida_mc->proc~track program~fidasim fidasim program~fidasim->proc~dcx program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~ndmc program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~fida_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code track Source Code subroutine track ( rin , vin , tracks , ntrack , los_intersect ) !+ Computes the path of a neutral through the [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: rin !+ Initial position of particle real ( Float64 ), dimension ( 3 ), intent ( in ) :: vin !+ Initial velocity of particle type ( ParticleTrack ), dimension (:), intent ( inout ) :: tracks !+ Array of [[ParticleTrack]] type integer ( Int32 ), intent ( out ) :: ntrack !+ Number of cells that a particle crosses logical , intent ( out ), optional :: los_intersect !+ Indicator whether particle intersects a LOS in [[libfida:spec_chords]] integer :: cc , i , j , ii , mind , ncross , id integer , dimension ( 3 ) :: ind logical :: in_plasma1 , in_plasma2 , in_plasma_tmp , los_inter real ( Float64 ) :: dT , dt1 , inv_50 real ( Float64 ), dimension ( 3 ) :: dt_arr , dr real ( Float64 ), dimension ( 3 ) :: vn , inv_vn , vp real ( Float64 ), dimension ( 3 ) :: ri , ri_tmp , ri_cell type ( LocalEMFields ) :: fields type ( LOSInters ) :: inter real ( Float64 ), dimension ( n_stark ) :: lambda integer , dimension ( 3 ) :: sgn integer , dimension ( 3 ) :: gdims vn = vin ; ri = rin ; sgn = 0 ; ntrack = 0 los_inter = . False . if (. not . present ( los_intersect )) then los_inter = . True . !avoids computation if not needed endif if ( dot_product ( vin , vin ). eq . 0.0 ) then return endif gdims ( 1 ) = beam_grid % nx gdims ( 2 ) = beam_grid % ny gdims ( 3 ) = beam_grid % nz !! define actual cell call get_indices ( ri , ind ) ri_cell = [ beam_grid % xc ( ind ( 1 )), & beam_grid % yc ( ind ( 2 )), & beam_grid % zc ( ind ( 3 ))] do i = 1 , 3 if ( vn ( i ). gt . 0.0 ) sgn ( i ) = 1 if ( vn ( i ). lt . 0.0 ) sgn ( i ) =- 1 if ( vn ( i ). eq . 0.0 ) vn ( i ) = 1.0d-3 enddo dr = beam_grid % dr * sgn inv_vn = 1 / vn inv_50 = 1.0 / 5 0.0 cc = 1 tracks % time = 0.d0 tracks % flux = 0.d0 ncross = 0 call in_plasma ( ri , in_plasma1 ) track_loop : do i = 1 , beam_grid % ntrack if ( cc . gt . beam_grid % ntrack ) exit track_loop dt_arr = abs (( ( ri_cell + 0.5 * dr ) - ri ) * inv_vn ) mind = minloc ( dt_arr , 1 ) dT = dt_arr ( mind ) ri_tmp = ri + dT * vn !! Check if velocity intersects LOS and produces wavelength in the right region inter = spec_chords % inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) if ((. not . los_inter ). and .( inter % nchan . ne . 0 )) then call get_fields ( fields , pos = ri_tmp ) chan_loop : do j = 1 , inter % nchan id = inter % los_elem ( j )% id vp = ri_tmp - spec_chords % los ( id )% lens call doppler_stark ( vp , vn , fields , lambda ) los_inter = any (( lambda . ge . inputs % lambdamin ). and .( lambda . le . inputs % lambdamax )) if ( los_inter ) exit chan_loop enddo chan_loop endif call in_plasma ( ri_tmp , in_plasma2 ) if ( in_plasma1 . neqv . in_plasma2 ) then dt1 = 0.0 track_fine : do ii = 1 , 50 dt1 = dt1 + dT * inv_50 ri_tmp = ri + vn * dt1 call in_plasma ( ri_tmp , in_plasma_tmp ) if ( in_plasma2 . eqv . in_plasma_tmp ) exit track_fine enddo track_fine tracks ( cc )% pos = ri + 0.5 * dt1 * vn tracks ( cc + 1 )% pos = ri + 0.5 * ( dt1 + dT ) * vn tracks ( cc )% time = dt1 tracks ( cc + 1 )% time = dT - dt1 tracks ( cc )% ind = ind tracks ( cc + 1 )% ind = ind cc = cc + 2 ncross = ncross + 1 else tracks ( cc )% pos = ri + 0.5 * dT * vn tracks ( cc )% time = dT tracks ( cc )% ind = ind cc = cc + 1 endif in_plasma1 = in_plasma2 ri = ri + dT * vn ind ( mind ) = ind ( mind ) + sgn ( mind ) ri_cell ( mind ) = ri_cell ( mind ) + dr ( mind ) if ( ind ( mind ). gt . gdims ( mind )) exit track_loop if ( ind ( mind ). lt . 1 ) exit track_loop if ( ncross . ge . 2 ) then cc = cc - 1 !dont include last segment exit track_loop endif enddo track_loop ntrack = cc - 1 if ( present ( los_intersect )) then los_intersect = los_inter endif end subroutine track","tags":"","loc":"proc/track.html","title":"track – FIDASIM"},{"text":"public subroutine track_cylindrical(rin, vin, tracks, ntrack, los_intersect) Computes the path of a neutral through the pass_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: rin Initial position of particle real(kind=Float64), intent(in), dimension(3) :: vin Initial velocity of particle type( ParticleTrack ), intent(inout), dimension(:) :: tracks Array of ParticleTrack type integer(kind=Int32), intent(out) :: ntrack Number of cells that a particle crosses logical, intent(out), optional :: los_intersect Indicator whether particle intersects a LOS in spec_chords Calls proc~~track_cylindrical~~CallsGraph proc~track_cylindrical track_cylindrical proc~get_fields get_fields proc~track_cylindrical->proc~get_fields proc~doppler_stark doppler_stark proc~track_cylindrical->proc~doppler_stark proc~cyl_to_uvw cyl_to_uvw proc~track_cylindrical->proc~cyl_to_uvw proc~plane_basis plane_basis proc~track_cylindrical->proc~plane_basis proc~get_passive_grid_indices get_passive_grid_indices proc~track_cylindrical->proc~get_passive_grid_indices proc~in_plasma in_plasma proc~track_cylindrical->proc~in_plasma proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~cross_product cross_product proc~plane_basis->proc~cross_product proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~in_plasma->proc~xyz_to_uvw proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panproctrack_cylindricalCallsGraph = svgPanZoom('#proctrack_cylindricalCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~track_cylindrical~~CalledByGraph proc~track_cylindrical track_cylindrical proc~pfida_mc pfida_mc proc~pfida_mc->proc~track_cylindrical proc~pfida_f pfida_f proc~pfida_f->proc~track_cylindrical proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~track_cylindrical program~fidasim fidasim program~fidasim->proc~pfida_mc program~fidasim->proc~pfida_f program~fidasim->proc~make_diagnostic_grids Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code track_cylindrical Source Code subroutine track_cylindrical ( rin , vin , tracks , ntrack , los_intersect ) !+ Computes the path of a neutral through the [[libfida:pass_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: rin !+ Initial position of particle real ( Float64 ), dimension ( 3 ), intent ( in ) :: vin !+ Initial velocity of particle type ( ParticleTrack ), dimension (:), intent ( inout ) :: tracks !+ Array of [[ParticleTrack]] type integer ( Int32 ), intent ( out ) :: ntrack !+ Number of cells that a particle crosses logical , intent ( out ), optional :: los_intersect !+ Indicator whether particle intersects a LOS in [[libfida:spec_chords]] real ( Float64 ), dimension ( 3 , 3 ) :: basis real ( Float64 ), dimension ( 3 ) :: dt_arr , dr !! Need to make this rzphi real ( Float64 ), dimension ( 3 ) :: vn , vn_cyl , vp real ( Float64 ), dimension ( 3 ) :: ri , ri_cyl , ri_tmp real ( Float64 ), dimension ( 3 ) :: p , nz real ( Float64 ), dimension ( 3 ) :: v_plane_cyl , v_plane real ( Float64 ), dimension ( 3 ) :: h_plane_cyl , h_plane real ( Float64 ), dimension ( 3 ) :: arc_cyl , arc real ( Float64 ), dimension ( 3 ) :: redge , tedge real ( Float64 ), dimension ( 3 ) :: redge_cyl , tedge_cyl integer , dimension ( 3 ) :: sgn integer , dimension ( 3 ) :: gdims integer , dimension ( 1 ) :: minpos integer , dimension ( 3 ) :: ind real ( Float64 ) :: dT , dt1 , inv_50 , t real ( Float64 ) :: s , c , phi integer :: cc , i , j , ii , mind , ncross , id type ( LocalEMFields ) :: fields type ( LOSInters ) :: inter real ( Float64 ), dimension ( n_stark ) :: lambda logical :: in_plasma1 , in_plasma2 , in_plasma_tmp , los_inter integer :: ir , iz , iphi vn = vin ; ri = rin ; sgn = 0 ; ntrack = 0 los_inter = . False . if (. not . present ( los_intersect )) then los_inter = . True . !avoids computation if not needed endif if ( dot_product ( vn , vn ). eq . 0.0 ) then return endif gdims ( 1 ) = pass_grid % nr gdims ( 2 ) = pass_grid % nz gdims ( 3 ) = pass_grid % nphi phi = atan2 ( rin ( 2 ), rin ( 1 )) s = sin ( phi ) ; c = cos ( phi ) vn_cyl ( 1 ) = c * vn ( 1 ) + s * vn ( 2 ) vn_cyl ( 3 ) = - s * vn ( 1 ) + c * vn ( 2 ) vn_cyl ( 2 ) = vn ( 3 ) do i = 1 , 3 !! sgn is in R-Z-Phi coordinates if ( vn_cyl ( i ). gt . 0.d0 ) then sgn ( i ) = 1 else if ( vn_cyl ( i ). lt . 0.d0 ) then sgn ( i ) =- 1 end if enddo dr ( 1 ) = pass_grid % dr * sgn ( 1 ) dr ( 2 ) = pass_grid % dz * sgn ( 2 ) dr ( 3 ) = pass_grid % dphi * sgn ( 3 ) !! Define actual cell ri_cyl ( 1 ) = sqrt ( ri ( 1 ) * ri ( 1 ) + ri ( 2 ) * ri ( 2 )) ri_cyl ( 2 ) = ri ( 3 ) ri_cyl ( 3 ) = atan2 ( ri ( 2 ), ri ( 1 )) call get_passive_grid_indices ( ri_cyl , ind ) arc_cyl ( 1 ) = pass_grid % r ( ind ( 1 )) arc_cyl ( 2 ) = pass_grid % z ( ind ( 2 )) arc_cyl ( 3 ) = pass_grid % phi ( ind ( 3 )) h_plane_cyl = arc_cyl v_plane_cyl = arc_cyl !! Define surfaces to intersect if ( sgn ( 1 ). gt . 0.d0 ) arc_cyl ( 1 ) = pass_grid % r ( ind ( 1 ) + 1 ) if ( sgn ( 2 ). gt . 0.d0 ) h_plane_cyl ( 2 ) = pass_grid % z ( ind ( 2 ) + 1 ) if ( sgn ( 3 ). gt . 0.d0 ) v_plane_cyl ( 3 ) = pass_grid % phi ( ind ( 3 ) + 1 ) ! Special case of the particle being on the surace handled below if (( sgn ( 1 ). lt . 0.d0 ). and .( arc_cyl ( 1 ). eq . ri_cyl ( 1 ))) then arc_cyl ( 1 ) = pass_grid % r ( ind ( 1 ) - 1 ) h_plane_cyl ( 1 ) = pass_grid % r ( ind ( 1 ) - 1 ) v_plane_cyl ( 1 ) = pass_grid % r ( ind ( 1 ) - 1 ) endif if (( sgn ( 2 ). lt . 0.d0 ). and .( h_plane_cyl ( 2 ). eq . ri_cyl ( 2 ))) then arc_cyl ( 2 ) = pass_grid % z ( ind ( 2 ) - 1 ) h_plane_cyl ( 2 ) = pass_grid % z ( ind ( 2 ) - 1 ) v_plane_cyl ( 2 ) = pass_grid % z ( ind ( 2 ) - 1 ) endif if (( sgn ( 3 ). lt . 0.d0 ). and .( v_plane_cyl ( 3 ). eq . ri_cyl ( 3 ))) then arc_cyl ( 3 ) = pass_grid % phi ( ind ( 3 ) - 1 ) h_plane_cyl ( 3 ) = pass_grid % phi ( ind ( 3 ) - 1 ) v_plane_cyl ( 3 ) = pass_grid % phi ( ind ( 3 ) - 1 ) endif call cyl_to_uvw ( arc_cyl , arc ) call cyl_to_uvw ( h_plane_cyl , h_plane ) call cyl_to_uvw ( v_plane_cyl , v_plane ) !! Normal vectors nz ( 1 ) = 0.d0 ; nz ( 2 ) = 0.d0 ; nz ( 3 ) = 1.d0 redge_cyl ( 1 ) = v_plane_cyl ( 1 ) + pass_grid % dr redge_cyl ( 2 ) = v_plane_cyl ( 2 ) redge_cyl ( 3 ) = v_plane_cyl ( 3 ) call cyl_to_uvw ( redge_cyl , redge ) tedge_cyl ( 1 ) = v_plane_cyl ( 1 ) tedge_cyl ( 2 ) = v_plane_cyl ( 2 ) + pass_grid % dz tedge_cyl ( 3 ) = v_plane_cyl ( 3 ) call cyl_to_uvw ( tedge_cyl , tedge ) call plane_basis ( v_plane , redge , tedge , basis ) !! Track the particle inv_50 = 1.0 / 5 0.0 cc = 1 tracks % time = 0.d0 tracks % flux = 0.d0 ncross = 0 call in_plasma ( ri , in_plasma1 , input_coords = 1 ) track_loop : do i = 1 , pass_grid % ntrack if ( cc . gt . pass_grid % ntrack ) exit track_loop call line_cylinder_intersect ( ri , vn , arc , p , dt_arr ( 1 )) call line_plane_intersect ( ri , vn , h_plane , nz , p , dt_arr ( 2 )) call line_plane_intersect ( ri , vn , v_plane , - basis (:, 3 ), p , dt_arr ( 3 )) minpos = minloc ( dt_arr , mask = dt_arr . gt . 0.d0 ) mind = minpos ( 1 ) dT = dt_arr ( mind ) ri_tmp = ri + dT * vn !! Check if velocity intersects LOS and produces wavelength in the right region inter = spec_chords % cyl_inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) if ((. not . los_inter ). and .( inter % nchan . ne . 0 )) then call get_fields ( fields , pos = ri_tmp , input_coords = 1 ) chan_loop : do j = 1 , inter % nchan id = inter % los_elem ( j )% id vp = ri_tmp - spec_chords % los ( id )% lens_uvw call doppler_stark ( vp , vn , fields , lambda ) los_inter = any (( lambda . ge . inputs % lambdamin ). and .( lambda . le . inputs % lambdamax )) if ( los_inter ) exit chan_loop enddo chan_loop endif call in_plasma ( ri_tmp , in_plasma2 , input_coords = 1 ) if ( in_plasma1 . neqv . in_plasma2 ) then dt1 = 0.0 track_fine : do ii = 1 , 50 dt1 = dt1 + dT * inv_50 ri_tmp = ri + vn * dt1 call in_plasma ( ri_tmp , in_plasma_tmp , input_coords = 1 ) if ( in_plasma2 . eqv . in_plasma_tmp ) exit track_fine enddo track_fine tracks ( cc )% pos = ri + 0.5 * dt1 * vn tracks ( cc + 1 )% pos = ri + 0.5 * ( dt1 + dT ) * vn tracks ( cc )% time = dt1 tracks ( cc + 1 )% time = dT - dt1 tracks ( cc )% ind = ind tracks ( cc + 1 )% ind = ind cc = cc + 2 ncross = ncross + 1 else tracks ( cc )% pos = ri + 0.5 * dT * vn tracks ( cc )% time = dT tracks ( cc )% ind = ind cc = cc + 1 endif in_plasma1 = in_plasma2 ri = ri + dT * vn ind ( mind ) = ind ( mind ) + sgn ( mind ) if ( ind ( mind ). gt . gdims ( mind )) exit track_loop if ( ind ( mind ). lt . 1 ) exit track_loop if ( ncross . ge . 2 ) then cc = cc - 1 !dont include last segment exit track_loop endif !! Particle advancement and basis update arc_cyl ( mind ) = arc_cyl ( mind ) + dr ( mind ) h_plane_cyl ( mind ) = h_plane_cyl ( mind ) + dr ( mind ) v_plane_cyl ( mind ) = v_plane_cyl ( mind ) + dr ( mind ) call cyl_to_uvw ( arc_cyl , arc ) call cyl_to_uvw ( h_plane_cyl , h_plane ) call cyl_to_uvw ( v_plane_cyl , v_plane ) redge_cyl ( 1 ) = v_plane_cyl ( 1 ) + pass_grid % dr redge_cyl ( 2 ) = v_plane_cyl ( 2 ) redge_cyl ( 3 ) = v_plane_cyl ( 3 ) call cyl_to_uvw ( redge_cyl , redge ) tedge_cyl ( 1 ) = v_plane_cyl ( 1 ) tedge_cyl ( 2 ) = v_plane_cyl ( 2 ) + pass_grid % dz tedge_cyl ( 3 ) = v_plane_cyl ( 3 ) call cyl_to_uvw ( tedge_cyl , tedge ) call plane_basis ( v_plane , redge , tedge , basis ) enddo track_loop ntrack = cc - 1 if ( present ( los_intersect )) then los_intersect = los_inter endif end subroutine track_cylindrical","tags":"","loc":"proc/track_cylindrical.html","title":"track_cylindrical – FIDASIM"},{"text":"public subroutine interpol1D_coeff(xmin, dx, nx, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa value real(kind=Float64), intent(in) :: dx Absissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code Called by proc~~interpol1d_coeff~~CalledByGraph proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff interpol_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~in_plasma in_plasma proc~in_plasma->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff proc~interpol3d_arr interpol3D_arr proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~get_neutron_rate get_neutron_rate proc~get_neutron_rate->interface~interpol_coeff proc~bt_cx_rates bt_cx_rates proc~bt_cx_rates->interface~interpol_coeff proc~bb_cx_rates bb_cx_rates proc~bb_cx_rates->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff proc~interpol3d_2d_arr interpol3D_2D_arr proc~interpol3d_2d_arr->interface~interpol_coeff proc~get_fields get_fields proc~get_fields->proc~in_plasma proc~make_beam_grid make_beam_grid proc~make_beam_grid->proc~in_plasma proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~bt_cx_rates proc~pnpa_mc->proc~get_fields proc~get_plasma get_plasma proc~pnpa_mc->proc~get_plasma proc~store_npa store_npa proc~pnpa_mc->proc~store_npa proc~attenuate attenuate proc~pnpa_mc->proc~attenuate proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~in_plasma proc~track_cylindrical->proc~get_fields proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~in_plasma proc~fida_weights_los->proc~bt_cx_rates proc~fida_weights_los->proc~bb_cx_rates proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~track track proc~fida_weights_los->proc~track proc~colrad colrad proc~fida_weights_los->proc~colrad proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~pfida_mc pfida_mc proc~pfida_mc->proc~bt_cx_rates proc~pfida_mc->proc~get_fields proc~pfida_mc->proc~track_cylindrical proc~pfida_mc->proc~get_plasma proc~get_plasma->proc~in_plasma proc~dcx_spec dcx_spec proc~dcx_spec->proc~in_plasma proc~dcx_spec->proc~get_plasma proc~store_photons store_photons proc~dcx_spec->proc~store_photons proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_neutron_rate proc~neutron_mc->proc~get_fields proc~neutron_mc->proc~get_plasma proc~track->proc~in_plasma proc~track->proc~get_fields proc~halo_spec halo_spec proc~halo_spec->proc~in_plasma proc~halo_spec->proc~get_plasma proc~halo_spec->proc~store_photons proc~nbi_spec nbi_spec proc~nbi_spec->proc~in_plasma proc~nbi_spec->proc~store_photons proc~get_plasma_extrema get_plasma_extrema proc~get_plasma_extrema->proc~in_plasma interface~interpol interpol interface~interpol->proc~interpol2d_arr interface~interpol->proc~interpol3d_arr interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol1d_arr interface~interpol->proc~interpol3d_2d_arr proc~neutron_f neutron_f proc~neutron_f->proc~get_neutron_rate proc~neutron_f->proc~get_fields proc~neutron_f->proc~get_plasma proc~pfida_f pfida_f proc~pfida_f->proc~bt_cx_rates proc~pfida_f->proc~track_cylindrical proc~pfida_f->proc~get_plasma proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~pfida_f->proc~mc_fastion_pass_grid proc~get_beam_cx_rate get_beam_cx_rate proc~get_beam_cx_rate->proc~bt_cx_rates proc~get_beam_cx_rate->proc~bb_cx_rates proc~get_beam_cx_rate->proc~get_plasma proc~colrad->proc~get_rate_matrix proc~pnpa_f pnpa_f proc~pnpa_f->proc~bt_cx_rates proc~pnpa_f->proc~get_plasma proc~pnpa_f->proc~mc_fastion_pass_grid proc~pnpa_f->proc~store_npa proc~pnpa_f->proc~attenuate proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~read_distribution read_distribution proc~read_distribution->proc~read_mc proc~mc_fastion_pass_grid->proc~get_fields proc~get_distribution get_distribution proc~mc_fastion_pass_grid->proc~get_distribution proc~get_distribution->interface~interpol proc~npa_mc npa_mc proc~npa_mc->proc~get_fields proc~npa_mc->proc~get_beam_cx_rate proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~ndmc ndmc proc~ndmc->proc~get_fields proc~ndmc->proc~mc_nbi proc~ndmc->proc~track program~fidasim fidasim program~fidasim->proc~make_beam_grid program~fidasim->proc~pnpa_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~pfida_mc program~fidasim->proc~dcx_spec program~fidasim->proc~neutron_mc program~fidasim->proc~halo_spec program~fidasim->proc~nbi_spec program~fidasim->proc~neutron_f program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_f program~fidasim->proc~bremsstrahlung program~fidasim->proc~read_distribution program~fidasim->proc~npa_mc program~fidasim->proc~ndmc proc~read_equilibrium read_equilibrium program~fidasim->proc~read_equilibrium proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~halo halo program~fidasim->proc~halo proc~dcx dcx program~fidasim->proc~dcx proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~cold_spec cold_spec program~fidasim->proc~cold_spec proc~make_diagnostic_grids make_diagnostic_grids program~fidasim->proc~make_diagnostic_grids proc~read_equilibrium->proc~colrad proc~npa_weights->proc~get_fields proc~npa_weights->proc~get_beam_cx_rate proc~npa_weights->proc~attenuate proc~fida_mc->proc~get_fields proc~fida_mc->proc~track proc~mc_halo mc_halo proc~mc_halo->proc~get_plasma proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~store_npa->proc~get_fields proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~store_photons->proc~get_fields proc~npa_f->proc~get_plasma proc~npa_f->proc~get_beam_cx_rate proc~npa_f->proc~store_npa proc~npa_f->proc~attenuate proc~npa_f->proc~mc_fastion proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~get_ep_denf get_ep_denf proc~fida_weights_mc->proc~get_ep_denf proc~cold_spec->proc~get_plasma proc~cold_spec->proc~store_photons proc~make_diagnostic_grids->proc~get_fields proc~make_diagnostic_grids->proc~track_cylindrical proc~make_diagnostic_grids->proc~track proc~make_passive_grid make_passive_grid proc~make_diagnostic_grids->proc~make_passive_grid proc~get_ep_denf->interface~interpol proc~make_passive_grid->proc~get_plasma_extrema proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons var panprocinterpol1d_coeffCalledByGraph = svgPanZoom('#procinterpol1d_coeffCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpol1D_coeff Source Code subroutine interpol1D_coeff ( xmin , dx , nx , xout , c , err ) !+ Linear interpolation coefficients and index for a 1D grid y(x) real ( Float64 ), intent ( in ) :: xmin !+ Minimum abscissa value real ( Float64 ), intent ( in ) :: dx !+ Absissa spacing integer , intent ( in ) :: nx !+ Number of abscissa real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate type ( InterpolCoeffs1D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: x1 , xp , b1 , b2 integer :: i , err_status err_status = 1 xp = max ( xout , xmin ) i = floor (( xp - xmin ) / dx ) + 1 if (( i . gt . 0 ). and .( i . le .( nx - 1 ))) then x1 = xmin + ( i - 1 ) * dx b2 = ( xp - x1 ) / dx b1 = ( 1.0 - b2 ) c % i = i c % b1 = b1 c % b2 = b2 err_status = 0 endif if ( present ( err )) err = err_status end subroutine interpol1D_coeff","tags":"","loc":"proc/interpol1d_coeff.html","title":"interpol1D_coeff – FIDASIM"},{"text":"public subroutine interpol1D_coeff_arr(x, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code Calls proc~~interpol1d_coeff_arr~~CallsGraph proc~interpol1d_coeff_arr interpol1D_coeff_arr proc~interpol1d_coeff interpol1D_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~interpol1d_coeff_arr~~CalledByGraph proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff interpol_coeff interface~interpol_coeff->proc~interpol1d_coeff_arr proc~in_plasma in_plasma proc~in_plasma->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff proc~interpol3d_arr interpol3D_arr proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~get_neutron_rate get_neutron_rate proc~get_neutron_rate->interface~interpol_coeff proc~bt_cx_rates bt_cx_rates proc~bt_cx_rates->interface~interpol_coeff proc~bb_cx_rates bb_cx_rates proc~bb_cx_rates->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff proc~interpol3d_2d_arr interpol3D_2D_arr proc~interpol3d_2d_arr->interface~interpol_coeff proc~get_fields get_fields proc~get_fields->proc~in_plasma proc~make_beam_grid make_beam_grid proc~make_beam_grid->proc~in_plasma proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~bt_cx_rates proc~pnpa_mc->proc~get_fields proc~get_plasma get_plasma proc~pnpa_mc->proc~get_plasma proc~store_npa store_npa proc~pnpa_mc->proc~store_npa proc~attenuate attenuate proc~pnpa_mc->proc~attenuate proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~in_plasma proc~track_cylindrical->proc~get_fields proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~in_plasma proc~fida_weights_los->proc~bt_cx_rates proc~fida_weights_los->proc~bb_cx_rates proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~track track proc~fida_weights_los->proc~track proc~colrad colrad proc~fida_weights_los->proc~colrad proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~pfida_mc pfida_mc proc~pfida_mc->proc~bt_cx_rates proc~pfida_mc->proc~get_fields proc~pfida_mc->proc~track_cylindrical proc~pfida_mc->proc~get_plasma proc~get_plasma->proc~in_plasma proc~dcx_spec dcx_spec proc~dcx_spec->proc~in_plasma proc~dcx_spec->proc~get_plasma proc~store_photons store_photons proc~dcx_spec->proc~store_photons proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_neutron_rate proc~neutron_mc->proc~get_fields proc~neutron_mc->proc~get_plasma proc~track->proc~in_plasma proc~track->proc~get_fields proc~halo_spec halo_spec proc~halo_spec->proc~in_plasma proc~halo_spec->proc~get_plasma proc~halo_spec->proc~store_photons proc~nbi_spec nbi_spec proc~nbi_spec->proc~in_plasma proc~nbi_spec->proc~store_photons proc~get_plasma_extrema get_plasma_extrema proc~get_plasma_extrema->proc~in_plasma interface~interpol interpol interface~interpol->proc~interpol2d_arr interface~interpol->proc~interpol3d_arr interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol1d_arr interface~interpol->proc~interpol3d_2d_arr proc~neutron_f neutron_f proc~neutron_f->proc~get_neutron_rate proc~neutron_f->proc~get_fields proc~neutron_f->proc~get_plasma proc~pfida_f pfida_f proc~pfida_f->proc~bt_cx_rates proc~pfida_f->proc~track_cylindrical proc~pfida_f->proc~get_plasma proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~pfida_f->proc~mc_fastion_pass_grid proc~get_beam_cx_rate get_beam_cx_rate proc~get_beam_cx_rate->proc~bt_cx_rates proc~get_beam_cx_rate->proc~bb_cx_rates proc~get_beam_cx_rate->proc~get_plasma proc~colrad->proc~get_rate_matrix proc~pnpa_f pnpa_f proc~pnpa_f->proc~bt_cx_rates proc~pnpa_f->proc~get_plasma proc~pnpa_f->proc~mc_fastion_pass_grid proc~pnpa_f->proc~store_npa proc~pnpa_f->proc~attenuate proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~read_distribution read_distribution proc~read_distribution->proc~read_mc proc~mc_fastion_pass_grid->proc~get_fields proc~get_distribution get_distribution proc~mc_fastion_pass_grid->proc~get_distribution proc~get_distribution->interface~interpol proc~npa_mc npa_mc proc~npa_mc->proc~get_fields proc~npa_mc->proc~get_beam_cx_rate proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~ndmc ndmc proc~ndmc->proc~get_fields proc~ndmc->proc~mc_nbi proc~ndmc->proc~track program~fidasim fidasim program~fidasim->proc~make_beam_grid program~fidasim->proc~pnpa_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~pfida_mc program~fidasim->proc~dcx_spec program~fidasim->proc~neutron_mc program~fidasim->proc~halo_spec program~fidasim->proc~nbi_spec program~fidasim->proc~neutron_f program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_f program~fidasim->proc~bremsstrahlung program~fidasim->proc~read_distribution program~fidasim->proc~npa_mc program~fidasim->proc~ndmc proc~read_equilibrium read_equilibrium program~fidasim->proc~read_equilibrium proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~halo halo program~fidasim->proc~halo proc~dcx dcx program~fidasim->proc~dcx proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~cold_spec cold_spec program~fidasim->proc~cold_spec proc~make_diagnostic_grids make_diagnostic_grids program~fidasim->proc~make_diagnostic_grids proc~read_equilibrium->proc~colrad proc~npa_weights->proc~get_fields proc~npa_weights->proc~get_beam_cx_rate proc~npa_weights->proc~attenuate proc~fida_mc->proc~get_fields proc~fida_mc->proc~track proc~mc_halo mc_halo proc~mc_halo->proc~get_plasma proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~store_npa->proc~get_fields proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~store_photons->proc~get_fields proc~npa_f->proc~get_plasma proc~npa_f->proc~get_beam_cx_rate proc~npa_f->proc~store_npa proc~npa_f->proc~attenuate proc~npa_f->proc~mc_fastion proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~get_ep_denf get_ep_denf proc~fida_weights_mc->proc~get_ep_denf proc~cold_spec->proc~get_plasma proc~cold_spec->proc~store_photons proc~make_diagnostic_grids->proc~get_fields proc~make_diagnostic_grids->proc~track_cylindrical proc~make_diagnostic_grids->proc~track proc~make_passive_grid make_passive_grid proc~make_diagnostic_grids->proc~make_passive_grid proc~get_ep_denf->interface~interpol proc~make_passive_grid->proc~get_plasma_extrema proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons var panprocinterpol1d_coeff_arrCalledByGraph = svgPanZoom('#procinterpol1d_coeff_arrCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpol1D_coeff_arr Source Code subroutine interpol1D_coeff_arr ( x , xout , c , err ) !+ Linear interpolation coefficients and index for a 1D grid y(x) real ( Float64 ), dimension (:), intent ( in ) :: x !+ Abscissa values real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate type ( InterpolCoeffs1D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: xmin , dx integer :: sx , err_status err_status = 1 sx = size ( x ) xmin = x ( 1 ) dx = abs ( x ( 2 ) - x ( 1 )) call interpol1D_coeff ( xmin , dx , sx , xout , c , err_status ) if ( present ( err )) err = err_status end subroutine interpol1D_coeff_arr","tags":"","loc":"proc/interpol1d_coeff_arr.html","title":"interpol1D_coeff_arr – FIDASIM"},{"text":"public subroutine interpol2D_coeff(xmin, dx, nx, ymin, dy, ny, xout, yout, c, err) Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa real(kind=Float64), intent(in) :: dx Abscissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: ymin Minimum ordinate real(kind=Float64), intent(in) :: dy Ordinate spacing integer, intent(in) :: ny Number of ordinates points real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code Called by proc~~interpol2d_coeff~~CalledByGraph proc~interpol2d_coeff interpol2D_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff interface~interpol_coeff interpol_coeff interface~interpol_coeff->proc~interpol2d_coeff interface~interpol_coeff->proc~interpol2d_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~in_plasma in_plasma proc~in_plasma->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff proc~interpol3d_arr interpol3D_arr proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~get_neutron_rate get_neutron_rate proc~get_neutron_rate->interface~interpol_coeff proc~bt_cx_rates bt_cx_rates proc~bt_cx_rates->interface~interpol_coeff proc~bb_cx_rates bb_cx_rates proc~bb_cx_rates->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff proc~interpol3d_2d_arr interpol3D_2D_arr proc~interpol3d_2d_arr->interface~interpol_coeff proc~get_fields get_fields proc~get_fields->proc~in_plasma proc~make_beam_grid make_beam_grid proc~make_beam_grid->proc~in_plasma proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~bt_cx_rates proc~pnpa_mc->proc~get_fields proc~get_plasma get_plasma proc~pnpa_mc->proc~get_plasma proc~store_npa store_npa proc~pnpa_mc->proc~store_npa proc~attenuate attenuate proc~pnpa_mc->proc~attenuate proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~in_plasma proc~track_cylindrical->proc~get_fields proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~in_plasma proc~fida_weights_los->proc~bt_cx_rates proc~fida_weights_los->proc~bb_cx_rates proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~track track proc~fida_weights_los->proc~track proc~colrad colrad proc~fida_weights_los->proc~colrad proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~pfida_mc pfida_mc proc~pfida_mc->proc~bt_cx_rates proc~pfida_mc->proc~get_fields proc~pfida_mc->proc~track_cylindrical proc~pfida_mc->proc~get_plasma proc~get_plasma->proc~in_plasma proc~dcx_spec dcx_spec proc~dcx_spec->proc~in_plasma proc~dcx_spec->proc~get_plasma proc~store_photons store_photons proc~dcx_spec->proc~store_photons proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_neutron_rate proc~neutron_mc->proc~get_fields proc~neutron_mc->proc~get_plasma proc~track->proc~in_plasma proc~track->proc~get_fields proc~halo_spec halo_spec proc~halo_spec->proc~in_plasma proc~halo_spec->proc~get_plasma proc~halo_spec->proc~store_photons proc~nbi_spec nbi_spec proc~nbi_spec->proc~in_plasma proc~nbi_spec->proc~store_photons proc~get_plasma_extrema get_plasma_extrema proc~get_plasma_extrema->proc~in_plasma interface~interpol interpol interface~interpol->proc~interpol2d_arr interface~interpol->proc~interpol3d_arr interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol1d_arr interface~interpol->proc~interpol3d_2d_arr proc~neutron_f neutron_f proc~neutron_f->proc~get_neutron_rate proc~neutron_f->proc~get_fields proc~neutron_f->proc~get_plasma proc~pfida_f pfida_f proc~pfida_f->proc~bt_cx_rates proc~pfida_f->proc~track_cylindrical proc~pfida_f->proc~get_plasma proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~pfida_f->proc~mc_fastion_pass_grid proc~get_beam_cx_rate get_beam_cx_rate proc~get_beam_cx_rate->proc~bt_cx_rates proc~get_beam_cx_rate->proc~bb_cx_rates proc~get_beam_cx_rate->proc~get_plasma proc~colrad->proc~get_rate_matrix proc~pnpa_f pnpa_f proc~pnpa_f->proc~bt_cx_rates proc~pnpa_f->proc~get_plasma proc~pnpa_f->proc~mc_fastion_pass_grid proc~pnpa_f->proc~store_npa proc~pnpa_f->proc~attenuate proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~read_distribution read_distribution proc~read_distribution->proc~read_mc proc~mc_fastion_pass_grid->proc~get_fields proc~get_distribution get_distribution proc~mc_fastion_pass_grid->proc~get_distribution proc~get_distribution->interface~interpol proc~npa_mc npa_mc proc~npa_mc->proc~get_fields proc~npa_mc->proc~get_beam_cx_rate proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~ndmc ndmc proc~ndmc->proc~get_fields proc~ndmc->proc~mc_nbi proc~ndmc->proc~track program~fidasim fidasim program~fidasim->proc~make_beam_grid program~fidasim->proc~pnpa_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~pfida_mc program~fidasim->proc~dcx_spec program~fidasim->proc~neutron_mc program~fidasim->proc~halo_spec program~fidasim->proc~nbi_spec program~fidasim->proc~neutron_f program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_f program~fidasim->proc~bremsstrahlung program~fidasim->proc~read_distribution program~fidasim->proc~npa_mc program~fidasim->proc~ndmc proc~read_equilibrium read_equilibrium program~fidasim->proc~read_equilibrium proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~halo halo program~fidasim->proc~halo proc~dcx dcx program~fidasim->proc~dcx proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~cold_spec cold_spec program~fidasim->proc~cold_spec proc~make_diagnostic_grids make_diagnostic_grids program~fidasim->proc~make_diagnostic_grids proc~read_equilibrium->proc~colrad proc~npa_weights->proc~get_fields proc~npa_weights->proc~get_beam_cx_rate proc~npa_weights->proc~attenuate proc~fida_mc->proc~get_fields proc~fida_mc->proc~track proc~mc_halo mc_halo proc~mc_halo->proc~get_plasma proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~store_npa->proc~get_fields proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~store_photons->proc~get_fields proc~npa_f->proc~get_plasma proc~npa_f->proc~get_beam_cx_rate proc~npa_f->proc~store_npa proc~npa_f->proc~attenuate proc~npa_f->proc~mc_fastion proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~get_ep_denf get_ep_denf proc~fida_weights_mc->proc~get_ep_denf proc~cold_spec->proc~get_plasma proc~cold_spec->proc~store_photons proc~make_diagnostic_grids->proc~get_fields proc~make_diagnostic_grids->proc~track_cylindrical proc~make_diagnostic_grids->proc~track proc~make_passive_grid make_passive_grid proc~make_diagnostic_grids->proc~make_passive_grid proc~get_ep_denf->interface~interpol proc~make_passive_grid->proc~get_plasma_extrema proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons var panprocinterpol2d_coeffCalledByGraph = svgPanZoom('#procinterpol2d_coeffCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpol2D_coeff Source Code subroutine interpol2D_coeff ( xmin , dx , nx , ymin , dy , ny , xout , yout , c , err ) !+ Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) real ( Float64 ), intent ( in ) :: xmin !+ Minimum abscissa real ( Float64 ), intent ( in ) :: dx !+ Abscissa spacing integer , intent ( in ) :: nx !+ Number of abscissa real ( Float64 ), intent ( in ) :: ymin !+ Minimum ordinate real ( Float64 ), intent ( in ) :: dy !+ Ordinate spacing integer , intent ( in ) :: ny !+ Number of ordinates points real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ Ordinate value to interpolate type ( InterpolCoeffs2D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: x1 , x2 , y1 , y2 , xp , yp integer :: i , j , err_status err_status = 1 xp = max ( xout , xmin ) yp = max ( yout , ymin ) i = floor (( xp - xmin ) / dx ) + 1 j = floor (( yp - ymin ) / dy ) + 1 if ((( i . gt . 0 ). and .( i . le .( nx - 1 ))). and .(( j . gt . 0 ). and .( j . le .( ny - 1 )))) then x1 = xmin + ( i - 1 ) * dx x2 = x1 + dx y1 = ymin + ( j - 1 ) * dy y2 = y1 + dy c % b11 = (( x2 - xp ) * ( y2 - yp )) / ( dx * dy ) c % b21 = (( xp - x1 ) * ( y2 - yp )) / ( dx * dy ) c % b12 = (( x2 - xp ) * ( yp - y1 )) / ( dx * dy ) c % b22 = (( xp - x1 ) * ( yp - y1 )) / ( dx * dy ) c % i = i c % j = j err_status = 0 endif if ( present ( err )) err = err_status end subroutine interpol2D_coeff","tags":"","loc":"proc/interpol2d_coeff.html","title":"interpol2D_coeff – FIDASIM"},{"text":"public subroutine interpol2D_coeff_arr(x, y, xout, yout, c, err) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in), dimension(:) :: y Ordinate values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code Calls proc~~interpol2d_coeff_arr~~CallsGraph proc~interpol2d_coeff_arr interpol2D_coeff_arr proc~interpol2d_coeff interpol2D_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~interpol2d_coeff_arr~~CalledByGraph proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff interpol_coeff interface~interpol_coeff->proc~interpol2d_coeff_arr proc~in_plasma in_plasma proc~in_plasma->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff proc~interpol3d_arr interpol3D_arr proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~get_neutron_rate get_neutron_rate proc~get_neutron_rate->interface~interpol_coeff proc~bt_cx_rates bt_cx_rates proc~bt_cx_rates->interface~interpol_coeff proc~bb_cx_rates bb_cx_rates proc~bb_cx_rates->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff proc~interpol3d_2d_arr interpol3D_2D_arr proc~interpol3d_2d_arr->interface~interpol_coeff proc~get_fields get_fields proc~get_fields->proc~in_plasma proc~make_beam_grid make_beam_grid proc~make_beam_grid->proc~in_plasma proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~bt_cx_rates proc~pnpa_mc->proc~get_fields proc~get_plasma get_plasma proc~pnpa_mc->proc~get_plasma proc~store_npa store_npa proc~pnpa_mc->proc~store_npa proc~attenuate attenuate proc~pnpa_mc->proc~attenuate proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~in_plasma proc~track_cylindrical->proc~get_fields proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~in_plasma proc~fida_weights_los->proc~bt_cx_rates proc~fida_weights_los->proc~bb_cx_rates proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~track track proc~fida_weights_los->proc~track proc~colrad colrad proc~fida_weights_los->proc~colrad proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~pfida_mc pfida_mc proc~pfida_mc->proc~bt_cx_rates proc~pfida_mc->proc~get_fields proc~pfida_mc->proc~track_cylindrical proc~pfida_mc->proc~get_plasma proc~get_plasma->proc~in_plasma proc~dcx_spec dcx_spec proc~dcx_spec->proc~in_plasma proc~dcx_spec->proc~get_plasma proc~store_photons store_photons proc~dcx_spec->proc~store_photons proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_neutron_rate proc~neutron_mc->proc~get_fields proc~neutron_mc->proc~get_plasma proc~track->proc~in_plasma proc~track->proc~get_fields proc~halo_spec halo_spec proc~halo_spec->proc~in_plasma proc~halo_spec->proc~get_plasma proc~halo_spec->proc~store_photons proc~nbi_spec nbi_spec proc~nbi_spec->proc~in_plasma proc~nbi_spec->proc~store_photons proc~get_plasma_extrema get_plasma_extrema proc~get_plasma_extrema->proc~in_plasma interface~interpol interpol interface~interpol->proc~interpol2d_arr interface~interpol->proc~interpol3d_arr interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol1d_arr interface~interpol->proc~interpol3d_2d_arr proc~neutron_f neutron_f proc~neutron_f->proc~get_neutron_rate proc~neutron_f->proc~get_fields proc~neutron_f->proc~get_plasma proc~pfida_f pfida_f proc~pfida_f->proc~bt_cx_rates proc~pfida_f->proc~track_cylindrical proc~pfida_f->proc~get_plasma proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~pfida_f->proc~mc_fastion_pass_grid proc~get_beam_cx_rate get_beam_cx_rate proc~get_beam_cx_rate->proc~bt_cx_rates proc~get_beam_cx_rate->proc~bb_cx_rates proc~get_beam_cx_rate->proc~get_plasma proc~colrad->proc~get_rate_matrix proc~pnpa_f pnpa_f proc~pnpa_f->proc~bt_cx_rates proc~pnpa_f->proc~get_plasma proc~pnpa_f->proc~mc_fastion_pass_grid proc~pnpa_f->proc~store_npa proc~pnpa_f->proc~attenuate proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~read_distribution read_distribution proc~read_distribution->proc~read_mc proc~mc_fastion_pass_grid->proc~get_fields proc~get_distribution get_distribution proc~mc_fastion_pass_grid->proc~get_distribution proc~get_distribution->interface~interpol proc~npa_mc npa_mc proc~npa_mc->proc~get_fields proc~npa_mc->proc~get_beam_cx_rate proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~ndmc ndmc proc~ndmc->proc~get_fields proc~ndmc->proc~mc_nbi proc~ndmc->proc~track program~fidasim fidasim program~fidasim->proc~make_beam_grid program~fidasim->proc~pnpa_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~pfida_mc program~fidasim->proc~dcx_spec program~fidasim->proc~neutron_mc program~fidasim->proc~halo_spec program~fidasim->proc~nbi_spec program~fidasim->proc~neutron_f program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_f program~fidasim->proc~bremsstrahlung program~fidasim->proc~read_distribution program~fidasim->proc~npa_mc program~fidasim->proc~ndmc proc~read_equilibrium read_equilibrium program~fidasim->proc~read_equilibrium proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~halo halo program~fidasim->proc~halo proc~dcx dcx program~fidasim->proc~dcx proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~cold_spec cold_spec program~fidasim->proc~cold_spec proc~make_diagnostic_grids make_diagnostic_grids program~fidasim->proc~make_diagnostic_grids proc~read_equilibrium->proc~colrad proc~npa_weights->proc~get_fields proc~npa_weights->proc~get_beam_cx_rate proc~npa_weights->proc~attenuate proc~fida_mc->proc~get_fields proc~fida_mc->proc~track proc~mc_halo mc_halo proc~mc_halo->proc~get_plasma proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~store_npa->proc~get_fields proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~store_photons->proc~get_fields proc~npa_f->proc~get_plasma proc~npa_f->proc~get_beam_cx_rate proc~npa_f->proc~store_npa proc~npa_f->proc~attenuate proc~npa_f->proc~mc_fastion proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~get_ep_denf get_ep_denf proc~fida_weights_mc->proc~get_ep_denf proc~cold_spec->proc~get_plasma proc~cold_spec->proc~store_photons proc~make_diagnostic_grids->proc~get_fields proc~make_diagnostic_grids->proc~track_cylindrical proc~make_diagnostic_grids->proc~track proc~make_passive_grid make_passive_grid proc~make_diagnostic_grids->proc~make_passive_grid proc~get_ep_denf->interface~interpol proc~make_passive_grid->proc~get_plasma_extrema proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons var panprocinterpol2d_coeff_arrCalledByGraph = svgPanZoom('#procinterpol2d_coeff_arrCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpol2D_coeff_arr Source Code subroutine interpol2D_coeff_arr ( x , y , xout , yout , c , err ) !!Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) real ( Float64 ), dimension (:), intent ( in ) :: x !+ Abscissa values real ( Float64 ), dimension (:), intent ( in ) :: y !+ Ordinate values real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ Ordinate value to interpolate type ( InterpolCoeffs2D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: xmin , ymin , dx , dy integer :: sx , sy , err_status err_status = 1 sx = size ( x ) sy = size ( y ) xmin = x ( 1 ) ymin = y ( 1 ) dx = abs ( x ( 2 ) - x ( 1 )) dy = abs ( y ( 2 ) - y ( 1 )) call interpol2D_coeff ( xmin , dx , sx , ymin , dy , sy , xout , yout , c , err_status ) if ( present ( err )) err = err_status end subroutine interpol2D_coeff_arr","tags":"","loc":"proc/interpol2d_coeff_arr.html","title":"interpol2D_coeff_arr – FIDASIM"},{"text":"public subroutine cyl_interpol3D_coeff(rmin, dr, nr, zmin, dz, nz, phimin, dphi, nphi, rout, zout, phiout, c, err) Cylindrical interpolation coefficients and indicies for a 3D grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: rmin Minimum R real(kind=Float64), intent(in) :: dr R spacing integer, intent(in) :: nr Number of R points real(kind=Float64), intent(in) :: zmin Minimum Z real(kind=Float64), intent(in) :: dz Z spacing integer, intent(in) :: nz Number of Z points real(kind=Float64), intent(in) :: phimin Minimum phi real(kind=Float64), intent(in) :: dphi Phi spacing integer, intent(in) :: nphi Number of phi points real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate type( InterpolCoeffs3D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code Calls proc~~cyl_interpol3d_coeff~~CallsGraph proc~cyl_interpol3d_coeff cyl_interpol3D_coeff proc~interpol2d_coeff interpol2D_coeff proc~cyl_interpol3d_coeff->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~cyl_interpol3d_coeff~~CalledByGraph proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff interpol_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~in_plasma in_plasma proc~in_plasma->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff proc~interpol3d_arr interpol3D_arr proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~get_neutron_rate get_neutron_rate proc~get_neutron_rate->interface~interpol_coeff proc~bt_cx_rates bt_cx_rates proc~bt_cx_rates->interface~interpol_coeff proc~bb_cx_rates bb_cx_rates proc~bb_cx_rates->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff proc~interpol3d_2d_arr interpol3D_2D_arr proc~interpol3d_2d_arr->interface~interpol_coeff proc~get_fields get_fields proc~get_fields->proc~in_plasma proc~make_beam_grid make_beam_grid proc~make_beam_grid->proc~in_plasma proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~bt_cx_rates proc~pnpa_mc->proc~get_fields proc~get_plasma get_plasma proc~pnpa_mc->proc~get_plasma proc~store_npa store_npa proc~pnpa_mc->proc~store_npa proc~attenuate attenuate proc~pnpa_mc->proc~attenuate proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~in_plasma proc~track_cylindrical->proc~get_fields proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~in_plasma proc~fida_weights_los->proc~bt_cx_rates proc~fida_weights_los->proc~bb_cx_rates proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~track track proc~fida_weights_los->proc~track proc~colrad colrad proc~fida_weights_los->proc~colrad proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~pfida_mc pfida_mc proc~pfida_mc->proc~bt_cx_rates proc~pfida_mc->proc~get_fields proc~pfida_mc->proc~track_cylindrical proc~pfida_mc->proc~get_plasma proc~get_plasma->proc~in_plasma proc~dcx_spec dcx_spec proc~dcx_spec->proc~in_plasma proc~dcx_spec->proc~get_plasma proc~store_photons store_photons proc~dcx_spec->proc~store_photons proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_neutron_rate proc~neutron_mc->proc~get_fields proc~neutron_mc->proc~get_plasma proc~track->proc~in_plasma proc~track->proc~get_fields proc~halo_spec halo_spec proc~halo_spec->proc~in_plasma proc~halo_spec->proc~get_plasma proc~halo_spec->proc~store_photons proc~nbi_spec nbi_spec proc~nbi_spec->proc~in_plasma proc~nbi_spec->proc~store_photons proc~get_plasma_extrema get_plasma_extrema proc~get_plasma_extrema->proc~in_plasma interface~interpol interpol interface~interpol->proc~interpol2d_arr interface~interpol->proc~interpol3d_arr interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol1d_arr interface~interpol->proc~interpol3d_2d_arr proc~neutron_f neutron_f proc~neutron_f->proc~get_neutron_rate proc~neutron_f->proc~get_fields proc~neutron_f->proc~get_plasma proc~pfida_f pfida_f proc~pfida_f->proc~bt_cx_rates proc~pfida_f->proc~track_cylindrical proc~pfida_f->proc~get_plasma proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~pfida_f->proc~mc_fastion_pass_grid proc~get_beam_cx_rate get_beam_cx_rate proc~get_beam_cx_rate->proc~bt_cx_rates proc~get_beam_cx_rate->proc~bb_cx_rates proc~get_beam_cx_rate->proc~get_plasma proc~colrad->proc~get_rate_matrix proc~pnpa_f pnpa_f proc~pnpa_f->proc~bt_cx_rates proc~pnpa_f->proc~get_plasma proc~pnpa_f->proc~mc_fastion_pass_grid proc~pnpa_f->proc~store_npa proc~pnpa_f->proc~attenuate proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~read_distribution read_distribution proc~read_distribution->proc~read_mc proc~mc_fastion_pass_grid->proc~get_fields proc~get_distribution get_distribution proc~mc_fastion_pass_grid->proc~get_distribution proc~get_distribution->interface~interpol proc~npa_mc npa_mc proc~npa_mc->proc~get_fields proc~npa_mc->proc~get_beam_cx_rate proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~ndmc ndmc proc~ndmc->proc~get_fields proc~ndmc->proc~mc_nbi proc~ndmc->proc~track program~fidasim fidasim program~fidasim->proc~make_beam_grid program~fidasim->proc~pnpa_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~pfida_mc program~fidasim->proc~dcx_spec program~fidasim->proc~neutron_mc program~fidasim->proc~halo_spec program~fidasim->proc~nbi_spec program~fidasim->proc~neutron_f program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_f program~fidasim->proc~bremsstrahlung program~fidasim->proc~read_distribution program~fidasim->proc~npa_mc program~fidasim->proc~ndmc proc~read_equilibrium read_equilibrium program~fidasim->proc~read_equilibrium proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~halo halo program~fidasim->proc~halo proc~dcx dcx program~fidasim->proc~dcx proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~cold_spec cold_spec program~fidasim->proc~cold_spec proc~make_diagnostic_grids make_diagnostic_grids program~fidasim->proc~make_diagnostic_grids proc~read_equilibrium->proc~colrad proc~npa_weights->proc~get_fields proc~npa_weights->proc~get_beam_cx_rate proc~npa_weights->proc~attenuate proc~fida_mc->proc~get_fields proc~fida_mc->proc~track proc~mc_halo mc_halo proc~mc_halo->proc~get_plasma proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~store_npa->proc~get_fields proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~store_photons->proc~get_fields proc~npa_f->proc~get_plasma proc~npa_f->proc~get_beam_cx_rate proc~npa_f->proc~store_npa proc~npa_f->proc~attenuate proc~npa_f->proc~mc_fastion proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~get_ep_denf get_ep_denf proc~fida_weights_mc->proc~get_ep_denf proc~cold_spec->proc~get_plasma proc~cold_spec->proc~store_photons proc~make_diagnostic_grids->proc~get_fields proc~make_diagnostic_grids->proc~track_cylindrical proc~make_diagnostic_grids->proc~track proc~make_passive_grid make_passive_grid proc~make_diagnostic_grids->proc~make_passive_grid proc~get_ep_denf->interface~interpol proc~make_passive_grid->proc~get_plasma_extrema proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons var panproccyl_interpol3d_coeffCalledByGraph = svgPanZoom('#proccyl_interpol3d_coeffCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code cyl_interpol3D_coeff Source Code subroutine cyl_interpol3D_coeff ( rmin , dr , nr , zmin , dz , nz , phimin , dphi , nphi , rout , zout , phiout , c , err ) !+ Cylindrical interpolation coefficients and indicies for a 3D grid real ( Float64 ), intent ( in ) :: rmin !+ Minimum R real ( Float64 ), intent ( in ) :: dr !+ R spacing integer , intent ( in ) :: nr !+ Number of R points real ( Float64 ), intent ( in ) :: zmin !+ Minimum Z real ( Float64 ), intent ( in ) :: dz !+ Z spacing integer , intent ( in ) :: nz !+ Number of Z points real ( Float64 ), intent ( in ) :: phimin !+ Minimum phi real ( Float64 ), intent ( in ) :: dphi !+ Phi spacing integer , intent ( in ) :: nphi !+ Number of phi points real ( Float64 ), intent ( in ) :: rout !+ R value to interpolate real ( Float64 ), intent ( in ) :: zout !+ Z value to interpolate real ( Float64 ), intent ( in ) :: phiout !+ Phi value to interpolate type ( InterpolCoeffs3D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs2D ) :: b real ( Float64 ) :: r1 , r2 , phi1 , phi2 , z1 , z2 , rp , phip , zp , dV real ( Float64 ) :: phi integer :: i , j , k , err_status err_status = 1 rp = max ( rout , rmin ) zp = max ( zout , zmin ) phip = max ( phiout , phimin ) i = floor (( rp - rmin ) / dr ) + 1 j = floor (( zp - zmin ) / dz ) + 1 k = floor (( phip - phimin ) / dphi ) + 1 if ( nphi . eq . 1 ) then if ((( i . gt . 0 ). and .( i . le .( nr - 1 ))). and .(( j . gt . 0 ). and .( j . le .( nz - 1 )))) then call interpol2D_coeff ( rmin , dr , nr , zmin , dz , nz , rout , zout , b , err_status ) c % b111 = b % b11 c % b121 = b % b12 c % b221 = b % b22 c % b211 = b % b21 c % b212 = 0 c % b222 = 0 c % b122 = 0 c % b112 = 0 c % i = b % i c % j = b % j c % k = 1 err_status = 0 endif else if (((( i . gt . 0 ). and .( i . le .( nr - 1 ))). and .(( j . gt . 0 ). and .( j . le .( nz - 1 )))). and .(( k . gt . 0 ). and .( k . le .( nphi - 1 )))) then r1 = rmin + ( i - 1 ) * dr r2 = r1 + dr z1 = zmin + ( j - 1 ) * dz z2 = z1 + dz phi1 = phimin + ( k - 1 ) * dphi phi2 = phi1 + dphi dV = (( r2 ** 2 - r1 ** 2 ) * ( phi2 - phi1 ) * ( z2 - z1 )) !! Both volume elements have a factor of 1/2 that cancels out c % b111 = (( r2 ** 2 - rp ** 2 ) * ( phi2 - phip ) * ( z2 - zp )) / dV c % b121 = (( r2 ** 2 - rp ** 2 ) * ( phi2 - phip ) * ( zp - z1 )) / dV c % b221 = (( rp ** 2 - r1 ** 2 ) * ( phi2 - phip ) * ( zp - z1 )) / dV c % b211 = (( rp ** 2 - r1 ** 2 ) * ( phi2 - phip ) * ( z2 - zp )) / dV c % b212 = (( rp ** 2 - r1 ** 2 ) * ( phip - phi1 ) * ( z2 - zp )) / dV c % b222 = (( rp ** 2 - r1 ** 2 ) * ( phip - phi1 ) * ( zp - z1 )) / dV c % b122 = (( r2 ** 2 - rp ** 2 ) * ( phip - phi1 ) * ( zp - z1 )) / dV c % b112 = (( r2 ** 2 - rp ** 2 ) * ( phip - phi1 ) * ( z2 - zp )) / dV c % i = i c % j = j c % k = k err_status = 0 endif endif if ( present ( err )) err = err_status end subroutine cyl_interpol3D_coeff","tags":"","loc":"proc/cyl_interpol3d_coeff.html","title":"cyl_interpol3D_coeff – FIDASIM"},{"text":"public subroutine cyl_interpol3D_coeff_arr(r, z, phi, rout, zout, phiout, c, err) Cylindrical interpolation coefficients and indicies for a 3D grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: r R values real(kind=Float64), intent(in), dimension(:) :: z Z values real(kind=Float64), intent(in), dimension(:) :: phi Phi values real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate type( InterpolCoeffs3D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code Calls proc~~cyl_interpol3d_coeff_arr~~CallsGraph proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr proc~interpol2d_coeff interpol2D_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~cyl_interpol3d_coeff_arr~~CalledByGraph proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff interpol_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~in_plasma in_plasma proc~in_plasma->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff proc~interpol3d_arr interpol3D_arr proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~get_neutron_rate get_neutron_rate proc~get_neutron_rate->interface~interpol_coeff proc~bt_cx_rates bt_cx_rates proc~bt_cx_rates->interface~interpol_coeff proc~bb_cx_rates bb_cx_rates proc~bb_cx_rates->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff proc~interpol3d_2d_arr interpol3D_2D_arr proc~interpol3d_2d_arr->interface~interpol_coeff proc~get_fields get_fields proc~get_fields->proc~in_plasma proc~make_beam_grid make_beam_grid proc~make_beam_grid->proc~in_plasma proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~bt_cx_rates proc~pnpa_mc->proc~get_fields proc~get_plasma get_plasma proc~pnpa_mc->proc~get_plasma proc~store_npa store_npa proc~pnpa_mc->proc~store_npa proc~attenuate attenuate proc~pnpa_mc->proc~attenuate proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~in_plasma proc~track_cylindrical->proc~get_fields proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~in_plasma proc~fida_weights_los->proc~bt_cx_rates proc~fida_weights_los->proc~bb_cx_rates proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~track track proc~fida_weights_los->proc~track proc~colrad colrad proc~fida_weights_los->proc~colrad proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~pfida_mc pfida_mc proc~pfida_mc->proc~bt_cx_rates proc~pfida_mc->proc~get_fields proc~pfida_mc->proc~track_cylindrical proc~pfida_mc->proc~get_plasma proc~get_plasma->proc~in_plasma proc~dcx_spec dcx_spec proc~dcx_spec->proc~in_plasma proc~dcx_spec->proc~get_plasma proc~store_photons store_photons proc~dcx_spec->proc~store_photons proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_neutron_rate proc~neutron_mc->proc~get_fields proc~neutron_mc->proc~get_plasma proc~track->proc~in_plasma proc~track->proc~get_fields proc~halo_spec halo_spec proc~halo_spec->proc~in_plasma proc~halo_spec->proc~get_plasma proc~halo_spec->proc~store_photons proc~nbi_spec nbi_spec proc~nbi_spec->proc~in_plasma proc~nbi_spec->proc~store_photons proc~get_plasma_extrema get_plasma_extrema proc~get_plasma_extrema->proc~in_plasma interface~interpol interpol interface~interpol->proc~interpol2d_arr interface~interpol->proc~interpol3d_arr interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol1d_arr interface~interpol->proc~interpol3d_2d_arr proc~neutron_f neutron_f proc~neutron_f->proc~get_neutron_rate proc~neutron_f->proc~get_fields proc~neutron_f->proc~get_plasma proc~pfida_f pfida_f proc~pfida_f->proc~bt_cx_rates proc~pfida_f->proc~track_cylindrical proc~pfida_f->proc~get_plasma proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~pfida_f->proc~mc_fastion_pass_grid proc~get_beam_cx_rate get_beam_cx_rate proc~get_beam_cx_rate->proc~bt_cx_rates proc~get_beam_cx_rate->proc~bb_cx_rates proc~get_beam_cx_rate->proc~get_plasma proc~colrad->proc~get_rate_matrix proc~pnpa_f pnpa_f proc~pnpa_f->proc~bt_cx_rates proc~pnpa_f->proc~get_plasma proc~pnpa_f->proc~mc_fastion_pass_grid proc~pnpa_f->proc~store_npa proc~pnpa_f->proc~attenuate proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~read_distribution read_distribution proc~read_distribution->proc~read_mc proc~mc_fastion_pass_grid->proc~get_fields proc~get_distribution get_distribution proc~mc_fastion_pass_grid->proc~get_distribution proc~get_distribution->interface~interpol proc~npa_mc npa_mc proc~npa_mc->proc~get_fields proc~npa_mc->proc~get_beam_cx_rate proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~ndmc ndmc proc~ndmc->proc~get_fields proc~ndmc->proc~mc_nbi proc~ndmc->proc~track program~fidasim fidasim program~fidasim->proc~make_beam_grid program~fidasim->proc~pnpa_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~pfida_mc program~fidasim->proc~dcx_spec program~fidasim->proc~neutron_mc program~fidasim->proc~halo_spec program~fidasim->proc~nbi_spec program~fidasim->proc~neutron_f program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_f program~fidasim->proc~bremsstrahlung program~fidasim->proc~read_distribution program~fidasim->proc~npa_mc program~fidasim->proc~ndmc proc~read_equilibrium read_equilibrium program~fidasim->proc~read_equilibrium proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~halo halo program~fidasim->proc~halo proc~dcx dcx program~fidasim->proc~dcx proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~cold_spec cold_spec program~fidasim->proc~cold_spec proc~make_diagnostic_grids make_diagnostic_grids program~fidasim->proc~make_diagnostic_grids proc~read_equilibrium->proc~colrad proc~npa_weights->proc~get_fields proc~npa_weights->proc~get_beam_cx_rate proc~npa_weights->proc~attenuate proc~fida_mc->proc~get_fields proc~fida_mc->proc~track proc~mc_halo mc_halo proc~mc_halo->proc~get_plasma proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~store_npa->proc~get_fields proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~store_photons->proc~get_fields proc~npa_f->proc~get_plasma proc~npa_f->proc~get_beam_cx_rate proc~npa_f->proc~store_npa proc~npa_f->proc~attenuate proc~npa_f->proc~mc_fastion proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~get_ep_denf get_ep_denf proc~fida_weights_mc->proc~get_ep_denf proc~cold_spec->proc~get_plasma proc~cold_spec->proc~store_photons proc~make_diagnostic_grids->proc~get_fields proc~make_diagnostic_grids->proc~track_cylindrical proc~make_diagnostic_grids->proc~track proc~make_passive_grid make_passive_grid proc~make_diagnostic_grids->proc~make_passive_grid proc~get_ep_denf->interface~interpol proc~make_passive_grid->proc~get_plasma_extrema proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons var panproccyl_interpol3d_coeff_arrCalledByGraph = svgPanZoom('#proccyl_interpol3d_coeff_arrCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code cyl_interpol3D_coeff_arr Source Code subroutine cyl_interpol3D_coeff_arr ( r , z , phi , rout , zout , phiout , c , err ) !+ Cylindrical interpolation coefficients and indicies for a 3D grid real ( Float64 ), dimension (:), intent ( in ) :: r !+ R values real ( Float64 ), dimension (:), intent ( in ) :: z !+ Z values real ( Float64 ), dimension (:), intent ( in ) :: phi !+ Phi values real ( Float64 ), intent ( in ) :: rout !+ R value to interpolate real ( Float64 ), intent ( in ) :: zout !+ Z value to interpolate real ( Float64 ), intent ( in ) :: phiout !+ Phi value to interpolate type ( InterpolCoeffs3D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs2D ) :: b real ( Float64 ) :: rmin , phimin , zmin , dr , dphi , dz integer :: sr , sphi , sz , err_status err_status = 1 sr = size ( r ) sphi = size ( phi ) sz = size ( z ) rmin = r ( 1 ) zmin = z ( 1 ) dr = abs ( r ( 2 ) - r ( 1 )) dz = abs ( z ( 2 ) - z ( 1 )) if ( sphi . eq . 1 ) then call interpol2D_coeff ( rmin , dr , sr , zmin , dz , sz , rout , zout , b , err_status ) c % b111 = b % b11 c % b121 = b % b12 c % b221 = b % b22 c % b211 = b % b21 c % b212 = 0 c % b222 = 0 c % b122 = 0 c % b112 = 0 c % i = b % i c % j = b % j c % k = 1 else phimin = phi ( 1 ) dphi = abs ( phi ( 2 ) - phi ( 1 )) call cyl_interpol3D_coeff ( rmin , dr , sr , zmin , dz , sz , phimin , dphi , sphi , rout , zout , phiout , c , err_status ) endif if ( present ( err )) err = err_status end subroutine cyl_interpol3D_coeff_arr","tags":"","loc":"proc/cyl_interpol3d_coeff_arr.html","title":"cyl_interpol3D_coeff_arr – FIDASIM"},{"text":"public subroutine interpol1D_arr(x, y, xout, yout, err, coeffs) Performs linear interpolation on a uniform 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of y real(kind=Float64), intent(in), dimension(:) :: y Values at abscissa values x : y(x) real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(out) :: yout Interpolant: y(xout) integer, intent(out), optional :: err Error code type( InterpolCoeffs1D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients Calls proc~~interpol1d_arr~~CallsGraph proc~interpol1d_arr interpol1D_arr interface~interpol_coeff interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocinterpol1d_arrCallsGraph = svgPanZoom('#procinterpol1d_arrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~interpol1d_arr~~CalledByGraph proc~interpol1d_arr interpol1D_arr interface~interpol interpol interface~interpol->proc~interpol1d_arr proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~mc_fastion_pass_grid->proc~get_distribution proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~fida_f fida_f proc~fida_f->proc~mc_fastion proc~pnpa_f pnpa_f proc~pnpa_f->proc~mc_fastion_pass_grid proc~pfida_f pfida_f proc~pfida_f->proc~mc_fastion_pass_grid proc~npa_f npa_f proc~npa_f->proc~mc_fastion program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~pnpa_f program~fidasim->proc~pfida_f program~fidasim->proc~npa_f var panprocinterpol1d_arrCalledByGraph = svgPanZoom('#procinterpol1d_arrCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpol1D_arr Source Code subroutine interpol1D_arr ( x , y , xout , yout , err , coeffs ) !+ Performs linear interpolation on a uniform 1D grid y(x) real ( Float64 ), dimension (:), intent ( in ) :: x !+ The abscissa values of `y` real ( Float64 ), dimension (:), intent ( in ) :: y !+ Values at abscissa values `x`: y(x) real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate real ( Float64 ), intent ( out ) :: yout !+ Interpolant: y(xout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs1D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients type ( InterpolCoeffs1D ) :: c integer :: i , err_status err_status = 1 if ( present ( coeffs )) then c = coeffs err_status = 0 else call interpol_coeff ( x , xout , c , err_status ) endif if ( err_status . eq . 0 ) then i = c % i yout = c % b1 * y ( i ) + c % b2 * y ( i + 1 ) else yout = 0.d0 endif if ( present ( err )) err = err_status end subroutine interpol1D_arr","tags":"","loc":"proc/interpol1d_arr.html","title":"interpol1D_arr – FIDASIM"},{"text":"public subroutine interpol2D_arr(x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:) :: z Values at the abscissa/ordinates: z(x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out) :: zout Interpolant: z(xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients Calls proc~~interpol2d_arr~~CallsGraph proc~interpol2d_arr interpol2D_arr interface~interpol_coeff interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocinterpol2d_arrCallsGraph = svgPanZoom('#procinterpol2d_arrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~interpol2d_arr~~CalledByGraph proc~interpol2d_arr interpol2D_arr interface~interpol interpol interface~interpol->proc~interpol2d_arr proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~mc_fastion_pass_grid->proc~get_distribution proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~fida_f fida_f proc~fida_f->proc~mc_fastion proc~pnpa_f pnpa_f proc~pnpa_f->proc~mc_fastion_pass_grid proc~pfida_f pfida_f proc~pfida_f->proc~mc_fastion_pass_grid proc~npa_f npa_f proc~npa_f->proc~mc_fastion program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~pnpa_f program~fidasim->proc~pfida_f program~fidasim->proc~npa_f var panprocinterpol2d_arrCalledByGraph = svgPanZoom('#procinterpol2d_arrCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpol2D_arr Source Code subroutine interpol2D_arr ( x , y , z , xout , yout , zout , err , coeffs ) !+ Performs bilinear interpolation on a 2D grid z(x,y) real ( Float64 ), dimension (:), intent ( in ) :: x !+ The abscissa values of `z` real ( Float64 ), dimension (:), intent ( in ) :: y !+ The ordinate values of `z` real ( Float64 ), dimension (:,:), intent ( in ) :: z !+ Values at the abscissa/ordinates: z(x,y) real ( Float64 ), intent ( in ) :: xout !+ The abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ The ordinate value to interpolate real ( Float64 ), intent ( out ) :: zout !+ Interpolant: z(xout,yout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs2D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients type ( InterpolCoeffs2D ) :: c integer :: i , j , err_status err_status = 1 if ( present ( coeffs )) then c = coeffs err_status = 0 else call interpol_coeff ( x , y , xout , yout , c , err_status ) endif if ( err_status . eq . 0 ) then i = c % i j = c % j zout = c % b11 * z ( i , j ) + c % b12 * z ( i , j + 1 ) + c % b21 * z ( i + 1 , j ) + c % b22 * z ( i + 1 , j + 1 ) else zout = 0.d0 endif if ( present ( err )) err = err_status end subroutine interpol2D_arr","tags":"","loc":"proc/interpol2d_arr.html","title":"interpol2D_arr – FIDASIM"},{"text":"public subroutine interpol2D_2D_arr(x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid of 2D arrays z(:,:,x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:,:,:) :: z Values at the abscissa/ordinates: z(:,:,x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out), dimension(:,:) :: zout Interpolant: z(:,:,xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients Calls proc~~interpol2d_2d_arr~~CallsGraph proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol_coeff interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocinterpol2d_2d_arrCallsGraph = svgPanZoom('#procinterpol2d_2d_arrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~interpol2d_2d_arr~~CalledByGraph proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol interpol interface~interpol->proc~interpol2d_2d_arr proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~mc_fastion_pass_grid->proc~get_distribution proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~fida_f fida_f proc~fida_f->proc~mc_fastion proc~pnpa_f pnpa_f proc~pnpa_f->proc~mc_fastion_pass_grid proc~pfida_f pfida_f proc~pfida_f->proc~mc_fastion_pass_grid proc~npa_f npa_f proc~npa_f->proc~mc_fastion program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~pnpa_f program~fidasim->proc~pfida_f program~fidasim->proc~npa_f var panprocinterpol2d_2d_arrCalledByGraph = svgPanZoom('#procinterpol2d_2d_arrCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpol2D_2D_arr Source Code subroutine interpol2D_2D_arr ( x , y , z , xout , yout , zout , err , coeffs ) !+ Performs bilinear interpolation on a 2D grid of 2D arrays z(:,:,x,y) real ( Float64 ), dimension (:), intent ( in ) :: x !+ The abscissa values of `z` real ( Float64 ), dimension (:), intent ( in ) :: y !+ The ordinate values of `z` real ( Float64 ), dimension (:,:,:,:), intent ( in ) :: z !+ Values at the abscissa/ordinates: z(:,:,x,y) real ( Float64 ), intent ( in ) :: xout !+ The abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ The ordinate value to interpolate real ( Float64 ), dimension (:,:), intent ( out ) :: zout !+ Interpolant: z(:,:,xout,yout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs2D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients type ( InterpolCoeffs2D ) :: c integer :: i , j , err_status err_status = 1 if ( present ( coeffs )) then c = coeffs err_status = 0 else call interpol_coeff ( x , y , xout , yout , c , err_status ) endif if ( err_status . eq . 0 ) then i = c % i j = c % j zout = c % b11 * z (:,:, i , j ) + c % b12 * z (:,:, i , j + 1 ) + c % b21 * z (:,:, i + 1 , j ) + c % b22 * z (:,:, i + 1 , j + 1 ) else zout = 0.0 endif if ( present ( err )) err = err_status end subroutine interpol2D_2D_arr","tags":"","loc":"proc/interpol2d_2d_arr.html","title":"interpol2D_2D_arr – FIDASIM"},{"text":"public subroutine interpol3D_arr(r, z, phi, d, rout, zout, phiout, dout, err, coeffs) Performs cylindrical interpolation on a 3D grid f(r,z,phi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: r R values real(kind=Float64), intent(in), dimension(:) :: z Z values real(kind=Float64), intent(in), dimension(:) :: phi Phi values real(kind=Float64), intent(in), dimension(:,:,:) :: d Values at r,z,phi: d(r,z,phi) real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate real(kind=Float64), intent(out) :: dout Interpolant: d(rout,zout,phiout) integer, intent(out), optional :: err Error code type( InterpolCoeffs3D ), intent(in), optional :: coeffs Precomputed Interpolation Coefficients Calls proc~~interpol3d_arr~~CallsGraph proc~interpol3d_arr interpol3D_arr interface~interpol_coeff interpol_coeff proc~interpol3d_arr->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocinterpol3d_arrCallsGraph = svgPanZoom('#procinterpol3d_arrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~interpol3d_arr~~CalledByGraph proc~interpol3d_arr interpol3D_arr interface~interpol interpol interface~interpol->proc~interpol3d_arr proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~mc_fastion_pass_grid->proc~get_distribution proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~fida_f fida_f proc~fida_f->proc~mc_fastion proc~pnpa_f pnpa_f proc~pnpa_f->proc~mc_fastion_pass_grid proc~pfida_f pfida_f proc~pfida_f->proc~mc_fastion_pass_grid proc~npa_f npa_f proc~npa_f->proc~mc_fastion program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~pnpa_f program~fidasim->proc~pfida_f program~fidasim->proc~npa_f var panprocinterpol3d_arrCalledByGraph = svgPanZoom('#procinterpol3d_arrCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpol3D_arr Source Code subroutine interpol3D_arr ( r , z , phi , d , rout , zout , phiout , dout , err , coeffs ) !+ Performs cylindrical interpolation on a 3D grid f(r,z,phi) real ( Float64 ), dimension (:), intent ( in ) :: r !+ R values real ( Float64 ), dimension (:), intent ( in ) :: z !+ Z values real ( Float64 ), dimension (:), intent ( in ) :: phi !+ Phi values real ( Float64 ), dimension (:,:,:), intent ( in ) :: d !+ Values at r,z,phi: d(r,z,phi) real ( Float64 ), intent ( in ) :: rout !+ R value to interpolate real ( Float64 ), intent ( in ) :: zout !+ Z value to interpolate real ( Float64 ), intent ( in ) :: phiout !+ Phi value to interpolate real ( Float64 ), intent ( out ) :: dout !+ Interpolant: d(rout,zout,phiout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs3D ), intent ( in ), optional :: coeffs !+ Precomputed Interpolation Coefficients type ( InterpolCoeffs3D ) :: b integer :: i , j , k , k2 , err_status integer :: nphi err_status = 1 nphi = size ( phi ) if ( present ( coeffs )) then b = coeffs if ( nphi . eq . 1 ) then b % b212 = 0 b % b222 = 0 b % b122 = 0 b % b112 = 0 b % k = 1 endif err_status = 0 else call interpol_coeff ( r , z , phi , rout , zout , phiout , b , err_status ) endif if ( err_status . eq . 0 ) then i = b % i j = b % j k = b % k if ( nphi . eq . 1 ) then k2 = min ( k + 1 , nphi ) else k2 = k + 1 endif dout = b % b111 * d ( i , j , k ) + b % b121 * d ( i , j + 1 , k ) + & b % b112 * d ( i , j , k2 ) + b % b122 * d ( i , j + 1 , k2 ) + & b % b211 * d ( i + 1 , j , k ) + b % b221 * d ( i + 1 , j + 1 , k ) + & b % b212 * d ( i + 1 , j , k2 ) + b % b222 * d ( i + 1 , j + 1 , k2 ) else dout = 0.d0 endif if ( present ( err )) err = err_status end subroutine interpol3D_arr","tags":"","loc":"proc/interpol3d_arr.html","title":"interpol3D_arr – FIDASIM"},{"text":"public subroutine interpol3D_2D_arr(r, z, phi, f, rout, zout, phiout, fout, err, coeffs) Performs cylindrical interpolation on a 3D grid of 2D arrays\n f(:,:,r,z,phi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: r R values real(kind=Float64), intent(in), dimension(:) :: z Z values real(kind=Float64), intent(in), dimension(:) :: phi Phi values real(kind=Float64), intent(in), dimension(:,:,:,:,:) :: f Values at r,z,phi: f(:,:,r,z,phi) real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate real(kind=Float64), intent(out), dimension(:,:) :: fout Interpolant: f(:,:,rout,zout,phiout) integer, intent(out), optional :: err Error code type( InterpolCoeffs3D ), intent(in), optional :: coeffs Precomputed Interpolation Coefficients Calls proc~~interpol3d_2d_arr~~CallsGraph proc~interpol3d_2d_arr interpol3D_2D_arr interface~interpol_coeff interpol_coeff proc~interpol3d_2d_arr->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocinterpol3d_2d_arrCallsGraph = svgPanZoom('#procinterpol3d_2d_arrCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~interpol3d_2d_arr~~CalledByGraph proc~interpol3d_2d_arr interpol3D_2D_arr interface~interpol interpol interface~interpol->proc~interpol3d_2d_arr proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~mc_fastion_pass_grid->proc~get_distribution proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~fida_f fida_f proc~fida_f->proc~mc_fastion proc~pnpa_f pnpa_f proc~pnpa_f->proc~mc_fastion_pass_grid proc~pfida_f pfida_f proc~pfida_f->proc~mc_fastion_pass_grid proc~npa_f npa_f proc~npa_f->proc~mc_fastion program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~pnpa_f program~fidasim->proc~pfida_f program~fidasim->proc~npa_f var panprocinterpol3d_2d_arrCalledByGraph = svgPanZoom('#procinterpol3d_2d_arrCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code interpol3D_2D_arr Source Code subroutine interpol3D_2D_arr ( r , z , phi , f , rout , zout , phiout , fout , err , coeffs ) !+ Performs cylindrical interpolation on a 3D grid of 2D arrays !+ f(:,:,r,z,phi) real ( Float64 ), dimension (:), intent ( in ) :: r !+ R values real ( Float64 ), dimension (:), intent ( in ) :: z !+ Z values real ( Float64 ), dimension (:), intent ( in ) :: phi !+ Phi values real ( Float64 ), dimension (:,:,:,:,:), intent ( in ) :: f !+ Values at r,z,phi: f(:,:,r,z,phi) real ( Float64 ), intent ( in ) :: rout !+ R value to interpolate real ( Float64 ), intent ( in ) :: zout !+ Z value to interpolate real ( Float64 ), intent ( in ) :: phiout !+ Phi value to interpolate real ( Float64 ), dimension (:,:), intent ( out ) :: fout !+ Interpolant: f(:,:,rout,zout,phiout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs3D ), intent ( in ), optional :: coeffs !+ Precomputed Interpolation Coefficients type ( InterpolCoeffs3D ) :: b integer :: i , j , k , k2 , err_status integer :: nphi err_status = 1 nphi = size ( phi ) if ( present ( coeffs )) then b = coeffs if ( nphi . eq . 1 ) then b % b212 = 0 b % b222 = 0 b % b122 = 0 b % b112 = 0 b % k = 1 endif err_status = 0 else call interpol_coeff ( r , z , phi , rout , zout , phiout , b , err_status ) endif if ( err_status . eq . 0 ) then i = b % i j = b % j k = b % k if ( nphi . eq . 1 ) then k2 = min ( k + 1 , nphi ) else k2 = k + 1 endif fout = b % b111 * f (:,:, i , j , k ) + b % b121 * f (:,:, i , j + 1 , k ) + & b % b112 * f (:,:, i , j , k2 ) + b % b122 * f (:,:, i , j + 1 , k2 ) + & b % b211 * f (:,:, i + 1 , j , k ) + b % b221 * f (:,:, i + 1 , j + 1 , k ) + & b % b212 * f (:,:, i + 1 , j , k2 ) + b % b222 * f (:,:, i + 1 , j + 1 , k2 ) else fout = 0.0 endif if ( present ( err )) err = err_status end subroutine interpol3D_2D_arr","tags":"","loc":"proc/interpol3d_2d_arr.html","title":"interpol3D_2D_arr – FIDASIM"},{"text":"public subroutine in_plasma(xyz, inp, input_coords, coeffs, uvw_out) Indicator subroutine to determine if a position is in a region where\n the plasma parameter and fields are valid/known Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: xyz Position in beam coordinates logical, intent(out) :: inp Indicates whether plasma parameters and fields are valid/known integer, intent(in), optional :: input_coords Indicates coordinate system of xyz. Beam grid (0), machine (1) and cylindrical (2) type( InterpolCoeffs3D ), intent(out), optional :: coeffs Interpolation coefficients used in calculation real(kind=Float64), intent(out), optional dimension(3) :: uvw_out Position in machine coordinates Calls proc~~in_plasma~~CallsGraph proc~in_plasma in_plasma proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~in_plasma~~CalledByGraph proc~in_plasma in_plasma proc~get_fields get_fields proc~get_fields->proc~in_plasma proc~make_beam_grid make_beam_grid proc~make_beam_grid->proc~in_plasma proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~in_plasma proc~track_cylindrical->proc~get_fields proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~in_plasma proc~fida_weights_los->proc~get_fields proc~get_plasma get_plasma proc~fida_weights_los->proc~get_plasma proc~track track proc~fida_weights_los->proc~track proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~get_plasma->proc~in_plasma proc~dcx_spec dcx_spec proc~dcx_spec->proc~in_plasma proc~dcx_spec->proc~get_plasma proc~store_photons store_photons proc~dcx_spec->proc~store_photons proc~track->proc~in_plasma proc~track->proc~get_fields proc~halo_spec halo_spec proc~halo_spec->proc~in_plasma proc~halo_spec->proc~get_plasma proc~halo_spec->proc~store_photons proc~nbi_spec nbi_spec proc~nbi_spec->proc~in_plasma proc~nbi_spec->proc~store_photons proc~get_plasma_extrema get_plasma_extrema proc~get_plasma_extrema->proc~in_plasma proc~pnpa_f pnpa_f proc~pnpa_f->proc~get_plasma proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~pnpa_f->proc~mc_fastion_pass_grid proc~attenuate attenuate proc~pnpa_f->proc~attenuate proc~store_npa store_npa proc~pnpa_f->proc~store_npa proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~read_distribution read_distribution proc~read_distribution->proc~read_mc proc~mc_fastion_pass_grid->proc~get_fields proc~attenuate->proc~get_plasma proc~ndmc ndmc proc~ndmc->proc~get_fields proc~ndmc->proc~mc_nbi proc~ndmc->proc~track program~fidasim fidasim program~fidasim->proc~make_beam_grid program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx_spec program~fidasim->proc~halo_spec program~fidasim->proc~nbi_spec program~fidasim->proc~pnpa_f program~fidasim->proc~bremsstrahlung program~fidasim->proc~read_distribution program~fidasim->proc~ndmc proc~pfida_f pfida_f program~fidasim->proc~pfida_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~pnpa_mc pnpa_mc program~fidasim->proc~pnpa_mc proc~halo halo program~fidasim->proc~halo proc~pfida_mc pfida_mc program~fidasim->proc~pfida_mc proc~dcx dcx program~fidasim->proc~dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_f fida_f program~fidasim->proc~fida_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~cold_spec cold_spec program~fidasim->proc~cold_spec proc~make_diagnostic_grids make_diagnostic_grids program~fidasim->proc~make_diagnostic_grids proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~pfida_f->proc~track_cylindrical proc~pfida_f->proc~get_plasma proc~pfida_f->proc~mc_fastion_pass_grid proc~fida_mc->proc~get_fields proc~fida_mc->proc~track proc~store_photons->proc~get_fields proc~pnpa_mc->proc~get_fields proc~pnpa_mc->proc~get_plasma proc~pnpa_mc->proc~attenuate proc~pnpa_mc->proc~store_npa proc~halo->proc~get_plasma proc~halo->proc~track proc~mc_halo mc_halo proc~halo->proc~mc_halo proc~pfida_mc->proc~get_fields proc~pfida_mc->proc~track_cylindrical proc~pfida_mc->proc~get_plasma proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~store_npa->proc~get_fields proc~npa_weights->proc~get_fields proc~npa_weights->proc~attenuate proc~get_beam_cx_rate get_beam_cx_rate proc~npa_weights->proc~get_beam_cx_rate proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~neutron_mc->proc~get_fields proc~neutron_mc->proc~get_plasma proc~mc_halo->proc~get_plasma proc~npa_f->proc~get_plasma proc~npa_f->proc~attenuate proc~npa_f->proc~store_npa proc~npa_f->proc~get_beam_cx_rate proc~npa_f->proc~mc_fastion proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~store_npa proc~npa_mc->proc~get_beam_cx_rate proc~get_beam_cx_rate->proc~get_plasma proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~cold_spec->proc~get_plasma proc~cold_spec->proc~store_photons proc~make_diagnostic_grids->proc~get_fields proc~make_diagnostic_grids->proc~track_cylindrical proc~make_diagnostic_grids->proc~track proc~make_passive_grid make_passive_grid proc~make_diagnostic_grids->proc~make_passive_grid proc~neutron_f->proc~get_fields proc~neutron_f->proc~get_plasma proc~make_passive_grid->proc~get_plasma_extrema proc~mc_fastion->proc~get_fields proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code in_plasma Source Code subroutine in_plasma ( xyz , inp , input_coords , coeffs , uvw_out ) !+ Indicator subroutine to determine if a position is in a region where !+ the plasma parameter and fields are valid/known real ( Float64 ), dimension ( 3 ), intent ( in ) :: xyz !+ Position in beam coordinates logical , intent ( out ) :: inp !+ Indicates whether plasma parameters and fields are valid/known integer , intent ( in ), optional :: input_coords !+ Indicates coordinate system of xyz. Beam grid (0), machine (1) and cylindrical (2) type ( InterpolCoeffs3D ), intent ( out ), optional :: coeffs !+ Interpolation coefficients used in calculation real ( Float64 ), dimension ( 3 ), intent ( out ), optional :: uvw_out !+ Position in machine coordinates real ( Float64 ), dimension ( 3 ) :: uvw type ( InterpolCoeffs3D ) :: b real ( Float64 ) :: R , W , mask real ( Float64 ) :: phi integer :: i , j , k , k2 , err , ics err = 1 if ( present ( input_coords )) then ics = input_coords else ics = 0 endif if ( ics . eq . 0 ) then call xyz_to_uvw ( xyz , uvw ) endif if ( ics . eq . 1 ) then uvw = xyz endif if ( ics . eq . 2 ) then call cyl_to_uvw ( xyz , uvw ) endif R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) W = uvw ( 3 ) phi = atan2 ( uvw ( 2 ), uvw ( 1 )) !! Interpolate mask value call interpol_coeff ( inter_grid % r , inter_grid % z , inter_grid % phi , R , W , phi , b , err ) inp = . False . if ( err . eq . 0 ) then i = b % i j = b % j k = b % k if ( inter_grid % nphi . eq . 1 ) then k2 = min ( k + 1 , inter_grid % nphi ) else k2 = k + 1 endif mask = b % b111 * equil % mask ( i , j , k ) + b % b112 * equil % mask ( i , j , k2 ) + & b % b121 * equil % mask ( i , j + 1 , k ) + b % b122 * equil % mask ( i , j + 1 , k2 ) + & b % b211 * equil % mask ( i + 1 , j , k ) + b % b212 * equil % mask ( i + 1 , j , k2 ) + & b % b221 * equil % mask ( i + 1 , j + 1 , k ) + b % b222 * equil % mask ( i + 1 , j + 1 , k2 ) if (( mask . ge . 0.5 ). and .( err . eq . 0 )) then inp = . True . endif endif if ( present ( coeffs )) coeffs = b if ( present ( uvw_out )) uvw_out = uvw end subroutine in_plasma","tags":"","loc":"proc/in_plasma.html","title":"in_plasma – FIDASIM"},{"text":"public subroutine get_plasma(plasma, pos, ind, input_coords, output_coords) Gets plasma parameters at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(out) :: plasma Plasma parameters at pos / ind real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices integer(kind=Int32), intent(in), optional :: input_coords Indicates coordinate system of inputs. Beam grid (0), machine (1) and cylindrical (2) integer(kind=Int32), intent(in), optional :: output_coords Indicates coordinate system of outputs. Beam grid (0), machine (1) and cylindrical (2) Calls proc~~get_plasma~~CallsGraph proc~get_plasma get_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~uvw_to_xyz uvw_to_xyz proc~get_plasma->proc~uvw_to_xyz proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~in_plasma->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocget_plasmaCallsGraph = svgPanZoom('#procget_plasmaCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_plasma~~CalledByGraph proc~get_plasma get_plasma proc~pnpa_f pnpa_f proc~pnpa_f->proc~get_plasma proc~attenuate attenuate proc~pnpa_f->proc~attenuate proc~dcx_spec dcx_spec proc~dcx_spec->proc~get_plasma proc~dcx dcx proc~dcx->proc~get_plasma proc~mc_halo mc_halo proc~dcx->proc~mc_halo proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_plasma proc~pfida_mc pfida_mc proc~pfida_mc->proc~get_plasma proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~get_plasma proc~pnpa_mc->proc~attenuate proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_plasma proc~mc_halo->proc~get_plasma proc~npa_f npa_f proc~npa_f->proc~get_plasma proc~npa_f->proc~attenuate proc~get_beam_cx_rate get_beam_cx_rate proc~npa_f->proc~get_beam_cx_rate proc~cold_spec cold_spec proc~cold_spec->proc~get_plasma proc~pfida_f pfida_f proc~pfida_f->proc~get_plasma proc~attenuate->proc~get_plasma proc~neutron_f neutron_f proc~neutron_f->proc~get_plasma proc~get_beam_cx_rate->proc~get_plasma proc~halo_spec halo_spec proc~halo_spec->proc~get_plasma proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~mc_halo proc~npa_weights npa_weights proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_rate program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~dcx program~fidasim->proc~bremsstrahlung program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~pfida_mc program~fidasim->proc~pnpa_mc program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~npa_f program~fidasim->proc~cold_spec program~fidasim->proc~pfida_f program~fidasim->proc~neutron_f program~fidasim->proc~halo_spec program~fidasim->proc~halo program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_rate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_plasma Source Code subroutine get_plasma ( plasma , pos , ind , input_coords , output_coords ) !+ Gets plasma parameters at position `pos` or [[libfida:beam_grid]] indices `ind` type ( LocalProfiles ), intent ( out ) :: plasma !+ Plasma parameters at `pos`/`ind` real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices integer ( Int32 ), intent ( in ), optional :: input_coords !+ Indicates coordinate system of inputs. Beam grid (0), machine (1) and cylindrical (2) integer ( Int32 ), intent ( in ), optional :: output_coords !+ Indicates coordinate system of outputs. Beam grid (0), machine (1) and cylindrical (2) logical :: inp type ( InterpolCoeffs3D ) :: coeffs real ( Float64 ), dimension ( 3 ) :: xyz , uvw , cyl , vrot_uvw real ( Float64 ) :: phi , s , c integer :: i , j , k , k2 , ics , ocs plasma % in_plasma = . False . if ( present ( input_coords )) then ics = input_coords else ics = 0 endif if ( present ( output_coords )) then ocs = output_coords else ocs = 0 endif if ( present ( ind )) then if ( ics . eq . 0 ) then call get_position ( ind , xyz ) endif if ( ics . eq . 2 ) then call get_position ( ind , xyz , input_coords = 2 ) endif endif if ( present ( pos )) then if ( ics . eq . 0 ) then xyz = pos call xyz_to_uvw ( xyz , uvw ) endif if ( ics . eq . 1 ) then uvw = pos call uvw_to_xyz ( uvw , xyz ) endif endif call in_plasma ( xyz , inp , 0 , coeffs ) if ( inp ) then phi = atan2 ( uvw ( 2 ), uvw ( 1 )) i = coeffs % i j = coeffs % j k = coeffs % k if ( inter_grid % nphi . eq . 1 ) then k2 = min ( k + 1 , inter_grid % nphi ) else k2 = k + 1 endif plasma = coeffs % b111 * equil % plasma ( i , j , k ) + coeffs % b121 * equil % plasma ( i , j + 1 , k ) + & coeffs % b112 * equil % plasma ( i , j , k2 ) + coeffs % b122 * equil % plasma ( i , j + 1 , k2 ) + & coeffs % b211 * equil % plasma ( i + 1 , j , k ) + coeffs % b221 * equil % plasma ( i + 1 , j + 1 , k ) + & coeffs % b212 * equil % plasma ( i + 1 , j , k2 ) + coeffs % b222 * equil % plasma ( i + 1 , j + 1 , k2 ) s = sin ( phi ) ; c = cos ( phi ) vrot_uvw ( 1 ) = plasma % vr * c - plasma % vt * s vrot_uvw ( 2 ) = plasma % vr * s + plasma % vt * c vrot_uvw ( 3 ) = plasma % vz if ( ocs . eq . 0 ) then plasma % vrot = matmul ( beam_grid % inv_basis , vrot_uvw ) plasma % pos = xyz endif if ( ocs . eq . 1 ) then plasma % vrot = vrot_uvw plasma % pos = uvw endif plasma % uvw = uvw plasma % in_plasma = . True . plasma % b = coeffs endif end subroutine get_plasma","tags":"","loc":"proc/get_plasma.html","title":"get_plasma – FIDASIM"},{"text":"public subroutine calc_perp_vectors(b, a, c) Calculates normalized vectors that are perpendicular to b\n such that a x c = b_norm Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: b real(kind=Float64), intent(out), dimension(3) :: a real(kind=Float64), intent(out), dimension(3) :: c Called by proc~~calc_perp_vectors~~CalledByGraph proc~calc_perp_vectors calc_perp_vectors proc~get_fields get_fields proc~get_fields->proc~calc_perp_vectors proc~lflf_subtract lflf_subtract proc~lflf_subtract->proc~calc_perp_vectors proc~lflf_add lflf_add proc~lflf_add->proc~calc_perp_vectors proc~fida_mc fida_mc proc~fida_mc->proc~get_fields proc~track track proc~fida_mc->proc~track proc~store_photons store_photons proc~store_photons->proc~get_fields proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~get_fields proc~store_npa store_npa proc~store_npa->proc~get_fields proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~mc_fastion_pass_grid->proc~get_fields proc~track->proc~get_fields proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~track interface~operator(-) operator(-) interface~operator(-)->proc~lflf_subtract proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~get_fields proc~pnpa_mc->proc~store_npa proc~ndmc ndmc proc~ndmc->proc~get_fields proc~ndmc->proc~track proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~get_fields proc~make_diagnostic_grids->proc~track_cylindrical proc~make_diagnostic_grids->proc~track proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_fields interface~operator(+) operator(+) interface~operator(+)->proc~lflf_add proc~npa_mc npa_mc proc~npa_mc->proc~get_fields proc~npa_mc->proc~store_npa proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~pfida_mc pfida_mc proc~pfida_mc->proc~get_fields proc~pfida_mc->proc~track_cylindrical proc~npa_weights npa_weights proc~npa_weights->proc~get_fields proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_fields proc~neutron_f neutron_f proc~neutron_f->proc~get_fields proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~track proc~pnpa_f pnpa_f proc~pnpa_f->proc~store_npa proc~pnpa_f->proc~mc_fastion_pass_grid proc~dcx_spec dcx_spec proc~dcx_spec->proc~store_photons proc~dcx dcx proc~dcx->proc~track proc~halo_spec halo_spec proc~halo_spec->proc~store_photons proc~fida_f fida_f proc~fida_f->proc~track proc~fida_f->proc~mc_fastion proc~cold_spec cold_spec proc~cold_spec->proc~store_photons proc~nbi_spec nbi_spec proc~nbi_spec->proc~store_photons proc~npa_f npa_f proc~npa_f->proc~store_npa proc~npa_f->proc~mc_fastion proc~halo halo proc~halo->proc~track program~fidasim fidasim program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~pnpa_mc program~fidasim->proc~ndmc program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~neutron_mc program~fidasim->proc~npa_mc program~fidasim->proc~pfida_mc program~fidasim->proc~npa_weights program~fidasim->proc~neutron_f program~fidasim->proc~fida_weights_mc program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~dcx program~fidasim->proc~halo_spec program~fidasim->proc~fida_f program~fidasim->proc~cold_spec program~fidasim->proc~nbi_spec program~fidasim->proc~npa_f program~fidasim->proc~halo proc~pfida_f pfida_f program~fidasim->proc~pfida_f proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~pfida_f->proc~track_cylindrical proc~pfida_f->proc~mc_fastion_pass_grid proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code calc_perp_vectors Source Code subroutine calc_perp_vectors ( b , a , c ) !+ Calculates normalized vectors that are perpendicular to b !+ such that `a` x `c` = `b_norm` real ( Float64 ), dimension ( 3 ), intent ( in ) :: b real ( Float64 ), dimension ( 3 ), intent ( out ) :: a real ( Float64 ), dimension ( 3 ), intent ( out ) :: c real ( Float64 ), dimension ( 3 ) :: bnorm bnorm = b / norm2 ( b ) if ( abs ( bnorm ( 3 )). eq . 1 ) then a = [ 1.d0 , 0.d0 , 0.d0 ] c = [ 0.d0 , 1.d0 , 0.d0 ] else if ( bnorm ( 3 ). eq . 0. ) then a = [ 0.d0 , 0.d0 , 1.d0 ] c = [ bnorm ( 2 ), - bnorm ( 1 ), 0.d0 ] / sqrt ( bnorm ( 1 ) ** 2 + bnorm ( 2 ) ** 2 ) else a = [ bnorm ( 2 ), - bnorm ( 1 ), 0.d0 ] / sqrt ( bnorm ( 1 ) ** 2 + bnorm ( 2 ) ** 2 ) c =- [ a ( 2 ) , - a ( 1 ) , ( a ( 1 ) * bnorm ( 2 ) - a ( 2 ) * bnorm ( 1 )) / bnorm ( 3 ) ] c = c / norm2 ( c ) if ( bnorm ( 3 ). lt . 0.0 ) then c =- c endif endif endif end subroutine calc_perp_vectors","tags":"","loc":"proc/calc_perp_vectors.html","title":"calc_perp_vectors – FIDASIM"},{"text":"public subroutine get_fields(fields, pos, ind, input_coords, output_coords) Gets electro-magnetic fields at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(out) :: fields Electro-magnetic fields at pos / ind real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices integer(kind=Int32), intent(in), optional :: input_coords Indicates coordinate system of inputs. Beam grid (0), machine (1) and cylindrical (2) integer(kind=Int32), intent(in), optional :: output_coords Indicates coordinate system of outputs. Beam grid (0), machine (1) and cylindrical (2) Calls proc~~get_fields~~CallsGraph proc~get_fields get_fields proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocget_fieldsCallsGraph = svgPanZoom('#procget_fieldsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_fields~~CalledByGraph proc~get_fields get_fields proc~fida_mc fida_mc proc~fida_mc->proc~get_fields proc~track track proc~fida_mc->proc~track proc~store_photons store_photons proc~store_photons->proc~get_fields proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~get_fields proc~store_npa store_npa proc~store_npa->proc~get_fields proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~mc_fastion_pass_grid->proc~get_fields proc~track->proc~get_fields proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~track proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~get_fields proc~pnpa_mc->proc~store_npa proc~ndmc ndmc proc~ndmc->proc~get_fields proc~ndmc->proc~track proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~get_fields proc~make_diagnostic_grids->proc~track_cylindrical proc~make_diagnostic_grids->proc~track proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_fields proc~npa_mc npa_mc proc~npa_mc->proc~get_fields proc~npa_mc->proc~store_npa proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~pfida_mc pfida_mc proc~pfida_mc->proc~get_fields proc~pfida_mc->proc~track_cylindrical proc~npa_weights npa_weights proc~npa_weights->proc~get_fields proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_fields proc~neutron_f neutron_f proc~neutron_f->proc~get_fields proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~track proc~pnpa_f pnpa_f proc~pnpa_f->proc~store_npa proc~pnpa_f->proc~mc_fastion_pass_grid proc~dcx_spec dcx_spec proc~dcx_spec->proc~store_photons proc~dcx dcx proc~dcx->proc~track proc~halo_spec halo_spec proc~halo_spec->proc~store_photons proc~fida_f fida_f proc~fida_f->proc~track proc~fida_f->proc~mc_fastion proc~cold_spec cold_spec proc~cold_spec->proc~store_photons proc~nbi_spec nbi_spec proc~nbi_spec->proc~store_photons proc~npa_f npa_f proc~npa_f->proc~store_npa proc~npa_f->proc~mc_fastion proc~halo halo proc~halo->proc~track program~fidasim fidasim program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~pnpa_mc program~fidasim->proc~ndmc program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~neutron_mc program~fidasim->proc~npa_mc program~fidasim->proc~pfida_mc program~fidasim->proc~npa_weights program~fidasim->proc~neutron_f program~fidasim->proc~fida_weights_mc program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~dcx program~fidasim->proc~halo_spec program~fidasim->proc~fida_f program~fidasim->proc~cold_spec program~fidasim->proc~nbi_spec program~fidasim->proc~npa_f program~fidasim->proc~halo proc~pfida_f pfida_f program~fidasim->proc~pfida_f proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~pfida_f->proc~track_cylindrical proc~pfida_f->proc~mc_fastion_pass_grid proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_fields Source Code subroutine get_fields ( fields , pos , ind , input_coords , output_coords ) !+ Gets electro-magnetic fields at position `pos` or [[libfida:beam_grid]] indices `ind` type ( LocalEMFields ), intent ( out ) :: fields !+ Electro-magnetic fields at `pos`/`ind` real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices integer ( Int32 ), intent ( in ), optional :: input_coords !+ Indicates coordinate system of inputs. Beam grid (0), machine (1) and cylindrical (2) integer ( Int32 ), intent ( in ), optional :: output_coords !+ Indicates coordinate system of outputs. Beam grid (0), machine (1) and cylindrical (2) logical :: inp real ( Float64 ), dimension ( 3 ) :: xyz , uvw real ( Float64 ), dimension ( 3 ) :: uvw_bfield , uvw_efield real ( Float64 ), dimension ( 3 ) :: xyz_bfield , xyz_efield real ( Float64 ) :: phi , s , c type ( InterpolCoeffs3D ) :: coeffs integer :: i , j , k , k2 , mc , ocs , ics fields % in_plasma = . False . if ( present ( input_coords )) then ics = input_coords else ics = 0 endif if ( present ( output_coords )) then ocs = output_coords else ocs = 0 endif if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) then if ( ics . eq . 0 ) then xyz = pos call xyz_to_uvw ( xyz , uvw ) endif if ( ics . eq . 1 ) then uvw = pos call uvw_to_xyz ( uvw , xyz ) endif endif call in_plasma ( xyz , inp , 0 , coeffs ) if ( inp ) then i = coeffs % i j = coeffs % j k = coeffs % k if ( inter_grid % nphi . eq . 1 ) then k2 = min ( k + 1 , inter_grid % nphi ) else k2 = k + 1 endif fields = coeffs % b111 * equil % fields ( i , j , k ) + coeffs % b121 * equil % fields ( i , j + 1 , k ) + & coeffs % b112 * equil % fields ( i , j , k2 ) + coeffs % b122 * equil % fields ( i , j + 1 , k2 ) + & coeffs % b211 * equil % fields ( i + 1 , j , k ) + coeffs % b221 * equil % fields ( i + 1 , j + 1 , k ) + & coeffs % b212 * equil % fields ( i + 1 , j , k2 ) + coeffs % b222 * equil % fields ( i + 1 , j + 1 , k2 ) phi = atan2 ( uvw ( 2 ), uvw ( 1 )) s = sin ( phi ) ; c = cos ( phi ) !Convert cylindrical coordinates to uvw uvw_bfield ( 1 ) = c * fields % br - s * fields % bt uvw_bfield ( 2 ) = s * fields % br + c * fields % bt uvw_bfield ( 3 ) = fields % bz uvw_efield ( 1 ) = c * fields % er - s * fields % et uvw_efield ( 2 ) = s * fields % er + c * fields % et uvw_efield ( 3 ) = fields % ez if ( ocs . eq . 0 ) then !Represent fields in beam grid coordinates xyz_bfield = matmul ( beam_grid % inv_basis , uvw_bfield ) xyz_efield = matmul ( beam_grid % inv_basis , uvw_efield ) fields % pos = xyz endif if ( ocs . eq . 1 ) then xyz_bfield = uvw_bfield xyz_efield = uvw_efield fields % pos = uvw endif !Calculate field directions and magnitudes fields % b_abs = norm2 ( xyz_bfield ) fields % e_abs = norm2 ( xyz_efield ) if ( fields % b_abs . gt . 0.d0 ) fields % b_norm = xyz_bfield / fields % b_abs if ( fields % e_abs . gt . 0.d0 ) fields % e_norm = xyz_efield / fields % e_abs call calc_perp_vectors ( fields % b_norm , fields % a_norm , fields % c_norm ) fields % uvw = uvw fields % in_plasma = . True . fields % coords = ocs fields % b = coeffs endif end subroutine get_fields","tags":"","loc":"proc/get_fields.html","title":"get_fields – FIDASIM"},{"text":"public subroutine get_distribution(fbeam, denf, pos, ind, coeffs) Gets Guiding Center distribution at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:,:) :: fbeam Guiding Center Fast-ion distribution at pos / ind : F(E,p) real(kind=Float64), intent(out) :: denf Guiding Center Fast-ion density at pos / ind [fast-ions/cm&#94;3] real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices type( InterpolCoeffs3D ), intent(in), optional :: coeffs Precomputed interpolation coefficients Calls proc~~get_distribution~~CallsGraph proc~get_distribution get_distribution interface~interpol interpol proc~get_distribution->interface~interpol proc~xyz_to_uvw xyz_to_uvw proc~get_distribution->proc~xyz_to_uvw proc~interpol3d_arr interpol3D_arr interface~interpol->proc~interpol3d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol3d_2d_arr interpol3D_2D_arr interface~interpol->proc~interpol3d_2d_arr interface~interpol_coeff interpol_coeff proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol3d_2d_arr->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocget_distributionCallsGraph = svgPanZoom('#procget_distributionCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_distribution~~CalledByGraph proc~get_distribution get_distribution proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~mc_fastion_pass_grid->proc~get_distribution proc~fida_f fida_f proc~fida_f->proc~mc_fastion proc~pnpa_f pnpa_f proc~pnpa_f->proc~mc_fastion_pass_grid proc~pfida_f pfida_f proc~pfida_f->proc~mc_fastion_pass_grid proc~npa_f npa_f proc~npa_f->proc~mc_fastion program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~pnpa_f program~fidasim->proc~pfida_f program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_distribution Source Code subroutine get_distribution ( fbeam , denf , pos , ind , coeffs ) !+ Gets Guiding Center distribution at position `pos` or [[libfida:beam_grid]] indices `ind` real ( Float64 ), dimension (:,:), intent ( out ) :: fbeam !+ Guiding Center Fast-ion distribution at `pos`/`ind`: F(E,p) real ( Float64 ), intent ( out ) :: denf !+ Guiding Center Fast-ion density at `pos`/`ind` [fast-ions/cm&#94;3] real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices type ( InterpolCoeffs3D ), intent ( in ), optional :: coeffs !+ Precomputed interpolation coefficients real ( Float64 ), dimension ( 3 ) :: xyz , uvw real ( Float64 ) :: R , Z , Phi integer :: err if ( present ( coeffs )) then call interpol ( fbm % r , fbm % z , fbm % phi , fbm % f , R , Z , Phi , fbeam , err , coeffs ) call interpol ( fbm % r , fbm % z , fbm % phi , fbm % denf , R , Z , Phi , denf , err , coeffs ) else if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) Z = uvw ( 3 ) Phi = atan2 ( uvw ( 2 ), uvw ( 1 )) call interpol ( fbm % r , fbm % z , fbm % phi , fbm % f , R , Z , Phi , fbeam , err ) call interpol ( fbm % r , fbm % z , fbm % phi , fbm % denf , R , Z , Phi , denf , err ) endif end subroutine get_distribution","tags":"","loc":"proc/get_distribution.html","title":"get_distribution – FIDASIM"},{"text":"public subroutine get_ep_denf(energy, pitch, denf, pos, ind, coeffs) Get guiding center fast-ion density at given energy and pitch\n at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: energy Energy [keV] real(kind=Float64), intent(in) :: pitch Pitch real(kind=Float64), intent(out) :: denf Fast-ion density [fast-ions/(cm&#94;3 dE dp)] real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices type( InterpolCoeffs3D ), intent(in), optional :: coeffs Precomputed interpolation coefficients Calls proc~~get_ep_denf~~CallsGraph proc~get_ep_denf get_ep_denf interface~interpol interpol proc~get_ep_denf->interface~interpol proc~xyz_to_uvw xyz_to_uvw proc~get_ep_denf->proc~xyz_to_uvw proc~interpol3d_arr interpol3D_arr interface~interpol->proc~interpol3d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol3d_2d_arr interpol3D_2D_arr interface~interpol->proc~interpol3d_2d_arr interface~interpol_coeff interpol_coeff proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol3d_2d_arr->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocget_ep_denfCallsGraph = svgPanZoom('#procget_ep_denfCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_ep_denf~~CalledByGraph proc~get_ep_denf get_ep_denf proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf program~fidasim fidasim program~fidasim->proc~fida_weights_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_ep_denf Source Code subroutine get_ep_denf ( energy , pitch , denf , pos , ind , coeffs ) !+ Get guiding center fast-ion density at given energy and pitch !+ at position `pos` or [[libfida:beam_grid]] indices `ind` real ( Float64 ), intent ( in ) :: energy !+ Energy [keV] real ( Float64 ), intent ( in ) :: pitch !+ Pitch real ( Float64 ), intent ( out ) :: denf !+ Fast-ion density [fast-ions/(cm&#94;3*dE*dp)] real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices type ( InterpolCoeffs3D ), intent ( in ), optional :: coeffs !+ Precomputed interpolation coefficients real ( Float64 ), dimension ( 3 ) :: xyz , uvw real ( Float64 ), dimension ( fbm % nenergy , fbm % npitch ) :: fbeam integer ( Int32 ), dimension ( 2 ) :: epi real ( Float64 ) :: R , Phi , Z real ( Float64 ) :: dE , dp integer :: err epi ( 1 ) = minloc ( abs ( fbm % energy - energy ), 1 ) epi ( 2 ) = minloc ( abs ( fbm % pitch - pitch ), 1 ) dE = abs ( fbm % energy ( epi ( 1 )) - energy ) dp = abs ( fbm % pitch ( epi ( 2 )) - pitch ) if (( dE . le . fbm % dE ). and .( dp . le . fbm % dp )) then if ( present ( coeffs )) then call interpol ( inter_grid % r , inter_grid % z , inter_grid % phi , fbm % f , R , Z , Phi , fbeam , err , coeffs ) else if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) Z = uvw ( 3 ) Phi = atan2 ( uvw ( 2 ), uvw ( 1 )) call interpol ( inter_grid % r , inter_grid % z , inter_grid % phi , fbm % f , R , Z , Phi , fbeam , err ) endif denf = fbeam ( epi ( 1 ), epi ( 2 )) else denf = 0.0 endif end subroutine get_ep_denf","tags":"","loc":"proc/get_ep_denf.html","title":"get_ep_denf – FIDASIM"},{"text":"public subroutine store_neutrals(ind, neut_type, dens, vn, store_iter) Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind beam_grid indices integer, intent(in) :: neut_type Neutral type real(kind=Float64), intent(in), dimension(:) :: dens Neutral density [neutrals/cm&#94;3] real(kind=Float64), intent(in), dimension(3) :: vn Neutral particle velocity [cm/s] logical, intent(in), optional :: store_iter Store DCX/Halo iteration density in halo_iter_dens Called by proc~~store_neutrals~~CalledByGraph proc~store_neutrals store_neutrals proc~ndmc ndmc proc~ndmc->proc~store_neutrals program~fidasim fidasim program~fidasim->proc~ndmc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code store_neutrals Source Code subroutine store_neutrals ( ind , neut_type , dens , vn , store_iter ) !Store neutrals in [[libfida:neut]] at indices `ind` integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices integer , intent ( in ) :: neut_type !+ Neutral type real ( Float64 ), dimension (:), intent ( in ) :: dens !+ Neutral density [neutrals/cm&#94;3] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vn !+ Neutral particle velocity [cm/s] logical , intent ( in ), optional :: store_iter !+ Store DCX/Halo iteration density in [[libfida:halo_iter_dens]] logical :: iter integer :: i , j , k if ( present ( store_iter )) then iter = store_iter else iter = . False . endif i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) !$OMP CRITICAL(store_neutrals_1) if ( iter ) halo_iter_dens ( neut_type ) = halo_iter_dens ( neut_type ) + sum ( dens ) select case ( neut_type ) case ( nbif_type ) neut % full (:, i , j , k ) = neut % full (:, i , j , k ) + dens case ( nbih_type ) neut % half (:, i , j , k ) = neut % half (:, i , j , k ) + dens case ( nbit_type ) neut % third (:, i , j , k ) = neut % third (:, i , j , k ) + dens case ( dcx_type ) neut % dcx (:, i , j , k ) = neut % dcx (:, i , j , k ) + dens case ( halo_type ) neut % halo (:, i , j , k ) = neut % halo (:, i , j , k ) + dens case default if ( inputs % verbose . ge . 0 ) then write ( * , '(\"STORE_NEUTRALS: Unknown neutral type: \",i2)' ) neut_type endif stop end select !$OMP END CRITICAL(store_neutrals_1) end subroutine store_neutrals","tags":"","loc":"proc/store_neutrals.html","title":"store_neutrals – FIDASIM"},{"text":"public subroutine store_births(ind, neut_type, dflux) Store birth particles/density in birth Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind beam_grid indices integer(kind=Int32), intent(in) :: neut_type Neutral type real(kind=Float64), intent(in) :: dflux Deposited flux Contents Source Code store_births Source Code subroutine store_births ( ind , neut_type , dflux ) !+ Store birth particles/density in [[libfida:birth]] integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices integer ( Int32 ), intent ( in ) :: neut_type !+ Neutral type real ( Float64 ), intent ( in ) :: dflux !+ Deposited flux !$OMP ATOMIC UPDATE birth % dens ( neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) = & birth % dens ( neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) + dflux !$OMP END ATOMIC end subroutine store_births","tags":"","loc":"proc/store_births.html","title":"store_births – FIDASIM"},{"text":"public subroutine store_npa(det, ri, rf, vn, flux, orbit_class, passive) Store NPA particles in npa Arguments Type Intent Optional Attributes Name integer, intent(in) :: det Detector/Channel Number real(kind=Float64), intent(in), dimension(3) :: ri Birth position in beam coordinates [cm] real(kind=Float64), intent(in), dimension(3) :: rf Detector position in beam coordinates [cm] real(kind=Float64), intent(in), dimension(3) :: vn Particle velocity [cm/s] real(kind=Float64), intent(in) :: flux Neutral flux [neutrals/s] integer, intent(in), optional :: orbit_class Orbit class ID logical, intent(in), optional :: passive Indicates whether npa particle is passive Calls proc~~store_npa~~CallsGraph proc~store_npa store_npa proc~get_fields get_fields proc~store_npa->proc~get_fields proc~xyz_to_uvw xyz_to_uvw proc~store_npa->proc~xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~in_plasma->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocstore_npaCallsGraph = svgPanZoom('#procstore_npaCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~store_npa~~CalledByGraph proc~store_npa store_npa proc~pnpa_f pnpa_f proc~pnpa_f->proc~store_npa proc~npa_mc npa_mc proc~npa_mc->proc~store_npa proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~store_npa proc~npa_f npa_f proc~npa_f->proc~store_npa program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~npa_mc program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code store_npa Source Code subroutine store_npa ( det , ri , rf , vn , flux , orbit_class , passive ) !+ Store NPA particles in [[libfida:npa]] integer , intent ( in ) :: det !+ Detector/Channel Number real ( Float64 ), dimension ( 3 ), intent ( in ) :: ri !+ Birth position in beam coordinates [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: rf !+ Detector position in beam coordinates [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vn !+ Particle velocity [cm/s] real ( Float64 ), intent ( in ) :: flux !+ Neutral flux [neutrals/s] integer , intent ( in ), optional :: orbit_class !+ Orbit class ID logical , intent ( in ), optional :: passive !+ Indicates whether npa particle is passive integer :: iclass , oclass type ( LocalEMFields ) :: fields real ( Float64 ), dimension ( 3 ) :: uvw_ri , uvw_rf , vn_norm real ( Float64 ) :: energy , pitch , dE integer ( Int32 ), dimension ( 1 ) :: ienergy type ( NPAParticle ), dimension (:), allocatable :: parts logical :: pas = . False . if ( present ( orbit_class )) then iclass = min ( orbit_class , particles % nclass ) oclass = orbit_class else iclass = 1 oclass = 1 endif if ( present ( passive )) pas = passive ! Convert to machine coordinates call xyz_to_uvw ( ri , uvw_ri ) call xyz_to_uvw ( rf , uvw_rf ) ! Calculate energy energy = inputs % ab * v2_to_E_per_amu * dot_product ( vn , vn ) if ( pas ) then dE = pnpa % energy ( 2 ) - pnpa % energy ( 1 ) else dE = npa % energy ( 2 ) - npa % energy ( 1 ) endif ! Calculate pitch if distribution actually uses pitch if ( inputs % dist_type . le . 2 ) then call get_fields ( fields , pos = ri ) vn_norm = vn / norm2 ( vn ) pitch = dot_product ( fields % b_norm , vn_norm ) else pitch = 0.d0 endif if ( pas ) then !$OMP CRITICAL(store_npa_1) pnpa % npart = pnpa % npart + 1 if ( pnpa % npart . gt . pnpa % nmax ) then pnpa % nmax = int ( pnpa % nmax * 2 ) allocate ( parts ( pnpa % nmax )) parts ( 1 :( pnpa % npart - 1 )) = pnpa % part deallocate ( pnpa % part ) call move_alloc ( parts , pnpa % part ) endif pnpa % part ( pnpa % npart )% detector = det pnpa % part ( pnpa % npart )% class = oclass pnpa % part ( pnpa % npart )% xi = uvw_ri ( 1 ) pnpa % part ( pnpa % npart )% yi = uvw_ri ( 2 ) pnpa % part ( pnpa % npart )% zi = uvw_ri ( 3 ) pnpa % part ( pnpa % npart )% xf = uvw_rf ( 1 ) pnpa % part ( pnpa % npart )% yf = uvw_rf ( 2 ) pnpa % part ( pnpa % npart )% zf = uvw_rf ( 3 ) pnpa % part ( pnpa % npart )% energy = energy pnpa % part ( pnpa % npart )% pitch = pitch pnpa % part ( pnpa % npart )% weight = flux ienergy = minloc ( abs ( pnpa % energy - energy )) pnpa % flux ( ienergy ( 1 ), det , iclass ) = & pnpa % flux ( ienergy ( 1 ), det , iclass ) + flux / dE !$OMP END CRITICAL(store_npa_1) else !$OMP CRITICAL(store_npa_2) npa % npart = npa % npart + 1 if ( npa % npart . gt . npa % nmax ) then npa % nmax = int ( npa % nmax * 2 ) allocate ( parts ( npa % nmax )) parts ( 1 :( npa % npart - 1 )) = npa % part deallocate ( npa % part ) call move_alloc ( parts , npa % part ) endif npa % part ( npa % npart )% detector = det npa % part ( npa % npart )% class = oclass npa % part ( npa % npart )% xi = uvw_ri ( 1 ) npa % part ( npa % npart )% yi = uvw_ri ( 2 ) npa % part ( npa % npart )% zi = uvw_ri ( 3 ) npa % part ( npa % npart )% xf = uvw_rf ( 1 ) npa % part ( npa % npart )% yf = uvw_rf ( 2 ) npa % part ( npa % npart )% zf = uvw_rf ( 3 ) npa % part ( npa % npart )% energy = energy npa % part ( npa % npart )% pitch = pitch npa % part ( npa % npart )% weight = flux ienergy = minloc ( abs ( npa % energy - energy )) npa % flux ( ienergy ( 1 ), det , iclass ) = & npa % flux ( ienergy ( 1 ), det , iclass ) + flux / dE !$OMP END CRITICAL(store_npa_2) endif end subroutine store_npa","tags":"","loc":"proc/store_npa.html","title":"store_npa – FIDASIM"},{"text":"public subroutine bb_cx_rates(denn, vi, vn, rates) Get beam-beam neutralization/cx rates Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(nlevs) :: denn Neutral density [cm&#94;-3] real(kind=Float64), intent(in), dimension(3) :: vi Ion velocity [cm/s] real(kind=Float64), intent(in), dimension(3) :: vn Neutral velocity [cm/s] real(kind=Float64), intent(out), dimension(nlevs) :: rates Reaction rates [1/s] Calls proc~~bb_cx_rates~~CallsGraph proc~bb_cx_rates bb_cx_rates interface~interpol_coeff interpol_coeff proc~bb_cx_rates->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bb_cx_rates~~CalledByGraph proc~bb_cx_rates bb_cx_rates proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~bb_cx_rates proc~get_beam_cx_rate get_beam_cx_rate proc~get_beam_cx_rate->proc~bb_cx_rates proc~npa_weights npa_weights proc~npa_weights->proc~get_beam_cx_rate proc~npa_f npa_f proc~npa_f->proc~get_beam_cx_rate program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~npa_weights program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_mc->proc~get_beam_cx_rate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code bb_cx_rates Source Code subroutine bb_cx_rates ( denn , vi , vn , rates ) !+ Get beam-beam neutralization/cx rates real ( Float64 ), dimension ( nlevs ), intent ( in ) :: denn !+ Neutral density [cm&#94;-3] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Ion velocity [cm/s] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vn !+ Neutral velocity [cm/s] real ( Float64 ), dimension ( nlevs ), intent ( out ) :: rates !+ Reaction rates [1/s] real ( Float64 ), dimension ( nlevs , nlevs ) :: neut !!rate coeff real ( Float64 ) :: eb !! relative Energy type ( InterpolCoeffs1D ) :: c real ( Float64 ) :: dlogE , logEmin , logeb real ( Float64 ) :: vrel !! relative velocity integer :: ebi , neb , err !Eeff vrel = norm2 ( vi - vn ) eb = v2_to_E_per_amu * vrel ** 2 ! [kev/amu] logeb = log10 ( eb ) logEmin = tables % H_H_cx_cross % logemin dlogE = tables % H_H_cx_cross % dlogE neb = tables % H_H_cx_cross % nenergy call interpol_coeff ( logEmin , dlogE , neb , logeb , c , err ) ebi = c % i if ( err . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"BB_CX_RATES: Eb out of range of H_H_cx table. Using nearest energy value.\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb endif if ( ebi . lt . 1 ) then ebi = 1 c % b1 = 1.0 ; c % b2 = 0.0 else ebi = neb - 1 c % b1 = 0.0 ; c % b2 = 1.0 endif endif neut (:,:) = ( c % b1 * tables % H_H_cx_cross % log_cross (:,:, ebi ) + & c % b2 * tables % H_H_cx_cross % log_cross (:,:, ebi + 1 )) where ( neut . lt . tables % H_H_cx_cross % minlog_cross ) neut = 0.d0 elsewhere neut = exp ( neut * log_10 ) end where rates = matmul ( neut , denn ) * vrel end subroutine bb_cx_rates","tags":"","loc":"proc/bb_cx_rates.html","title":"bb_cx_rates – FIDASIM"},{"text":"public subroutine bt_cx_rates(plasma, denn, vi, i_type, rates) Get beam-target neutralization/cx rates Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma Plasma parameters real(kind=Float64), intent(in), dimension(nlevs) :: denn Neutral density [cm&#94;-3] real(kind=Float64), intent(in), dimension(3) :: vi Ion velocity [cm/s] integer, intent(in) :: i_type Ion type real(kind=Float64), intent(out), dimension(nlevs) :: rates Reaction rates [1/s] Calls proc~~bt_cx_rates~~CallsGraph proc~bt_cx_rates bt_cx_rates interface~interpol_coeff interpol_coeff proc~bt_cx_rates->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bt_cx_rates~~CalledByGraph proc~bt_cx_rates bt_cx_rates proc~pnpa_f pnpa_f proc~pnpa_f->proc~bt_cx_rates proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~bt_cx_rates proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~bt_cx_rates proc~get_beam_cx_rate get_beam_cx_rate proc~get_beam_cx_rate->proc~bt_cx_rates proc~pfida_f pfida_f proc~pfida_f->proc~bt_cx_rates proc~pfida_mc pfida_mc proc~pfida_mc->proc~bt_cx_rates proc~npa_weights npa_weights proc~npa_weights->proc~get_beam_cx_rate proc~npa_f npa_f proc~npa_f->proc~get_beam_cx_rate program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~fida_weights_los program~fidasim->proc~pnpa_mc program~fidasim->proc~pfida_f program~fidasim->proc~pfida_mc program~fidasim->proc~npa_weights program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_mc->proc~get_beam_cx_rate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code bt_cx_rates Source Code subroutine bt_cx_rates ( plasma , denn , vi , i_type , rates ) !+ Get beam-target neutralization/cx rates type ( LocalProfiles ), intent ( in ) :: plasma !+ Plasma parameters real ( Float64 ), dimension ( nlevs ), intent ( in ) :: denn !+ Neutral density [cm&#94;-3] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Ion velocity [cm/s] integer , intent ( in ) :: i_type !+ Ion type real ( Float64 ), dimension ( nlevs ), intent ( out ) :: rates !+ Reaction rates [1/s] real ( Float64 ) :: logEmin , dlogE , logeb , eb real ( Float64 ) :: logTmin , dlogT , logti , vrel integer :: neb , nt type ( InterpolCoeffs2D ) :: c real ( Float64 ) :: b11 , b12 , b21 , b22 , b_amu real ( Float64 ), dimension ( nlevs , nlevs ) :: H_H_rate integer :: ebi , tii , n , err_status H_H_rate = 0.d0 if ( i_type . eq . beam_ion ) then b_amu = inputs % ab else b_amu = inputs % ai endif vrel = norm2 ( vi - plasma % vrot ) eb = b_amu * v2_to_E_per_amu * vrel ** 2 ! [kev/amu] logeb = log10 ( eb ) logti = log10 ( plasma % ti ) !!H_H err_status = 1 logEmin = tables % H_H_cx_rate % logemin logTmin = tables % H_H_cx_rate % logtmin dlogE = tables % H_H_cx_rate % dlogE dlogT = tables % H_H_cx_rate % dlogT neb = tables % H_H_cx_rate % nenergy nt = tables % H_H_cx_rate % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , c , err_status ) ebi = c % i tii = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"BT_CX_RATES: Eb or Ti out of range of H_H_CX table. Setting H_H_CX rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",ES10.3,\" [keV]\")' ) plasma % ti endif rates = 0.0 return endif H_H_rate = ( b11 * tables % H_H_cx_rate % log_rate (:,:, ebi , tii , i_type ) + & b12 * tables % H_H_cx_rate % log_rate (:,:, ebi , tii + 1 , i_type ) + & b21 * tables % H_H_cx_rate % log_rate (:,:, ebi + 1 , tii , i_type ) + & b22 * tables % H_H_cx_rate % log_rate (:,:, ebi + 1 , tii + 1 , i_type )) where ( H_H_rate . lt . tables % H_H_cx_rate % minlog_rate ) H_H_rate = 0.d0 elsewhere H_H_rate = exp ( H_H_rate * log_10 ) !cm&#94;3/s end where rates = matmul ( H_H_rate , denn ) !1/s end subroutine bt_cx_rates","tags":"","loc":"proc/bt_cx_rates.html","title":"bt_cx_rates – FIDASIM"},{"text":"public subroutine get_neutron_rate(plasma, eb, rate) Gets neutron rate for a beam with energy eb interacting with a target plasma Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma Plasma Paramters real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(out) :: rate Neutron reaction rate [1/s] Calls proc~~get_neutron_rate~~CallsGraph proc~get_neutron_rate get_neutron_rate interface~interpol_coeff interpol_coeff proc~get_neutron_rate->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocget_neutron_rateCallsGraph = svgPanZoom('#procget_neutron_rateCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_neutron_rate~~CalledByGraph proc~get_neutron_rate get_neutron_rate proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_neutron_rate proc~neutron_f neutron_f proc~neutron_f->proc~get_neutron_rate program~fidasim fidasim program~fidasim->proc~neutron_mc program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_neutron_rate Source Code subroutine get_neutron_rate ( plasma , eb , rate ) !+ Gets neutron rate for a beam with energy `eb` interacting with a target plasma type ( LocalProfiles ), intent ( in ) :: plasma !+ Plasma Paramters real ( Float64 ), intent ( in ) :: eb !+ Beam energy [keV] real ( Float64 ), intent ( out ) :: rate !+ Neutron reaction rate [1/s] integer :: err_status , neb , nt , ebi , tii real ( Float64 ) :: dlogE , dlogT , logEmin , logTmin real ( Float64 ) :: logeb , logti , lograte , denp type ( InterpolCoeffs2D ) :: c real ( Float64 ) :: b11 , b12 , b21 , b22 logeb = log10 ( eb ) logti = log10 ( plasma % ti ) denp = plasma % denp !!D_D err_status = 1 logEmin = tables % D_D % logemin logTmin = tables % D_D % logtmin dlogE = tables % D_D % dlogE dlogT = tables % D_D % dlogT neb = tables % D_D % nenergy nt = tables % D_D % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , c , err_status ) ebi = c % i tii = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_NEUTRON_RATE: Eb or Ti out of range of D_D table. Setting D_D rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",ES10.3,\" [keV]\")' ) plasma % ti endif denp = 0.d0 endif lograte = ( b11 * tables % D_D % log_rate ( ebi , tii , 2 ) + & b12 * tables % D_D % log_rate ( ebi , tii + 1 , 2 ) + & b21 * tables % D_D % log_rate ( ebi + 1 , tii , 2 ) + & b22 * tables % D_D % log_rate ( ebi + 1 , tii + 1 , 2 )) if ( lograte . lt . tables % D_D % minlog_rate ) then rate = 0.d0 else rate = denp * exp ( lograte * log_10 ) endif end subroutine get_neutron_rate","tags":"","loc":"proc/get_neutron_rate.html","title":"get_neutron_rate – FIDASIM"},{"text":"public subroutine get_beam_cx_rate(ind, pos, v_ion, i_type, types, rate_tot) Get probability of a thermal ion charge exchanging with types neutrals Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind beam_grid indices real(kind=Float64), intent(in), dimension(3) :: pos Interaction position in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: v_ion Ion velocity [cm/s] integer, intent(in) :: i_type Ion type integer(kind=Int32), intent(in), dimension(:) :: types Neutral types real(kind=Float64), intent(out), dimension(nlevs) :: rate_tot Total charge exchange rate [1/s] Calls proc~~get_beam_cx_rate~~CallsGraph proc~get_beam_cx_rate get_beam_cx_rate proc~bb_cx_rates bb_cx_rates proc~get_beam_cx_rate->proc~bb_cx_rates proc~get_plasma get_plasma proc~get_beam_cx_rate->proc~get_plasma proc~bt_cx_rates bt_cx_rates proc~get_beam_cx_rate->proc~bt_cx_rates interface~interpol_coeff interpol_coeff proc~bb_cx_rates->interface~interpol_coeff proc~get_position get_position proc~get_plasma->proc~get_position proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~uvw_to_xyz uvw_to_xyz proc~get_plasma->proc~uvw_to_xyz proc~bt_cx_rates->interface~interpol_coeff proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocget_beam_cx_rateCallsGraph = svgPanZoom('#procget_beam_cx_rateCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_beam_cx_rate~~CalledByGraph proc~get_beam_cx_rate get_beam_cx_rate proc~npa_weights npa_weights proc~npa_weights->proc~get_beam_cx_rate proc~npa_f npa_f proc~npa_f->proc~get_beam_cx_rate proc~npa_mc npa_mc proc~npa_mc->proc~get_beam_cx_rate program~fidasim fidasim program~fidasim->proc~npa_weights program~fidasim->proc~npa_f program~fidasim->proc~npa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_beam_cx_rate Source Code subroutine get_beam_cx_rate ( ind , pos , v_ion , i_type , types , rate_tot ) !+ Get probability of a thermal ion charge exchanging with `types` neutrals integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Interaction position in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: v_ion !+ Ion velocity [cm/s] integer , intent ( in ) :: i_type !+ Ion type integer ( Int32 ), dimension (:), intent ( in ) :: types !+ Neutral types real ( Float64 ), dimension ( nlevs ), intent ( out ) :: rate_tot !+ Total charge exchange rate [1/s] integer :: n , i , j , k , ii type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: rates , denn real ( Float64 ), dimension ( 3 ) :: vhalo , vn , vnbi vnbi = pos - nbi % src vnbi = nbi % vinj * vnbi / norm2 ( vnbi ) n = size ( types ) rate_tot = 0 i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) do ii = 1 , n select case ( types ( ii )) case ( nbif_type ) vn = vnbi call bb_cx_rates ( neut % full (:, i , j , k ), v_ion , vn , rates ) case ( nbih_type ) vn = vnbi / sqrt ( 2.0 ) call bb_cx_rates ( neut % half (:, i , j , k ), v_ion , vn , rates ) case ( nbit_type ) vn = vnbi / sqrt ( 3.0 ) call bb_cx_rates ( neut % third (:, i , j , k ), v_ion , vn , rates ) case ( dcx_type ) call get_plasma ( plasma , pos = pos ) call bt_cx_rates ( plasma , neut % dcx (:, i , j , k ), v_ion , i_type , rates ) case ( halo_type ) call get_plasma ( plasma , pos = pos ) call bt_cx_rates ( plasma , neut % halo (:, i , j , k ), v_ion , i_type , rates ) end select rate_tot = rate_tot + rates enddo end subroutine get_beam_cx_rate","tags":"","loc":"proc/get_beam_cx_rate.html","title":"get_beam_cx_rate – FIDASIM"},{"text":"public subroutine get_rate_matrix(plasma, i_type, eb, rmat) Gets rate matrix for use in colrad Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma Plasma parameters integer, intent(in) :: i_type Ion type real(kind=Float64), intent(in) :: eb Ion energy [keV] real(kind=Float64), intent(out), dimension(nlevs,nlevs) :: rmat Rate matrix Calls proc~~get_rate_matrix~~CallsGraph proc~get_rate_matrix get_rate_matrix interface~interpol_coeff interpol_coeff proc~get_rate_matrix->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocget_rate_matrixCallsGraph = svgPanZoom('#procget_rate_matrixCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_rate_matrix~~CalledByGraph proc~get_rate_matrix get_rate_matrix proc~colrad colrad proc~colrad->proc~get_rate_matrix proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~pnpa_f pnpa_f proc~pnpa_f->proc~attenuate proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_equilibrium program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc->proc~attenuate proc~npa_weights->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_rate_matrix Source Code subroutine get_rate_matrix ( plasma , i_type , eb , rmat ) !+ Gets rate matrix for use in [[libfida:colrad]] type ( LocalProfiles ), intent ( in ) :: plasma !+ Plasma parameters integer , intent ( in ) :: i_type !+ Ion type real ( Float64 ), intent ( in ) :: eb !+ Ion energy [keV] real ( Float64 ), dimension ( nlevs , nlevs ), intent ( out ) :: rmat !+ Rate matrix real ( Float64 ) :: logEmin , dlogE , logeb real ( Float64 ) :: logTmin , dlogT , logti , logte integer :: neb , nt type ( InterpolCoeffs2D ) :: c real ( Float64 ) :: b11 , b12 , b21 , b22 , dene , denp , denimp real ( Float64 ), dimension ( nlevs , nlevs ) :: H_H_pop , H_e_pop , H_Aq_pop real ( Float64 ), dimension ( nlevs ) :: H_H_depop , H_e_depop , H_Aq_depop integer :: ebi , tii , tei , n , err_status H_H_pop = 0.d0 H_e_pop = 0.d0 H_Aq_pop = 0.d0 H_H_depop = 0.d0 H_e_depop = 0.d0 H_Aq_depop = 0.d0 denp = plasma % denp dene = plasma % dene denimp = plasma % denimp logeb = log10 ( eb ) logti = log10 ( plasma % ti ) logte = log10 ( plasma % te ) !!H_H err_status = 1 logEmin = tables % H_H % logemin logTmin = tables % H_H % logtmin dlogE = tables % H_H % dlogE dlogT = tables % H_H % dlogT neb = tables % H_H % nenergy nt = tables % H_H % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , c , err_status ) ebi = c % i tii = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Ti out of range of H_H table. Setting H_H rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",ES10.3,\" [keV]\")' ) plasma % ti endif else H_H_pop = ( b11 * tables % H_H % log_pop (:,:, ebi , tii , i_type ) + & b12 * tables % H_H % log_pop (:,:, ebi , tii + 1 , i_type ) + & b21 * tables % H_H % log_pop (:,:, ebi + 1 , tii , i_type ) + & b22 * tables % H_H % log_pop (:,:, ebi + 1 , tii + 1 , i_type )) where ( H_H_pop . lt . tables % H_H % minlog_pop ) H_H_pop = 0.d0 elsewhere H_H_pop = denp * exp ( H_H_pop * log_10 ) end where H_H_depop = ( b11 * tables % H_H % log_depop (:, ebi , tii , i_type ) + & b12 * tables % H_H % log_depop (:, ebi , tii + 1 , i_type ) + & b21 * tables % H_H % log_depop (:, ebi + 1 , tii , i_type ) + & b22 * tables % H_H % log_depop (:, ebi + 1 , tii + 1 , i_type )) where ( H_H_depop . lt . tables % H_H % minlog_depop ) H_H_depop = 0.d0 elsewhere H_H_depop = denp * exp ( H_H_depop * log_10 ) end where endif !!H_e err_status = 1 logEmin = tables % H_e % logemin logTmin = tables % H_e % logtmin dlogE = tables % H_e % dlogE dlogT = tables % H_e % dlogT neb = tables % H_e % nenergy nt = tables % H_e % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logte , c , err_status ) ebi = c % i tei = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Te out of range of H_e table. Setting H_e rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"te = \",ES10.3,\" [keV]\")' ) plasma % te endif else H_e_pop = ( b11 * tables % H_e % log_pop (:,:, ebi , tei , i_type ) + & b12 * tables % H_e % log_pop (:,:, ebi , tei + 1 , i_type ) + & b21 * tables % H_e % log_pop (:,:, ebi + 1 , tei , i_type ) + & b22 * tables % H_e % log_pop (:,:, ebi + 1 , tei + 1 , i_type )) where ( H_e_pop . lt . tables % H_e % minlog_pop ) H_e_pop = 0.d0 elsewhere H_e_pop = dene * exp ( H_e_pop * log_10 ) end where H_e_depop = ( b11 * tables % H_e % log_depop (:, ebi , tei , i_type ) + & b12 * tables % H_e % log_depop (:, ebi , tei + 1 , i_type ) + & b21 * tables % H_e % log_depop (:, ebi + 1 , tei , i_type ) + & b22 * tables % H_e % log_depop (:, ebi + 1 , tei + 1 , i_type )) where ( H_e_depop . lt . tables % H_e % minlog_depop ) H_e_depop = 0.d0 elsewhere H_e_depop = dene * exp ( H_e_depop * log_10 ) end where endif !!H_Aq err_status = 1 logEmin = tables % H_Aq % logemin logTmin = tables % H_Aq % logtmin dlogE = tables % H_Aq % dlogE dlogT = tables % H_Aq % dlogT neb = tables % H_Aq % nenergy nt = tables % H_Aq % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , c , err_status ) ebi = c % i tii = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Ti out of range of H_Aq table. Setting H_Aq rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",ES10.3,\" [keV]\")' ) plasma % ti endif else H_Aq_pop = ( b11 * tables % H_Aq % log_pop (:,:, ebi , tii , i_type ) + & b12 * tables % H_Aq % log_pop (:,:, ebi , tii + 1 , i_type ) + & b21 * tables % H_Aq % log_pop (:,:, ebi + 1 , tii , i_type ) + & b22 * tables % H_Aq % log_pop (:,:, ebi + 1 , tii + 1 , i_type )) where ( H_Aq_pop . lt . tables % H_Aq % minlog_pop ) H_Aq_pop = 0.d0 elsewhere H_Aq_pop = denimp * exp ( H_Aq_pop * log_10 ) end where H_Aq_depop = ( b11 * tables % H_Aq % log_depop (:, ebi , tii , i_type ) + & b12 * tables % H_Aq % log_depop (:, ebi , tii + 1 , i_type ) + & b21 * tables % H_Aq % log_depop (:, ebi + 1 , tii , i_type ) + & b22 * tables % H_Aq % log_depop (:, ebi + 1 , tii + 1 , i_type )) where ( H_Aq_depop . lt . tables % H_Aq % minlog_depop ) H_Aq_depop = 0.d0 elsewhere H_Aq_depop = denimp * exp ( H_Aq_depop * log_10 ) end where endif rmat = tables % einstein + H_H_pop + H_e_pop + H_Aq_pop do n = 1 , nlevs rmat ( n , n ) = - sum ( tables % einstein (:, n )) - H_H_depop ( n ) - H_e_depop ( n ) - H_Aq_depop ( n ) enddo end subroutine get_rate_matrix","tags":"","loc":"proc/get_rate_matrix.html","title":"get_rate_matrix – FIDASIM"},{"text":"public subroutine colrad(plasma, i_type, vn, dt, states, dens, photons) Evolve density of states in time dt via collisional radiative model Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma Plasma parameters integer, intent(in) :: i_type Ion/Neutral type (beam,thermal) real(kind=Float64), intent(in), dimension(:) :: vn Neutral velocitiy [cm/s] real(kind=Float64), intent(in) :: dt Time interval [s] real(kind=Float64), intent(inout), dimension(:) :: states Density of states real(kind=Float64), intent(out), dimension(nlevs) :: dens Density of neutrals real(kind=Float64), intent(out) :: photons Emitted photons(3->2) Calls proc~~colrad~~CallsGraph proc~colrad colrad proc~eigen eigen proc~colrad->proc~eigen proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~linsolve linsolve proc~colrad->proc~linsolve proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~balback balback proc~eigen->proc~balback proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balance balance proc~eigen->proc~balance interface~interpol_coeff interpol_coeff proc~get_rate_matrix->interface~interpol_coeff proc~matinv matinv proc~linsolve->proc~matinv dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panproccolradCallsGraph = svgPanZoom('#proccolradCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~colrad~~CalledByGraph proc~colrad colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~pnpa_f pnpa_f proc~pnpa_f->proc~attenuate proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_equilibrium program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc->proc~attenuate proc~npa_weights->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code colrad Source Code subroutine colrad ( plasma , i_type , vn , dt , states , dens , photons ) !+ Evolve density of states in time `dt` via collisional radiative model type ( LocalProfiles ), intent ( in ) :: plasma !+ Plasma parameters integer , intent ( in ) :: i_type !+ Ion/Neutral type (beam,thermal) real ( Float64 ), dimension (:), intent ( in ) :: vn !+ Neutral velocitiy [cm/s] real ( Float64 ), intent ( in ) :: dt !+ Time interval [s] real ( Float64 ), dimension (:), intent ( inout ) :: states !+ Density of states real ( Float64 ), dimension ( nlevs ), intent ( out ) :: dens !+ Density of neutrals real ( Float64 ), intent ( out ) :: photons !+ Emitted photons(3->2) real ( Float64 ), dimension ( nlevs , nlevs ) :: matrix !! Matrix real ( Float64 ) :: b_amu real ( Float64 ) :: vnet_square !! net velocity of neutrals squared real ( Float64 ) :: eb !! Energy of the fast neutral real ( Float64 ), dimension ( nlevs , nlevs ) :: eigvec real ( Float64 ), dimension ( nlevs ) :: eigval , coef real ( Float64 ), dimension ( nlevs ) :: exp_eigval_dt real ( Float64 ) :: iflux !!Initial total flux integer :: n photons = 0.d0 dens = 0.d0 iflux = sum ( states ) if (. not . plasma % in_plasma ) then dens = states * dt return endif if ( i_type . eq . beam_ion ) then b_amu = inputs % ab else b_amu = inputs % ai endif vnet_square = dot_product ( vn - plasma % vrot , vn - plasma % vrot ) ![cm/s] eb = v2_to_E_per_amu * b_amu * vnet_square ![kev] call get_rate_matrix ( plasma , i_type , eb , matrix ) call eigen ( nlevs , matrix , eigvec , eigval ) call linsolve ( eigvec , states , coef ) !coeffs determined from states at t=0 exp_eigval_dt = exp ( eigval * dt ) ! to improve speed (used twice) do n = 1 , nlevs if ( eigval ( n ). eq . 0.0 ) eigval ( n ) = eigval ( n ) + 1 !protect against dividing by zero enddo states = matmul ( eigvec , coef * exp_eigval_dt ) ![neutrals/cm&#94;3/s]! dens = matmul ( eigvec , coef * ( exp_eigval_dt - 1.d0 ) / eigval ) where ( states . lt . 0 ) states = 0.d0 endwhere where ( dens . lt . 0 ) dens = 0.d0 endwhere photons = dens ( 3 ) * tables % einstein ( 2 , 3 ) !! - [Ph/(s*cm&#94;3)] - !! end subroutine colrad","tags":"","loc":"proc/colrad.html","title":"colrad – FIDASIM"},{"text":"public subroutine attenuate(ri, rf, vi, states, dstep_in) Attenuate states along a trajectory Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: ri Initial position in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: rf Final position in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: vi Initial velocity of neutral real(kind=Float64), intent(inout), dimension(nlevs) :: states Density of states real(kind=Float64), intent(in), optional :: dstep_in Step length [cm] Calls proc~~attenuate~~CallsGraph proc~attenuate attenuate proc~colrad colrad proc~attenuate->proc~colrad proc~get_plasma get_plasma proc~attenuate->proc~get_plasma proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~linsolve linsolve proc~colrad->proc~linsolve proc~get_position get_position proc~get_plasma->proc~get_position proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~uvw_to_xyz uvw_to_xyz proc~get_plasma->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~get_rate_matrix->interface~interpol_coeff proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~balback balback proc~eigen->proc~balback proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balance balance proc~eigen->proc~balance proc~matinv matinv proc~linsolve->proc~matinv dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocattenuateCallsGraph = svgPanZoom('#procattenuateCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~attenuate~~CalledByGraph proc~attenuate attenuate proc~pnpa_f pnpa_f proc~pnpa_f->proc~attenuate proc~npa_weights npa_weights proc~npa_weights->proc~attenuate proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~attenuate proc~npa_mc npa_mc proc~npa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~npa_weights program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_mc program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code attenuate Source Code subroutine attenuate ( ri , rf , vi , states , dstep_in ) !+ Attenuate `states` along a trajectory real ( Float64 ), dimension ( 3 ), intent ( in ) :: ri !+ Initial position in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: rf !+ Final position in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Initial velocity of neutral real ( Float64 ), dimension ( nlevs ), intent ( inout ) :: states !+ Density of states real ( Float64 ), intent ( in ), optional :: dstep_in !+ Step length [cm] type ( LocalProfiles ) :: plasma real ( Float64 ) :: photons , vabs , dt , dstep , dis , max_dis real ( Float64 ), dimension ( 3 ) :: r0 real ( Float64 ), dimension ( nlevs ) :: dens logical :: inp integer :: ncross if ( present ( dstep_in )) then dstep = dstep_in else dstep = sqrt ( inter_grid % da ) !cm endif max_dis = norm2 ( rf - ri ) vabs = norm2 ( vi ) dt = dstep / vabs call get_plasma ( plasma , pos = ri ) r0 = ri dis = 0.d0 ncross = 0 inp = plasma % in_plasma do while ( dis . le . max_dis ) call colrad ( plasma , beam_ion , vi , dt , states , dens , photons ) r0 = r0 + vi * dt dis = dis + dstep call get_plasma ( plasma , pos = r0 ) if ( inp . neqv . plasma % in_plasma ) then ncross = ncross + 1 inp = plasma % in_plasma endif enddo if ( ncross . gt . 1 ) states = 0.0 end subroutine attenuate","tags":"","loc":"proc/attenuate.html","title":"attenuate – FIDASIM"},{"text":"public subroutine doppler_stark(vecp, vi, fields, lambda) Calculates doppler shift and stark split wavelengths Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: vecp Vector directing towards optical head real(kind=Float64), intent(in), dimension(3) :: vi Particle velocity type( LocalEMFields ), intent(in) :: fields Electro-magnetic fields real(kind=Float64), intent(out), dimension(n_stark) :: lambda Wavelengths [nm] Called by proc~~doppler_stark~~CalledByGraph proc~doppler_stark doppler_stark proc~track track proc~track->proc~doppler_stark proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~doppler_stark proc~dcx dcx proc~dcx->proc~track proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~track proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~track proc~ndmc ndmc proc~ndmc->proc~track proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~track proc~make_diagnostic_grids->proc~track_cylindrical proc~fida_f fida_f proc~fida_f->proc~track proc~halo halo proc~halo->proc~track proc~pfida_mc pfida_mc proc~pfida_mc->proc~track_cylindrical proc~pfida_f pfida_f proc~pfida_f->proc~track_cylindrical proc~fida_mc fida_mc proc~fida_mc->proc~track program~fidasim fidasim program~fidasim->proc~dcx program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~ndmc program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~fida_f program~fidasim->proc~halo program~fidasim->proc~pfida_mc program~fidasim->proc~pfida_f program~fidasim->proc~fida_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/doppler_stark.html","title":"doppler_stark – FIDASIM"},{"text":"public subroutine spectrum(vecp, vi, fields, sigma_pi, photons, dlength, lambda, intensity) Calculates doppler shift, stark splitting, and intensities Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: vecp Vector directing towards optical head real(kind=Float64), intent(in), dimension(3) :: vi Particle velocity type( LocalEMFields ), intent(in) :: fields Electro-magnetic fields real(kind=Float64), intent(in) :: sigma_pi Sigma-pi ratio real(kind=Float64), intent(in) :: photons Photon density from colrad real(kind=Float64), intent(in) :: dlength LOS intersection length with beam_grid cell particle is in real(kind=Float64), intent(out), dimension(n_stark) :: lambda Wavelengths [nm] real(kind=Float64), intent(out), dimension(n_stark) :: intensity Spectra intensities [Ph/(s cm&#94;2 starkline)] Called by proc~~spectrum~~CalledByGraph proc~spectrum spectrum proc~store_photons store_photons proc~store_photons->proc~spectrum proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~store_fw_photons_at_chan->proc~spectrum proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~store_fw_photons_at_chan proc~dcx_spec dcx_spec proc~dcx_spec->proc~store_photons proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~store_fw_photons_at_chan proc~halo_spec halo_spec proc~halo_spec->proc~store_photons proc~cold_spec cold_spec proc~cold_spec->proc~store_photons proc~nbi_spec nbi_spec proc~nbi_spec->proc~store_photons proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx_spec program~fidasim->proc~halo_spec program~fidasim->proc~cold_spec program~fidasim->proc~nbi_spec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code spectrum Source Code subroutine spectrum ( vecp , vi , fields , sigma_pi , photons , dlength , lambda , intensity ) !+ Calculates doppler shift, stark splitting, and intensities real ( Float64 ), dimension ( 3 ), intent ( in ) :: vecp !+ Vector directing towards optical head real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Particle velocity type ( LocalEMFields ), intent ( in ) :: fields !+ Electro-magnetic fields real ( Float64 ), intent ( in ) :: sigma_pi !+ Sigma-pi ratio real ( Float64 ), intent ( in ) :: photons !+ Photon density from [[libfida:colrad]] real ( Float64 ), intent ( in ) :: dlength !+ LOS intersection length with [[libfida:beam_grid]] cell particle is in real ( Float64 ), dimension ( n_stark ), intent ( out ) :: lambda !+ Wavelengths [nm] real ( Float64 ), dimension ( n_stark ), intent ( out ) :: intensity !+ Spectra intensities [Ph/(s cm&#94;2 starkline)] real ( Float64 ), dimension ( 3 ) :: vp , vn real ( Float64 ), dimension ( 3 ) :: bfield , efield real ( Float64 ) :: E , cos_los_Efield , lambda_shifted integer , parameter , dimension ( n_stark ) :: stark_sign = + 1 * stark_sigma - 1 * stark_pi !! vector directing towards the optical head vp = vecp / norm2 ( vecp ) ! Calculate Doppler shift vn = vi * 0.01d0 ! [m/s] lambda_shifted = lambda0 * ( 1.d0 + dot_product ( vn , vp ) / c0 ) !! Calculate Stark Splitting ! Calculate E-field bfield = fields % b_norm * fields % b_abs efield = fields % e_norm * fields % e_abs efield ( 1 ) = efield ( 1 ) + vn ( 2 ) * bfield ( 3 ) - vn ( 3 ) * bfield ( 2 ) efield ( 2 ) = efield ( 2 ) - ( vn ( 1 ) * bfield ( 3 ) - vn ( 3 ) * bfield ( 1 )) efield ( 3 ) = efield ( 3 ) + vn ( 1 ) * bfield ( 2 ) - vn ( 2 ) * bfield ( 1 ) E = norm2 ( efield ) !Stark Splitting lambda = lambda_shifted + E * stark_wavel ![nm] !Intensities of stark components if ( E . eq . 0.d0 ) then cos_los_Efield = 0.d0 else cos_los_Efield = dot_product ( vp , efield ) / E endif intensity = stark_intens * ( 1.d0 + stark_sign * cos_los_Efield ** 2 ) !! E.g. mirrors may change the pi to sigma intensity ratio where ( stark_sigma . eq . 1 ) intensity = intensity * sigma_pi endwhere !! normalize and multiply with photon density from colrad intensity = intensity / sum ( intensity ) * photons * dlength endsubroutine spectrum","tags":"","loc":"proc/spectrum.html","title":"spectrum – FIDASIM"},{"text":"public subroutine store_photons(pos, vi, photons, spectra, passive) Store photons in spectra Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position of neutral real(kind=Float64), intent(in), dimension(3) :: vi Velocitiy of neutral [cm/s] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] real(kind=Float64), intent(inout), dimension(:,:) :: spectra logical, intent(in), optional :: passive Indicates whether photon is passive FIDA Calls proc~~store_photons~~CallsGraph proc~store_photons store_photons proc~get_indices get_indices proc~store_photons->proc~get_indices proc~uvw_to_xyz uvw_to_xyz proc~store_photons->proc~uvw_to_xyz proc~spectrum spectrum proc~store_photons->proc~spectrum proc~get_passive_grid_indices get_passive_grid_indices proc~store_photons->proc~get_passive_grid_indices proc~get_fields get_fields proc~store_photons->proc~get_fields proc~get_fields->proc~uvw_to_xyz proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocstore_photonsCallsGraph = svgPanZoom('#procstore_photonsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~store_photons~~CalledByGraph proc~store_photons store_photons proc~dcx_spec dcx_spec proc~dcx_spec->proc~store_photons proc~halo_spec halo_spec proc~halo_spec->proc~store_photons proc~cold_spec cold_spec proc~cold_spec->proc~store_photons proc~nbi_spec nbi_spec proc~nbi_spec->proc~store_photons proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons program~fidasim fidasim program~fidasim->proc~dcx_spec program~fidasim->proc~halo_spec program~fidasim->proc~cold_spec program~fidasim->proc~nbi_spec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code store_photons Source Code subroutine store_photons ( pos , vi , photons , spectra , passive ) !+ Store photons in `spectra` real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position of neutral real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocitiy of neutral [cm/s] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] real ( Float64 ), dimension (:,:), intent ( inout ) :: spectra logical , intent ( in ), optional :: passive !+ Indicates whether photon is passive FIDA real ( Float64 ), dimension ( n_stark ) :: lambda , intensity real ( Float64 ) :: dlength , sigma_pi type ( LocalEMFields ) :: fields integer ( Int32 ), dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: pos_xyz , lens_xyz , cyl , vp type ( LOSInters ) :: inter integer :: ichan , i , j , bin , nchan logical :: pas = . False . if ( present ( passive )) pas = passive if ( pas ) then cyl ( 1 ) = sqrt ( pos ( 1 ) * pos ( 1 ) + pos ( 2 ) * pos ( 2 )) cyl ( 2 ) = pos ( 3 ) cyl ( 3 ) = atan2 ( pos ( 2 ), pos ( 1 )) call get_passive_grid_indices ( cyl , ind ) inter = spec_chords % cyl_inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) call uvw_to_xyz ( pos , pos_xyz ) else call get_indices ( pos , ind ) inter = spec_chords % inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) pos_xyz = pos endif nchan = inter % nchan if ( nchan . eq . 0 ) return call get_fields ( fields , pos = pos_xyz ) loop_over_channels : do j = 1 , nchan ichan = inter % los_elem ( j )% id dlength = inter % los_elem ( j )% length sigma_pi = spec_chords % los ( ichan )% sigma_pi if ( pas ) then call uvw_to_xyz ( spec_chords % los ( ichan )% lens_uvw , lens_xyz ) else lens_xyz = spec_chords % los ( ichan )% lens endif vp = pos_xyz - lens_xyz call spectrum ( vp , vi , fields , sigma_pi , photons , & dlength , lambda , intensity ) loop_over_stark : do i = 1 , n_stark bin = floor (( lambda ( i ) - inputs % lambdamin ) / inputs % dlambda ) + 1 if ( bin . lt . 1 ) cycle loop_over_stark if ( bin . gt . inputs % nlambda ) cycle loop_over_stark !$OMP ATOMIC UPDATE spectra ( bin , ichan ) = spectra ( bin , ichan ) + intensity ( i ) !$OMP END ATOMIC enddo loop_over_stark enddo loop_over_channels end subroutine store_photons","tags":"","loc":"proc/store_photons.html","title":"store_photons – FIDASIM"},{"text":"public subroutine store_bes_photons(pos, vi, photons, neut_type) Store BES photons in Spectra Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position of neutral in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: vi Velocitiy of neutral [cm/s] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] integer, intent(in) :: neut_type Neutral type (full,half,third,halo) Calls proc~~store_bes_photons~~CallsGraph proc~store_bes_photons store_bes_photons proc~store_photons store_photons proc~store_bes_photons->proc~store_photons proc~get_indices get_indices proc~store_photons->proc~get_indices proc~uvw_to_xyz uvw_to_xyz proc~store_photons->proc~uvw_to_xyz proc~spectrum spectrum proc~store_photons->proc~spectrum proc~get_passive_grid_indices get_passive_grid_indices proc~store_photons->proc~get_passive_grid_indices proc~get_fields get_fields proc~store_photons->proc~get_fields proc~get_fields->proc~uvw_to_xyz proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocstore_bes_photonsCallsGraph = svgPanZoom('#procstore_bes_photonsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code store_bes_photons Source Code subroutine store_bes_photons ( pos , vi , photons , neut_type ) !+ Store BES photons in [[libfida:spectra]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position of neutral in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocitiy of neutral [cm/s] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] integer , intent ( in ) :: neut_type !+ Neutral type (full,half,third,halo) select case ( neut_type ) case ( nbif_type ) call store_photons ( pos , vi , photons , spec % full ) case ( nbih_type ) call store_photons ( pos , vi , photons , spec % half ) case ( nbit_type ) call store_photons ( pos , vi , photons , spec % third ) case ( dcx_type ) call store_photons ( pos , vi , photons , spec % dcx ) case ( halo_type ) call store_photons ( pos , vi , photons , spec % halo ) case default if ( inputs % verbose . ge . 0 ) then write ( * , '(\"STORE_BES_PHOTONS: Unknown neutral type: \",i2)' ) neut_type endif stop end select end subroutine store_bes_photons","tags":"","loc":"proc/store_bes_photons.html","title":"store_bes_photons – FIDASIM"},{"text":"public subroutine store_fida_photons(pos, vi, photons, orbit_class, passive) Store fida photons in Spectra Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position of neutral in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: vi Velocitiy of neutral [cm/s] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] integer, intent(in), optional :: orbit_class Orbit class ID logical, intent(in), optional :: passive Indicates whether photon is passive FIDA Calls proc~~store_fida_photons~~CallsGraph proc~store_fida_photons store_fida_photons proc~store_photons store_photons proc~store_fida_photons->proc~store_photons proc~get_indices get_indices proc~store_photons->proc~get_indices proc~uvw_to_xyz uvw_to_xyz proc~store_photons->proc~uvw_to_xyz proc~spectrum spectrum proc~store_photons->proc~spectrum proc~get_passive_grid_indices get_passive_grid_indices proc~store_photons->proc~get_passive_grid_indices proc~get_fields get_fields proc~store_photons->proc~get_fields proc~get_fields->proc~uvw_to_xyz proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocstore_fida_photonsCallsGraph = svgPanZoom('#procstore_fida_photonsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code store_fida_photons Source Code subroutine store_fida_photons ( pos , vi , photons , orbit_class , passive ) !+ Store fida photons in [[libfida:spectra]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position of neutral in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocitiy of neutral [cm/s] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] integer , intent ( in ), optional :: orbit_class !+ Orbit class ID logical , intent ( in ), optional :: passive !+ Indicates whether photon is passive FIDA integer :: iclass = 1 logical :: pas = . False . if ( present ( orbit_class )) then iclass = min ( orbit_class , particles % nclass ) endif if ( present ( passive )) pas = passive if ( pas ) then call store_photons ( pos , vi , photons , spec % pfida (:,:, iclass ), passive = . True .) else call store_photons ( pos , vi , photons , spec % fida (:,:, iclass )) endif end subroutine store_fida_photons","tags":"","loc":"proc/store_fida_photons.html","title":"store_fida_photons – FIDASIM"},{"text":"public subroutine store_neutrons(rate, orbit_class) Store neutron rate in neutron Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: rate Neutron rate [neutrons/sec] integer, intent(in), optional :: orbit_class Orbit class ID Called by proc~~store_neutrons~~CalledByGraph proc~store_neutrons store_neutrons proc~neutron_mc neutron_mc proc~neutron_mc->proc~store_neutrons proc~neutron_f neutron_f proc~neutron_f->proc~store_neutrons program~fidasim fidasim program~fidasim->proc~neutron_mc program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code store_neutrons Source Code subroutine store_neutrons ( rate , orbit_class ) !+ Store neutron rate in [[libfida:neutron]] real ( Float64 ), intent ( in ) :: rate !+ Neutron rate [neutrons/sec] integer , intent ( in ), optional :: orbit_class !+ Orbit class ID integer :: iclass if ( present ( orbit_class )) then iclass = min ( orbit_class , particles % nclass ) else iclass = 1 endif !$OMP ATOMIC UPDATE neutron % rate ( iclass ) = neutron % rate ( iclass ) + rate !$OMP END ATOMIC end subroutine store_neutrons","tags":"","loc":"proc/store_neutrons.html","title":"store_neutrons – FIDASIM"},{"text":"public subroutine store_fw_photons_at_chan(ichan, eind, pind, vp, vi, fields, dlength, sigma_pi, denf, photons) Store FIDA weight photons in fweight for a specific channel Arguments Type Intent Optional Attributes Name integer, intent(in) :: ichan Channel index integer, intent(in) :: eind Energy index integer, intent(in) :: pind Pitch index real(kind=Float64), intent(in), dimension(3) :: vp Vector pointing toward optical head real(kind=Float64), intent(in), dimension(3) :: vi Velocity of neutral [cm/s] type( LocalEMFields ), intent(in) :: fields Electro-magnetic fields real(kind=Float64), intent(in) :: dlength LOS intersection length with beam_grid cell particle is in real(kind=Float64), intent(in) :: sigma_pi Sigma-pi ratio for channel real(kind=Float64), intent(in) :: denf Fast-ion density [cm&#94;-3] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] Calls proc~~store_fw_photons_at_chan~~CallsGraph proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~spectrum spectrum proc~store_fw_photons_at_chan->proc~spectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~store_fw_photons_at_chan~~CalledByGraph proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~store_fw_photons_at_chan proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~store_fw_photons_at_chan program~fidasim fidasim program~fidasim->proc~fida_weights_los Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code store_fw_photons_at_chan Source Code subroutine store_fw_photons_at_chan ( ichan , eind , pind , vp , vi , fields , dlength , sigma_pi , denf , photons ) !+ Store FIDA weight photons in [[libfida:fweight]] for a specific channel integer , intent ( in ) :: ichan !+ Channel index integer , intent ( in ) :: eind !+ Energy index integer , intent ( in ) :: pind !+ Pitch index real ( Float64 ), dimension ( 3 ), intent ( in ) :: vp !+ Vector pointing toward optical head real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocity of neutral [cm/s] type ( LocalEMFields ), intent ( in ) :: fields !+ Electro-magnetic fields real ( Float64 ), intent ( in ) :: dlength !+ LOS intersection length with [[libfida:beam_grid]] cell particle is in real ( Float64 ), intent ( in ) :: sigma_pi !+ Sigma-pi ratio for channel real ( Float64 ), intent ( in ) :: denf !+ Fast-ion density [cm&#94;-3] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] real ( Float64 ), dimension ( n_stark ) :: lambda , intensity real ( Float64 ) :: dlambda , intens_fac integer :: i , bin dlambda = ( inputs % lambdamax_wght - inputs % lambdamin_wght ) / inputs % nlambda_wght intens_fac = ( 1.d0 ) / ( 4.d0 * pi * dlambda ) call spectrum ( vp , vi , fields , sigma_pi , photons , & dlength , lambda , intensity ) !$OMP CRITICAL(fida_wght) loop_over_stark : do i = 1 , n_stark bin = floor (( lambda ( i ) - inputs % lambdamin_wght ) / dlambda ) + 1 if ( bin . lt . 1 ) cycle loop_over_stark if ( bin . gt . inputs % nlambda_wght ) cycle loop_over_stark !fida(bin,ichan)= fida(bin,ichan) + & !  (denf*intens_fac*1.d4)*intensity(i) !ph/(s*nm*sr*m&#94;2) fweight % weight ( bin , eind , pind , ichan ) = & fweight % weight ( bin , eind , pind , ichan ) + intensity ( i ) * intens_fac !(ph*cm)/(s*nm*sr*fast-ion*dE*dp) enddo loop_over_stark if ( denf . gt . 0.d0 ) then fweight % mean_f ( eind , pind , ichan ) = fweight % mean_f ( eind , pind , ichan ) + & ( denf * intens_fac ) * sum ( intensity ) endif !$OMP END CRITICAL(fida_wght) end subroutine store_fw_photons_at_chan","tags":"","loc":"proc/store_fw_photons_at_chan.html","title":"store_fw_photons_at_chan – FIDASIM"},{"text":"public subroutine store_fw_photons(eind, pind, pos, vi, denf, photons) Store FIDA weight photons in fweight Arguments Type Intent Optional Attributes Name integer, intent(in) :: eind Energy index integer, intent(in) :: pind Pitch index real(kind=Float64), intent(in), dimension(3) :: pos Position of neutral real(kind=Float64), intent(in), dimension(3) :: vi Velocity of neutral [cm/s] real(kind=Float64), intent(in) :: denf Fast-ion density [cm&#94;-3] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] Calls proc~~store_fw_photons~~CallsGraph proc~store_fw_photons store_fw_photons proc~get_indices get_indices proc~store_fw_photons->proc~get_indices proc~get_fields get_fields proc~store_fw_photons->proc~get_fields proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~store_fw_photons->proc~store_fw_photons_at_chan proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~spectrum spectrum proc~store_fw_photons_at_chan->proc~spectrum proc~in_plasma->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocstore_fw_photonsCallsGraph = svgPanZoom('#procstore_fw_photonsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code store_fw_photons Source Code subroutine store_fw_photons ( eind , pind , pos , vi , denf , photons ) !+ Store FIDA weight photons in [[libfida:fweight]] integer , intent ( in ) :: eind !+ Energy index integer , intent ( in ) :: pind !+ Pitch index real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position of neutral real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocity of neutral [cm/s] real ( Float64 ), intent ( in ) :: denf !+ Fast-ion density [cm&#94;-3] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] real ( Float64 ) :: dlength , sigma_pi type ( LocalEMFields ) :: fields integer ( Int32 ), dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: vp type ( LOSInters ) :: inter integer :: ichan , nchan , i call get_indices ( pos , ind ) inter = spec_chords % inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) nchan = inter % nchan if ( nchan . eq . 0 ) return call get_fields ( fields , pos = pos ) loop_over_channels : do i = 1 , nchan ichan = inter % los_elem ( i )% id dlength = inter % los_elem ( i )% length sigma_pi = spec_chords % los ( ichan )% sigma_pi vp = pos - spec_chords % los ( ichan )% lens call store_fw_photons_at_chan ( ichan , eind , pind , & vp , vi , fields , dlength , sigma_pi , denf , photons ) enddo loop_over_channels end subroutine store_fw_photons","tags":"","loc":"proc/store_fw_photons.html","title":"store_fw_photons – FIDASIM"},{"text":"public subroutine get_nlaunch(nr_markers, papprox, nlaunch) Sets the number of MC markers launched from each beam_grid cell Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: nr_markers Approximate total number of markers to launch real(kind=Float64), intent(in), dimension(:,:,:), target :: papprox beam_grid cell weights integer(kind=Int32), intent(out), dimension(:,:,:) :: nlaunch Number of mc markers to launch for each cell: nlaunch(x,y,z) Calls proc~~get_nlaunch~~CallsGraph proc~get_nlaunch get_nlaunch proc~cumsum cumsum proc~get_nlaunch->proc~cumsum interface~randind_cdf randind_cdf proc~get_nlaunch->interface~randind_cdf proc~rng_init rng_init proc~get_nlaunch->proc~rng_init proc~rng_seed rng_seed proc~rng_init->proc~rng_seed proc~my_rank my_rank proc~rng_init->proc~my_rank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_nlaunch~~CalledByGraph proc~get_nlaunch get_nlaunch proc~fida_f fida_f proc~fida_f->proc~get_nlaunch proc~dcx dcx proc~dcx->proc~get_nlaunch proc~npa_f npa_f proc~npa_f->proc~get_nlaunch proc~halo halo proc~halo->proc~get_nlaunch proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_nlaunch program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~dcx program~fidasim->proc~npa_f program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_nlaunch Source Code subroutine get_nlaunch ( nr_markers , papprox , nlaunch ) !+ Sets the number of MC markers launched from each [[libfida:beam_grid]] cell integer ( Int64 ), intent ( in ) :: nr_markers !+ Approximate total number of markers to launch real ( Float64 ), dimension (:,:,:), target , intent ( in ) :: papprox !+ [[libfida:beam_grid]] cell weights integer ( Int32 ), dimension (:,:,:), intent ( out ) :: nlaunch !+ Number of mc markers to launch for each cell: nlaunch(x,y,z) logical , dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: mask real ( Float64 ), dimension ( beam_grid % ngrid ) :: cdf integer :: c , i , j , k , nc , nm , ind ( 3 ) integer :: nmin = 5 integer , dimension ( 1 ) :: randomi type ( rng_type ) :: r real ( Float64 ), pointer :: papprox_ptr (:) !! Fill in minimum number of markers per cell nlaunch = 0 mask = papprox . gt . 0.0 where ( mask ) nlaunch = nmin endwhere !! If there are any left over distribute according to papprox nc = count ( mask ) if ( nr_markers . gt .( nmin * nc )) then nm = nr_markers - nmin * nc !! precalculate cdf to save time call c_f_pointer ( c_loc ( papprox ), papprox_ptr , [ beam_grid % ngrid ]) call cumsum ( papprox_ptr , cdf ) !! use the same seed for all processes call rng_init ( r , 932117 ) do c = 1 , nm call randind_cdf ( r , cdf , randomi ) call ind2sub ( beam_grid % dims , randomi ( 1 ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) nlaunch ( i , j , k ) = nlaunch ( i , j , k ) + 1 enddo endif end subroutine get_nlaunch","tags":"","loc":"proc/get_nlaunch.html","title":"get_nlaunch – FIDASIM"},{"text":"public subroutine get_nlaunch_pass_grid(nr_markers, papprox, nlaunch) Sets the number of MC markers launched from each pass_grid cell Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: nr_markers Approximate total number of markers to launch real(kind=Float64), intent(in), dimension(:,:,:) :: papprox pass_grid cell weights integer(kind=Int32), intent(out), dimension(:,:,:) :: nlaunch Number of mc markers to launch for each cell: nlaunch(r,z,phi) Calls proc~~get_nlaunch_pass_grid~~CallsGraph proc~get_nlaunch_pass_grid get_nlaunch_pass_grid proc~rng_init rng_init proc~get_nlaunch_pass_grid->proc~rng_init interface~randind_cdf randind_cdf proc~get_nlaunch_pass_grid->interface~randind_cdf proc~rng_seed rng_seed proc~rng_init->proc~rng_seed proc~my_rank my_rank proc~rng_init->proc~my_rank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_nlaunch_pass_grid~~CalledByGraph proc~get_nlaunch_pass_grid get_nlaunch_pass_grid proc~pnpa_f pnpa_f proc~pnpa_f->proc~get_nlaunch_pass_grid proc~pfida_f pfida_f proc~pfida_f->proc~get_nlaunch_pass_grid program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~pfida_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_nlaunch_pass_grid Source Code subroutine get_nlaunch_pass_grid ( nr_markers , papprox , nlaunch ) !+ Sets the number of MC markers launched from each [[libfida:pass_grid]] cell integer ( Int64 ), intent ( in ) :: nr_markers !+ Approximate total number of markers to launch real ( Float64 ), dimension (:,:,:), intent ( in ) :: papprox !+ [[libfida:pass_grid]] cell weights integer ( Int32 ), dimension (:,:,:), intent ( out ) :: nlaunch !+ Number of mc markers to launch for each cell: nlaunch(r,z,phi) logical , dimension ( pass_grid % nr , pass_grid % nz , pass_grid % nphi ) :: mask real ( Float64 ), dimension ( pass_grid % ngrid ) :: cdf integer , dimension ( 1 ) :: randomi type ( rng_type ) :: r integer :: c , i , j , k , nc , nm , ind ( 3 ) integer :: nmin = 5 !! Fill in minimum number of markers per cell nlaunch = 0 mask = papprox . gt . 0.0 where ( mask ) nlaunch = nmin endwhere !! If there are any left over distribute according to papprox nc = count ( mask ) if ( nr_markers . gt .( nmin * nc )) then nm = nr_markers - nmin * nc !! precalculate cdf to save time call cumsum ( reshape ( papprox ,[ pass_grid % ngrid ]), cdf ) !! use the same seed for all processes call rng_init ( r , 932117 ) do c = 1 , nm call randind_cdf ( r , cdf , randomi ) call ind2sub ( pass_grid % dims , randomi ( 1 ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) nlaunch ( i , j , k ) = nlaunch ( i , j , k ) + 1 enddo endif end subroutine get_nlaunch_pass_grid","tags":"","loc":"proc/get_nlaunch_pass_grid.html","title":"get_nlaunch_pass_grid – FIDASIM"},{"text":"public subroutine pitch_to_vec(pitch, gyroangle, fields, vi_norm) Calculates velocity vector from pitch, gyroangle and fields Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: pitch Pitch real(kind=Float64), intent(in) :: gyroangle Gyroangle [radians] type( LocalEMFields ), intent(in) :: fields Electromagnetic fields real(kind=Float64), intent(out), dimension(3) :: vi_norm Normalized velocity vector Called by proc~~pitch_to_vec~~CalledByGraph proc~pitch_to_vec pitch_to_vec proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~pitch_to_vec proc~gyro_correction gyro_correction proc~gyro_correction->proc~pitch_to_vec proc~gyro_radius gyro_radius proc~gyro_radius->proc~pitch_to_vec proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~gyro_correction proc~fida_f fida_f proc~fida_f->proc~gyro_correction proc~neutron_mc neutron_mc proc~neutron_mc->proc~gyro_correction program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc proc~pfida_mc pfida_mc program~fidasim->proc~pfida_mc proc~pfida_f pfida_f program~fidasim->proc~pfida_f proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~pfida_mc->proc~gyro_correction proc~pfida_f->proc~gyro_correction proc~neutron_f->proc~gyro_correction proc~fida_mc->proc~gyro_correction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pitch_to_vec Source Code subroutine pitch_to_vec ( pitch , gyroangle , fields , vi_norm ) !+ Calculates velocity vector from pitch, gyroangle and fields real ( Float64 ), intent ( in ) :: pitch !+ Pitch real ( Float64 ), intent ( in ) :: gyroangle !+ Gyroangle [radians] type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields real ( Float64 ), dimension ( 3 ), intent ( out ) :: vi_norm !+ Normalized velocity vector real ( Float64 ) :: sinus sinus = sqrt ( max ( 1.d0 - pitch ** 2 , 0.d0 )) vi_norm = ( sinus * cos ( gyroangle ) * fields % a_norm + & pitch * fields % b_norm + & sinus * sin ( gyroangle ) * fields % c_norm ) end subroutine pitch_to_vec","tags":"","loc":"proc/pitch_to_vec.html","title":"pitch_to_vec – FIDASIM"},{"text":"public subroutine gyro_step(vi, fields, r_gyro) Calculates gyro-step References Belova, E. V., N. N. Gorelenkov, and C. Z. Cheng. \"Self-consistent equilibrium model of low aspect-\n ratio toroidal plasma with energetic beam ions.\" Physics of Plasmas (1994-present) 10.8 (2003):\n 3240-3251. Appendix A: Last equation Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: vi Ion velocity type( LocalEMFields ), intent(in) :: fields Electro-magnetic fields real(kind=Float64), intent(out), dimension(3) :: r_gyro Gyro-step\n Gyro-radius vector from particle position to guiding center Calls proc~~gyro_step~~CallsGraph proc~gyro_step gyro_step proc~cross_product cross_product proc~gyro_step->proc~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gyro_step~~CalledByGraph proc~gyro_step gyro_step proc~gyro_correction gyro_correction proc~gyro_correction->proc~gyro_step proc~npa_weights npa_weights proc~npa_weights->proc~gyro_step proc~gyro_radius gyro_radius proc~gyro_radius->proc~gyro_step proc~ndmc ndmc proc~ndmc->proc~gyro_step proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~gyro_correction proc~fida_f fida_f proc~fida_f->proc~gyro_correction proc~neutron_mc neutron_mc proc~neutron_mc->proc~gyro_correction program~fidasim fidasim program~fidasim->proc~npa_weights program~fidasim->proc~ndmc program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc proc~pfida_mc pfida_mc program~fidasim->proc~pfida_mc proc~pfida_f pfida_f program~fidasim->proc~pfida_f proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~pfida_mc->proc~gyro_correction proc~pfida_f->proc~gyro_correction proc~neutron_f->proc~gyro_correction proc~fida_mc->proc~gyro_correction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code gyro_step Source Code subroutine gyro_step ( vi , fields , r_gyro ) !+ Calculates gyro-step !+ !+###References !+ Belova, E. V., N. N. Gorelenkov, and C. Z. Cheng. \"Self-consistent equilibrium model of low aspect- !+ ratio toroidal plasma with energetic beam ions.\" Physics of Plasmas (1994-present) 10.8 (2003): !+ 3240-3251. Appendix A: Last equation real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Ion velocity type ( LocalEMFields ), intent ( in ) :: fields !+ Electro-magnetic fields real ( Float64 ), dimension ( 3 ), intent ( out ) :: r_gyro !+ Gyro-step !+ Gyro-radius vector from particle position to guiding center real ( Float64 ), dimension ( 3 ) :: vxB , rg_uvw , uvw , cuvrxb , b_rtz , grad_B , rg_rtz real ( Float64 ) :: one_over_omega , phi , R , vpar , term1 , term2 if ( inputs % flr . ge . 1 ) then uvw = fields % uvw R = sqrt ( uvw ( 1 ) ** 2 + uvw ( 2 ) ** 2 ) phi = atan2 ( uvw ( 2 ), uvw ( 1 )) one_over_omega = inputs % ab * mass_u / ( fields % b_abs * e0 ) vxB = cross_product ( vi , fields % b_norm ) vpar = dot_product ( vi , fields % b_norm ) r_gyro = vxB * one_over_omega !points towards gyrocenter, in beam coordinates if ( inputs % flr . ge . 2 ) then !! convert the r_gyro vector to machine coordiantes if ( fields % coords . eq . 0 ) then rg_uvw = matmul ( beam_grid % basis , r_gyro ) endif if ( fields % coords . eq . 1 ) then rg_uvw = r_gyro endif b_rtz ( 1 ) = fields % br / fields % b_abs b_rtz ( 2 ) = fields % bt / fields % b_abs b_rtz ( 3 ) = fields % bz / fields % b_abs cuvrxb ( 1 ) = ( 1. / R * fields % dbz_dphi - fields % dbt_dz ) / fields % b_abs cuvrxb ( 2 ) = ( fields % dbr_dz - fields % dbz_dr ) / fields % b_abs cuvrxb ( 3 ) = ( 1.0 / R * fields % bt + fields % dbt_dr - 1.0 / R * fields % dbr_dphi ) / fields % b_abs term1 = vpar * one_over_omega * dot_product ( b_rtz , cuvrxb ) grad_B ( 1 ) = ( fields % br * fields % dbr_dr + fields % bt * fields % dbt_dr + fields % bz * fields % dbz_dr ) / & fields % b_abs grad_B ( 2 ) = 1.0 / R * ( fields % br * fields % dbr_dphi + fields % bt * fields % dbt_dphi + fields % bz * fields % dbz_dphi ) / & fields % b_abs grad_B ( 3 ) = ( fields % br * fields % dbr_dz + fields % bt * fields % dbt_dz + fields % bz * fields % dbz_dz ) / & fields % b_abs !convert rg_uvw vector to cylindrical coordiantes rg_rtz ( 1 ) = rg_uvw ( 1 ) * cos ( phi ) + rg_uvw ( 2 ) * sin ( phi ) rg_rtz ( 2 ) = - rg_uvw ( 1 ) * sin ( phi ) + rg_uvw ( 2 ) * cos ( phi ) rg_rtz ( 3 ) = rg_uvw ( 3 ) term2 = - 1.0 / ( 2.0 * fields % b_abs ) * dot_product ( rg_rtz , grad_B ) else term1 = 0.0 term2 = 0.0 endif r_gyro = r_gyro * ( 1.0 - term1 - term2 ) if (( 1.0 - term1 - term2 . le . 0.0 ) . or . ( 1.0 - term1 - term2 . ge . 2.0 ) ) then write ( * , * ) 'GYRO_STEP: Gyro correction results in negative distances or too large shift: ' , & 1.0 - term1 - term2 stop endif else r_gyro = 0.d0 endif end subroutine gyro_step","tags":"","loc":"proc/gyro_step.html","title":"gyro_step – FIDASIM"},{"text":"public subroutine gyro_correction(fields, energy, pitch, rp, vp, theta_in) Calculates gyro correction for Guiding Center MC distribution calculation Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: fields Electromagnetic fields at guiding center real(kind=Float64), intent(in) :: energy Energy of particle real(kind=Float64), intent(in) :: pitch Particle pitch w.r.t the magnetic field real(kind=Float64), intent(out), dimension(3) :: rp Particle position real(kind=Float64), intent(out), dimension(3) :: vp Particle velocity real(kind=Float64), intent(in), optional :: theta_in Gyro-angle Calls proc~~gyro_correction~~CallsGraph proc~gyro_correction gyro_correction interface~randu randu proc~gyro_correction->interface~randu proc~gyro_step gyro_step proc~gyro_correction->proc~gyro_step proc~pitch_to_vec pitch_to_vec proc~gyro_correction->proc~pitch_to_vec proc~cross_product cross_product proc~gyro_step->proc~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gyro_correction~~CalledByGraph proc~gyro_correction gyro_correction proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~gyro_correction proc~fida_f fida_f proc~fida_f->proc~gyro_correction proc~neutron_mc neutron_mc proc~neutron_mc->proc~gyro_correction proc~pfida_mc pfida_mc proc~pfida_mc->proc~gyro_correction proc~pfida_f pfida_f proc~pfida_f->proc~gyro_correction proc~neutron_f neutron_f proc~neutron_f->proc~gyro_correction proc~fida_mc fida_mc proc~fida_mc->proc~gyro_correction program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~pfida_mc program~fidasim->proc~pfida_f program~fidasim->proc~neutron_f program~fidasim->proc~fida_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code gyro_correction Source Code subroutine gyro_correction ( fields , energy , pitch , rp , vp , theta_in ) !+ Calculates gyro correction for Guiding Center MC distribution calculation type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields at guiding center real ( Float64 ), intent ( in ) :: energy !+ Energy of particle real ( Float64 ), intent ( in ) :: pitch !+ Particle pitch w.r.t the magnetic field real ( Float64 ), dimension ( 3 ), intent ( out ) :: rp !+ Particle position real ( Float64 ), dimension ( 3 ), intent ( out ) :: vp !+ Particle velocity real ( Float64 ), intent ( in ), optional :: theta_in !+ Gyro-angle real ( Float64 ), dimension ( 3 ) :: vi_norm , r_step real ( Float64 ), dimension ( 1 ) :: randomu real ( Float64 ) :: vabs , theta vabs = sqrt ( energy / ( v2_to_E_per_amu * inputs % ab )) if ( present ( theta_in )) then theta = theta_in else !! Sample gyroangle call randu ( randomu ) theta = 2 * pi * randomu ( 1 ) endif !! Calculate velocity vector call pitch_to_vec ( pitch , theta , fields , vi_norm ) vp = vabs * vi_norm !! Move to particle location call gyro_step ( vp , fields , r_step ) rp = fields % pos - r_step end subroutine gyro_correction","tags":"","loc":"proc/gyro_correction.html","title":"gyro_correction – FIDASIM"},{"text":"public subroutine mc_fastion(ind, fields, eb, ptch, denf) Samples a Guiding Center Fast-ion distribution function at a given beam_grid index Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind beam_grid index type( LocalEMFields ), intent(out) :: fields Electromagnetic fields at the guiding center real(kind=Float64), intent(out) :: eb Energy of the fast ion real(kind=Float64), intent(out) :: ptch Pitch of the fast ion real(kind=Float64), intent(out) :: denf Fast-ion density at guiding center Calls proc~~mc_fastion~~CallsGraph proc~mc_fastion mc_fastion proc~get_fields get_fields proc~mc_fastion->proc~get_fields interface~randu randu proc~mc_fastion->interface~randu proc~get_distribution get_distribution proc~mc_fastion->proc~get_distribution interface~randind randind proc~mc_fastion->interface~randind proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw interface~interpol interpol proc~get_distribution->interface~interpol proc~get_distribution->proc~xyz_to_uvw proc~interpol3d_arr interpol3D_arr interface~interpol->proc~interpol3d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol3d_2d_arr interpol3D_2D_arr interface~interpol->proc~interpol3d_2d_arr proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol3d_2d_arr->interface~interpol_coeff proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocmc_fastionCallsGraph = svgPanZoom('#procmc_fastionCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mc_fastion~~CalledByGraph proc~mc_fastion mc_fastion proc~fida_f fida_f proc~fida_f->proc~mc_fastion proc~npa_f npa_f proc~npa_f->proc~mc_fastion program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code mc_fastion Source Code subroutine mc_fastion ( ind , fields , eb , ptch , denf ) !+ Samples a Guiding Center Fast-ion distribution function at a given [[libfida:beam_grid]] index integer , dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] index type ( LocalEMFields ), intent ( out ) :: fields !+ Electromagnetic fields at the guiding center real ( Float64 ), intent ( out ) :: eb !+ Energy of the fast ion real ( Float64 ), intent ( out ) :: ptch !+ Pitch of the fast ion real ( Float64 ), intent ( out ) :: denf !+ Fast-ion density at guiding center real ( Float64 ), dimension ( fbm % nenergy , fbm % npitch ) :: fbeam real ( Float64 ), dimension ( 3 ) :: rg real ( Float64 ), dimension ( 3 ) :: randomu3 integer , dimension ( 2 , 1 ) :: ep_ind call randu ( randomu3 ) rg ( 1 ) = beam_grid % xc ( ind ( 1 )) + beam_grid % dr ( 1 ) * ( randomu3 ( 1 ) - 0.5 ) rg ( 2 ) = beam_grid % yc ( ind ( 2 )) + beam_grid % dr ( 2 ) * ( randomu3 ( 2 ) - 0.5 ) rg ( 3 ) = beam_grid % zc ( ind ( 3 )) + beam_grid % dr ( 3 ) * ( randomu3 ( 3 ) - 0.5 ) denf = 0.d0 call get_fields ( fields , pos = rg ) if (. not . fields % in_plasma ) return call get_distribution ( fbeam , denf , pos = rg , coeffs = fields % b ) call randind ( fbeam , ep_ind ) call randu ( randomu3 ) eb = fbm % energy ( ep_ind ( 1 , 1 )) + fbm % dE * ( randomu3 ( 1 ) - 0.5 ) ptch = fbm % pitch ( ep_ind ( 2 , 1 )) + fbm % dp * ( randomu3 ( 2 ) - 0.5 ) end subroutine mc_fastion","tags":"","loc":"proc/mc_fastion.html","title":"mc_fastion – FIDASIM"},{"text":"public subroutine mc_fastion_pass_grid(ind, fields, eb, ptch, denf, output_coords) Samples a Guiding Center Fast-ion distribution function at a given pass_grid index Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind pass_grid index type( LocalEMFields ), intent(out) :: fields Electromagnetic fields at the guiding center real(kind=Float64), intent(out) :: eb Energy of the fast ion real(kind=Float64), intent(out) :: ptch Pitch of the fast ion real(kind=Float64), intent(out) :: denf Fast-ion density at guiding center integer, intent(in), optional :: output_coords Indicates coordinate system of fields . Beam grid (0), machine (1) and cylindrical (2) Calls proc~~mc_fastion_pass_grid~~CallsGraph proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~get_fields get_fields proc~mc_fastion_pass_grid->proc~get_fields interface~randu randu proc~mc_fastion_pass_grid->interface~randu proc~cyl_to_uvw cyl_to_uvw proc~mc_fastion_pass_grid->proc~cyl_to_uvw proc~get_distribution get_distribution proc~mc_fastion_pass_grid->proc~get_distribution interface~randind randind proc~mc_fastion_pass_grid->interface~randind proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw interface~interpol interpol proc~get_distribution->interface~interpol proc~get_distribution->proc~xyz_to_uvw proc~interpol3d_arr interpol3D_arr interface~interpol->proc~interpol3d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol3d_2d_arr interpol3D_2D_arr interface~interpol->proc~interpol3d_2d_arr proc~in_plasma->proc~cyl_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol3d_2d_arr->interface~interpol_coeff proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocmc_fastion_pass_gridCallsGraph = svgPanZoom('#procmc_fastion_pass_gridCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mc_fastion_pass_grid~~CalledByGraph proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~pnpa_f pnpa_f proc~pnpa_f->proc~mc_fastion_pass_grid proc~pfida_f pfida_f proc~pfida_f->proc~mc_fastion_pass_grid program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~pfida_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code mc_fastion_pass_grid Source Code subroutine mc_fastion_pass_grid ( ind , fields , eb , ptch , denf , output_coords ) !+ Samples a Guiding Center Fast-ion distribution function at a given [[libfida:pass_grid]] index integer , dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:pass_grid]] index type ( LocalEMFields ), intent ( out ) :: fields !+ Electromagnetic fields at the guiding center real ( Float64 ), intent ( out ) :: eb !+ Energy of the fast ion real ( Float64 ), intent ( out ) :: ptch !+ Pitch of the fast ion real ( Float64 ), intent ( out ) :: denf !+ Fast-ion density at guiding center integer , intent ( in ), optional :: output_coords !+ Indicates coordinate system of `fields`. Beam grid (0), machine (1) and cylindrical (2) real ( Float64 ), dimension ( fbm % nenergy , fbm % npitch ) :: fbeam real ( Float64 ), dimension ( 3 ) :: rg , rg_cyl real ( Float64 ), dimension ( 3 ) :: randomu3 real ( Float64 ) :: rmin , rmax , zmin , phimin integer , dimension ( 2 , 1 ) :: ep_ind integer :: ocs if ( present ( output_coords )) then ocs = output_coords else ocs = 0 endif denf = 0.d0 call randu ( randomu3 ) rmin = pass_grid % r ( ind ( 1 )) rmax = rmin + pass_grid % dr zmin = pass_grid % z ( ind ( 2 )) phimin = pass_grid % phi ( ind ( 3 )) ! Sample uniformally in annulus rg_cyl ( 1 ) = sqrt ( randomu3 ( 1 ) * ( rmax ** 2 - rmin ** 2 ) + rmin ** 2 ) rg_cyl ( 2 ) = zmin + randomu3 ( 2 ) * pass_grid % dz rg_cyl ( 3 ) = phimin + randomu3 ( 3 ) * pass_grid % dphi call cyl_to_uvw ( rg_cyl , rg ) call get_fields ( fields , pos = rg , input_coords = 1 , output_coords = ocs ) if (. not . fields % in_plasma ) return call get_distribution ( fbeam , denf , coeffs = fields % b ) call randind ( fbeam , ep_ind ) call randu ( randomu3 ) eb = fbm % energy ( ep_ind ( 1 , 1 )) + fbm % dE * ( randomu3 ( 1 ) - 0.5 ) ptch = fbm % pitch ( ep_ind ( 2 , 1 )) + fbm % dp * ( randomu3 ( 2 ) - 0.5 ) end subroutine mc_fastion_pass_grid","tags":"","loc":"proc/mc_fastion_pass_grid.html","title":"mc_fastion_pass_grid – FIDASIM"},{"text":"public subroutine mc_halo(ind, vhalo, ri, plasma_in) Sample thermal Maxwellian distribution at beam_grid indices ind Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind beam_grid indices real(kind=Float64), intent(out), dimension(3) :: vhalo Velocity [cm/s] real(kind=Float64), intent(out), optional dimension(3) :: ri Position in beam_grid cell type( LocalProfiles ), intent(in), optional :: plasma_in Plasma parameters Calls proc~~mc_halo~~CallsGraph proc~mc_halo mc_halo interface~randn randn proc~mc_halo->interface~randn interface~randu randu proc~mc_halo->interface~randu proc~get_plasma get_plasma proc~mc_halo->proc~get_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~uvw_to_xyz uvw_to_xyz proc~get_plasma->proc~uvw_to_xyz proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~in_plasma->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocmc_haloCallsGraph = svgPanZoom('#procmc_haloCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mc_halo~~CalledByGraph proc~mc_halo mc_halo proc~dcx dcx proc~dcx->proc~mc_halo proc~halo halo proc~halo->proc~mc_halo program~fidasim fidasim program~fidasim->proc~dcx program~fidasim->proc~halo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code mc_halo Source Code subroutine mc_halo ( ind , vhalo , ri , plasma_in ) !+ Sample thermal Maxwellian distribution at [[libfida:beam_grid]] indices `ind` integer , dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices real ( Float64 ), dimension ( 3 ), intent ( out ) :: vhalo !+ Velocity [cm/s] real ( Float64 ), dimension ( 3 ), intent ( out ), optional :: ri !+ Position in [[libfida:beam_grid]] cell type ( LocalProfiles ), intent ( in ), optional :: plasma_in !+ Plasma parameters type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( 3 ) :: random3 if (. not . present ( plasma_in )) then if ( present ( ri )) then call randu ( random3 ) ri ( 1 ) = beam_grid % xc ( ind ( 1 )) + beam_grid % dr ( 1 ) * ( random3 ( 1 ) - 0.5 ) ri ( 2 ) = beam_grid % yc ( ind ( 2 )) + beam_grid % dr ( 2 ) * ( random3 ( 2 ) - 0.5 ) ri ( 3 ) = beam_grid % zc ( ind ( 3 )) + beam_grid % dr ( 3 ) * ( random3 ( 3 ) - 0.5 ) call get_plasma ( plasma , pos = ri ) else call get_plasma ( plasma , ind = ind ) endif else plasma = plasma_in endif call randn ( random3 ) vhalo = plasma % vrot + sqrt ( plasma % ti * 0.5 / ( v2_to_E_per_amu * inputs % ai )) * random3 !![cm/s] end subroutine mc_halo","tags":"","loc":"proc/mc_halo.html","title":"mc_halo – FIDASIM"},{"text":"public subroutine mc_nbi(vnbi, efrac, rnbi, err) Generates a neutral beam particle trajectory Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(3) :: vnbi Velocity [cm/s] integer, intent(in) :: efrac Beam neutral type (1,2,3) real(kind=Float64), intent(out), dimension(3) :: rnbi Starting position on beam_grid logical, intent(out) :: err Error Code Calls proc~~mc_nbi~~CallsGraph proc~mc_nbi mc_nbi interface~randn randn proc~mc_nbi->interface~randn interface~randu randu proc~mc_nbi->interface~randu proc~in_plasma in_plasma proc~mc_nbi->proc~in_plasma proc~grid_intersect grid_intersect proc~mc_nbi->proc~grid_intersect proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~in_passive_grid in_passive_grid proc~grid_intersect->proc~in_passive_grid proc~approx_le approx_le proc~in_passive_grid->proc~approx_le proc~approx_ge approx_ge proc~in_passive_grid->proc~approx_ge proc~uvw_to_cyl uvw_to_cyl proc~in_passive_grid->proc~uvw_to_cyl proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~approx_eq approx_eq proc~approx_le->proc~approx_eq proc~approx_ge->proc~approx_eq proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocmc_nbiCallsGraph = svgPanZoom('#procmc_nbiCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mc_nbi~~CalledByGraph proc~mc_nbi mc_nbi proc~ndmc ndmc proc~ndmc->proc~mc_nbi program~fidasim fidasim program~fidasim->proc~ndmc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code mc_nbi Source Code subroutine mc_nbi ( vnbi , efrac , rnbi , err ) !+ Generates a neutral beam particle trajectory integer , intent ( in ) :: efrac !+ Beam neutral type (1,2,3) real ( Float64 ), dimension ( 3 ), intent ( out ) :: vnbi !+ Velocity [cm/s] real ( Float64 ), dimension ( 3 ), intent ( out ) :: rnbi !+ Starting position on [[libfida:beam_grid]] logical , intent ( out ) :: err !+ Error Code real ( Float64 ), dimension ( 3 ) :: r_exit real ( Float64 ), dimension ( 3 ) :: uvw_src !! Start position on ion source real ( Float64 ), dimension ( 3 ) :: xyz_src !! Start position on ion source real ( Float64 ), dimension ( 3 ) :: uvw_ray !! NBI velocity in uvw coords real ( Float64 ), dimension ( 3 ) :: xyz_ray !! NBI velocity in xyz coords real ( Float64 ), dimension ( 3 ) :: xyz_ape !! Aperture plane intersection point real ( Float64 ), dimension ( 2 ) :: randomu !! uniform random numbers real ( Float64 ), dimension ( 2 ) :: randomn !! normal random numbers real ( Float64 ) :: length , sqrt_rho , theta integer :: i , j logical :: inp , valid_trajectory err = . False . valid_trajectory = . False . rejection_loop : do i = 1 , 1000 call randu ( randomu ) select case ( nbi % shape ) case ( 1 ) ! Uniformally sample in rectangle xyz_src ( 1 ) = 0.d0 xyz_src ( 2 ) = nbi % widy * 2.d0 * ( randomu ( 1 ) - 0.5d0 ) xyz_src ( 3 ) = nbi % widz * 2.d0 * ( randomu ( 2 ) - 0.5d0 ) case ( 2 ) ! Uniformally sample in ellipse sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) xyz_src ( 1 ) = 0.d0 xyz_src ( 2 ) = nbi % widy * sqrt_rho * cos ( theta ) xyz_src ( 3 ) = nbi % widz * sqrt_rho * sin ( theta ) end select !! Create random velocity vector call randn ( randomn ) xyz_ray ( 1 ) = 1.d0 xyz_ray ( 2 ) = ( - xyz_src ( 2 ) / nbi % focy + tan ( nbi % divy ( efrac ) * randomn ( 1 ))) xyz_ray ( 3 ) = ( - xyz_src ( 3 ) / nbi % focz + tan ( nbi % divz ( efrac ) * randomn ( 2 ))) aperture_loop : do j = 1 , nbi % naperture xyz_ape = xyz_ray * nbi % adist ( j ) + xyz_src select case ( nbi % ashape ( j )) case ( 1 ) if (( abs ( xyz_ape ( 2 ) - nbi % aoffy ( j )). gt . nbi % awidy ( j )). or .& ( abs ( xyz_ape ( 3 ) - nbi % aoffz ( j )). gt . nbi % awidz ( j ))) then cycle rejection_loop endif case ( 2 ) if (((( xyz_ape ( 2 ) - nbi % aoffy ( j )) * nbi % awidz ( j )) ** 2 + & (( xyz_ape ( 3 ) - nbi % aoffz ( j )) * nbi % awidy ( j )) ** 2 ). gt . & ( nbi % awidy ( j ) * nbi % awidz ( j )) ** 2 ) then cycle rejection_loop endif end select enddo aperture_loop valid_trajectory = . True . !! Convert to beam centerline coordinates to beam grid coordinates uvw_src = matmul ( nbi % basis , xyz_src ) + nbi % src uvw_ray = matmul ( nbi % basis , xyz_ray ) exit rejection_loop enddo rejection_loop !Set Default trajectory in case rejection sampling fails if (. not . valid_trajectory ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"MC_NBI: Failed to find trajectory though aperture(s). Using beam centerline.\" endif uvw_src = nbi % src uvw_ray = nbi % axis endif vnbi = uvw_ray / norm2 ( uvw_ray ) !! Determine start position on beam grid call grid_intersect ( uvw_src , vnbi , length , rnbi , r_exit ) if ( length . le . 0.0 ) then err = . True . nbi_outside = nbi_outside + 1 endif !! Check if start position is in the plasma call in_plasma ( rnbi , inp ) if ( inp ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"MC_NBI: A beam neutral has started inside the plasma.\" write ( * , '(a)' ) \"Move the beam grid closer to the source to fix\" endif stop endif !! Determine velocity of neutrals corrected by efrac vnbi = vnbi * nbi % vinj / sqrt ( real ( efrac )) end subroutine mc_nbi","tags":"","loc":"proc/mc_nbi.html","title":"mc_nbi – FIDASIM"},{"text":"public subroutine mc_nbi_cell(ind, neut_type, vnbi, weight) Generates a neutral beam velocity vector\n that passes through cell at ind with weight weight Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind Cell index integer, intent(in) :: neut_type Neutral Type (1=Full,2=Half,3=Third) real(kind=Float64), intent(out), dimension(3) :: vnbi Normalized Velocity real(kind=Float64), intent(out) :: weight Weigth/probability of trajectory Calls proc~~mc_nbi_cell~~CallsGraph proc~mc_nbi_cell mc_nbi_cell interface~randu randu proc~mc_nbi_cell->interface~randu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mc_nbi_cell~~CalledByGraph proc~mc_nbi_cell mc_nbi_cell proc~nbi_spec nbi_spec proc~nbi_spec->proc~mc_nbi_cell program~fidasim fidasim program~fidasim->proc~nbi_spec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code mc_nbi_cell Source Code subroutine mc_nbi_cell ( ind , neut_type , vnbi , weight ) !+ Generates a neutral beam velocity vector !+ that passes through cell at `ind` with weight `weight` integer , dimension ( 3 ), intent ( in ) :: ind !+ Cell index integer , intent ( in ) :: neut_type !+ Neutral Type (1=Full,2=Half,3=Third) real ( Float64 ), dimension ( 3 ), intent ( out ) :: vnbi !+ Normalized Velocity real ( Float64 ), intent ( out ) :: weight !+ Weigth/probability of trajectory real ( Float64 ), dimension ( 3 ) :: rc !! Center of cell in uvw coords real ( Float64 ), dimension ( 3 ) :: uvw_rf !! End position in xyz coords real ( Float64 ), dimension ( 3 ) :: xyz_rf !! End position in xyz coords real ( Float64 ), dimension ( 3 ) :: uvw_src !! Start position on ion source real ( Float64 ), dimension ( 3 ) :: xyz_src !! Start position on ion source real ( Float64 ), dimension ( 3 ) :: uvw_ray !! NBI velocity in uvw coords real ( Float64 ), dimension ( 3 ) :: xyz_ray !! NBI velocity in xyz coords real ( Float64 ), dimension ( 3 ) :: xyz_ape !! Aperture plane intersection point real ( Float64 ), dimension ( 3 ) :: randomu !! uniform random numbers real ( Float64 ) :: sqrt_rho , theta , vy , vz , theta_y , theta_z , py , pz integer :: i , j logical :: valid_trajectory rc = [ beam_grid % xc ( ind ( 1 )), beam_grid % yc ( ind ( 2 )), beam_grid % zc ( ind ( 3 ))] valid_trajectory = . False . rejection_loop : do i = 1 , 1000 call randu ( randomu ) select case ( nbi % shape ) case ( 1 ) ! Uniformally sample in rectangle xyz_src ( 1 ) = 0.d0 xyz_src ( 2 ) = nbi % widy * 2.d0 * ( randomu ( 1 ) - 0.5d0 ) xyz_src ( 3 ) = nbi % widz * 2.d0 * ( randomu ( 2 ) - 0.5d0 ) case ( 2 ) ! Uniformally sample in ellipse sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) xyz_src ( 1 ) = 0.d0 xyz_src ( 2 ) = nbi % widy * sqrt_rho * cos ( theta ) xyz_src ( 3 ) = nbi % widz * sqrt_rho * sin ( theta ) end select !! Create random position in the cell call randu ( randomu ) uvw_rf = rc + ( randomu - 0.5 ) * beam_grid % dr xyz_rf = matmul ( nbi % inv_basis , uvw_rf - nbi % src ) xyz_ray = xyz_rf - xyz_src xyz_ray = xyz_ray / norm2 ( xyz_ray ) aperture_loop : do j = 1 , nbi % naperture xyz_ape = xyz_ray * nbi % adist ( j ) + xyz_src select case ( nbi % ashape ( j )) case ( 1 ) if (( abs ( xyz_ape ( 2 ) - nbi % aoffy ( j )). gt . nbi % awidy ( j )). or .& ( abs ( xyz_ape ( 3 ) - nbi % aoffz ( j )). gt . nbi % awidz ( j ))) then cycle rejection_loop endif case ( 2 ) if (((( xyz_ape ( 2 ) - nbi % aoffy ( j )) * nbi % awidz ( j )) ** 2 + & (( xyz_ape ( 3 ) - nbi % aoffz ( j )) * nbi % awidy ( j )) ** 2 ). gt . & ( nbi % awidy ( j ) * nbi % awidz ( j )) ** 2 ) then cycle rejection_loop endif end select enddo aperture_loop valid_trajectory = . True . !! Convert to beam centerline coordinates to beam grid coordinates uvw_src = matmul ( nbi % basis , xyz_src ) + nbi % src uvw_ray = matmul ( nbi % basis , xyz_ray ) vnbi = nbi % vinj * uvw_ray / norm2 ( uvw_ray ) / sqrt ( real ( neut_type )) exit rejection_loop enddo rejection_loop !Set Default trajectory in case rejection sampling fails if (. not . valid_trajectory ) then call randu ( randomu ) uvw_rf = rc + ( randomu - 0.5 ) * beam_grid % dr uvw_ray = uvw_rf - nbi % src vnbi = nbi % vinj * uvw_ray / norm2 ( uvw_ray ) / sqrt ( real ( neut_type )) endif !! Find probability of trajectory vy = xyz_ray ( 2 ) / xyz_ray ( 1 ) vz = xyz_ray ( 3 ) / xyz_ray ( 1 ) theta_y = atan ( vy + xyz_src ( 2 ) / nbi % focy ) theta_z = atan ( vz + xyz_src ( 3 ) / nbi % focz ) py = ( 1.0 / ( 1.0 + ( vy + xyz_src ( 2 ) / nbi % focy ) ** 2 )) * & exp ( - ( theta_y ** 2 ) / ( 2 * nbi % divy ( neut_type ) ** 2 )) / & sqrt ( 2 * nbi % divy ( neut_type ) ** 2 ) pz = ( 1.0 / ( 1.0 + ( vz + xyz_src ( 3 ) / nbi % focy ) ** 2 )) * & exp ( - ( theta_z ** 2 ) / ( 2 * nbi % divz ( neut_type ) ** 2 )) / & sqrt ( 2 * nbi % divz ( neut_type ) ** 2 ) weight = py * pz end subroutine mc_nbi_cell","tags":"","loc":"proc/mc_nbi_cell.html","title":"mc_nbi_cell – FIDASIM"},{"text":"public subroutine ndmc() Calculates neutral beam deposition and spectra Arguments None Calls proc~~ndmc~~CallsGraph proc~ndmc ndmc proc~get_fields get_fields proc~ndmc->proc~get_fields proc~store_neutrals store_neutrals proc~ndmc->proc~store_neutrals proc~track track proc~ndmc->proc~track interface~randu randu proc~ndmc->interface~randu proc~mc_nbi mc_nbi proc~ndmc->proc~mc_nbi proc~gyro_step gyro_step proc~ndmc->proc~gyro_step interface~parallel_sum parallel_sum proc~ndmc->interface~parallel_sum proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~track->proc~get_fields proc~doppler_stark doppler_stark proc~track->proc~doppler_stark proc~track->proc~in_plasma proc~get_indices get_indices proc~track->proc~get_indices proc~mc_nbi->interface~randu interface~randn randn proc~mc_nbi->interface~randn proc~mc_nbi->proc~in_plasma proc~grid_intersect grid_intersect proc~mc_nbi->proc~grid_intersect proc~cross_product cross_product proc~gyro_step->proc~cross_product proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~in_plasma->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~in_passive_grid in_passive_grid proc~grid_intersect->proc~in_passive_grid proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~approx_le approx_le proc~in_passive_grid->proc~approx_le proc~approx_ge approx_ge proc~in_passive_grid->proc~approx_ge proc~uvw_to_cyl uvw_to_cyl proc~in_passive_grid->proc~uvw_to_cyl proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~approx_eq approx_eq proc~approx_le->proc~approx_eq proc~approx_ge->proc~approx_eq proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocndmcCallsGraph = svgPanZoom('#procndmcCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ndmc~~CalledByGraph proc~ndmc ndmc program~fidasim fidasim program~fidasim->proc~ndmc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ndmc Source Code subroutine ndmc !+ Calculates neutral beam deposition and spectra integer :: neut_type !! full half third energy real ( Float64 ) :: nlaunch !! nr. of markers real ( Float64 ) :: nneutrals !! # NBI particles real ( Float64 ), dimension ( 3 ) :: vnbi !! velocities(full..) real ( Float64 ), dimension ( 3 ) :: rnbi !! initial position integer ( Int64 ) :: jj , ii , kk , cnt integer :: ntrack type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( Float64 ), dimension ( nlevs ) :: states , dens real ( Float64 ) :: photons , iflux , flux_tot integer ( Int32 ), dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: ri , ri_gc , r_gyro real ( Float64 ), dimension ( 1 ) :: randomu integer , dimension ( 1 ) :: randi logical :: err if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) inputs % n_nbi if ( inputs % calc_birth . ge . 1 ) then write ( * , '(T6,\"# of birth markers: 3 x\",i10)' ) int ( inputs % n_nbi * inputs % n_birth ) endif endif !! # of injected neutrals = NBI power/energy_per_particle nneutrals = 1.d6 * nbi % pinj / ( 1.d3 * nbi % einj * e0 & * ( nbi % current_fractions ( 1 ) & + nbi % current_fractions ( 2 ) / 2.d0 & + nbi % current_fractions ( 3 ) / 3.d0 ) ) nlaunch = real ( inputs % n_nbi ) !$OMP PARALLEL DO schedule(guided) & !$OMP& private(vnbi,rnbi,tracks,ntrack,plasma,fields,randi,flux_tot, & !$OMP& states,dens,iflux,photons,neut_type,jj,ii,kk,ind,err,ri,ri_gc,r_gyro) loop_over_markers : do ii = istart , inputs % n_nbi , istep energy_fractions : do neut_type = 1 , 3 !! (type = 1: full energy, =2: half energy, =3: third energy call mc_nbi ( vnbi , neut_type , rnbi , err ) if ( err ) cycle energy_fractions call track ( rnbi , vnbi , tracks , ntrack ) if ( ntrack . eq . 0 ) cycle energy_fractions !! Solve collisional radiative model along track flux_tot = 0.d0 states = 0.d0 states ( 1 ) = nneutrals * nbi % current_fractions ( neut_type ) / beam_grid % dv loop_along_track : do jj = 1 , ntrack iflux = sum ( states ) ind = tracks ( jj )% ind call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vnbi , tracks ( jj )% time , states , dens , photons ) call store_neutrals ( ind , neut_type , dens / nlaunch , vnbi ) tracks ( jj )% flux = ( iflux - sum ( states )) / nlaunch flux_tot = flux_tot + tracks ( jj )% flux * beam_grid % dv if ( inputs % calc_birth . ge . 1 ) then call store_births ( ind , neut_type , tracks ( jj )% flux ) endif if (( photons . gt . 0.d0 ). and .( inputs % calc_bes . ge . 1 )) then call store_bes_photons ( tracks ( jj )% pos , vnbi , photons / nlaunch , neut_type ) endif enddo loop_along_track if (( inputs % calc_birth . ge . 1 ). and .( flux_tot . gt . 0.d0 )) then !! Sample according to deposited flux along neutral trajectory !$OMP CRITICAL(ndmc_birth) do kk = 1 , inputs % n_birth call randind ( tracks ( 1 : ntrack )% flux , randi ) call randu ( randomu ) birth % part ( birth % cnt )% neut_type = neut_type birth % part ( birth % cnt )% energy = nbi % einj / real ( neut_type ) birth % part ( birth % cnt )% weight = flux_tot / inputs % n_birth birth % part ( birth % cnt )% ind = tracks ( randi ( 1 ))% ind birth % part ( birth % cnt )% vi = vnbi ri = tracks ( randi ( 1 ))% pos + vnbi * ( tracks ( randi ( 1 ))% time * ( randomu ( 1 ) - 0.5 )) birth % part ( birth % cnt )% ri = ri call get_fields ( fields , pos = ri ) birth % part ( birth % cnt )% pitch = dot_product ( fields % b_norm , vnbi / norm2 ( vnbi )) call gyro_step ( vnbi , fields , r_gyro ) birth % part ( birth % cnt )% ri_gc = ri + r_gyro birth % cnt = birth % cnt + 1 enddo !$OMP END CRITICAL(ndmc_birth) endif enddo energy_fractions enddo loop_over_markers !$OMP END PARALLEL DO #ifdef _MPI !! Combine beam neutrals call parallel_sum ( neut % full ) call parallel_sum ( neut % half ) call parallel_sum ( neut % third ) call parallel_sum ( nbi_outside ) if ( inputs % calc_birth . ge . 1 ) then call parallel_sum ( birth % dens ) endif !! Combine spectra if ( inputs % calc_bes . ge . 1 ) then call parallel_sum ( spec % full ) call parallel_sum ( spec % half ) call parallel_sum ( spec % third ) endif #endif if ( nbi_outside . gt . 0 ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a, f6.2,a)' ) 'Percent of markers outside the grid: ' , & 10 0. * nbi_outside / ( 3. * inputs % n_nbi ), '%' endif if ( sum ( neut % full ). eq . 0 ) stop 'Beam does not intersect the grid!' endif end subroutine ndmc","tags":"","loc":"proc/ndmc.html","title":"ndmc – FIDASIM"},{"text":"public subroutine bremsstrahlung() Calculates bremsstrahlung Arguments None Calls proc~~bremsstrahlung~~CallsGraph proc~bremsstrahlung bremsstrahlung proc~line_basis line_basis proc~bremsstrahlung->proc~line_basis interface~randu randu proc~bremsstrahlung->interface~randu proc~get_plasma get_plasma proc~bremsstrahlung->proc~get_plasma interface~parallel_sum parallel_sum proc~bremsstrahlung->interface~parallel_sum proc~tb_zyx tb_zyx proc~line_basis->proc~tb_zyx proc~uvw_to_xyz uvw_to_xyz proc~get_plasma->proc~uvw_to_xyz proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 mpi_allreduce mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~in_plasma->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocbremsstrahlungCallsGraph = svgPanZoom('#procbremsstrahlungCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bremsstrahlung~~CalledByGraph proc~bremsstrahlung bremsstrahlung program~fidasim fidasim program~fidasim->proc~bremsstrahlung Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code bremsstrahlung Source Code subroutine bremsstrahlung !+ Calculates bremsstrahlung type ( LocalProfiles ) :: plasma integer :: i , ichan , nc , ic real ( Float64 ) :: dlength , dlambda , gaunt , max_length real ( Float64 ) :: spot_size , theta , sqrt_rho real ( Float64 ), dimension ( 2 ) :: randomu real ( Float64 ), dimension ( 3 ) :: vi , xyz , r0 real ( Float64 ), dimension ( 3 , 3 ) :: basis real ( Float64 ), dimension (:), allocatable :: lambda_arr , brems allocate ( lambda_arr ( inputs % nlambda )) allocate ( brems ( inputs % nlambda )) do i = 1 , inputs % nlambda lambda_arr ( i ) = 10 * (( i - 0.5 ) * inputs % dlambda + inputs % lambdamin ) ! [A] enddo dlambda = 10 * inputs % dlambda ![A] dlength = 0.3 !cm !! $OMP PARALLEL DO schedule(guided) private(ichan,xyz,vi,basis,spot_size, & !! $OMP& max_length, ic, nc,randomu,sqrt_rho,theta,r0,plasma,gaunt,brems) loop_over_channels : do ichan = istart , spec_chords % nchan , istep xyz = spec_chords % los ( ichan )% lens vi = spec_chords % los ( ichan )% axis vi = vi / norm2 ( vi ) spot_size = spec_chords % los ( ichan )% spot_size call line_basis ( xyz , vi , basis ) if ( spot_size . le . 0.d0 ) then nc = 1 else nc = 100 endif loop_over_los : do ic = 1 , nc call randu ( randomu ) sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) r0 ( 1 ) = 0.d0 r0 ( 2 ) = spot_size * sqrt_rho * cos ( theta ) r0 ( 3 ) = spot_size * sqrt_rho * sin ( theta ) r0 = matmul ( basis , r0 ) + xyz ! Find edge of plasma call get_plasma ( plasma , pos = r0 ) max_length = 0.0 do while (. not . plasma % in_plasma ) r0 = r0 + vi * dlength ! move dlength call get_plasma ( plasma , pos = r0 ) max_length = max_length + dlength if ( max_length . gt . 300 ) cycle loop_over_los enddo ! Calculate bremsstrahlung along los do while ( plasma % in_plasma ) if ( plasma % te . gt . 0.0 ) then gaunt = 5.542 - ( 3.108 - log ( plasma % te )) * ( 0.6905 - 0.1323 / plasma % zeff ) brems = ( 7.57d-9 ) * gaunt * (( plasma % dene ** 2 ) * plasma % zeff / ( lambda_arr & * sqrt ( plasma % te * 100 0.0 ))) * exp ( - h_planck * c0 / (( 1.d-10 ) * lambda_arr * plasma % te * 1.d3 )) & * dlambda * ( 4.d0 * pi ) * 1.d-4 spec % brems (:, ichan ) = spec % brems (:, ichan ) + ( brems * dlength * 1.d-2 ) / nc endif ! Take a step r0 = r0 + vi * dlength call get_plasma ( plasma , pos = r0 ) enddo enddo loop_over_los enddo loop_over_channels !! $OMP END PARALLEL DO #ifdef _MPI !! Combine Brems call parallel_sum ( spec % brems ) #endif deallocate ( lambda_arr , brems ) end subroutine bremsstrahlung","tags":"","loc":"proc/bremsstrahlung.html","title":"bremsstrahlung – FIDASIM"},{"text":"public subroutine dcx() Calculates Direct Charge Exchange (DCX) neutral density and spectra Arguments None Calls proc~~dcx~~CallsGraph proc~dcx dcx proc~mc_halo mc_halo proc~dcx->proc~mc_halo proc~get_nlaunch get_nlaunch proc~dcx->proc~get_nlaunch proc~ind2sub ind2sub proc~dcx->proc~ind2sub proc~get_plasma get_plasma proc~dcx->proc~get_plasma proc~track track proc~dcx->proc~track interface~parallel_sum parallel_sum proc~dcx->interface~parallel_sum proc~mc_halo->proc~get_plasma interface~randn randn proc~mc_halo->interface~randn interface~randu randu proc~mc_halo->interface~randu proc~rng_init rng_init proc~get_nlaunch->proc~rng_init interface~randind_cdf randind_cdf proc~get_nlaunch->interface~randind_cdf proc~cumsum cumsum proc~get_nlaunch->proc~cumsum proc~uvw_to_xyz uvw_to_xyz proc~get_plasma->proc~uvw_to_xyz proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~get_fields get_fields proc~track->proc~get_fields proc~doppler_stark doppler_stark proc~track->proc~doppler_stark proc~track->proc~in_plasma proc~get_indices get_indices proc~track->proc~get_indices proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~get_fields->proc~uvw_to_xyz proc~get_fields->proc~in_plasma proc~get_fields->proc~xyz_to_uvw proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~rng_seed rng_seed proc~rng_init->proc~rng_seed proc~my_rank my_rank proc~rng_init->proc~my_rank mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocdcxCallsGraph = svgPanZoom('#procdcxCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~dcx~~CalledByGraph proc~dcx dcx program~fidasim fidasim program~fidasim->proc~dcx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code dcx Source Code subroutine dcx !+ Calculates Direct Charge Exchange (DCX) neutral density and spectra integer :: ic , i , j , k , ncell integer ( Int64 ) :: idcx !! counter real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vihalo integer , dimension ( 3 ) :: ind integer , dimension ( 3 ) :: neut_types = [ 1 , 2 , 3 ] !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( Float64 ), dimension ( nlevs ) :: rates !!  CX rates !! Collisiional radiative model along track real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states integer :: ntrack type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks !! Particle tracks integer :: jj !! counter along track real ( Float64 ) :: max_papprox , tot_denn , photons !! photon flux integer , dimension ( beam_grid % ngrid ) :: cell_ind real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox integer ( Int32 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: nlaunch real ( Float64 ) :: fi_correction halo_iter_dens ( dcx_type ) = 0.d0 papprox = 0.d0 tot_denn = 0.d0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) call get_plasma ( plasma , ind = ind ) if (. not . plasma % in_plasma ) cycle tot_denn = sum ( neut % full (:, i , j , k )) + & sum ( neut % half (:, i , j , k )) + & sum ( neut % third (:, i , j , k )) papprox ( i , j , k ) = tot_denn * ( plasma % denp - plasma % denf ) enddo !! TODO: Remove this once we have a 3D interpolation grid max_papprox = maxval ( papprox ) where ( papprox . lt .( max_papprox * 1.d-3 )) papprox = 0.0 endwhere ncell = 0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) if ( papprox ( i , j , k ). gt . 0.0 ) then ncell = ncell + 1 cell_ind ( ncell ) = ic endif enddo call get_nlaunch ( inputs % n_dcx , papprox , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) sum ( nlaunch ) endif !$OMP PARALLEL DO schedule(dynamic,1) private(i,j,k,ic,idcx,ind,vihalo, & !$OMP& ri,tracks,ntrack,rates,denn,states,jj,photons,plasma,fi_correction) loop_over_cells : do ic = istart , ncell , istep call ind2sub ( beam_grid % dims , cell_ind ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) !! Loop over the markers loop_over_dcx : do idcx = 1 , nlaunch ( i , j , k ) !! Calculate ri,vhalo and track call mc_halo ( ind , vihalo , ri ) call track ( ri , vihalo , tracks , ntrack ) if ( ntrack . eq . 0 ) cycle loop_over_dcx !! Calculate CX probability call get_beam_cx_rate ( tracks ( 1 )% ind , ri , vihalo , thermal_ion , neut_types , rates ) if ( sum ( rates ). le . 0. ) cycle loop_over_dcx !! Solve collisional radiative model along track call get_plasma ( plasma , pos = tracks ( 1 )% pos ) !! Weight CX rates by ion source density states = rates * plasma % denp fi_correction = max (( plasma % denp - plasma % denf ) / plasma % denp , 0.d0 ) loop_along_track : do jj = 1 , ntrack call get_plasma ( plasma , pos = tracks ( jj )% pos ) if (. not . plasma % in_plasma ) exit loop_along_track call colrad ( plasma , thermal_ion , vihalo , tracks ( jj )% time , states , denn , photons ) call store_neutrals ( tracks ( jj )% ind , dcx_type , denn / nlaunch ( i , j , k ), vihalo , plasma % in_plasma ) if (( photons . gt . 0.d0 ). and .( inputs % calc_dcx . ge . 1 )) then photons = fi_correction * photons !! Correct for including fast-ions in states call store_bes_photons ( tracks ( jj )% pos , vihalo , photons / nlaunch ( i , j , k ), dcx_type ) endif enddo loop_along_track enddo loop_over_dcx enddo loop_over_cells !$OMP END PARALLEL DO #ifdef _MPI !! Combine densities call parallel_sum ( neut % dcx ) if ( inputs % calc_dcx . ge . 1 ) then call parallel_sum ( spec % dcx ) endif call parallel_sum ( halo_iter_dens ( dcx_type )) #endif end subroutine dcx","tags":"","loc":"proc/dcx.html","title":"dcx – FIDASIM"},{"text":"public subroutine halo() Calculates halo neutral density and spectra Arguments None Calls proc~~halo~~CallsGraph proc~halo halo proc~mc_halo mc_halo proc~halo->proc~mc_halo proc~get_nlaunch get_nlaunch proc~halo->proc~get_nlaunch proc~ind2sub ind2sub proc~halo->proc~ind2sub omp_get_max_threads omp_get_max_threads proc~halo->omp_get_max_threads proc~get_plasma get_plasma proc~halo->proc~get_plasma proc~track track proc~halo->proc~track interface~parallel_sum parallel_sum proc~halo->interface~parallel_sum omp_get_thread_num omp_get_thread_num proc~halo->omp_get_thread_num proc~mc_halo->proc~get_plasma interface~randn randn proc~mc_halo->interface~randn interface~randu randu proc~mc_halo->interface~randu proc~rng_init rng_init proc~get_nlaunch->proc~rng_init interface~randind_cdf randind_cdf proc~get_nlaunch->interface~randind_cdf proc~cumsum cumsum proc~get_nlaunch->proc~cumsum proc~uvw_to_xyz uvw_to_xyz proc~get_plasma->proc~uvw_to_xyz proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~get_fields get_fields proc~track->proc~get_fields proc~doppler_stark doppler_stark proc~track->proc~doppler_stark proc~track->proc~in_plasma proc~get_indices get_indices proc~track->proc~get_indices proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~get_fields->proc~uvw_to_xyz proc~get_fields->proc~in_plasma proc~get_fields->proc~xyz_to_uvw proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~rng_seed rng_seed proc~rng_init->proc~rng_seed proc~my_rank my_rank proc~rng_init->proc~my_rank mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprochaloCallsGraph = svgPanZoom('#prochaloCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~halo~~CalledByGraph proc~halo halo program~fidasim fidasim program~fidasim->proc~halo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code halo Source Code subroutine halo !+ Calculates halo neutral density and spectra integer :: ic , i , j , k , ncell integer ( Int64 ) :: ihalo !! counter real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vihalo !! velocity bulk plasma ion integer , dimension ( 3 ) :: ind , tind !! actual cell !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( Float64 ), dimension ( nlevs ) :: rates !! CX rates !! Collisiional radiative model along track real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states integer :: ntrack type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks !! Particle Tracks integer :: jj !! counter along track real ( Float64 ) :: tot_denn , photons !! photon flux integer , dimension ( beam_grid % ngrid ) :: cell_ind real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox integer ( Int32 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: nlaunch real ( Float64 ), dimension ( nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: dens_prev real ( Float64 ), dimension (:,:,:,:,:), allocatable :: dens_cur real ( Float64 ) :: local_iter_dens integer :: n_slices , cur_slice , is #ifdef _OMP integer , external :: omp_get_max_threads , omp_get_thread_num #endif !! Halo iteration integer ( Int64 ) :: hh , n_halo !! counters real ( Float64 ) :: max_papprox , dcx_dens , halo_iteration_dens , seed_dcx integer :: prev_type ! previous iteration integer :: cur_type ! current iteration real ( Float64 ) :: fi_correction prev_type = fida_type cur_type = brems_type cur_slice = 1 n_slices = 1 #ifdef _OMP n_slices = omp_get_max_threads () #endif allocate ( dens_cur ( nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz , n_slices )) dens_prev = 0.d0 dens_cur = 0.d0 dcx_dens = halo_iter_dens ( dcx_type ) halo_iter_dens ( prev_type ) = dcx_dens if ( dcx_dens . eq . 0 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'HALO: Density of DCX-neutrals is zero' endif stop endif dens_prev = neut % dcx n_halo = inputs % n_halo seed_dcx = 1.0 iterations : do hh = 1 , 200 papprox = 0.d0 tot_denn = 0.d0 halo_iter_dens ( cur_type ) = 0.d0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) call get_plasma ( plasma , ind = ind ) if (. not . plasma % in_plasma ) cycle tot_denn = sum ( dens_prev (:, i , j , k )) papprox ( i , j , k ) = tot_denn * ( plasma % denp - plasma % denf ) enddo !! TODO: Remove this once we have a 3D interpolation grid max_papprox = maxval ( papprox ) where ( papprox . lt .( max_papprox * 1.d-3 )) papprox = 0.0 endwhere cell_ind = 0 ncell = 0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) if ( papprox ( i , j , k ). gt . 0.0 ) then ncell = ncell + 1 cell_ind ( ncell ) = ic endif enddo call get_nlaunch ( n_halo , papprox , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10,\" --- Seed/DCX: \",f5.3)' ) sum ( nlaunch ), seed_dcx endif local_iter_dens = halo_iter_dens ( cur_type ) !$OMP PARALLEL DO schedule(dynamic,1) private(i,j,k,ic,ihalo,ind,vihalo, & !$OMP& ri,tracks,ntrack,rates,denn,states,jj,photons,plasma,tind, cur_slice,fi_correction) & !$OMP& reduction(+: local_iter_dens ) loop_over_cells : do ic = istart , ncell , istep #ifdef _OMP cur_slice = omp_get_thread_num () + 1 #endif call ind2sub ( beam_grid % dims , cell_ind ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) !! Loop over the markers loop_over_halos : do ihalo = 1 , nlaunch ( i , j , k ) !! Calculate ri,vhalo and track call mc_halo ( ind , vihalo , ri ) call track ( ri , vihalo , tracks , ntrack ) if ( ntrack . eq . 0 ) cycle loop_over_halos !! Get plasma parameters at particle location call get_plasma ( plasma , pos = ri ) !! Calculate CX probability tind = tracks ( 1 )% ind call bt_cx_rates ( plasma , dens_prev (:, tind ( 1 ), tind ( 2 ), tind ( 3 )), vihalo , thermal_ion , rates ) if ( sum ( rates ). le . 0. ) cycle loop_over_halos !! Get plasma parameters at mean point in cell call get_plasma ( plasma , pos = tracks ( 1 )% pos ) !! Weight CX rates by ion source density states = rates * plasma % denp fi_correction = max (( plasma % denp - plasma % denf ) / plasma % denp , 0.d0 ) loop_along_track : do jj = 1 , ntrack call get_plasma ( plasma , pos = tracks ( jj )% pos ) if (. not . plasma % in_plasma ) exit loop_along_track call colrad ( plasma , thermal_ion , vihalo , tracks ( jj )% time , states , denn , photons ) !! Store Neutrals tind = tracks ( jj )% ind dens_cur (:, tind ( 1 ), tind ( 2 ), tind ( 3 ), cur_slice ) = & dens_cur (:, tind ( 1 ), tind ( 2 ), tind ( 3 ), cur_slice ) + denn / nlaunch ( i , j , k ) local_iter_dens = & local_iter_dens + sum ( denn ) / nlaunch ( i , j , k ) if (( photons . gt . 0.d0 ). and .( inputs % calc_halo . ge . 1 )) then photons = fi_correction * photons !! Correct for including fast-ions in states call store_bes_photons ( tracks ( jj )% pos , vihalo , photons / nlaunch ( i , j , k ), halo_type ) endif enddo loop_along_track enddo loop_over_halos enddo loop_over_cells !$OMP END PARALLEL DO halo_iter_dens ( cur_type ) = local_iter_dens #ifdef _OMP !$OMP PARALLEL DO private(i,j,is) do i = 1 , beam_grid % nz do j = 1 , beam_grid % ny do is = 2 , n_slices dens_cur (:,:, j , i , 1 ) = dens_cur (:,:, j , i , 1 ) + dens_cur (:,:, j , i , is ) enddo enddo enddo #endif ! at this point, dens_cur(*,1) contains all the info #ifdef _MPI !! Combine densities call parallel_sum ( dens_cur (:,:,:,:, 1 )) call parallel_sum ( halo_iter_dens ( cur_type )) #endif if ( halo_iter_dens ( cur_type ) / halo_iter_dens ( prev_type ). gt . 1.0 ) then write ( * , '(a)' ) \"HALO: Halo generation density exceeded seed density. This shouldn't happen.\" exit iterations endif halo_iteration_dens = halo_iter_dens ( cur_type ) halo_iter_dens ( prev_type ) = halo_iter_dens ( cur_type ) !$OMP PARALLEL DO private(i) do i = 1 , beam_grid % nz neut % halo (:,:,:, i ) = neut % halo (:,:,:, i ) + dens_cur (:,:,:, i , 1 ) dens_prev (:,:,:, i ) = dens_cur (:,:,:, i , 1 ) dens_cur (:,:,:, i ,:) = 0.d0 enddo seed_dcx = halo_iteration_dens / dcx_dens n_halo = int ( inputs % n_halo * seed_dcx , Int64 ) if ( seed_dcx . lt . 0.01 ) exit iterations enddo iterations #ifdef _MPI !! Combine Spectra if ( inputs % calc_halo . ge . 1 ) then call parallel_sum ( spec % halo ) endif #endif deallocate ( dens_cur ) end subroutine halo","tags":"","loc":"proc/halo.html","title":"halo – FIDASIM"},{"text":"public subroutine nbi_spec() Calculates approximate neutral beam emission (full, half, third)\n from user supplied neutrals file Arguments None Calls proc~~nbi_spec~~CallsGraph proc~nbi_spec nbi_spec proc~store_photons store_photons proc~nbi_spec->proc~store_photons proc~mc_nbi_cell mc_nbi_cell proc~nbi_spec->proc~mc_nbi_cell proc~ind2sub ind2sub proc~nbi_spec->proc~ind2sub proc~in_plasma in_plasma proc~nbi_spec->proc~in_plasma interface~randu randu proc~nbi_spec->interface~randu interface~parallel_sum parallel_sum proc~nbi_spec->interface~parallel_sum proc~get_fields get_fields proc~store_photons->proc~get_fields proc~get_passive_grid_indices get_passive_grid_indices proc~store_photons->proc~get_passive_grid_indices proc~get_indices get_indices proc~store_photons->proc~get_indices proc~uvw_to_xyz uvw_to_xyz proc~store_photons->proc~uvw_to_xyz proc~spectrum spectrum proc~store_photons->proc~spectrum proc~mc_nbi_cell->interface~randu interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~get_fields->proc~in_plasma proc~get_fields->proc~uvw_to_xyz proc~get_fields->proc~xyz_to_uvw proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr mpi_allreduce mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocnbi_specCallsGraph = svgPanZoom('#procnbi_specCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~nbi_spec~~CalledByGraph proc~nbi_spec nbi_spec program~fidasim fidasim program~fidasim->proc~nbi_spec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code nbi_spec Source Code subroutine nbi_spec !+ Calculates approximate neutral beam emission (full, half, third) !+ from user supplied neutrals file integer :: ic , i , j , k , it real ( Float64 ), dimension ( 3 ) :: ri , vnbi , random3 , rc integer , dimension ( 3 ) :: ind !! Determination of the CX probability real ( Float64 ) :: nbif_photons , nbih_photons , nbit_photons real ( Float64 ) :: f_wght , h_wght , t_wght real ( Float64 ) :: f_tot , h_tot , t_tot real ( Float64 ), dimension ( inputs % nlambda , spec_chords % nchan ) :: full , half , third logical :: inp integer :: n = 10000 !$OMP PARALLEL DO schedule(dynamic,1) private(i,j,k,ic,ind, & !$OMP& nbif_photons, nbih_photons, nbit_photons, rc, ri,inp, vnbi,& !$OMP& random3,f_tot,h_tot,t_tot,full,half,third,f_wght,h_wght,t_wght) loop_over_cells : do ic = istart , spec_chords % ncell , istep call ind2sub ( beam_grid % dims , spec_chords % cell ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) nbif_photons = neut % full ( 3 , i , j , k ) * tables % einstein ( 2 , 3 ) nbih_photons = neut % half ( 3 , i , j , k ) * tables % einstein ( 2 , 3 ) nbit_photons = neut % third ( 3 , i , j , k ) * tables % einstein ( 2 , 3 ) if (( nbif_photons + nbih_photons + nbit_photons ). le . 0.0 ) then cycle loop_over_cells endif rc = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] !Find a point in cell that is also in the plasma ri = rc call in_plasma ( ri , inp ) do while (. not . inp ) call randu ( random3 ) ri = rc + beam_grid % dr * ( random3 - 0.5 ) call in_plasma ( ri , inp ) enddo f_tot = 0.0 ; h_tot = 0.0 ; t_tot = 0.0 full = 0.0 ; half = 0.0 ; third = 0.0 do it = 1 , n !! Full Spectra call mc_nbi_cell ( ind , nbif_type , vnbi , f_wght ) f_tot = f_tot + f_wght call store_photons ( ri , vnbi , f_wght * nbif_photons , full ) !! Half Spectra call mc_nbi_cell ( ind , nbih_type , vnbi , h_wght ) h_tot = h_tot + h_wght call store_photons ( ri , vnbi , h_wght * nbih_photons , half ) !! Third Spectra call mc_nbi_cell ( ind , nbit_type , vnbi , t_wght ) t_tot = t_tot + t_wght call store_photons ( ri , vnbi , t_wght * nbit_photons , third ) enddo !$OMP CRITICAL(nbi_spec_1) spec % full = spec % full + full / f_tot spec % half = spec % half + half / h_tot spec % third = spec % third + third / t_tot !$OMP END CRITICAL(nbi_spec_1) enddo loop_over_cells !$OMP END PARALLEL DO #ifdef _MPI !! Combine Spectra call parallel_sum ( spec % full ) call parallel_sum ( spec % half ) call parallel_sum ( spec % third ) #endif end subroutine nbi_spec","tags":"","loc":"proc/nbi_spec.html","title":"nbi_spec – FIDASIM"},{"text":"public subroutine dcx_spec() Calculates DCX emission from user supplied neutrals file Arguments None Calls proc~~dcx_spec~~CallsGraph proc~dcx_spec dcx_spec proc~store_photons store_photons proc~dcx_spec->proc~store_photons proc~ind2sub ind2sub proc~dcx_spec->proc~ind2sub proc~get_plasma get_plasma proc~dcx_spec->proc~get_plasma proc~in_plasma in_plasma proc~dcx_spec->proc~in_plasma interface~randu randu proc~dcx_spec->interface~randu interface~parallel_sum parallel_sum proc~dcx_spec->interface~parallel_sum interface~randn randn proc~dcx_spec->interface~randn proc~get_fields get_fields proc~store_photons->proc~get_fields proc~get_passive_grid_indices get_passive_grid_indices proc~store_photons->proc~get_passive_grid_indices proc~get_indices get_indices proc~store_photons->proc~get_indices proc~uvw_to_xyz uvw_to_xyz proc~store_photons->proc~uvw_to_xyz proc~spectrum spectrum proc~store_photons->proc~spectrum proc~get_plasma->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~get_plasma->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~get_fields->proc~in_plasma proc~get_fields->proc~uvw_to_xyz proc~get_fields->proc~xyz_to_uvw proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr mpi_allreduce mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~parallel_sum_i2->mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~cyl_to_xyz->proc~cyl_to_uvw proc~cyl_to_xyz->proc~uvw_to_xyz proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocdcx_specCallsGraph = svgPanZoom('#procdcx_specCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~dcx_spec~~CalledByGraph proc~dcx_spec dcx_spec program~fidasim fidasim program~fidasim->proc~dcx_spec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code dcx_spec Source Code subroutine dcx_spec !+ Calculates DCX emission from user supplied neutrals file integer :: ic , i , j , k , it real ( Float64 ), dimension ( 3 ) :: ri , vhalo , random3 , rc integer , dimension ( 3 ) :: ind !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( Float64 ) :: dcx_photons logical :: inp integer :: n = 10000 !$OMP PARALLEL DO schedule(dynamic,1) private(i,j,k,ic,ind, & !$OMP& dcx_photons, rc, ri, inp, vhalo, random3, plasma) loop_over_cells : do ic = istart , spec_chords % ncell , istep call ind2sub ( beam_grid % dims , spec_chords % cell ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) dcx_photons = neut % dcx ( 3 , i , j , k ) * tables % einstein ( 2 , 3 ) if ( dcx_photons . le . 0.0 ) cycle loop_over_cells rc = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] !Find a point in cell that is also in the plasma ri = rc call in_plasma ( ri , inp ) do while (. not . inp ) call randu ( random3 ) ri = rc + beam_grid % dr * ( random3 - 0.5 ) call in_plasma ( ri , inp ) enddo call get_plasma ( plasma , pos = ri ) do it = 1 , n !! DCX Spectra call randn ( random3 ) vhalo = plasma % vrot + sqrt ( plasma % ti * 0.5 / ( v2_to_E_per_amu * inputs % ai )) * random3 call store_photons ( ri , vhalo , dcx_photons / n , spec % dcx ) enddo enddo loop_over_cells !$OMP END PARALLEL DO #ifdef _MPI !! Combine Spectra call parallel_sum ( spec % dcx ) #endif end subroutine dcx_spec","tags":"","loc":"proc/dcx_spec.html","title":"dcx_spec – FIDASIM"},{"text":"public subroutine halo_spec() Calculates halo emission from user supplied neutrals file Arguments None Calls proc~~halo_spec~~CallsGraph proc~halo_spec halo_spec proc~store_photons store_photons proc~halo_spec->proc~store_photons proc~ind2sub ind2sub proc~halo_spec->proc~ind2sub proc~get_plasma get_plasma proc~halo_spec->proc~get_plasma proc~in_plasma in_plasma proc~halo_spec->proc~in_plasma interface~randu randu proc~halo_spec->interface~randu interface~parallel_sum parallel_sum proc~halo_spec->interface~parallel_sum interface~randn randn proc~halo_spec->interface~randn proc~get_fields get_fields proc~store_photons->proc~get_fields proc~get_passive_grid_indices get_passive_grid_indices proc~store_photons->proc~get_passive_grid_indices proc~get_indices get_indices proc~store_photons->proc~get_indices proc~uvw_to_xyz uvw_to_xyz proc~store_photons->proc~uvw_to_xyz proc~spectrum spectrum proc~store_photons->proc~spectrum proc~get_plasma->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~get_plasma->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~get_fields->proc~in_plasma proc~get_fields->proc~uvw_to_xyz proc~get_fields->proc~xyz_to_uvw proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr mpi_allreduce mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~parallel_sum_i2->mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~cyl_to_xyz->proc~cyl_to_uvw proc~cyl_to_xyz->proc~uvw_to_xyz proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprochalo_specCallsGraph = svgPanZoom('#prochalo_specCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~halo_spec~~CalledByGraph proc~halo_spec halo_spec program~fidasim fidasim program~fidasim->proc~halo_spec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code halo_spec Source Code subroutine halo_spec !+ Calculates halo emission from user supplied neutrals file integer :: ic , i , j , k , it real ( Float64 ), dimension ( 3 ) :: ri , vhalo , random3 , rc integer , dimension ( 3 ) :: ind !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( Float64 ) :: halo_photons logical :: inp integer :: n = 10000 !$OMP PARALLEL DO schedule(dynamic,1) private(i,j,k,ic,ind, & !$OMP& halo_photons, rc, ri, inp, vhalo, random3, plasma) loop_over_cells : do ic = istart , spec_chords % ncell , istep call ind2sub ( beam_grid % dims , spec_chords % cell ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) halo_photons = neut % halo ( 3 , i , j , k ) * tables % einstein ( 2 , 3 ) if ( halo_photons . le . 0.0 ) cycle loop_over_cells rc = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] !Find a point in cell that is also in the plasma ri = rc call in_plasma ( ri , inp ) do while (. not . inp ) call randu ( random3 ) ri = rc + beam_grid % dr * ( random3 - 0.5 ) call in_plasma ( ri , inp ) enddo call get_plasma ( plasma , pos = ri ) do it = 1 , n !! Halo Spectra call randn ( random3 ) vhalo = plasma % vrot + sqrt ( plasma % ti * 0.5 / ( v2_to_E_per_amu * inputs % ai )) * random3 call store_photons ( ri , vhalo , halo_photons / n , spec % halo ) enddo enddo loop_over_cells !$OMP END PARALLEL DO #ifdef _MPI !! Combine Spectra call parallel_sum ( spec % halo ) #endif end subroutine halo_spec","tags":"","loc":"proc/halo_spec.html","title":"halo_spec – FIDASIM"},{"text":"public subroutine cold_spec() Calculates cold D-alpha emission Arguments None Calls proc~~cold_spec~~CallsGraph proc~cold_spec cold_spec proc~ind2sub ind2sub proc~cold_spec->proc~ind2sub proc~store_photons store_photons proc~cold_spec->proc~store_photons proc~get_plasma get_plasma proc~cold_spec->proc~get_plasma interface~parallel_sum parallel_sum proc~cold_spec->interface~parallel_sum interface~randn randn proc~cold_spec->interface~randn proc~get_fields get_fields proc~store_photons->proc~get_fields proc~get_passive_grid_indices get_passive_grid_indices proc~store_photons->proc~get_passive_grid_indices proc~get_indices get_indices proc~store_photons->proc~get_indices proc~uvw_to_xyz uvw_to_xyz proc~store_photons->proc~uvw_to_xyz proc~spectrum spectrum proc~store_photons->proc~spectrum proc~get_position get_position proc~get_plasma->proc~get_position proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~get_plasma->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~get_fields->proc~in_plasma proc~get_fields->proc~uvw_to_xyz proc~get_fields->proc~xyz_to_uvw proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~parallel_sum_i2->mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~in_plasma->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panproccold_specCallsGraph = svgPanZoom('#proccold_specCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~cold_spec~~CalledByGraph proc~cold_spec cold_spec program~fidasim fidasim program~fidasim->proc~cold_spec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code cold_spec Source Code subroutine cold_spec !+ Calculates cold D-alpha emission integer :: ic , i , j , k , it , ncell real ( Float64 ), dimension ( 3 ) :: ri , vhalo , random3 integer , dimension ( 3 ) :: ind !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( Float64 ) :: cold_photons integer :: n = 10000 !$OMP PARALLEL DO schedule(dynamic,1) private(i,j,k,ic,ind, & !$OMP& cold_photons, ri, vhalo, random3, plasma) loop_over_cells : do ic = istart , spec_chords % ncell , istep call ind2sub ( beam_grid % dims , spec_chords % cell ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) ri = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] call get_plasma ( plasma , pos = ri ) cold_photons = plasma % denn ( 3 ) * tables % einstein ( 2 , 3 ) if ( cold_photons . le . 0.0 ) cycle loop_over_cells do it = 1 , n !! Cold Spectra call randn ( random3 ) vhalo = plasma % vrot + sqrt ( plasma % ti * 0.5 / ( v2_to_E_per_amu * inputs % ai )) * random3 call store_photons ( ri , vhalo , cold_photons / n , spec % cold ) enddo enddo loop_over_cells !$OMP END PARALLEL DO #ifdef _MPI !! Combine Spectra call parallel_sum ( spec % cold ) #endif end subroutine cold_spec","tags":"","loc":"proc/cold_spec.html","title":"cold_spec – FIDASIM"},{"text":"public subroutine fida_f() Calculate Active FIDA emission using a Fast-ion distribution function F(E,p,r,z) Arguments None Calls proc~~fida_f~~CallsGraph proc~fida_f fida_f proc~get_nlaunch get_nlaunch proc~fida_f->proc~get_nlaunch proc~ind2sub ind2sub proc~fida_f->proc~ind2sub proc~get_plasma get_plasma proc~fida_f->proc~get_plasma proc~track track proc~fida_f->proc~track proc~gyro_correction gyro_correction proc~fida_f->proc~gyro_correction interface~parallel_sum parallel_sum proc~fida_f->interface~parallel_sum proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion interface~randind_cdf randind_cdf proc~get_nlaunch->interface~randind_cdf proc~cumsum cumsum proc~get_nlaunch->proc~cumsum proc~rng_init rng_init proc~get_nlaunch->proc~rng_init proc~get_position get_position proc~get_plasma->proc~get_position proc~uvw_to_xyz uvw_to_xyz proc~get_plasma->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~get_indices get_indices proc~track->proc~get_indices proc~track->proc~in_plasma proc~get_fields get_fields proc~track->proc~get_fields proc~doppler_stark doppler_stark proc~track->proc~doppler_stark proc~pitch_to_vec pitch_to_vec proc~gyro_correction->proc~pitch_to_vec proc~gyro_step gyro_step proc~gyro_correction->proc~gyro_step interface~randu randu proc~gyro_correction->interface~randu proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~get_distribution get_distribution proc~mc_fastion->proc~get_distribution proc~mc_fastion->interface~randu proc~mc_fastion->proc~get_fields interface~randind randind proc~mc_fastion->interface~randind proc~get_distribution->proc~xyz_to_uvw interface~interpol interpol proc~get_distribution->interface~interpol proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz mpi_allreduce mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~cross_product cross_product proc~gyro_step->proc~cross_product proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~get_fields->proc~uvw_to_xyz proc~get_fields->proc~xyz_to_uvw proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~rng_seed rng_seed proc~rng_init->proc~rng_seed proc~my_rank my_rank proc~rng_init->proc~my_rank proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol3d_arr interpol3D_arr interface~interpol->proc~interpol3d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol3d_2d_arr interpol3D_2D_arr interface~interpol->proc~interpol3d_2d_arr proc~interpol2d_arr->interface~interpol_coeff proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol3d_2d_arr->interface~interpol_coeff var panprocfida_fCallsGraph = svgPanZoom('#procfida_fCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fida_f~~CalledByGraph proc~fida_f fida_f program~fidasim fidasim program~fidasim->proc~fida_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fida_f Source Code subroutine fida_f !+ Calculate Active FIDA emission using a Fast-ion distribution function F(E,p,r,z) integer :: i , j , k , ic , ncell integer ( Int64 ) :: iion real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions real ( Float64 ) :: denf !! fast-ion density integer , dimension ( 3 ) :: ind !! new actual cell integer , dimension ( 5 ) :: neut_types = [ 1 , 2 , 3 , 4 , 5 ] logical :: los_intersect !! Determination of the CX probability type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: rates !! CX rates !! Collisiional radiative model along track integer :: ntrack integer :: jj !! counter along track type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks real ( Float64 ) :: photons !! photon flux real ( Float64 ), dimension ( nlevs ) :: states !! Density of n-states real ( Float64 ), dimension ( nlevs ) :: denn !! Number of particles to launch real ( Float64 ) :: max_papprox , eb , ptch integer , dimension ( beam_grid % ngrid ) :: cell_ind real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox integer ( Int32 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: nlaunch !! Estimate how many particles to launch in each cell papprox = 0.d0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) call get_plasma ( plasma , ind = ind ) if (. not . plasma % in_plasma ) cycle papprox ( i , j , k ) = ( sum ( neut % full (:, i , j , k )) + & sum ( neut % half (:, i , j , k )) + & sum ( neut % third (:, i , j , k )) + & sum ( neut % dcx (:, i , j , k )) + & sum ( neut % halo (:, i , j , k ))) * & plasma % denf enddo !! TODO: Remove this once we have a 3D interpolation grid max_papprox = maxval ( papprox ) where ( papprox . lt .( max_papprox * 1.d-3 )) papprox = 0.0 endwhere ncell = 0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) if ( papprox ( i , j , k ). gt . 0.0 ) then ncell = ncell + 1 cell_ind ( ncell ) = ic endif enddo call get_nlaunch ( inputs % n_fida , papprox , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) sum ( nlaunch ) endif !! Loop over all cells that have neutrals !$OMP PARALLEL DO schedule(dynamic,1) private(ic,i,j,k,ind,iion,vi,ri,fields, & !$OMP tracks,ntrack,jj,plasma,rates,denn,states,photons,denf,eb,ptch,los_intersect) loop_over_cells : do ic = istart , ncell , istep call ind2sub ( beam_grid % dims , cell_ind ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) loop_over_fast_ions : do iion = 1 , nlaunch ( i , j , k ) !! Sample fast ion distribution for velocity and position call mc_fastion ( ind , fields , eb , ptch , denf ) if ( denf . le . 0.0 ) cycle loop_over_fast_ions !! Correct for gyro motion and get particle position and velocity call gyro_correction ( fields , eb , ptch , ri , vi ) !! Find the particles path through the beam grid call track ( ri , vi , tracks , ntrack , los_intersect ) if (. not . los_intersect ) cycle loop_over_fast_ions if ( ntrack . eq . 0 ) cycle loop_over_fast_ions !! Calculate CX probability with beam and halo neutrals call get_beam_cx_rate ( tracks ( 1 )% ind , ri , vi , beam_ion , neut_types , rates ) if ( sum ( rates ). le . 0. ) cycle loop_over_fast_ions !! Weight CX rates by ion source density states = rates * denf !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ntrack call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fida_photons ( tracks ( jj )% pos , vi , photons / nlaunch ( i , j , k )) enddo loop_along_track enddo loop_over_fast_ions enddo loop_over_cells !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( spec % fida ) #endif end subroutine fida_f","tags":"","loc":"proc/fida_f.html","title":"fida_f – FIDASIM"},{"text":"public subroutine pfida_f() Calculate Passive FIDA emission using a Fast-ion distribution function F(E,p,r,z) Arguments None Calls proc~~pfida_f~~CallsGraph proc~pfida_f pfida_f proc~track_cylindrical track_cylindrical proc~pfida_f->proc~track_cylindrical proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~pfida_f->proc~mc_fastion_pass_grid proc~ind2sub ind2sub proc~pfida_f->proc~ind2sub proc~get_plasma get_plasma proc~pfida_f->proc~get_plasma proc~bt_cx_rates bt_cx_rates proc~pfida_f->proc~bt_cx_rates proc~get_nlaunch_pass_grid get_nlaunch_pass_grid proc~pfida_f->proc~get_nlaunch_pass_grid proc~gyro_correction gyro_correction proc~pfida_f->proc~gyro_correction interface~parallel_sum parallel_sum proc~pfida_f->interface~parallel_sum proc~plane_basis plane_basis proc~track_cylindrical->proc~plane_basis proc~cyl_to_uvw cyl_to_uvw proc~track_cylindrical->proc~cyl_to_uvw proc~get_passive_grid_indices get_passive_grid_indices proc~track_cylindrical->proc~get_passive_grid_indices proc~in_plasma in_plasma proc~track_cylindrical->proc~in_plasma proc~get_fields get_fields proc~track_cylindrical->proc~get_fields proc~doppler_stark doppler_stark proc~track_cylindrical->proc~doppler_stark proc~get_distribution get_distribution proc~mc_fastion_pass_grid->proc~get_distribution proc~mc_fastion_pass_grid->proc~cyl_to_uvw interface~randu randu proc~mc_fastion_pass_grid->interface~randu proc~mc_fastion_pass_grid->proc~get_fields interface~randind randind proc~mc_fastion_pass_grid->interface~randind proc~get_position get_position proc~get_plasma->proc~get_position proc~uvw_to_xyz uvw_to_xyz proc~get_plasma->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~get_plasma->proc~in_plasma interface~interpol_coeff interpol_coeff proc~bt_cx_rates->interface~interpol_coeff interface~randind_cdf randind_cdf proc~get_nlaunch_pass_grid->interface~randind_cdf proc~rng_init rng_init proc~get_nlaunch_pass_grid->proc~rng_init proc~pitch_to_vec pitch_to_vec proc~gyro_correction->proc~pitch_to_vec proc~gyro_step gyro_step proc~gyro_correction->proc~gyro_step proc~gyro_correction->interface~randu proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~get_distribution->proc~xyz_to_uvw interface~interpol interpol proc~get_distribution->interface~interpol proc~cross_product cross_product proc~plane_basis->proc~cross_product proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz mpi_allreduce mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~gyro_step->proc~cross_product proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~in_plasma->proc~cyl_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol_coeff proc~get_fields->proc~uvw_to_xyz proc~get_fields->proc~xyz_to_uvw proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~rng_seed rng_seed proc~rng_init->proc~rng_seed proc~my_rank my_rank proc~rng_init->proc~my_rank proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~cyl_to_xyz->proc~cyl_to_uvw proc~cyl_to_xyz->proc~uvw_to_xyz proc~interpol3d_arr interpol3D_arr interface~interpol->proc~interpol3d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol3d_2d_arr interpol3D_2D_arr interface~interpol->proc~interpol3d_2d_arr proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol3d_2d_arr->interface~interpol_coeff var panprocpfida_fCallsGraph = svgPanZoom('#procpfida_fCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pfida_f~~CalledByGraph proc~pfida_f pfida_f program~fidasim fidasim program~fidasim->proc~pfida_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pfida_f Source Code subroutine pfida_f !+ Calculate Passive FIDA emission using a Fast-ion distribution function F(E,p,r,z) integer :: i , j , k , ic , ncell integer ( Int64 ) :: iion real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions real ( Float64 ), dimension ( 3 ) :: xyz_vi real ( Float64 ) :: denf !! fast-ion density integer , dimension ( 3 ) :: ind !! new actual cell logical :: los_intersect !! Determination of the CX probability type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: rates !! CX rates !! Collisiional radiative model along track integer :: ntrack integer :: jj !! counter along track type ( ParticleTrack ), dimension ( pass_grid % ntrack ) :: tracks real ( Float64 ) :: photons !! photon flux real ( Float64 ), dimension ( nlevs ) :: states !! Density of n-states real ( Float64 ), dimension ( nlevs ) :: denn !! Number of particles to launch real ( Float64 ) :: max_papprox , eb , ptch integer , dimension ( pass_grid % ngrid ) :: cell_ind real ( Float64 ), dimension ( pass_grid % nr , pass_grid % nz , pass_grid % nphi ) :: papprox integer ( Int32 ), dimension ( pass_grid % nr , pass_grid % nz , pass_grid % nphi ) :: nlaunch !! Estimate how many particles to launch in each cell papprox = 0.d0 do ic = 1 , pass_grid % ngrid call ind2sub ( pass_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) call get_plasma ( plasma , ind = ind , input_coords = 2 ) if (. not . plasma % in_plasma ) cycle papprox ( i , j , k ) = sum ( plasma % denn ) * plasma % denf enddo max_papprox = maxval ( papprox ) where ( papprox . lt .( max_papprox * 1.d-3 )) papprox = 0.0 endwhere ncell = 0 do ic = 1 , pass_grid % ngrid call ind2sub ( pass_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) if ( papprox ( i , j , k ). gt . 0.0 ) then ncell = ncell + 1 cell_ind ( ncell ) = ic endif enddo call get_nlaunch_pass_grid ( inputs % n_pfida , papprox , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) sum ( nlaunch ) endif !! Loop over all cells that have neutrals !$OMP PARALLEL DO schedule(dynamic,1) private(ic,i,j,k,ind,iion,vi,xyz_vi,ri,fields, & !$OMP tracks,ntrack,jj,plasma,rates,denn,states,photons,denf,eb,ptch,los_intersect) loop_over_cells : do ic = istart , ncell , istep call ind2sub ( pass_grid % dims , cell_ind ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) loop_over_fast_ions : do iion = 1 , nlaunch ( i , j , k ) !! Sample fast ion distribution for velocity and position call mc_fastion_pass_grid ( ind , fields , eb , ptch , denf , output_coords = 1 ) if ( denf . le . 0.0 ) cycle loop_over_fast_ions !! Correct for gyro motion and get particle position and velocity call gyro_correction ( fields , eb , ptch , ri , vi ) xyz_vi = matmul ( beam_grid % inv_basis , vi ) !! Find the particles path through the interpolation grid call track_cylindrical ( ri , vi , tracks , ntrack , los_intersect ) if (. not . los_intersect ) cycle loop_over_fast_ions if ( ntrack . eq . 0 ) cycle loop_over_fast_ions !! Calculate CX probability with beam and halo neutrals call get_plasma ( plasma , pos = ri , input_coords = 1 ) call bt_cx_rates ( plasma , plasma % denn , xyz_vi , beam_ion , rates ) if ( sum ( rates ). le . 0. ) cycle loop_over_fast_ions !! Weight CX rates by ion source density states = rates * denf !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ntrack call get_plasma ( plasma , pos = tracks ( jj )% pos , input_coords = 1 ) call colrad ( plasma , beam_ion , xyz_vi , tracks ( jj )% time , states , denn , photons ) call store_fida_photons ( tracks ( jj )% pos , xyz_vi , photons / nlaunch ( i , j , k ), passive = . True .) enddo loop_along_track enddo loop_over_fast_ions enddo loop_over_cells !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( spec % pfida ) #endif end subroutine pfida_f","tags":"","loc":"proc/pfida_f.html","title":"pfida_f – FIDASIM"},{"text":"public subroutine fida_mc() Calculate Active FIDA emission using a Monte Carlo Fast-ion distribution Arguments None Calls proc~~fida_mc~~CallsGraph proc~fida_mc fida_mc proc~get_fields get_fields proc~fida_mc->proc~get_fields proc~uvw_to_xyz uvw_to_xyz proc~fida_mc->proc~uvw_to_xyz interface~randu randu proc~fida_mc->interface~randu proc~track track proc~fida_mc->proc~track proc~gyro_correction gyro_correction proc~fida_mc->proc~gyro_correction interface~parallel_sum parallel_sum proc~fida_mc->interface~parallel_sum proc~get_fields->proc~uvw_to_xyz proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~track->proc~get_fields proc~doppler_stark doppler_stark proc~track->proc~doppler_stark proc~track->proc~in_plasma proc~get_indices get_indices proc~track->proc~get_indices proc~gyro_correction->interface~randu proc~gyro_step gyro_step proc~gyro_correction->proc~gyro_step proc~pitch_to_vec pitch_to_vec proc~gyro_correction->proc~pitch_to_vec proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~in_plasma->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cross_product cross_product proc~gyro_step->proc~cross_product proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocfida_mcCallsGraph = svgPanZoom('#procfida_mcCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fida_mc~~CalledByGraph proc~fida_mc fida_mc program~fidasim fidasim program~fidasim->proc~fida_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fida_mc Source Code subroutine fida_mc !+ Calculate Active FIDA emission using a Monte Carlo Fast-ion distribution integer :: iion , igamma , ngamma type ( FastIon ) :: fast_ion type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma real ( Float64 ) :: phi real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions !! Determination of the CX probability real ( Float64 ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( Float64 ), dimension ( nlevs ) :: rates !! CX rates !! Collisiional radiative model along track real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states integer :: ntrack type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks logical :: los_intersect integer :: jj !! counter along track real ( Float64 ) :: photons !! photon flux integer , dimension ( 5 ) :: neut_types = [ 1 , 2 , 3 , 4 , 5 ] real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ) :: s , c real ( Float64 ), dimension ( 1 ) :: randomu ngamma = 1 if ( particles % axisym . or .( inputs % dist_type . eq . 2 )) then ngamma = ceiling ( dble ( inputs % n_fida ) / particles % nparticle ) endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) int ( particles % nparticle * ngamma , Int64 ) endif !$OMP PARALLEL DO schedule(dynamic,1) private(iion,igamma,fast_ion,vi,ri,phi,tracks,s,c, & !$OMP& randomu,plasma,fields,uvw,uvw_vi,ntrack,jj,rates,denn,los_intersect,states,photons) loop_over_fast_ions : do iion = istart , particles % nparticle , istep fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0 ) cycle loop_over_fast_ions if (. not . fast_ion % beam_grid_cross_grid ) cycle loop_over_fast_ions gamma_loop : do igamma = 1 , ngamma if ( particles % axisym ) then !! Pick random toroidal angle call randu ( randomu ) phi = fast_ion % beam_grid_phi_enter + fast_ion % delta_phi * randomu ( 1 ) else phi = fast_ion % phi endif s = sin ( phi ) c = cos ( phi ) !! Calculate position in machine coordinates uvw ( 1 ) = fast_ion % r * c uvw ( 2 ) = fast_ion % r * s uvw ( 3 ) = fast_ion % z !! Convert to beam grid coordinates call uvw_to_xyz ( uvw , ri ) if ( inputs % dist_type . eq . 2 ) then !! Get electomagnetic fields call get_fields ( fields , pos = ri ) !! Correct for gyro motion and get particle position and velocity call gyro_correction ( fields , fast_ion % energy , fast_ion % pitch , ri , vi ) else !! Full Orbit !! Calculate velocity vector uvw_vi ( 1 ) = c * fast_ion % vr - s * fast_ion % vt uvw_vi ( 2 ) = s * fast_ion % vr + c * fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) endif !! Track particle through grid call track ( ri , vi , tracks , ntrack , los_intersect ) if (. not . los_intersect ) cycle gamma_loop if ( ntrack . eq . 0 ) cycle gamma_loop !! Calculate CX probability call get_beam_cx_rate ( tracks ( 1 )% ind , ri , vi , beam_ion , neut_types , rates ) if ( sum ( rates ). le . 0. ) cycle gamma_loop !! Weight CX rates by ion source density states = rates * fast_ion % weight * ( fast_ion % delta_phi / ( 2 * pi )) / beam_grid % dv / ngamma !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ntrack call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fida_photons ( tracks ( jj )% pos , vi , photons , fast_ion % class ) enddo loop_along_track enddo gamma_loop enddo loop_over_fast_ions !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( spec % fida ) #endif end subroutine fida_mc","tags":"","loc":"proc/fida_mc.html","title":"fida_mc – FIDASIM"},{"text":"public subroutine pfida_mc() Calculate Passive FIDA emission using a Monte Carlo Fast-ion distribution Arguments None Calls proc~~pfida_mc~~CallsGraph proc~pfida_mc pfida_mc proc~get_fields get_fields proc~pfida_mc->proc~get_fields proc~track_cylindrical track_cylindrical proc~pfida_mc->proc~track_cylindrical proc~get_plasma get_plasma proc~pfida_mc->proc~get_plasma proc~gyro_correction gyro_correction proc~pfida_mc->proc~gyro_correction proc~bt_cx_rates bt_cx_rates proc~pfida_mc->proc~bt_cx_rates interface~randu randu proc~pfida_mc->interface~randu interface~parallel_sum parallel_sum proc~pfida_mc->interface~parallel_sum proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~track_cylindrical->proc~get_fields proc~doppler_stark doppler_stark proc~track_cylindrical->proc~doppler_stark proc~cyl_to_uvw cyl_to_uvw proc~track_cylindrical->proc~cyl_to_uvw proc~plane_basis plane_basis proc~track_cylindrical->proc~plane_basis proc~get_passive_grid_indices get_passive_grid_indices proc~track_cylindrical->proc~get_passive_grid_indices proc~track_cylindrical->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~get_plasma->proc~in_plasma proc~get_plasma->proc~uvw_to_xyz proc~get_plasma->proc~xyz_to_uvw proc~gyro_correction->interface~randu proc~gyro_step gyro_step proc~gyro_correction->proc~gyro_step proc~pitch_to_vec pitch_to_vec proc~gyro_correction->proc~pitch_to_vec interface~interpol_coeff interpol_coeff proc~bt_cx_rates->interface~interpol_coeff proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr mpi_allreduce mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~cross_product cross_product proc~plane_basis->proc~cross_product proc~parallel_sum_d4->mpi_allreduce proc~in_plasma->interface~interpol_coeff proc~in_plasma->proc~cyl_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~gyro_step->proc~cross_product proc~parallel_sum_i2->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~cyl_to_xyz->proc~cyl_to_uvw proc~cyl_to_xyz->proc~uvw_to_xyz proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocpfida_mcCallsGraph = svgPanZoom('#procpfida_mcCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pfida_mc~~CalledByGraph proc~pfida_mc pfida_mc program~fidasim fidasim program~fidasim->proc~pfida_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pfida_mc Source Code subroutine pfida_mc !+ Calculate Passive FIDA emission using a Monte Carlo Fast-ion distribution integer :: iion , igamma , ngamma type ( FastIon ) :: fast_ion type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma real ( Float64 ) :: phi real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions real ( Float64 ), dimension ( 3 ) :: xyz_vi !! Determination of the CX probability real ( Float64 ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( Float64 ), dimension ( nlevs ) :: rates !! CX rates !! Collisiional radiative model along track real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states type ( ParticleTrack ), dimension ( pass_grid % ntrack ) :: tracks integer :: ntrack logical :: los_intersect integer :: jj !! counter along track real ( Float64 ) :: photons !! photon flux real ( Float64 ) :: s , c real ( Float64 ), dimension ( 1 ) :: randomu ngamma = 1 if ( particles % axisym . or .( inputs % dist_type . eq . 2 )) then ngamma = ceiling ( dble ( inputs % n_pfida ) / particles % nparticle ) endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) int ( particles % nparticle * ngamma , Int64 ) endif !$OMP PARALLEL DO schedule(dynamic,1) private(iion,igamma,fast_ion,vi,ri,phi,tracks,s,c,& !$OMP& randomu,plasma,fields,ntrack,jj,rates,denn,los_intersect,states,photons,xyz_vi) loop_over_fast_ions : do iion = istart , particles % nparticle , istep fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0 ) cycle loop_over_fast_ions gamma_loop : do igamma = 1 , ngamma if ( particles % axisym ) then !! Pick random toroidal angle call randu ( randomu ) phi = pass_grid % phi ( 1 ) + pass_grid % nphi * pass_grid % dphi * randomu ( 1 ) else phi = fast_ion % phi endif s = sin ( phi ) c = cos ( phi ) !! Calculate position in machine coordinates ri ( 1 ) = fast_ion % r * c ri ( 2 ) = fast_ion % r * s ri ( 3 ) = fast_ion % z if ( inputs % dist_type . eq . 2 ) then !! Get electomagnetic fields call get_fields ( fields , pos = ri , input_coords = 1 , output_coords = 1 ) !! Correct for gyro motion and get particle position and velocity call gyro_correction ( fields , fast_ion % energy , fast_ion % pitch , ri , vi ) else !! Full Orbit !! Calculate velocity vector vi ( 1 ) = c * fast_ion % vr - s * fast_ion % vt vi ( 2 ) = s * fast_ion % vr + c * fast_ion % vt vi ( 3 ) = fast_ion % vz endif xyz_vi = matmul ( beam_grid % inv_basis , vi ) !! Track particle through grid call track_cylindrical ( ri , vi , tracks , ntrack , los_intersect ) if (. not . los_intersect ) cycle gamma_loop if ( ntrack . eq . 0 ) cycle gamma_loop !! Calculate CX probability call get_plasma ( plasma , pos = ri , input_coords = 1 ) call bt_cx_rates ( plasma , plasma % denn , xyz_vi , beam_ion , rates ) if ( sum ( rates ). le . 0. ) cycle gamma_loop !! Weight CX rates by ion source density if ( particles % axisym ) then states = rates * fast_ion % weight * ( pass_grid % nphi * pass_grid % dphi / ( 2 * pi )) & / ( fast_ion % r * pass_grid % dv ) / ngamma else states = rates * fast_ion % weight / ( fast_ion % r * pass_grid % dv ) / ngamma endif !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ntrack call get_plasma ( plasma , pos = tracks ( jj )% pos , input_coords = 1 ) call colrad ( plasma , beam_ion , xyz_vi , tracks ( jj )% time , states , denn , photons ) call store_fida_photons ( tracks ( jj )% pos , xyz_vi , photons , fast_ion % class , passive = . True .) enddo loop_along_track enddo gamma_loop enddo loop_over_fast_ions !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( spec % pfida ) #endif end subroutine pfida_mc","tags":"","loc":"proc/pfida_mc.html","title":"pfida_mc – FIDASIM"},{"text":"public subroutine npa_f() Calculate Active NPA flux using a fast-ion distribution function F(E,p,r,z) Arguments None Calls proc~~npa_f~~CallsGraph proc~npa_f npa_f proc~npa_gyro_range npa_gyro_range proc~npa_f->proc~npa_gyro_range proc~store_npa store_npa proc~npa_f->proc~store_npa proc~get_nlaunch get_nlaunch proc~npa_f->proc~get_nlaunch proc~ind2sub ind2sub proc~npa_f->proc~ind2sub proc~get_plasma get_plasma proc~npa_f->proc~get_plasma proc~get_indices get_indices proc~npa_f->proc~get_indices proc~hit_npa_detector hit_npa_detector proc~npa_f->proc~hit_npa_detector proc~gyro_trajectory gyro_trajectory proc~npa_f->proc~gyro_trajectory proc~gyro_surface gyro_surface proc~npa_f->proc~gyro_surface proc~attenuate attenuate proc~npa_f->proc~attenuate proc~get_beam_cx_rate get_beam_cx_rate proc~npa_f->proc~get_beam_cx_rate interface~parallel_sum parallel_sum proc~npa_f->interface~parallel_sum proc~mc_fastion mc_fastion proc~npa_f->proc~mc_fastion proc~approx_eq approx_eq proc~npa_gyro_range->proc~approx_eq proc~gyro_range gyro_range proc~npa_gyro_range->proc~gyro_range proc~xyz_to_uvw xyz_to_uvw proc~store_npa->proc~xyz_to_uvw proc~get_fields get_fields proc~store_npa->proc~get_fields interface~randind_cdf randind_cdf proc~get_nlaunch->interface~randind_cdf proc~cumsum cumsum proc~get_nlaunch->proc~cumsum proc~rng_init rng_init proc~get_nlaunch->proc~rng_init proc~get_position get_position proc~get_plasma->proc~get_position proc~uvw_to_xyz uvw_to_xyz proc~get_plasma->proc~uvw_to_xyz proc~get_plasma->proc~xyz_to_uvw proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector->proc~line_plane_intersect proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~attenuate->proc~get_plasma proc~colrad colrad proc~attenuate->proc~colrad proc~get_beam_cx_rate->proc~get_plasma proc~bt_cx_rates bt_cx_rates proc~get_beam_cx_rate->proc~bt_cx_rates proc~bb_cx_rates bb_cx_rates proc~get_beam_cx_rate->proc~bb_cx_rates proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~get_distribution get_distribution proc~mc_fastion->proc~get_distribution interface~randind randind proc~mc_fastion->interface~randind interface~randu randu proc~mc_fastion->interface~randu proc~mc_fastion->proc~get_fields proc~get_distribution->proc~xyz_to_uvw interface~interpol interpol proc~get_distribution->interface~interpol interface~interpol_coeff interpol_coeff proc~bt_cx_rates->interface~interpol_coeff proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz mpi_allreduce mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~gyro_range->proc~line_plane_intersect proc~gyro_range->proc~in_boundary proc~boundary_edge boundary_edge proc~gyro_range->proc~boundary_edge proc~line_gyro_surface_intersect line_gyro_surface_intersect proc~gyro_range->proc~line_gyro_surface_intersect proc~gyro_surface_coordinates gyro_surface_coordinates proc~gyro_range->proc~gyro_surface_coordinates proc~in_gyro_surface in_gyro_surface proc~gyro_range->proc~in_gyro_surface proc~get_fields->proc~uvw_to_xyz proc~get_fields->proc~xyz_to_uvw proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~rng_seed rng_seed proc~rng_init->proc~rng_seed proc~my_rank my_rank proc~rng_init->proc~my_rank proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~linsolve linsolve proc~colrad->proc~linsolve proc~eigen eigen proc~colrad->proc~eigen proc~bb_cx_rates->interface~interpol_coeff proc~get_rate_matrix->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw dgetrf dgetrf proc~linsolve->dgetrf proc~matinv matinv proc~linsolve->proc~matinv dgetrs dgetrs proc~linsolve->dgetrs proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~balback balback proc~eigen->proc~balback proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balance balance proc~eigen->proc~balance proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol3d_arr interpol3D_arr interface~interpol->proc~interpol3d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol3d_2d_arr interpol3D_2D_arr interface~interpol->proc~interpol3d_2d_arr proc~interpol2d_arr->interface~interpol_coeff proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~interpol3d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~interpol2d_2d_arr->interface~interpol_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol3d_2d_arr->interface~interpol_coeff proc~outerprod outerprod proc~ludcmp->proc~outerprod var panprocnpa_fCallsGraph = svgPanZoom('#procnpa_fCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~npa_f~~CalledByGraph proc~npa_f npa_f program~fidasim fidasim program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code npa_f Source Code subroutine npa_f !+ Calculate Active NPA flux using a fast-ion distribution function F(E,p,r,z) integer :: i , j , k , det , ic integer ( Int64 ) :: iion real ( Float64 ), dimension ( 3 ) :: rg , ri , rf , vi integer , dimension ( 3 ) :: ind , pind real ( Float64 ) :: denf type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields type ( GyroSurface ) :: gs real ( Float64 ), dimension ( 2 , 4 ) :: gyrange integer , dimension ( 5 ) :: neut_types = [ 1 , 2 , 3 , 4 , 5 ] real ( Float64 ), dimension ( nlevs ) :: rates real ( Float64 ), dimension ( nlevs ) :: states real ( Float64 ) :: flux , theta , dtheta , eb , ptch , max_papprox integer :: inpa , ichan , nrange , ir , npart , ncell integer , dimension ( beam_grid % ngrid ) :: cell_ind real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox integer ( Int32 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: nlaunch papprox = 0.d0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) call get_plasma ( plasma , ind = ind ) if (. not . plasma % in_plasma ) cycle papprox ( i , j , k ) = ( sum ( neut % full (:, i , j , k )) + & sum ( neut % half (:, i , j , k )) + & sum ( neut % third (:, i , j , k )) + & sum ( neut % dcx (:, i , j , k )) + & sum ( neut % halo (:, i , j , k ))) * & plasma % denf enddo !! TODO: Remove this once we have a 3D interpolation grid max_papprox = maxval ( papprox ) where ( papprox . lt .( max_papprox * 1.d-3 )) papprox = 0.0 endwhere ncell = 0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) if ( papprox ( i , j , k ). gt . 0.0 ) then ncell = ncell + 1 cell_ind ( ncell ) = ic endif enddo call get_nlaunch ( inputs % n_npa , papprox , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i12)' ) sum ( nlaunch ) endif !! Loop over all cells that can contribute to NPA signal !$OMP PARALLEL DO schedule(dynamic,1) private(ic,i,j,k,ind,iion,ichan,fields,nrange,gyrange, & !$OMP& pind,vi,ri,rf,det,plasma,rates,states,flux,denf,eb,ptch,gs,ir,theta,dtheta) loop_over_cells : do ic = istart , ncell , istep call ind2sub ( beam_grid % dims , cell_ind ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) loop_over_fast_ions : do iion = 1 , nlaunch ( i , j , k ) !! Sample fast ion distribution for energy and pitch call mc_fastion ( ind , fields , eb , ptch , denf ) if ( denf . le . 0.0 ) cycle loop_over_fast_ions call gyro_surface ( fields , eb , ptch , gs ) detector_loop : do ichan = 1 , npa_chords % nchan call npa_gyro_range ( ichan , gs , gyrange , nrange ) if ( nrange . eq . 0 ) cycle detector_loop gyro_range_loop : do ir = 1 , nrange dtheta = gyrange ( 2 , ir ) theta = gyrange ( 1 , ir ) + 0.5 * dtheta call gyro_trajectory ( gs , theta , ri , vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf , ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"NPA_F: Missed Detector \" , ichan endif cycle gyro_range_loop endif !! Get beam grid indices at ri call get_indices ( ri , pind ) !! Calculate CX probability with beam and halo neutrals call get_beam_cx_rate ( pind , ri , vi , beam_ion , neut_types , rates ) if ( sum ( rates ). le . 0. ) cycle gyro_range_loop !! Weight CX rates by ion source density states = rates * denf !! Attenuate states as the particle move through plasma call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = ( dtheta / ( 2 * pi )) * sum ( states ) * beam_grid % dv / nlaunch ( i , j , k ) call store_npa ( det , ri , rf , vi , flux ) enddo gyro_range_loop enddo detector_loop enddo loop_over_fast_ions enddo loop_over_cells !$OMP END PARALLEL DO npart = npa % npart #ifdef _MPI call parallel_sum ( npart ) call parallel_sum ( npa % flux ) #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Number of Active NPA particles that hit a detector: \",i8)' ) npart endif end subroutine npa_f","tags":"","loc":"proc/npa_f.html","title":"npa_f – FIDASIM"},{"text":"public subroutine pnpa_f() Calculate Passive NPA flux using a fast-ion distribution function F(E,p,r,z) Arguments None Calls proc~~pnpa_f~~CallsGraph proc~pnpa_f pnpa_f proc~npa_gyro_range npa_gyro_range proc~pnpa_f->proc~npa_gyro_range proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~pnpa_f->proc~mc_fastion_pass_grid proc~get_nlaunch_pass_grid get_nlaunch_pass_grid proc~pnpa_f->proc~get_nlaunch_pass_grid proc~ind2sub ind2sub proc~pnpa_f->proc~ind2sub proc~get_plasma get_plasma proc~pnpa_f->proc~get_plasma proc~bt_cx_rates bt_cx_rates proc~pnpa_f->proc~bt_cx_rates proc~hit_npa_detector hit_npa_detector proc~pnpa_f->proc~hit_npa_detector proc~gyro_trajectory gyro_trajectory proc~pnpa_f->proc~gyro_trajectory proc~gyro_surface gyro_surface proc~pnpa_f->proc~gyro_surface proc~attenuate attenuate proc~pnpa_f->proc~attenuate interface~parallel_sum parallel_sum proc~pnpa_f->interface~parallel_sum proc~store_npa store_npa proc~pnpa_f->proc~store_npa proc~approx_eq approx_eq proc~npa_gyro_range->proc~approx_eq proc~gyro_range gyro_range proc~npa_gyro_range->proc~gyro_range proc~get_distribution get_distribution proc~mc_fastion_pass_grid->proc~get_distribution proc~cyl_to_uvw cyl_to_uvw proc~mc_fastion_pass_grid->proc~cyl_to_uvw interface~randu randu proc~mc_fastion_pass_grid->interface~randu proc~get_fields get_fields proc~mc_fastion_pass_grid->proc~get_fields interface~randind randind proc~mc_fastion_pass_grid->interface~randind interface~randind_cdf randind_cdf proc~get_nlaunch_pass_grid->interface~randind_cdf proc~rng_init rng_init proc~get_nlaunch_pass_grid->proc~rng_init proc~get_position get_position proc~get_plasma->proc~get_position proc~uvw_to_xyz uvw_to_xyz proc~get_plasma->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_plasma->proc~xyz_to_uvw proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma interface~interpol_coeff interpol_coeff proc~bt_cx_rates->interface~interpol_coeff proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector->proc~line_plane_intersect proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~attenuate->proc~get_plasma proc~colrad colrad proc~attenuate->proc~colrad proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~store_npa->proc~xyz_to_uvw proc~store_npa->proc~get_fields proc~get_distribution->proc~xyz_to_uvw interface~interpol interpol proc~get_distribution->interface~interpol proc~gyro_range->proc~line_plane_intersect proc~gyro_range->proc~in_boundary proc~boundary_edge boundary_edge proc~gyro_range->proc~boundary_edge proc~line_gyro_surface_intersect line_gyro_surface_intersect proc~gyro_range->proc~line_gyro_surface_intersect proc~gyro_surface_coordinates gyro_surface_coordinates proc~gyro_range->proc~gyro_surface_coordinates proc~in_gyro_surface in_gyro_surface proc~gyro_range->proc~in_gyro_surface proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~linsolve linsolve proc~colrad->proc~linsolve mpi_allreduce mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~in_plasma->proc~cyl_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol_coeff proc~get_fields->proc~uvw_to_xyz proc~get_fields->proc~xyz_to_uvw proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~rng_seed rng_seed proc~rng_init->proc~rng_seed proc~my_rank my_rank proc~rng_init->proc~my_rank proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~get_rate_matrix->interface~interpol_coeff proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~cyl_to_xyz->proc~cyl_to_uvw proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~balback balback proc~eigen->proc~balback proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balance balance proc~eigen->proc~balance proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol3d_arr interpol3D_arr interface~interpol->proc~interpol3d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol3d_2d_arr interpol3D_2D_arr interface~interpol->proc~interpol3d_2d_arr proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~matinv matinv proc~linsolve->proc~matinv dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs proc~interpol2d_arr->interface~interpol_coeff proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~interpol3d_arr->interface~interpol_coeff proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol3d_2d_arr->interface~interpol_coeff proc~outerprod outerprod proc~ludcmp->proc~outerprod var panprocpnpa_fCallsGraph = svgPanZoom('#procpnpa_fCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pnpa_f~~CalledByGraph proc~pnpa_f pnpa_f program~fidasim fidasim program~fidasim->proc~pnpa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pnpa_f Source Code subroutine pnpa_f !+ Calculate Passive NPA flux using a fast-ion distribution function F(E,p,r,z) integer :: i , j , k , det , ic integer ( Int64 ) :: iion real ( Float64 ), dimension ( 3 ) :: rg , ri , rf , vi , ri_uvw integer , dimension ( 3 ) :: ind real ( Float64 ) :: denf , r type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields type ( GyroSurface ) :: gs real ( Float64 ), dimension ( 2 , 4 ) :: gyrange real ( Float64 ), dimension ( nlevs ) :: rates real ( Float64 ), dimension ( nlevs ) :: states real ( Float64 ) :: flux , theta , dtheta , eb , ptch , max_papprox integer :: inpa , ichan , nrange , ir , npart , ncell integer , dimension ( pass_grid % ngrid ) :: cell_ind real ( Float64 ), dimension ( pass_grid % nr , pass_grid % nz , pass_grid % nphi ) :: papprox integer ( Int32 ), dimension ( pass_grid % nr , pass_grid % nz , pass_grid % nphi ) :: nlaunch papprox = 0.d0 do ic = 1 , pass_grid % ngrid call ind2sub ( pass_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) call get_plasma ( plasma , ind = ind , input_coords = 2 ) if (. not . plasma % in_plasma ) cycle papprox ( i , j , k ) = sum ( plasma % denn ) * plasma % denf enddo max_papprox = maxval ( papprox ) where ( papprox . lt .( max_papprox * 1.d-3 )) papprox = 0.0 endwhere ncell = 0 do ic = 1 , pass_grid % ngrid call ind2sub ( pass_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) if ( papprox ( i , j , k ). gt . 0.0 ) then ncell = ncell + 1 cell_ind ( ncell ) = ic endif enddo call get_nlaunch_pass_grid ( inputs % n_pnpa , papprox , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i12)' ) sum ( nlaunch ) endif !! Loop over all cells that can contribute to NPA signal !$OMP PARALLEL DO schedule(dynamic,1) private(ic,i,j,k,ind,iion,ichan,fields,nrange,gyrange, & !$OMP& vi,ri,rf,det,plasma,rates,states,flux,denf,eb,ptch,gs,ir,theta,dtheta,r,ri_uvw) loop_over_cells : do ic = istart , ncell , istep call ind2sub ( pass_grid % dims , cell_ind ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) loop_over_fast_ions : do iion = 1 , nlaunch ( i , j , k ) !! Sample fast ion distribution for energy and pitch call mc_fastion_pass_grid ( ind , fields , eb , ptch , denf ) if ( denf . le . 0.0 ) cycle loop_over_fast_ions call gyro_surface ( fields , eb , ptch , gs ) detector_loop : do ichan = 1 , npa_chords % nchan call npa_gyro_range ( ichan , gs , gyrange , nrange ) if ( nrange . eq . 0 ) cycle detector_loop gyro_range_loop : do ir = 1 , nrange dtheta = gyrange ( 2 , ir ) theta = gyrange ( 1 , ir ) + 0.5 * dtheta call gyro_trajectory ( gs , theta , ri , vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf , ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"PNPA_F: Missed Detector \" , ichan endif cycle gyro_range_loop endif !! Calculate CX probability with beam and halo neutrals call get_plasma ( plasma , pos = ri ) call bt_cx_rates ( plasma , plasma % denn , vi , beam_ion , rates ) if ( sum ( rates ). le . 0. ) cycle gyro_range_loop !! Weight CX rates by ion source density states = rates * denf !! Attenuate states as the particle move through plasma call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = ( dtheta / ( 2 * pi )) * sum ( states ) * pass_grid % r ( i ) * pass_grid % dv / nlaunch ( i , j , k ) call store_npa ( det , ri , rf , vi , flux , passive = . True .) enddo gyro_range_loop enddo detector_loop enddo loop_over_fast_ions enddo loop_over_cells !$OMP END PARALLEL DO npart = pnpa % npart #ifdef _MPI call parallel_sum ( npart ) call parallel_sum ( pnpa % flux ) #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Number of Passive NPA particles that hit a detector: \",i8)' ) npart endif end subroutine pnpa_f","tags":"","loc":"proc/pnpa_f.html","title":"pnpa_f – FIDASIM"},{"text":"public subroutine npa_mc() Calculate Active NPA flux using a Monte Carlo fast-ion distribution Arguments None Calls proc~~npa_mc~~CallsGraph proc~npa_mc npa_mc proc~get_fields get_fields proc~npa_mc->proc~get_fields proc~npa_gyro_range npa_gyro_range proc~npa_mc->proc~npa_gyro_range proc~store_npa store_npa proc~npa_mc->proc~store_npa proc~hit_npa_detector hit_npa_detector proc~npa_mc->proc~hit_npa_detector proc~get_indices get_indices proc~npa_mc->proc~get_indices proc~uvw_to_xyz uvw_to_xyz proc~npa_mc->proc~uvw_to_xyz interface~randu randu proc~npa_mc->interface~randu proc~gyro_trajectory gyro_trajectory proc~npa_mc->proc~gyro_trajectory proc~gyro_surface gyro_surface proc~npa_mc->proc~gyro_surface proc~attenuate attenuate proc~npa_mc->proc~attenuate proc~get_beam_cx_rate get_beam_cx_rate proc~npa_mc->proc~get_beam_cx_rate interface~parallel_sum parallel_sum proc~npa_mc->interface~parallel_sum proc~get_fields->proc~uvw_to_xyz proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~approx_eq approx_eq proc~npa_gyro_range->proc~approx_eq proc~gyro_range gyro_range proc~npa_gyro_range->proc~gyro_range proc~store_npa->proc~get_fields proc~store_npa->proc~xyz_to_uvw proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector->proc~line_plane_intersect proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~get_plasma get_plasma proc~attenuate->proc~get_plasma proc~colrad colrad proc~attenuate->proc~colrad proc~bt_cx_rates bt_cx_rates proc~get_beam_cx_rate->proc~bt_cx_rates proc~get_beam_cx_rate->proc~get_plasma proc~bb_cx_rates bb_cx_rates proc~get_beam_cx_rate->proc~bb_cx_rates proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 mpi_allreduce mpi_allreduce proc~parallel_sum_d1->mpi_allreduce interface~interpol_coeff interpol_coeff proc~bt_cx_rates->interface~interpol_coeff proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~get_plasma->proc~uvw_to_xyz proc~get_plasma->proc~in_plasma proc~get_plasma->proc~xyz_to_uvw proc~get_position get_position proc~get_plasma->proc~get_position proc~parallel_sum_d4->mpi_allreduce proc~gyro_range->proc~line_plane_intersect proc~gyro_range->proc~in_boundary proc~boundary_edge boundary_edge proc~gyro_range->proc~boundary_edge proc~line_gyro_surface_intersect line_gyro_surface_intersect proc~gyro_range->proc~line_gyro_surface_intersect proc~gyro_surface_coordinates gyro_surface_coordinates proc~gyro_range->proc~gyro_surface_coordinates proc~in_gyro_surface in_gyro_surface proc~gyro_range->proc~in_gyro_surface proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~linsolve linsolve proc~colrad->proc~linsolve proc~parallel_sum_d5->mpi_allreduce proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~bb_cx_rates->interface~interpol_coeff proc~get_rate_matrix->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balback balback proc~eigen->proc~balback proc~elmhes elmhes proc~eigen->proc~elmhes proc~balance balance proc~eigen->proc~balance proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~matinv matinv proc~linsolve->proc~matinv dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~outerprod outerprod proc~ludcmp->proc~outerprod var panprocnpa_mcCallsGraph = svgPanZoom('#procnpa_mcCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~npa_mc~~CalledByGraph proc~npa_mc npa_mc program~fidasim fidasim program~fidasim->proc~npa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code npa_mc Source Code subroutine npa_mc !+ Calculate Active NPA flux using a Monte Carlo fast-ion distribution integer :: iion , igamma , ngamma , npart type ( FastIon ) :: fast_ion real ( Float64 ) :: phi , theta , dtheta real ( Float64 ), dimension ( 3 ) :: ri , rf , rg , vi integer :: det , ichan , ir , nrange , it type ( LocalEMFields ) :: fields type ( GyroSurface ) :: gs real ( Float64 ), dimension ( nlevs ) :: rates real ( Float64 ), dimension ( nlevs ) :: states real ( Float64 ) :: flux integer , dimension ( 5 ) :: neut_types = [ 1 , 2 , 3 , 4 , 5 ] integer , dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ), dimension ( 2 , 4 ) :: gyrange real ( Float64 ) :: s , c real ( Float64 ), dimension ( 1 ) :: randomu ngamma = 1 if ( particles % axisym . or .( inputs % dist_type . eq . 2 )) then ngamma = ceiling ( dble ( inputs % n_npa ) / particles % nparticle ) endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) int ( particles % nparticle * ngamma , Int64 ) endif !$OMP PARALLEL DO schedule(guided) private(iion,igamma,ind,fast_ion,vi,ri,rf,phi,s,c,ir,it, & !$OMP& randomu,rg,fields,uvw,uvw_vi,rates,states,flux,det,ichan,gs,nrange,gyrange,theta,dtheta) loop_over_fast_ions : do iion = istart , particles % nparticle , istep fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0 ) cycle loop_over_fast_ions if (. not . fast_ion % beam_grid_cross_grid ) cycle loop_over_fast_ions gamma_loop : do igamma = 1 , ngamma if ( particles % axisym ) then !! Pick random toroidal angle call randu ( randomu ) phi = fast_ion % beam_grid_phi_enter + fast_ion % delta_phi * randomu ( 1 ) else phi = fast_ion % phi endif s = sin ( phi ) c = cos ( phi ) !! Calculate position in machine coordinates uvw ( 1 ) = fast_ion % r * c uvw ( 2 ) = fast_ion % r * s uvw ( 3 ) = fast_ion % z if ( inputs % dist_type . eq . 2 ) then !! Convert to beam grid coordinates call uvw_to_xyz ( uvw , rg ) !! Get electomagnetic fields call get_fields ( fields , pos = rg ) !! Correct for gyro motion and get position and velocity call gyro_surface ( fields , fast_ion % energy , fast_ion % pitch , gs ) detector_loop : do ichan = 1 , npa_chords % nchan call npa_gyro_range ( ichan , gs , gyrange , nrange ) if ( nrange . eq . 0 ) cycle detector_loop gyro_range_loop : do ir = 1 , nrange dtheta = gyrange ( 2 , ir ) theta = gyrange ( 1 , ir ) + 0.5 * dtheta call gyro_trajectory ( gs , theta , ri , vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf , det = ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"NPA_MC: Missed Detector \" , ichan endif cycle gyro_range_loop endif !! Get beam grid indices at ri call get_indices ( ri , ind ) !! Calculate CX probability with beam and halo neutrals call get_beam_cx_rate ( ind , ri , vi , beam_ion , neut_types , rates ) if ( sum ( rates ). le . 0. ) cycle gyro_range_loop !! Weight CX rates by ion source density states = rates * fast_ion % weight * ( fast_ion % delta_phi / ( 2 * pi )) / beam_grid % dv / ngamma !! Attenuate states as the particle move through plasma call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = ( dtheta / ( 2 * pi )) * sum ( states ) * beam_grid % dv spread_loop : do it = 1 , 25 theta = gyrange ( 1 , ir ) + ( it - 0.5 ) * dtheta / 25 call gyro_trajectory ( gs , theta , ri , vi ) call hit_npa_detector ( ri , vi , det , rf , det = ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"NPA_MC: Missed Detector \" , ichan endif cycle spread_loop endif call store_npa ( det , ri , rf , vi , flux / 25 , fast_ion % class ) enddo spread_loop enddo gyro_range_loop enddo detector_loop else !! Full Orbit !! Convert to beam grid coordinates call uvw_to_xyz ( uvw , ri ) !! Calculate velocity vector uvw_vi ( 1 ) = c * fast_ion % vr - s * fast_ion % vt uvw_vi ( 2 ) = s * fast_ion % vr + c * fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf ) if ( det . eq . 0 ) cycle gamma_loop !! Get beam grid indices at ri call get_indices ( ri , ind ) !! Calculate CX probability with beam and halo neutrals call get_beam_cx_rate ( ind , ri , vi , beam_ion , neut_types , rates ) if ( sum ( rates ). le . 0. ) cycle gamma_loop !! Weight CX rates by ion source density states = rates * fast_ion % weight * ( fast_ion % delta_phi / ( 2 * pi )) / beam_grid % dv / ngamma !! Attenuate states as the particle moves though plasma call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = sum ( states ) * beam_grid % dv call store_npa ( det , ri , rf , vi , flux , fast_ion % class ) endif enddo gamma_loop enddo loop_over_fast_ions !$OMP END PARALLEL DO npart = npa % npart #ifdef _MPI call parallel_sum ( npart ) call parallel_sum ( npa % flux ) #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Number of Active NPA particles that hit a detector: \",i8)' ) npart endif end subroutine npa_mc","tags":"","loc":"proc/npa_mc.html","title":"npa_mc – FIDASIM"},{"text":"public subroutine pnpa_mc() Calculate Passive NPA flux using a Monte Carlo fast-ion distribution Arguments None Calls proc~~pnpa_mc~~CallsGraph proc~pnpa_mc pnpa_mc proc~get_fields get_fields proc~pnpa_mc->proc~get_fields proc~npa_gyro_range npa_gyro_range proc~pnpa_mc->proc~npa_gyro_range proc~store_npa store_npa proc~pnpa_mc->proc~store_npa proc~hit_npa_detector hit_npa_detector proc~pnpa_mc->proc~hit_npa_detector proc~get_plasma get_plasma proc~pnpa_mc->proc~get_plasma proc~bt_cx_rates bt_cx_rates proc~pnpa_mc->proc~bt_cx_rates proc~uvw_to_xyz uvw_to_xyz proc~pnpa_mc->proc~uvw_to_xyz interface~randu randu proc~pnpa_mc->interface~randu proc~gyro_trajectory gyro_trajectory proc~pnpa_mc->proc~gyro_trajectory proc~gyro_surface gyro_surface proc~pnpa_mc->proc~gyro_surface proc~attenuate attenuate proc~pnpa_mc->proc~attenuate interface~parallel_sum parallel_sum proc~pnpa_mc->interface~parallel_sum proc~get_fields->proc~uvw_to_xyz proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~approx_eq approx_eq proc~npa_gyro_range->proc~approx_eq proc~gyro_range gyro_range proc~npa_gyro_range->proc~gyro_range proc~store_npa->proc~get_fields proc~store_npa->proc~xyz_to_uvw proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector->proc~line_plane_intersect proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~get_plasma->proc~uvw_to_xyz proc~get_position get_position proc~get_plasma->proc~get_position proc~get_plasma->proc~in_plasma proc~get_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~bt_cx_rates->interface~interpol_coeff proc~attenuate->proc~get_plasma proc~colrad colrad proc~attenuate->proc~colrad proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 mpi_allreduce mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~gyro_range->proc~line_plane_intersect proc~gyro_range->proc~in_boundary proc~boundary_edge boundary_edge proc~gyro_range->proc~boundary_edge proc~line_gyro_surface_intersect line_gyro_surface_intersect proc~gyro_range->proc~line_gyro_surface_intersect proc~gyro_surface_coordinates gyro_surface_coordinates proc~gyro_range->proc~gyro_surface_coordinates proc~in_gyro_surface in_gyro_surface proc~gyro_range->proc~in_gyro_surface proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~eigen eigen proc~colrad->proc~eigen proc~linsolve linsolve proc~colrad->proc~linsolve proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~parallel_sum_d5->mpi_allreduce proc~in_plasma->interface~interpol_coeff proc~in_plasma->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~balback balback proc~eigen->proc~balback proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~elmhes elmhes proc~eigen->proc~elmhes proc~balance balance proc~eigen->proc~balance proc~matinv matinv proc~linsolve->proc~matinv dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~get_rate_matrix->interface~interpol_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~outerprod outerprod proc~ludcmp->proc~outerprod var panprocpnpa_mcCallsGraph = svgPanZoom('#procpnpa_mcCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pnpa_mc~~CalledByGraph proc~pnpa_mc pnpa_mc program~fidasim fidasim program~fidasim->proc~pnpa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code pnpa_mc Source Code subroutine pnpa_mc !+ Calculate Passive NPA flux using a Monte Carlo fast-ion distribution integer :: iion , igamma , ngamma , npart type ( FastIon ) :: fast_ion real ( Float64 ) :: phi , theta , dtheta real ( Float64 ), dimension ( 3 ) :: ri , rf , rg , vi integer :: det , j , ichan , ir , nrange , it type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma type ( GyroSurface ) :: gs real ( Float64 ), dimension ( nlevs ) :: rates real ( Float64 ), dimension ( nlevs ) :: states real ( Float64 ) :: flux integer , dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ), dimension ( 2 , 4 ) :: gyrange real ( Float64 ) :: s , c real ( Float64 ), dimension ( 1 ) :: randomu ngamma = 1 if ( particles % axisym . or .( inputs % dist_type . eq . 2 )) then ngamma = ceiling ( dble ( inputs % n_pnpa ) / particles % nparticle ) endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) int ( particles % nparticle * ngamma , Int64 ) endif !$OMP PARALLEL DO schedule(guided) private(iion,igamma,ind,fast_ion,vi,ri,rf,phi,s,c,ir,it,plasma, & !$OMP& randomu,rg,fields,uvw,uvw_vi,rates,states,flux,det,ichan,gs,nrange,gyrange,theta,dtheta) loop_over_fast_ions : do iion = istart , particles % nparticle , istep fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0 ) cycle loop_over_fast_ions gamma_loop : do igamma = 1 , ngamma if ( particles % axisym ) then !! Pick random toroidal angle call randu ( randomu ) phi = pass_grid % phi ( 1 ) + pass_grid % nphi * pass_grid % dphi * randomu ( 1 ) else phi = fast_ion % phi endif s = sin ( phi ) c = cos ( phi ) !! Calculate position in machine coordinates uvw ( 1 ) = fast_ion % r * c uvw ( 2 ) = fast_ion % r * s uvw ( 3 ) = fast_ion % z if ( inputs % dist_type . eq . 2 ) then !! Get electomagnetic fields call get_fields ( fields , pos = uvw , input_coords = 1 ) !! Correct for gyro motion and get position and velocity call gyro_surface ( fields , fast_ion % energy , fast_ion % pitch , gs ) detector_loop : do ichan = 1 , npa_chords % nchan call npa_gyro_range ( ichan , gs , gyrange , nrange ) if ( nrange . eq . 0 ) cycle detector_loop gyro_range_loop : do ir = 1 , nrange dtheta = gyrange ( 2 , ir ) theta = gyrange ( 1 , ir ) + 0.5 * dtheta call gyro_trajectory ( gs , theta , ri , vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf , det = ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"PNPA_MC: Missed Detector \" , ichan endif cycle gyro_range_loop endif !! Calculate CX probability with beam and halo neutrals call get_plasma ( plasma , pos = ri ) call bt_cx_rates ( plasma , plasma % denn , vi , beam_ion , rates ) if ( sum ( rates ). le . 0. ) cycle gyro_range_loop !! Weight CX rates by ion source density if ( particles % axisym ) then states = rates * fast_ion % weight * ( pass_grid % nphi * pass_grid % dphi / ( 2 * pi )) & / ( fast_ion % r * pass_grid % dv ) / ngamma else states = rates * fast_ion % weight / ( fast_ion % r * pass_grid % dv ) / ngamma endif !! Attenuate states as the particle move through plasma call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = ( dtheta / ( 2 * pi )) * sum ( states ) * ( fast_ion % r * pass_grid % dv ) spread_loop : do it = 1 , 25 theta = gyrange ( 1 , ir ) + ( it - 0.5 ) * dtheta / 25 call gyro_trajectory ( gs , theta , ri , vi ) call hit_npa_detector ( ri , vi , det , rf , det = ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"PNPA_MC: Missed Detector \" , ichan endif cycle spread_loop endif call store_npa ( det , ri , rf , vi , flux / 25 , fast_ion % class , passive = . True .) enddo spread_loop enddo gyro_range_loop enddo detector_loop else !! Full Orbit !! Convert to beam grid coordinates call uvw_to_xyz ( uvw , ri ) !! Calculate velocity vector uvw_vi ( 1 ) = c * fast_ion % vr - s * fast_ion % vt uvw_vi ( 2 ) = s * fast_ion % vr + c * fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf ) if ( det . eq . 0 ) cycle gamma_loop !! Calculate CX probability with beam and halo neutrals call get_plasma ( plasma , pos = ri ) call bt_cx_rates ( plasma , plasma % denn , vi , beam_ion , rates ) if ( sum ( rates ). le . 0. ) cycle gamma_loop !! Weight CX rates by ion source density if ( particles % axisym ) then states = rates * fast_ion % weight * ( pass_grid % nphi * pass_grid % dphi / ( 2 * pi )) & / ( fast_ion % r * pass_grid % dv ) / ngamma else states = rates * fast_ion % weight / ( fast_ion % r * pass_grid % dv ) / ngamma endif !! Attenuate states as the particle moves though plasma call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = sum ( states ) * ( fast_ion % r * pass_grid % dv ) call store_npa ( det , ri , rf , vi , flux , fast_ion % class , passive = . True .) endif enddo gamma_loop enddo loop_over_fast_ions !$OMP END PARALLEL DO npart = pnpa % npart #ifdef _MPI call parallel_sum ( npart ) call parallel_sum ( pnpa % flux ) #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Number of Passive NPA particles that hit a detector: \",i8)' ) npart endif end subroutine pnpa_mc","tags":"","loc":"proc/pnpa_mc.html","title":"pnpa_mc – FIDASIM"},{"text":"public subroutine neutron_f() Calculate neutron emission rate using a fast-ion distribution function F(E,p,r,z) Arguments None Calls proc~~neutron_f~~CallsGraph proc~neutron_f neutron_f proc~get_fields get_fields proc~neutron_f->proc~get_fields proc~store_neutrons store_neutrons proc~neutron_f->proc~store_neutrons proc~get_plasma get_plasma proc~neutron_f->proc~get_plasma proc~gyro_correction gyro_correction proc~neutron_f->proc~gyro_correction proc~get_neutron_rate get_neutron_rate proc~neutron_f->proc~get_neutron_rate proc~write_neutrons write_neutrons proc~neutron_f->proc~write_neutrons interface~parallel_sum parallel_sum proc~neutron_f->interface~parallel_sum proc~my_rank my_rank proc~neutron_f->proc~my_rank proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~get_plasma->proc~uvw_to_xyz proc~get_position get_position proc~get_plasma->proc~get_position proc~get_plasma->proc~xyz_to_uvw proc~get_plasma->proc~in_plasma proc~pitch_to_vec pitch_to_vec proc~gyro_correction->proc~pitch_to_vec proc~gyro_step gyro_step proc~gyro_correction->proc~gyro_step interface~randu randu proc~gyro_correction->interface~randu interface~interpol_coeff interpol_coeff proc~get_neutron_rate->interface~interpol_coeff h5fclose_f h5fclose_f proc~write_neutrons->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_neutrons->h5ltmake_dataset_int_f h5close_f h5close_f proc~write_neutrons->h5close_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_neutrons->h5ltset_attribute_string_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f h5fcreate_f h5fcreate_f proc~write_neutrons->h5fcreate_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_neutrons->h5ltmake_dataset_double_f h5open_f h5open_f proc~write_neutrons->h5open_f proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 mpi_allreduce mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~cross_product cross_product proc~gyro_step->proc~cross_product proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocneutron_fCallsGraph = svgPanZoom('#procneutron_fCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~neutron_f~~CalledByGraph proc~neutron_f neutron_f program~fidasim fidasim program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code neutron_f Source Code subroutine neutron_f !+ Calculate neutron emission rate using a fast-ion distribution function F(E,p,r,z) integer :: ir , iphi , iz , ie , ip , igamma , ngamma type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( Float64 ) :: eb , pitch real ( Float64 ) :: erel , rate real ( Float64 ), dimension ( 3 ) :: ri real ( Float64 ), dimension ( 3 ) :: vi real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ) :: vnet_square , factor real ( Float64 ) :: s , c if ( inputs % calc_neutron . ge . 2 ) then allocate ( neutron % weight ( fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz , fbm % nphi )) neutron % weight = 0.d0 allocate ( neutron % emis ( fbm % nr , fbm % nz , fbm % nphi )) neutron % emis = 0.d0 endif ngamma = 20 rate = 0 !$OMP PARALLEL DO schedule(guided) private(fields,vi,ri,pitch,eb,& !$OMP& ir,iphi,iz,ie,ip,igamma,plasma,factor,uvw,uvw_vi,vnet_square,rate,erel,s,c) phi_loop : do iphi = 1 , fbm % nphi z_loop : do iz = istart , fbm % nz , istep r_loop : do ir = 1 , fbm % nr !! Calculate position if ( fbm % nphi . eq . 1 ) then s = 0.d0 c = 1.d0 else s = sin ( fbm % phi ( iphi )) c = cos ( fbm % phi ( iphi )) endif uvw ( 1 ) = fbm % r ( ir ) * c uvw ( 2 ) = fbm % r ( ir ) * s uvw ( 3 ) = fbm % z ( iz ) !! Get fields call get_fields ( fields , pos = uvw , input_coords = 1 ) if (. not . fields % in_plasma ) cycle r_loop factor = fbm % r ( ir ) * fbm % dE * fbm % dp * fbm % dr * fbm % dz * fbm % dphi / ngamma !! Loop over energy/pitch/gamma pitch_loop : do ip = 1 , fbm % npitch pitch = fbm % pitch ( ip ) energy_loop : do ie = 1 , fbm % nenergy eb = fbm % energy ( ie ) gyro_loop : do igamma = 1 , ngamma call gyro_correction ( fields , eb , pitch , ri , vi ) !! Get plasma parameters at particle position call get_plasma ( plasma , pos = ri ) if (. not . plasma % in_plasma ) cycle gyro_loop !! Calculate effective beam energy vnet_square = dot_product ( vi - plasma % vrot , vi - plasma % vrot ) ![cm/s] erel = v2_to_E_per_amu * inputs % ab * vnet_square ![kev] !! Get neutron production rate call get_neutron_rate ( plasma , erel , rate ) if ( inputs % calc_neutron . ge . 2 ) then neutron % weight ( ie , ip , ir , iz , iphi ) = neutron % weight ( ie , ip , ir , iz , iphi ) & + rate * factor !$OMP CRITICAL(neutron_emis) neutron % emis ( ir , iz , iphi ) = neutron % emis ( ir , iz , iphi ) & + rate * fbm % f ( ie , ip , ir , iz , iphi ) & * factor !$OMP END CRITICAL(neutron_emis) endif rate = rate * fbm % f ( ie , ip , ir , iz , iphi ) * factor !! Store neutrons call store_neutrons ( rate ) enddo gyro_loop enddo energy_loop enddo pitch_loop enddo r_loop enddo z_loop enddo phi_loop !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( neutron % rate ) if ( inputs % calc_neutron . ge . 2 ) then call parallel_sum ( neutron % weight ) call parallel_sum ( neutron % emis ) endif #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,A,ES14.5,\" [neutrons/s]\")' ) 'Rate:   ' , sum ( neutron % rate ) write ( * , '(30X,a)' ) '' write ( * , * ) 'write neutrons:    ' , time ( time_start ) endif #ifdef _MPI if ( my_rank (). eq . 0 ) call write_neutrons () #else call write_neutrons () #endif end subroutine neutron_f","tags":"","loc":"proc/neutron_f.html","title":"neutron_f – FIDASIM"},{"text":"public subroutine neutron_mc() Calculate neutron flux using a Monte Carlo Fast-ion distribution Arguments None Calls proc~~neutron_mc~~CallsGraph proc~neutron_mc neutron_mc proc~get_fields get_fields proc~neutron_mc->proc~get_fields proc~store_neutrons store_neutrons proc~neutron_mc->proc~store_neutrons proc~get_plasma get_plasma proc~neutron_mc->proc~get_plasma proc~gyro_correction gyro_correction proc~neutron_mc->proc~gyro_correction proc~get_neutron_rate get_neutron_rate proc~neutron_mc->proc~get_neutron_rate proc~write_neutrons write_neutrons proc~neutron_mc->proc~write_neutrons interface~parallel_sum parallel_sum proc~neutron_mc->interface~parallel_sum proc~my_rank my_rank proc~neutron_mc->proc~my_rank proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~get_plasma->proc~uvw_to_xyz proc~get_position get_position proc~get_plasma->proc~get_position proc~get_plasma->proc~xyz_to_uvw proc~get_plasma->proc~in_plasma proc~pitch_to_vec pitch_to_vec proc~gyro_correction->proc~pitch_to_vec proc~gyro_step gyro_step proc~gyro_correction->proc~gyro_step interface~randu randu proc~gyro_correction->interface~randu interface~interpol_coeff interpol_coeff proc~get_neutron_rate->interface~interpol_coeff h5fclose_f h5fclose_f proc~write_neutrons->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_neutrons->h5ltmake_dataset_int_f h5close_f h5close_f proc~write_neutrons->h5close_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_neutrons->h5ltset_attribute_string_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f h5fcreate_f h5fcreate_f proc~write_neutrons->h5fcreate_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_neutrons->h5ltmake_dataset_double_f h5open_f h5open_f proc~write_neutrons->h5open_f proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 mpi_allreduce mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~cross_product cross_product proc~gyro_step->proc~cross_product proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocneutron_mcCallsGraph = svgPanZoom('#procneutron_mcCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~neutron_mc~~CalledByGraph proc~neutron_mc neutron_mc program~fidasim fidasim program~fidasim->proc~neutron_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code neutron_mc Source Code subroutine neutron_mc !+ Calculate neutron flux using a Monte Carlo Fast-ion distribution integer :: iion , ngamma , igamma type ( FastIon ) :: fast_ion type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( Float64 ) :: eb , rate real ( Float64 ), dimension ( 3 ) :: ri real ( Float64 ), dimension ( 3 ) :: vi real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ) :: vnet_square real ( Float64 ) :: phi , s , c , factor , delta_phi if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) particles % nparticle endif !! Correct neutron rate when equilibrium is 3D and MC distribution is 4D if ( particles % axisym . and .( inter_grid % nphi . gt . 1 )) then delta_phi = inter_grid % phi ( inter_grid % nphi ) - inter_grid % phi ( 1 ) delta_phi = delta_phi + delta_phi / ( inter_grid % nphi - 1 ) / 2 !Add half a cell factor = delta_phi / ( 2 * pi ) * 2 !Riemann sum below assumes coord's are at midpoint of cell else factor = 1 endif rate = 0.0 ngamma = 20 !$OMP PARALLEL DO schedule(guided) private(iion,fast_ion,vi,ri,s,c, & !$OMP& plasma,fields,uvw,uvw_vi,vnet_square,rate,eb,igamma,phi) loop_over_fast_ions : do iion = istart , particles % nparticle , istep fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0.d0 ) cycle loop_over_fast_ions !! Calculate position in machine coordinates if ( particles % axisym ) then s = 0.d0 c = 1.d0 else phi = fast_ion % phi s = sin ( phi ) c = cos ( phi ) endif uvw ( 1 ) = fast_ion % r * c uvw ( 2 ) = fast_ion % r * s uvw ( 3 ) = fast_ion % z if ( inputs % dist_type . eq . 2 ) then !! Get electomagnetic fields call get_fields ( fields , pos = uvw , input_coords = 1 ) if (. not . fields % in_plasma ) cycle loop_over_fast_ions gyro_loop : do igamma = 1 , ngamma !! Correct for Gyro-motion call gyro_correction ( fields , fast_ion % energy , fast_ion % pitch , ri , vi ) !! Get plasma parameters call get_plasma ( plasma , pos = ri ) if (. not . plasma % in_plasma ) cycle gyro_loop !! Calculate effective beam energy vnet_square = dot_product ( vi - plasma % vrot , vi - plasma % vrot ) ![cm/s] eb = v2_to_E_per_amu * inputs % ab * vnet_square ![kev] !! Get neutron production rate call get_neutron_rate ( plasma , eb , rate ) rate = rate * fast_ion % weight / ngamma * factor !! Store neutrons call store_neutrons ( rate , fast_ion % class ) enddo gyro_loop else !! Get plasma parameters call get_plasma ( plasma , pos = uvw , input_coords = 1 ) if (. not . plasma % in_plasma ) cycle loop_over_fast_ions !! Calculate effective beam energy uvw_vi ( 1 ) = fast_ion % vr uvw_vi ( 2 ) = fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) vnet_square = dot_product ( vi - plasma % vrot , vi - plasma % vrot ) ![cm/s] eb = v2_to_E_per_amu * inputs % ab * vnet_square ![kev] !! Get neutron production rate call get_neutron_rate ( plasma , eb , rate ) rate = rate * fast_ion % weight * factor !! Store neutrons call store_neutrons ( rate , fast_ion % class ) endif enddo loop_over_fast_ions !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( neutron % rate ) #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,A,ES14.5,\" [neutrons/s]\")' ) 'Rate:   ' , sum ( neutron % rate ) write ( * , '(30X,a)' ) '' write ( * , * ) 'write neutrons:    ' , time ( time_start ) endif #ifdef _MPI if ( my_rank (). eq . 0 ) call write_neutrons () #else call write_neutrons () #endif end subroutine neutron_mc","tags":"","loc":"proc/neutron_mc.html","title":"neutron_mc – FIDASIM"},{"text":"public subroutine fida_weights_mc() Calculates FIDA weights Arguments None Calls proc~~fida_weights_mc~~CallsGraph proc~fida_weights_mc fida_weights_mc proc~get_fields get_fields proc~fida_weights_mc->proc~get_fields interface~randind randind proc~fida_weights_mc->interface~randind proc~write_fida_weights write_fida_weights proc~fida_weights_mc->proc~write_fida_weights proc~get_nlaunch get_nlaunch proc~fida_weights_mc->proc~get_nlaunch proc~ind2sub ind2sub proc~fida_weights_mc->proc~ind2sub proc~get_plasma get_plasma proc~fida_weights_mc->proc~get_plasma proc~gyro_correction gyro_correction proc~fida_weights_mc->proc~gyro_correction proc~track track proc~fida_weights_mc->proc~track interface~randu randu proc~fida_weights_mc->interface~randu proc~get_ep_denf get_ep_denf proc~fida_weights_mc->proc~get_ep_denf interface~parallel_sum parallel_sum proc~fida_weights_mc->interface~parallel_sum proc~my_rank my_rank proc~fida_weights_mc->proc~my_rank proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~in_plasma in_plasma proc~get_fields->proc~in_plasma h5fclose_f h5fclose_f proc~write_fida_weights->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_fida_weights->h5ltmake_dataset_int_f h5close_f h5close_f proc~write_fida_weights->h5close_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_fida_weights->h5ltset_attribute_string_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f h5fcreate_f h5fcreate_f proc~write_fida_weights->h5fcreate_f h5open_f h5open_f proc~write_fida_weights->h5open_f interface~randind_cdf randind_cdf proc~get_nlaunch->interface~randind_cdf proc~cumsum cumsum proc~get_nlaunch->proc~cumsum proc~rng_init rng_init proc~get_nlaunch->proc~rng_init proc~get_plasma->proc~uvw_to_xyz proc~get_position get_position proc~get_plasma->proc~get_position proc~get_plasma->proc~xyz_to_uvw proc~get_plasma->proc~in_plasma proc~gyro_correction->interface~randu proc~pitch_to_vec pitch_to_vec proc~gyro_correction->proc~pitch_to_vec proc~gyro_step gyro_step proc~gyro_correction->proc~gyro_step proc~track->proc~get_fields proc~get_indices get_indices proc~track->proc~get_indices proc~track->proc~in_plasma proc~doppler_stark doppler_stark proc~track->proc~doppler_stark proc~get_ep_denf->proc~xyz_to_uvw interface~interpol interpol proc~get_ep_denf->interface~interpol proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 mpi_allreduce mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~cross_product cross_product proc~gyro_step->proc~cross_product proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~rng_init->proc~my_rank proc~rng_seed rng_seed proc~rng_init->proc~rng_seed proc~interpol3d_arr interpol3D_arr interface~interpol->proc~interpol3d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol3d_2d_arr interpol3D_2D_arr interface~interpol->proc~interpol3d_2d_arr h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol3d_2d_arr->interface~interpol_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var panprocfida_weights_mcCallsGraph = svgPanZoom('#procfida_weights_mcCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fida_weights_mc~~CalledByGraph proc~fida_weights_mc fida_weights_mc program~fidasim fidasim program~fidasim->proc~fida_weights_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fida_weights_mc Source Code subroutine fida_weights_mc !+ Calculates FIDA weights integer :: i , j , k , ic , ncell integer ( Int64 ) :: iion , ip real ( Float64 ), dimension ( 3 ) :: ri , rg !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions integer , dimension ( 3 ) :: ind !! new actual cell integer , dimension ( 5 ) :: neut_types = [ 1 , 2 , 3 , 4 , 5 ] logical :: los_intersect !! Determination of the CX rates type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( Float64 ), dimension ( nlevs ) :: rates !! CX rates !! Collisiional radiative model along track integer :: ntrack integer :: jj !! counter along track type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks real ( Float64 ) :: photons !! photon flux real ( Float64 ), dimension ( nlevs ) :: states !! Density of n-states real ( Float64 ), dimension ( nlevs ) :: denn integer :: nwav real ( Float64 ) :: etov2 , energy , pitch real ( Float64 ) :: dE , dP , dEdP real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr integer , dimension ( 1 ) :: ienergy , ipitch real ( Float64 ), dimension ( 3 ) :: randomu3 !! Number of particles to launch real ( Float64 ) :: fbm_denf , phase_area , max_papprox integer , dimension ( beam_grid % ngrid ) :: cell_ind real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox integer ( Int32 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: nlaunch nwav = inputs % nlambda_wght !! define arrays !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) dEdP = dE * dP phase_area = dEdP * real ( inputs % np_wght ) * real ( inputs % ne_wght ) !! allocate storage arrays allocate ( fweight % weight ( nwav , inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( fweight % mean_f ( inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) if ( inputs % verbose . ge . 1 ) then write ( * , '(T3,\"Number of Channels: \",i5)' ) spec_chords % nchan write ( * , '(T3,\"Nlambda: \",i4)' ) nwav write ( * , '(T3,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T3,\"Maximum Energy: \",f7.2)' ) inputs % emax_wght write ( * , '(T3,\"LOS averaged: \",a)' ) \"False\" endif !! zero out arrays fweight % weight = 0.d0 fweight % mean_f = 0.d0 etov2 = 1.d0 / ( v2_to_E_per_amu * inputs % ab ) !! Estimate how many particles to launch in each cell papprox = 0.d0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) call get_plasma ( plasma , ind = ind ) if (. not . plasma % in_plasma ) cycle papprox ( i , j , k ) = ( sum ( neut % full (:, i , j , k )) + & sum ( neut % half (:, i , j , k )) + & sum ( neut % third (:, i , j , k )) + & sum ( neut % dcx (:, i , j , k )) + & sum ( neut % halo (:, i , j , k ))) enddo !! TODO: Remove this once we have a 3D interpolation grid max_papprox = maxval ( papprox ) where ( papprox . lt .( max_papprox * 1.d-3 )) papprox = 0.0 endwhere ncell = 0 do ic = 1 , beam_grid % ngrid call ind2sub ( beam_grid % dims , ic , ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) if ( papprox ( i , j , k ). gt . 0.0 ) then ncell = ncell + 1 cell_ind ( ncell ) = ic endif enddo call get_nlaunch ( 10 * inputs % n_fida , papprox , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i10)' ) sum ( nlaunch ) endif !! Loop over all cells that have neutrals !$OMP PARALLEL DO schedule(guided) private(ic,i,j,k,ind,iion,vi,ri,rg,ienergy,ipitch, & !$OMP tracks,ntrack,jj,plasma,fields,rates,denn,states,photons,energy,pitch, & !$OMP los_intersect,randomu3,fbm_denf) loop_over_cells : do ic = istart , ncell , istep call ind2sub ( beam_grid % dims , cell_ind ( ic ), ind ) i = ind ( 1 ) ; j = ind ( 2 ) ; k = ind ( 3 ) loop_over_fast_ions : do iion = 1 , nlaunch ( i , j , k ) !! Sample fast ion distribution uniformally call randind ( inputs % ne_wght , ienergy ) call randind ( inputs % np_wght , ipitch ) call randu ( randomu3 ) energy = ebarr ( ienergy ( 1 )) + dE * ( randomu3 ( 1 ) - 0.5 ) pitch = ptcharr ( ipitch ( 1 )) + dP * ( randomu3 ( 2 ) - 0.5 ) if ( energy . le . 0 ) cycle loop_over_fast_ions call randu ( randomu3 ) rg = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] + beam_grid % dr * ( randomu3 - 0.5 ) !! Get velocity call get_fields ( fields , pos = rg ) if (. not . fields % in_plasma ) cycle loop_over_fast_ions call gyro_correction ( fields , energy , pitch , ri , vi ) fbm_denf = 0.0 if ( inputs % dist_type . eq . 1 ) then call get_ep_denf ( energy , pitch , fbm_denf , coeffs = fields % b ) endif !! Find the particles path through the beam grid call track ( ri , vi , tracks , ntrack , los_intersect ) if (. not . los_intersect ) cycle loop_over_fast_ions if ( ntrack . eq . 0 ) cycle loop_over_fast_ions !! Calculate CX probability with beam and halo neutrals call get_beam_cx_rate ( tracks ( 1 )% ind , ri , vi , beam_ion , neut_types , rates ) if ( sum ( rates ). le . 0. ) cycle loop_over_fast_ions states = rates * 1.d20 !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ntrack call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fw_photons ( ienergy ( 1 ), ipitch ( 1 ), & tracks ( jj )% pos , vi , fbm_denf , photons / nlaunch ( i , j , k )) enddo loop_along_track enddo loop_over_fast_ions enddo loop_over_cells !$OMP END PARALLEL DO fweight % weight = (( 1.d-20 ) * phase_area / dEdP ) * fweight % weight fweight % mean_f = (( 1.d-20 ) * phase_area / dEdP ) * fweight % mean_f if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'write fida weights:    ' , time ( time_start ) endif #ifdef _MPI call parallel_sum ( fweight % weight ) call parallel_sum ( fweight % mean_f ) if ( my_rank (). eq . 0 ) call write_fida_weights () #else call write_fida_weights () #endif end subroutine fida_weights_mc","tags":"","loc":"proc/fida_weights_mc.html","title":"fida_weights_mc – FIDASIM"},{"text":"public subroutine fida_weights_los() Calculates LOS averaged FIDA weights Arguments None Calls proc~~fida_weights_los~~CallsGraph proc~fida_weights_los fida_weights_los proc~get_fields get_fields proc~fida_weights_los->proc~get_fields proc~write_fida_weights write_fida_weights proc~fida_weights_los->proc~write_fida_weights proc~get_plasma get_plasma proc~fida_weights_los->proc~get_plasma proc~in_plasma in_plasma proc~fida_weights_los->proc~in_plasma proc~grid_intersect grid_intersect proc~fida_weights_los->proc~grid_intersect proc~track track proc~fida_weights_los->proc~track proc~colrad colrad proc~fida_weights_los->proc~colrad proc~bt_cx_rates bt_cx_rates proc~fida_weights_los->proc~bt_cx_rates interface~parallel_sum parallel_sum proc~fida_weights_los->interface~parallel_sum proc~pitch_to_vec pitch_to_vec proc~fida_weights_los->proc~pitch_to_vec proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~fida_weights_los->proc~store_fw_photons_at_chan proc~bb_cx_rates bb_cx_rates proc~fida_weights_los->proc~bb_cx_rates proc~my_rank my_rank proc~fida_weights_los->proc~my_rank proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw h5fclose_f h5fclose_f proc~write_fida_weights->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_fida_weights->h5ltmake_dataset_int_f h5close_f h5close_f proc~write_fida_weights->h5close_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_fida_weights->h5ltset_attribute_string_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f h5fcreate_f h5fcreate_f proc~write_fida_weights->h5fcreate_f h5open_f h5open_f proc~write_fida_weights->h5open_f proc~get_plasma->proc~in_plasma proc~get_plasma->proc~uvw_to_xyz proc~get_position get_position proc~get_plasma->proc~get_position proc~get_plasma->proc~xyz_to_uvw proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~in_passive_grid in_passive_grid proc~grid_intersect->proc~in_passive_grid proc~track->proc~get_fields proc~track->proc~in_plasma proc~get_indices get_indices proc~track->proc~get_indices proc~doppler_stark doppler_stark proc~track->proc~doppler_stark proc~linsolve linsolve proc~colrad->proc~linsolve proc~eigen eigen proc~colrad->proc~eigen proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~bt_cx_rates->interface~interpol_coeff proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~spectrum spectrum proc~store_fw_photons_at_chan->proc~spectrum proc~bb_cx_rates->interface~interpol_coeff proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz mpi_allreduce mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce dgetrf dgetrf proc~linsolve->dgetrf proc~matinv matinv proc~linsolve->proc~matinv dgetrs dgetrs proc~linsolve->dgetrs proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~balance balance proc~eigen->proc~balance proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~get_rate_matrix->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~approx_ge approx_ge proc~in_passive_grid->proc~approx_ge proc~approx_le approx_le proc~in_passive_grid->proc~approx_le proc~uvw_to_cyl uvw_to_cyl proc~in_passive_grid->proc~uvw_to_cyl proc~cyl_to_xyz->proc~cyl_to_uvw proc~cyl_to_xyz->proc~uvw_to_xyz proc~approx_eq approx_eq proc~approx_ge->proc~approx_eq proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~approx_le->proc~approx_eq h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~outerprod outerprod proc~ludcmp->proc~outerprod var panprocfida_weights_losCallsGraph = svgPanZoom('#procfida_weights_losCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fida_weights_los~~CalledByGraph proc~fida_weights_los fida_weights_los program~fidasim fidasim program~fidasim->proc~fida_weights_los Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code fida_weights_los Source Code subroutine fida_weights_los !+ Calculates LOS averaged FIDA weights type ( LocalProfiles ) :: plasma , plasma_cell type ( LocalEMFields ) :: fields , fields_cell real ( Float64 ) :: denf real ( Float64 ) :: wght , wght_tot real ( Float64 ) :: photons !! photon flux real ( Float64 ) :: length type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks integer :: nwav integer ( Int32 ) :: i , j , k , ienergy , cid , cind integer ( Int32 ) :: ipitch , igyro , icell , ichan real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr , phiarr real ( Float64 ), dimension (:,:), allocatable :: mean_f real ( Float64 ), dimension ( 3 ) :: vi , vi_norm , vp real ( Float64 ), dimension ( 3 ) :: vnbi_f , vnbi_h , vnbi_t , vhalo real ( Float64 ), dimension ( 3 ) :: r_enter , r_exit real ( Float64 ) :: vabs , dE , dP !! Determination of the CX probability real ( Float64 ), dimension ( nlevs ) :: fdens , hdens , tdens , dcxdens , halodens real ( Float64 ), dimension ( nlevs ) :: rates real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states real ( Float64 ), dimension ( nlevs ) :: denn ! Density of n-states !! COLRAD real ( Float64 ) :: dt , max_dens , dlength , sigma_pi type ( LOSInters ) :: inter real ( Float64 ) :: eb , ptch , phi !! Solution of differential equation integer , dimension ( 3 ) :: ind !!actual cell real ( Float64 ), dimension ( 3 ) :: ri integer ( Int32 ) :: ntrack logical :: inp real ( Float64 ) :: etov2 , dEdP nwav = inputs % nlambda_wght !! Define energy array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! Define pitch array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) dEdP = dE * dP !! define gyro - array allocate ( phiarr ( inputs % nphi_wght )) do i = 1 , inputs % nphi_wght phiarr ( i ) = real ( i - 0.5 ) * 2.d0 * pi / real ( inputs % nphi_wght ) enddo !! allocate storage arrays allocate ( fweight % mean_f ( inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( fweight % weight ( nwav , inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( mean_f ( inputs % ne_wght , inputs % np_wght )) !! zero out arrays fweight % weight = 0.d0 fweight % mean_f = 0.d0 mean_f = 0.d0 if ( inputs % verbose . ge . 1 ) then write ( * , '(T3,\"Number of Channels: \",i5)' ) spec_chords % nchan write ( * , '(T3,\"Nlambda: \",i4)' ) nwav write ( * , '(T3,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T3,\"Npitch: \",i3)' ) inputs % np_wght write ( * , '(T3,\"Ngyro: \", i3)' ) inputs % nphi_wght write ( * , '(T3,\"Maximum Energy: \",f7.2)' ) inputs % emax_wght write ( * , '(T3,\"LOS averaged: \",a)' ) \"True\" write ( * , * ) '' endif etov2 = 1.0 / ( v2_to_E_per_amu * inputs % ab ) chan_loop : do ichan = 1 , spec_chords % nchan fdens = 0.d0 ; hdens = 0.d0 ; tdens = 0.d0 halodens = 0.d0 ; dcxdens = 0.d0 plasma = plasma * 0.d0 fields = fields * 0.d0 wght_tot = 0.d0 mean_f = 0.d0 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny x_loop : do i = 1 , beam_grid % nx inter = spec_chords % inter ( i , j , k ) cid = 0 cind = 0 do while ( cid . ne . ichan . and . cind . lt . inter % nchan ) cind = cind + 1 cid = inter % los_elem ( cind )% id enddo if ( cid . eq . ichan ) then ind = [ i , j , k ] ri = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] call in_plasma ( ri , inp ) if (. not . inp ) cycle x_loop dlength = inter % los_elem ( cind )% length fdens = fdens + neut % full (:, i , j , k ) * dlength hdens = hdens + neut % half (:, i , j , k ) * dlength tdens = tdens + neut % third (:, i , j , k ) * dlength dcxdens = dcxdens + neut % dcx (:, i , j , k ) * dlength halodens = halodens + neut % halo (:, i , j , k ) * dlength wght = ( neut % full ( 3 , i , j , k ) + neut % half ( 3 , i , j , k ) + & neut % third ( 3 , i , j , k ) + neut % dcx ( 3 , i , j , k ) + & neut % halo ( 3 , i , j , k )) * dlength call get_plasma ( plasma_cell , pos = ri ) call get_fields ( fields_cell , pos = ri ) plasma = plasma + wght * plasma_cell fields = fields + wght * fields_cell if ( inputs % dist_type . eq . 1 ) then do ipitch = 1 , inputs % np_wght do ienergy = 1 , inputs % ne_wght call get_ep_denf ( ebarr ( ienergy ), ptcharr ( ipitch ), denf , coeffs = fields_cell % b ) mean_f ( ienergy , ipitch ) = mean_f ( ienergy , ipitch ) + wght * denf enddo enddo endif wght_tot = wght_tot + wght endif enddo x_loop enddo enddo if ( wght_tot . le . 0 ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Skipping channel \",i5,\": Neutral density is zero\")' ) ichan endif cycle chan_loop else plasma = plasma / wght_tot plasma % in_plasma = . True . fields = fields / wght_tot fields % in_plasma = . True . mean_f = mean_f / wght_tot if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Channel: \",i5)' ) ichan write ( * , '(T4,\"Radius: \",f7.2)' ) spec_chords % radius ( ichan ) write ( * , '(T4,\"Mean Fast-ion Density: \",ES14.5)' ) sum ( mean_f ) * dEdP write ( * , * ) '' endif endif ri = plasma % pos vp = ri - spec_chords % los ( ichan )% lens vnbi_f = ri - nbi % src vnbi_f = vnbi_f / norm2 ( vnbi_f ) * nbi % vinj vnbi_h = vnbi_f / sqrt ( 2.d0 ) vnbi_t = vnbi_f / sqrt ( 3.d0 ) sigma_pi = spec_chords % los ( ichan )% sigma_pi dlength = 1.d0 !$OMP PARALLEL DO schedule(guided) collapse(3) private(eb,vabs,ptch,phi,vi,vi_norm, & !$OMP& r_enter,r_exit,length,max_dens,ind,tracks,ntrack,dt,icell,states,rates, & !$OMP& vhalo,denn,denf,photons,ienergy,ipitch,igyro) do ienergy = istart , inputs % ne_wght , istep do ipitch = 1 , inputs % np_wght do igyro = 1 , inputs % nphi_wght eb = ebarr ( ienergy ) vabs = sqrt ( eb * etov2 ) ptch = ptcharr ( ipitch ) phi = phiarr ( igyro ) call pitch_to_vec ( ptch , phi , fields , vi_norm ) vi = vabs * vi_norm call grid_intersect ( ri , vi , length , r_enter , r_exit ) call track ( r_enter , vi , tracks , ntrack ) max_dens = 0.d0 do icell = 1 , ntrack ind = tracks ( icell )% ind tracks ( icell )% flux = neut % full ( 3 , ind ( 1 ), ind ( 2 ), ind ( 3 )) + & neut % half ( 3 , ind ( 1 ), ind ( 2 ), ind ( 3 )) + & neut % third ( 3 , ind ( 1 ), ind ( 2 ), ind ( 3 )) + & neut % dcx ( 3 , ind ( 1 ), ind ( 2 ), ind ( 3 )) + & neut % halo ( 3 , ind ( 1 ), ind ( 2 ), ind ( 3 )) if ( tracks ( icell )% flux . gt . max_dens ) max_dens = tracks ( icell )% flux enddo dt = 0.d0 do icell = 1 , ntrack if ( tracks ( icell )% flux . gt .( 0.5 * max_dens )) then dt = dt + tracks ( icell )% time endif enddo states = 0.d0 call bb_cx_rates ( fdens , vi , vnbi_f , rates ) states = states + rates call bb_cx_rates ( hdens , vi , vnbi_h , rates ) states = states + rates call bb_cx_rates ( tdens , vi , vnbi_t , rates ) states = states + rates call bt_cx_rates ( plasma , dcxdens + halodens , vi , beam_ion , rates ) states = states + rates call colrad ( plasma , beam_ion , vi , dt , states , denn , photons ) denf = mean_f ( ienergy , ipitch ) * dEdP photons = photons / real ( inputs % nphi_wght ) call store_fw_photons_at_chan ( ichan , ienergy , ipitch , & vp , vi , fields , dlength , sigma_pi , denf , photons ) enddo enddo enddo !$OMP END PARALLEL DO enddo chan_loop fweight % mean_f = fweight % mean_f / ( dEdP ) if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'write fida weights:    ' , time ( time_start ) endif #ifdef _MPI call parallel_sum ( fweight % weight ) call parallel_sum ( fweight % mean_f ) if ( my_rank (). eq . 0 ) call write_fida_weights () #else call write_fida_weights () #endif end subroutine fida_weights_los","tags":"","loc":"proc/fida_weights_los.html","title":"fida_weights_los – FIDASIM"},{"text":"public subroutine npa_weights() Calculates NPA weights Arguments None Calls proc~~npa_weights~~CallsGraph proc~npa_weights npa_weights proc~get_fields get_fields proc~npa_weights->proc~get_fields proc~write_npa_weights write_npa_weights proc~npa_weights->proc~write_npa_weights proc~hit_npa_detector hit_npa_detector proc~npa_weights->proc~hit_npa_detector proc~gyro_step gyro_step proc~npa_weights->proc~gyro_step interface~parallel_sum parallel_sum proc~npa_weights->interface~parallel_sum proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~get_beam_cx_rate get_beam_cx_rate proc~npa_weights->proc~get_beam_cx_rate proc~my_rank my_rank proc~npa_weights->proc~my_rank proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~uvw_to_xyz uvw_to_xyz proc~get_fields->proc~uvw_to_xyz proc~xyz_to_uvw xyz_to_uvw proc~get_fields->proc~xyz_to_uvw proc~in_plasma in_plasma proc~get_fields->proc~in_plasma h5fclose_f h5fclose_f proc~write_npa_weights->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_npa_weights->h5ltmake_dataset_int_f h5close_f h5close_f proc~write_npa_weights->h5close_f proc~write_beam_grid write_beam_grid proc~write_npa_weights->proc~write_beam_grid h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_npa_weights->h5ltset_attribute_string_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f h5fcreate_f h5fcreate_f proc~write_npa_weights->h5fcreate_f h5open_f h5open_f proc~write_npa_weights->h5open_f proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector->proc~line_plane_intersect proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~cross_product cross_product proc~gyro_step->proc~cross_product proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~colrad colrad proc~attenuate->proc~colrad proc~get_plasma get_plasma proc~attenuate->proc~get_plasma proc~bt_cx_rates bt_cx_rates proc~get_beam_cx_rate->proc~bt_cx_rates proc~get_beam_cx_rate->proc~get_plasma proc~bb_cx_rates bb_cx_rates proc~get_beam_cx_rate->proc~bb_cx_rates interface~interpol_coeff interpol_coeff proc~bt_cx_rates->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~linsolve linsolve proc~colrad->proc~linsolve mpi_allreduce mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~write_beam_grid->proc~xyz_to_uvw proc~write_beam_grid->h5ltset_attribute_string_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol_coeff proc~cyl_to_uvw cyl_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~get_plasma->proc~uvw_to_xyz proc~get_plasma->proc~xyz_to_uvw proc~get_plasma->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~bb_cx_rates->interface~interpol_coeff proc~get_rate_matrix->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~balback balback proc~eigen->proc~balback proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~balance balance proc~eigen->proc~balance h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f dgetrf dgetrf proc~linsolve->dgetrf proc~matinv matinv proc~linsolve->proc~matinv dgetrs dgetrs proc~linsolve->dgetrs proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~outerprod outerprod proc~ludcmp->proc~outerprod var panprocnpa_weightsCallsGraph = svgPanZoom('#procnpa_weightsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~npa_weights~~CalledByGraph proc~npa_weights npa_weights program~fidasim fidasim program~fidasim->proc~npa_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code npa_weights Source Code subroutine npa_weights !+ Calculates NPA weights type ( LocalEMFields ) :: fields type ( NPAProbability ) :: phit real ( Float64 ) :: pitch real ( Float64 ) :: pcxa integer ( Int32 ) :: det integer ( Int32 ) :: ii , jj , kk , i , ic !!indices integer , dimension ( 1 ) :: ipitch real ( Float64 ), dimension ( 3 ) :: vi , vi_norm real ( Float64 ) :: vabs , fbm_denf , dE , dP real ( Float64 ), dimension ( nlevs ) :: pcx !! Rate coefficiants for CX real ( Float64 ), dimension ( nlevs ) :: states , states_i ! Density of n-states integer , dimension ( 5 ) :: neut_types = [ 1 , 2 , 3 , 4 , 5 ] real ( Float64 ), dimension ( 3 ) :: pos , dpos , r_gyro integer ( Int32 ) :: ichan real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) if ( inputs % verbose . ge . 1 ) then write ( * , '(T3,\"Number of Channels: \",i3)' ) npa_chords % nchan write ( * , '(T3,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T3,\"Npitch: \",i3)' ) inputs % np_wght write ( * , '(T3,\"Maximum energy: \",f7.2)' ) inputs % emax_wght write ( * , * ) '' endif !! define storage arrays allocate ( nweight % emissivity ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % attenuation ( inputs % ne_wght , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % cx ( inputs % ne_wght , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % weight ( inputs % ne_wght , & inputs % np_wght , & npa_chords % nchan )) allocate ( nweight % flux ( inputs % ne_wght , npa_chords % nchan )) nweight % emissivity = 0.d0 nweight % attenuation = 0.d0 nweight % cx = 0.d0 nweight % weight = 0.d0 nweight % flux = 0.d0 loop_over_channels : do ichan = 1 , npa_chords % nchan !$OMP PARALLEL DO schedule(guided) collapse(3) private(ii,jj,kk,fields,phit,& !$OMP& ic,det,pos,dpos,r_gyro,pitch,ipitch,vabs,vi,pcx,pcxa,states,states_i,vi_norm,fbm_denf) loop_along_z : do kk = 1 , beam_grid % nz loop_along_y : do jj = 1 , beam_grid % ny loop_along_x : do ii = 1 , beam_grid % nx phit = npa_chords % phit ( ii , jj , kk , ichan ) if ( phit % p . gt . 0.d0 ) then pos = [ beam_grid % xc ( ii ), beam_grid % yc ( jj ), beam_grid % zc ( kk )] call get_fields ( fields , pos = pos ) if (. not . fields % in_plasma ) cycle loop_along_x !!Check if it hits a detector just to make sure dpos = phit % eff_rd vi_norm = phit % dir call hit_npa_detector ( pos , vi_norm , det ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'NPA_WEIGHTS: Missed detector' endif cycle loop_along_x endif !! Determine the angle between the B-field and the Line of Sight pitch = phit % pitch ipitch = minloc ( abs ( ptcharr - pitch )) loop_over_energy : do ic = istart , inputs % ne_wght , istep !! energy loop vabs = sqrt ( ebarr ( ic ) / ( v2_to_E_per_amu * inputs % ab )) vi = vi_norm * vabs !!Correct for gyro orbit call gyro_step ( vi , fields , r_gyro ) fbm_denf = 0 if ( inputs % dist_type . eq . 1 ) then !get dist at guiding center call get_ep_denf ( ebarr ( ic ), pitch , fbm_denf , pos = ( pos + r_gyro )) endif if ( fbm_denf . ne . fbm_denf ) cycle loop_over_energy !! -------------- calculate CX probability -------!! call get_beam_cx_rate ([ ii , jj , kk ], pos , vi , beam_ion , neut_types , pcx ) if ( sum ( pcx ). le . 0 ) cycle loop_over_energy !!Calculate attenuation states = pcx * 1.0d14 !!needs to be large aribitrary number so colrad works states_i = states call attenuate ( pos , dpos , vi , states ) pcxa = sum ( states ) / sum ( states_i ) !$OMP CRITICAL(npa_wght) nweight % attenuation ( ic , ii , jj , kk , ichan ) = pcxa nweight % cx ( ic , ii , jj , kk , ichan ) = sum ( pcx ) nweight % weight ( ic , ipitch ( 1 ), ichan ) = nweight % weight ( ic , ipitch ( 1 ), ichan ) + & 2 * sum ( pcx ) * pcxa * phit % p * beam_grid % dv / dP nweight % flux ( ic , ichan ) = nweight % flux ( ic , ichan ) + & 2 * beam_grid % dv * fbm_denf * sum ( pcx ) * pcxa * phit % p !Factor of 2 above is to convert fbm to ions/(cm&#94;3 dE (domega/4pi)) nweight % emissivity ( ii , jj , kk , ichan ) = nweight % emissivity ( ii , jj , kk , ichan ) + & 2 * fbm_denf * sum ( pcx ) * pcxa * phit % p * dE !$OMP END CRITICAL(npa_wght) enddo loop_over_energy endif enddo loop_along_x enddo loop_along_y enddo loop_along_z !$OMP END PARALLEL DO enddo loop_over_channels #ifdef _MPI call parallel_sum ( nweight % weight ) call parallel_sum ( nweight % flux ) call parallel_sum ( nweight % cx ) call parallel_sum ( nweight % attenuation ) call parallel_sum ( nweight % emissivity ) #endif do ichan = 1 , npa_chords % nchan if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Channel: \",i3)' ) ichan write ( * , '(T4,\"Radius: \",f10.3)' ) npa_chords % radius ( ichan ) write ( * , '(T4,A,ES14.5)' ) 'Flux:   ' , sum ( nweight % flux (:, ichan )) * dE write ( * , '(T4,A,ES14.5)' ) 'Weight: ' , sum ( nweight % weight (:,:, ichan )) * dE * dP write ( * , * ) '' endif enddo if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'write npa weights:    ' , time ( time_start ) endif #ifdef _MPI if ( my_rank (). eq . 0 ) call write_npa_weights () #else call write_npa_weights () #endif end subroutine npa_weights","tags":"","loc":"proc/npa_weights.html","title":"npa_weights – FIDASIM"},{"text":"public interface assignment(=) Allows for assigning Profiles , LocalProfiles , EMFields , LocalEMFields , FastIon , NPAParticle , and BirthParticle Calls interface~~assignment(=)~~CallsGraph interface~assignment(=) assignment(=) proc~ff_assign ff_assign interface~assignment(=)->proc~ff_assign proc~pp_assign pp_assign interface~assignment(=)->proc~pp_assign proc~flf_assign flf_assign interface~assignment(=)->proc~flf_assign proc~fast_ion_assign fast_ion_assign interface~assignment(=)->proc~fast_ion_assign proc~lff_assign lff_assign interface~assignment(=)->proc~lff_assign proc~lplp_assign lplp_assign interface~assignment(=)->proc~lplp_assign proc~lpp_assign lpp_assign interface~assignment(=)->proc~lpp_assign proc~plp_assign plp_assign interface~assignment(=)->proc~plp_assign proc~npa_part_assign npa_part_assign interface~assignment(=)->proc~npa_part_assign proc~lflf_assign lflf_assign interface~assignment(=)->proc~lflf_assign proc~birth_part_assign birth_part_assign interface~assignment(=)->proc~birth_part_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures pp_assign lpp_assign plp_assign lplp_assign ff_assign lff_assign flf_assign lflf_assign fast_ion_assign npa_part_assign birth_part_assign Module Procedures public subroutine pp_assign (p1, p2) Defines how to assign Profiles types to eachother Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 public subroutine lpp_assign (p1, p2) Defines how to assign a Profiles type to a LocalProfiles type Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 public subroutine plp_assign (p1, p2) Defines how to assign a LocalProfiles type to a Profiles type Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine lplp_assign (p1, p2) Defines how to assign LocalProfiles types to eachother Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine ff_assign (p1, p2) Defines how to assign EMFields types to eachother Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 public subroutine lff_assign (p1, p2) Defines how to assign a EMFields type to a LocalEMFields type Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 public subroutine flf_assign (p1, p2) Defines how to assign a LocalEMFields type to a EMFields type Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine lflf_assign (p1, p2) Defines how to assign LocalEMFields types to eachother Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine fast_ion_assign (p1, p2) Defines how to assign FastIon types to eachother Arguments Type Intent Optional Attributes Name type( FastIon ), intent(out) :: p1 type( FastIon ), intent(in) :: p2 public subroutine npa_part_assign (p1, p2) Defines how to assign NPAParticle types to eachother Arguments Type Intent Optional Attributes Name type( NPAParticle ), intent(out) :: p1 type( NPAParticle ), intent(in) :: p2 public subroutine birth_part_assign (p1, p2) Defines how to assign BirthParticle types to eachother Arguments Type Intent Optional Attributes Name type( BirthParticle ), intent(out) :: p1 type( BirthParticle ), intent(in) :: p2","tags":"","loc":"interface/assignment(=).html","title":"assignment(=) – FIDASIM"},{"text":"public interface operator(+) Allows for adding Profiles , LocalProfiles , EMFields , and LocalEMFields Calls interface~~operator(+)~~CallsGraph interface~operator(+) operator(+) proc~ff_add ff_add interface~operator(+)->proc~ff_add proc~lplp_add lplp_add interface~operator(+)->proc~lplp_add proc~pp_add pp_add interface~operator(+)->proc~pp_add proc~lflf_add lflf_add interface~operator(+)->proc~lflf_add proc~calc_perp_vectors calc_perp_vectors proc~lflf_add->proc~calc_perp_vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures pp_add lplp_add ff_add lflf_add Module Procedures public function pp_add (p1, p2) result(p3) Defines how to add two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_add (p1, p2) result(p3) Defines how to add two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ff_add (p1, p2) result(p3) Defines how to add two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function lflf_add (p1, p2) result(p3) Defines how to add two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields )","tags":"","loc":"interface/operator(+).html","title":"operator(+) – FIDASIM"},{"text":"public interface operator(-) Allows for subtracting Profiles , LocalProfiles , EMFields , and LocalEMFields Calls interface~~operator(-)~~CallsGraph interface~operator(-) operator(-) proc~pp_subtract pp_subtract interface~operator(-)->proc~pp_subtract proc~lflf_subtract lflf_subtract interface~operator(-)->proc~lflf_subtract proc~lplp_subtract lplp_subtract interface~operator(-)->proc~lplp_subtract proc~ff_subtract ff_subtract interface~operator(-)->proc~ff_subtract proc~calc_perp_vectors calc_perp_vectors proc~lflf_subtract->proc~calc_perp_vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures pp_subtract lplp_subtract ff_subtract lflf_subtract Module Procedures public function pp_subtract (p1, p2) result(p3) Defines how to subtract two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_subtract (p1, p2) result(p3) Defines how to subtract two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ff_subtract (p1, p2) result(p3) Defines how to subtract two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function lflf_subtract (p1, p2) result(p3) Defines how to subtract two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields )","tags":"","loc":"interface/operator(-).html","title":"operator(-) – FIDASIM"},{"text":"public interface operator(*) Allows for multiplying Profiles , LocalProfiles , EMFields , and LocalEMFields by scalars Calls interface~~operator(*)~~CallsGraph interface~operator(*) operator(*) proc~sf_multiply sf_multiply interface~operator(*)->proc~sf_multiply proc~lfs_multiply lfs_multiply interface~operator(*)->proc~lfs_multiply proc~slp_multiply slp_multiply interface~operator(*)->proc~slp_multiply proc~ps_multiply ps_multiply interface~operator(*)->proc~ps_multiply proc~sp_multiply sp_multiply interface~operator(*)->proc~sp_multiply proc~lps_multiply lps_multiply interface~operator(*)->proc~lps_multiply proc~fs_multiply fs_multiply interface~operator(*)->proc~fs_multiply proc~slf_multiply slf_multiply interface~operator(*)->proc~slf_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures sp_multiply ps_multiply lps_multiply slp_multiply sf_multiply fs_multiply lfs_multiply slf_multiply Module Procedures public function sp_multiply (real_scalar, p1) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( Profiles ), intent(in) :: p1 Return Value type( Profiles ) public function ps_multiply (p1, real_scalar) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_multiply (p1, real_scalar) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function slp_multiply (real_scalar, p1) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalProfiles ), intent(in) :: p1 Return Value type( LocalProfiles ) public function sf_multiply (real_scalar, p1) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( EMFields ), intent(in) :: p1 Return Value type( EMFields ) public function fs_multiply (p1, real_scalar) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) public function lfs_multiply (p1, real_scalar) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields ) public function slf_multiply (real_scalar, p1) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalEMFields ), intent(in) :: p1 Return Value type( LocalEMFields )","tags":"","loc":"interface/operator(*).html","title":"operator(*) – FIDASIM"},{"text":"public interface operator(/) Allows for dividing Profiles , LocalProfiles , EMFields , and LocalEMFields by scalars Calls interface~~operator(SLASH)~~CallsGraph interface~operator(SLASH) operator(/) proc~lps_divide lps_divide interface~operator(SLASH)->proc~lps_divide proc~ps_divide ps_divide interface~operator(SLASH)->proc~ps_divide proc~lfs_divide lfs_divide interface~operator(SLASH)->proc~lfs_divide proc~fs_divide fs_divide interface~operator(SLASH)->proc~fs_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures ps_divide lps_divide fs_divide lfs_divide Module Procedures public function ps_divide (p1, real_scalar) result(p3) Defines how to divide Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_divide (p1, real_scalar) result(p3) Defines how to divide LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function fs_divide (p1, real_scalar) result(p3) Defines how to divide EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) public function lfs_divide (p1, real_scalar) result(p3) Defines how to divide LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields )","tags":"","loc":"interface/operator(SLASH).html","title":"operator(/) – FIDASIM"},{"text":"public interface interpol_coeff Calculates interpolation coefficients Calls interface~~interpol_coeff~~CallsGraph interface~interpol_coeff interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~interpol_coeff~~CalledByGraph interface~interpol_coeff interpol_coeff proc~in_plasma in_plasma proc~in_plasma->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff proc~interpol3d_arr interpol3D_arr proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~get_neutron_rate get_neutron_rate proc~get_neutron_rate->interface~interpol_coeff proc~bt_cx_rates bt_cx_rates proc~bt_cx_rates->interface~interpol_coeff proc~bb_cx_rates bb_cx_rates proc~bb_cx_rates->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff proc~interpol3d_2d_arr interpol3D_2D_arr proc~interpol3d_2d_arr->interface~interpol_coeff proc~get_fields get_fields proc~get_fields->proc~in_plasma proc~make_beam_grid make_beam_grid proc~make_beam_grid->proc~in_plasma proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~bt_cx_rates proc~pnpa_mc->proc~get_fields proc~get_plasma get_plasma proc~pnpa_mc->proc~get_plasma proc~store_npa store_npa proc~pnpa_mc->proc~store_npa proc~attenuate attenuate proc~pnpa_mc->proc~attenuate proc~track_cylindrical track_cylindrical proc~track_cylindrical->proc~in_plasma proc~track_cylindrical->proc~get_fields proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~in_plasma proc~fida_weights_los->proc~bt_cx_rates proc~fida_weights_los->proc~bb_cx_rates proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~track track proc~fida_weights_los->proc~track proc~colrad colrad proc~fida_weights_los->proc~colrad proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~pfida_mc pfida_mc proc~pfida_mc->proc~bt_cx_rates proc~pfida_mc->proc~get_fields proc~pfida_mc->proc~track_cylindrical proc~pfida_mc->proc~get_plasma proc~get_plasma->proc~in_plasma proc~dcx_spec dcx_spec proc~dcx_spec->proc~in_plasma proc~dcx_spec->proc~get_plasma proc~store_photons store_photons proc~dcx_spec->proc~store_photons proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_neutron_rate proc~neutron_mc->proc~get_fields proc~neutron_mc->proc~get_plasma proc~track->proc~in_plasma proc~track->proc~get_fields proc~halo_spec halo_spec proc~halo_spec->proc~in_plasma proc~halo_spec->proc~get_plasma proc~halo_spec->proc~store_photons proc~nbi_spec nbi_spec proc~nbi_spec->proc~in_plasma proc~nbi_spec->proc~store_photons proc~get_plasma_extrema get_plasma_extrema proc~get_plasma_extrema->proc~in_plasma interface~interpol interpol interface~interpol->proc~interpol2d_arr interface~interpol->proc~interpol3d_arr interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol1d_arr interface~interpol->proc~interpol3d_2d_arr proc~neutron_f neutron_f proc~neutron_f->proc~get_neutron_rate proc~neutron_f->proc~get_fields proc~neutron_f->proc~get_plasma proc~pfida_f pfida_f proc~pfida_f->proc~bt_cx_rates proc~pfida_f->proc~track_cylindrical proc~pfida_f->proc~get_plasma proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~pfida_f->proc~mc_fastion_pass_grid proc~get_beam_cx_rate get_beam_cx_rate proc~get_beam_cx_rate->proc~bt_cx_rates proc~get_beam_cx_rate->proc~bb_cx_rates proc~get_beam_cx_rate->proc~get_plasma proc~colrad->proc~get_rate_matrix proc~pnpa_f pnpa_f proc~pnpa_f->proc~bt_cx_rates proc~pnpa_f->proc~get_plasma proc~pnpa_f->proc~mc_fastion_pass_grid proc~pnpa_f->proc~store_npa proc~pnpa_f->proc~attenuate proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~read_distribution read_distribution proc~read_distribution->proc~read_mc proc~mc_fastion_pass_grid->proc~get_fields proc~get_distribution get_distribution proc~mc_fastion_pass_grid->proc~get_distribution proc~get_distribution->interface~interpol proc~npa_mc npa_mc proc~npa_mc->proc~get_fields proc~npa_mc->proc~get_beam_cx_rate proc~npa_mc->proc~store_npa proc~npa_mc->proc~attenuate proc~ndmc ndmc proc~ndmc->proc~get_fields proc~ndmc->proc~mc_nbi proc~ndmc->proc~track program~fidasim fidasim program~fidasim->proc~make_beam_grid program~fidasim->proc~pnpa_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~pfida_mc program~fidasim->proc~dcx_spec program~fidasim->proc~neutron_mc program~fidasim->proc~halo_spec program~fidasim->proc~nbi_spec program~fidasim->proc~neutron_f program~fidasim->proc~pfida_f program~fidasim->proc~pnpa_f program~fidasim->proc~bremsstrahlung program~fidasim->proc~read_distribution program~fidasim->proc~npa_mc program~fidasim->proc~ndmc proc~read_equilibrium read_equilibrium program~fidasim->proc~read_equilibrium proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~halo halo program~fidasim->proc~halo proc~dcx dcx program~fidasim->proc~dcx proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~cold_spec cold_spec program~fidasim->proc~cold_spec proc~make_diagnostic_grids make_diagnostic_grids program~fidasim->proc~make_diagnostic_grids proc~read_equilibrium->proc~colrad proc~npa_weights->proc~get_fields proc~npa_weights->proc~get_beam_cx_rate proc~npa_weights->proc~attenuate proc~fida_mc->proc~get_fields proc~fida_mc->proc~track proc~mc_halo mc_halo proc~mc_halo->proc~get_plasma proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~store_npa->proc~get_fields proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~store_photons->proc~get_fields proc~npa_f->proc~get_plasma proc~npa_f->proc~get_beam_cx_rate proc~npa_f->proc~store_npa proc~npa_f->proc~attenuate proc~npa_f->proc~mc_fastion proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~get_ep_denf get_ep_denf proc~fida_weights_mc->proc~get_ep_denf proc~cold_spec->proc~get_plasma proc~cold_spec->proc~store_photons proc~make_diagnostic_grids->proc~get_fields proc~make_diagnostic_grids->proc~track_cylindrical proc~make_diagnostic_grids->proc~track proc~make_passive_grid make_passive_grid proc~make_diagnostic_grids->proc~make_passive_grid proc~get_ep_denf->interface~interpol proc~make_passive_grid->proc~get_plasma_extrema proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~store_photons proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~store_photons var paninterfaceinterpol_coeffCalledByGraph = svgPanZoom('#interfaceinterpol_coeffCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures interpol1D_coeff interpol1D_coeff_arr interpol2D_coeff interpol2D_coeff_arr cyl_interpol3D_coeff cyl_interpol3D_coeff_arr Module Procedures public subroutine interpol1D_coeff (xmin, dx, nx, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa value real(kind=Float64), intent(in) :: dx Absissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol1D_coeff_arr (x, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol2D_coeff (xmin, dx, nx, ymin, dy, ny, xout, yout, c, err) Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa real(kind=Float64), intent(in) :: dx Abscissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: ymin Minimum ordinate real(kind=Float64), intent(in) :: dy Ordinate spacing integer, intent(in) :: ny Number of ordinates points real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol2D_coeff_arr (x, y, xout, yout, c, err) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in), dimension(:) :: y Ordinate values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine cyl_interpol3D_coeff (rmin, dr, nr, zmin, dz, nz, phimin, dphi, nphi, rout, zout, phiout, c, err) Cylindrical interpolation coefficients and indicies for a 3D grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: rmin Minimum R real(kind=Float64), intent(in) :: dr R spacing integer, intent(in) :: nr Number of R points real(kind=Float64), intent(in) :: zmin Minimum Z real(kind=Float64), intent(in) :: dz Z spacing integer, intent(in) :: nz Number of Z points real(kind=Float64), intent(in) :: phimin Minimum phi real(kind=Float64), intent(in) :: dphi Phi spacing integer, intent(in) :: nphi Number of phi points real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate type( InterpolCoeffs3D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine cyl_interpol3D_coeff_arr (r, z, phi, rout, zout, phiout, c, err) Cylindrical interpolation coefficients and indicies for a 3D grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: r R values real(kind=Float64), intent(in), dimension(:) :: z Z values real(kind=Float64), intent(in), dimension(:) :: phi Phi values real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate type( InterpolCoeffs3D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code","tags":"","loc":"interface/interpol_coeff.html","title":"interpol_coeff – FIDASIM"},{"text":"public interface interpol Performs linear/bilinear/cylindrical interpolation Calls interface~~interpol~~CallsGraph interface~interpol interpol proc~interpol3d_arr interpol3D_arr interface~interpol->proc~interpol3d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol3d_2d_arr interpol3D_2D_arr interface~interpol->proc~interpol3d_2d_arr interface~interpol_coeff interpol_coeff proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol3d_2d_arr->interface~interpol_coeff proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff var paninterfaceinterpolCallsGraph = svgPanZoom('#interfaceinterpolCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~interpol~~CalledByGraph interface~interpol interpol proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~mc_fastion_pass_grid->proc~get_distribution proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~fida_f fida_f proc~fida_f->proc~mc_fastion proc~pnpa_f pnpa_f proc~pnpa_f->proc~mc_fastion_pass_grid proc~pfida_f pfida_f proc~pfida_f->proc~mc_fastion_pass_grid proc~npa_f npa_f proc~npa_f->proc~mc_fastion program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~pnpa_f program~fidasim->proc~pfida_f program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures interpol1D_arr interpol2D_arr interpol2D_2D_arr interpol3D_arr interpol3D_2D_arr Module Procedures public subroutine interpol1D_arr (x, y, xout, yout, err, coeffs) Performs linear interpolation on a uniform 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of y real(kind=Float64), intent(in), dimension(:) :: y Values at abscissa values x : y(x) real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(out) :: yout Interpolant: y(xout) integer, intent(out), optional :: err Error code type( InterpolCoeffs1D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol2D_arr (x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:) :: z Values at the abscissa/ordinates: z(x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out) :: zout Interpolant: z(xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol2D_2D_arr (x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid of 2D arrays z(:,:,x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:,:,:) :: z Values at the abscissa/ordinates: z(:,:,x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out), dimension(:,:) :: zout Interpolant: z(:,:,xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol3D_arr (r, z, phi, d, rout, zout, phiout, dout, err, coeffs) Performs cylindrical interpolation on a 3D grid f(r,z,phi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: r R values real(kind=Float64), intent(in), dimension(:) :: z Z values real(kind=Float64), intent(in), dimension(:) :: phi Phi values real(kind=Float64), intent(in), dimension(:,:,:) :: d Values at r,z,phi: d(r,z,phi) real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate real(kind=Float64), intent(out) :: dout Interpolant: d(rout,zout,phiout) integer, intent(out), optional :: err Error code type( InterpolCoeffs3D ), intent(in), optional :: coeffs Precomputed Interpolation Coefficients public subroutine interpol3D_2D_arr (r, z, phi, f, rout, zout, phiout, fout, err, coeffs) Performs cylindrical interpolation on a 3D grid of 2D arrays\n f(:,:,r,z,phi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: r R values real(kind=Float64), intent(in), dimension(:) :: z Z values real(kind=Float64), intent(in), dimension(:) :: phi Phi values real(kind=Float64), intent(in), dimension(:,:,:,:,:) :: f Values at r,z,phi: f(:,:,r,z,phi) real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate real(kind=Float64), intent(out), dimension(:,:) :: fout Interpolant: f(:,:,rout,zout,phiout) integer, intent(out), optional :: err Error code type( InterpolCoeffs3D ), intent(in), optional :: coeffs Precomputed Interpolation Coefficients","tags":"","loc":"interface/interpol.html","title":"interpol – FIDASIM"},{"text":"public function comabs(ar, ai) Calculates absolute value of a complex number a Arguments Type Intent Optional Attributes Name real(kind=double) :: ar Real part of a real(kind=double) :: ai Imaginary part of a Return Value real(kind=double) Absolute value of a Calls proc~~comabs~~CallsGraph proc~comabs comabs proc~rswap RSWAP proc~comabs->proc~rswap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code comabs Source Code function comabs ( ar , ai ) !+ Calculates absolute value of a complex number `a` real ( double ) :: ar !+ Real part of `a` real ( double ) :: ai !+ Imaginary part of `a` real ( double ) :: comabs !+ Absolute value of `a` if ( ar == ZERO . and . ai == ZERO ) then Comabs = ZERO return endif ar = DABS ( ar ) ai = DABS ( ai ) if ( ai > ar ) then !Switch  ai and ar call RSWAP ( ai , ar ) endif if ( ai == ZERO ) then Comabs = ar else Comabs = ar * DSQRT ( ONE + ai / ar * ai / ar ) endif end function comabs","tags":"","loc":"proc/comabs.html","title":"comabs – FIDASIM"},{"text":"public function outerprod(a, b) Calculates outer product Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: a real(kind=double), intent(in), dimension(:) :: b Return Value real(kind=double),\n  dimension(size(a),size(b)) Called by proc~~outerprod~~CalledByGraph proc~outerprod outerprod proc~ludcmp ludcmp proc~ludcmp->proc~outerprod proc~matinv matinv proc~matinv->proc~ludcmp proc~linsolve linsolve proc~linsolve->proc~matinv proc~colrad colrad proc~colrad->proc~linsolve proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~pnpa_f pnpa_f proc~pnpa_f->proc~attenuate proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_equilibrium program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc->proc~attenuate proc~npa_weights->proc~attenuate var panprocouterprodCalledByGraph = svgPanZoom('#procouterprodCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code outerprod Source Code function outerprod ( a , b ) !+ Calculates outer product real ( double ), dimension (:), intent ( IN ) :: a , b real ( double ), dimension ( size ( a ), size ( b )) :: outerprod outerprod = spread ( a , dim = 2 , ncopies = size ( b )) * & spread ( b , dim = 1 , ncopies = size ( a )) end function outerprod","tags":"","loc":"proc/outerprod.html","title":"outerprod – FIDASIM"},{"text":"public subroutine RSWAP(a, b) Swaps values a and b Arguments Type Intent Optional Attributes Name real(kind=double) :: a real(kind=double) :: b Called by proc~~rswap~~CalledByGraph proc~rswap RSWAP proc~comabs comabs proc~comabs->proc~rswap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code RSWAP Source Code subroutine RSWAP ( a , b ) !+ Swaps values `a` and `b` real ( double ) :: a , b , t t = a ; a = b ; b = t end subroutine RSWAP","tags":"","loc":"proc/rswap.html","title":"RSWAP – FIDASIM"},{"text":"public subroutine balance(n, mat, scal, low, high) Balances the matrix so that the rows with zero entries\noff the diagonal are isolated and the remaining columns and rows\nare resized to have one norm close to 1. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of mat real(kind=double) :: mat (0:n-1,0:n-1) n x n scaled matrix real(kind=double) :: scal (0:n-1) Contains isolated eigenvalue in the positions 0- low and high - n -1\n its other components contain the scaling factors for transforming mat integer, intent(out) :: low integer, intent(out) :: high Called by proc~~balance~~CalledByGraph proc~balance balance proc~eigen eigen proc~eigen->proc~balance proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~pnpa_f pnpa_f proc~pnpa_f->proc~attenuate proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_equilibrium program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc->proc~attenuate proc~npa_weights->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code balance Source Code subroutine balance ( n , mat , scal , low , high ) !+Balances the matrix so that the rows with zero entries !+off the diagonal are isolated and the remaining columns and rows !+are resized to have one norm close to 1. integer , intent ( in ) :: n !+ Dimension of `mat` real ( double ) :: mat ( 0 : n - 1 , 0 : n - 1 ) !+ `n`x`n` scaled matrix real ( double ) :: scal ( 0 : n - 1 ) !+ Contains isolated eigenvalue in the positions 0-`low` and `high`-`n`-1 !+ its other components contain the scaling factors for transforming `mat` integer , intent ( out ) :: high integer , intent ( out ) :: low integer , parameter :: basis = 2 real ( double ) :: b2 , r , c , f , g , s integer :: m , k , i , j , iter scal = 0.d0 b2 = basis * basis m = 0 k = n - 1 iter = 1 do while ( iter == 1 ) iter = 0 do j = k , 0 , - 1 r = ZERO do i = 0 , k if ( i . ne . j ) r = r + DABS ( mat ( j , i )) enddo if ( r == ZERO ) then scal ( k ) = j if ( j . ne . k ) then do i = 0 , k call RSWAP ( mat ( i , j ), mat ( i , k )) enddo do i = m , n - 1 call RSWAP ( mat ( j , i ), mat ( k , i )) enddo endif k = k - 1 iter = 1 endif enddo !j loop enddo !while iter=1 iter = 1 do while ( iter == 1 ) iter = 0 do j = m , k c = ZERO do i = m , k if ( i . ne . j ) c = c + DABS ( mat ( i , j )) enddo if ( c == ZERO ) then scal ( m ) = j if ( j . ne . m ) then do i = 0 , k call RSWAP ( mat ( i , j ), mat ( i , m )) enddo do i = m , n - 1 call RSWAP ( mat ( j , i ), mat ( m , i )) enddo endif m = m + 1 iter = 1 endif enddo !j loop enddo !while iter=1 low = m high = k do i = m , k scal ( i ) = ONE enddo iter = 1 do while ( iter == 1 ) iter = 0 do i = m , k c = ZERO ; r = ZERO do j = m , k if ( j . ne . i ) then c = c + DABS ( mat ( j , i )) r = r + DABS ( mat ( i , j )) endif enddo g = r / basis f = ONE s = c + r do while ( c < g ) f = f * basis c = c * b2 enddo g = r * basis do while ( c >= g ) f = f / basis c = c / b2 enddo if (( c + r ) / f < 0.95 * s ) then g = ONE / f scal ( i ) = scal ( i ) * f iter = 1 do j = m , n - 1 mat ( i , j ) = mat ( i , j ) * g enddo do j = 0 , k mat ( j , i ) = mat ( j , i ) * f enddo endif enddo !i loop enddo !while iter=1 return end subroutine balance","tags":"","loc":"proc/balance.html","title":"balance – FIDASIM"},{"text":"public subroutine balback(n, low, high, scal, eivec) Reverses the balancing of balance for the eigenvectors Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of matrix integer, intent(in) :: low First nonzero row integer, intent(in) :: high Last nonzero row real(kind=double), intent(in) :: scal (0:n-1) Scaling data from balance real(kind=double), intent(inout) :: eivec (0:n-1,0:n-1) Called by proc~~balback~~CalledByGraph proc~balback balback proc~eigen eigen proc~eigen->proc~balback proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~pnpa_f pnpa_f proc~pnpa_f->proc~attenuate proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_equilibrium program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc->proc~attenuate proc~npa_weights->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code balback Source Code subroutine balback ( n , low , high , scal , eivec ) !+  Reverses the balancing of balance for the eigenvectors integer , intent ( in ) :: n !+ Dimension of matrix integer , intent ( in ) :: low !+ First nonzero row integer , intent ( in ) :: high !+ Last nonzero row real ( double ), intent ( in ) :: scal ( 0 : n - 1 ) !+ Scaling data from balance real ( double ), intent ( inout ) :: eivec ( 0 : n - 1 , 0 : n - 1 ) !+ Input: n x n matrix of eigenvectors, as computed in qr2 !+ Output: Non-normalized eigenvectors of the original matrix real ( double ) :: s integer :: i , j , k do i = low , high s = scal ( i ) do j = 0 , n - 1 eivec ( i , j ) = eivec ( i , j ) * s enddo enddo do i = low - 1 , 0 , - 1 k = Int ( scal ( i )) if ( k . ne . i ) then do j = 0 , n - 1 call RSWAP ( eivec ( i , j ), eivec ( k , j )) enddo endif enddo do i = high + 1 , n - 1 k = Int ( scal ( i )) if ( k . ne . i ) then do j = 0 , n - 1 call RSWAP ( eivec ( i , j ), eivec ( k , j )) enddo endif enddo return end subroutine balback","tags":"","loc":"proc/balback.html","title":"balback – FIDASIM"},{"text":"public subroutine elmhes(n, low, high, mat, perm) Transforms the matrix mat to upper Hessenberg form. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of mat integer, intent(in) :: low First nonzero row integer, intent(in) :: high Last nonzero row real(kind=double), intent(inout) :: mat (0:n-1,0:n-1) is stored in the lower triangle integer, intent(out) :: perm (0:n-1) Permutation vector for elmtrans Called by proc~~elmhes~~CalledByGraph proc~elmhes elmhes proc~eigen eigen proc~eigen->proc~elmhes proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~pnpa_f pnpa_f proc~pnpa_f->proc~attenuate proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_equilibrium program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc->proc~attenuate proc~npa_weights->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code elmhes Source Code subroutine elmhes ( n , low , high , mat , perm ) !+Transforms the matrix `mat` to upper Hessenberg form. integer , intent ( in ) :: n !+Dimension of `mat` integer , intent ( in ) :: low !+First nonzero row integer , intent ( in ) :: high !+Last nonzero row real ( double ), intent ( inout ) :: mat ( 0 : n - 1 , 0 : n - 1 ) !+Input: `n`x`n` matrix !+Output: Upper Hessenberg matrix; additional information on the tranformation !+is stored in the lower triangle integer , intent ( out ) :: perm ( 0 : n - 1 ) !+Permutation vector for elmtrans integer :: i , j , m real ( double ) :: x , y do m = low + 1 , high - 1 i = m x = ZERO do j = m , high if ( DABS ( mat ( j , m - 1 )) > DABS ( x )) then x = mat ( j , m - 1 ) i = j endif enddo perm ( m ) = i if ( i . ne . m ) then do j = m - 1 , n - 1 call RSWAP ( mat ( i , j ), mat ( m , j )) enddo do j = 0 , high call RSWAP ( mat ( j , i ), mat ( j , m )) enddo endif if ( x . ne . ZERO ) then do i = m + 1 , high y = mat ( i , m - 1 ) if ( y . ne . ZERO ) then y = y / x mat ( i , m - 1 ) = y do j = m , n - 1 mat ( i , j ) = mat ( i , j ) - y * mat ( m , j ) enddo do j = 0 , high mat ( j , m ) = mat ( j , m ) + y * mat ( j , i ) enddo endif enddo !i loop endif !x <> ZERO enddo !m loop end subroutine elmhes","tags":"","loc":"proc/elmhes.html","title":"elmhes – FIDASIM"},{"text":"public subroutine elmtrans(n, low, high, mat, perm, h) Elmtrans copies the Hessenberg matrix stored in mat to h Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of mat integer, intent(in) :: low First nonzero row integer, intent(in) :: high Last nonzero row real(kind=double), intent(in) :: mat (0:n-1,0:n-1) n x n input matrix integer, intent(in) :: perm (0:n-1) Permutation data from elmhes real(kind=double), intent(out) :: h (0:n-1,0:n-1) Hessenberg matrix Called by proc~~elmtrans~~CalledByGraph proc~elmtrans elmtrans proc~eigen eigen proc~eigen->proc~elmtrans proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~pnpa_f pnpa_f proc~pnpa_f->proc~attenuate proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_equilibrium program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc->proc~attenuate proc~npa_weights->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code elmtrans Source Code Subroutine elmtrans ( n , low , high , mat , perm , h ) !+  Elmtrans copies the Hessenberg matrix stored in `mat` to `h` integer , intent ( in ) :: n !+ Dimension of mat integer , intent ( in ) :: low !+ First nonzero row integer , intent ( in ) :: high !+ Last nonzero row real ( double ), intent ( in ) :: mat ( 0 : n - 1 , 0 : n - 1 ) !+ `n`x`n` input matrix integer , intent ( in ) :: perm ( 0 : n - 1 ) !+ Permutation data from elmhes real ( double ), intent ( out ) :: h ( 0 : n - 1 , 0 : n - 1 ) !+ Hessenberg matrix integer :: i , j , k do i = 0 , n - 1 do k = 0 , n - 1 h ( i , k ) = ZERO enddo h ( i , i ) = ONE enddo do i = high - 1 , low + 1 , - 1 j = perm ( i ) do k = i + 1 , high h ( k , i ) = mat ( k , i - 1 ) enddo if ( i . ne . j ) then do k = i , high h ( i , k ) = h ( j , k ) h ( j , k ) = ZERO enddo h ( j , i ) = ONE endif enddo end subroutine elmtrans","tags":"","loc":"proc/elmtrans.html","title":"elmtrans – FIDASIM"},{"text":"public subroutine Comdiv(ar, ai, br, bi, cr, ci, rc) Performs complex division c = a / b Arguments Type Intent Optional Attributes Name real(kind=double) :: ar Real part of numerator real(kind=double) :: ai Imaginary part of numerator real(kind=double) :: br Real part of denominator real(kind=double) :: bi Imaginary part of denominator real(kind=double) :: cr Real part of quotient real(kind=double) :: ci Imaginary part of quotient integer :: rc return code Contents Source Code Comdiv Source Code subroutine Comdiv ( ar , ai , br , bi , cr , ci , rc ) !+ Performs complex division `c` = `a` / `b` real ( double ) :: ar !+ Real part of numerator real ( double ) :: ai !+ Imaginary part of numerator real ( double ) :: br !+ Real part of denominator real ( double ) :: bi !+ Imaginary part of denominator real ( double ) :: cr !+ Real part of quotient real ( double ) :: ci !+ Imaginary part of quotient integer :: rc !+ return code real ( double ) :: tmp if ( br == ZERO . AND . bi == ZERO ) then rc = 1 return endif if ( dabs ( br ) > dabs ( bi )) then tmp = bi / br br = tmp * bi + br cr = ( ar + tmp * ai ) / br ci = ( ai - tmp * ar ) / br else tmp = br / bi bi = tmp * br + bi cr = ( tmp * ar + ai ) / bi ci = ( tmp * ai - ar ) / bi endif rc = 0 end subroutine Comdiv !Comdiv","tags":"","loc":"proc/comdiv.html","title":"Comdiv – FIDASIM"},{"text":"public subroutine hqrvec(n, low, high, h, wr, wi, eivec, rc) Computes the eigenvectors for the eigenvalues found in hqr2 Input parameters n     :   int n;  ( n > 0 )\n         :   Dimension of  mat and eivec, number of eigenvalues. low   :   int low; high  :   int high; see  balance h     :   n x n upper Hessenberg matrix wr    :   vector of size n;\n         :   Real parts of the n eigenvalues. wi    :   vector of size n; Imaginary parts of the n eigenvalues. Output parameter: eivec :  n x n matrix, whose columns are the eigenvectors\n w   x |  | h[i][en]   |   | -r |\n       |  |            | = |    |\n y   z |  | h[i+1][en] |   | -s |\n w+i q     x | | h[i][na] + i h[i][en]  |   | -ra+i sa |\n             | |                        | = |          |\n   y    z+i q| | h[i+1][na]+i h[i+1][en]|   | -r+i s   | Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double) :: h (0:n-1,0:n-1) real(kind=double), intent(in) :: wr (0:n-1) real(kind=double), intent(in) :: wi (0:n-1) real(kind=double), intent(out) :: eivec (0:n-1,0:n-1) integer :: rc Called by proc~~hqrvec~~CalledByGraph proc~hqrvec hqrvec proc~hqr2 hqr2 proc~hqr2->proc~hqrvec proc~eigen eigen proc~eigen->proc~hqr2 proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~pnpa_f pnpa_f proc~pnpa_f->proc~attenuate proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_equilibrium program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc->proc~attenuate proc~npa_weights->proc~attenuate var panprochqrvecCalledByGraph = svgPanZoom('#prochqrvecCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code hqrvec Source Code subroutine hqrvec ( n , & !Dimension of matrix ....... low , & !first nonzero row ......... high , & !last nonzero row .......... h , & !upper Hessenberg matrix ... wr , & !Real parts of evalues ..... wi , & !Imaginary parts of evalues eivec , & !Eigenvectors .............. rc ) !return code ............... !+Computes the eigenvectors for the eigenvalues found in hqr2 !+ !+###Input parameters !+   n     :   int n;  ( n > 0 ) !+         :   Dimension of  mat and eivec, number of eigenvalues. !+ !+   low   :   int low; !+ !+   high  :   int high; see  balance !+ !+   h     :   n x n upper Hessenberg matrix !+ !+   wr    :   vector of size n; !+         :   Real parts of the n eigenvalues. !+ !+   wi    :   vector of size n; Imaginary parts of the n eigenvalues. !+ !+###Output parameter: !+   eivec :  n x n matrix, whose columns are the eigenvectors integer , intent ( in ) :: n integer , intent ( in ) :: high , low real ( double ), intent ( in ) :: wr ( 0 : n - 1 ), wi ( 0 : n - 1 ) real ( double ), intent ( out ) :: eivec ( 0 : n - 1 , 0 : n - 1 ) real ( double ) :: h ( 0 : n - 1 , 0 : n - 1 ) integer :: rc integer :: i , j , m , k , na , l integer :: code , en real ( double ) :: p , q , r , s , t , w , x , y , z , ra , sa , vr , vi , norm , temp r = ZERO ; s = ZERO ; z = ZERO ; norm = ZERO do i = 0 , n - 1 !find norm of h do j = i , n - 1 norm = norm + DABS ( h ( i , j )) enddo enddo if ( norm == ZERO ) then rc = 1 !zero matrix return endif do en = n - 1 , 0 , - 1 !transform back p = wr ( en ) q = wi ( en ) na = en - 1 if ( q == ZERO ) then m = en h ( en , en ) = ONE do i = na , 0 , - 1 w = h ( i , i ) - p r = h ( i , en ) do j = m , na r = r + h ( i , j ) * h ( j , en ) enddo if ( wi ( i ) < ZERO ) then z = w s = r else m = i if ( wi ( i ) == ZERO ) then if ( w . ne . ZERO ) then temp = w else temp = XMACH_EPS * norm endif h ( i , en ) = - r / temp else !Solve the linear system: !| w   x |  | h[i][en]   |   | -r | !|       |  |            | = |    | !| y   z |  | h[i+1][en] |   | -s | x = h ( i , i + 1 ) y = h ( i + 1 , i ) q = ( wr ( i ) - p ) ** 2 + wi ( i ) ** 2 h ( i , en ) = ( x * s - z * r ) / q t = h ( i , en ) if ( DABS ( x ) > DABS ( z )) then temp = ( - r - w * t ) / x else temp = ( - s - y * t ) / z endif h ( i + 1 , en ) = temp endif endif !wi[i] < 0 enddo !i loop else if ( q < ZERO ) then m = na if ( DABS ( h ( en , na )) > DABS ( h ( na , en ))) then h ( na , na ) = - ( h ( en , en ) - p ) / h ( en , na ) h ( na , en ) = - q / h ( en , na ) else call Comdiv ( - h ( na , en ), 0.d0 , h ( na , na ) - p , q , h ( na , na ), h ( na , en ), code ) endif h ( en , na ) = ONE h ( en , en ) = ZERO do i = na - 1 , 0 , - 1 w = h ( i , i ) - p ra = h ( i , en ) sa = ZERO do j = m , na ra = ra + h ( i , j ) * h ( j , na ) sa = sa + h ( i , j ) * h ( j , en ) enddo if ( wi ( i ) < ZERO ) then z = w r = ra s = sa else m = i if ( wi ( i ) == ZERO ) then call Comdiv ( - ra , - sa , w , q , h ( i , na ), h ( i , en ), code ) else !  solve complex linear system: !| w+i*q     x | | h[i][na] + i*h[i][en]  |   | -ra+i*sa | !|             | |                        | = |          | !|   y    z+i*q| | h[i+1][na]+i*h[i+1][en]|   | -r+i*s   | x = h ( i , i + 1 ) y = h ( i + 1 , i ) vr = ( wr ( i ) - p ) ** 2 + wi ( i ) ** 2 - q * q vi = TWO * q * ( wr ( i ) - p ) if ( vr == ZERO . AND . vi == ZERO ) then vr = XMACH_EPS * norm * ( DABS ( w ) + DABS ( q ) & + DABS ( x ) + DABS ( y ) + DABS ( z )) endif call Comdiv ( x * r - z * ra + q * sa , x * s - z * sa - q * ra & , vr , vi , h ( i , na ), h ( i , en ), code ) if ( DABS ( x ) > DABS ( z ) + DABS ( q )) then h ( i + 1 , na ) = ( - ra - w * h ( i , na ) + q * h ( i , en )) / x h ( i + 1 , en ) = ( - sa - w * h ( i , en ) - q * h ( i , na )) / x else call Comdiv ( - r - y * h ( i , na ), - s - y * h ( i , en ) & , z , q , h ( i + 1 , na ), h ( i + 1 , en ), code ) endif endif !wi[i] = 0 endif !wi[i] < 0 enddo !i loop endif !else if q < 0 enddo !en loop do i = 0 , n - 1 !Eigenvectors for the evalues for if ( i < low . or . i > high ) then !rows < low  and rows  > high do k = i + 1 , n - 1 eivec ( i , k ) = h ( i , k ) enddo endif enddo j = n - 1 do while ( j >= low ) if ( j <= high ) then m = j else j = high endif if ( j < 0 ) exit if ( wi ( j ) < ZERO ) then l = j - 1 do i = low , high y = ZERO ; z = ZERO do k = low , m y = y + eivec ( i , k ) * h ( k , l ) z = z + eivec ( i , k ) * h ( k , j ) enddo eivec ( i , l ) = y eivec ( i , j ) = z enddo else if ( wi ( j ) == ZERO ) then do i = low , high z = ZERO do k = low , m z = z + eivec ( i , k ) * h ( k , j ) enddo eivec ( i , j ) = z enddo endif endif j = j - 1 enddo !j loop rc = 0 end subroutine hqrvec","tags":"","loc":"proc/hqrvec.html","title":"hqrvec – FIDASIM"},{"text":"public subroutine hqr2(n, low, high, h, wr, wi, eivec, cnt, rc) Computes the eigenvalues and (if vec = True) the eigenvectors\nof an  n * n upper Hessenberg matrix. Input parameters n     :  integer;  ( n > 0 )\n            Dimension of  h and eivec,\n            length of the real parts vector  wr and of the\n            imaginary parts vector  wi of the eigenvalues. low   :  integer; high  :  integer;  see balance h     :  n x n matrix;\n            upper Hessenberg matrix as output of Elmhes\n            (destroyed in the process). Output parameters eivec :  n x n matrix;  (only if vec = 1)\n            Matrix, which for vec = 1 contains the\n            eigenvectors as follows:\n            For real eigebvalues the corresponding column\n            contains the corresponding eigenvactor, while for\n            complex eigenvalues the corresponding column contains\n            the real part of the eigenvactor with its imaginary\n            part is stored in the subsequent column of eivec.\n            The eigenvactor for the complex conjugate eigenvactor\n            is given by the complex conjugate eigenvactor. wr    :  vector of size n;\n            Real part of the n eigenvalues. wi    :  vector of size n;\n            Imaginary parts of the eigenvalues cnt   :  Integer vector of size n;\n            vector of iterations used for each eigenvalue.\n            For a complex conjugate eigenvalue pair the second\n            entry is negative. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double), intent(out) :: h (0:n-1,0:n-1) real(kind=double), intent(out) :: wr (0:n-1) real(kind=double), intent(out) :: wi (0:n-1) real(kind=double), intent(out) :: eivec (0:n-1,0:n-1) integer, intent(out) :: cnt (0:n-1) integer, intent(out) :: rc Calls proc~~hqr2~~CallsGraph proc~hqr2 hqr2 proc~hqrvec hqrvec proc~hqr2->proc~hqrvec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~hqr2~~CalledByGraph proc~hqr2 hqr2 proc~eigen eigen proc~eigen->proc~hqr2 proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~pnpa_f pnpa_f proc~pnpa_f->proc~attenuate proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_equilibrium program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc->proc~attenuate proc~npa_weights->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code hqr2 Source Code subroutine hqr2 ( n , & !Dimension of matrix ......... low , & !first nonzero row ........... high , & !last nonzero row ............ h , & !Hessenberg matrix ........... wr , & !Real parts of eigenvalues ... wi , & !Imaginary parts of evalues .. eivec ,& !Matrix of eigenvectors ...... cnt , & !Iteration counter ........... rc ) !return code ................. !+Computes the eigenvalues and (if vec = True) the eigenvectors !+of an  n * n upper Hessenberg matrix. !+ !+###Input parameters !+   n     :  integer;  ( n > 0 ) !+            Dimension of  h and eivec, !+            length of the real parts vector  wr and of the !+            imaginary parts vector  wi of the eigenvalues. !+ !+   low   :  integer; !+ !+   high  :  integer;  see balance !+ !+   h     :  n x n matrix; !+            upper Hessenberg matrix as output of Elmhes !+            (destroyed in the process). !+###Output parameters !+   eivec :  n x n matrix;  (only if vec = 1) !+            Matrix, which for vec = 1 contains the !+            eigenvectors as follows: !+            For real eigebvalues the corresponding column !+            contains the corresponding eigenvactor, while for !+            complex eigenvalues the corresponding column contains !+            the real part of the eigenvactor with its imaginary !+            part is stored in the subsequent column of eivec. !+            The eigenvactor for the complex conjugate eigenvactor !+            is given by the complex conjugate eigenvactor. !+ !+   wr    :  vector of size n; !+            Real part of the n eigenvalues. !+ !+   wi    :  vector of size n; !+            Imaginary parts of the eigenvalues !+ !+   cnt   :  Integer vector of size n; !+            vector of iterations used for each eigenvalue. !+            For a complex conjugate eigenvalue pair the second !+            entry is negative. integer , intent ( in ) :: n integer , intent ( in ) :: high , low real ( double ) , intent ( out ) :: h ( 0 : n - 1 , 0 : n - 1 ) real ( double ), intent ( out ) :: wr ( 0 : n - 1 ), wi ( 0 : n - 1 ) real ( double ), intent ( out ) :: eivec ( 0 : n - 1 , 0 : n - 1 ) integer , intent ( out ) :: rc integer , intent ( out ) :: cnt ( 0 : n - 1 ) integer :: en integer :: i , j , na , iter , l , ll , m , k real ( double ) :: p , q , r , s , t , w , x , y , z real ( double ) :: r_p , r_r , r_s , r_x , r_z p = ZERO ; q = ZERO ; r = ZERO do i = 0 , n - 1 if ( i < low . or . i > high ) then wr ( i ) = h ( i , i ) wi ( i ) = ZERO cnt ( i ) = 0 endif enddo en = high t = ZERO do while ( en >= low ) iter = 0 na = en - 1 do while ( 1 < 2 ) ll = 999 do l = en , low + 1 , - 1 !search for small !subdiagonal element if ( DABS ( h ( l , l - 1 )) <= XMACH_EPS * ( DABS ( h ( l - 1 , l - 1 )) + DABS ( h ( l , l )))) then ll = l ; !save current index goto 10 !exit l loop endif enddo 10 if ( ll . ne . 999 ) then l = ll else l = 0 !restore l endif x = h ( en , en ) if ( l == en ) then !found one evalue wr ( en ) = x + t h ( en , en ) = x + t wi ( en ) = ZERO cnt ( en ) = iter en = en - 1 goto 15 !exit from loop while(True) endif y = h ( na , na ) w = h ( en , na ) * h ( na , en ) if ( l == na ) then !found two evalues p = ( y - x ) * 0.5d0 q = p * p + w z = DSQRT ( DABS ( q )) x = x + t h ( en , en ) = x + t h ( na , na ) = y + t cnt ( en ) = - iter cnt ( na ) = iter if ( q >= ZERO ) then !real eigenvalues if ( p < ZERO ) then z = p - z else z = p + z endif r_z = 1.0d0 / z wr ( na ) = x + z wr ( en ) = x - w * r_z s = w - w * r_z wi ( na ) = ZERO wi ( en ) = ZERO x = h ( en , na ) r = DSQRT ( x * x + z * z ) r_r = 1.0d0 / r p = x * r_r q = z * r_r do j = na , n - 1 z = h ( na , j ) h ( na , j ) = q * z + p * h ( en , j ) h ( en , j ) = q * h ( en , j ) - p * z enddo do i = 0 , en z = h ( i , na ) h ( i , na ) = q * z + p * h ( i , en ) h ( i , en ) = q * h ( i , en ) - p * z enddo do i = low , high z = eivec ( i , na ) eivec ( i , na ) = q * z + p * eivec ( i , en ) eivec ( i , en ) = q * eivec ( i , en ) - p * z enddo else !pair of complex wr ( na ) = x + p wr ( en ) = x + p wi ( na ) = z wi ( en ) = - z endif !if q>=ZERO en = en - 2 goto 15 !exit while(1<2) endif !if l = na if ( iter >= MAXIT ) then cnt ( en ) = MAXIT + 1 rc = en write ( * , * ) ' stop at iter >= MAXIT.' return endif if ( iter . ne . 0. and . MOD ( iter , 10 ) == 0 ) then t = t + x do i = low , en h ( i , i ) = h ( i , i ) - x enddo s = DABS ( h ( en , na )) + DABS ( h ( na , en - 2 )) x = 0.75d0 * s ; y = x w = - 0.4375d0 * s * s endif iter = iter + 1 do m = en - 2 , l , - 1 z = h ( m , m ) r = x - z s = y - z p = ( r * s - w ) / h ( m + 1 , m ) + h ( m , m + 1 ) q = h ( m + 1 , m + 1 ) - z - r - s r = h ( m + 2 , m + 1 ) s = DABS ( p ) + DABS ( q ) + DABS ( r ) r_s = 1.0d0 / s p = p * r_s q = q * r_s r = r * r_s if ( m == l ) goto 12 if ( DABS ( h ( m , m - 1 )) * ( DABS ( q ) + DABS ( r )) <= XMACH_EPS * DABS ( p ) & * ( DABS ( h ( m - 1 , m - 1 )) + DABS ( z ) + DABS ( h ( m + 1 , m + 1 )))) then goto 12 !exit m loop endif enddo 12 do i = m + 2 , en h ( i , i - 2 ) = ZERO enddo do i = m + 3 , en h ( i , i - 3 ) = ZERO enddo do k = m , na if ( k . ne . m ) then !double QR step, for rows l to en and columns m to en p = h ( k , k - 1 ) q = h ( k + 1 , k - 1 ) if ( k . ne . na ) then r = h ( k + 2 , k - 1 ) else r = ZERO endif x = DABS ( p ) + DABS ( q ) + DABS ( r ) if ( x == ZERO ) goto 30 !next k r_x = 1.0d0 / x p = p * r_x q = q * r_x r = r * r_x endif s = DSQRT ( p * p + q * q + r * r ) if ( p < ZERO ) s = - s r_s = 1.0d0 / s if ( k . ne . m ) then h ( k , k - 1 ) = - s * x else if ( l . ne . m ) then h ( k , k - 1 ) = - h ( k , k - 1 ) endif p = p + s r_p = 1.0d0 / p x = p * r_s y = q * r_s z = r * r_s q = q * r_p r = r * r_p do j = k , n - 1 !modify rows p = h ( k , j ) + q * h ( k + 1 , j ) if ( k . ne . na ) then p = p + r * h ( k + 2 , j ) h ( k + 2 , j ) = h ( k + 2 , j ) - p * z endif h ( k + 1 , j ) = h ( k + 1 , j ) - p * y h ( k , j ) = h ( k , j ) - p * x enddo if ( k + 3 < en ) then j = k + 3 else j = en endif do i = 0 , j !modify columns p = x * h ( i , k ) + y * h ( i , k + 1 ) if ( k . ne . na ) then p = p + z * h ( i , k + 2 ) h ( i , k + 2 ) = h ( i , k + 2 ) - p * r endif h ( i , k + 1 ) = h ( i , k + 1 ) - p * q h ( i , k ) = h ( i , k ) - p enddo do i = low , high p = x * eivec ( i , k ) + y * eivec ( i , k + 1 ) if ( k . ne . na ) then p = p + z * eivec ( i , k + 2 ) eivec ( i , k + 2 ) = eivec ( i , k + 2 ) - p * r endif eivec ( i , k + 1 ) = eivec ( i , k + 1 ) - p * q eivec ( i , k ) = eivec ( i , k ) - p enddo 30 continue enddo !k loop enddo !while(1<2) 15 continue enddo !while en >= low                         All evalues found !transform evectors back call hqrvec ( n , low , high , h , wr , wi , eivec , rc ) end subroutine hqr2","tags":"","loc":"proc/hqr2.html","title":"hqr2 – FIDASIM"},{"text":"public subroutine eigen(n, matrix, eigvec, eigval) The subroutine eigen  determines all eigenvalues and (if desired)\nall eigenvectors of a real square  n * n  matrix via the QR method\nin the version of Martin, Parlett, Peters, Reinsch and Wilkinson. Literature Peters, Wilkinson: Eigenvectors of real and complex\n   matrices by LR and QR triangularisations,\n   Num. Math. 16, p.184-204, (1970); [PETE70]; contribution\n   II/15, p. 372 - 395 in [WILK71]. Martin, Wilkinson: Similarity reductions of a general\n   matrix to Hessenberg form, Num. Math. 12, p. 349-368,(1968)\n   [MART 68]; contribution II,13, p. 339 - 358 in [WILK71]. Parlett, Reinsch: Balancing a matrix for calculations of\n   eigenvalues and eigenvectors, Num. Math. 13, p. 293-304,\n   (1969); [PARL69]; contribution II/11, p.315 - 326 in\n   [WILK71]. Input parameters n     :  integer; ( n > 0 )\n            size of matrix, number of eigenvalues mat   :  n x n matrix;\n            input matrix Output parameters eivec :  n x n matrix;     (only if vec = 1)\n            matrix, if  vec = 1  that holds the eigenvectors\n            thus :\n            If the jth eigenvalue of the matrix is real then the\n            jth column is the corresponding real eigenvector;\n            if the jth eigenvalue is complex then the jth column\n            of eivec contains the real part of the eigenvector\n            while its imaginary part is in column j+1.\n            (the j+1st eigenvector is the complex conjugate\n            vector.) valre :  vector of size n;\n            Real parts of the eigenvalues. valim :  vector of size n;\n            Imaginary parts of the eigenvalues cnt   :  Integer vector of size n;\n            vector containing the number of iterations for each\n            eigenvalue. (for a complex conjugate pair the second\n            entry is negative). Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=double), intent(in), dimension(n,n) :: matrix real(kind=double), intent(out), dimension(n,n) :: eigvec real(kind=double), intent(out), dimension(n) :: eigval Calls proc~~eigen~~CallsGraph proc~eigen eigen proc~elmhes elmhes proc~eigen->proc~elmhes proc~balback balback proc~eigen->proc~balback proc~balance balance proc~eigen->proc~balance proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~hqrvec hqrvec proc~hqr2->proc~hqrvec Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~eigen~~CalledByGraph proc~eigen eigen proc~colrad colrad proc~colrad->proc~eigen proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~pnpa_f pnpa_f proc~pnpa_f->proc~attenuate proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_equilibrium program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc->proc~attenuate proc~npa_weights->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code eigen Source Code subroutine eigen ( n , matrix , eigvec , eigval ) !+The subroutine eigen  determines all eigenvalues and (if desired) !+all eigenvectors of a real square  n * n  matrix via the QR method !+in the version of Martin, Parlett, Peters, Reinsch and Wilkinson. !+ !+###Literature !+1. Peters, Wilkinson: Eigenvectors of real and complex !+   matrices by LR and QR triangularisations, !+   Num. Math. 16, p.184-204, (1970); [PETE70]; contribution !+   II/15, p. 372 - 395 in [WILK71]. !+2. Martin, Wilkinson: Similarity reductions of a general !+   matrix to Hessenberg form, Num. Math. 12, p. 349-368,(1968) !+   [MART 68]; contribution II,13, p. 339 - 358 in [WILK71]. !+3. Parlett, Reinsch: Balancing a matrix for calculations of !+   eigenvalues and eigenvectors, Num. Math. 13, p. 293-304, !+   (1969); [PARL69]; contribution II/11, p.315 - 326 in !+   [WILK71]. !+ !+###Input parameters !+   n     :  integer; ( n > 0 ) !+            size of matrix, number of eigenvalues !+ !+   mat   :  n x n matrix; !+            input matrix !+ !+###Output parameters !+   eivec :  n x n matrix;     (only if vec = 1) !+            matrix, if  vec = 1  that holds the eigenvectors !+            thus : !+            If the jth eigenvalue of the matrix is real then the !+            jth column is the corresponding real eigenvector; !+            if the jth eigenvalue is complex then the jth column !+            of eivec contains the real part of the eigenvector !+            while its imaginary part is in column j+1. !+            (the j+1st eigenvector is the complex conjugate !+            vector.) !+ !+   valre :  vector of size n; !+            Real parts of the eigenvalues. !+ !+   valim :  vector of size n; !+            Imaginary parts of the eigenvalues !+ !+   cnt   :  Integer vector of size n; !+            vector containing the number of iterations for each !+            eigenvalue. (for a complex conjugate pair the second !+            entry is negative). integer , intent ( in ) :: n ! nlevels real ( double ) , intent ( in ), dimension ( n , n ) :: matrix real ( double ) , intent ( out ), dimension ( n , n ) :: eigvec real ( double ) , intent ( out ), dimension ( n ) :: eigval real ( double ) :: mat ( 0 : n - 1 , 0 : n - 1 ) real ( double ) :: eivec ( 0 : n - 1 , 0 : n - 1 ) real ( double ) :: valre ( 0 : n - 1 ) !real parts of eigenvalues real ( double ) :: valim ( 0 : n - 1 ) !imaginary parts of eigenvalues integer :: rc !return code integer :: cnt ( 0 : n - 1 ) !Iteration counter integer :: high , low real ( double ) :: d ( 0 : n - 1 ), scale ( 0 : n - 1 ) integer :: perm ( 0 : n - 1 ) cnt = 0 ; d = 0.d0 mat ( 0 : n - 1 , 0 : n - 1 ) = matrix ( 1 : n , 1 : n ) !balance mat for nearly call balance ( n , mat , scale , low , high ) !equal row and column !reduce mat to upper call elmhes ( n , low , high , mat , perm ) !reduce mat to upper !Hessenberg form call elmtrans ( n , low , high , mat , perm , eivec ) !QR algorithm for eigenvalues and eigenvectors call hqr2 ( n , low , high , mat , valre , valim , eivec , cnt , rc ) !reverse balancing to determine eigenvectors call balback ( n , low , high , scale , eivec ) if ( rc . ne . 0 ) then print * , 'matrix = ' print * , matrix stop 'problem in eigen!' endif eigval ( 1 : n ) = valre ( 0 : n - 1 ) eigvec ( 1 : n , 1 : n ) = eivec ( 0 : n - 1 , 0 : n - 1 ) end subroutine eigen","tags":"","loc":"proc/eigen.html","title":"eigen – FIDASIM"},{"text":"public subroutine swap(a, b) Swap arrays a and b Arguments Type Intent Optional Attributes Name real(kind=double), intent(inout), dimension(:) :: a real(kind=double), intent(inout), dimension(:) :: b Contents Source Code swap Source Code subroutine swap ( a , b ) !+Swap arrays `a` and `b` real ( double ), dimension (:), intent ( INOUT ) :: a , b real ( double ), dimension ( size ( a )) :: dum dum = a a = b b = dum end subroutine swap","tags":"","loc":"proc/swap.html","title":"swap – FIDASIM"},{"text":"public subroutine ludcmp(a, indx, d) Calculates LU decomposition Arguments Type Intent Optional Attributes Name real(kind=double), intent(inout), dimension(:,:) :: a integer, intent(out), dimension(:) :: indx real(kind=double), intent(out) :: d Calls proc~~ludcmp~~CallsGraph proc~ludcmp ludcmp proc~outerprod outerprod proc~ludcmp->proc~outerprod Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ludcmp~~CalledByGraph proc~ludcmp ludcmp proc~matinv matinv proc~matinv->proc~ludcmp proc~linsolve linsolve proc~linsolve->proc~matinv proc~colrad colrad proc~colrad->proc~linsolve proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~pnpa_f pnpa_f proc~pnpa_f->proc~attenuate proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_equilibrium program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc->proc~attenuate proc~npa_weights->proc~attenuate var panprocludcmpCalledByGraph = svgPanZoom('#procludcmpCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ludcmp Source Code subroutine ludcmp ( a , indx , d ) !+Calculates LU decomposition real ( double ), dimension (:,:), intent ( INOUT ) :: a integer , dimension (:), intent ( OUT ) :: indx real ( double ), intent ( OUT ) :: d real ( double ), dimension ( size ( a , 1 )) :: vv integer , dimension ( 1 ) :: imaxloc integer :: j , n , imax n = size ( indx ) d = 1.0 vv = maxval ( abs ( a ), dim = 2 ) if ( any ( vv . eq . 0. )) stop 'singular matrix in ludcmp' vv = 1.d0 / vv do j = 1 , n imaxloc = maxloc ( vv ( j : n ) * abs ( a ( j : n , j ))) imax = ( j - 1 ) + imaxloc ( 1 ) if ( j /= imax ) then call swap ( a ( imax ,:), a ( j ,:)) d =- d vv ( imax ) = vv ( j ) endif indx ( j ) = imax if ( a ( j , j ) == 0.0 ) a ( j , j ) = 1.0d-20 a ( j + 1 : n , j ) = a ( j + 1 : n , j ) / a ( j , j ) a ( j + 1 : n , j + 1 : n ) = a ( j + 1 : n , j + 1 : n ) - outerprod ( a ( j + 1 : n , j ), a ( j , j + 1 : n )) enddo end subroutine ludcmp","tags":"","loc":"proc/ludcmp.html","title":"ludcmp – FIDASIM"},{"text":"public subroutine lubksb(a, indx, b) Does LU back substitution Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:,:) :: a integer, intent(in), dimension(:) :: indx real(kind=double), intent(inout), dimension(:) :: b Contents Source Code lubksb Source Code subroutine lubksb ( a , indx , b ) !+ Does LU back substitution real ( double ), dimension (:,:), intent ( IN ) :: a integer , dimension (:), intent ( IN ) :: indx real ( double ), dimension (:), intent ( INOUT ) :: b integer :: i , n , ii , ll real ( double ) :: summ n = size ( indx ) ii = 0 do i = 1 , n ll = indx ( i ) summ = b ( ll ) b ( ll ) = b ( i ) if ( ii /= 0 ) then summ = summ - dot_product ( a ( i , ii : i - 1 ), b ( ii : i - 1 )) else if ( summ /= 0.0 ) then ii = i endif b ( i ) = summ enddo do i = n , 1 , - 1 b ( i ) = ( b ( i ) - dot_product ( a ( i , i + 1 : n ), b ( i + 1 : n ))) / a ( i , i ) enddo end subroutine lubksb","tags":"","loc":"proc/lubksb.html","title":"lubksb – FIDASIM"},{"text":"public subroutine matinv(a, b) Matrix inversion with LU-decomposition Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:,:) :: a real(kind=double), intent(out), dimension(:,:) :: b Calls proc~~matinv~~CallsGraph proc~matinv matinv proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~outerprod outerprod proc~ludcmp->proc~outerprod Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~matinv~~CalledByGraph proc~matinv matinv proc~linsolve linsolve proc~linsolve->proc~matinv proc~colrad colrad proc~colrad->proc~linsolve proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~pnpa_f pnpa_f proc~pnpa_f->proc~attenuate proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_equilibrium program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc->proc~attenuate proc~npa_weights->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code matinv Source Code subroutine matinv ( a , b ) !+ Matrix inversion with LU-decomposition !==================================================== real ( double ), dimension (:,:), intent ( IN ) :: a real ( double ), dimension (:,:), intent ( OUT ) :: b real ( double ), dimension ( size ( a , dim = 1 ), size ( a , dim = 2 )) :: ah , y integer :: i , N integer , dimension ( size ( a , dim = 1 )) :: indx real ( double ) :: d N = size ( a , dim = 1 ) if ( N /= size ( a , dim = 2 )) stop 'SUB matinv: ludcmp matrix must be square!' ah = a y = 0. do i = 1 , N y ( i , i ) = 1.d0 enddo call ludcmp ( ah , indx , d ) do i = 1 , N call lubksb ( ah , indx , y (:, i )) enddo b = y end subroutine matinv","tags":"","loc":"proc/matinv.html","title":"matinv – FIDASIM"},{"text":"public subroutine linsolve(a, b, x) Solve linear equations A * X = B Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:,:) :: a real(kind=double), intent(in), dimension(:) :: b real(kind=double), intent(out), dimension(:) :: x Calls proc~~linsolve~~CallsGraph proc~linsolve linsolve proc~matinv matinv proc~linsolve->proc~matinv dgetrs dgetrs proc~linsolve->dgetrs dgetrf dgetrf proc~linsolve->dgetrf proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~outerprod outerprod proc~ludcmp->proc~outerprod Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~linsolve~~CalledByGraph proc~linsolve linsolve proc~colrad colrad proc~colrad->proc~linsolve proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~pnpa_f pnpa_f proc~pnpa_f->proc~attenuate proc~pnpa_mc pnpa_mc proc~pnpa_mc->proc~attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~read_equilibrium program~fidasim->proc~pnpa_f program~fidasim->proc~pnpa_mc program~fidasim->proc~npa_f proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc->proc~attenuate proc~npa_weights->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code linsolve Source Code subroutine linsolve ( a , b , x ) !+ Solve linear equations A * X = B real ( double ), dimension (:,:), intent ( IN ) :: a ! assume a square real ( double ), dimension (:), intent ( IN ) :: b ! assume size(b) == size(a,1) real ( double ), dimension (:), intent ( OUT ) :: x ! assume size(x) == size(b) #ifdef _USE_BLAS real ( double ), dimension ( size ( b ), size ( b )) :: lu integer , dimension ( size ( b )) :: ipiv integer :: n , info n = size ( b ) ! first factorize a lu (:,:) = a (:,:) call DGETRF ( n , n , lu , n , ipiv , info ) if ( info /= 0 ) stop 'sub linsolve: DGETRF failed!' x (:) = b (:) call DGETRS ( 'N' , n , 1 , lu , n , ipiv , x , n , info ) if ( info /= 0 ) stop 'sub linsolve: DGETRS failed!' #else real ( double ), dimension ( size ( b ), size ( b )) :: a_inv call matinv ( a , a_inv ) x = matmul ( a_inv , b ) !coeffs determined from states at t=0 #endif end subroutine linsolve","tags":"","loc":"proc/linsolve.html","title":"linsolve – FIDASIM"},{"text":"public function sub2ind(dims, subs) result(ind) Calculates the linear index of an array with dimensions dims and\n subcripts subs Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: dims Dimension of Array integer, intent(in), dimension(:) :: subs Subscripts to convert Return Value integer Linear index Called by proc~~sub2ind~~CalledByGraph proc~sub2ind sub2ind proc~get_value get_value proc~get_value->proc~sub2ind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sub2ind Source Code function sub2ind ( dims , subs ) result ( ind ) !+ Calculates the linear index of an array with dimensions `dims` and !+ subcripts `subs` integer , dimension (:), intent ( in ) :: dims !+ Dimension of Array integer , dimension (:), intent ( in ) :: subs !+ Subscripts to convert integer :: ind !+ Linear index integer :: k , l , p ind = subs ( 1 ) do k = 2 , size ( dims ) p = dims ( 1 ) do l = 2 , k - 1 p = p * dims ( l ) enddo ind = ind + p * ( subs ( k ) - 1 ) enddo end function sub2ind","tags":"","loc":"proc/sub2ind.html","title":"sub2ind – FIDASIM"},{"text":"public function rng_seed() result(seed) Generates random 32-bit integer seed from /dev/urandom Arguments None Return Value integer(kind=Int32) Seed value Called by proc~~rng_seed~~CalledByGraph proc~rng_seed rng_seed proc~rng_init rng_init proc~rng_init->proc~rng_seed proc~read_inputs read_inputs proc~read_inputs->proc~rng_seed proc~get_nlaunch get_nlaunch proc~get_nlaunch->proc~rng_init proc~get_nlaunch_pass_grid get_nlaunch_pass_grid proc~get_nlaunch_pass_grid->proc~rng_init program~fidasim fidasim program~fidasim->proc~read_inputs proc~pnpa_f pnpa_f program~fidasim->proc~pnpa_f proc~dcx dcx program~fidasim->proc~dcx proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~halo halo program~fidasim->proc~halo proc~pfida_f pfida_f program~fidasim->proc~pfida_f proc~pnpa_f->proc~get_nlaunch_pass_grid proc~dcx->proc~get_nlaunch proc~fida_weights_mc->proc~get_nlaunch proc~fida_f->proc~get_nlaunch proc~npa_f->proc~get_nlaunch proc~halo->proc~get_nlaunch proc~pfida_f->proc~get_nlaunch_pass_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code rng_seed Source Code function rng_seed () result ( seed ) !+ Generates random 32-bit integer seed from `/dev/urandom` integer ( Int32 ) :: seed !+ Seed value open ( 89 , file = \"/dev/urandom\" , access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" ) read ( 89 ) seed close ( 89 ) seed = abs ( seed ) end function rng_seed","tags":"","loc":"proc/rng_seed.html","title":"rng_seed – FIDASIM"},{"text":"public function get_rng() result(r) Arguments None Return Value type( rng_type ) Calls proc~~get_rng~~CallsGraph proc~get_rng get_rng omp_get_thread_num omp_get_thread_num proc~get_rng->omp_get_thread_num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_rng Source Code function get_rng () result ( r ) type ( rng_type ) :: r integer :: thread_id #ifdef _OMP thread_id = OMP_get_thread_num () + 1 #else thread_id = 1 #endif r = rng ( thread_id ) end function get_rng","tags":"","loc":"proc/get_rng.html","title":"get_rng – FIDASIM"},{"text":"public function rng_uniform(self) result(u) Generate a uniformally-distributed random number in the range [0,1) Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator Return Value real(kind=Float64) Uniform random deviate Called by proc~~rng_uniform~~CalledByGraph proc~rng_uniform rng_uniform proc~rng_normal rng_normal proc~rng_normal->proc~rng_uniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code rng_uniform Source Code function rng_uniform ( self ) result ( u ) !+ Generate a uniformally-distributed random number in the range [0,1) type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator real ( Float64 ) :: u !+ Uniform random deviate integer ( Int32 ) :: ix , iy , k real ( Float64 ) :: am ix = self % state ( 1 ) iy = self % state ( 2 ) ix = ieor ( ix , ishft ( ix , 13 )) ix = ieor ( ix , ishft ( ix , - 17 )) ix = ieor ( ix , ishft ( ix , 5 )) k = iy / IQ iy = IA * ( iy - k * IQ ) - IR * k if ( iy . lt . 0 ) iy = iy + IM self % state ( 1 ) = ix self % state ( 2 ) = iy am = nearest ( 1.0 , - 1.0 ) / IM u = am * ior ( iand ( IM , ieor ( ix , iy )), 1 ) end function rng_uniform","tags":"","loc":"proc/rng_uniform.html","title":"rng_uniform – FIDASIM"},{"text":"public function rng_normal(self) result(n) Generate a normally-distributed random number with mean 0 and standard deviation 1 Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator Return Value real(kind=Float64) Normal random deviate Calls proc~~rng_normal~~CallsGraph proc~rng_normal rng_normal proc~rng_uniform rng_uniform proc~rng_normal->proc~rng_uniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code rng_normal Source Code function rng_normal ( self ) result ( n ) !+ Generate a normally-distributed random number with mean 0 and standard deviation 1 type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator real ( Float64 ) :: n !+ Normal random deviate real ( Float64 ), parameter :: s = 0.449871d0 real ( Float64 ), parameter :: t = 0.386595d0 real ( Float64 ), parameter :: a = 0.196000d0 real ( Float64 ), parameter :: b = 0.254720d0 real ( Float64 ), parameter :: r1 = 0.27597d0 real ( Float64 ), parameter :: r2 = 0.27846d0 real ( Float64 ) :: u , v , x , y , q do u = rng_uniform ( self ) v = rng_uniform ( self ) v = 1.7156d0 * ( v - 0.5d0 ) x = u - s y = abs ( v ) + t q = x ** 2 + y * ( a * y - b * x ) if ( q . lt . r1 ) exit if ( q . gt . r2 ) cycle if (( v ** 2 ). lt .( - 4.0 * log ( u ) * u ** 2 )) exit enddo n = v / u end function rng_normal","tags":"","loc":"proc/rng_normal.html","title":"rng_normal – FIDASIM"},{"text":"public function get_value(SA, subs) result(val) Gets value of sparse array SA at the subscripts subs Arguments Type Intent Optional Attributes Name type( SparseArray ), intent(in) :: SA Sparse Array integer, intent(in), dimension(:) :: subs Subscripts of Sparse Array Return Value real(kind=Float64) Value of SA at subs Calls proc~~get_value~~CallsGraph proc~get_value get_value proc~sub2ind sub2ind proc~get_value->proc~sub2ind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code get_value Source Code function get_value ( SA , subs ) result ( val ) !+ Gets value of sparse array `SA` at the subscripts `subs` type ( SparseArray ), intent ( in ) :: SA !+ Sparse Array integer , dimension (:), intent ( in ) :: subs !+ Subscripts of Sparse Array real ( Float64 ) :: val !+ Value of `SA` at `subs` integer :: ind , cind val = 0.d0 if ( SA % nnz . eq . 0 ) return ind = sub2ind ( SA % dims , subs ) cind = search_sorted_first ( SA % inds , ind ) if ( ind . eq . SA % inds ( cind )) then val = SA % vals ( cind ) endif end function get_value","tags":"","loc":"proc/get_value.html","title":"get_value – FIDASIM"},{"text":"public function time(time_start) result(time_str) Returns time string Arguments Type Intent Optional Attributes Name integer, intent(in), optional dimension(8) :: time_start Optional start time Return Value character(len=30) Time string Contents Source Code time Source Code function time ( time_start ) result ( time_str ) !+ Returns time string integer , dimension ( 8 ), intent ( in ), optional :: time_start !+ Optional start time character ( 30 ) :: time_str !+ Time string integer :: ts ( 8 ), ta ( 8 ), hour , minu , sec ts = 0 if ( present ( time_start )) then ts = time_start endif call date_and_time ( values = ta ) hour = ta ( 5 ) - ts ( 5 ) minu = ta ( 6 ) - ts ( 6 ) sec = ta ( 7 ) - ts ( 7 ) if ( minu . lt . 0. ) then minu = minu + 60 hour = hour - 1 endif if ( sec . lt . 0. ) then sec = sec + 60 minu = minu - 1 endif if ( present ( time_start )) then write ( time_str , '(I2,\":\",I2.2,\":\",I2.2,\" --- elapsed:\",I2,\":\",I2.2,\":\",I2.2)' ) & ta ( 5 ), ta ( 6 ), ta ( 7 ), hour , minu , sec else write ( time_str , '(I2,\":\",I2.2,\":\",I2.2)' ) & ta ( 5 ), ta ( 6 ), ta ( 7 ) endif end function time","tags":"","loc":"proc/time.html","title":"time – FIDASIM"},{"text":"public function norm2(in) result(res) Arguments Type Intent Optional Attributes Name real(kind=Float64), dimension(:) :: in Return Value real(kind=Float64) Contents Source Code norm2 Source Code function norm2 ( in ) result ( res ) implicit none real ( Float64 ), dimension (:) :: in real ( Float64 ) :: res res = sqrt ( sum ( in (:) ** 2 )) end function norm2","tags":"","loc":"proc/norm2.html","title":"norm2 – FIDASIM"},{"text":"public subroutine ind2sub(dims, ind, subs) Calculate the subscripts subs into an array with dimensions dims given the corresponding linear index ind Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: dims Dimensions of array integer, intent(in) :: ind Linear index integer, intent(out), dimension(:) :: subs Subscripts corresponding to the linear index Called by proc~~ind2sub~~CalledByGraph proc~ind2sub ind2sub proc~pnpa_f pnpa_f proc~pnpa_f->proc~ind2sub proc~dcx_spec dcx_spec proc~dcx_spec->proc~ind2sub proc~dcx dcx proc~dcx->proc~ind2sub proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~ind2sub proc~halo_spec halo_spec proc~halo_spec->proc~ind2sub proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->proc~ind2sub proc~fida_f fida_f proc~fida_f->proc~ind2sub proc~cold_spec cold_spec proc~cold_spec->proc~ind2sub proc~nbi_spec nbi_spec proc~nbi_spec->proc~ind2sub proc~npa_f npa_f proc~npa_f->proc~ind2sub proc~halo halo proc~halo->proc~ind2sub proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~ind2sub proc~pfida_f pfida_f proc~pfida_f->proc~ind2sub program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx_spec program~fidasim->proc~dcx program~fidasim->proc~fida_weights_mc program~fidasim->proc~halo_spec program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~fida_f program~fidasim->proc~cold_spec program~fidasim->proc~nbi_spec program~fidasim->proc~npa_f program~fidasim->proc~halo program~fidasim->proc~read_equilibrium program~fidasim->proc~pfida_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code ind2sub Source Code subroutine ind2sub ( dims , ind , subs ) !+ Calculate the subscripts `subs` into an array with dimensions `dims` !+ given the corresponding linear index `ind` integer , dimension (:), intent ( in ) :: dims !+ Dimensions of array integer , intent ( in ) :: ind !+ Linear index integer , dimension (:), intent ( out ) :: subs !+ Subscripts corresponding to the linear index integer :: i , ndims , ind1 , ind2 ind1 = ind ndims = size ( dims ) do i = 1 , ndims - 1 ind2 = ( ind1 - 1 ) / dims ( i ) + 1 subs ( i ) = ind1 - dims ( i ) * ( ind2 - 1 ) ind1 = ind2 enddo subs ( ndims ) = ind1 end subroutine ind2sub","tags":"","loc":"proc/ind2sub.html","title":"ind2sub – FIDASIM"},{"text":"public subroutine rng_init(self, seed) Uses mpi_utils proc~~rng_init~~UsesGraph proc~rng_init rng_init module~mpi_utils mpi_utils proc~rng_init->module~mpi_utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Procedure to initialize a random number generator with a seed.\n If seed is negative then random seed is used Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator integer(kind=Int32), intent(in) :: seed Initial Seed Value Calls proc~~rng_init~~CallsGraph proc~rng_init rng_init proc~rng_seed rng_seed proc~rng_init->proc~rng_seed proc~my_rank my_rank proc~rng_init->proc~my_rank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rng_init~~CalledByGraph proc~rng_init rng_init proc~get_nlaunch get_nlaunch proc~get_nlaunch->proc~rng_init proc~get_nlaunch_pass_grid get_nlaunch_pass_grid proc~get_nlaunch_pass_grid->proc~rng_init proc~pnpa_f pnpa_f proc~pnpa_f->proc~get_nlaunch_pass_grid proc~dcx dcx proc~dcx->proc~get_nlaunch proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_nlaunch proc~fida_f fida_f proc~fida_f->proc~get_nlaunch proc~npa_f npa_f proc~npa_f->proc~get_nlaunch proc~halo halo proc~halo->proc~get_nlaunch proc~pfida_f pfida_f proc~pfida_f->proc~get_nlaunch_pass_grid program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~npa_f program~fidasim->proc~halo program~fidasim->proc~pfida_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code rng_init Source Code subroutine rng_init ( self , seed ) #ifdef _MPI use mpi_utils #endif !+ Procedure to initialize a random number generator with a seed. !+ If seed is negative then random seed is used type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator integer ( Int32 ), intent ( in ) :: seed !+ Initial Seed Value integer ( Int32 ) :: s if ( seed . lt . 0 ) then s = rng_seed () else #ifdef _MPI s = seed + my_rank () #else s = seed #endif endif self % seed = s self % state ( 1 ) = ieor ( 777755555 , abs ( s )) self % state ( 2 ) = ior ( ieor ( 888889999 , abs ( s )), 1 ) end subroutine rng_init","tags":"","loc":"proc/rng_init.html","title":"rng_init – FIDASIM"},{"text":"public subroutine cumsum(x, cs) Calculate cumulative sum Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Array to sum real(kind=Float64), intent(out), dimension(:) :: cs Cumulative sum of x Called by proc~~cumsum~~CalledByGraph proc~cumsum cumsum proc~get_nlaunch get_nlaunch proc~get_nlaunch->proc~cumsum proc~fida_f fida_f proc~fida_f->proc~get_nlaunch proc~dcx dcx proc~dcx->proc~get_nlaunch proc~npa_f npa_f proc~npa_f->proc~get_nlaunch proc~halo halo proc~halo->proc~get_nlaunch proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_nlaunch program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~dcx program~fidasim->proc~npa_f program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code cumsum Source Code subroutine cumsum ( x , cs ) !+ Calculate cumulative sum real ( Float64 ), dimension (:), intent ( in ) :: x !+ Array to sum real ( Float64 ), dimension (:), intent ( out ) :: cs !+ Cumulative sum of `x` integer :: i , n real ( Float64 ) :: cdf_val , t n = size ( x ) t = 0.d0 do i = 1 , n cs ( i ) = t + x ( i ) t = cs ( i ) enddo end subroutine cumsum","tags":"","loc":"proc/cumsum.html","title":"cumsum – FIDASIM"},{"text":"public interface randu Called by interface~~randu~~CalledByGraph interface~randu randu proc~dcx_spec dcx_spec proc~dcx_spec->interface~randu proc~mc_halo mc_halo proc~mc_halo->interface~randu proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->interface~randu proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~mc_fastion_pass_grid->interface~randu proc~halo_spec halo_spec proc~halo_spec->interface~randu proc~pnpa_mc pnpa_mc proc~pnpa_mc->interface~randu proc~ndmc ndmc proc~ndmc->interface~randu proc~mc_nbi mc_nbi proc~ndmc->proc~mc_nbi proc~make_diagnostic_grids make_diagnostic_grids proc~make_diagnostic_grids->interface~randu proc~mc_nbi->interface~randu proc~gyro_correction gyro_correction proc~gyro_correction->interface~randu proc~mc_nbi_cell mc_nbi_cell proc~mc_nbi_cell->interface~randu proc~npa_mc npa_mc proc~npa_mc->interface~randu proc~nbi_spec nbi_spec proc~nbi_spec->interface~randu proc~nbi_spec->proc~mc_nbi_cell proc~fida_mc fida_mc proc~fida_mc->interface~randu proc~fida_mc->proc~gyro_correction proc~mc_fastion mc_fastion proc~mc_fastion->interface~randu proc~pfida_mc pfida_mc proc~pfida_mc->interface~randu proc~pfida_mc->proc~gyro_correction proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~randu proc~fida_weights_mc->proc~gyro_correction proc~pnpa_f pnpa_f proc~pnpa_f->proc~mc_fastion_pass_grid proc~dcx dcx proc~dcx->proc~mc_halo proc~fida_f fida_f proc~fida_f->proc~gyro_correction proc~fida_f->proc~mc_fastion proc~neutron_mc neutron_mc proc~neutron_mc->proc~gyro_correction proc~npa_f npa_f proc~npa_f->proc~mc_fastion proc~halo halo proc~halo->proc~mc_halo program~fidasim fidasim program~fidasim->proc~dcx_spec program~fidasim->proc~bremsstrahlung program~fidasim->proc~halo_spec program~fidasim->proc~pnpa_mc program~fidasim->proc~ndmc program~fidasim->proc~make_diagnostic_grids program~fidasim->proc~npa_mc program~fidasim->proc~nbi_spec program~fidasim->proc~fida_mc program~fidasim->proc~pfida_mc program~fidasim->proc~fida_weights_mc program~fidasim->proc~pnpa_f program~fidasim->proc~dcx program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~npa_f program~fidasim->proc~halo proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~pfida_f pfida_f program~fidasim->proc~pfida_f proc~neutron_f->proc~gyro_correction proc~pfida_f->proc~mc_fastion_pass_grid proc~pfida_f->proc~gyro_correction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures randu_arr randu_r_arr Module Procedures private subroutine randu_arr(randomu) Generate an array of uniformally-distributed random deviates Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:) :: randomu Array of uniform random deviates private subroutine randu_r_arr(r, randomu) Generate an array of uniformally-distributed random deviates Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(out), dimension(:) :: randomu Array of uniform random deviates","tags":"","loc":"interface/randu.html","title":"randu – FIDASIM"},{"text":"public interface randn Called by interface~~randn~~CalledByGraph interface~randn randn proc~dcx_spec dcx_spec proc~dcx_spec->interface~randn proc~mc_halo mc_halo proc~mc_halo->interface~randn proc~halo_spec halo_spec proc~halo_spec->interface~randn proc~mc_nbi mc_nbi proc~mc_nbi->interface~randn proc~cold_spec cold_spec proc~cold_spec->interface~randn proc~read_equilibrium read_equilibrium proc~read_equilibrium->interface~randn proc~dcx dcx proc~dcx->proc~mc_halo proc~halo halo proc~halo->proc~mc_halo program~fidasim fidasim program~fidasim->proc~dcx_spec program~fidasim->proc~halo_spec program~fidasim->proc~cold_spec program~fidasim->proc~read_equilibrium program~fidasim->proc~dcx program~fidasim->proc~halo proc~ndmc ndmc program~fidasim->proc~ndmc proc~ndmc->proc~mc_nbi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures randn_arr randn_r_arr Module Procedures private subroutine randn_arr(randomn) Generate an array of normally-distributed random deviates Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:) :: randomn Array of normal random deviates private subroutine randn_r_arr(r, randomn) Generate an array of normally-distributed random deviates Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(out), dimension(:) :: randomn Array of normal random deviates","tags":"","loc":"interface/randn.html","title":"randn – FIDASIM"},{"text":"public interface randind_cdf Procedure for generating a random array index/subscripts Called by interface~~randind_cdf~~CalledByGraph interface~randind_cdf randind_cdf proc~get_nlaunch get_nlaunch proc~get_nlaunch->interface~randind_cdf proc~get_nlaunch_pass_grid get_nlaunch_pass_grid proc~get_nlaunch_pass_grid->interface~randind_cdf proc~pnpa_f pnpa_f proc~pnpa_f->proc~get_nlaunch_pass_grid proc~dcx dcx proc~dcx->proc~get_nlaunch proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_nlaunch proc~fida_f fida_f proc~fida_f->proc~get_nlaunch proc~npa_f npa_f proc~npa_f->proc~get_nlaunch proc~halo halo proc~halo->proc~get_nlaunch proc~pfida_f pfida_f proc~pfida_f->proc~get_nlaunch_pass_grid program~fidasim fidasim program~fidasim->proc~pnpa_f program~fidasim->proc~dcx program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~npa_f program~fidasim->proc~halo program~fidasim->proc~pfida_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures randind_r_cdf_1 randind_cdf_1 Module Procedures private subroutine randind_r_cdf_1(r, cdf, randomi) Generate an array of random indices of an 1D array distributed according to cdf Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(in), dimension(:) :: cdf 1D array of index weights integer, intent(out), dimension(:) :: randomi Random indices private subroutine randind_cdf_1(cdf, randomi) Generate an array of random indices of an 1D array distributed according to cdf Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: cdf 1D array of index weights integer, intent(out), dimension(:) :: randomi Random indices","tags":"","loc":"interface/randind_cdf.html","title":"randind_cdf – FIDASIM"},{"text":"public interface randind Procedure for generating a random array index/subscripts Called by interface~~randind~~CalledByGraph interface~randind randind proc~mc_fastion mc_fastion proc~mc_fastion->interface~randind proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~mc_fastion_pass_grid->interface~randind proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~randind proc~fida_f fida_f proc~fida_f->proc~mc_fastion proc~pnpa_f pnpa_f proc~pnpa_f->proc~mc_fastion_pass_grid proc~pfida_f pfida_f proc~pfida_f->proc~mc_fastion_pass_grid proc~npa_f npa_f proc~npa_f->proc~mc_fastion program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~pnpa_f program~fidasim->proc~pfida_f program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures randind_n randind_w_1 randind_w_2 randind_w_3 randind_w_4 randind_w_5 randind_r_n randind_r_w_1 randind_r_w_2 randind_r_w_3 randind_r_w_4 randind_r_w_5 Module Procedures private subroutine randind_n(n, randomi) Generate a array of uniformally-distributed random integers in the range [1, n] Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Largest possible value integer, intent(out), dimension(:) :: randomi Array of uniform deviates private subroutine randind_w_1(w, randomi) Generate an array of random indices of an 1D array distributed according to w Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: w 1D array of index weights integer, intent(out), dimension(:) :: randomi Random indices private subroutine randind_w_2(w, randomi) Generate an array of random subscripts of an 2D array distributed according to w Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:) :: w 2D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts private subroutine randind_w_3(w, randomi) Generate an array of random subscripts of an 3D array distributed according to w Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:,:) :: w 3D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts private subroutine randind_w_4(w, randomi) Generate an array of random subscripts of an 4D array distributed according to w Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:,:,:) :: w 4D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts private subroutine randind_w_5(w, randomi) Generate an array of random subscripts of an 5D array distributed according to w Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:,:,:,:) :: w 5D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts private subroutine randind_r_n(r, n, randomi) Generate a array of uniformally-distributed random integers in the range [1, n] Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator integer, intent(in) :: n Largest possible value integer, intent(out), dimension(:) :: randomi Array of uniform deviates private subroutine randind_r_w_1(r, w, randomi) Generate an array of random indices of an 1D array distributed according to w Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(in), dimension(:) :: w 1D array of index weights integer, intent(out), dimension(:) :: randomi Random indices private subroutine randind_r_w_2(r, w, randomi) Generate an array of random subscripts of an 2D array distributed according to w Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(in), dimension(:,:), target :: w 2D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts private subroutine randind_r_w_3(r, w, randomi) Generate an array of random subscripts of an 3D array distributed according to w Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(in), dimension(:,:,:), target :: w 3D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts private subroutine randind_r_w_4(r, w, randomi) Generate an array of random subscripts of an 4D array distributed according to w Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(in), dimension(:,:,:,:), target :: w 4D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts private subroutine randind_r_w_5(r, w, randomi) Generate an array of random subscripts of an 5D array distributed according to w Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(in), dimension(:,:,:,:,:), target :: w 5D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts","tags":"","loc":"interface/randind.html","title":"randind – FIDASIM"},{"text":"public interface sparse Creates a sparse array from a dense array Contents Module Procedures sparse_1 sparse_2 sparse_3 sparse_4 Module Procedures private subroutine sparse_1(A, SA) Routine to create a 1D sparse array from a 1D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array private subroutine sparse_2(A, SA) Routine to create a 2D sparse array from a 2D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array private subroutine sparse_3(A, SA) Routine to create a 3D sparse array from a 3D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:,:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array private subroutine sparse_4(A, SA) Routine to create a 4D sparse array from a 4D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:,:,:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array","tags":"","loc":"interface/sparse.html","title":"sparse – FIDASIM"},{"text":"public interface deriv Procedure for finding derivatives from an array Called by interface~~deriv~~CalledByGraph interface~deriv deriv proc~read_equilibrium read_equilibrium proc~read_equilibrium->interface~deriv program~fidasim fidasim program~fidasim->proc~read_equilibrium Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures deriv_1d deriv_2d deriv_3d Module Procedures private subroutine deriv_1d(x, y, yp) Uses 3 point lagrangian method to calculate the derivative of an array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x X Values real(kind=Float64), intent(in), dimension(:) :: y Y Values real(kind=Float64), intent(out), dimension(:) :: yp Derivative of Y w.r.t. X private subroutine deriv_2d(x, y, z, zxp, zyp) Uses 3 point lagrangian method to calculate the partial derivative\n of an array Z w.r.t X and Y Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x X Values real(kind=Float64), intent(in), dimension(:) :: y Y Values real(kind=Float64), intent(in), dimension(:,:) :: z Z Values real(kind=Float64), intent(out), dimension(:,:) :: zxp Derivative of Z w.r.t. X real(kind=Float64), intent(out), dimension(:,:) :: zyp Derivative of Z w.r.t. Y private subroutine deriv_3d(r, z, phi, f, frp, fzp, fphip) Uses 3 point lagrangian method to calculate the partial derivative\n of an array F w.r.t R, Z and Phi Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: r R Values real(kind=Float64), intent(in), dimension(:) :: z Z Values real(kind=Float64), intent(in), dimension(:) :: phi Phi Values real(kind=Float64), intent(in), dimension(:,:,:) :: f F Values real(kind=Float64), intent(out), dimension(:,:,:) :: frp Derivative of F w.r.t. R real(kind=Float64), intent(out), dimension(:,:,:) :: fzp Derivative of F w.r.t. Z real(kind=Float64), intent(out), dimension(:,:,:) :: fphip Derivative of F w.r.t. Phi","tags":"","loc":"interface/deriv.html","title":"deriv – FIDASIM"},{"text":"public subroutine check_compression_availability() Checks whether dataset compression is available Arguments None Calls proc~~check_compression_availability~~CallsGraph proc~check_compression_availability check_compression_availability h5zget_filter_info_f h5zget_filter_info_f proc~check_compression_availability->h5zget_filter_info_f h5close_f h5close_f proc~check_compression_availability->h5close_f h5open_f h5open_f proc~check_compression_availability->h5open_f h5zfilter_avail_f h5zfilter_avail_f proc~check_compression_availability->h5zfilter_avail_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~check_compression_availability~~CalledByGraph proc~check_compression_availability check_compression_availability program~generate_tables generate_tables program~generate_tables->proc~check_compression_availability program~fidasim fidasim program~fidasim->proc~check_compression_availability Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code check_compression_availability Source Code subroutine check_compression_availability !+ Checks whether dataset compression is available IMPLICIT NONE logical :: shuffle_avail , gzip_avail integer :: gzip_info , shuf_info , filter_info_both integer :: error call h5open_f ( error ) filter_info_both = ior ( H5Z_FILTER_ENCODE_ENABLED_F , H5Z_FILTER_DECODE_ENABLED_F ) !! Check for GZIP filter call h5zfilter_avail_f ( H5Z_FILTER_DEFLATE_F , gzip_avail , error ) call h5zget_filter_info_f ( H5Z_FILTER_DEFLATE_F , gzip_info , error ) if (. not . gzip_avail ) then print * , 'HDF5: gzip filter is not available' compress_data = . False . endif if ( filter_info_both . ne . gzip_info ) then print * , 'HDF5: gzip filter is not available for encoding and decoding' compress_data = . False . endif !! Check for SHUFFLE filter call h5zfilter_avail_f ( H5Z_FILTER_SHUFFLE_F , shuffle_avail , error ) call h5zget_filter_info_f ( H5Z_FILTER_SHUFFLE_F , shuf_info , error ) if (. not . shuffle_avail ) then print * , 'HDF5: shuffle filter is not available' compress_data = . False . endif if ( filter_info_both . ne . shuf_info ) then print * , 'HDF5: shuffle filter is not available for encoding and decoding' compress_data = . False . endif if (. not . compress_data ) then print * , 'HDF5: Compression is not available. Proceeding without compression.' endif call h5close_f ( error ) end subroutine check_compression_availability","tags":"","loc":"proc/check_compression_availability.html","title":"check_compression_availability – FIDASIM"},{"text":"public subroutine h5ltread_dataset_int_scalar_f(loc_id, dset_name, x, error) Write a scalar 32-bit integer Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(inout) :: x Data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltread_dataset_int_scalar_f~~CallsGraph proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltread_dataset_int_scalar_f~~CalledByGraph proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_f read_f proc~read_f->proc~h5ltread_dataset_int_scalar_f proc~read_distribution read_distribution proc~read_distribution->proc~h5ltread_dataset_int_scalar_f proc~read_distribution->proc~read_f proc~read_mc read_mc proc~read_distribution->proc~read_mc proc~read_mc->proc~h5ltread_dataset_int_scalar_f proc~read_nuclear_rates read_nuclear_rates proc~read_nuclear_rates->proc~h5ltread_dataset_int_scalar_f proc~read_tables read_tables proc~read_tables->proc~h5ltread_dataset_int_scalar_f proc~read_tables->proc~read_nuclear_rates proc~read_atomic_transitions read_atomic_transitions proc~read_tables->proc~read_atomic_transitions proc~read_atomic_rate read_atomic_rate proc~read_tables->proc~read_atomic_rate proc~read_atomic_cross read_atomic_cross proc~read_tables->proc~read_atomic_cross proc~read_atomic_transitions->proc~h5ltread_dataset_int_scalar_f proc~read_atomic_rate->proc~h5ltread_dataset_int_scalar_f proc~read_chords read_chords proc~read_chords->proc~h5ltread_dataset_int_scalar_f proc~read_npa read_npa proc~read_npa->proc~h5ltread_dataset_int_scalar_f proc~read_beam read_beam proc~read_beam->proc~h5ltread_dataset_int_scalar_f proc~read_atomic_cross->proc~h5ltread_dataset_int_scalar_f proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~h5ltread_dataset_int_scalar_f proc~read_neutrals read_neutrals proc~read_neutrals->proc~h5ltread_dataset_int_scalar_f program~fidasim fidasim program~fidasim->proc~read_distribution program~fidasim->proc~read_tables program~fidasim->proc~read_chords program~fidasim->proc~read_npa program~fidasim->proc~read_equilibrium program~fidasim->proc~read_neutrals Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltread_dataset_int_scalar_f Source Code subroutine h5ltread_dataset_int_scalar_f ( loc_id , dset_name , x , error ) !+ Write a scalar 32-bit integer IMPLICIT NONE integer ( HID_T ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( inout ) :: x !+ Data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HSIZE_T ), dimension ( 1 ) :: dims ( 1 ) = 1 integer , dimension ( 1 ) :: dummy call h5ltread_dataset_int_f ( loc_id , dset_name , dummy , dims , error ) x = dummy ( 1 ) end subroutine h5ltread_dataset_int_scalar_f","tags":"","loc":"proc/h5ltread_dataset_int_scalar_f.html","title":"h5ltread_dataset_int_scalar_f – FIDASIM"},{"text":"public subroutine h5ltread_dataset_double_scalar_f(loc_id, dset_name, x, error) Write a scalar 64-bit float Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create real(kind=Float64), intent(inout) :: x Data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltread_dataset_double_scalar_f~~CallsGraph proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltread_dataset_double_scalar_f~~CalledByGraph proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_atomic_cross read_atomic_cross proc~read_atomic_cross->proc~h5ltread_dataset_double_scalar_f proc~read_atomic_rate read_atomic_rate proc~read_atomic_rate->proc~h5ltread_dataset_double_scalar_f proc~read_nuclear_rates read_nuclear_rates proc~read_nuclear_rates->proc~h5ltread_dataset_double_scalar_f proc~read_beam read_beam proc~read_beam->proc~h5ltread_dataset_double_scalar_f proc~read_atomic_transitions read_atomic_transitions proc~read_atomic_transitions->proc~h5ltread_dataset_double_scalar_f proc~read_tables read_tables proc~read_tables->proc~read_atomic_cross proc~read_tables->proc~read_atomic_rate proc~read_tables->proc~read_nuclear_rates proc~read_tables->proc~read_atomic_transitions program~fidasim fidasim program~fidasim->proc~read_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltread_dataset_double_scalar_f Source Code subroutine h5ltread_dataset_double_scalar_f ( loc_id , dset_name , x , error ) !+ Write a scalar 64-bit float IMPLICIT NONE integer ( HID_T ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create real ( Float64 ), intent ( inout ) :: x !+ Data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HSIZE_T ), dimension ( 1 ) :: dims ( 1 ) = 1 real ( Float64 ), dimension ( 1 ) :: dummy call h5ltread_dataset_double_f ( loc_id , dset_name , dummy , dims , error ) x = dummy ( 1 ) end subroutine h5ltread_dataset_double_scalar_f","tags":"","loc":"proc/h5ltread_dataset_double_scalar_f.html","title":"h5ltread_dataset_double_scalar_f – FIDASIM"},{"text":"public subroutine chunk_size(elsize, dims, cdims) Arguments Type Intent Optional Attributes Name integer, intent(in) :: elsize Size of elements in bytes integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Dimensions of dataset integer(kind=HSIZE_T), intent(out), dimension(:) :: cdims Maximum allowed chunk size/dims Called by proc~~chunk_size~~CalledByGraph proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 proc~h5ltmake_compressed_dataset_int_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 proc~h5ltmake_compressed_dataset_int_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 proc~h5ltmake_compressed_dataset_int_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 proc~h5ltmake_compressed_dataset_int_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 proc~h5ltmake_compressed_dataset_int_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 proc~h5ltmake_compressed_dataset_int_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 proc~h5ltmake_compressed_dataset_int_f_5->proc~chunk_size interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_neutrals->proc~write_beam_grid proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_birth_profile->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_npa->interface~h5ltmake_compressed_dataset_int_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~write_fida_weights proc~neutron_mc neutron_mc proc~neutron_mc->proc~write_neutrons program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~write_neutrals program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_npa program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~neutron_mc proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~npa_weights->proc~write_npa_weights var panprocchunk_sizeCalledByGraph = svgPanZoom('#procchunk_sizeCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code chunk_size Source Code subroutine chunk_size ( elsize , dims , cdims ) integer , intent ( in ) :: elsize !+ Size of elements in bytes integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Dimensions of dataset integer ( HSIZE_T ), dimension (:), intent ( out ) :: cdims !+ Maximum allowed chunk size/dims real , parameter :: max_bytes = 4 * 1e9 !GigaBytes integer :: d real ( Float64 ) :: nbytes d = size ( cdims ) cdims ( 1 : d ) = dims ( 1 : d ) nbytes = elsize * product ( 1.d0 * cdims ) do while (( nbytes . gt . max_bytes ). and .( d . gt . 0 )) cdims ( d ) = max ( floor ( cdims ( d ) * max_bytes / nbytes , Int32 ), 1 ) nbytes = elsize * product ( 1.d0 * cdims ) d = d - 1 enddo end subroutine chunk_size","tags":"","loc":"proc/chunk_size.html","title":"chunk_size – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_double_f_1(loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_double_f_1~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltmake_compressed_dataset_double_f_1~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_neutrals->proc~write_beam_grid proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~write_fida_weights proc~neutron_mc neutron_mc proc~neutron_mc->proc~write_neutrons program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~write_neutrals program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_npa program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~neutron_mc proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_1CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_1CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltmake_compressed_dataset_double_f_1 Source Code subroutine h5ltmake_compressed_dataset_double_f_1 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 1 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( Float64 ), dimension ( dims ( 1 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 1 ) if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Float64 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_1","tags":"","loc":"proc/h5ltmake_compressed_dataset_double_f_1.html","title":"h5ltmake_compressed_dataset_double_f_1 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_double_f_2(loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_double_f_2~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltmake_compressed_dataset_double_f_2~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_neutrals->proc~write_beam_grid proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~write_fida_weights proc~neutron_mc neutron_mc proc~neutron_mc->proc~write_neutrons program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~write_neutrals program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_npa program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~neutron_mc proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_2CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltmake_compressed_dataset_double_f_2 Source Code subroutine h5ltmake_compressed_dataset_double_f_2 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 2 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( Float64 ), dimension ( dims ( 1 ), dims ( 2 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 2 ) if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Float64 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_2","tags":"","loc":"proc/h5ltmake_compressed_dataset_double_f_2.html","title":"h5ltmake_compressed_dataset_double_f_2 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_double_f_3(loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_double_f_3~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltmake_compressed_dataset_double_f_3~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_neutrals->proc~write_beam_grid proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~write_fida_weights proc~neutron_mc neutron_mc proc~neutron_mc->proc~write_neutrons program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~write_neutrals program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_npa program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~neutron_mc proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_3CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_3CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltmake_compressed_dataset_double_f_3 Source Code subroutine h5ltmake_compressed_dataset_double_f_3 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 3 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( Float64 ), dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 3 ) if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Float64 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_3","tags":"","loc":"proc/h5ltmake_compressed_dataset_double_f_3.html","title":"h5ltmake_compressed_dataset_double_f_3 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_double_f_4(loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_double_f_4~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltmake_compressed_dataset_double_f_4~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_neutrals->proc~write_beam_grid proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~write_fida_weights proc~neutron_mc neutron_mc proc~neutron_mc->proc~write_neutrons program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~write_neutrals program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_npa program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~neutron_mc proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_4CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_4CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltmake_compressed_dataset_double_f_4 Source Code subroutine h5ltmake_compressed_dataset_double_f_4 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 4 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( Float64 ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 4 ) if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Float64 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_4","tags":"","loc":"proc/h5ltmake_compressed_dataset_double_f_4.html","title":"h5ltmake_compressed_dataset_double_f_4 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_double_f_5(loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_double_f_5~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltmake_compressed_dataset_double_f_5~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_neutrals->proc~write_beam_grid proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~write_fida_weights proc~neutron_mc neutron_mc proc~neutron_mc->proc~write_neutrons program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~write_neutrals program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_npa program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~neutron_mc proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_5CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_5CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltmake_compressed_dataset_double_f_5 Source Code subroutine h5ltmake_compressed_dataset_double_f_5 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 5 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( Float64 ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 5 ) if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Float64 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_5","tags":"","loc":"proc/h5ltmake_compressed_dataset_double_f_5.html","title":"h5ltmake_compressed_dataset_double_f_5 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_double_f_6(loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_double_f_6~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltmake_compressed_dataset_double_f_6~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_neutrals->proc~write_beam_grid proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~write_fida_weights proc~neutron_mc neutron_mc proc~neutron_mc->proc~write_neutrons program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~write_neutrals program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_npa program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~neutron_mc proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_6CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_6CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltmake_compressed_dataset_double_f_6 Source Code subroutine h5ltmake_compressed_dataset_double_f_6 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 6 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( Float64 ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 6 ) if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Float64 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_6","tags":"","loc":"proc/h5ltmake_compressed_dataset_double_f_6.html","title":"h5ltmake_compressed_dataset_double_f_6 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_double_f_7(loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_double_f_7~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltmake_compressed_dataset_double_f_7~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_neutrals->proc~write_beam_grid proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~write_fida_weights proc~neutron_mc neutron_mc proc~neutron_mc->proc~write_neutrons program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~write_neutrals program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_npa program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~neutron_mc proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_7CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_7CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltmake_compressed_dataset_double_f_7 Source Code subroutine h5ltmake_compressed_dataset_double_f_7 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 7 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( Float64 ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 ), dims ( 7 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 7 ) if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Float64 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_7","tags":"","loc":"proc/h5ltmake_compressed_dataset_double_f_7.html","title":"h5ltmake_compressed_dataset_double_f_7 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_int_f_1(loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_int_f_1~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_1->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5sclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_1->h5ltmake_dataset_int_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_int_f_1->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_1->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltmake_compressed_dataset_int_f_1~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa var panproch5ltmake_compressed_dataset_int_f_1CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_int_f_1CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltmake_compressed_dataset_int_f_1 Source Code subroutine h5ltmake_compressed_dataset_int_f_1 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 1 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 1 ) if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Int32 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_1","tags":"","loc":"proc/h5ltmake_compressed_dataset_int_f_1.html","title":"h5ltmake_compressed_dataset_int_f_1 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_int_f_2(loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_int_f_2~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_2->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5sclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2->h5ltmake_dataset_int_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_int_f_2->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_2->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltmake_compressed_dataset_int_f_2~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa var panproch5ltmake_compressed_dataset_int_f_2CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_int_f_2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltmake_compressed_dataset_int_f_2 Source Code subroutine h5ltmake_compressed_dataset_int_f_2 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 2 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 2 ) if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Int32 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_2","tags":"","loc":"proc/h5ltmake_compressed_dataset_int_f_2.html","title":"h5ltmake_compressed_dataset_int_f_2 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_int_f_3(loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_int_f_3~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_3->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5sclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3->h5ltmake_dataset_int_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_int_f_3->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_3->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltmake_compressed_dataset_int_f_3~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa var panproch5ltmake_compressed_dataset_int_f_3CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_int_f_3CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltmake_compressed_dataset_int_f_3 Source Code subroutine h5ltmake_compressed_dataset_int_f_3 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 3 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 3 ) if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Int32 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_3","tags":"","loc":"proc/h5ltmake_compressed_dataset_int_f_3.html","title":"h5ltmake_compressed_dataset_int_f_3 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_int_f_4(loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_int_f_4~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_4->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5sclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_4->h5ltmake_dataset_int_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_int_f_4->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_4->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltmake_compressed_dataset_int_f_4~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa var panproch5ltmake_compressed_dataset_int_f_4CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_int_f_4CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltmake_compressed_dataset_int_f_4 Source Code subroutine h5ltmake_compressed_dataset_int_f_4 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 4 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 4 ) if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Int32 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_4","tags":"","loc":"proc/h5ltmake_compressed_dataset_int_f_4.html","title":"h5ltmake_compressed_dataset_int_f_4 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_int_f_5(loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_int_f_5~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_5->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5sclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_5->h5ltmake_dataset_int_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_int_f_5->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_5->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltmake_compressed_dataset_int_f_5~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa var panproch5ltmake_compressed_dataset_int_f_5CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_int_f_5CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltmake_compressed_dataset_int_f_5 Source Code subroutine h5ltmake_compressed_dataset_int_f_5 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 5 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 5 ) if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Int32 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_5","tags":"","loc":"proc/h5ltmake_compressed_dataset_int_f_5.html","title":"h5ltmake_compressed_dataset_int_f_5 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_int_f_6(loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_int_f_6~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_6->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5sclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_6->h5ltmake_dataset_int_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_int_f_6->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_6->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltmake_compressed_dataset_int_f_6~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa var panproch5ltmake_compressed_dataset_int_f_6CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_int_f_6CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltmake_compressed_dataset_int_f_6 Source Code subroutine h5ltmake_compressed_dataset_int_f_6 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 6 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 6 ) if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Int32 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_6","tags":"","loc":"proc/h5ltmake_compressed_dataset_int_f_6.html","title":"h5ltmake_compressed_dataset_int_f_6 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_int_f_7(loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_int_f_7~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_7->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5sclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_7->h5ltmake_dataset_int_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_int_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5ltmake_compressed_dataset_int_f_7~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa var panproch5ltmake_compressed_dataset_int_f_7CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_int_f_7CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code h5ltmake_compressed_dataset_int_f_7 Source Code subroutine h5ltmake_compressed_dataset_int_f_7 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 7 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 ), dims ( 7 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id integer ( HSIZE_T ) :: cdims ( 7 ) if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call chunk_size ( Int32 , dims , cdims ) call h5pset_chunk_f ( plist_id , rank , cdims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_7","tags":"","loc":"proc/h5ltmake_compressed_dataset_int_f_7.html","title":"h5ltmake_compressed_dataset_int_f_7 – FIDASIM"},{"text":"public interface h5ltmake_compressed_dataset_double_f Write a compressed datasets of 64-bit floats Calls interface~~h5ltmake_compressed_dataset_double_f~~CallsGraph interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f var paninterfaceh5ltmake_compressed_dataset_double_fCallsGraph = svgPanZoom('#interfaceh5ltmake_compressed_dataset_double_fCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~h5ltmake_compressed_dataset_double_f~~CalledByGraph interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_neutrals->proc~write_beam_grid proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~write_fida_weights proc~neutron_mc neutron_mc proc~neutron_mc->proc~write_neutrons program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bt_h_e program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bb_d_d program~fidasim fidasim program~fidasim->proc~write_neutrals program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_npa program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~neutron_mc proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~npa_weights->proc~write_npa_weights var paninterfaceh5ltmake_compressed_dataset_double_fCalledByGraph = svgPanZoom('#interfaceh5ltmake_compressed_dataset_double_fCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_7 Module Procedures public subroutine h5ltmake_compressed_dataset_double_f_1 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_2 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_3 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_4 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_5 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_6 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_7 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code","tags":"","loc":"interface/h5ltmake_compressed_dataset_double_f.html","title":"h5ltmake_compressed_dataset_double_f – FIDASIM"},{"text":"public interface h5ltmake_compressed_dataset_int_f Write a compressed dataset of 32-bit integers Calls interface~~h5ltmake_compressed_dataset_int_f~~CallsGraph interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_2->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5sclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2->h5ltmake_dataset_int_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_int_f_2->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_2->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~h5ltmake_compressed_dataset_int_f~~CalledByGraph interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_7 Module Procedures public subroutine h5ltmake_compressed_dataset_int_f_1 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_2 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_3 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_4 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_5 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_6 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_7 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code","tags":"","loc":"interface/h5ltmake_compressed_dataset_int_f.html","title":"h5ltmake_compressed_dataset_int_f – FIDASIM"},{"text":"public function p_cx_1_janev(Erel) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=1 state at energy Erel Equation H&#94;+ + H(1) \\rightarrow H(\\forall m) + H&#94;+ References Eq. 44 and Table 9 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_1_janev~~CalledByGraph proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev p_cx_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~p_cx_2->proc~p_cx_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_janevCalledByGraph = svgPanZoom('#procp_cx_1_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_1_janev Source Code function p_cx_1_janev ( Erel ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=1 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 3.2345d0 , 2.3588d2 , 2.3713d0 , & 3.8371d-2 , 3.8068d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ), parameter :: n = 1.d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_1_janev","tags":"","loc":"proc/p_cx_1_janev.html","title":"p_cx_1_janev – FIDASIM"},{"text":"public function p_cx_2_janev(Erel) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=2 state at energy Erel Equation H&#94;+ + H(2) \\rightarrow H(\\forall m) + H&#94;+ References Eq. 44 and Table 9 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_2_janev~~CalledByGraph proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev p_cx_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~p_cx_2->proc~p_cx_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_2_janevCalledByGraph = svgPanZoom('#procp_cx_2_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_2_janev Source Code function p_cx_2_janev ( Erel ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 9.2750d-1 , 6.5040d3 , 2.0699d1 , & 1.3405d-2 , 3.0842d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ), parameter :: n = 2.d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_2_janev","tags":"","loc":"proc/p_cx_2_janev.html","title":"p_cx_2_janev – FIDASIM"},{"text":"public function p_cx_3_janev(Erel) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=3 state at energy Erel Equation H&#94;+ + H(3) \\rightarrow H(\\forall m) + H&#94;+ References Eq. 44 and Table 9 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_3_janev~~CalledByGraph proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev p_cx_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~p_cx_2->proc~p_cx_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_3_janevCalledByGraph = svgPanZoom('#procp_cx_3_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_3_janev Source Code function p_cx_3_janev ( Erel ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 3.7271d-1 , 2.7645d6 , 1.4857d3 , & 1.5720d-3 , 3.0842d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ), parameter :: n = 3.d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_3_janev","tags":"","loc":"proc/p_cx_3_janev.html","title":"p_cx_3_janev – FIDASIM"},{"text":"public function p_cx_n_janev(Erel, n) result(sigma) Calculates cross section for proton-Hydrogen charge exchange interactions from the n \\geq 4 state at energy Erel Equation H&#94;+ + H(n \\geq 4) \\rightarrow H(\\forall m) + H&#94;+ References Eq. 44 and Table 9 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_n_janev~~CalledByGraph proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev p_cx_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~p_cx_2->proc~p_cx_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_n_janevCalledByGraph = svgPanZoom('#procp_cx_n_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_n_janev Source Code function p_cx_n_janev ( Erel , n ) result ( sigma ) !+Calculates cross section for proton-Hydrogen charge exchange interactions from the n \\geq 4 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n \\geq 4) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 2.1336d-1 , 1.0000d10 , 1.3426d6 , & 1.8184d-3 , 3.0842d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ) :: Ehat if ( n . lt . 4 ) then write ( * , '(a)' ) \"P_CX_N_JANEV: n cannot be less than 4\" stop endif Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_n_janev","tags":"","loc":"proc/p_cx_n_janev.html","title":"p_cx_n_janev – FIDASIM"},{"text":"public function p_cx_janev(Erel, n) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n state at energy Erel Equation H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ References Eq. 44 and Table 9 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~p_cx_janev~~CallsGraph proc~p_cx_janev p_cx_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_cx_janev~~CalledByGraph proc~p_cx_janev p_cx_janev proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~p_cx_2->proc~p_cx_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_janevCalledByGraph = svgPanZoom('#procp_cx_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_janev Source Code function p_cx_janev ( Erel , n ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the `n` state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer :: i i = min ( n , 4 ) select case ( i ) case ( 0 ) stop case ( 1 ) sigma = p_cx_1_janev ( Erel ) case ( 2 ) sigma = p_cx_2_janev ( Erel ) case ( 3 ) sigma = p_cx_3_janev ( Erel ) case DEFAULT sigma = p_cx_n_janev ( Erel , n ) end select end function p_cx_janev","tags":"","loc":"proc/p_cx_janev.html","title":"p_cx_janev – FIDASIM"},{"text":"public function aljan1(energy, pcf) result(sigma) Fit function for p_cx_1_2_janev Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: energy Relative collision energy [eV] real(kind=Float64), intent(in), dimension(:) :: pcf Fit Coefficients Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~aljan1~~CalledByGraph proc~aljan1 aljan1 proc~p_cx_1_2_janev p_cx_1_2_janev proc~p_cx_1_2_janev->proc~aljan1 proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_1_2_janev proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_1 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_3->proc~p_cx_1 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocaljan1CalledByGraph = svgPanZoom('#procaljan1CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/aljan1.html","title":"aljan1 – FIDASIM"},{"text":"public function p_cx_1_2_janev(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=2 state at energy Erel Equation H&#94;+ + H(1) \\rightarrow H(2) + H&#94;+ References Ref. 8 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~p_cx_1_2_janev~~CallsGraph proc~p_cx_1_2_janev p_cx_1_2_janev proc~aljan1 aljan1 proc~p_cx_1_2_janev->proc~aljan1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_cx_1_2_janev~~CalledByGraph proc~p_cx_1_2_janev p_cx_1_2_janev proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_1_2_janev proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_1 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_3->proc~p_cx_1 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_2_janevCalledByGraph = svgPanZoom('#procp_cx_1_2_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/p_cx_1_2_janev.html","title":"p_cx_1_2_janev – FIDASIM"},{"text":"public function p_cx_1_1_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=1 state at energy Erel Equation H&#94;+ + H(1) \\rightarrow H(1) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_1_1_adas~~CalledByGraph proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_1 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_3->proc~p_cx_1 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_1_adasCalledByGraph = svgPanZoom('#procp_cx_1_1_adasCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_1_1_adas Source Code function p_cx_1_1_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=1 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(1) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 7 ), parameter :: a = [ - 3.496092687d2 , 4.724931484d2 , & - 2.720493064d2 , 8.158564625d1 , & - 1.339790721d1 , 1.138706949d0 , & - 3.914774156d-2 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 1.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 1.0d3 fac = Erel ** ( - 0.2 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_1_1_adas","tags":"","loc":"proc/p_cx_1_1_adas.html","title":"p_cx_1_1_adas – FIDASIM"},{"text":"public function p_cx_1_2_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=2 state at energy Erel Equation H&#94;+ + H(1) \\rightarrow H(2) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_1_2_adas~~CalledByGraph proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_2 proc~p_cx_n->proc~p_cx_1 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_3->proc~p_cx_1 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_2_adasCalledByGraph = svgPanZoom('#procp_cx_1_2_adasCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_1_2_adas Source Code function p_cx_1_2_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(2) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 9 ), parameter :: a = [ - 4.036239511d3 , 6.941235312d3 , & - 5.186974866d3 , 2.194885201d3 , & - 5.765960509d2 , 9.653534186d1 , & - 1.008066138d1 , 6.010731909d-1 ,& - 1.567417031d-2 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 1.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 1.0d3 fac = Erel ** ( 0.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_1_2_adas","tags":"","loc":"proc/p_cx_1_2_adas.html","title":"p_cx_1_2_adas – FIDASIM"},{"text":"public function p_cx_1_3_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=3 state at energy Erel Equation H&#94;+ + H(1) \\rightarrow H(3) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_1_3_adas~~CalledByGraph proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_1 p_cx_1 proc~p_cx_3->proc~p_cx_1 proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3 proc~p_cx_n->proc~p_cx_1 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_3_adasCalledByGraph = svgPanZoom('#procp_cx_1_3_adasCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_1_3_adas Source Code function p_cx_1_3_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(3) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ 7.037287586d4 , - 1.479161477d5 , & 1.370120708d5 , - 7.343180122d4 , & 2.509832081d4 , - 5.674317075d3 , & 8.487767749d2 , - 8.102284612d1 , & 4.480007503d0 , - 1.093512342d-1 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 2.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 2.0d3 fac = ( Erel ** ( 1.4 )) / 2.8 endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = max ( fac * ( 1 0.d0 ** p ), 1.d-300 ) end function p_cx_1_3_adas","tags":"","loc":"proc/p_cx_1_3_adas.html","title":"p_cx_1_3_adas – FIDASIM"},{"text":"public function p_cx_1_4_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=4 state at energy Erel Equation H&#94;+ + H(1) \\rightarrow H(4) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_1_4_adas~~CalledByGraph proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~p_cx_3->proc~p_cx_1 proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_4_adasCalledByGraph = svgPanZoom('#procp_cx_1_4_adasCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_1_4_adas Source Code function p_cx_1_4_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=4 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(4) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ 6.826447557d4 , - 1.431980004d5 , & 1.323968679d5 , - 7.083995050d4 , & 2.417608863d4 , - 5.458418789d3 , & 8.154875237d2 , - 7.776012846d1 , & 4.295431731d0 , - 1.047567211d-1 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 2.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 2.0d3 fac = ( Erel ** ( 2.0 )) / 4.0 endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = max ( fac * ( 1 0.d0 ** p ), 1.d-300 ) end function p_cx_1_4_adas","tags":"","loc":"proc/p_cx_1_4_adas.html","title":"p_cx_1_4_adas – FIDASIM"},{"text":"public function p_cx_1(Erel, m_max) result(sigma) Calculates an array of cross section for proton-Hydrogen charge exchange interactions\nfrom the n=1 state to m = 1.. m_max states at energy Erel Note Cross sections are normalized to the total cross sections calculated by p_cx_janev Equation H&#94;+ + H(1) \\rightarrow H(m=1..m_{max}) + H&#94;+ References Ref. 2 atomic_tables Ref. 4 atomic_tables Ref. 8 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [ cm&#94;2 ] Calls proc~~p_cx_1~~CallsGraph proc~p_cx_1 p_cx_1 proc~p_cx_janev p_cx_janev proc~p_cx_1->proc~p_cx_janev proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1_2_janev p_cx_1_2_janev proc~p_cx_1->proc~p_cx_1_2_janev proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~aljan1 aljan1 proc~p_cx_1_2_janev->proc~aljan1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_cx_1~~CalledByGraph proc~p_cx_1 p_cx_1 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_1 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_3->proc~p_cx_1 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_1 Source Code function p_cx_1 ( Erel , m_max ) result ( sigma ) !+Calculates an array of cross section for proton-Hydrogen charge exchange interactions !+from the n=1 state to m = 1..`m_max` states at energy `Erel` !+ !+@note Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]] !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 2 [[atomic_tables(module)]] !+* Ref. 4 [[atomic_tables(module)]] !+* Ref. 8 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] integer :: i real ( Float64 ) :: norm_fac sigma = 0.d0 do i = 1 , m_max select case ( i ) case ( 1 ) if ( Erel . le . 2.0 ) then sigma ( 1 ) = p_cx_janev ( Erel , 1 ) else sigma ( 1 ) = p_cx_1_1_adas ( Erel ) endif case ( 2 ) if ( Erel . le . 2.0 ) then sigma ( 2 ) = p_cx_1_2_janev ( Erel ) else sigma ( 2 ) = p_cx_1_2_adas ( Erel ) endif case ( 3 ) sigma ( 3 ) = p_cx_1_3_adas ( Erel ) case ( 4 ) sigma ( 4 ) = p_cx_1_4_adas ( Erel ) case DEFAULT sigma ( i ) = 0.d0 end select enddo !Normalize to Janev to be consistent with other n levels (p_cx_2/3/...) norm_fac = p_cx_janev ( Erel , 1 ) / sum ( sigma ) sigma = norm_fac * sigma end function p_cx_1","tags":"","loc":"proc/p_cx_1.html","title":"p_cx_1 – FIDASIM"},{"text":"public function p_cx_2_2_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=2 state to the m=2 state at energy Erel Equation H&#94;+ + H(2) \\rightarrow H(2) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_2_2_adas~~CalledByGraph proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_2 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_2_2_adas Source Code function p_cx_2_2_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=2 state to the m=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(2) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a2s = [ - 1.896015167d6 , 4.431727330d6 , & - 4.627815357d6 , 2.843068107d6 , & - 1.137952956d6 , 3.100801094d5 , & - 5.825744660d4 , 7.452319142d3 , & - 6.212350647d2 , 3.047712749d1 , & - 6.682658463d-1 ] real ( Float64 ), dimension ( 11 ), parameter :: a2p = [ - 1.614213508d5 , 3.772469288d5 , & - 3.924736424d5 , 2.393127027d5 , & - 9.470300966d4 , 2.541276100d4 , & - 4.682860453d3 , 5.851219013d2 , & - 4.744504549d1 , 2.254460913d0 , & - 4.767235839d-2 ] real ( Float64 ), parameter :: n = 2.d0 real ( Float64 ) :: e , ee , fac , l , sigma2s , sigma2p e = Erel * 1.d3 * n ** 2.0 if ( Erel . le . 1.5d2 ) then ee = max ( e , 1.d3 ) fac = 1.d0 else ee = 1.5e5 * n ** 2.d0 fac = 2.d15 * (( e * 1.d-3 ) ** ( - 5.5 )) endif l = log10 ( ee ) sigma2s = a2s ( 1 ) + a2s ( 2 ) * l + a2s ( 3 ) * l ** 2.0 + a2s ( 4 ) * l ** 3.0 + & a2s ( 5 ) * l ** 4.0 + a2s ( 6 ) * l ** 5.0 + a2s ( 7 ) * l ** 6.0 + & a2s ( 8 ) * l ** 7.0 + a2s ( 9 ) * l ** 8.0 + a2s ( 10 ) * l ** 9.0 + a2s ( 11 ) * l ** 1 0.0 sigma2s = 1 0.d0 ** ( sigma2s ) sigma2p = a2p ( 1 ) + a2p ( 2 ) * l + a2p ( 3 ) * l ** 2.0 + a2p ( 4 ) * l ** 3.0 + & a2p ( 5 ) * l ** 4.0 + a2p ( 6 ) * l ** 5.0 + a2p ( 7 ) * l ** 6.0 + & a2p ( 8 ) * l ** 7.0 + a2p ( 9 ) * l ** 8.0 + a2p ( 10 ) * l ** 9.0 + a2p ( 11 ) * l ** 1 0.0 sigma2p = 1 0.d0 ** ( sigma2p ) sigma = fac * ( 0.25 * sigma2s + 0.75 * sigma2p ) end function p_cx_2_2_adas","tags":"","loc":"proc/p_cx_2_2_adas.html","title":"p_cx_2_2_adas – FIDASIM"},{"text":"public function p_cx_2_3_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=2 state to the m=3 state at energy Erel Equation H&#94;+ + H(2) \\rightarrow H(3) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_2_3_adas~~CalledByGraph proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_2 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_2_3_adas Source Code function p_cx_2_3_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=2 state to the m=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(3) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a2s = [ - 3.513030327d5 , 9.281116596d5 , & - 1.086843398d6 , 7.437325055d5 , & - 3.296609685d5 , 9.897503768d4 , & - 2.039707143d4 , 2.850670244d3 , & - 2.587092857d2 , 1.377382945d1 , & - 3.268306303d-1 ] real ( Float64 ), dimension ( 11 ), parameter :: a2p = [ - 1.901264631d5 , 5.124716103d5 , & - 6.101921504d5 , 4.234717934d5 , & - 1.899866398d5 , 5.764464326d4 , & - 1.199087959d4 , 1.689900512d3 , & - 1.545334374d2 , 8.285001228d0 , & - 1.978656474d-1 ] real ( Float64 ), parameter :: n = 2.d0 real ( Float64 ) :: ee , l , sigma2s , sigma2p ee = min ( max ( Erel * 1.d3 * n ** 2.d0 , 1.d3 ), 4.d6 ) l = log10 ( ee ) sigma2s = a2s ( 1 ) + a2s ( 2 ) * l + a2s ( 3 ) * l ** 2.0 + a2s ( 4 ) * l ** 3.0 + & a2s ( 5 ) * l ** 4.0 + a2s ( 6 ) * l ** 5.0 + a2s ( 7 ) * l ** 6.0 + & a2s ( 8 ) * l ** 7.0 + a2s ( 9 ) * l ** 8.0 + a2s ( 10 ) * l ** 9.0 + a2s ( 11 ) * l ** 1 0.0 sigma2s = 1 0.d0 ** ( sigma2s ) sigma2p = a2p ( 1 ) + a2p ( 2 ) * l + a2p ( 3 ) * l ** 2.0 + a2p ( 4 ) * l ** 3.0 + & a2p ( 5 ) * l ** 4.0 + a2p ( 6 ) * l ** 5.0 + a2p ( 7 ) * l ** 6.0 + & a2p ( 8 ) * l ** 7.0 + a2p ( 9 ) * l ** 8.0 + a2p ( 10 ) * l ** 9.0 + a2p ( 11 ) * l ** 1 0.0 sigma2p = 1 0.d0 ** ( sigma2p ) sigma = ( 0.25 * sigma2s + 0.75 * sigma2p ) end function p_cx_2_3_adas","tags":"","loc":"proc/p_cx_2_3_adas.html","title":"p_cx_2_3_adas – FIDASIM"},{"text":"public function p_cx_2(Erel, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n=2 state to m = 1.. m_max states at energy Erel Note Cross sections are normalized to the total cross sections calculated by p_cx_janev . Note Cross sections for the n=2 \\rightarrow m=1 states are calculated via\nequivalence principle using p_cx_1_2_adas . Note Cross Sections for m \\geq 4 are calculated by \"spreading\" their\nexpected total cross sections among the m \\geq 4 states. Equation H&#94;+ + H(2) \\rightarrow H(m=1..m_{max}) + H&#94;+ References Ref. 2 atomic_tables Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [ cm&#94;2 ] Calls proc~~p_cx_2~~CallsGraph proc~p_cx_2 p_cx_2 proc~p_cx_janev p_cx_janev proc~p_cx_2->proc~p_cx_janev proc~m_spread m_spread proc~p_cx_2->proc~m_spread proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_cx_2~~CalledByGraph proc~p_cx_2 p_cx_2 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_2 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_2 Source Code function p_cx_2 ( Erel , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen charge exchange interactions !+from the n=2 state to m = 1..`m_max` states at energy `Erel` !+ !+@note !+Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]]. !+ !+@note !+Cross sections for the n=2 \\rightarrow m=1 states are calculated via !+equivalence principle using [[p_cx_1_2_adas(proc)]]. !+ !+@note !+Cross Sections for m \\geq 4 are calculated by \"spreading\" their !+expected total cross sections among the m \\geq 4 states. !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 2 [[atomic_tables(module)]] !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] real ( Float64 ), parameter :: n2 = 4.d0 integer :: i real ( Float64 ) :: En , Em , sigma_n , norm_fac sigma = 0.d0 do i = 1 , min ( m_max , 3 ) select case ( i ) case ( 1 ) sigma ( 1 ) = p_cx_1_2_adas ( Erel * n2 ) / n2 case ( 2 ) sigma ( 2 ) = p_cx_2_2_adas ( Erel ) case ( 3 ) sigma ( 3 ) = p_cx_2_3_adas ( Erel ) end select enddo sigma_n = max ( p_cx_janev ( Erel , 2 ) - sum ( sigma ), 0.d0 ) call m_spread ( 2 , m_max , sigma_n , sigma ) norm_fac = p_cx_janev ( Erel , 2 ) / sum ( sigma ) sigma = sigma * norm_fac end function p_cx_2","tags":"","loc":"proc/p_cx_2.html","title":"p_cx_2 – FIDASIM"},{"text":"public function p_cx_3_2_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=2 state at energy Erel Equation H&#94;+ + H(3) \\rightarrow H(2) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_3_2_adas~~CalledByGraph proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_3_2_adas Source Code function p_cx_3_2_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(2) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a = [ - 1.149224555d6 , 2.750368877d6 , & - 2.942222842d6 , 1.852584954d6 , & - 7.603284323d5 , 2.125284465d5 , & - 4.097580431d4 , 5.380901722d3 , & - 4.606297192d2 , 2.321345254d1 , & - 5.230186707d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2.0 fac = 1.d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0.d0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_2_adas","tags":"","loc":"proc/p_cx_3_2_adas.html","title":"p_cx_3_2_adas – FIDASIM"},{"text":"public function p_cx_3_3_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=3 state at energy Erel Equation H&#94;+ + H(3) \\rightarrow H(3) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_3_3_adas~~CalledByGraph proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_3_3_adas Source Code function p_cx_3_3_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(3) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ - 4.302808608d4 , 9.499298161d4 , & - 9.264698488d4 , 5.236947172d4 , & - 1.890479538d4 , 4.519068626d3 , & - 7.152485009d2 , 7.227063167d1 , & - 4.230036444d0 , 1.092702525d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2 fac = 0.85d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_3_adas","tags":"","loc":"proc/p_cx_3_3_adas.html","title":"p_cx_3_3_adas – FIDASIM"},{"text":"public function p_cx_3_4_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=4 state at energy Erel Equation H&#94;+ + H(3) \\rightarrow H(4) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_3_4_adas~~CalledByGraph proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_3_4_adas Source Code function p_cx_3_4_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=4 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(4) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 9 ), parameter :: a = [ 1.705303425d4 , - 3.316878090d4 , & 2.792556433d4 , - 1.330264490d4 , & 3.921666688d3 , - 7.327555138d2 , & 8.476342861d1 , - 5.551987930d0 , & 1.577120745d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2.0 fac = 0.82d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_4_adas","tags":"","loc":"proc/p_cx_3_4_adas.html","title":"p_cx_3_4_adas – FIDASIM"},{"text":"public function p_cx_3_5_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=5 state at energy Erel Equation H&#94;+ + H(3) \\rightarrow H(5) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_3_5_adas~~CalledByGraph proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_3_5_adas Source Code function p_cx_3_5_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=5 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(5) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a = [ - 2.786268232d2 , 4.269683825d4 , & - 8.973561028d4 , 8.365732310d4 , & - 4.524587937d4 , 1.563630402d4 , & - 3.580391824d3 , 5.432527332d2 , & - 5.267599631d1 , 2.962329657d0 , & - 7.362649692d-2 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p ee = max ( min ( Erel * 1.d3 , 5.5d5 ) * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_5_adas","tags":"","loc":"proc/p_cx_3_5_adas.html","title":"p_cx_3_5_adas – FIDASIM"},{"text":"public function p_cx_3_6inf_adas(Erel) result(sigma) Calculates total cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to \\forall \\; m \\geq 6 states at energy Erel Equation H&#94;+ + H(3) \\rightarrow H(\\forall \\; m \\geq 6) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_cx_3_6inf_adas~~CalledByGraph proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_3_6inf_adas Source Code function p_cx_3_6inf_adas ( Erel ) result ( sigma ) !+Calculates total cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to \\forall \\; m \\geq 6 states at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(\\forall \\; m \\geq 6) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a = [ 7.146969470d5 , - 1.665413326d6 , & 1.735840441d6 , - 1.065792786d6 , & 4.269334710d5 , - 1.165954977d5 , & 2.198700496d4 , - 2.827160468d3 , & 2.372409350d2 , - 1.173264972d1 , & 2.596865877d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2.0 fac = 2.d20 * ( Erel * n ** 2.0 ) ** ( - 7.0 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_6inf_adas","tags":"","loc":"proc/p_cx_3_6inf_adas.html","title":"p_cx_3_6inf_adas – FIDASIM"},{"text":"public function p_cx_3(Erel, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n=3 state to m = 1.. m_max states at energy Erel Note Cross sections are normalized to the total cross sections calculated by p_cx_janev . Note Cross sections for the n=3 \\rightarrow m=1 states are calculated via\nequivalence principle using p_cx_1_3_adas . Note Cross Sections for m \\geq 6 are calculated by \"spreading\" their\nexpected total cross sections among the m \\geq 6 states. Equation H&#94;+ + H(3) \\rightarrow H(m=1..m_{max}) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [ cm&#94;2 ] Calls proc~~p_cx_3~~CallsGraph proc~p_cx_3 p_cx_3 proc~p_cx_janev p_cx_janev proc~p_cx_3->proc~p_cx_janev proc~m_spread m_spread proc~p_cx_3->proc~m_spread proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_1 p_cx_1 proc~p_cx_3->proc~p_cx_1 proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_1->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1_2_janev p_cx_1_2_janev proc~p_cx_1->proc~p_cx_1_2_janev proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_4_adas proc~aljan1 aljan1 proc~p_cx_1_2_janev->proc~aljan1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_cx_3~~CalledByGraph proc~p_cx_3 p_cx_3 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_3 Source Code function p_cx_3 ( Erel , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen charge exchange interactions !+from the n=3 state to m = 1..`m_max` states at energy `Erel` !+ !+@note !+Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]]. !+ !+@note !+Cross sections for the n=3 \\rightarrow m=1 states are calculated via !+equivalence principle using [[p_cx_1_3_adas(proc)]]. !+ !+@note !+Cross Sections for m \\geq 6 are calculated by \"spreading\" their !+expected total cross sections among the  m \\geq 6 states. !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] real ( Float64 ), parameter :: n2 = 9.d0 real ( Float64 ) :: eb , En , Em , sigma_m6 , norm_fac real ( Float64 ), dimension ( m_max ) :: sigma1 sigma = 0.d0 sigma1 = 0.d0 sigma1 = p_cx_1 ( Erel * n2 , m_max ) sigma ( 1 ) = p_cx_1_3_adas ( Erel * n2 ) / n2 sigma ( 2 ) = p_cx_3_2_adas ( Erel ) sigma ( 3 ) = p_cx_3_3_adas ( Erel ) sigma ( 4 ) = p_cx_3_4_adas ( Erel ) if ( m_max . ge . 5 ) then sigma ( 5 ) = p_cx_3_5_adas ( Erel ) endif if ( m_max . ge . 6 ) then sigma_m6 = p_cx_3_6inf_adas ( Erel ) call m_spread ( 3 , m_max , sigma_m6 , sigma ) endif norm_fac = p_cx_janev ( Erel , 3 ) / sum ( sigma ) sigma = sigma * norm_fac end function p_cx_3","tags":"","loc":"proc/p_cx_3.html","title":"p_cx_3 – FIDASIM"},{"text":"public function p_cx_n(Erel, n, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n state to m = 1.. m_max states at energy Erel Note Cross sections are normalized to the total cross sections calculated by p_cx_janev . Note Cross sections for some transitions are calculated via the equivalence principle or\nby \"spreading\" their expected total cross sections among the non-filled m states. Equation H&#94;+ + H(n) \\rightarrow H(m=1..m_{max}) + H&#94;+ References Ref. 2 atomic_tables Ref. 4 atomic_tables Ref. 8 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [ cm&#94;2 ] Calls proc~~p_cx_n~~CallsGraph proc~p_cx_n p_cx_n proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_1 proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_1->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_2_janev p_cx_1_2_janev proc~p_cx_1->proc~p_cx_1_2_janev proc~aljan1 aljan1 proc~p_cx_1_2_janev->proc~aljan1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_cx_n~~CalledByGraph proc~p_cx_n p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_n Source Code function p_cx_n ( Erel , n , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen charge exchange interactions !+from the `n` state to m = 1..`m_max` states at energy `Erel` !+ !+@note !+Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]]. !+ !+@note !+Cross sections for some transitions are calculated via the equivalence principle or !+by \"spreading\" their expected total cross sections among the non-filled m states. !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 2 [[atomic_tables(module)]] !+* Ref. 4 [[atomic_tables(module)]] !+* Ref. 8 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] real ( Float64 ), dimension ( m_max ) :: sigma2 , sigma3 real ( Float64 ) :: sigma_n , e , norm_fac sigma = 0.d0 select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_cx_1 ( Erel , m_max ) return case ( 2 ) sigma = p_cx_2 ( Erel , m_max ) return case ( 3 ) sigma = p_cx_3 ( Erel , m_max ) return case ( 4 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 1 ) = p_cx_1_4_adas ( e / ( 1.0 ** 2.0 )) * ( 1.d0 / n ) ** 2.0 sigma ( 2 ) = sigma2 ( 4 ) * ( 2.d0 / n ) ** 2.0 sigma ( 3 ) = p_cx_3_4_adas ( e / ( 3.0 ** 2.0 )) * ( 3.d0 / n ) ** 2.0 case ( 5 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 2 ) = sigma2 ( 5 ) * ( 2.d0 / n ) ** 2.0 sigma ( 3 ) = p_cx_3_5_adas ( e / ( 3.0 ** 2.0 )) * ( 3.d0 / n ) ** 2.0 case ( 6 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 2 ) = sigma2 ( 6 ) * ( 2.d0 / n ) ** 2.0 sigma3 = p_cx_3 ( e / ( 3.0 ** 2.0 ), m_max ) * ( 3.d0 / n ) ** 2.0 sigma ( 3 ) = sigma3 ( 6 ) case DEFAULT end select sigma_n = max ( p_cx_janev ( Erel , n ) - sum ( sigma ), 0.0 ) call m_spread ( n , m_max , sigma_n , sigma ) norm_fac = p_cx_janev ( Erel , n ) / sum ( sigma ) sigma = norm_fac * sigma end function p_cx_n","tags":"","loc":"proc/p_cx_n.html","title":"p_cx_n – FIDASIM"},{"text":"public function p_cx_n_m(Erel, n, m) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n state to the m state at energy Erel Equation H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ References Ref. 2 atomic_tables Ref. 4 atomic_tables Ref. 8 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~p_cx_n_m~~CallsGraph proc~p_cx_n_m p_cx_n_m proc~p_cx_n p_cx_n proc~p_cx_n_m->proc~p_cx_n proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_1 proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_1->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_2_janev p_cx_1_2_janev proc~p_cx_1->proc~p_cx_1_2_janev proc~aljan1 aljan1 proc~p_cx_1_2_janev->proc~aljan1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx_n_m Source Code function p_cx_n_m ( Erel , n , m ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the `n` state to the `m` state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ !+###References !+* Ref. 2 [[atomic_tables(module)]] !+* Ref. 4 [[atomic_tables(module)]] !+* Ref. 8 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer :: m_max = 12 real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = p_cx_n ( Erel , n , m_max ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function p_cx_n_m","tags":"","loc":"proc/p_cx_n_m.html","title":"p_cx_n_m – FIDASIM"},{"text":"public function p_cx(Erel, n_max, m_max) result(sigma) Calculates a matrix of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy Erel Equation H&#94;+ + H(n=1..n_{max}) \\rightarrow H(m=1..m_{max}) + H&#94;+ References Ref. 2 atomic_tables Ref. 4 atomic_tables Ref. 8 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of initial atomic energy levels/states integer, intent(in) :: m_max Number of final atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max,m_max) Matrix of cross sections where the subscripts correspond\n to the n \\rightarrow m transitions: p_cx[n,m] [ cm&#94;2 ] Calls proc~~p_cx~~CallsGraph proc~p_cx p_cx proc~p_cx_n p_cx_n proc~p_cx->proc~p_cx_n proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_1 proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_1->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_2_janev p_cx_1_2_janev proc~p_cx_1->proc~p_cx_1_2_janev proc~aljan1 aljan1 proc~p_cx_1_2_janev->proc~aljan1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_cx~~CalledByGraph proc~p_cx p_cx proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_cx Source Code function p_cx ( Erel , n_max , m_max ) result ( sigma ) !+Calculates a matrix of cross sections for proton-Hydrogen charge exchange interactions !+from the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n=1..n_{max}) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 2 [[atomic_tables(module)]] !+* Ref. 4 [[atomic_tables(module)]] !+* Ref. 8 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n_max !+ Number of initial atomic energy levels/states integer , intent ( in ) :: m_max !+ Number of final atomic energy levels/states real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts correspond !+ to the n \\rightarrow m transitions: p_cx[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = p_cx_n ( Erel , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function p_cx","tags":"","loc":"proc/p_cx.html","title":"p_cx – FIDASIM"},{"text":"public function p_ioniz_1_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=1 state at energy eb Equation H&#94;+ + H(1) \\rightarrow H&#94;+ + H&#94;+ + e References Eq. 40 and Table 8 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_ioniz_1_janev~~CalledByGraph proc~p_ioniz_1_janev p_ioniz_1_janev proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_1_janev proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_ioniz_1_janev Source Code function p_ioniz_1_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=1 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 40 and Table 8 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 2.0160d-3 , 3.7154d0 , & 3.9890d-2 , 3.1413d-1 , & 2.1254d0 , 6.3990d3 , & 6.1897d1 , 9.2731d3 ] !+ Fitting Parameters from Table 8 in Ref. 2 real ( Float64 ), parameter :: n2 = 1.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_1_janev","tags":"","loc":"proc/p_ioniz_1_janev.html","title":"p_ioniz_1_janev – FIDASIM"},{"text":"public function p_ioniz_2_omullane(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=2 state at energy eb Equation H&#94;+ + H(2) \\rightarrow H&#94;+ + H&#94;+ + e References Eq. 5 and Table 1 in Ref. 3 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_ioniz_2_omullane~~CalledByGraph proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_2_omullane proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_ioniz_2_omullane Source Code function p_ioniz_2_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=2 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 3.9330d-3 , 1.8188d0 , & 1.8870d-2 , 6.7489d-3 , & 1.3768d0 , 6.8852d2 , & 9.6435d1 , 5.6515d23 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 4.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_2_omullane","tags":"","loc":"proc/p_ioniz_2_omullane.html","title":"p_ioniz_2_omullane – FIDASIM"},{"text":"public function p_ioniz_3_omullane(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=3 state at energy eb Equation H&#94;+ + H(3) \\rightarrow H&#94;+ + H&#94;+ + e References Eq. 5 and Table 1 in Ref. 3 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_ioniz_3_omullane~~CalledByGraph proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_ioniz_3_omullane Source Code function p_ioniz_3_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=3 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1076d-2 , 1.6197d0 , & 6.7154d-3 , 5.1188d-3 , & 1.8549d0 , 2.3696d2 , & 7.8286d1 , 1.0926d23 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 9.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_3_omullane","tags":"","loc":"proc/p_ioniz_3_omullane.html","title":"p_ioniz_3_omullane – FIDASIM"},{"text":"public function p_ioniz_4_omullane(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=4 state at energy eb Equation H&#94;+ + H(4) \\rightarrow H&#94;+ + H&#94;+ + e References Eq. 5 and Table 1 in Ref. 3 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_ioniz_4_omullane~~CalledByGraph proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_ioniz_4_omullane Source Code function p_ioniz_4_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(4) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1033d-2 , 1.6281d0 , & 5.5955d-3 , 7.2023d-3 , & 1.7358d0 , 2.2755d2 , & 8.6339d1 , 3.9151d29 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 1 6.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_4_omullane","tags":"","loc":"proc/p_ioniz_4_omullane.html","title":"p_ioniz_4_omullane – FIDASIM"},{"text":"public function p_ioniz_5_omullane(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=5 state at energy eb Equation H&#94;+ + H(5) \\rightarrow H&#94;+ + H&#94;+ + e References Eq. 5 and Table 1 in Ref. 3 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_ioniz_5_omullane~~CalledByGraph proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_5_omullane proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_ioniz_5_omullane Source Code function p_ioniz_5_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(5) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1297d-2 , 1.8685d0 , & 1.5038d-2 , 1.1195d-1 , & 1.0538d0 , 8.6096d2 , & 8.9939d1 , 1.9249d4 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 2 5.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_5_omullane","tags":"","loc":"proc/p_ioniz_5_omullane.html","title":"p_ioniz_5_omullane – FIDASIM"},{"text":"public function p_ioniz_n(eb, n) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n th state at energy eb Equation H&#94;+ + H(n) \\rightarrow H&#94;+ + H&#94;+ + e References Eq. 40 and Table 8 in Ref. 2 for n=1 atomic_tables Eq. 5 and Table 1 in Ref. 3 for n \\geq 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~p_ioniz_n~~CallsGraph proc~p_ioniz_n p_ioniz_n proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n->proc~p_ioniz_5_omullane proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n->proc~p_ioniz_2_omullane proc~p_ioniz_1_janev p_ioniz_1_janev proc~p_ioniz_n->proc~p_ioniz_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_ioniz_n~~CalledByGraph proc~p_ioniz_n p_ioniz_n proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_ioniz_n Source Code function p_ioniz_n ( eb , n ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the `n`th state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 40 and Table 8 in Ref. 2 for n=1 [[atomic_tables(module)]] !+* Eq. 5 and Table 1 in Ref. 3 for n \\geq 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_ioniz_1_janev ( eb ) case ( 2 ) sigma = p_ioniz_2_omullane ( eb ) case ( 3 ) sigma = p_ioniz_3_omullane ( eb ) case ( 4 ) sigma = p_ioniz_4_omullane ( eb ) case DEFAULT sigma = p_ioniz_5_omullane ( eb ) * ( n / 5.d0 ) ** 4 end select end function p_ioniz_n","tags":"","loc":"proc/p_ioniz_n.html","title":"p_ioniz_n – FIDASIM"},{"text":"public function p_ioniz(eb, n_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen impact ionization interactions\nfrom the n = 1.. n_max state at energy eb Equation H&#94;+ + H(n=1..n_{max}) \\rightarrow H&#94;+ + H&#94;+ + e References Eq. 40 and Table 8 in Ref. 2 for n=1 atomic_tables Eq. 5 and Table 1 in Ref. 3 for n \\geq 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of initial atomic energy level/state Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the index refers to the n 'th state [ cm&#94;2 ] Calls proc~~p_ioniz~~CallsGraph proc~p_ioniz p_ioniz proc~p_ioniz_n p_ioniz_n proc~p_ioniz->proc~p_ioniz_n proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n->proc~p_ioniz_5_omullane proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n->proc~p_ioniz_2_omullane proc~p_ioniz_1_janev p_ioniz_1_janev proc~p_ioniz_n->proc~p_ioniz_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_ioniz~~CalledByGraph proc~p_ioniz p_ioniz proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_ioniz Source Code function p_ioniz ( eb , n_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen impact ionization interactions !+from the n = 1..`n_max` state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n=1..n_{max}) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 40 and Table 8 in Ref. 2 for n=1 [[atomic_tables(module)]] !+* Eq. 5 and Table 1 in Ref. 3 for n \\geq 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n_max !+ Number of initial atomic energy level/state real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the index refers to the `n`'th state [cm&#94;2] integer :: i do i = 1 , n_max sigma ( i ) = p_ioniz_n ( eb , i ) enddo end function p_ioniz","tags":"","loc":"proc/p_ioniz.html","title":"p_ioniz – FIDASIM"},{"text":"public function p_excit_1_2_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=2 state at energy eb Equation H&#94;+ + H(1) \\rightarrow H&#94;+ + H(2) References Eq. 29.b and Table 4 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_excit_1_2_janev~~CalledByGraph proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_2_janevCalledByGraph = svgPanZoom('#procp_excit_1_2_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_1_2_janev Source Code function p_excit_1_2_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=2 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(2)  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ 3 4.433d0 , 8.5476d0 , & 7.8501d0 , - 9.2217d0 , & 1.8020d-2 , 1.6931d0 , & 1.9422d-3 , 2.9068d0 , & 4 4.507d0 , 0.56870d0 ] !+ Fitting parameters from Table 4 in Ref. 2 sigma = 1.d-16 * a ( 1 ) * ( a ( 2 ) * exp ( - a ( 3 ) * eb ) / ( eb ** a ( 4 )) + & a ( 5 ) * exp ( - a ( 6 ) / eb ) / ( 1. + a ( 7 ) * eb ** a ( 8 )) + & exp ( - a ( 9 ) / eb ) * log ( 1. + a ( 10 ) * eb ) / eb ) end function p_excit_1_2_janev","tags":"","loc":"proc/p_excit_1_2_janev.html","title":"p_excit_1_2_janev – FIDASIM"},{"text":"public function p_excit_1_3_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=3 state at energy eb Equation H&#94;+ + H(1) \\rightarrow H&#94;+ + H(3) References Eq. 30 and Table 5 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_excit_1_3_janev~~CalledByGraph proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_3_janevCalledByGraph = svgPanZoom('#procp_excit_1_3_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_1_3_janev Source Code function p_excit_1_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=3 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(3)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 6.1950d0 , 5.5162d-3 , & 0.29114d0 , - 4.5264d0 , & 6.0311d0 , - 2.0679d0 , & 3 5.773d0 , 0.54818d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_3_janev","tags":"","loc":"proc/p_excit_1_3_janev.html","title":"p_excit_1_3_janev – FIDASIM"},{"text":"public function p_excit_1_4_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=4 state at energy eb Equation H&#94;+ + H(1) \\rightarrow H&#94;+ + H(4) References Eq. 30 and Table 5 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_excit_1_4_janev~~CalledByGraph proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_4_janevCalledByGraph = svgPanZoom('#procp_excit_1_4_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_1_4_janev Source Code function p_excit_1_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(4)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 2.0661d0 , 5.1335d-4 , & 0.28953d0 , - 2.2849d0 , & 0.11528d0 , - 4.8970d0 , & 3 4.975d0 , 0.91213d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_4_janev","tags":"","loc":"proc/p_excit_1_4_janev.html","title":"p_excit_1_4_janev – FIDASIM"},{"text":"public function p_excit_1_5_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=5 state at energy eb Equation H&#94;+ + H(1) \\rightarrow H&#94;+ + H(5) References Eq. 30 and Table 5 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_excit_1_5_janev~~CalledByGraph proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_5_janevCalledByGraph = svgPanZoom('#procp_excit_1_5_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_1_5_janev Source Code function p_excit_1_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(5)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.2449d0 , 3.0826d-4 , & 0.31063d0 , - 2.4161d0 , & 0.024664d0 , - 6.3726d0 , & 3 2.291d0 , 0.21176d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_5_janev","tags":"","loc":"proc/p_excit_1_5_janev.html","title":"p_excit_1_5_janev – FIDASIM"},{"text":"public function p_excit_1_6_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=6 state at energy eb Equation H&#94;+ + H(1) \\rightarrow H&#94;+ + H(6) References Eq. 30 and Table 5 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_excit_1_6_janev~~CalledByGraph proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_6_janevCalledByGraph = svgPanZoom('#procp_excit_1_6_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_1_6_janev Source Code function p_excit_1_6_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=6 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(6)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 0.63771d0 , 3.2949d-4 , & 0.25757d0 , - 2.2950d0 , & 0.050796d0 , - 5.5986d0 , & 3 7.174d0 , 0.39265d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_6_janev","tags":"","loc":"proc/p_excit_1_6_janev.html","title":"p_excit_1_6_janev – FIDASIM"},{"text":"public function p_excit_1_janev(eb, m_max) result(sigma) Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from\nthe n=1 state to the m=1..{m_max} state at energy eb Equation H&#94;+ + H(1) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 1 References Eq. 29.b and Table 4 in Ref. 2 for m = 2 atomic_tables Eq. 30 and Table 5 in Ref. 2 for m = 3-6 atomic_tables Eq. 31 and Table 5 in Ref. 2 for m \\gt 6 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n=1 to m [ cm&#94;2 ] Calls proc~~p_excit_1_janev~~CallsGraph proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_excit_1_janev~~CalledByGraph proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_1_janev Source Code function p_excit_1_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from !+the n=1 state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 1  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for m \\gt 6 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from n=1 to m [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = p_excit_1_2_janev ( eb ) case ( 3 ) sigma ( 3 ) = p_excit_1_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = p_excit_1_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_1_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_1_6_janev ( eb ) case DEFAULT sigma ( m ) = p_excit_1_6_janev ( eb ) * ( 6.0 / real ( m )) ** 3.0 end select enddo end function p_excit_1_janev","tags":"","loc":"proc/p_excit_1_janev.html","title":"p_excit_1_janev – FIDASIM"},{"text":"public function p_excit_2_3_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=3 state at energy eb Equation H&#94;+ + H(2) \\rightarrow H&#94;+ + H(3) References Eq. 32 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_excit_2_3_janev~~CalledByGraph proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_3_janevCalledByGraph = svgPanZoom('#procp_excit_2_3_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_2_3_janev Source Code function p_excit_2_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=3 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(3)  !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 39 4.51d0 , 0.013597d0 , & 0.16565d0 , - 0.8949d0 , & 2 1.606d0 , 0.62426d0 ] !+ Fitting parameters from Table 6 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_3_janev","tags":"","loc":"proc/p_excit_2_3_janev.html","title":"p_excit_2_3_janev – FIDASIM"},{"text":"public function p_excit_2_4_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=4 state at energy eb Equation H&#94;+ + H(2) \\rightarrow H&#94;+ + H(4) References Eq. 32 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_excit_2_4_janev~~CalledByGraph proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_4_janevCalledByGraph = svgPanZoom('#procp_excit_2_4_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_2_4_janev Source Code function p_excit_2_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(4)  !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 5 0.744d0 , 0.014398d0 , & 0.31584d0 , - 1.4799d0 , & 1 9.416d0 , 4.0262d0 ] !+ Fitting parameters from Table 6 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_4_janev","tags":"","loc":"proc/p_excit_2_4_janev.html","title":"p_excit_2_4_janev – FIDASIM"},{"text":"public function p_excit_2_5_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=5 state at energy eb Equation H&#94;+ + H(2) \\rightarrow H&#94;+ + H(5) References Eq. 32 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_excit_2_5_janev~~CalledByGraph proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_5_janevCalledByGraph = svgPanZoom('#procp_excit_2_5_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_2_5_janev Source Code function p_excit_2_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(5)  !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 1 8.264d0 , 0.013701d0 , & 0.31711d0 , - 1.4775d0 , & 1 8.973d0 , 2.9056d0 ] !+ Fitting parameters from Table 6 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_5_janev","tags":"","loc":"proc/p_excit_2_5_janev.html","title":"p_excit_2_5_janev – FIDASIM"},{"text":"public function p_excit_2_6_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=6 state at energy eb Equation H&#94;+ + H(2) \\rightarrow H&#94;+ + H(6) References Eq. 33 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~p_excit_2_6_janev~~CallsGraph proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_excit_2_6_janev~~CalledByGraph proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_6_janevCalledByGraph = svgPanZoom('#procp_excit_2_6_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_2_6_janev Source Code function p_excit_2_6_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=6 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(6)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 4.61d-1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_6_janev","tags":"","loc":"proc/p_excit_2_6_janev.html","title":"p_excit_2_6_janev – FIDASIM"},{"text":"public function p_excit_2_7_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=7 state at energy eb Equation H&#94;+ + H(2) \\rightarrow H&#94;+ + H(7) References Eq. 33 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~p_excit_2_7_janev~~CallsGraph proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_excit_2_7_janev~~CalledByGraph proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_7_janevCalledByGraph = svgPanZoom('#procp_excit_2_7_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_2_7_janev Source Code function p_excit_2_7_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=7 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(7)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 2.475d-1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_7_janev","tags":"","loc":"proc/p_excit_2_7_janev.html","title":"p_excit_2_7_janev – FIDASIM"},{"text":"public function p_excit_2_8_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=8 state at energy eb Equation H&#94;+ + H(2) \\rightarrow H&#94;+ + H(8) References Eq. 33 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~p_excit_2_8_janev~~CallsGraph proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_excit_2_8_janev~~CalledByGraph proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_8_janevCalledByGraph = svgPanZoom('#procp_excit_2_8_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_2_8_janev Source Code function p_excit_2_8_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=8 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(8)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.465d-1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_8_janev","tags":"","loc":"proc/p_excit_2_8_janev.html","title":"p_excit_2_8_janev – FIDASIM"},{"text":"public function p_excit_2_9_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=9 state at energy eb Equation H&#94;+ + H(2) \\rightarrow H&#94;+ + H(9) References Eq. 33 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~p_excit_2_9_janev~~CallsGraph proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_excit_2_9_janev~~CalledByGraph proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_9_janevCalledByGraph = svgPanZoom('#procp_excit_2_9_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_2_9_janev Source Code function p_excit_2_9_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=9 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(9)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 9.2d-2 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_9_janev","tags":"","loc":"proc/p_excit_2_9_janev.html","title":"p_excit_2_9_janev – FIDASIM"},{"text":"public function p_excit_2_10_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=10 state at energy eb Equation H&#94;+ + H(2) \\rightarrow H&#94;+ + H(10) References Eq. 33 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~p_excit_2_10_janev~~CallsGraph proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_excit_2_10_janev~~CalledByGraph proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_10_janevCalledByGraph = svgPanZoom('#procp_excit_2_10_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_2_10_janev Source Code function p_excit_2_10_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=10 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(10)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 6.05d-2 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_10_janev","tags":"","loc":"proc/p_excit_2_10_janev.html","title":"p_excit_2_10_janev – FIDASIM"},{"text":"public function p_excit_2_janev(eb, m_max) result(sigma) Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from\nthe n=2 state to the m=1..{m_max} state at energy eb Equation H&#94;+ + H(2) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 2 References Eq. 32 and Table 6 in Ref. 2 for m \\le 5 atomic_tables Eq. 33 and Table 6 in Ref. 2 for m = 6-10 atomic_tables Eq. 34 and Table 6 in Ref. 2 for m \\gt 10 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n=2 to m [ cm&#94;2 ] Calls proc~~p_excit_2_janev~~CallsGraph proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_excit_2_janev~~CalledByGraph proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_2_janev Source Code function p_excit_2_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from !+the n=2 state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 2 !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 for m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for m \\gt 10 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from n=2 to m [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = p_excit_2_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = p_excit_2_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_2_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_2_6_janev ( eb ) case ( 7 ) sigma ( 7 ) = p_excit_2_7_janev ( eb ) case ( 8 ) sigma ( 8 ) = p_excit_2_8_janev ( eb ) case ( 9 ) sigma ( 9 ) = p_excit_2_9_janev ( eb ) case ( 10 ) sigma ( 10 ) = p_excit_2_10_janev ( eb ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / real ( m )) ** 3.0 end select enddo end function p_excit_2_janev","tags":"","loc":"proc/p_excit_2_janev.html","title":"p_excit_2_janev – FIDASIM"},{"text":"public function p_excit_3_4_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=4 state at energy eb Equation H&#94;+ + H(3) \\rightarrow H&#94;+ + H(4) References Eq. 35 and Table 7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_excit_3_4_janev~~CalledByGraph proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_4_janevCalledByGraph = svgPanZoom('#procp_excit_3_4_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_3_4_janev Source Code function p_excit_3_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(4)  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 124 7.5d0 , 0.068781d0 , & 0.521176d0 , - 1.2722d0 , & 1 1.319d0 , 2.6235d0 ] !+ Fitting parameters from Table 7 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_4_janev","tags":"","loc":"proc/p_excit_3_4_janev.html","title":"p_excit_3_4_janev – FIDASIM"},{"text":"public function p_excit_3_5_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=5 state at energy eb Equation H&#94;+ + H(3) \\rightarrow H&#94;+ + H(5) References Eq. 35 and Table 7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_excit_3_5_janev~~CalledByGraph proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_5_janevCalledByGraph = svgPanZoom('#procp_excit_3_5_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_3_5_janev Source Code function p_excit_3_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(5)  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 19 0.59d0 , 0.073307d0 , & 0.54177d0 , - 1.2894d0 , & 1 1.096d0 , 2.9098d0 ] !+ Fitting parameters from Table 7 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_5_janev","tags":"","loc":"proc/p_excit_3_5_janev.html","title":"p_excit_3_5_janev – FIDASIM"},{"text":"public function p_excit_3_6_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=6 state at energy eb Equation H&#94;+ + H(3) \\rightarrow H&#94;+ + H(6) References Eq. 35 and Table 7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~p_excit_3_6_janev~~CalledByGraph proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_6_janevCalledByGraph = svgPanZoom('#procp_excit_3_6_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_3_6_janev Source Code function p_excit_3_6_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=6 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(6)  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 6 3.494d0 , 0.077953d0 , & 0.53461d0 , - 1.2881d0 , & 1 1.507d0 , 4.3417d0 ] !+ Fitting parameters from Table 7 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_6_janev","tags":"","loc":"proc/p_excit_3_6_janev.html","title":"p_excit_3_6_janev – FIDASIM"},{"text":"public function p_excit_3_7_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=7 state at energy eb Equation H&#94;+ + H(3) \\rightarrow H&#94;+ + H(7) References Eq. 36 and Table 7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~p_excit_3_7_janev~~CallsGraph proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_excit_3_7_janev~~CalledByGraph proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_7_janevCalledByGraph = svgPanZoom('#procp_excit_3_7_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_3_7_janev Source Code function p_excit_3_7_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=7 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(7)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 4.67d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_7_janev","tags":"","loc":"proc/p_excit_3_7_janev.html","title":"p_excit_3_7_janev – FIDASIM"},{"text":"public function p_excit_3_8_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=8 state at energy eb Equation H&#94;+ + H(3) \\rightarrow H&#94;+ + H(8) References Eq. 36 and Table 7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~p_excit_3_8_janev~~CallsGraph proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_excit_3_8_janev~~CalledByGraph proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_8_janevCalledByGraph = svgPanZoom('#procp_excit_3_8_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_3_8_janev Source Code function p_excit_3_8_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=8 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(8)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 2.545d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_8_janev","tags":"","loc":"proc/p_excit_3_8_janev.html","title":"p_excit_3_8_janev – FIDASIM"},{"text":"public function p_excit_3_9_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=9 state at energy eb Equation H&#94;+ + H(3) \\rightarrow H&#94;+ + H(9) References Eq. 36 and Table 7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~p_excit_3_9_janev~~CallsGraph proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_excit_3_9_janev~~CalledByGraph proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_9_janevCalledByGraph = svgPanZoom('#procp_excit_3_9_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_3_9_janev Source Code function p_excit_3_9_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=9 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(9)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.54d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_9_janev","tags":"","loc":"proc/p_excit_3_9_janev.html","title":"p_excit_3_9_janev – FIDASIM"},{"text":"public function p_excit_3_10_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=10 state at energy eb Equation H&#94;+ + H(3) \\rightarrow H&#94;+ + H(10) References Eq. 36 and Table 7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~p_excit_3_10_janev~~CallsGraph proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_excit_3_10_janev~~CalledByGraph proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_10_janevCalledByGraph = svgPanZoom('#procp_excit_3_10_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_3_10_janev Source Code function p_excit_3_10_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=10 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(10)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.0d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_10_janev","tags":"","loc":"proc/p_excit_3_10_janev.html","title":"p_excit_3_10_janev – FIDASIM"},{"text":"public function p_excit_3_janev(eb, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen impact excitation transitions from\nthe n=3 state to the m=1..{m_max} state at energy eb Equation H&#94;+ + H(3) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 3 References Eq. 35 and Table 7 in Ref. 2 for m \\le 6 atomic_tables Eq. 36 and Table 7 in Ref. 2 for m = 7-10 atomic_tables Eq. 37 and Table 7 in Ref. 2 for m \\gt 10 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n=3 to m [ cm&#94;2 ] Calls proc~~p_excit_3_janev~~CallsGraph proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_excit_3_janev~~CalledByGraph proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_3_janev Source Code function p_excit_3_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen impact excitation transitions from !+the n=3 state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 3  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 for m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for m \\gt 10 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from n=3 to m [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = 0.d0 case ( 4 ) sigma ( 4 ) = p_excit_3_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_3_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_3_6_janev ( eb ) case ( 7 ) sigma ( 7 ) = p_excit_3_7_janev ( eb ) case ( 8 ) sigma ( 8 ) = p_excit_3_8_janev ( eb ) case ( 9 ) sigma ( 9 ) = p_excit_3_9_janev ( eb ) case ( 10 ) sigma ( 10 ) = p_excit_3_10_janev ( eb ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / real ( m )) ** 3.0 end select enddo end function p_excit_3_janev","tags":"","loc":"proc/p_excit_3_janev.html","title":"p_excit_3_janev – FIDASIM"},{"text":"public function p_excit_n(eb, n, m_max) result(sigma) Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from\nthe n state to the m=1..{m_max} state at energy eb Equation H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt n References Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 atomic_tables Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 atomic_tables Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 atomic_tables Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 atomic_tables Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 atomic_tables Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 atomic_tables Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 atomic_tables Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 atomic_tables Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 atomic_tables Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n to m [ cm&#94;2 ] Calls proc~~p_excit_n~~CallsGraph proc~p_excit_n p_excit_n proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_excit_n~~CalledByGraph proc~p_excit_n p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_n Source Code function p_excit_n ( eb , n , m_max ) result ( sigma ) !+Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from !+the `n` state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 [[atomic_tables(module)]] !+* Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from `n` to m [cm&#94;2] integer :: m real ( Float64 ) :: nf , mf , Etil , s , D , A , G , L , F real ( Float64 ) :: y , zpl , zmi , C2pl , C2mi , H sigma = 0.d0 select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_excit_1_janev ( eb , m_max ) case ( 2 ) sigma = p_excit_2_janev ( eb , m_max ) case ( 3 ) sigma = p_excit_3_janev ( eb , m_max ) case DEFAULT nf = real ( n ) m_loop : do m = 1 , m_max if ( n . ge . m ) then sigma ( m ) = 0.d0 cycle m_loop endif mf = real ( m ) Etil = Eb / 2 5.0 s = ( mf - nf ) D = exp ( - 1.0 / ( nf * mf * Etil ** 2.0 )) A = 8.0 / ( 3.0 * s ) * ( mf / ( s * nf )) ** 3 * ( 0.184 - 0.04 / s ** ( 2.0 / 3.0 )) * & ( 1.0 - 0.2 * s / ( nf * mf )) ** ( 1.0 + 2.0 * s ) G = 0.5 * ( Etil * nf ** 2.0 / ( mf - 1.0 / mf ) ) ** 3. L = log ( 1.0 + 0.53 * Etil ** 2.0 * nf * ( mf - 2.0 / mf ) / ( 1.0 + 0.4 * Etil )) F = ( 1.0 - 0.3 * s * D / ( nf * mf ) ) ** ( 1.0 + 2.0 * s ) y = 1.0 / ( 1.0 - D * log ( 18 * s ) / ( 4.0 * s ) ) zpl = 2.0 / ( Etil * nf ** 2 * ( ( 2.0 - ( nf / mf ) ** 2 ) ** 0.5 + 1.0 )) zmi = 2.0 / ( Etil * nf ** 2 * ( ( 2.0 - ( nf / mf ) ** 2 ) ** 0.5 - 1.0 )) C2pl = zpl ** 2 * log ( 1.0 + 2.0 * zpl / 3.0 ) / ( 2.0 * y + 3.0 * zpl / 2.0 ) C2mi = zmi ** 2 * log ( 1.0 + 2.0 * zmi / 3.0 ) / ( 2.0 * y + 3.0 * zmi / 2.0 ) H = C2mi - C2pl sigma ( m ) = (( 8.8d-17 * n ** 4 ) / Etil ) * ( A * L * D + F * G * H ) enddo m_loop end select end function p_excit_n","tags":"","loc":"proc/p_excit_n.html","title":"p_excit_n – FIDASIM"},{"text":"public function p_excit_n_m(eb, n, m) result(sigma) Calculates the cross section for a proton-Hydrogen impact excitation transition from\nthe n state to the m state at energy eb Equation H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m), m \\gt n References Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 atomic_tables Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 atomic_tables Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 atomic_tables Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 atomic_tables Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 atomic_tables Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 atomic_tables Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 atomic_tables Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 atomic_tables Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 atomic_tables Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~p_excit_n_m~~CallsGraph proc~p_excit_n_m p_excit_n_m proc~p_excit_n p_excit_n proc~p_excit_n_m->proc~p_excit_n proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit_n_m Source Code function p_excit_n_m ( eb , n , m ) result ( sigma ) !+Calculates the cross section for a proton-Hydrogen impact excitation transition from !+the `n` state to the `m` state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m), m \\gt n  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 [[atomic_tables(module)]] !+* Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = p_excit_n ( eb , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function p_excit_n_m","tags":"","loc":"proc/p_excit_n_m.html","title":"p_excit_n_m – FIDASIM"},{"text":"public function p_excit(eb, n_max, m_max) result(sigma) Calculates a matrix of cross sections for a proton-Hydrogen impact excitation transitions\nfrom the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy eb Equation H&#94;+ + H(n=1..n_{max}) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt n References Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 atomic_tables Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 atomic_tables Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 atomic_tables Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 atomic_tables Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 atomic_tables Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 atomic_tables Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 atomic_tables Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 atomic_tables Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 atomic_tables Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of final atomic energy levels/states integer, intent(in) :: m_max Number of initial atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max,m_max) Matrix of cross sections where the subscripts correspond\n to the n \\rightarrow m transitions: p_excit[n,m] [ cm&#94;2 ] Calls proc~~p_excit~~CallsGraph proc~p_excit p_excit proc~p_excit_n p_excit_n proc~p_excit->proc~p_excit_n proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~p_excit~~CalledByGraph proc~p_excit p_excit proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code p_excit Source Code function p_excit ( eb , n_max , m_max ) result ( sigma ) !+Calculates a matrix of cross sections for a proton-Hydrogen impact excitation transitions !+from the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n=1..n_{max}) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 [[atomic_tables(module)]] !+* Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of initial atomic energy levels/states integer , intent ( in ) :: n_max !+ Number of final atomic energy levels/states real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts correspond !+ to the n \\rightarrow m transitions: p_excit[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = p_excit_n ( eb , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function p_excit","tags":"","loc":"proc/p_excit.html","title":"p_excit – FIDASIM"},{"text":"public function e_ioniz_1_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n=1 state at energy eb Equation e + H(1) \\rightarrow e + H&#94;+ + e References Eq. 14 and Table 3 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~e_ioniz_1_janev~~CalledByGraph proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n e_ioniz_n proc~e_ioniz_n->proc~e_ioniz_1_janev proc~e_ioniz e_ioniz proc~e_ioniz->proc~e_ioniz_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_ioniz_1_janev Source Code function e_ioniz_1_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the n=1 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer , parameter :: n = 1 !+ Initial atomic energy level/state real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.18450d0 , - 0.032226d0 , & - 0.034539d0 , 1.4003d0 , & - 2.8115d0 , 2.2986d0 ] !+ Fitting parameters from Table 3 in Ref. 2 real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1.d3 !keV to eV x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1.d-13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) sigma = max ( sigma , 0.d0 ) end function e_ioniz_1_janev","tags":"","loc":"proc/e_ioniz_1_janev.html","title":"e_ioniz_1_janev – FIDASIM"},{"text":"public function e_ioniz_2_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n=2 state at energy eb Equation e + H(2) \\rightarrow e + H&#94;+ + e References Eq. 14 and Table 3 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~e_ioniz_2_janev~~CalledByGraph proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n e_ioniz_n proc~e_ioniz_n->proc~e_ioniz_2_janev proc~e_ioniz e_ioniz proc~e_ioniz->proc~e_ioniz_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_ioniz_2_janev Source Code function e_ioniz_2_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the n=2 state at energy `eb` !+ !+###Equation !+ e + H(2) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer , parameter :: n = 2 !+ Initial atomic energy level/state real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.14784d0 , 0.0080871d0 , & - 0.062270d0 , 1.9414d0 , & - 2.1980d0 , 0.95894d0 ] !+ Fitting parameters from Table 3 in Ref. 2 real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1.d3 !keV to eV x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1.d-13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) sigma = max ( sigma , 0.d0 ) end function e_ioniz_2_janev","tags":"","loc":"proc/e_ioniz_2_janev.html","title":"e_ioniz_2_janev – FIDASIM"},{"text":"public function e_ioniz_3_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n=3 state at energy eb Equation e + H(3) \\rightarrow e + H&#94;+ + e References Eq. 14 and Table 3 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~e_ioniz_3_janev~~CalledByGraph proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n e_ioniz_n proc~e_ioniz_n->proc~e_ioniz_3_janev proc~e_ioniz e_ioniz proc~e_ioniz->proc~e_ioniz_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_ioniz_3_janev Source Code function e_ioniz_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the n=3 state at energy `eb` !+ !+###Equation !+ e + H(3) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer , parameter :: n = 3 !+ Initial atomic energy level/state real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.058463d0 , - 0.051272d0 , & 0.85310d0 , - 0.57014d0 , & 0.76684d0 , 0.00d0 ] !+ Fitting parameters from Table 3 in Ref. 2 real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1.d3 !keV to eV if ( e . ge . 1.5 ) then x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1.d-13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) else sigma = 0.d0 endif end function e_ioniz_3_janev","tags":"","loc":"proc/e_ioniz_3_janev.html","title":"e_ioniz_3_janev – FIDASIM"},{"text":"public function e_ioniz_n(eb, n) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n state at energy eb Equation e + H(n) \\rightarrow e + H&#94;+ + e References Eq. 14 and Table 3 in Ref. 2 atomic_tables Eq. 15-16 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~e_ioniz_n~~CallsGraph proc~e_ioniz_n e_ioniz_n proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n->proc~e_ioniz_3_janev proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n->proc~e_ioniz_2_janev proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n->proc~e_ioniz_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~e_ioniz_n~~CalledByGraph proc~e_ioniz_n e_ioniz_n proc~e_ioniz e_ioniz proc~e_ioniz->proc~e_ioniz_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_ioniz_n Source Code function e_ioniz_n ( eb , n ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the `n` state at energy `eb` !+ !+###Equation !+ e + H(n) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+* Eq. 15-16 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ) :: rn , xn , Edn2 real ( Float64 ) :: g0 , g1 , g2 , An , b , Bn select case ( n ) case ( 0 ) stop case ( 1 ) sigma = e_ioniz_1_janev ( eb ) case ( 2 ) sigma = e_ioniz_2_janev ( eb ) case ( 3 ) sigma = e_ioniz_3_janev ( eb ) case DEFAULT rn = 1.94 / n ** 1.57 Edn2 = 1 3.6 / n ** 2.0 xn = ( eb * 1.d3 ) / Edn2 g0 = 0.9935 + 0.2328 / n - 0.1296 / n ** 2.0 g1 = - ( 1.0 / n ) * ( 0.6282 - 0.5598 / n + 0.5299 / n ** 2.0 ) g2 = ( 1.0 / n ** 2.0 ) * ( 0.3887 - 1.181 / n + 1.47 / n ** 2.0 ) An = 3 2.0 * n / ( 3.0 * sqrt ( 3.0 ) * PI ) * ( g0 / 3.0 + g1 / 4.0 + g2 / 5.0 ) b = ( 1.0 / n ) * ( 4.0 - 1 8.63 / n + 3 6.24 / n ** 2.0 - 2 8.09 / n ** 3.0 ) Bn = ( 2.0 / 3.0 ) * ( n ** 2.0 ) * ( 5.0 + b ) if ( xn . gt . 1 ) then sigma = 1.76 * n ** 2 / xn * ( 1.0 - exp ( - rn * xn )) * & ( An * log ( xn ) + ( Bn - An * log ( 2.0 * n ** 2 )) * & ( 1.0 - 1.0 / xn ) ** 2 ) * 1.e-16 else sigma = 0.d0 endif end select end function e_ioniz_n","tags":"","loc":"proc/e_ioniz_n.html","title":"e_ioniz_n – FIDASIM"},{"text":"public function e_ioniz(eb, n_max) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact ionization from\nthe n=1..n_{max} states at energy eb Equation e + H(n=1..n_{max}) \\rightarrow e + H&#94;+ + e References Eq. 14 and Table 3 in Ref. 2 atomic_tables Eq. 15-16 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n_max Number of initial atomic energy levels/states to calculate Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the n'th index refers to a ionization from the n'th state [ cm&#94;2 ] Calls proc~~e_ioniz~~CallsGraph proc~e_ioniz e_ioniz proc~e_ioniz_n e_ioniz_n proc~e_ioniz->proc~e_ioniz_n proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n->proc~e_ioniz_3_janev proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n->proc~e_ioniz_2_janev proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n->proc~e_ioniz_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~e_ioniz~~CalledByGraph proc~e_ioniz e_ioniz proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_ioniz Source Code function e_ioniz ( eb , n_max ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact ionization from !+the n=1..n_{max} states at energy `eb` !+ !+###Equation !+ e + H(n=1..n_{max}) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+* Eq. 15-16 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n_max !+ Number of initial atomic energy levels/states to calculate real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the n'th index refers to a ionization from the n'th state [cm&#94;2] integer :: i do i = 1 , n_max sigma ( i ) = e_ioniz_n ( eb , i ) enddo end function e_ioniz","tags":"","loc":"proc/e_ioniz.html","title":"e_ioniz – FIDASIM"},{"text":"public function e_excit_1_2_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=2 state at energy eb Equation e + H(1) \\rightarrow e + H(2) References Eq. 4 and Table 1 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~e_excit_1_2_janev~~CalledByGraph proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e var panproce_excit_1_2_janevCalledByGraph = svgPanZoom('#proce_excit_1_2_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_excit_1_2_janev Source Code function e_excit_1_2_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=2 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(2)  !+ !+###References !+* Eq. 4 and Table 1 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 0.2d0 real ( Float64 ), parameter :: a = 0.228d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: b = 0.1865d0 !+ Fitting paramter from Table 2 in Ref. 2 real ( Float64 ), parameter :: c = 0.5025d0 !+ Fitting paramter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 6 ), parameter :: An = [ 4.4979d0 , 1.4182d0 , & - 2 0.877d0 , 4 9.735d0 , & - 4 6.249d0 , 1 7.442d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ( ecoll ) / deltaE if (( ecoll . gt . 1 0.2 ). and .( ecoll . le . 1 1.56 )) then sigma = 1.d-16 * ( a + b * ( ecoll - deltaE )) return endif if (( ecoll . ge . 1 1.56 ). and .( ecoll . le . 1 2.23 )) then sigma = 1.d-16 * c return endif if ( ecoll . ge . 1 2.23 ) then s = An ( 2 ) + An ( 3 ) / x + An ( 4 ) / x ** 2.0 + An ( 5 ) / x ** 3.0 + An ( 6 ) / x ** 4.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( An ( 1 ) * log ( x ) + s ) return endif if ( x . le . 1.0 ) then sigma = 0.0 return endif end function e_excit_1_2_janev","tags":"","loc":"proc/e_excit_1_2_janev.html","title":"e_excit_1_2_janev – FIDASIM"},{"text":"public function e_excit_1_3_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=3 state at energy eb Equation e + H(1) \\rightarrow e + H(3) References Eq. 5 and Table 2 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~e_excit_1_3_janev~~CalledByGraph proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e var panproce_excit_1_3_janevCalledByGraph = svgPanZoom('#proce_excit_1_3_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_excit_1_3_janev Source Code function e_excit_1_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=3 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(3)  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 2.09d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: alpha = 0.38277d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.75448d0 , 0.42956d0 , & - 0.58288d0 , 1.0693d0 , & 0.d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_1_3_janev","tags":"","loc":"proc/e_excit_1_3_janev.html","title":"e_excit_1_3_janev – FIDASIM"},{"text":"public function e_excit_1_4_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=4 state at energy eb Equation e + H(1) \\rightarrow e + H(4) References Eq. 5 and Table 2 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~e_excit_1_4_janev~~CalledByGraph proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e var panproce_excit_1_4_janevCalledByGraph = svgPanZoom('#proce_excit_1_4_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_excit_1_4_janev Source Code function e_excit_1_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=4 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(4)  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 2.75d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: alpha = 0.41844d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.24300d0 , 0.24846d0 , & 0.19701d0 , 0.d0 , & 0.d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_1_4_janev","tags":"","loc":"proc/e_excit_1_4_janev.html","title":"e_excit_1_4_janev – FIDASIM"},{"text":"public function e_excit_1_5_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=5 state at energy eb Equation e + H(1) \\rightarrow e + H(5) References Eq. 5 and Table 2 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~e_excit_1_5_janev~~CalledByGraph proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e var panproce_excit_1_5_janevCalledByGraph = svgPanZoom('#proce_excit_1_5_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_excit_1_5_janev Source Code function e_excit_1_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=5 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(5)  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 3.06d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: alpha = 0.45929d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.11508d0 , 0.13092d0 , & 0.23581d0 , 0.d0 , & 0.d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_1_5_janev","tags":"","loc":"proc/e_excit_1_5_janev.html","title":"e_excit_1_5_janev – FIDASIM"},{"text":"public function e_excit_f(n, m) result(fnm) Oscillator strength for a n \\rightarrow m transition due to electron-Hydrogen impact excitation References Eqs. 11-13 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Oscillator strength Called by proc~~e_excit_f~~CalledByGraph proc~e_excit_f e_excit_f proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_f proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_excit_f Source Code function e_excit_f ( n , m ) result ( fnm ) !+ Oscillator strength for a `n`\\rightarrow`m` transition due to electron-Hydrogen impact excitation !+ !+###References !+* Eqs. 11-13 in Ref. 2 [[atomic_tables(module)]] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: fnm !+ Oscillator strength real ( Float64 ), dimension ( 3 ) :: g real ( Float64 ) :: x , nf , mf , gs nf = real ( n ) mf = real ( m ) x = 1.0 - ( nf / mf ) ** 2.0 select case ( n ) case ( 1 ) g = [ 1.133 , - 0.4059 , 0.0714 ] case ( 2 ) g = [ 1.0785 , - 0.2319 , 0.02947 ] case DEFAULT g ( 1 ) = 0.9935 + 0.2328 / nf - 0.1296 / nf ** 2 g ( 2 ) =- 1.0 / nf * ( 0.6282 - 0.5598 / nf + 0.5299 / nf ** 2 ) g ( 3 ) = 1.0 / nf ** 2.0 * ( 0.3887 - 1.1810 / nf + 1.4700 / nf ** 2 ) end select gs = g ( 1 ) + g ( 2 ) / x + g ( 3 ) / x ** 2 fnm = 3 2.0 / ( 3.0 * sqrt ( 3.0 ) * PI ) * nf / mf ** 3 * 1 / x ** 3 * gs end function e_excit_f","tags":"","loc":"proc/e_excit_f.html","title":"e_excit_f – FIDASIM"},{"text":"public function e_excit_1_janev(eb, m_max) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=1..m_{max} state at energy eb Equation e + H(1) \\rightarrow e + H(m=1..m_{max}) References Eq. 5 and Table 2 in Ref. 2 atomic_tables Eqs. 6-7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=1 state to the m'th state [ cm&#94;2 ] Calls proc~~e_excit_1_janev~~CallsGraph proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_f e_excit_f proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~e_excit_1_janev~~CalledByGraph proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_excit_1_janev Source Code function e_excit_1_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=1..m_{max} state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(m=1..m_{max})  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=1 state to the m'th state [cm&#94;2] integer :: m real ( Float64 ) :: x , y , A , B , deltaE do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = e_excit_1_2_janev ( eb ) case ( 3 ) sigma ( 3 ) = e_excit_1_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = e_excit_1_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = e_excit_1_5_janev ( eb ) case DEFAULT y = 1.0 - ( 1.d0 / m ) ** 2.0 deltaE = 1 3.6 * y x = ( eb * 1.d3 ) / deltaE A = 2.0 * e_excit_f ( 1 , m ) / y B = 4.0 / ( m ** 3.0 * y ) * ( 1.0 + 4.0 / ( 3.0 * y ) - 0.603 / y ** 2.0 ) sigma ( m ) = 1.76e-16 / ( y * x ) * ( 1.0 - exp ( - 0.45 * y * x )) * & ( A * ( log ( x ) + 1.0 / ( 2.0 * x )) + ( B - A * log ( 2.0 / y )) * & ( 1.0 - 1.0 / x )) if ( x . le . 1.0 ) sigma ( m ) = 0.d0 end select enddo end function e_excit_1_janev","tags":"","loc":"proc/e_excit_1_janev.html","title":"e_excit_1_janev – FIDASIM"},{"text":"public function e_excit_2_3_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=2 state to the m=3 state at energy eb Equation e + H(2) \\rightarrow e + H(3) References Eq. 5 in Ref. 2 atomic_tables Section 2.1.1 B in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~e_excit_2_3_janev~~CalledByGraph proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_excit_2_3_janev Source Code function e_excit_2_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=2 state to the m=3 state at energy `eb` !+ !+###Equation !+ e + H(2) \\rightarrow e + H(3)  !+ !+###References !+* Eq. 5 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1.8888d0 !+ Energy difference between n=1 and n=3: !+ \\Delta E = 13.6\\left (\\frac{1}{2&#94;2} - \\frac{1}{3&#94;2}\\right ) real ( Float64 ), parameter :: alpha = 1.3196d0 !+ Fitting parameter from Section 2.1.1 B in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 3 8.906d0 , 5.2373d0 , 11 9.25d0 , & - 59 5.39d0 , 81 6.71d0 ] !+ Fitting parameters from Section 2.1.1 B in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_2_3_janev","tags":"","loc":"proc/e_excit_2_3_janev.html","title":"e_excit_2_3_janev – FIDASIM"},{"text":"public function e_excit_n(eb, n, m_max) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from\nthe n state to the m=1..m_{max} state at energy eb Equation e + H(n) \\rightarrow e + H(m=1..m_{max}), m \\gt n References Eq. 5 and Table 2 in Ref. 2 atomic_tables Eqs. 6-7 in Ref. 2 atomic_tables Section 2.1.1 B in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n \\rightarrow m state [ cm&#94;2 ] Calls proc~~e_excit_n~~CallsGraph proc~e_excit_n e_excit_n proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~e_excit_n~~CalledByGraph proc~e_excit_n e_excit_n proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_excit_n Source Code function e_excit_n ( eb , n , m_max ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from !+the `n` state to the m=1..m_{max} state at energy `eb` !+ !+###Equation !+ e + H(n) \\rightarrow e + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the `n`\\rightarrow`m` state [cm&#94;2] integer :: m real ( Float64 ) :: nf , mf real ( Float64 ) :: x , y , A , B , bn , r , deltaE nf = real ( n ) if ( n . eq . 1 ) then sigma = e_excit_1_janev ( eb , m_max ) else m_loop : do m = 1 , m_max mf = real ( m ) if ( n . ge . m ) then sigma ( m ) = 0.d0 cycle m_loop endif if (( n . eq . 2 ). and .( m . eq . 3 )) then sigma ( m ) = e_excit_2_3_janev ( eb ) else deltaE = 1 3.6 * ( 1.0 / nf ** 2 - 1.0 / mf ** 2 ) x = ( eb * 1.d3 ) / deltaE y = 1.0 - ( nf / mf ) ** 2 r = 1.94 / nf ** 1.57 A = 2.0 * nf ** 2 * e_excit_f ( n , m ) / y bn = 1.0 / nf * ( 4.0 - 1 8.63 / nf + 3 6.24 / nf ** 2 - 2 8.09 / nf ** 3 ) B = 4.0 * nf ** 4 / ( mf ** 3 * y ** 2 ) * ( 1.0 + 4.0 / ( 3.0 * y ) + bn / y ** 2.0 ) sigma ( m ) = 1.76e-16 * nf ** 2 / ( y * x ) * ( 1.0 - exp ( - r * y * x )) * & ( A * ( log ( x ) + 1.0 / ( 2.0 * x )) + ( B - A * log ( 2.0 * n ** 2.0 / y )) * & ( 1.0 - 1.0 / x )) if ( x . le . 1.0 ) sigma ( m ) = 0.d0 endif enddo m_loop endif end function e_excit_n","tags":"","loc":"proc/e_excit_n.html","title":"e_excit_n – FIDASIM"},{"text":"public function e_excit_n_m(eb, n, m) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from\nthe n \\rightarrow m state at energy eb Equation e + H(n) \\rightarrow e + H(m), m \\gt n References Eq. 5 and Table 2 in Ref. 2 atomic_tables Eqs. 6-7 in Ref. 2 atomic_tables Section 2.1.1 B in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~e_excit_n_m~~CallsGraph proc~e_excit_n_m e_excit_n_m proc~e_excit_n e_excit_n proc~e_excit_n_m->proc~e_excit_n proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_excit_n_m Source Code function e_excit_n_m ( eb , n , m ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from !+the `n` \\rightarrow `m` state at energy `eb` !+ !+###Equation !+ e + H(n) \\rightarrow e + H(m), m \\gt n  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = e_excit_n ( eb , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function e_excit_n_m","tags":"","loc":"proc/e_excit_n_m.html","title":"e_excit_n_m – FIDASIM"},{"text":"public function e_excit(eb, n_max, m_max) result(sigma) Calculates a matrix of cross section for a proton-Hydrogen impact excitation transition\nfrom the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy eb Equation e + H(n=1..n_{max}) \\rightarrow e + H(m=1..m_{max}), m \\gt n References Eq. 5 and Table 2 in Ref. 2 atomic_tables Eqs. 6-7 in Ref. 2 atomic_tables Section 2.1.1 B in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of final atomic energy levels/states integer, intent(in) :: m_max Number of initial atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max,m_max) Matrix of cross sections where the subscripts correspond\n to the n \\rightarrow m transitions: e_excit[n,m] [ cm&#94;2 ] Calls proc~~e_excit~~CallsGraph proc~e_excit e_excit proc~e_excit_n e_excit_n proc~e_excit->proc~e_excit_n proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~e_excit~~CalledByGraph proc~e_excit e_excit proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code e_excit Source Code function e_excit ( eb , n_max , m_max ) result ( sigma ) !+Calculates a matrix of cross section for a proton-Hydrogen impact excitation transition !+from the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy `eb` !+ !+###Equation !+ e + H(n=1..n_{max}) \\rightarrow e + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of initial atomic energy levels/states integer , intent ( in ) :: n_max !+ Number of final atomic energy levels/states real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts correspond !+ to the n \\rightarrow m transitions: e_excit[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n do n = 1 , 12 sigma_full ( n ,:) = e_excit_n ( eb , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function e_excit","tags":"","loc":"proc/e_excit.html","title":"e_excit – FIDASIM"},{"text":"public function B5_cx_1_adas(eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Boron ion at energy eb Equation B&#94;{5+} + H(1) \\rightarrow B&#94;{4+} + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~b5_cx_1_adas~~CalledByGraph proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code B5_cx_1_adas Source Code function B5_cx_1_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(1) \\rightarrow B&#94;{4+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 7 ), parameter :: A = [ 1.174052518d3 , - 1.793561728d3 , & 1.117522436d3 , - 3.679435571d2 , & 6.750816878d1 , - 6.542029074d0 , & 2.614113716d-1 ] real ( Float64 ) :: e , l , p e = max ( eb , 1.0 ) * 1.d3 !set lower limit to be 1keV l = log10 ( e ) if ( e . le . 4.d5 ) then p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 sigma = 1 0.d0 ** p else sigma = 0.d0 endif end function B5_cx_1_adas","tags":"","loc":"proc/b5_cx_1_adas.html","title":"B5_cx_1_adas – FIDASIM"},{"text":"public function B5_cx_2_adas(eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=2 state colliding with a fully stripped Boron ion at energy eb Equation B&#94;{5+} + H(2) \\rightarrow B&#94;{4+} + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~b5_cx_2_adas~~CalledByGraph proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code B5_cx_2_adas Source Code function B5_cx_2_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=2 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(2) \\rightarrow B&#94;{4+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: A = [ 6.603246818d1 , - 3.072575676d2 , & 5.030801019d2 , - 4.585636345d2 , & 2.568666393d2 , - 9.185150382d1 , & 2.100012584d1 , - 2.964174788d0 , & 2.346396110d-1 , - 7.943766873d-3 ] real ( Float64 ) :: e , l , p e = max ( eb * 1.d3 , 1 0.0 ) l = log10 ( e ) if ( e . le . 1.d5 ) then p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 sigma = 1 0.d0 ** p else sigma = 0.d0 endif end function B5_cx_2_adas","tags":"","loc":"proc/b5_cx_2_adas.html","title":"B5_cx_2_adas – FIDASIM"},{"text":"public function C6_cx_1_adas(eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Carbon ion at energy eb Equation C&#94;{6+} + H(1) \\rightarrow C&#94;{5+} + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~c6_cx_1_adas~~CalledByGraph proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code C6_cx_1_adas Source Code function C6_cx_1_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(1) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 7 ), parameter :: A = [ 2.007882674d2 , - 3.546893286d2 , & 2.381542403d2 , - 8.355431742d1 , & 1.617519888d1 , - 1.638152470d0 , & 6.768953863d-2 ] real ( Float64 ) :: e , l , p , m e = max ( eb * 1.d3 , 1.5d3 ) if ( eb . le . 500 ) then l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 else l = log10 ( 500 * 1.d3 ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 m = A ( 2 ) + 2 * A ( 3 ) * l + 3 * A ( 4 ) * l ** 2 + & 4 * A ( 5 ) * l ** 3 + 5 * A ( 6 ) * l ** 4 + 6 * A ( 7 ) * l ** 5 p = p + m * ( log10 ( e ) - l ) endif sigma = 1 0.d0 ** p end function C6_cx_1_adas","tags":"","loc":"proc/c6_cx_1_adas.html","title":"C6_cx_1_adas – FIDASIM"},{"text":"public function C6_cx_2_adas(eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=2 state colliding with a fully stripped Carbon ion at energy eb Equation C&#94;{6+} + H(2) \\rightarrow C&#94;{5+} + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~c6_cx_2_adas~~CalledByGraph proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code C6_cx_2_adas Source Code function C6_cx_2_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=2 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(2) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 9.151879441d5 , - 2.134573133d6 , & 2.223792624d6 , - 1.362648703d6 , & 5.438401343d5 , - 1.477110500d5 , & 2.764972254d4 , - 3.522105245d3 , & 2.921934171d2 , - 1.425552507d1 , & 3.106007048d-1 ] real ( Float64 ) :: e , l , p , m e = max ( eb * 1.d3 , 1.5d3 ) * 2.0 ** 2 if ( eb . le . 700 ) then l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 + A ( 11 ) * l ** 10 else l = log10 ( 700 * 1.d3 * 2.0 ** 2 ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 + A ( 11 ) * l ** 10 m = A ( 2 ) + 2 * A ( 3 ) * l + 3 * A ( 4 ) * l ** 2 + & 4 * A ( 5 ) * l ** 3 + 5 * A ( 6 ) * l ** 4 + 6 * A ( 7 ) * l ** 5 + & 7 * A ( 8 ) * l ** 6 + 8 * A ( 9 ) * l ** 7 + 9 * A ( 10 ) * l ** 8 + 10 * A ( 11 ) * l ** 9 p = p + m * ( log10 ( e ) - l ) endif sigma = 1 0.d0 ** p end function C6_cx_2_adas","tags":"","loc":"proc/c6_cx_2_adas.html","title":"C6_cx_2_adas – FIDASIM"},{"text":"public function C6_cx_3_adas(eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=3 state colliding with a fully stripped Carbon ion at energy eb Equation C&#94;{6+} + H(3) \\rightarrow C&#94;{5+} + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~c6_cx_3_adas~~CalledByGraph proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code C6_cx_3_adas Source Code function C6_cx_3_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=3 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(3) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 9.208877916d5 , - 2.147294379d6 , & 2.236451628d6 , - 1.370042347d6 , & 5.466461899d5 , - 1.484338816d5 , & 2.777765778d4 , - 3.537459450d3 , & 2.933884362d2 , - 1.430994136d1 , & 3.117002878d-1 ] real ( Float64 ) :: e , l , p , m e = max ( eb * 1.d3 , 1.5d3 ) * 3.0 ** 2 if ( eb . le . 300 ) then l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 + A ( 11 ) * l ** 10 else l = log10 ( 300 * 1.d3 * 3.0 ** 2 ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 + A ( 11 ) * l ** 10 m = A ( 2 ) + 2 * A ( 3 ) * l + 3 * A ( 4 ) * l ** 2 + & 4 * A ( 5 ) * l ** 3 + 5 * A ( 6 ) * l ** 4 + 6 * A ( 7 ) * l ** 5 + & 7 * A ( 8 ) * l ** 6 + 8 * A ( 9 ) * l ** 7 + 9 * A ( 10 ) * l ** 8 + 10 * A ( 11 ) * l ** 9 p = p + m * ( log10 ( e ) - l ) endif sigma = 1 0.d0 ** p end function C6_cx_3_adas","tags":"","loc":"proc/c6_cx_3_adas.html","title":"C6_cx_3_adas – FIDASIM"},{"text":"public function Aq_cx_n_adas(eb, q, n) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Note Returns 0 if ADAS cross sections are not available for given inputs Equation A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~aq_cx_n_adas~~CallsGraph proc~aq_cx_n_adas Aq_cx_n_adas proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_cx_n_adas~~CalledByGraph proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_cx_n_adas Source Code function Aq_cx_n_adas ( eb , q , n ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+@note Returns 0 if ADAS cross sections are not available for given inputs !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] sigma = 0.d0 select case ( q ) case ( 5 ) if ( n . eq . 1 ) sigma = B5_cx_1_adas ( eb ) if ( n . eq . 2 ) sigma = B5_cx_2_adas ( eb ) case ( 6 ) if ( n . eq . 1 ) sigma = C6_cx_1_adas ( eb ) if ( n . eq . 2 ) sigma = C6_cx_2_adas ( eb ) if ( n . eq . 3 ) sigma = C6_cx_3_adas ( eb ) case DEFAULT sigma = 0.d0 end select end function Aq_cx_n_adas","tags":"","loc":"proc/aq_cx_n_adas.html","title":"Aq_cx_n_adas – FIDASIM"},{"text":"public function B5_cx_1_janev(eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Boron ion at energy eb Equation B&#94;{5+} + H(1) \\rightarrow B&#94;{4+} + H&#94;+ References Page 166 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~b5_cx_1_janev~~CalledByGraph proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_janev proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocb5_cx_1_janevCalledByGraph = svgPanZoom('#procb5_cx_1_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code B5_cx_1_janev Source Code function B5_cx_1_janev ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(1) \\rightarrow B&#94;{4+} + H&#94;+  !+ !+###References !+* Page 166 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 3 1.226d0 , 1.1442d0 , & 4.8372d-8 , 3.0961d-10 , & 4.7205d0 , 6.2844d-7 , & 3.1297d0 , 0.12556d0 , & 0.30098d0 , 5.9607d-2 , & - 0.57923d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ** A ( 8 )) / & ( 1.0 + A ( 3 ) * eb ** 2 + A ( 4 ) * eb ** A ( 5 ) + & A ( 6 ) * eb ** A ( 7 )) + A ( 9 ) * exp ( - A ( 10 ) * eb ) / eb ** A ( 11 )) end function B5_cx_1_janev","tags":"","loc":"proc/b5_cx_1_janev.html","title":"B5_cx_1_janev – FIDASIM"},{"text":"public function C6_cx_1_janev(eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Carbon ion at energy eb Equation C&#94;{6+} + H(1) \\rightarrow C&#94;{5+} + H&#94;+ References Page 168 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~c6_cx_1_janev~~CalledByGraph proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_janev proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocc6_cx_1_janevCalledByGraph = svgPanZoom('#procc6_cx_1_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code C6_cx_1_janev Source Code function C6_cx_1_janev ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(1) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Page 168 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 41 8.18d0 , 2.1585d0 , & 3.4808d-4 , 5.3333d-9 , & 4.6556d0 , 0.33755d0 , & 0.81736d0 , 0.27874d0 , & 1.8003d-6 , 7.1033d-2 , & 0.53261d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ** A ( 8 )) / & ( 1.0 + A ( 3 ) * eb ** 2 + A ( 4 ) * eb ** A ( 5 ) + & A ( 6 ) * eb ** A ( 7 )) + A ( 9 ) * exp ( - A ( 10 ) * eb ) / eb ** A ( 11 )) end function C6_cx_1_janev","tags":"","loc":"proc/c6_cx_1_janev.html","title":"C6_cx_1_janev – FIDASIM"},{"text":"public function Aq_cx_n_janev(eb, q, n) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Equation A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3 References Page 166 in Ref. 5 atomic_tables Page 168 in Ref. 5 atomic_tables Page 174 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~aq_cx_n_janev~~CallsGraph proc~aq_cx_n_janev Aq_cx_n_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_cx_n_janev~~CalledByGraph proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_janev proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_cx_n_janev Source Code function Aq_cx_n_janev ( eb , q , n ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Page 166 in Ref. 5 [[atomic_tables(module)]] !+* Page 168 in Ref. 5 [[atomic_tables(module)]] !+* Page 174 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.507d5 real ( Float64 ), parameter :: B = 1.974d-5 real ( Float64 ) :: etil , nf , qf nf = real ( n ) qf = real ( q ) if (( n . eq . 1 ). and .( q . eq . 5 )) then sigma = B5_cx_1_janev ( eb ) return endif if (( n . eq . 1 ). and .( q . eq . 6 )) then sigma = C6_cx_1_janev ( eb ) return endif if ( n . le . 1 ) then sigma = 0.d0 return endif etil = eb * ( nf ** 2.0 ) / ( qf ** 0.5 ) sigma = qf * nf ** 4 * 7.04d-16 * A / ( etil ** 3.5 * ( 1.0 + B * etil ** 2 )) * & ( 1.0 - exp ( - 2.0 * etil ** 3.5 * ( 1.0 + B * etil ** 2 ) / ( 3.0 * A ))) end function Aq_cx_n_janev","tags":"","loc":"proc/aq_cx_n_janev.html","title":"Aq_cx_n_janev – FIDASIM"},{"text":"public function Aq_cx_n(eb, q, n) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Note Uses ADAS(Ref. 4) cross sections if available else uses Janev (Ref. 5) cross sections Equation A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3 References Ref. 4 atomic_tables Page 166 in Ref. 5 atomic_tables Page 168 in Ref. 5 atomic_tables Page 174 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~aq_cx_n~~CallsGraph proc~aq_cx_n Aq_cx_n proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n->proc~aq_cx_n_janev proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n->proc~aq_cx_n_adas proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_cx_n~~CalledByGraph proc~aq_cx_n Aq_cx_n proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_cx_n Source Code function Aq_cx_n ( eb , q , n ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses ADAS(Ref. 4) cross sections if available else uses Janev (Ref. 5) cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] !+* Page 166 in Ref. 5 [[atomic_tables(module)]] !+* Page 168 in Ref. 5 [[atomic_tables(module)]] !+* Page 174 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] sigma = Aq_cx_n_adas ( eb , q , n ) if ( sigma . eq . 0.d0 ) then sigma = Aq_cx_n_janev ( eb , q , n ) endif end function Aq_cx_n","tags":"","loc":"proc/aq_cx_n.html","title":"Aq_cx_n – FIDASIM"},{"text":"public function Aq_cx(eb, q, n_max) result(sigma) Calculates an array of total charge exchange cross sections for a Neutral Hydrogen atom\nin the n=1...n_max states colliding with a ion with charge q at energy eb Note Uses ADAS(Ref. 4) cross sections if available else uses Janev (Ref. 5) cross sections Equation A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3 References Ref. 4 atomic_tables Page 174 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n_max Number of initial atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the n'th index refers to a charge exchange from the n'th state [ cm&#94;2 ] Calls proc~~aq_cx~~CallsGraph proc~aq_cx Aq_cx proc~aq_cx_n Aq_cx_n proc~aq_cx->proc~aq_cx_n proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n->proc~aq_cx_n_janev proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n->proc~aq_cx_n_adas proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_cx~~CalledByGraph proc~aq_cx Aq_cx proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_cx Source Code function Aq_cx ( eb , q , n_max ) result ( sigma ) !+ Calculates an array of total charge exchange cross sections for a Neutral Hydrogen atom !+in the n=1...n_max states colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses ADAS(Ref. 4) cross sections if available else uses Janev (Ref. 5) cross sections !+ !+###Equation !+ A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] !+* Page 174 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n_max !+ Number of initial atomic energy levels/states real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the n'th index refers to a charge exchange from the n'th state [cm&#94;2] integer :: n do n = 1 , n_max sigma ( n ) = Aq_cx_n ( eb , q , n ) enddo end function Aq_cx","tags":"","loc":"proc/aq_cx.html","title":"Aq_cx – FIDASIM"},{"text":"public function B5_ioniz_1_janev(eb) result(sigma) Calculates the total ionization cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Boron ion at energy eb Equation B&#94;{5+} + H(1) \\rightarrow B&#94;{5+} + H&#94;+ + e References Page 152 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~b5_ioniz_1_janev~~CalledByGraph proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~aq_ioniz Aq_ioniz proc~aq_ioniz->proc~aq_ioniz_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code B5_ioniz_1_janev Source Code function B5_ioniz_1_janev ( eb ) result ( sigma ) !+ Calculates the total ionization cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(1) \\rightarrow B&#94;{5+} + H&#94;+ + e  !+ !+###References !+* Page 152 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: A = [ 35 1.52d0 , 23 3.63d0 , & 3.2952d3 , 5.3787d-6 , & 1.8834d-2 , - 2.2064d0 , & 7.2074d0 , - 3.78664d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ) * log ( 1 + A ( 3 ) * eb ) / eb & + A ( 4 ) * exp ( - A ( 5 ) * eb ) / (( eb ** A ( 6 )) + A ( 7 ) * ( eb ** A ( 8 )))) end function B5_ioniz_1_janev","tags":"","loc":"proc/b5_ioniz_1_janev.html","title":"B5_ioniz_1_janev – FIDASIM"},{"text":"public function C6_ioniz_1_janev(eb) result(sigma) Calculates the total ionization cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Carbon ion at energy eb Equation C&#94;{6+} + H(1) \\rightarrow C&#94;{6+} + H&#94;+ + e References Page 154 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called by proc~~c6_ioniz_1_janev~~CalledByGraph proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz_n->proc~c6_ioniz_1_janev proc~aq_ioniz Aq_ioniz proc~aq_ioniz->proc~aq_ioniz_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code C6_ioniz_1_janev Source Code function C6_ioniz_1_janev ( eb ) result ( sigma ) !+ Calculates the total ionization cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(1) \\rightarrow C&#94;{6+} + H&#94;+ + e  !+ !+###References !+* Page 154 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: A = [ 43 8.36d0 , 32 7.10d0 , & 1.4444d5 , 3.5212d-3 , & 8.3031d-3 , - 0.63731d0 , & 1.9116d4 , - 3.1003d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ) * log ( 1 + A ( 3 ) * eb ) / eb & + A ( 4 ) * exp ( - A ( 5 ) * eb ) / (( eb ** A ( 6 )) + A ( 7 ) * ( eb ** A ( 8 )))) end function C6_ioniz_1_janev","tags":"","loc":"proc/c6_ioniz_1_janev.html","title":"C6_ioniz_1_janev – FIDASIM"},{"text":"public function Aq_ioniz_n_janev(eb, q, n) result(sigma) Calculates the generic total ionization cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Equation A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H&#94;+ + e, n \\gt 1, q \\gt 3 References Page 160 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~aq_ioniz_n_janev~~CalledByGraph proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz_n->proc~aq_ioniz_n_janev proc~aq_ioniz Aq_ioniz proc~aq_ioniz->proc~aq_ioniz_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_ioniz_n_janev Source Code function Aq_ioniz_n_janev ( eb , q , n ) result ( sigma ) !+ Calculates the generic total ionization cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H&#94;+ + e, n \\gt 1, q \\gt 3  !+ !+###References !+* Page 160 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: M = 0.283d0 real ( Float64 ), parameter :: B = 4.04d0 real ( Float64 ), parameter :: c = 13 7.d0 real ( Float64 ), parameter :: g = 0.662d0 real ( Float64 ), parameter :: lambda = 0.76d0 real ( Float64 ) :: nf , qf , u , v , sigma_b nf = real ( n ) qf = real ( q ) v = sqrt ( eb / 2 5. ) u = nf * v sigma_b = 3.52d-16 * ( nf ** 4 ) * ( qf ** 2 ) / ( u ** 2 ) * & ( M * ( log (( u ** 2 ) / ( c ** 2 - u ** 2 )) - ( u ** 2 ) / ( c ** 2 )) + B - g / u ** 2 ) sigma_b = max ( sigma_b , 0.d0 ) sigma = exp ( - lambda * qf / u ** 2 ) * sigma_b end function Aq_ioniz_n_janev","tags":"","loc":"proc/aq_ioniz_n_janev.html","title":"Aq_ioniz_n_janev – FIDASIM"},{"text":"public function Aq_ioniz_n(eb, q, n) result(sigma) Calculates the total ionization cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Note Uses specialized cross sections if available else uses generic cross sections Equation A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3 References Page 152 in Ref. 5 atomic_tables Page 154 in Ref. 5 atomic_tables Page 160 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~aq_ioniz_n~~CallsGraph proc~aq_ioniz_n Aq_ioniz_n proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n->proc~aq_ioniz_n_janev proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n->proc~c6_ioniz_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_ioniz_n~~CalledByGraph proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz Aq_ioniz proc~aq_ioniz->proc~aq_ioniz_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_ioniz_n Source Code function Aq_ioniz_n ( eb , q , n ) result ( sigma ) !+ Calculates the total ionization cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Page 152 in Ref. 5 [[atomic_tables(module)]] !+* Page 154 in Ref. 5 [[atomic_tables(module)]] !+* Page 160 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] if (( q . eq . 5 ). and .( n . eq . 1 )) then sigma = B5_ioniz_1_janev ( eb ) return endif if (( q . eq . 6 ). and .( n . eq . 1 )) then sigma = C6_ioniz_1_janev ( eb ) return endif sigma = Aq_ioniz_n_janev ( eb , q , n ) end function Aq_ioniz_n","tags":"","loc":"proc/aq_ioniz_n.html","title":"Aq_ioniz_n – FIDASIM"},{"text":"public function Aq_ioniz(eb, q, n_max) result(sigma) Calculates an array of total ionization cross sections for a Neutral Hydrogen atom\nin the n=1...n_max states colliding with a ion with charge q at energy eb Note Uses specialized cross sections if available else uses generic cross sections Equation A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3 References Page 152 in Ref. 5 atomic_tables Page 154 in Ref. 5 atomic_tables Page 160 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n_max Number of initial states n to calculate Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the n'th index refers to a ionization from the n'th state [ cm&#94;2 ] Calls proc~~aq_ioniz~~CallsGraph proc~aq_ioniz Aq_ioniz proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz->proc~aq_ioniz_n proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n->proc~aq_ioniz_n_janev proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n->proc~c6_ioniz_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_ioniz~~CalledByGraph proc~aq_ioniz Aq_ioniz proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_ioniz Source Code function Aq_ioniz ( eb , q , n_max ) result ( sigma ) !+ Calculates an array of total ionization cross sections for a Neutral Hydrogen atom !+in the n=1...n_max states colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Page 152 in Ref. 5 [[atomic_tables(module)]] !+* Page 154 in Ref. 5 [[atomic_tables(module)]] !+* Page 160 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n_max !+ Number of initial states n to calculate real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the n'th index refers to a ionization from the n'th state [cm&#94;2] integer :: n do n = 1 , n_max sigma ( n ) = Aq_ioniz_n ( eb , q , n ) enddo end function Aq_ioniz","tags":"","loc":"proc/aq_ioniz.html","title":"Aq_ioniz – FIDASIM"},{"text":"public function Aq_excit_1_2_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=2 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(2), q \\gt 4 References Page 132 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~aq_excit_1_2_janev~~CalledByGraph proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_1_2_janevCalledByGraph = svgPanZoom('#procaq_excit_1_2_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_1_2_janev Source Code function Aq_excit_1_2_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=2 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(2), q \\gt 4  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 3 8.738d0 , 3 7.033d0 , & 0.39862d0 , 7.7582d-5 , & 0.25402d0 , - 2.7418d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_2_janev","tags":"","loc":"proc/aq_excit_1_2_janev.html","title":"Aq_excit_1_2_janev – FIDASIM"},{"text":"public function Aq_excit_1_3_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=3 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(3), q \\gt 4 References Page 134 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~aq_excit_1_3_janev~~CalledByGraph proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_1_3_janevCalledByGraph = svgPanZoom('#procaq_excit_1_3_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_1_3_janev Source Code function Aq_excit_1_3_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=3 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(3), q \\gt 4  !+ !+###References !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 4.3619d0 , 5 7.451d0 , & 2 1.001d0 , 2.3292d-4 , & 0.083130d0 , - 2.2364d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_3_janev","tags":"","loc":"proc/aq_excit_1_3_janev.html","title":"Aq_excit_1_3_janev – FIDASIM"},{"text":"public function Aq_excit_1_4_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=4 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(4), q \\gt 4 References Page 134 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~aq_excit_1_4_janev~~CalledByGraph proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_1_4_janevCalledByGraph = svgPanZoom('#procaq_excit_1_4_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_1_4_janev Source Code function Aq_excit_1_4_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=4 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(4), q \\gt 4  !+ !+###References !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 1.3730d0 , 6 0.710d0 , & 3 1.797d0 , 2.0207d-4 , & 0.082513d0 , - 2.3055d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_4_janev","tags":"","loc":"proc/aq_excit_1_4_janev.html","title":"Aq_excit_1_4_janev – FIDASIM"},{"text":"public function Aq_excit_1_5_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=5 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(5), q \\gt 4 References Page 136 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~aq_excit_1_5_janev~~CalledByGraph proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_1_5_janevCalledByGraph = svgPanZoom('#procaq_excit_1_5_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_1_5_janev Source Code function Aq_excit_1_5_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=5 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(5), q \\gt 4  !+ !+###References !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.56565d0 , 6 7.333d0 , & 5 5.290d0 , 2.1595d-4 , & 0.081624d0 , - 2.1971d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_5_janev","tags":"","loc":"proc/aq_excit_1_5_janev.html","title":"Aq_excit_1_5_janev – FIDASIM"},{"text":"public function Aq_excit_1_janev(eb, q, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4 References Page 132 in Ref. 5 atomic_tables Page 134 in Ref. 5 atomic_tables Page 136 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=1 state to the m'th state [ cm&#94;2 ] Calls proc~~aq_excit_1_janev~~CallsGraph proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_excit_1_janev~~CalledByGraph proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_1_janev Source Code function Aq_excit_1_janev ( eb , q , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=1 state to the m'th state [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = Aq_excit_1_2_janev ( eb , q ) case ( 3 ) sigma ( 3 ) = Aq_excit_1_3_janev ( eb , q ) case ( 4 ) sigma ( 4 ) = Aq_excit_1_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_1_5_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 5 ) * ( 5.0 / m ) ** 3.0 end select enddo end function Aq_excit_1_janev","tags":"","loc":"proc/aq_excit_1_janev.html","title":"Aq_excit_1_janev – FIDASIM"},{"text":"public function Aq_excit_2_3_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=3 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(3), q \\gt 3 References Page 138 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~aq_excit_2_3_janev~~CalledByGraph proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_3_janevCalledByGraph = svgPanZoom('#procaq_excit_2_3_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_2_3_janev Source Code function Aq_excit_2_3_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=3 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(3), q \\gt 3  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 35 8.03d0 , 2 5.283d0 , & 1.4726d0 , 0.014398d0 , & 0.12207d0 , - 0.86210d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_3_janev","tags":"","loc":"proc/aq_excit_2_3_janev.html","title":"Aq_excit_2_3_janev – FIDASIM"},{"text":"public function Aq_excit_2_4_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=4 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(4), q \\gt 3 References Page 138 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~aq_excit_2_4_janev~~CalledByGraph proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_4_janevCalledByGraph = svgPanZoom('#procaq_excit_2_4_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_2_4_janev Source Code function Aq_excit_2_4_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=4 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(4), q \\gt 3  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 5 0.744d0 , 1 9.416d0 , & 4.0262d0 , 0.014398d0 , & 0.31584d0 , - 1.4799d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_4_janev","tags":"","loc":"proc/aq_excit_2_4_janev.html","title":"Aq_excit_2_4_janev – FIDASIM"},{"text":"public function Aq_excit_2_5_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=5 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(5), q \\gt 3 References Page 138 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~aq_excit_2_5_janev~~CalledByGraph proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_5_janevCalledByGraph = svgPanZoom('#procaq_excit_2_5_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_2_5_janev Source Code function Aq_excit_2_5_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=5 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(5), q \\gt 3  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 1 8.264d0 , 1 8.973d0 , & 2.9056d0 , 0.013701d0 , & 0.31711d0 , - 1.4775d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_5_janev","tags":"","loc":"proc/aq_excit_2_5_janev.html","title":"Aq_excit_2_5_janev – FIDASIM"},{"text":"public function Aq_excit_2_6_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=6 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(6), q \\gt 3 References Page 140 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~aq_excit_2_6_janev~~CallsGraph proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_excit_2_6_janev~~CalledByGraph proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_6_janevCalledByGraph = svgPanZoom('#procaq_excit_2_6_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_2_6_janev Source Code function Aq_excit_2_6_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=6 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(6), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.4610d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_6_janev","tags":"","loc":"proc/aq_excit_2_6_janev.html","title":"Aq_excit_2_6_janev – FIDASIM"},{"text":"public function Aq_excit_2_7_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=7 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(7), q \\gt 3 References Page 140 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~aq_excit_2_7_janev~~CallsGraph proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_excit_2_7_janev~~CalledByGraph proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_7_janevCalledByGraph = svgPanZoom('#procaq_excit_2_7_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_2_7_janev Source Code function Aq_excit_2_7_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=7 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(7), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.2475d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_7_janev","tags":"","loc":"proc/aq_excit_2_7_janev.html","title":"Aq_excit_2_7_janev – FIDASIM"},{"text":"public function Aq_excit_2_8_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=8 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(8), q \\gt 3 References Page 140 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~aq_excit_2_8_janev~~CallsGraph proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_excit_2_8_janev~~CalledByGraph proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_8_janevCalledByGraph = svgPanZoom('#procaq_excit_2_8_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_2_8_janev Source Code function Aq_excit_2_8_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=8 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(8), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.1465d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_8_janev","tags":"","loc":"proc/aq_excit_2_8_janev.html","title":"Aq_excit_2_8_janev – FIDASIM"},{"text":"public function Aq_excit_2_9_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=9 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(9), q \\gt 3 References Page 140 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~aq_excit_2_9_janev~~CallsGraph proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_excit_2_9_janev~~CalledByGraph proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_9_janevCalledByGraph = svgPanZoom('#procaq_excit_2_9_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_2_9_janev Source Code function Aq_excit_2_9_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=9 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(9), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.092d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_9_janev","tags":"","loc":"proc/aq_excit_2_9_janev.html","title":"Aq_excit_2_9_janev – FIDASIM"},{"text":"public function Aq_excit_2_10_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=10 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(10), q \\gt 3 References Page 140 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~aq_excit_2_10_janev~~CallsGraph proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_excit_2_10_janev~~CalledByGraph proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_10_janevCalledByGraph = svgPanZoom('#procaq_excit_2_10_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_2_10_janev Source Code function Aq_excit_2_10_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=10 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(10), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.0605d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_10_janev","tags":"","loc":"proc/aq_excit_2_10_janev.html","title":"Aq_excit_2_10_janev – FIDASIM"},{"text":"public function Aq_excit_2_janev(eb, q, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4, m \\gt n References Page 138 in Ref. 5 atomic_tables Page 140 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=2 state to the m'th state [ cm&#94;2 ] Calls proc~~aq_excit_2_janev~~CallsGraph proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_excit_2_janev~~CalledByGraph proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_2_janev Source Code function Aq_excit_2_janev ( eb , q , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4, m \\gt n  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=2 state to the m'th state [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = Aq_excit_2_3_janev ( eb , q ) case ( 4 ) sigma ( 4 ) = Aq_excit_2_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_2_5_janev ( eb , q ) case ( 6 ) sigma ( 6 ) = Aq_excit_2_6_janev ( eb , q ) case ( 7 ) sigma ( 7 ) = Aq_excit_2_7_janev ( eb , q ) case ( 8 ) sigma ( 8 ) = Aq_excit_2_8_janev ( eb , q ) case ( 9 ) sigma ( 9 ) = Aq_excit_2_9_janev ( eb , q ) case ( 10 ) sigma ( 10 ) = Aq_excit_2_10_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / m ) ** 3.0 end select enddo end function Aq_excit_2_janev","tags":"","loc":"proc/aq_excit_2_janev.html","title":"Aq_excit_2_janev – FIDASIM"},{"text":"public function Aq_excit_3_4_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=4 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(4), q \\gt 3 References Page 142 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~aq_excit_3_4_janev~~CalledByGraph proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_4_janevCalledByGraph = svgPanZoom('#procaq_excit_3_4_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_3_4_janev Source Code function Aq_excit_3_4_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=4 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(4), q \\gt 3  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 124 7.5d0 , 1 1.319d0 , & 2.6235d0 , 0.068781d0 , & 0.521176d0 , - 1.2722d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_4_janev","tags":"","loc":"proc/aq_excit_3_4_janev.html","title":"Aq_excit_3_4_janev – FIDASIM"},{"text":"public function Aq_excit_3_5_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=5 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(5), q \\gt 3 References Page 142 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~aq_excit_3_5_janev~~CalledByGraph proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_5_janevCalledByGraph = svgPanZoom('#procaq_excit_3_5_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_3_5_janev Source Code function Aq_excit_3_5_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=5 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(5), q \\gt 3  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 19 0.59d0 , 1 1.096d0 , & 2.9098d0 , 0.073307d0 , & 0.54177d0 , - 1.2894d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_5_janev","tags":"","loc":"proc/aq_excit_3_5_janev.html","title":"Aq_excit_3_5_janev – FIDASIM"},{"text":"public function Aq_excit_3_6_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=6 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(6), q \\gt 3 References Page 142 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~aq_excit_3_6_janev~~CalledByGraph proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_6_janevCalledByGraph = svgPanZoom('#procaq_excit_3_6_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_3_6_janev Source Code function Aq_excit_3_6_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=6 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(6), q \\gt 3  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 6 3.494d0 , 1 1.507d0 , & 4.3417d0 , 0.077953d0 , & 0.53461d0 , - 1.2881d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_6_janev","tags":"","loc":"proc/aq_excit_3_6_janev.html","title":"Aq_excit_3_6_janev – FIDASIM"},{"text":"public function Aq_excit_3_7_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=7 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(7), q \\gt 3 References Page 144 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~aq_excit_3_7_janev~~CallsGraph proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_excit_3_7_janev~~CalledByGraph proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_7_janevCalledByGraph = svgPanZoom('#procaq_excit_3_7_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_3_7_janev Source Code function Aq_excit_3_7_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=7 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(7), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.4670d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_7_janev","tags":"","loc":"proc/aq_excit_3_7_janev.html","title":"Aq_excit_3_7_janev – FIDASIM"},{"text":"public function Aq_excit_3_8_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=8 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(8), q \\gt 3 References Page 144 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~aq_excit_3_8_janev~~CallsGraph proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_excit_3_8_janev~~CalledByGraph proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_8_janevCalledByGraph = svgPanZoom('#procaq_excit_3_8_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_3_8_janev Source Code function Aq_excit_3_8_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=8 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(8), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.2545d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_8_janev","tags":"","loc":"proc/aq_excit_3_8_janev.html","title":"Aq_excit_3_8_janev – FIDASIM"},{"text":"public function Aq_excit_3_9_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=9 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(9), q \\gt 3 References Page 144 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~aq_excit_3_9_janev~~CallsGraph proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_excit_3_9_janev~~CalledByGraph proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_9_janevCalledByGraph = svgPanZoom('#procaq_excit_3_9_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_3_9_janev Source Code function Aq_excit_3_9_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=9 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(9), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.1540d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_9_janev","tags":"","loc":"proc/aq_excit_3_9_janev.html","title":"Aq_excit_3_9_janev – FIDASIM"},{"text":"public function Aq_excit_3_10_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=10 state due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(10), q \\gt 3 References Page 144 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~aq_excit_3_10_janev~~CallsGraph proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_excit_3_10_janev~~CalledByGraph proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_10_janevCalledByGraph = svgPanZoom('#procaq_excit_3_10_janevCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_3_10_janev Source Code function Aq_excit_3_10_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=10 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(10), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.1d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_10_janev","tags":"","loc":"proc/aq_excit_3_10_janev.html","title":"Aq_excit_3_10_janev – FIDASIM"},{"text":"public function Aq_excit_3_janev(eb, q, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4, m \\gt n References Page 142 in Ref. 5 atomic_tables Page 144 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=3 state to the m'th state [ cm&#94;2 ] Calls proc~~aq_excit_3_janev~~CallsGraph proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_excit_3_janev~~CalledByGraph proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_3_janev Source Code function Aq_excit_3_janev ( eb , q , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4, m \\gt n  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=3 state to the m'th state [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = 0.d0 case ( 4 ) sigma ( 4 ) = Aq_excit_3_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_3_5_janev ( eb , q ) case ( 6 ) sigma ( 6 ) = Aq_excit_3_6_janev ( eb , q ) case ( 7 ) sigma ( 7 ) = Aq_excit_3_7_janev ( eb , q ) case ( 8 ) sigma ( 8 ) = Aq_excit_3_8_janev ( eb , q ) case ( 9 ) sigma ( 9 ) = Aq_excit_3_9_janev ( eb , q ) case ( 10 ) sigma ( 10 ) = Aq_excit_3_10_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / m ) ** 3.0 end select enddo end function Aq_excit_3_janev","tags":"","loc":"proc/aq_excit_3_janev.html","title":"Aq_excit_3_janev – FIDASIM"},{"text":"public function Aq_excit_n_janev(eb, q, n, m_max) result(sigma) Calculates an array of the generic excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Equation A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n, n \\gt 3 References Page 146 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n state to the m'th state [ cm&#94;2 ] Called by proc~~aq_excit_n_janev~~CalledByGraph proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_n_janev Source Code function Aq_excit_n_janev ( eb , q , n , m_max ) result ( sigma ) !+Calculates an array of the generic excitation cross sections for a neutral Hydrogen atom transitioning from !+the `n` state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n, n \\gt 3  !+ !+###References !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the `n` state to the m'th state [cm&#94;2] integer :: m real ( Float64 ) :: nf , mf , qf , etil , hi , s real ( Float64 ) :: D , A , G , L , F , H , y , zpl , zmi , C2pl , C2mi nf = real ( n ) qf = real ( q ) sigma = 0.d0 m_loop : do m = 1 , m_max mf = real ( m ) if ( n . ge . m ) then sigma ( m ) = 0.d0 cycle m_loop endif etil = eb / ( 2 5.0 * qf ) hi = 2.0 ** ( 0.322 * ( 1.0 - sqrt ( 2.0 / qf ))) s = ( mf - nf ) D = exp ( - 1.0 / ( nf * mf * etil ** 2 )) A = 8.0 / ( 3.0 * s ) * ( mf / ( s * nf )) ** 3 * ( 0.184 - 0.04 / s ** ( 2.0 / 3.0 )) * & ( 1.0 - 0.2 * s / ( nf * mf )) ** ( 1.0 + 2.0 * s ) G = 0.5 * ( etil * nf ** 2.0 / ( mf - 1.0 / mf )) ** 3.0 L = log ( 1.0 + 0.53 * etil ** 2.0 * nf * ( mf - 2.0 / mf ) / ( 1.0 + 0.4 * etil )) F = ( 1.0 - 0.3 * s * D / ( nf * mf )) ** ( 1.0 + 2.0 * s ) y = 1.0 / ( 1.0 - D * log ( 18 * s ) / ( 4.0 * s )) zpl = 2.0 / ( etil * nf ** 2 * ( sqrt ( 2.0 - nf ** 2 / mf ** 2 ) + 1.0 )) zmi = 2.0 / ( etil * nf ** 2 * ( sqrt ( 2.0 - nf ** 2 / mf ** 2 ) - 1.0 )) C2pl = zpl ** 2 * log ( 1.0 + 2.0 * zpl / 3.0 ) / ( 2.0 * y + 3.0 * zpl / 2.0 ) C2mi = zmi ** 2 * log ( 1.0 + 2.0 * zmi / 3.0 ) / ( 2.0 * y + 3.0 * zmi / 2.0 ) H = C2mi - C2pl sigma ( m ) = q * hi * 8.86e-17 * nf ** 4 / etil * ( A * D * L + F * G * H ) enddo m_loop end function Aq_excit_n_janev","tags":"","loc":"proc/aq_excit_n_janev.html","title":"Aq_excit_n_janev – FIDASIM"},{"text":"public function Aq_excit_n(eb, q, n, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Note Uses specialized cross sections if available else uses generic cross sections Equation A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n, n \\gt 3 References Page 132 in Ref. 5 atomic_tables Page 134 in Ref. 5 atomic_tables Page 136 in Ref. 5 atomic_tables Page 138 in Ref. 5 atomic_tables Page 140 in Ref. 5 atomic_tables Page 142 in Ref. 5 atomic_tables Page 142 in Ref. 5 atomic_tables Page 144 in Ref. 5 atomic_tables Page 146 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n state to the m'th state [ cm&#94;2 ] Calls proc~~aq_excit_n~~CallsGraph proc~aq_excit_n Aq_excit_n proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_excit_n~~CalledByGraph proc~aq_excit_n Aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_n Source Code function Aq_excit_n ( eb , q , n , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the `n` state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n, n \\gt 3  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the `n` state to the m'th state [cm&#94;2] select case ( n ) case ( 0 ) stop case ( 1 ) sigma = Aq_excit_1_janev ( eb , q , m_max ) case ( 2 ) sigma = Aq_excit_2_janev ( eb , q , m_max ) case ( 3 ) sigma = Aq_excit_3_janev ( eb , q , m_max ) case DEFAULT sigma = Aq_excit_n_janev ( eb , q , n , m_max ) end select end function Aq_excit_n","tags":"","loc":"proc/aq_excit_n.html","title":"Aq_excit_n – FIDASIM"},{"text":"public function Aq_excit_n_m(eb, q, n, m) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n \\rightarrow m state due to a collision an ion with charge q at energy eb Note Uses specialized cross sections if available else uses generic cross sections Equation A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m), q \\gt 3, m \\gt n References Page 132 in Ref. 5 atomic_tables Page 134 in Ref. 5 atomic_tables Page 136 in Ref. 5 atomic_tables Page 138 in Ref. 5 atomic_tables Page 140 in Ref. 5 atomic_tables Page 142 in Ref. 5 atomic_tables Page 142 in Ref. 5 atomic_tables Page 144 in Ref. 5 atomic_tables Page 146 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Calls proc~~aq_excit_n_m~~CallsGraph proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n Aq_excit_n proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit_n_m Source Code function Aq_excit_n_m ( eb , q , n , m ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the `n`\\rightarrow`m` state due to a collision an ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m), q \\gt 3, m \\gt n  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = Aq_excit_n ( eb , q , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function Aq_excit_n_m","tags":"","loc":"proc/aq_excit_n_m.html","title":"Aq_excit_n_m – FIDASIM"},{"text":"public function Aq_excit(eb, q, n_max, m_max) result(sigma) Calculates an matrix of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=1.. n_max state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Note Uses specialized cross sections if available else uses generic cross sections Equation A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n References Page 132 in Ref. 5 atomic_tables Page 134 in Ref. 5 atomic_tables Page 136 in Ref. 5 atomic_tables Page 138 in Ref. 5 atomic_tables Page 140 in Ref. 5 atomic_tables Page 142 in Ref. 5 atomic_tables Page 142 in Ref. 5 atomic_tables Page 144 in Ref. 5 atomic_tables Page 146 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n_max Number of n states to calculate integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(n_max, m_max) Matrix of cross sections where the subscripts refers to\nan excitation from the n state to the m'th state: Aq_excit[n,m] [ cm&#94;2 ] Calls proc~~aq_excit~~CallsGraph proc~aq_excit Aq_excit proc~aq_excit_n Aq_excit_n proc~aq_excit->proc~aq_excit_n proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~aq_excit~~CalledByGraph proc~aq_excit Aq_excit proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code Aq_excit Source Code function Aq_excit ( eb , q , n_max , m_max ) result ( sigma ) !+Calculates an matrix of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=1..`n_max` state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n_max !+ Number of n states to calculate integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts refers to !+an excitation from the `n` state to the m'th state: Aq_excit[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = Aq_excit_n ( eb , q , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function Aq_excit","tags":"","loc":"proc/aq_excit.html","title":"Aq_excit – FIDASIM"},{"text":"public function d_d_fusion_t(eb) result(sigma) Calculates total cross section at a given Deuterium energy, eb ,\nfor the Tritium branch of Deuterium-Deutrium nuclear reactions Equation D + D \\rightarrow T(1.01 MeV) + p(3.02 MeV) (50%) References Equations 8-9 Table IV in Ref. 7 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Deuterium energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~d_d_fusion_t~~CalledByGraph proc~d_d_fusion_t d_d_fusion_t proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->proc~d_d_fusion_t program~generate_tables generate_tables program~generate_tables->proc~write_bb_d_d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code d_d_fusion_t Source Code function d_d_fusion_t ( eb ) result ( sigma ) !+Calculates total cross section at a given Deuterium energy, `eb`, !+for the Tritium branch of Deuterium-Deutrium nuclear reactions !+ !+###Equation !+ D + D \\rightarrow T(1.01 MeV) + p(3.02 MeV) (50%) !+ !+###References !+* Equations 8-9 !+* Table IV in Ref. 7 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Deuterium energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 5 ), parameter :: A = [ 5.5576d4 , 2.1054d2 , & - 3.2638d-2 , 1.4987d-6 , & 1.8181d-10 ] real ( Float64 ), dimension ( 4 ), parameter :: B = [ 0.d0 , 0.d0 , 0.d0 , 0.d0 ] real ( Float64 ), parameter :: Bg = 3 1.3970 real ( Float64 ) :: S , E E = min ( max ( eb , 0.5 ), 500 0.0 ) S = ( A ( 1 ) + E * ( A ( 2 ) + E * ( A ( 3 ) + E * ( A ( 4 ) + E * A ( 5 ))))) / & ( 1 + E * ( B ( 1 ) + E * ( B ( 2 ) + E * ( B ( 3 ) + E * B ( 4 ))))) sigma = ( 1.0d-27 ) * ( S / ( E * exp ( Bg / sqrt ( E )))) end function d_d_fusion_t","tags":"","loc":"proc/d_d_fusion_t.html","title":"d_d_fusion_t – FIDASIM"},{"text":"public function d_d_fusion_he(eb) result(sigma) Calculates total cross section at a given deuterium energy, eb ,\nfor the Helium-3 branch of Deuterium-Deutrium nuclear reactions Equation D + D \\rightarrow He&#94;3(0.82 MeV) + n(2.45 MeV) (50%) References Equations 8-9 Table IV in Ref. 7 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Deuterium energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~d_d_fusion_he~~CalledByGraph proc~d_d_fusion_he d_d_fusion_he proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->proc~d_d_fusion_he program~generate_tables generate_tables program~generate_tables->proc~write_bb_d_d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code d_d_fusion_he Source Code function d_d_fusion_he ( eb ) result ( sigma ) !+Calculates total cross section at a given deuterium energy, `eb`, !+for the Helium-3 branch of Deuterium-Deutrium nuclear reactions !+ !+###Equation !+ D + D \\rightarrow He&#94;3(0.82 MeV) + n(2.45 MeV) (50%) !+ !+###References !+* Equations 8-9 !+* Table IV in Ref. 7 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Deuterium energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 5 ), parameter :: A = [ 5.3701d4 , 3.3027d2 , & - 1.2706d-1 , 2.9327d-5 , & - 2.5151d-9 ] real ( Float64 ), dimension ( 4 ), parameter :: B = [ 0.d0 , 0.d0 , 0.d0 , 0.d0 ] real ( Float64 ), parameter :: Bg = 3 1.3970 real ( Float64 ) :: S , E E = min ( max ( eb , 0.5 ), 490 0.0 ) S = ( A ( 1 ) + E * ( A ( 2 ) + E * ( A ( 3 ) + E * ( A ( 4 ) + E * A ( 5 ))))) / & ( 1 + E * ( B ( 1 ) + E * ( B ( 2 ) + E * ( B ( 3 ) + E * B ( 4 ))))) sigma = ( 1.0d-27 ) * ( S / ( E * exp ( Bg / sqrt ( E )))) end function d_d_fusion_he","tags":"","loc":"proc/d_d_fusion_he.html","title":"d_d_fusion_he – FIDASIM"},{"text":"public function d_t_fusion(eb) result(sigma) Calculates total cross section at a given deuterium energy, eb ,\nfor Deuterium-Tritium nuclear reactions in the range [0.5-550 keV] Equation D + T \\rightarrow He&#94;4(3.5 MeV) + n(14.1 MeV) References Equations 8-9 Table IV, VI in Ref. 7 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Deuterium energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] Called by proc~~d_t_fusion~~CalledByGraph proc~d_t_fusion d_t_fusion proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->proc~d_t_fusion Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code d_t_fusion Source Code function d_t_fusion ( eb ) result ( sigma ) !+Calculates total cross section at a given deuterium energy, `eb`, !+for Deuterium-Tritium nuclear reactions in the range [0.5-550 keV] !+ !+###Equation !+ D + T \\rightarrow He&#94;4(3.5 MeV) + n(14.1 MeV) !+ !+###References !+* Equations 8-9 !+* Table IV, VI in Ref. 7 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Deuterium energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 5 ), parameter :: A1 = [ 6.927d4 , 7.454d8 , & 2.050d6 , 5.2002d4 , & 0.d0 ] real ( Float64 ), dimension ( 4 ), parameter :: B1 = [ 6.38d1 , - 9.95d-1 , & 6.981d-5 , 1.728d-4 ] real ( Float64 ), dimension ( 5 ), parameter :: A2 = [ - 1.4714d6 , 0.d0 , & 0.d0 , 0.d0 , 0.d0 ] real ( Float64 ), dimension ( 4 ), parameter :: B2 = [ - 8.4127d-3 , 4.7983d-6 , & - 1.0748d-9 , 8.5184d-14 ] real ( Float64 ), parameter :: Bg = 3 4.3827 real ( Float64 ), dimension ( 5 ) :: A real ( Float64 ), dimension ( 4 ) :: B real ( Float64 ) :: S , E E = min ( max ( eb , 0.5 ), 470 0.0 ) if ( E . le . 53 0.0 ) then A = A1 B = B1 else A = A2 B = B2 endif S = ( A ( 1 ) + E * ( A ( 2 ) + E * ( A ( 3 ) + E * ( A ( 4 ) + E * A ( 5 ))))) / & ( 1 + E * ( B ( 1 ) + E * ( B ( 2 ) + E * ( B ( 3 ) + E * B ( 4 ))))) sigma = ( 1.0d-27 ) * ( S / ( E * exp ( Bg / sqrt ( E )))) end function d_t_fusion","tags":"","loc":"proc/d_t_fusion.html","title":"d_t_fusion – FIDASIM"},{"text":"public function simpsons_rule(f, dx) result(I) Performs 1D integration using Simpsons rule ###References\n* Simpson's rule Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: f Array of equally spaced f(x) values real(kind=Float64), intent(in) :: dx Spacing between x values Return Value real(kind=Float64) Called by proc~~simpsons_rule~~CalledByGraph proc~simpsons_rule simpsons_rule proc~bt_maxwellian_eb bt_maxwellian_eb proc~bt_maxwellian_eb->proc~simpsons_rule proc~bt_maxwellian_q_n bt_maxwellian_q_n proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_n bt_maxwellian_n proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_n_m bt_maxwellian_n_m proc~bt_maxwellian_n_m->proc~simpsons_rule proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m proc~bt_maxwellian_q_n_m->proc~simpsons_rule interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_eb interface~bt_maxwellian->proc~bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code simpsons_rule Source Code function simpsons_rule ( f , dx ) result ( I ) !+ Performs 1D integration using Simpsons rule !+ !+ ###References !+* [Simpson's rule](http://mathworld.wolfram.com/SimpsonsRule.html) real ( Float64 ), dimension (:), intent ( in ) :: f !+ Array of equally spaced f(x) values real ( Float64 ), intent ( in ) :: dx !+ Spacing between x values real ( Float64 ) :: I integer :: s , ii s = size ( f ) I = 0.d0 if ( mod ( s , 2 ). eq . 1 ) then write ( * , '(a)' ) \"Length of array must be even\" return endif I = f ( 1 ) do ii = 2 , s - 1 if ( mod ( ii , 2 ). eq . 1 ) then I = I + 4.0 * f ( ii ) else I = I + 2.0 * f ( ii ) endif enddo I = I + f ( s ) I = ( dx / 3.0 ) * I end function simpsons_rule","tags":"","loc":"proc/simpsons_rule.html","title":"simpsons_rule – FIDASIM"},{"text":"public subroutine m_spread(n, m_max, sigma_tot, sigma) Spreads the total charge exchange cross section, sigma_tot ,\n among the non-filled m states of sigma according to an exponential Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states in sigma real(kind=Float64), intent(in) :: sigma_tot Amount of \"cross section\" to spread about the non-filled m state of sigma real(kind=Float64), intent(inout), dimension(m_max) :: sigma Array of cross sections from the n state to m=1.. m_max [ cm&#94;2 ] Called by proc~~m_spread~~CalledByGraph proc~m_spread m_spread proc~p_cx_n p_cx_n proc~p_cx_n->proc~m_spread proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_2->proc~m_spread proc~p_cx_3->proc~m_spread proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code m_spread Source Code subroutine m_spread ( n , m_max , sigma_tot , sigma ) !+ Spreads the total charge exchange cross section, `sigma_tot`, !+ among the non-filled m states of `sigma` according to an exponential integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states in `sigma` real ( Float64 ), intent ( in ) :: sigma_tot !+ Amount of \"cross section\" to spread about the non-filled m state of sigma real ( Float64 ), dimension ( m_max ), intent ( inout ) :: sigma !+ Array of cross sections from the `n` state to m=1..`m_max` [cm&#94;2] real ( Float64 ) :: En , Em real ( Float64 ) :: norm_fac real ( Float64 ), dimension ( m_max ) :: sigma_m integer :: m sigma_m = 0.d0 En = 1 3.6 / ( real ( n ) ** 2.0 ) do m = 1 , m_max Em = 1 3.6 / ( real ( m ) ** 2.0 ) if ( sigma ( m ). eq . 0.d0 ) then sigma_m ( m ) = ( sigma_tot / sqrt ( 2.0 * PI )) * exp ( - 0.5 * ( En - Em ) ** 2.0 ) endif enddo norm_fac = sigma_tot / sum ( sigma_m ) do m = 1 , m_max if ( sigma ( m ). eq . 0.d0 ) sigma ( m ) = sigma_m ( m ) * norm_fac if ( sigma ( m ). ne . sigma ( m )) sigma ( m ) = 0.d0 enddo end subroutine m_spread","tags":"","loc":"proc/m_spread.html","title":"m_spread – FIDASIM"},{"text":"public subroutine bt_maxwellian_eb(fn, T, eb, am, ab, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] Calls proc~~bt_maxwellian_eb~~CallsGraph proc~bt_maxwellian_eb bt_maxwellian_eb proc~simpsons_rule simpsons_rule proc~bt_maxwellian_eb->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bt_maxwellian_eb~~CalledByGraph proc~bt_maxwellian_eb bt_maxwellian_eb interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_eb Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code bt_maxwellian_eb Source Code subroutine bt_maxwellian_eb ( fn , T , eb , am , ab , rate ) !+ Calculates Maxwellian reaction rate for a beam with atomic mass `ab` and energy `eb` !+firing into a target with atomic mass `am` and temperature `T` which has a cross section given by the function `fn` interface function fn ( a ) !+Cross section function real ( 8 ) :: fn !sigma real ( 8 ), intent ( in ) :: a !eb end function fn end interface real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] integer , parameter :: n_vr = 30 real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( n_vr ) :: vr real ( Float64 ), dimension ( n_vr ) :: fr integer , parameter :: n_vz = 60 real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( n_vz ) :: vz real ( Float64 ), dimension ( n_vz ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , v_therm , dE integer :: i , j vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 sig = fn ( erel ) fr ( j ) = sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm end subroutine bt_maxwellian_eb","tags":"","loc":"proc/bt_maxwellian_eb.html","title":"bt_maxwellian_eb – FIDASIM"},{"text":"public subroutine bt_maxwellian_n(fn, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a, b) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] Calls proc~~bt_maxwellian_n~~CallsGraph proc~bt_maxwellian_n bt_maxwellian_n proc~simpsons_rule simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bt_maxwellian_n~~CalledByGraph proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_n Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code bt_maxwellian_n Source Code subroutine bt_maxwellian_n ( fn , T , eb , am , ab , n , rate ) !+ Calculates Maxwellian reaction rate for a beam with atomic mass `ab`, energy `eb`, and energy level `n` !+firing into a target with atomic mass `am` and temperature `T` which has a cross section given by the function `fn` interface function fn ( a , b ) !+Cross section function real ( 8 ) :: fn !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !n end function fn end interface real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] logical :: dxc integer , parameter :: n_vr = 30 real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( n_vr ) :: vr real ( Float64 ), dimension ( n_vr ) :: fr integer , parameter :: n_vz = 60 real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( n_vz ) :: vz real ( Float64 ), dimension ( n_vz ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , v_therm , dE integer :: i , j vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) dE = ( 1 3.6d-3 ) / ( n ** 2.0 ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 !for electron interactions fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( erel . ge . dE ) then sig = fn ( erel / ared , n ) else sig = 0.d0 endif fr ( j ) = sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm end subroutine bt_maxwellian_n","tags":"","loc":"proc/bt_maxwellian_n.html","title":"bt_maxwellian_n – FIDASIM"},{"text":"public subroutine bt_maxwellian_q_n(fqn, q, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqn Arguments Type Intent Optional Attributes Name public function fqn(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] Calls proc~~bt_maxwellian_q_n~~CallsGraph proc~bt_maxwellian_q_n bt_maxwellian_q_n proc~simpsons_rule simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bt_maxwellian_q_n~~CalledByGraph proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_q_n Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code bt_maxwellian_q_n Source Code subroutine bt_maxwellian_q_n ( fqn , q , T , eb , am , ab , n , rate ) !+ Calculates Maxwellian reaction rate for a beam with atomic mass `ab`, energy `eb`, and energy level `n` !+firing into a target with atomic mass `am`, temperature `T`, and charge `q`  which has a cross section given by the function `fqn` interface function fqn ( a , b , c ) !+Cross section function real ( 8 ) :: fqn !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !q integer , intent ( in ) :: c !n end function fqn end interface integer , intent ( in ) :: q !+Target charge real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] integer , parameter :: n_vr = 30 real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( n_vr ) :: vr real ( Float64 ), dimension ( n_vr ) :: fr integer , parameter :: n_vz = 60 real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( n_vz ) :: vz real ( Float64 ), dimension ( n_vz ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , v_therm , dE integer :: i , j vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) dE = ( 1 3.6d-3 ) / ( n ** 2.0 ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( erel . ge . dE ) then sig = fqn ( erel / ared , q , n ) else sig = 0.d0 endif fr ( j ) = sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm end subroutine bt_maxwellian_q_n","tags":"","loc":"proc/bt_maxwellian_q_n.html","title":"bt_maxwellian_q_n – FIDASIM"},{"text":"public subroutine bt_maxwellian_n_m(fnm, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fnm Arguments Type Intent Optional Attributes Name public function fnm(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate Calls proc~~bt_maxwellian_n_m~~CallsGraph proc~bt_maxwellian_n_m bt_maxwellian_n_m proc~simpsons_rule simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bt_maxwellian_n_m~~CalledByGraph proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_n_m Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code bt_maxwellian_n_m Source Code subroutine bt_maxwellian_n_m ( fnm , T , eb , am , ab , n , m , rate , deexcit ) !+ Calculates Maxwellian reaction rate for a `n`\\rightarrow)`m` transition due to a beam with atomic mass `ab` and energy `eb` !+firing into a target with atomic mass `am` and temperature `T` which has a cross section given by the function `fnm` interface function fnm ( a , b , c ) !+Cross section function real ( 8 ) :: fnm !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !n integer , intent ( in ) :: c !m end function fnm end interface real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state integer , intent ( in ) :: m !+Final atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] logical , intent ( in ), optional :: deexcit !+Calculate de-excitation reaction rate logical :: dxc integer , parameter :: n_vr = 30 real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( n_vr ) :: vr real ( Float64 ), dimension ( n_vr ) :: fr integer , parameter :: n_vz = 60 real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( n_vz ) :: vz real ( Float64 ), dimension ( n_vz ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , dE , factor , En , Em , v_therm integer :: i , j if ( present ( deexcit )) then dxc = deexcit else dxc = . False . endif vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo En = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / n ) ** 2.0 ) Em = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / m ) ** 2.0 ) dE = Em - En T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( dxc ) then factor = ( erel + dE ) / erel erel = erel + dE else factor = 1.0 endif if ( erel . ge . dE ) then sig = fnm ( erel / ared , n , m ) else sig = 0.d0 endif fr ( j ) = factor * sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm if ( dxc ) rate = rate * ( real ( n ) / real ( m )) ** 2.0 end subroutine bt_maxwellian_n_m","tags":"","loc":"proc/bt_maxwellian_n_m.html","title":"bt_maxwellian_n_m – FIDASIM"},{"text":"public subroutine bt_maxwellian_q_n_m(fqnm, q, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqnm Arguments Type Intent Optional Attributes Name public function fqnm(a, b, c, d) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate Calls proc~~bt_maxwellian_q_n_m~~CallsGraph proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m proc~simpsons_rule simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bt_maxwellian_q_n_m~~CalledByGraph proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_q_n_m Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code bt_maxwellian_q_n_m Source Code subroutine bt_maxwellian_q_n_m ( fqnm , q , T , eb , am , ab , n , m , rate , deexcit ) !+ Calculates Maxwellian reaction rate for a `n`\\rightarrow)`m` transition due to a beam with atomic mass `ab` and energy `eb` !+firing into a target with atomic mass `am`, temperature `T`, and charge `q` which has a cross section given by the function `fqnm` interface function fqnm ( a , b , c , d ) !+Cross section function real ( 8 ) :: fqnm !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !q integer , intent ( in ) :: c !n integer , intent ( in ) :: d !m end function fqnm end interface integer , intent ( in ) :: q !+Target charge real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state integer , intent ( in ) :: m !+Final atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] logical , intent ( in ), optional :: deexcit !+Calculate de-excitation reaction rate logical :: dxc integer , parameter :: n_vr = 30 real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( n_vr ) :: vr real ( Float64 ), dimension ( n_vr ) :: fr integer , parameter :: n_vz = 60 real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( n_vz ) :: vz real ( Float64 ), dimension ( n_vz ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , dE , factor , En , Em , v_therm integer :: i , j if ( present ( deexcit )) then dxc = deexcit else dxc = . False . endif vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo En = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / n ) ** 2.0 ) Em = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / m ) ** 2.0 ) dE = Em - En T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( dxc ) then factor = ( erel + dE ) / erel erel = erel + dE else factor = 1.0 endif if ( erel . ge . dE ) then sig = fqnm ( erel / ared , q , n , m ) else sig = 0.d0 endif fr ( j ) = factor * sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm if ( dxc ) rate = rate * ( real ( n ) / real ( m )) ** 2.0 end subroutine bt_maxwellian_q_n_m","tags":"","loc":"proc/bt_maxwellian_q_n_m.html","title":"bt_maxwellian_q_n_m – FIDASIM"},{"text":"public subroutine write_einstein(id, n_max, m_max) Write Einstein coefficients to HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate Calls proc~~write_einstein~~CallsGraph proc~write_einstein write_einstein h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_einstein->h5ltmake_dataset_int_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_einstein->h5ltset_attribute_string_f h5gcreate_f h5gcreate_f proc~write_einstein->h5gcreate_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f h5gclose_f h5gclose_f proc~write_einstein->h5gclose_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f var panprocwrite_einsteinCallsGraph = svgPanZoom('#procwrite_einsteinCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_einstein~~CalledByGraph proc~write_einstein write_einstein program~generate_tables generate_tables program~generate_tables->proc~write_einstein Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_einstein Source Code subroutine write_einstein ( id , n_max , m_max ) !+ Write Einstein coefficients to HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate real ( Float64 ), dimension ( n_max , m_max ) :: ein integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: error if ( verbose ) then ein (:,:) = EINSTEIN ( 1 : n_max , 1 : m_max ) call h5gcreate_f ( id , \"spontaneous\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , m_max ] call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_compressed_dataset_double_f ( gid , \"einstein\" , 2 , dim2 , ein , error ) call h5ltset_attribute_string_f ( id , \"spontaneous\" , \"description\" , & \"Atomic rates for spontaneous emission/deexcitation\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"description\" , & \"n/m resolved einstein coefficients: einstein(n,m)\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"units\" , \"1/s\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"reaction\" , & \"H(n) -> H(m) + ph, n > m\" , error ) call h5gclose_f ( gid , error ) endif end subroutine write_einstein","tags":"","loc":"proc/write_einstein.html","title":"write_einstein – FIDASIM"},{"text":"public subroutine write_bb_H_H(id, namelist_file, n_max, m_max) Write Hydrogen-Hydrogen interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate Calls proc~~write_bb_h_h~~CallsGraph proc~write_bb_h_h write_bb_H_H proc~p_ioniz p_ioniz proc~write_bb_h_h->proc~p_ioniz h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bb_h_h->h5ltmake_dataset_int_f proc~p_excit p_excit proc~write_bb_h_h->proc~p_excit h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bb_h_h->h5ltmake_dataset_double_f h5gclose_f h5gclose_f proc~write_bb_h_h->h5gclose_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bb_h_h->h5ltset_attribute_string_f interface~parallel_sum parallel_sum proc~write_bb_h_h->interface~parallel_sum proc~p_cx p_cx proc~write_bb_h_h->proc~p_cx h5gcreate_f h5gcreate_f proc~write_bb_h_h->h5gcreate_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~p_ioniz_n p_ioniz_n proc~p_ioniz->proc~p_ioniz_n proc~p_excit_n p_excit_n proc~p_excit->proc~p_excit_n proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~p_cx_n p_cx_n proc~p_cx->proc~p_cx_n proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n->proc~p_ioniz_2_omullane proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n->proc~p_ioniz_5_omullane proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz_1_janev p_ioniz_1_janev proc~p_ioniz_n->proc~p_ioniz_1_janev proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~parallel_sum_d3->mpi_allreduce proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_1 proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1->proc~p_cx_janev proc~p_cx_1_2_janev p_cx_1_2_janev proc~p_cx_1->proc~p_cx_1_2_janev proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~aljan1 aljan1 proc~p_cx_1_2_janev->proc~aljan1 proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev var panprocwrite_bb_h_hCallsGraph = svgPanZoom('#procwrite_bb_h_hCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_bb_h_h~~CalledByGraph proc~write_bb_h_h write_bb_H_H program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_bb_H_H Source Code subroutine write_bb_H_H ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Hydrogen interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate logical :: calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:), allocatable :: cx , excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: i , cnt , error logical :: exis NAMELIST / H_H_cross / calculate , nenergy , emin , emax calculate = . True .; nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_H: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_H_cross ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( cx ( n_max , m_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 if ( verbose ) then write ( * , '(a)' ) \"---- H-H cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' endif cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = istart , nenergy , istep eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb cx (:,:, i ) = p_cx ( eb , n_max , m_max ) excit (:,:, i ) = p_excit ( eb , n_max , m_max ) ioniz (:, i ) = p_ioniz ( eb , n_max ) cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt * istep / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( ebarr ) call parallel_sum ( cx ) call parallel_sum ( excit ) call parallel_sum ( ioniz ) #endif if ( verbose ) then call h5gcreate_f ( id , \"H_H\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 3 , dim3 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_H\" , \"description\" , & \"Cross sections for Hydrogen-Hydrogen interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n/m resolved charge exchange cross sections: cx(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"H(+) + H(n) -> H(m) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , cx , excit , ioniz ) end subroutine write_bb_H_H","tags":"","loc":"proc/write_bb_h_h.html","title":"write_bb_H_H – FIDASIM"},{"text":"public subroutine write_bb_H_e(id, namelist_file, n_max, m_max) Write Hydrogen-Electron interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate Calls proc~~write_bb_h_e~~CallsGraph proc~write_bb_h_e write_bb_H_e h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bb_h_e->h5ltmake_dataset_int_f h5gcreate_f h5gcreate_f proc~write_bb_h_e->h5gcreate_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bb_h_e->h5ltmake_dataset_double_f h5gclose_f h5gclose_f proc~write_bb_h_e->h5gclose_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bb_h_e->h5ltset_attribute_string_f interface~parallel_sum parallel_sum proc~write_bb_h_e->interface~parallel_sum proc~e_excit e_excit proc~write_bb_h_e->proc~e_excit interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~e_ioniz e_ioniz proc~write_bb_h_e->proc~e_ioniz proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~e_excit_n e_excit_n proc~e_excit->proc~e_excit_n proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~e_ioniz_n e_ioniz_n proc~e_ioniz->proc~e_ioniz_n mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n->proc~e_ioniz_2_janev proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n->proc~e_ioniz_3_janev proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n->proc~e_ioniz_1_janev proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev var panprocwrite_bb_h_eCallsGraph = svgPanZoom('#procwrite_bb_h_eCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_bb_h_e~~CalledByGraph proc~write_bb_h_e write_bb_H_e program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_bb_H_e Source Code subroutine write_bb_H_e ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Electron interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate logical :: calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: i , cnt , error logical :: exis NAMELIST / H_e_cross / calculate , nenergy , emin , emax calculate = . True .; nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_E: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_e_cross ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0.d0 ioniz = 0.d0 excit = 0.d0 if ( verbose ) then write ( * , '(a)' ) \"---- H-e cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' endif cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = istart , nenergy , istep eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb excit (:,:, i ) = e_excit ( eb , n_max , m_max ) ioniz (:, i ) = e_ioniz ( eb , n_max ) cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt * istep / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( ebarr ) call parallel_sum ( excit ) call parallel_sum ( ioniz ) #endif if ( verbose ) then call h5gcreate_f ( id , \"H_e\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_e\" , \"description\" , & \"Cross sections for Hydrogen-Electron interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum Energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum Energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"e- + H(n) -> e- + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"e- + H(n) -> e- + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , ioniz , excit ) end subroutine write_bb_H_e","tags":"","loc":"proc/write_bb_h_e.html","title":"write_bb_H_e – FIDASIM"},{"text":"public subroutine write_bb_H_Aq(id, namelist_file, n_max, m_max) Write Hydrogen-Impurity interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate Calls proc~~write_bb_h_aq~~CallsGraph proc~write_bb_h_aq write_bb_H_Aq proc~aq_cx Aq_cx proc~write_bb_h_aq->proc~aq_cx proc~aq_excit Aq_excit proc~write_bb_h_aq->proc~aq_excit h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bb_h_aq->h5ltmake_dataset_int_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bb_h_aq->h5ltmake_dataset_double_f h5gclose_f h5gclose_f proc~write_bb_h_aq->h5gclose_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bb_h_aq->h5ltset_attribute_string_f interface~parallel_sum parallel_sum proc~write_bb_h_aq->interface~parallel_sum proc~aq_ioniz Aq_ioniz proc~write_bb_h_aq->proc~aq_ioniz interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~aq_cx_n Aq_cx_n proc~aq_cx->proc~aq_cx_n proc~aq_excit_n Aq_excit_n proc~aq_excit->proc~aq_excit_n proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz->proc~aq_ioniz_n proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n->proc~aq_cx_n_janev mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n->proc~aq_ioniz_n_janev proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n->proc~c6_ioniz_1_janev proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev var panprocwrite_bb_h_aqCallsGraph = svgPanZoom('#procwrite_bb_h_aqCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_bb_h_aq~~CalledByGraph proc~write_bb_h_aq write_bb_H_Aq program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_bb_H_Aq Source Code subroutine write_bb_H_Aq ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Impurity interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate logical :: calculate integer :: q ( 10 ) = 0 real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: cx , ioniz real ( Float64 ), dimension (:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 character ( len = 10 ) :: aname character ( len = 5 ) :: asym integer :: i , iq , cnt , error logical :: exis NAMELIST / H_Aq_cross / calculate , q , nenergy , emin , emax nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 calculate = . True .; q ( 1 ) = 6 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_Aq: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_Aq_cross ) close ( 13 ) endif if (. not . calculate ) return q_loop : do iq = 1 , size ( q ) if ( q ( iq ). eq . 0 ) cycle q_loop allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( cx ( n_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 select case ( q ( iq )) case ( 5 ) aname = \"Boron\" asym = \"H_B5\" case ( 6 ) aname = \"Carbon\" asym = \"H_C6\" case DEFAULT write ( aname , '(\"Impurity-\",i1)' ) q ( iq ) write ( asym , '(\"H_A\",i1)' ) q ( iq ) end select if ( verbose ) then write ( * , '(a)' ) \"---- H-\" // trim ( adjustl ( aname )) // \" cross sections settings ----\" write ( * , '(T2,\"q = \", i2)' ) q ( iq ) write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' endif cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = istart , nenergy , istep eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb cx (:, i ) = Aq_cx ( eb , q ( iq ), n_max ) ioniz (:, i ) = Aq_ioniz ( eb , q ( iq ), n_max ) excit (:,:, i ) = Aq_excit ( eb , q ( iq ), n_max , m_max ) cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt * istep / real ( nenergy ), char ( 13 ) enddo #ifdef _MPI call parallel_sum ( ebarr ) call parallel_sum ( cx ) call parallel_sum ( excit ) call parallel_sum ( ioniz ) #endif if ( verbose ) then call h5gcreate_f ( id , trim ( adjustl ( asym )), gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 2 , dim2 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , trim ( adjustl ( asym )), \"description\" , & \"Cross sections for Hydrogen-\" // trim ( adjustl ( aname )) // \" interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n resolved charge exchange / electron capture cross sections: cx(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"A(q+) + H(n) -> A((q-1)+) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , ioniz , cx , excit ) enddo q_loop end subroutine write_bb_H_Aq","tags":"","loc":"proc/write_bb_h_aq.html","title":"write_bb_H_Aq – FIDASIM"},{"text":"public subroutine write_bb_D_D(id, namelist_file) Write Deuterium-Deuterium interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings Calls proc~~write_bb_d_d~~CallsGraph proc~write_bb_d_d write_bb_D_D interface~parallel_sum parallel_sum proc~write_bb_d_d->interface~parallel_sum proc~d_d_fusion_t d_d_fusion_t proc~write_bb_d_d->proc~d_d_fusion_t h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bb_d_d->h5ltmake_dataset_int_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bb_d_d->h5ltmake_dataset_double_f h5gclose_f h5gclose_f proc~write_bb_d_d->h5gclose_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bb_d_d->h5ltset_attribute_string_f proc~d_d_fusion_he d_d_fusion_he proc~write_bb_d_d->proc~d_d_fusion_he h5gcreate_f h5gcreate_f proc~write_bb_d_d->h5gcreate_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f var panprocwrite_bb_d_dCallsGraph = svgPanZoom('#procwrite_bb_d_dCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_bb_d_d~~CalledByGraph proc~write_bb_d_d write_bb_D_D program~generate_tables generate_tables program~generate_tables->proc~write_bb_d_d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_bb_D_D Source Code subroutine write_bb_D_D ( id , namelist_file ) !+ Write Deuterium-Deuterium interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings logical :: calculate integer :: nbranch = 2 real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: i , cnt , error logical :: exis NAMELIST / D_D_cross / calculate , nenergy , emin , emax calculate = . True .; nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_D_D: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_D_cross ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( fusion ( nenergy , nbranch )) ebarr = 0.d0 fusion = 0.d0 if ( verbose ) then write ( * , '(a)' ) \"---- D-D cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' endif cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = istart , nenergy , istep eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb fusion ( i , 1 ) = d_d_fusion_t ( eb ) fusion ( i , 2 ) = d_d_fusion_he ( eb ) cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt * istep / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( ebarr ) call parallel_sum ( fusion ) #endif if ( verbose ) then call h5gcreate_f ( id , \"D_D\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] dim2 = [ nenergy , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 2 , dim2 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_D\" , \"description\" , & \"Cross sections for Deuterium-Deuterium interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Deuterium energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Cross sections for the Tritium[1] and He3[2] branches of D-D nuclear reactions: fusion(energy, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + D -> [1] T(1.01 MeV) + p(3.02 MeV) (50%); [2] He3(0.82 MeV) + n(2.45 MeV) (50%)\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , fusion ) end subroutine write_bb_D_D","tags":"","loc":"proc/write_bb_d_d.html","title":"write_bb_D_D – FIDASIM"},{"text":"public subroutine write_bb_D_T(id, namelist_file) Write Deuterium-Tritium interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings Calls proc~~write_bb_d_t~~CallsGraph proc~write_bb_d_t write_bb_D_T interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bb_d_t->h5ltmake_dataset_int_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bb_d_t->h5ltmake_dataset_double_f h5gclose_f h5gclose_f proc~write_bb_d_t->h5gclose_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bb_d_t->h5ltset_attribute_string_f proc~d_t_fusion d_t_fusion proc~write_bb_d_t->proc~d_t_fusion interface~parallel_sum parallel_sum proc~write_bb_d_t->interface~parallel_sum h5gcreate_f h5gcreate_f proc~write_bb_d_t->h5gcreate_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 mpi_allreduce mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce var panprocwrite_bb_d_tCallsGraph = svgPanZoom('#procwrite_bb_d_tCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_bb_D_T Source Code subroutine write_bb_D_T ( id , namelist_file ) !+ Write Deuterium-Tritium interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings logical :: calculate integer :: nbranch = 1 real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: i , cnt , error logical :: exis NAMELIST / D_T_cross / calculate , nenergy , emin , emax calculate = . True .; nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_D_T: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_T_cross ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( fusion ( nenergy , nbranch )) ebarr = 0.d0 fusion = 0.d0 if ( verbose ) then write ( * , '(a)' ) \"---- D-T cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' endif cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = istart , nenergy , istep eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb fusion ( i , 1 ) = d_t_fusion ( eb ) cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt * istep / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( ebarr ) call parallel_sum ( fusion ) #endif if ( verbose ) then call h5gcreate_f ( id , \"D_T\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] dim2 = [ nenergy , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 2 , dim2 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_T\" , \"description\" , & \"Cross sections for Deuterium-Tritium interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Deuterium energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Total cross sections for D-T nuclear reactions: fusion(deuterium energy, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + T -> He4(3.5 MeV) + n(14.1 MeV)\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , fusion ) end subroutine write_bb_D_T","tags":"","loc":"proc/write_bb_d_t.html","title":"write_bb_D_T – FIDASIM"},{"text":"public subroutine write_bt_H_H(id, namelist_file, n_max, m_max) Write Hydrogen-Hydrogen reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate Calls proc~~write_bt_h_h~~CallsGraph proc~write_bt_h_h write_bt_H_H h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_h_h->h5ltmake_dataset_int_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_h_h->h5ltmake_dataset_double_f h5gclose_f h5gclose_f proc~write_bt_h_h->h5gclose_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bt_h_h->h5ltset_attribute_string_f interface~parallel_sum parallel_sum proc~write_bt_h_h->interface~parallel_sum h5gcreate_f h5gcreate_f proc~write_bt_h_h->h5gcreate_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f var panprocwrite_bt_h_hCallsGraph = svgPanZoom('#procwrite_bt_h_hCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_bt_h_h~~CalledByGraph proc~write_bt_h_h write_bt_H_H program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_bt_H_H Source Code subroutine write_bt_H_H ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Hydrogen reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate logical :: calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit , cx integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 9 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a logical :: exis NAMELIST / H_H_rates / calculate , nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 calculate = . True . inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_H: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_H_rates ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( cx ( n_max , m_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) ebarr = 0.d0 tarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 a (:, 1 ) = [ H1_amu , H1_amu ] a (:, 2 ) = [ H1_amu , H2_amu ] a (:, 3 ) = [ H1_amu , H3_amu ] a (:, 4 ) = [ H2_amu , H1_amu ] a (:, 5 ) = [ H2_amu , H2_amu ] a (:, 6 ) = [ H2_amu , H3_amu ] a (:, 7 ) = [ H3_amu , H1_amu ] a (:, 8 ) = [ H3_amu , H2_amu ] a (:, 9 ) = [ H3_amu , H3_amu ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo if ( verbose ) then write ( * , '(a)' ) \"---- H-H reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' endif cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = istart , nenergy , istep eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max call bt_maxwellian ( p_cx_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) cx ( n , m , ie , it , ia ) = rate if ( m . gt . n ) then call bt_maxwellian ( p_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( p_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( p_ioniz_n , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * istep * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( cx ) call parallel_sum ( excit ) call parallel_sum ( ioniz ) #endif if ( verbose ) then call h5gcreate_f ( id , \"H_H\" , gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 5 , dim5 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_H\" , \"description\" , & \"Beam-Target reaction rates for Hydrogen(beam)-Hydrogen(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n/m resolved charge exchange reaction rates: cx(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"H(+) + H(n) -> H(m) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , tarr , cx , excit , ioniz ) end subroutine write_bt_H_H","tags":"","loc":"proc/write_bt_h_h.html","title":"write_bt_H_H – FIDASIM"},{"text":"public subroutine write_bt_H_e(id, namelist_file, n_max, m_max) Write Hydrogen-Electron reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate Calls proc~~write_bt_h_e~~CallsGraph proc~write_bt_h_e write_bt_H_e h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_h_e->h5ltmake_dataset_int_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_h_e->h5ltmake_dataset_double_f h5gclose_f h5gclose_f proc~write_bt_h_e->h5gclose_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bt_h_e->h5ltset_attribute_string_f interface~parallel_sum parallel_sum proc~write_bt_h_e->interface~parallel_sum h5gcreate_f h5gcreate_f proc~write_bt_h_e->h5gcreate_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f var panprocwrite_bt_h_eCallsGraph = svgPanZoom('#procwrite_bt_h_eCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_bt_h_e~~CalledByGraph proc~write_bt_h_e write_bt_H_e program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_bt_H_e Source Code subroutine write_bt_H_e ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Electron reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate logical :: calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 3 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a logical :: exis NAMELIST / H_e_rates / calculate , nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 calculate = . True . inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_E: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_e_rates ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) ebarr = 0.d0 ioniz = 0.d0 excit = 0.d0 a (:, 1 ) = [ H1_amu , e_amu ] a (:, 2 ) = [ H2_amu , e_amu ] a (:, 3 ) = [ H3_amu , e_amu ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo if ( verbose ) then write ( * , '(a)' ) \"---- H-e reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' endif cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = istart , nenergy , istep eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max if ( m . gt . n ) then call bt_maxwellian ( e_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( e_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( e_ioniz_n , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * istep * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( excit ) call parallel_sum ( ioniz ) #endif if ( verbose ) then call h5gcreate_f ( id , \"H_e\" , gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_e\" , \"description\" , & \"Beam-Target reaction rates for Hydrogen(beam)-Electron(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"e- + H(n) -> e- + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"e- + H(n) -> e- + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , tarr , excit , ioniz ) end subroutine write_bt_H_e","tags":"","loc":"proc/write_bt_h_e.html","title":"write_bt_H_e – FIDASIM"},{"text":"public subroutine write_bt_H_Aq(id, namelist_file, n_max, m_max) Write Hydrogen-Impurity reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate Calls proc~~write_bt_h_aq~~CallsGraph proc~write_bt_h_aq write_bt_H_Aq h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_h_aq->h5ltmake_dataset_int_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_h_aq->h5ltmake_dataset_double_f h5gclose_f h5gclose_f proc~write_bt_h_aq->h5gclose_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bt_h_aq->h5ltset_attribute_string_f interface~parallel_sum parallel_sum proc~write_bt_h_aq->interface~parallel_sum interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f var panprocwrite_bt_h_aqCallsGraph = svgPanZoom('#procwrite_bt_h_aqCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_bt_h_aq~~CalledByGraph proc~write_bt_h_aq write_bt_H_Aq program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_bt_H_Aq Source Code subroutine write_bt_H_Aq ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Impurity reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate logical :: calculate integer :: q ( 10 ) = 0 real ( Float64 ) :: mass real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz , cx real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: iq , ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 3 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a character ( len = 10 ) :: aname character ( len = 5 ) :: asym logical :: exis NAMELIST / H_Aq_rates / calculate , q , mass , nenergy , emin , emax , ntemp , tmin , tmax calculate = . True . ; q ( 1 ) = 6 ; mass = C_amu nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_Aq: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_Aq_rates ) close ( 13 ) endif if (. not . calculate ) return q_loop : do iq = 1 , size ( q ) if ( q ( iq ). eq . 0 ) cycle q_loop allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( cx ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) select case ( q ( iq )) case ( 5 ) aname = \"Boron\" asym = \"H_B5\" case ( 6 ) aname = \"Carbon\" asym = \"H_C6\" case DEFAULT write ( aname , '(\"Impurity-\",i1)' ) q ( iq ) write ( asym , '(\"H_A\",i1)' ) q ( iq ) end select ebarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 a (:, 1 ) = [ H1_amu , mass ] a (:, 2 ) = [ H2_amu , mass ] a (:, 3 ) = [ H3_amu , mass ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo if ( verbose ) then write ( * , '(a)' ) \"---- H-\" // trim ( adjustl ( aname )) // \" reaction rates settings ----\" write ( * , '(T2,\"q = \", i2)' ) q ( iq ) write ( * , '(T2,\"mass = \",f7.2, \" amu\")' ) mass write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' endif cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = istart , nenergy , istep eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max if ( m . gt . n ) then call bt_maxwellian ( Aq_excit_n_m , q ( iq ), ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( Aq_excit_n_m , q ( iq ), ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( Aq_cx_n , q ( iq ), ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) cx ( n , ie , it , ia ) = rate call bt_maxwellian ( Aq_ioniz_n , q ( iq ), ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * istep * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( cx ) call parallel_sum ( excit ) call parallel_sum ( ioniz ) #endif if ( verbose ) then call h5gcreate_f ( id , trim ( adjustl ( asym )), gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 4 , dim4 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , trim ( adjustl ( asym )), \"description\" , & \"Beam-Target reaction rates for Hydrogen(beam)-\" // trim ( adjustl ( aname )) // & \"(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n-resolved charge exchange reaction rates: cx(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"A(q+) + H(n) -> A((q-1)+) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , tarr , excit , ioniz , cx ) enddo q_loop end subroutine write_bt_H_Aq","tags":"","loc":"proc/write_bt_h_aq.html","title":"write_bt_H_Aq – FIDASIM"},{"text":"public subroutine write_bt_D_D(id, namelist_file) Write Deuterium-Deuterium reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings Calls proc~~write_bt_d_d~~CallsGraph proc~write_bt_d_d write_bt_D_D h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_d_d->h5ltmake_dataset_int_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_d_d->h5ltmake_dataset_double_f h5gclose_f h5gclose_f proc~write_bt_d_d->h5gclose_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bt_d_d->h5ltset_attribute_string_f interface~parallel_sum parallel_sum proc~write_bt_d_d->interface~parallel_sum h5gcreate_f h5gcreate_f proc~write_bt_d_d->h5gcreate_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f var panprocwrite_bt_d_dCallsGraph = svgPanZoom('#procwrite_bt_d_dCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_bt_d_d~~CalledByGraph proc~write_bt_d_d write_bt_D_D program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_bt_D_D Source Code subroutine write_bt_D_D ( id , namelist_file ) !+ Write Deuterium-Deuterium reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings logical :: calculate integer :: nbranch = 2 real ( Float64 ), dimension ( 2 ) :: bt_amu = [ H2_amu , H2_amu ] real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: ie , it , error , cnt real ( Float64 ) :: rate_a , rate_b logical :: exis NAMELIST / D_D_rates / calculate , nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 calculate = . True . inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_D_D: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_D_rates ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( fusion ( nenergy , ntemp , nbranch )) ebarr = 0.d0 tarr = 0.d0 fusion = 0.d0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo if ( verbose ) then write ( * , '(a)' ) \"---- D-D reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' endif cnt = 0 !$OMP PARALLEL DO private(ie, it, eb, ti, rate_a, rate_b) do ie = istart , nenergy , istep eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) call bt_maxwellian ( d_d_fusion_t , ti , eb , bt_amu ( 1 ), bt_amu ( 2 ), rate_a ) call bt_maxwellian ( d_d_fusion_he , ti , eb , bt_amu ( 2 ), bt_amu ( 2 ), rate_b ) fusion ( ie , it , 1 ) = rate_a fusion ( ie , it , 2 ) = rate_b cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * istep * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( fusion ) #endif if ( verbose ) then call h5gcreate_f ( id , \"D_D\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim1 = [ 2 ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 1 , dim1 , bt_amu , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) dim3 = [ nenergy , ntemp , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 3 , dim3 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_D\" , \"description\" , & \"Beam-Target reaction rates for Deuterium(beam)-Deuterium(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Isotope mass of the beam and target species respectively\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"units\" , \"amu\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Beam-Target reaction rates for T/He3 branches of D-D nuclear reactions: fusion(energy, temp, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + D -> [1] T(1.01 MeV) + p(3.02 MeV) (50%); [2] He3(0.82 MeV) + n(2.45 MeV) (50%)\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , tarr , fusion ) end subroutine write_bt_D_D","tags":"","loc":"proc/write_bt_d_d.html","title":"write_bt_D_D – FIDASIM"},{"text":"public subroutine write_bt_D_T(id, namelist_file) Write Deuterium-Tritium reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings Calls proc~~write_bt_d_t~~CallsGraph proc~write_bt_d_t write_bt_D_T h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_d_t->h5ltmake_dataset_int_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_d_t->h5ltmake_dataset_double_f h5gclose_f h5gclose_f proc~write_bt_d_t->h5gclose_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bt_d_t->h5ltset_attribute_string_f interface~parallel_sum parallel_sum proc~write_bt_d_t->interface~parallel_sum h5gcreate_f h5gcreate_f proc~write_bt_d_t->h5gcreate_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 mpi_allreduce mpi_allreduce proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~parallel_sum_d4->mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d3->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f var panprocwrite_bt_d_tCallsGraph = svgPanZoom('#procwrite_bt_d_tCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code write_bt_D_T Source Code subroutine write_bt_D_T ( id , namelist_file ) !+ Write Deuterium-Tritium reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer :: nbranch = 1 real ( Float64 ), dimension ( 2 ) :: bt_amu = [ H2_amu , H3_amu ] logical :: calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: ie , it , error , cnt real ( Float64 ) :: rate logical :: exis NAMELIST / D_T_rates / calculate , nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 calculate = . True . inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_D_T: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_T_rates ) close ( 13 ) endif if (. not . calculate ) return allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( fusion ( nenergy , ntemp , nbranch )) ebarr = 0.d0 tarr = 0.d0 fusion = 0.d0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo if ( verbose ) then write ( * , '(a)' ) \"---- D-T reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' endif cnt = 0 !$OMP PARALLEL DO private(ie, it, eb, ti, rate) do ie = istart , nenergy , istep eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) call bt_maxwellian ( d_t_fusion , ti , eb , bt_amu ( 1 ), bt_amu ( 2 ), rate ) fusion ( ie , it , 1 ) = rate cnt = cnt + 1 if ( verbose ) WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * istep * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO #ifdef _MPI call parallel_sum ( fusion ) #endif if ( verbose ) then call h5gcreate_f ( id , \"D_T\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim1 = [ 2 ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 1 , dim1 , bt_amu , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) dim3 = [ nenergy , ntemp , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 3 , dim3 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_T\" , \"description\" , & \"Beam-Target reaction rates for Deuterium(beam)-Tritium(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Isotope mass of the beam and target species respectively\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"units\" , \"amu\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Beam-Target reaction rates for D-T nuclear reactions: fusion(energy, temperature, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + T -> He4(3.5 MeV) + n(14.1 MeV)\" , error ) call h5gclose_f ( gid , error ) endif deallocate ( ebarr , tarr , fusion ) end subroutine write_bt_D_T","tags":"","loc":"proc/write_bt_d_t.html","title":"write_bt_D_T – FIDASIM"},{"text":"public subroutine print_default_namelist() Prints out the default settings as a namelist Arguments None Called by proc~~print_default_namelist~~CalledByGraph proc~print_default_namelist print_default_namelist program~generate_tables generate_tables program~generate_tables->proc~print_default_namelist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code print_default_namelist Source Code subroutine print_default_namelist !+ Prints out the default settings as a namelist write ( * , '(a)' ) \"!Default Atomic Table Settings\" write ( * , '(a)' ) \"&general_settings\" write ( * , '(a)' ) \"n_max = 12,    !Number of initial atomic energy levels\" write ( * , '(a)' ) \"m_max = 12,    !Number of final atomic energy levels\" write ( * , '(a)' ) \"tables_file = './atomic_tables.h5'\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Hydrogen Cross Sections\" write ( * , '(a)' ) \"&H_H_cross\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Electron Cross Sections\" write ( * , '(a)' ) \"&H_e_cross\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Impurity Cross Sections. Up to 10 impurity charges\" write ( * , '(a)' ) \"&H_Aq_cross\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"q(1) = 5,      !Impurity charge: Boron: 5, Carbon: 6, ...\" write ( * , '(a)' ) \"q(2) = 6,      !Impurity charge: Boron: 5, Carbon: 6, ...\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Deuterium-Deuterium Nuclear Cross Sections\" write ( * , '(a)' ) \"&D_D_cross\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Hydrogen Reaction Rates\" write ( * , '(a)' ) \"&H_H_rates\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum ion temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum ion temperature [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Electron Reaction Rates\" write ( * , '(a)' ) \"&H_e_rates\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum electron temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum electron temperature [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Impurity Reaction Rates. Up to 10 impurity charges\" write ( * , '(a)' ) \"&H_Aq_rates\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"q(1) = 5,      !Impurity charge: Boron: 5, Carbon: 6, ...\" write ( * , '(a)' ) \"q(2) = 6,      !Impurity charge: Boron: 5, Carbon: 6, ...\" write ( * , '(a)' ) \"mass = 12.011, !Impurity mass [amu]\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum ion temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum ion temperature [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Deuterium-Deuterium Nuclear Reaction Rates\" write ( * , '(a)' ) \"&D_D_rates\" write ( * , '(a)' ) \"calculate = T, !Calculate Table\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum deuterium temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum deuterium temperature [keV]\" write ( * , '(a)' ) \"/\" end subroutine print_default_namelist","tags":"","loc":"proc/print_default_namelist.html","title":"print_default_namelist – FIDASIM"},{"text":"public interface bt_maxwellian Calculates the reaction rate coefficients given beam energy eb and target temperature T where the velocity distribution of the target is a Maxwellian Calls interface~~bt_maxwellian~~CallsGraph interface~bt_maxwellian bt_maxwellian proc~bt_maxwellian_eb bt_maxwellian_eb interface~bt_maxwellian->proc~bt_maxwellian_eb proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~simpsons_rule simpsons_rule proc~bt_maxwellian_eb->proc~simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures bt_maxwellian_eb bt_maxwellian_n bt_maxwellian_n_m bt_maxwellian_q_n bt_maxwellian_q_n_m Module Procedures public subroutine bt_maxwellian_eb (fn, T, eb, am, ab, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] public subroutine bt_maxwellian_n (fn, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a, b) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] public subroutine bt_maxwellian_n_m (fnm, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fnm Arguments Type Intent Optional Attributes Name public function fnm(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate public subroutine bt_maxwellian_q_n (fqn, q, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqn Arguments Type Intent Optional Attributes Name public function fqn(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] public subroutine bt_maxwellian_q_n_m (fqnm, q, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqnm Arguments Type Intent Optional Attributes Name public function fqnm(a, b, c, d) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate","tags":"","loc":"interface/bt_maxwellian.html","title":"bt_maxwellian – FIDASIM"},{"text":"Used by module~~mpi_utils~~UsedByGraph module~mpi_utils mpi_utils module~libfida libfida module~libfida->module~mpi_utils proc~rng_init rng_init proc~rng_init->module~mpi_utils program~fidasim fidasim program~fidasim->module~mpi_utils program~fidasim->module~libfida module~atomic_tables atomic_tables module~atomic_tables->module~mpi_utils program~generate_tables generate_tables program~generate_tables->module~atomic_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces parallel_sum Functions my_rank num_ranks Subroutines init_mpi cleanup_mpi parallel_sum_d0 parallel_sum_d1 parallel_sum_d2 parallel_sum_d3 parallel_sum_d4 parallel_sum_d5 parallel_sum_i0 parallel_sum_i1 parallel_sum_i2 Interfaces public interface parallel_sum public recursive subroutine parallel_sum_d0 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout) :: A public recursive subroutine parallel_sum_d1 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:) :: A public recursive subroutine parallel_sum_d2 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:), target :: A public recursive subroutine parallel_sum_d3 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:,:), target :: A public recursive subroutine parallel_sum_d4 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:,:,:), target :: A public recursive subroutine parallel_sum_d5 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:,:,:,:), target :: A public recursive subroutine parallel_sum_i0 (A) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: A public recursive subroutine parallel_sum_i1 (A) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: A public recursive subroutine parallel_sum_i2 (A) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:,:), target :: A Functions public recursive function my_rank () result(n) Arguments None Return Value integer public recursive function num_ranks () result(n) Arguments None Return Value integer Subroutines public subroutine init_mpi () Arguments None public subroutine cleanup_mpi () Arguments None public recursive subroutine parallel_sum_d0 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout) :: A public recursive subroutine parallel_sum_d1 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:) :: A public recursive subroutine parallel_sum_d2 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:), target :: A public recursive subroutine parallel_sum_d3 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:,:), target :: A public recursive subroutine parallel_sum_d4 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:,:,:), target :: A public recursive subroutine parallel_sum_d5 (A) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(inout), dimension(:,:,:,:,:), target :: A public recursive subroutine parallel_sum_i0 (A) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: A public recursive subroutine parallel_sum_i1 (A) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: A public recursive subroutine parallel_sum_i2 (A) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:,:), target :: A","tags":"","loc":"module/mpi_utils.html","title":"mpi_utils – FIDASIM"},{"text":"Main FIDASIM library Uses H5LT HDF5 hdf5_utils eigensystem utilities iso_c_binding mpi_utils module~~libfida~~UsesGraph module~libfida libfida HDF5 HDF5 module~libfida->HDF5 module~eigensystem eigensystem module~libfida->module~eigensystem H5LT H5LT module~libfida->H5LT module~hdf5_utils hdf5_utils module~libfida->module~hdf5_utils module~mpi_utils mpi_utils module~libfida->module~mpi_utils module~utilities utilities module~libfida->module~utilities iso_c_binding iso_c_binding module~libfida->iso_c_binding module~hdf5_utils->HDF5 module~hdf5_utils->H5LT module~utilities->iso_c_binding omp_lib omp_lib module~utilities->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~libfida~~UsedByGraph module~libfida libfida program~fidasim fidasim program~fidasim->module~libfida Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables version time_start charlim namelist_file nbif_type nbih_type nbit_type dcx_type halo_type fida_type brems_type ntypes beam_ion thermal_ion e_amu H1_amu H2_amu H3_amu He3_amu B5_amu C6_amu mass_u e0 pi c0 h_planck lambda0 v2_to_E_per_amu log_10 n_stark stark_wavel stark_intens stark_pi stark_sigma nlevs halo_iter_dens nbi_outside istart istep beam_grid inter_grid pass_grid fbm particles equil nbi tables npa pnpa spec_chords npa_chords inputs birth neut spec neutron fweight nweight Interfaces assignment(=) operator(+) operator(-) operator(*) operator(/) interpol_coeff interpol Derived Types InterpolCoeffs1D InterpolCoeffs2D InterpolCoeffs3D BeamGrid InterpolationGrid Profiles LocalProfiles EMFields LocalEMFields Equilibrium FastIonDistribution FastIon FastIonParticles NeutralBeam AtomicCrossSection AtomicRates AtomicTransitions NuclearRates AtomicTables LineOfSight LOSElement LOSInters SpectralChords BoundedPlane NPADetector NPAProbability NPAChords NPAParticle NPAResults BirthParticle BirthProfile Spectra NeutronRate NeutralDensity FIDAWeights NPAWeights SimulationInputs ParticleTrack GyroSurface Functions pp_add pp_subtract lplp_add lplp_subtract ps_multiply sp_multiply ps_divide lps_multiply slp_multiply lps_divide ff_add ff_subtract fs_multiply sf_multiply fs_divide lflf_add lflf_subtract lfs_multiply slf_multiply lfs_divide approx_eq approx_ge approx_le cross_product in_boundary in_gyro_surface in_grid in_passive_grid gyro_radius Subroutines print_banner fast_ion_assign npa_part_assign birth_part_assign pp_assign lpp_assign plp_assign lplp_assign ff_assign lff_assign flf_assign lflf_assign read_inputs make_beam_grid make_passive_grid make_diagnostic_grids read_beam read_chords read_npa read_equilibrium read_f read_mc read_distribution read_atomic_cross read_atomic_rate read_atomic_transitions read_nuclear_rates read_tables write_beam_grid write_birth_profile write_neutrals write_npa write_spectra write_neutrons write_fida_weights write_npa_weights read_neutrals tb_zyx line_basis plane_basis line_plane_intersect line_cylinder_intersect boundary_edge gyro_surface line_gyro_surface_intersect gyro_surface_coordinates gyro_trajectory gyro_range npa_gyro_range hit_npa_detector xyz_to_uvw xyz_to_cyl uvw_to_xyz cyl_to_uvw cyl_to_xyz uvw_to_cyl grid_intersect circle_grid_intersect get_indices get_passive_grid_indices get_plasma_extrema get_position track track_cylindrical interpol1D_coeff interpol1D_coeff_arr interpol2D_coeff interpol2D_coeff_arr cyl_interpol3D_coeff cyl_interpol3D_coeff_arr interpol1D_arr interpol2D_arr interpol2D_2D_arr interpol3D_arr interpol3D_2D_arr in_plasma get_plasma calc_perp_vectors get_fields get_distribution get_ep_denf store_neutrals store_births store_npa bb_cx_rates bt_cx_rates get_neutron_rate get_beam_cx_rate get_rate_matrix colrad attenuate doppler_stark spectrum store_photons store_bes_photons store_fida_photons store_neutrons store_fw_photons_at_chan store_fw_photons get_nlaunch get_nlaunch_pass_grid pitch_to_vec gyro_step gyro_correction mc_fastion mc_fastion_pass_grid mc_halo mc_nbi mc_nbi_cell ndmc bremsstrahlung dcx halo nbi_spec dcx_spec halo_spec cold_spec fida_f pfida_f fida_mc pfida_mc npa_f pnpa_f npa_mc pnpa_mc neutron_f neutron_mc fida_weights_mc fida_weights_los npa_weights Variables Type Visibility Attributes Name Initial character(len=30), public :: version = '' FIDASIM version number integer, public, dimension(8) :: time_start Start time integer, public, parameter :: charlim = 150 Defines character limit for files and directories character(len=charlim), public :: namelist_file Input namelist file integer, public, parameter :: nbif_type = 1 Identifier for full energy NBI neutral interaction integer, public, parameter :: nbih_type = 2 Identifier for half energy NBI neutral interaction integer, public, parameter :: nbit_type = 3 Identifier for third energy NBI neutral interaction integer, public, parameter :: dcx_type = 4 Identifier for dcx neutral interaction integer, public, parameter :: halo_type = 5 Identifier for halo neutral interaction integer, public, parameter :: fida_type = 6 Identifier for fida neutral interaction integer, public, parameter :: brems_type = 7 Identifier for bremsstrahlung interaction. Acts as dummy type integer, public, parameter :: ntypes = 7 Number of different types of neutrals integer, public, parameter :: beam_ion = 1 Identifier for a beam ion integer, public, parameter :: thermal_ion = 2 Identifier for a thermal ion real(kind=Float64), public, parameter :: e_amu = 5.48579909070d-4 Atomic mass of an electron [amu] real(kind=Float64), public, parameter :: H1_amu = 1.007276466879d0 Atomic mass of Hydrogen-1 (protium) [amu] real(kind=Float64), public, parameter :: H2_amu = 2.013553212745d0 Atomic mass of Hydrogen-2 (deuterium) [amu] real(kind=Float64), public, parameter :: H3_amu = 3.01550071632d0 Atomic mass of Hydrogen-3 (tritium) [amu] real(kind=Float64), public, parameter :: He3_amu = 3.01602931914d0 Atomic mass of Helium-3 [amu] real(kind=Float64), public, parameter :: B5_amu = 10.81d0 Atomic mass of Boron [amu] real(kind=Float64), public, parameter :: C6_amu = 12.011d0 Atomic mass of Carbon [amu] real(kind=Float64), public, parameter :: mass_u = 1.660539040d-27 Atomic mass unit [kg] real(kind=Float64), public, parameter :: e0 = 1.60217733d-19 Electron charge [C] real(kind=Float64), public, parameter :: pi = 3.14159265358979323846264d0 Pi real(kind=Float64), public, parameter :: c0 = 2.99792458d+08 Speed of light [m/s] real(kind=Float64), public, parameter :: h_planck = 4.135667516d-15 Planck's constant [eV*s] real(kind=Float64), public, parameter :: lambda0 = 656.1d0 D-alpha emission line [nm] real(kind=Float64), public, parameter :: v2_to_E_per_amu = mass_u/(2.*e0*1.d3)*1.d-4 cm&#94;2/s&#94;2 to keV conversion factor real(kind=Float64), public, parameter :: log_10 = log(10.d0) Natural log of 10.0 integer, public, parameter :: n_stark = 15 Number of Stark lines real(kind=Float64), public, parameter, dimension(n_stark) :: stark_wavel = [-2.20200d-07, -1.65200d-07, -1.37700d-07, -1.10200d-07, -8.26400d-08, -5.51000d-08, -2.75600d-08, 0.00000d0, 2.75700d-08, 5.51500d-08, 8.27400d-08, 1.10300d-07, 1.38000d-07, 1.65600d-07, 2.20900d-07] Stark wavelengths [nm*m/V] real(kind=Float64), public, parameter, dimension(n_stark) :: stark_intens = [1.000d0, 18.00d0, 16.00d0, 1681.d0, 2304.d0, 729.0d0, 1936.d0, 5490.d0, 1936.d0, 729.0d0, 2304.d0, 1681.d0, 16.00d0, 18.00d0, 1.000d0] Stark Intensities integer, public, parameter, dimension(n_stark) :: stark_pi = [1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1] Pi line indicators integer, public, parameter, dimension(n_stark) :: stark_sigma = 1-stark_pi Sigma line indicators integer, public, parameter :: nlevs = 6 Number of atomic energy levels real(kind=Float64), public, dimension(ntypes) :: halo_iter_dens = 0.d0 Keeps track of how of each generations halo density integer, public :: nbi_outside = 0 Keeps track of how many beam neutrals do not hit the beam_grid integer, public :: istart = 1 Starting loop counter (1 if OpenMP, processor number if MPI) integer, public :: istep = 1 Loop step size (1 if OpenMP, number of processes if MPI) type( BeamGrid ), public, save :: beam_grid Variable containing beam grid definition type( InterpolationGrid ), public, save :: inter_grid Variable containing interpolation grid definition type( InterpolationGrid ), public, save :: pass_grid Variable containing passive neutral grid definition type( FastIonDistribution ), public, save :: fbm Variable containing the fast-ion distribution function type( FastIonParticles ), public, save :: particles Variable containing a MC fast-ion distribution type( Equilibrium ), public, save :: equil Variable containing the plasma parameters and fields type( NeutralBeam ), public, save :: nbi Variable containing the neutral beam geometry and settings type( AtomicTables ), public, save :: tables Variable containing the atomic tables type( NPAResults ), public, save :: npa Variable for storing the calculated active NPA results type( NPAResults ), public, save :: pnpa Variable for storing the calculated passive NPA results type( SpectralChords ), public, save :: spec_chords Variable containing the spectral system definition type( NPAChords ), public, save :: npa_chords Variable containing the NPA system definition type( SimulationInputs ), public, save :: inputs Variable containing the simulation inputs type( BirthProfile ), public, save :: birth Variable for storing the calculated birth profile type( NeutralDensity ), public, save :: neut Variable for storing the calculated beam density type( Spectra ), public, save :: spec Variable for storing the calculated spectra type( NeutronRate ), public, save :: neutron Variable for storing the neutron rate type( FIDAWeights ), public, save :: fweight Variable for storing the calculated FIDA weights type( NPAWeights ), public, save :: nweight Variable for storing the calculated NPA weights Interfaces public interface assignment(=) Allows for assigning Profiles , LocalProfiles , EMFields , LocalEMFields , FastIon , NPAParticle , and BirthParticle public subroutine pp_assign (p1, p2) Defines how to assign Profiles types to eachother Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 public subroutine lpp_assign (p1, p2) Defines how to assign a Profiles type to a LocalProfiles type Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 public subroutine plp_assign (p1, p2) Defines how to assign a LocalProfiles type to a Profiles type Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine lplp_assign (p1, p2) Defines how to assign LocalProfiles types to eachother Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine ff_assign (p1, p2) Defines how to assign EMFields types to eachother Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 public subroutine lff_assign (p1, p2) Defines how to assign a EMFields type to a LocalEMFields type Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 public subroutine flf_assign (p1, p2) Defines how to assign a LocalEMFields type to a EMFields type Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine lflf_assign (p1, p2) Defines how to assign LocalEMFields types to eachother Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine fast_ion_assign (p1, p2) Defines how to assign FastIon types to eachother Arguments Type Intent Optional Attributes Name type( FastIon ), intent(out) :: p1 type( FastIon ), intent(in) :: p2 public subroutine npa_part_assign (p1, p2) Defines how to assign NPAParticle types to eachother Arguments Type Intent Optional Attributes Name type( NPAParticle ), intent(out) :: p1 type( NPAParticle ), intent(in) :: p2 public subroutine birth_part_assign (p1, p2) Defines how to assign BirthParticle types to eachother Arguments Type Intent Optional Attributes Name type( BirthParticle ), intent(out) :: p1 type( BirthParticle ), intent(in) :: p2 public interface operator(+) Allows for adding Profiles , LocalProfiles , EMFields , and LocalEMFields public function pp_add (p1, p2) result(p3) Defines how to add two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_add (p1, p2) result(p3) Defines how to add two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ff_add (p1, p2) result(p3) Defines how to add two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function lflf_add (p1, p2) result(p3) Defines how to add two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) public interface operator(-) Allows for subtracting Profiles , LocalProfiles , EMFields , and LocalEMFields public function pp_subtract (p1, p2) result(p3) Defines how to subtract two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_subtract (p1, p2) result(p3) Defines how to subtract two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ff_subtract (p1, p2) result(p3) Defines how to subtract two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function lflf_subtract (p1, p2) result(p3) Defines how to subtract two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) public interface operator(*) Allows for multiplying Profiles , LocalProfiles , EMFields , and LocalEMFields by scalars public function sp_multiply (real_scalar, p1) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( Profiles ), intent(in) :: p1 Return Value type( Profiles ) public function ps_multiply (p1, real_scalar) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_multiply (p1, real_scalar) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function slp_multiply (real_scalar, p1) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalProfiles ), intent(in) :: p1 Return Value type( LocalProfiles ) public function sf_multiply (real_scalar, p1) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( EMFields ), intent(in) :: p1 Return Value type( EMFields ) public function fs_multiply (p1, real_scalar) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) public function lfs_multiply (p1, real_scalar) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields ) public function slf_multiply (real_scalar, p1) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalEMFields ), intent(in) :: p1 Return Value type( LocalEMFields ) public interface operator(/) Allows for dividing Profiles , LocalProfiles , EMFields , and LocalEMFields by scalars public function ps_divide (p1, real_scalar) result(p3) Defines how to divide Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_divide (p1, real_scalar) result(p3) Defines how to divide LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function fs_divide (p1, real_scalar) result(p3) Defines how to divide EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) public function lfs_divide (p1, real_scalar) result(p3) Defines how to divide LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields ) public interface interpol_coeff Calculates interpolation coefficients public subroutine interpol1D_coeff (xmin, dx, nx, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa value real(kind=Float64), intent(in) :: dx Absissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol1D_coeff_arr (x, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol2D_coeff (xmin, dx, nx, ymin, dy, ny, xout, yout, c, err) Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa real(kind=Float64), intent(in) :: dx Abscissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: ymin Minimum ordinate real(kind=Float64), intent(in) :: dy Ordinate spacing integer, intent(in) :: ny Number of ordinates points real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol2D_coeff_arr (x, y, xout, yout, c, err) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in), dimension(:) :: y Ordinate values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine cyl_interpol3D_coeff (rmin, dr, nr, zmin, dz, nz, phimin, dphi, nphi, rout, zout, phiout, c, err) Cylindrical interpolation coefficients and indicies for a 3D grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: rmin Minimum R real(kind=Float64), intent(in) :: dr R spacing integer, intent(in) :: nr Number of R points real(kind=Float64), intent(in) :: zmin Minimum Z real(kind=Float64), intent(in) :: dz Z spacing integer, intent(in) :: nz Number of Z points real(kind=Float64), intent(in) :: phimin Minimum phi real(kind=Float64), intent(in) :: dphi Phi spacing integer, intent(in) :: nphi Number of phi points real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate type( InterpolCoeffs3D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine cyl_interpol3D_coeff_arr (r, z, phi, rout, zout, phiout, c, err) Cylindrical interpolation coefficients and indicies for a 3D grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: r R values real(kind=Float64), intent(in), dimension(:) :: z Z values real(kind=Float64), intent(in), dimension(:) :: phi Phi values real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate type( InterpolCoeffs3D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public interface interpol Performs linear/bilinear/cylindrical interpolation public subroutine interpol1D_arr (x, y, xout, yout, err, coeffs) Performs linear interpolation on a uniform 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of y real(kind=Float64), intent(in), dimension(:) :: y Values at abscissa values x : y(x) real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(out) :: yout Interpolant: y(xout) integer, intent(out), optional :: err Error code type( InterpolCoeffs1D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol2D_arr (x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:) :: z Values at the abscissa/ordinates: z(x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out) :: zout Interpolant: z(xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol2D_2D_arr (x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid of 2D arrays z(:,:,x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:,:,:) :: z Values at the abscissa/ordinates: z(:,:,x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out), dimension(:,:) :: zout Interpolant: z(:,:,xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol3D_arr (r, z, phi, d, rout, zout, phiout, dout, err, coeffs) Performs cylindrical interpolation on a 3D grid f(r,z,phi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: r R values real(kind=Float64), intent(in), dimension(:) :: z Z values real(kind=Float64), intent(in), dimension(:) :: phi Phi values real(kind=Float64), intent(in), dimension(:,:,:) :: d Values at r,z,phi: d(r,z,phi) real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate real(kind=Float64), intent(out) :: dout Interpolant: d(rout,zout,phiout) integer, intent(out), optional :: err Error code type( InterpolCoeffs3D ), intent(in), optional :: coeffs Precomputed Interpolation Coefficients public subroutine interpol3D_2D_arr (r, z, phi, f, rout, zout, phiout, fout, err, coeffs) Performs cylindrical interpolation on a 3D grid of 2D arrays\n f(:,:,r,z,phi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: r R values real(kind=Float64), intent(in), dimension(:) :: z Z values real(kind=Float64), intent(in), dimension(:) :: phi Phi values real(kind=Float64), intent(in), dimension(:,:,:,:,:) :: f Values at r,z,phi: f(:,:,r,z,phi) real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate real(kind=Float64), intent(out), dimension(:,:) :: fout Interpolant: f(:,:,rout,zout,phiout) integer, intent(out), optional :: err Error code type( InterpolCoeffs3D ), intent(in), optional :: coeffs Precomputed Interpolation Coefficients Derived Types type, public :: InterpolCoeffs1D Linear Interpolation Coefficients and indices Components Type Visibility Attributes Name Initial integer, public :: i = 0 Index of position right before xout real(kind=Float64), public :: b1 = 0.d0 Coefficient for y(i) term real(kind=Float64), public :: b2 = 0.d0 Coefficient for y(i+1) term type, public :: InterpolCoeffs2D 2D Linear Interpolation Coefficients and indices Components Type Visibility Attributes Name Initial integer, public :: i = 0 Index of abscissa before xout integer, public :: j = 0 Index of ordinate before yout real(kind=Float64), public :: b11 = 0.d0 Coefficient for z(i,j) term real(kind=Float64), public :: b12 = 0.d0 Coefficient for z(i,j+1) term real(kind=Float64), public :: b21 = 0.d0 Coefficient for z(i+1,j) term real(kind=Float64), public :: b22 = 0.d0 Coefficient for z(i+1,j+1) term type, public :: InterpolCoeffs3D 3D Cylindrical Interpolation Coefficients and indices Components Type Visibility Attributes Name Initial integer, public :: i = 0 Index of R before rout integer, public :: j = 0 Index of Z before zout integer, public :: k = 0 Index of Phi before phiout real(kind=Float64), public :: b111 = 0.d0 Coefficient for z(i,j,k) term real(kind=Float64), public :: b121 = 0.d0 Coefficient for z(i,j+1,k) term real(kind=Float64), public :: b112 = 0.d0 Coefficient for z(i,j,k+1) term real(kind=Float64), public :: b122 = 0.d0 Coefficient for z(i,j+1,k+1) term real(kind=Float64), public :: b211 = 0.d0 Coefficient for z(i+1,j,k) term real(kind=Float64), public :: b212 = 0.d0 Coefficient for z(i+1,j,k+1) term real(kind=Float64), public :: b221 = 0.d0 Coefficient for z(i+1,j+1,k) term real(kind=Float64), public :: b222 = 0.d0 Coefficient for z(i+1,j+1,k+1) term type, public :: BeamGrid Defines a 3D grid for neutral beam calculations Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nx Number of cells in the x direction integer(kind=Int32), public :: ny Number of cells in the y direction integer(kind=Int32), public :: nz Number of cells in the z direction real(kind=Float64), public :: xmin Minimum x value real(kind=Float64), public :: xmax Maximum x value real(kind=Float64), public :: ymin Minimum y value real(kind=Float64), public :: ymax Maximum y value real(kind=Float64), public :: zmin Minimum z value real(kind=Float64), public :: zmax Maximum z value real(kind=Float64), public :: alpha Tait-Bryan angle for a rotation about z [radians] real(kind=Float64), public :: beta Tait-Bryan angle for a rotation about y' [radians] real(kind=Float64), public :: gamma Tait-Bryan angle for a rotation about x\" [radians] real(kind=Float64), public :: drmin Minimum cell spacing: min(dx,dy,dz) real(kind=Float64), public :: dv Cell volume [ cm&#94;3 ] real(kind=Float64), public :: volume Grid volume [ cm&#94;3 ] integer(kind=Int32), public :: ntrack Maximum number of cell for particle tracking integer(kind=Int32), public :: ngrid Number of cells integer(kind=Int32), public, dimension(3) :: dims Dimensions of beam grid real(kind=Float64), public, dimension(3) :: origin Origin of beam grid in machine coordinates real(kind=Float64), public, dimension(3) :: center Center of beam grid in beam coordinates real(kind=Float64), public, dimension(3) :: dr Cell spacings [dx, dy, dz] real(kind=Float64), public, dimension(3) :: lwh Grid [length(x), width(y), height(z)] real(kind=Float64), public, dimension(3,3) :: basis Beam grid basis for converting from beam coordinates(xyz)\nto machine coordinates(uvw): (\\uvw = B*xyz + origin) real(kind=Float64), public, dimension(3,3) :: inv_basis Inverse basis for reverse transformation: (\\xyz = B&#94;{-1}*(uvw - origin)) real(kind=Float64), public, dimension(:), allocatable :: xc x positions of cell centers real(kind=Float64), public, dimension(:), allocatable :: yc y positions of cell centers real(kind=Float64), public, dimension(:), allocatable :: zc z positions of cell centers type, public :: InterpolationGrid Defines a 3D R-Z-phi grid for interpolating plasma parameters and fields Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nr Number of Radii integer(kind=Int32), public :: nz Number of Z values integer(kind=Int32), public :: nphi Number of phi values real(kind=Float64), public :: dr Radial spacing [cm] real(kind=Float64), public :: dz Vertical spacing [cm] real(kind=Float64), public :: dphi Angular spacing [rad] real(kind=Float64), public :: da Grid element area [ cm&#94;2 ] real(kind=Float64), public :: dv dr dz dphi [ rad*cm&#94;2 ] integer(kind=Int32), public :: dims (3) Dimension of the interpolation grid real(kind=Float64), public, dimension(:), allocatable :: r Radii values [cm] real(kind=Float64), public, dimension(:), allocatable :: z Z values [cm] real(kind=Float64), public, dimension(:), allocatable :: phi Angular values [rad] integer(kind=Int32), public :: ntrack Maximum number of cells for particle tracking integer(kind=Int32), public :: ngrid Number of cells type, public :: Profiles Torodial symmetric plasma parameters at a given R-Z Components Type Visibility Attributes Name Initial real(kind=Float64), public :: dene = 0.d0 Electron density [ cm&#94;{-3} ] real(kind=Float64), public :: denp = 0.d0 Ion density [ cm&#94;{-3} ] real(kind=Float64), public :: denimp = 0.d0 Impurity density [ cm&#94;{-3} ] real(kind=Float64), public :: denf = 0.d0 Fast-ion density [ cm&#94;{-3} ] real(kind=Float64), public :: te = 0.d0 Electron temperature [kev] real(kind=Float64), public :: ti = 0.d0 Ion temperature [kev] real(kind=Float64), public :: zeff = 0.d0 Effective Nuclear Charge real(kind=Float64), public :: vr = 0.d0 Plasma rotation in radial direction real(kind=Float64), public :: vt = 0.d0 Plasma rotation in torodial/phi direction real(kind=Float64), public :: vz = 0.d0 Plasma rotation in z direction real(kind=Float64), public :: denn (nlevs) = 0.d0 Cold neutral density [ cm&#94;{-3} ] type, public, extends( Profiles ) :: LocalProfiles Plasma parameters at given position Components Type Visibility Attributes Name Initial real(kind=Float64), public :: dene = 0.d0 Electron density [ cm&#94;{-3} ] real(kind=Float64), public :: denp = 0.d0 Ion density [ cm&#94;{-3} ] real(kind=Float64), public :: denimp = 0.d0 Impurity density [ cm&#94;{-3} ] real(kind=Float64), public :: denf = 0.d0 Fast-ion density [ cm&#94;{-3} ] real(kind=Float64), public :: te = 0.d0 Electron temperature [kev] real(kind=Float64), public :: ti = 0.d0 Ion temperature [kev] real(kind=Float64), public :: zeff = 0.d0 Effective Nuclear Charge real(kind=Float64), public :: vr = 0.d0 Plasma rotation in radial direction real(kind=Float64), public :: vt = 0.d0 Plasma rotation in torodial/phi direction real(kind=Float64), public :: vz = 0.d0 Plasma rotation in z direction real(kind=Float64), public :: denn (nlevs) = 0.d0 Cold neutral density [ cm&#94;{-3} ] logical, public :: in_plasma = .False. Indicates whether plasma parameters are valid/known integer, public :: coords = 0 Indicates coordinate system of vectors. Beam grid (0), machine (1) and cylindrical (2) real(kind=Float64), public, dimension(3) :: pos = 0.d0 Position in beam grid coordinates real(kind=Float64), public, dimension(3) :: uvw = 0.d0 Position in machine coordinates real(kind=Float64), public, dimension(3) :: vrot = 0.d0 Plasma rotation in beam grid coordinates real(kind=Float64), public, dimension(3) :: vrot_uvw = 0.d0 Plasma rotation in machine coordinates type( InterpolCoeffs3D ), public :: b Cylindrical Interpolation Coefficients and indicies for interpolation at pos type, public :: EMFields Torodial symmetric electro-magnetic fields at given R-Z Components Type Visibility Attributes Name Initial real(kind=Float64), public :: br = 0.d0 Radial magnetic field [T] real(kind=Float64), public :: bt = 0.d0 Torodial magnetic field [T] real(kind=Float64), public :: bz = 0.d0 Vertical magnetic field [T] real(kind=Float64), public :: er = 0.d0 Radial electric field [V/m] real(kind=Float64), public :: et = 0.d0 Torodial electric field [V/m] real(kind=Float64), public :: ez = 0.d0 Vertical electric field [V/m] real(kind=Float64), public :: dbr_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbr_dphi = 0.d0 Angular derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbr_dz = 0.d0 Vertical derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbt_dr = 0.d0 Radial derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbt_dphi = 0.d0 Angular derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbt_dz = 0.d0 Vertical derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbz_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbz_dphi = 0.d0 Angular derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbz_dz = 0.d0 Vertical derivative of the vertical magnetic field [T/m] type, public, extends( EMFields ) :: LocalEMFields Electro-magnetic fields at given position Components Type Visibility Attributes Name Initial real(kind=Float64), public :: br = 0.d0 Radial magnetic field [T] real(kind=Float64), public :: bt = 0.d0 Torodial magnetic field [T] real(kind=Float64), public :: bz = 0.d0 Vertical magnetic field [T] real(kind=Float64), public :: er = 0.d0 Radial electric field [V/m] real(kind=Float64), public :: et = 0.d0 Torodial electric field [V/m] real(kind=Float64), public :: ez = 0.d0 Vertical electric field [V/m] real(kind=Float64), public :: dbr_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbr_dphi = 0.d0 Angular derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbr_dz = 0.d0 Vertical derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbt_dr = 0.d0 Radial derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbt_dphi = 0.d0 Angular derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbt_dz = 0.d0 Vertical derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbz_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbz_dphi = 0.d0 Angular derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbz_dz = 0.d0 Vertical derivative of the vertical magnetic field [T/m] logical, public :: in_plasma = .False. Indicates whether fields are valid/known integer, public :: coords = 0 Indicates coordinate system of vectors. Beam grid (0), machine (1) and cylindrical (2) real(kind=Float64), public :: b_abs = 0.d0 Magnitude of magnetic field real(kind=Float64), public :: e_abs = 0.d0 Magnitude of electrin field real(kind=Float64), public, dimension(3) :: pos = 0.d0 Position in beam grid coordinates real(kind=Float64), public, dimension(3) :: uvw = 0.d0 Position in machine coordinates real(kind=Float64), public, dimension(3) :: b_norm = 0.d0 Direction of magnetic field in beam grid coordinates real(kind=Float64), public, dimension(3) :: a_norm = 0.d0 Vector perpendicular to b_norm and c_norm real(kind=Float64), public, dimension(3) :: c_norm = 0.d0 Vector perpendicular to b_norm and a_norm real(kind=Float64), public, dimension(3) :: e_norm = 0.d0 Direction of electric field in beam grid coordinates type( InterpolCoeffs3D ), public :: b Cylindrical Interpolation Coefficients and indicies for interpolation at pos type, public :: Equilibrium MHD Equilbrium Components Type Visibility Attributes Name Initial type( EMFields ), public, dimension(:,:,:), allocatable :: fields Electro-magnetic fields at points defined in inter_grid type( Profiles ), public, dimension(:,:,:), allocatable :: plasma Plasma parameters at points defined in inter_grid real(kind=Float64), public, dimension(:,:,:), allocatable :: mask Indicates whether fields and plasma are well-defined at points defined in inter_grid type, public :: FastIonDistribution Defines a Guiding Center Fast-ion Distribution Function: F(E,p,R,Z,Phi) Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nenergy Number of energies integer(kind=Int32), public :: npitch Number of pitches integer(kind=Int32), public :: nr Number of radii integer(kind=Int32), public :: nz Number of z values integer(kind=Int32), public :: nphi Number of phi values real(kind=Float64), public :: dE Energy spacing [keV] real(kind=Float64), public :: dp Pitch spacing real(kind=Float64), public :: dr Radial spacing [cm] real(kind=Float64), public :: dz Z spacing [cm] real(kind=Float64), public :: dphi Angular spacing [rad] real(kind=Float64), public :: emin Minimum energy [keV] real(kind=Float64), public :: emax Maximum energy [keV] real(kind=Float64), public :: e_range Energy interval length [keV] real(kind=Float64), public :: pmin Minimum pitch real(kind=Float64), public :: pmax Maximum pitch real(kind=Float64), public :: p_range Pitch interval length real(kind=Float64), public :: rmin Minimum radius [cm] real(kind=Float64), public :: rmax Maximum radius [cm] real(kind=Float64), public :: r_range Radius interval length [cm] real(kind=Float64), public :: zmin Minimum Z [cm] real(kind=Float64), public :: zmax Maximum Z [cm] real(kind=Float64), public :: z_range Z interval length [cm] real(kind=Float64), public :: phimin Minimum Phi [rad] real(kind=Float64), public :: phimax Maximum Phi [rad] real(kind=Float64), public :: phi_range Phi interval length [rad] real(kind=Float64), public :: n_tot = 0.d0 Total Number of fast-ions real(kind=Float64), public, dimension(:), allocatable :: energy Energy values [keV] real(kind=Float64), public, dimension(:), allocatable :: pitch Pitch w.r.t. the magnetic field real(kind=Float64), public, dimension(:), allocatable :: r Radius [cm] real(kind=Float64), public, dimension(:), allocatable :: z Z [cm] real(kind=Float64), public, dimension(:), allocatable :: phi Angles [rad] real(kind=Float64), public, dimension(:,:,:), allocatable :: denf Fast-ion density defined on the inter_grid : denf(R,Z,Phi) real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: f Fast-ion distribution function defined on the inter_grid : F(E,p,R,Z,Phi) type, public :: FastIon Defines a fast-ion Components Type Visibility Attributes Name Initial logical, public :: beam_grid_cross_grid = .False. Indicates whether the fast-ion crosses the beam_grid real(kind=Float64), public :: r = 0.d0 Radial position of fast-ion [cm] real(kind=Float64), public :: phi = 0.d0 Angular position of fast-ion [rad] real(kind=Float64), public :: z = 0.d0 Vertical position of fast-ion [cm] real(kind=Float64), public :: beam_grid_phi_enter = 0.d0 Torodial/phi position where fast-ion enters the beam_grid [radians] real(kind=Float64), public :: delta_phi = 2*pi Angle subtended by the beam_grid at (r,z) real(kind=Float64), public :: energy = 0.d0 Energy [keV] real(kind=Float64), public :: pitch = 0.d0 Pitch w.r.t. the magnetic field real(kind=Float64), public :: vabs = 0.d0 Speed [cm/s] real(kind=Float64), public :: vr = 0.d0 Radial velocity [cm/s] real(kind=Float64), public :: vt = 0.d0 Torodial velocity [cm/s] real(kind=Float64), public :: vz = 0.d0 Z velocity [cm/s] real(kind=Float64), public :: weight = 0.d0 Particle weight: How many fast-ions does particle represent. integer(kind=Int32), public :: class = 0 Orbit class id type, public :: FastIonParticles Collection of fast-ion particles Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nparticle = 0 Number of particles integer(kind=Int32), public :: nclass = 1 Number of orbit classes logical, public :: axisym = .True. Indicates whether distribution function is axisymmetric type( FastIon ), public, dimension(:), allocatable :: fast_ion Fast-ion particles type, public :: NeutralBeam Defines a neutral beam with +x defined to be into the plasma Components Type Visibility Attributes Name Initial character(len=25), public :: name = '' Beam name integer, public :: shape Beam source shape 1=\"rectangular\", 2=\"circular\" real(kind=Float64), public :: widy Half width of source in y direction real(kind=Float64), public :: widz Half height of source in z direction real(kind=Float64), public :: focy Focal length in y direction real(kind=Float64), public :: focz Focal length in z direction real(kind=Float64), public :: einj NBI voltage  [kV] real(kind=Float64), public :: pinj NBI power    [MW] real(kind=Float64), public :: vinj NBI velocity [cm/s] real(kind=Float64), public :: alpha Z rotation not same as beam_grid alpha real(kind=Float64), public :: beta Tilt rotation not same as beam_grid beta real(kind=Float64), public, dimension(3) :: divy Energy dependent divergence in y direction real(kind=Float64), public, dimension(3) :: divz Energy dependent divergence in z direction real(kind=Float64), public, dimension(3) :: current_fractions Fractions of full, half, and third energy neutrals real(kind=Float64), public, dimension(3) :: src Position of source in beam grid coordinates [cm] real(kind=Float64), public, dimension(3) :: axis Beam centerline integer, public :: naperture Number of beam apertures integer, public, dimension(:), allocatable :: ashape Aperture shape 1=\"rectangular\", 2=\"circular\" real(kind=Float64), public, dimension(:), allocatable :: awidy Half width of the aperture(s) in y direction real(kind=Float64), public, dimension(:), allocatable :: awidz Half height of the aperture(s) in z direction real(kind=Float64), public, dimension(:), allocatable :: aoffy Horizontal (y) offset of the aperture(s) relative to the beam centerline [cm] real(kind=Float64), public, dimension(:), allocatable :: aoffz Vertical (z) offset of the aperture(s) relative to the beam centerline [cm] real(kind=Float64), public, dimension(:), allocatable :: adist Distance from the center of the beam source grid to the aperture(s) plane [cm] real(kind=Float64), public, dimension(3,3) :: basis Beam basis for converting from centerline coordinates to beam grid coordinates real(kind=Float64), public, dimension(3,3) :: inv_basis Inverse basis for reverse transfomation type, public :: AtomicCrossSection Defines a n/m-resolved atomic cross section table Components Type Visibility Attributes Name Initial integer, public :: nenergy = 1 Number of beam energies real(kind=Float64), public :: logemin = 0.d0 Log-10 minimum energy real(kind=Float64), public :: logemax = 0.d0 Log-10 maximum energy integer, public :: n_max = nlevs Number of initial atomic energy levels integer, public :: m_max = nlevs Number of final atomic energy levels real(kind=Float64), public :: dlogE = 0.d0 Log-10 energy spacing real(kind=Float64), public :: minlog_cross Log-10 minimum cross section real(kind=Float64), public, dimension(:,:,:), allocatable :: log_cross Log-10 cross sections type, public :: AtomicRates Defines a n/m-resolved atomic cross section table Components Type Visibility Attributes Name Initial integer, public :: nenergy = 1 Number of beam energies real(kind=Float64), public :: logemin = 0.d0 Log-10 minimum energy real(kind=Float64), public :: logemax = 0.d0 Log-10 maximum energy integer, public :: ntemp = 1 Number of target temperatures real(kind=Float64), public :: logtmin = 0.d0 Log-10 minimum temperature real(kind=Float64), public :: logtmax = 0.d0 Log-10 maximum temperature integer, public :: n_max = nlevs Number of initial atomic energy levels integer, public :: m_max = nlevs Number of final atomic energy levels real(kind=Float64), public :: dlogE = 0.d0 Log-10 energy spacing real(kind=Float64), public :: dlogT = 0.d0 Log-10 temperature spacing real(kind=Float64), public :: minlog_rate = 0.d0 Log-10 minimum reaction rate real(kind=Float64), public, dimension(2) :: ab = 0.d0 Atomic mass of beam and thermal ions respectively [amu] real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: log_rate Log-10 beam-target rates type, public :: AtomicTransitions Defines an atomic table for populating and de-populating reaction rates Components Type Visibility Attributes Name Initial integer, public :: nenergy = 1 Number of beam energies real(kind=Float64), public :: logemin = 0.d0 Log-10 minimum energy real(kind=Float64), public :: logemax = 0.d0 Log-10 maximum energy integer, public :: ntemp = 1 Number of target temperatures real(kind=Float64), public :: logtmin = 0.d0 Log-10 minimum temperature real(kind=Float64), public :: logtmax = 0.d0 Log-10 maximum temperature integer, public :: n_max = nlevs Number of initial atomic energy levels integer, public :: m_max = nlevs Number of final atomic energy levels real(kind=Float64), public :: dlogE = 0.d0 Log-10 energy spacing real(kind=Float64), public :: dlogT = 0.d0 Log-10 temperature spacing real(kind=Float64), public :: minlog_pop = 0.d0 Log-10 minimum reaction rates for populating transistions real(kind=Float64), public :: minlog_depop = 0.d0 Log-10 minimum reaction rates for de-populating transistions real(kind=Float64), public, dimension(2) :: ab = 0.d0 Atomic mass of beam and thermal ions respectively [amu] real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: log_pop Log-10 reaction rates for populating transistions real(kind=Float64), public, dimension(:,:,:,:), allocatable :: log_depop Log-10 reaction rates for de-populating transistions type, public :: NuclearRates Nuclear reaction rates Components Type Visibility Attributes Name Initial integer, public :: nbranch = 1 Number of reaction branches integer, public :: nenergy = 1 Number of beam energies real(kind=Float64), public :: logemin = 0.d0 Log-10 minimum energy real(kind=Float64), public :: logemax = 0.d0 Log-10 maximum energy integer, public :: ntemp = 1 Number of target temperatures real(kind=Float64), public :: logtmin = 0.d0 Log-10 minimum temperature real(kind=Float64), public :: logtmax = 0.d0 Log-10 maximum temperature real(kind=Float64), public :: dlogE = 0.d0 Log-10 energy spacing real(kind=Float64), public :: dlogT = 0.d0 Log-10 temperature spacing real(kind=Float64), public :: minlog_rate = 0.d0 Log-10 minimum reaction rate real(kind=Float64), public, dimension(2) :: bt_amu = 0.d0 Isotope mass of beam and thermal ions respectively [amu] real(kind=Float64), public, dimension(:,:,:), allocatable :: log_rate Log-10 reaction rates: log_rate(energy, temperature, branch) type, public :: AtomicTables Atomic tables for various types of interactions Components Type Visibility Attributes Name Initial type( AtomicCrossSection ), public :: H_H_cx_cross Hydrogen-Hydrogen charge exchange n/m-resolved cross sections type( AtomicRates ), public :: H_H_cx_rate Hydrogen-Hydrogen charge exchange n/m-resolved beam-target rates type( AtomicTransitions ), public :: H_H Hydrogen-Hydrogen atomic transitions type( AtomicTransitions ), public :: H_e Hydrogen-Electron atomic transitions type( AtomicTransitions ), public :: H_Aq Hydrogen-Impurity atomic transitions real(kind=Float64), public, dimension(nlevs,nlevs) :: einstein Einstein coefficients for spontaneous emission type( NuclearRates ), public :: D_D Deuterium-Deuterium reaction rates type, public :: LineOfSight Defines a line of sight Components Type Visibility Attributes Name Initial real(kind=Float64), public :: sigma_pi = 1.d0 Ratio of sigma to pi line intensity real(kind=Float64), public :: spot_size = 0.d0 Radius of spot size [cm] real(kind=Float64), public, dimension(3) :: lens = 0.d0 Lens location in beam grid coordinates real(kind=Float64), public, dimension(3) :: axis = 0.d0 Optical axis in beam grid coordinates real(kind=Float64), public, dimension(3) :: lens_uvw = 0.d0 Lens location in machine coordinates real(kind=Float64), public, dimension(3) :: axis_uvw = 0.d0 Optical axis in machine coordinates type, public :: LOSElement Defines a element of a line of sight and cell intersection Components Type Visibility Attributes Name Initial integer, public :: id Line of sight index real(kind=Float64), public :: length Length of crossing type, public :: LOSInters Defines the channels that intersect a cell Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 Number of channels that intersect type( LOSElement ), public, dimension(:), allocatable :: los_elem Array of crossing type, public :: SpectralChords Defines an spectral diagnostic system Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 Number of channels integer, public :: ncell = 0 Number of beam_grid cells with intersections integer, public :: cyl_ncell = 0 Number of pass_grid cells with intersections type( LineOfSight ), public, dimension(:), allocatable :: los Line of sight array real(kind=Float64), public, dimension(:), allocatable :: radius Radius of each line of sight type( LOSInters ), public, dimension(:,:,:), allocatable :: inter Array of LOS intersections with beam_grid type( LOSInters ), public, dimension(:,:,:), allocatable :: cyl_inter Array of LOS intersections with pass_grid integer, public, dimension(:), allocatable :: cell Linear indices of beam_grid that have intersections integer, public, dimension(:), allocatable :: cyl_cell Linear indices of pass_grid that have intersections type, public :: BoundedPlane Defines a plane with a circular or rectangular boundary Components Type Visibility Attributes Name Initial integer, public :: shape = 0 Boundary shape 1=\"Rectangular\", 2=\"circular\" real(kind=Float64), public :: hh = 0.d0 Half height of boundary [cm] real(kind=Float64), public :: hw = 0.d0 Half width of boundary [cm] real(kind=Float64), public, dimension(3) :: origin = 0.d0 Origin of plane in machine coordinates real(kind=Float64), public, dimension(3,3) :: basis = 0.d0 Basis vectors basis(:,1) = u_1 is plane normal real(kind=Float64), public, dimension(3,3) :: inv_basis = 0.d0 Inverse basis type, public :: NPADetector Defines a NPA detector Components Type Visibility Attributes Name Initial type( BoundedPlane ), public :: detector Detecting plane of NPA detector type( BoundedPlane ), public :: aperture Aperture plane of NPA detector type, public :: NPAProbability Type to contain the probability of hitting a NPA detector Components Type Visibility Attributes Name Initial real(kind=Float64), public :: p = 0.d0 Hit probability real(kind=Float64), public :: pitch = -2.d0 Pitch real(kind=Float64), public, dimension(3) :: eff_rd = 0.d0 Effective position of detector real(kind=Float64), public, dimension(3) :: dir = 0.d0 Trajectory direction type, public :: NPAChords Defines a NPA system Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 Number of channels type( NPADetector ), public, dimension(:), allocatable :: det NPA detector array real(kind=Float64), public, dimension(:), allocatable :: radius Radius [cm] logical, public, dimension(:,:,:), allocatable :: hit Indicates whether a particle can hit any NPA detector from a grid cell: hit(x,y,z) type( NPAProbability ), public, dimension(:,:,:,:), allocatable :: phit Probability of hitting a detector from a grid cell: phit(x,y,z,chan) type, public :: NPAParticle Defines a NPA particle Components Type Visibility Attributes Name Initial integer, public :: detector = 0 Detector NPA particle hit integer(kind=Int32), public :: class = 0 Orbit class id real(kind=Float64), public :: xi = 0.d0 Initial x position real(kind=Float64), public :: yi = 0.d0 Initial y position real(kind=Float64), public :: zi = 0.d0 Initial z position real(kind=Float64), public :: xf = 0.d0 Final x position real(kind=Float64), public :: yf = 0.d0 Final y position real(kind=Float64), public :: zf = 0.d0 Final z position real(kind=Float64), public :: weight = 0.d0 NPA particle weight real(kind=Float64), public :: energy = 0.d0 Birth Energy [keV] real(kind=Float64), public :: pitch = 0.d0 Birth Pitch type, public :: NPAResults MC NPA result structure Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nchan = 0 Number of NPA channels integer(kind=Int32), public :: npart = 0 Number of particles that hit a detector integer(kind=Int32), public :: nmax = 1000000 Maximum allowed number of particles grows if necessary integer(kind=Int32), public :: nenergy = 122 Number of energy values type( NPAParticle ), public, dimension(:), allocatable :: part Array of NPA particles real(kind=Float64), public, dimension(:), allocatable :: energy Energy array [keV] real(kind=Float64), public, dimension(:,:,:), allocatable :: flux Neutral particle flux: flux(energy,chan, orbit_type) [neutrals/(s*dE)] type, public :: BirthParticle Defines a Birth particle Components Type Visibility Attributes Name Initial integer, public :: neut_type = 0 Birth type (1=Full, 2=Half, 3=Third) integer(kind=Int32), public, dimension(3) :: ind = 0 Initial beam_grid indices real(kind=Float64), public, dimension(3) :: ri = 0.d0 Initial position in beam grid coordinates [cm] real(kind=Float64), public, dimension(3) :: vi = 0.d0 Initial velocity in beam grid coordinates [cm/s] real(kind=Float64), public, dimension(3) :: ri_gc = 0.d0 Initial guiding-center position in beam grid coordinates [cm] real(kind=Float64), public :: weight = 0.d0 NPA particle weight [fast-ions/s] real(kind=Float64), public :: energy = 0.d0 Birth Energy [keV] real(kind=Float64), public :: pitch = 0.d0 Birth Pitch w.r.t. the magnetic field type, public :: BirthProfile Birth profile structure Components Type Visibility Attributes Name Initial integer, public :: cnt = 1 Particle counter type( BirthParticle ), public, dimension(:), allocatable :: part Array of birth particles real(kind=Float64), public, dimension(:,:,:,:), allocatable :: dens Birth density: dens(neutral_type,x,y,z) [fast-ions/(s*cm&#94;3)] type, public :: Spectra Spectra storage structure Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:), allocatable :: brems Bremsstruhlung: brems(lambda,chan) real(kind=Float64), public, dimension(:,:), allocatable :: full Full energy beam emission: full(lambda,chan) real(kind=Float64), public, dimension(:,:), allocatable :: half Half energy beam emission: half(lambda,chan) real(kind=Float64), public, dimension(:,:), allocatable :: third Third energy beam emission: third(lambda,chan) real(kind=Float64), public, dimension(:,:), allocatable :: dcx Direct CX emission: dcx(lambda,chan) real(kind=Float64), public, dimension(:,:), allocatable :: halo Thermal halo emission: halo(lambda,chan) real(kind=Float64), public, dimension(:,:), allocatable :: cold Cold D-alpha emission: cold(lambda,chan) real(kind=Float64), public, dimension(:,:,:), allocatable :: fida Active FIDA emission: fida(lambda,chan,orbit_type) real(kind=Float64), public, dimension(:,:,:), allocatable :: pfida Passive FIDA emission: pfida(lambda,chan,orbit_type) type, public :: NeutronRate Neutron storage structure Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:), allocatable :: rate Neutron rate: rate(orbit_type) [neutrons/sec] real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: weight Neutron rate weight: weight(E,p,R,Z,Phi) real(kind=Float64), public, dimension(:,:,:), allocatable :: emis Neutron emissivity: emis(R,Z,Phi) type, public :: NeutralDensity Neutral density structure Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:,:,:), allocatable :: full Full energy neutral density: full(lev,x,y,z) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: half Half energy neutral density: half(lev,x,y,z) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: third Third energy neutral density: third(lev,x,y,z) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: dcx Direct CX neutral density: dcx(lev,x,y,z) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: halo Thermal halo neutral density: dens(lev,x,y,z) type, public :: FIDAWeights FIDA weights structure Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:,:), allocatable :: mean_f Estimate of mean fast-ion distribution function \"seen\" by LOS: mean_f(E,p,chan) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: weight FIDA weight function: weight(lambda,E,p,chan) type, public :: NPAWeights NPA weights structure Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: attenuation Attenuation fraction: attenuation(E,x,y,z,chan) real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: cx Charge Exchange reaction rates: cx(E,x,y,z,chan) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: emissivity Emissivity: emissivity(x,y,z,chan) [neutrals/(s*dV)] real(kind=Float64), public, dimension(:,:,:), allocatable :: weight NPA weight function: weight(E,p,chan) [neutrals/(s fast-ion dE*dP)] real(kind=Float64), public, dimension(:,:), allocatable :: flux Neutral particle flux: flux(E,chan) [neutrals/(s*dE)] type, public :: SimulationInputs Simulation settings structure Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: shot_number Shot Number real(kind=Float64), public :: time Shot time [s] character(len=charlim), public :: runid = '' FIDASIM run ID character(len=charlim), public :: result_dir = '' Result directory character(len=charlim), public :: tables_file = '' Atomic tables file character(len=charlim), public :: geometry_file = '' FIDASIM input file containing geometric quantities character(len=charlim), public :: equilibrium_file = '' FIDASIM input file containing the plasma parameters and fields character(len=charlim), public :: distribution_file = '' FIDASIM input file containing the fast-ion distribution character(len=charlim), public :: neutrals_file = '' FIDASIM output/input file containing beam neutral density.\n Used when load_neutrals is set. integer, public :: seed Random number generator seed integer(kind=Int64), public :: n_fida Number of Active FIDA mc markers integer(kind=Int64), public :: n_pfida Number of Passive FIDA mc markers integer(kind=Int64), public :: n_npa Number of Passiv NPA mc markers integer(kind=Int64), public :: n_pnpa Number of Passive NPA mc markers integer(kind=Int64), public :: n_nbi Number of neutral beam mc markers integer(kind=Int64), public :: n_dcx Number of direct charge exchange (DCX) mc markers integer(kind=Int64), public :: n_halo Number of halo mc markers integer(kind=Int64), public :: n_birth Number of birth particles per n_nbi integer(kind=Int32), public :: calc_spec Calculate spectra: 0 = off, 1=on integer(kind=Int32), public :: calc_beam Calculate beam densities: 0 = off, 1=on integer(kind=Int32), public :: calc_nbi_dens Calculate neutral beam density: 0 = off, 1=on integer(kind=Int32), public :: calc_dcx_dens Calculate Direct Charge Exchange (DCX) density: 0 = off, 1=on integer(kind=Int32), public :: calc_halo_dens Calculate Thermal Halo density: 0 = off, 1=on integer(kind=Int32), public :: calc_brems Calculate bremmstruhlung: 0 = off, 1=on integer(kind=Int32), public :: calc_bes Calculate NBI: 0 = off, 1=on integer(kind=Int32), public :: calc_dcx Calculate DCX: 0 = off, 1=on integer(kind=Int32), public :: calc_halo Calculate Halo: 0 = off, 1=on integer(kind=Int32), public :: calc_cold Calculate Cold D-alpha: 0 = off, 1=on integer(kind=Int32), public :: calc_fida Calculate Active FIDA: 0 = off, 1=on integer(kind=Int32), public :: calc_pfida Calculate Passive FIDA: 0 = off, 1=on integer(kind=Int32), public :: tot_spectra Total number of spectral switches on integer(kind=Int32), public :: load_neutrals Load neutrals from file: 0 = off, 1=on integer(kind=Int32), public :: calc_npa Calculate Active NPA: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: calc_pnpa Calculate Passive NPA: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: calc_fida_wght Calculate FIDA weight: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: calc_npa_wght Calculate NPA weights: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: calc_birth Calculate birth profile: 0 = off, 1=on integer(kind=Int32), public :: calc_neutron Calculate neutron flux: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: flr FLR correction: 0=off, 1=1st order(vxb/omega), 2=2nd order correction integer(kind=Int32), public :: split Split signals by fast ion class: 0=off, 1=on integer(kind=Int32), public :: verbose real(kind=Float64), public :: ab Atomic mass of beam neutrals integer(kind=Int32), public :: impurity_charge Impurity proton number real(kind=Float64), public :: ai Atomic mass of thermal ions integer(kind=Int32), public :: dist_type Type of fast-ion distribution integer(kind=Int32), public :: nlambda Number of wavelength to calculate real(kind=Float64), public :: dlambda Wavelength spacing [nm] real(kind=Float64), public :: lambdamin Minimum wavelength [nm] real(kind=Float64), public :: lambdamax Maximum wavelength [nm] integer(kind=Int32), public :: ne_wght Number of energies in weight functions integer(kind=Int32), public :: np_wght Number of pitches in weight functions integer(kind=Int32), public :: nphi_wght Number of gyro-angles to average over in weight functions integer(kind=Int32), public :: nlambda_wght Number of wavelength to calculate in weight functions real(kind=Float64), public :: emax_wght Maximum energy in weight functions [keV] real(kind=Float64), public :: lambdamin_wght Minimum wavelength in weight functions [nm] real(kind=Float64), public :: lambdamax_wght Maximum wavelength in weight functions [nm] type, public :: ParticleTrack Stores properties seen when traveling through a 3D grid Components Type Visibility Attributes Name Initial real(kind=Float64), public :: time = 0.d0 Time/distance/... in cell real(kind=Float64), public :: flux = 0.d0 Flux/density/... in cell integer(kind=Int32), public, dimension(3) :: ind = 0 Indices of cell real(kind=Float64), public, dimension(3) :: pos = 0.d0 Midpoint of track in cell [cm] type, public :: GyroSurface Surface containing the fast-ion velocity vectors for all values of the\n gyro-angle. It takes the form of a hyperboloid (x(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(cos(\\gamma + \\pi/2) - \\omega_i t sin(\\gamma + \\pi/2)) (y(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(sin(\\gamma + \\pi/2) + \\omega_i t cos(\\gamma + \\pi/2)) (z(\\gamma,t) = \\alpha \\omega_i \\rm{pitch} t where \\gamma is the gyro-angle, \\omega_i is the ion\n gyro-frequency and \\alpha = V/\\omega_i Components Type Visibility Attributes Name Initial real(kind=Float64), public :: v = 0.d0 Particle speed real(kind=Float64), public :: omega = 0.d0 Ion gyro-frequency real(kind=Float64), public, dimension(3) :: axes = 0.d0 Semi-axes of the hyperboloid, i.e. a, b, c coefficients real(kind=Float64), public, dimension(3) :: center = 0.d0 Center of the gyrosurface real(kind=Float64), public, dimension(3,3) :: A = 0.d0 Coefficients of quartic surface i.e. basis*diagm(1/a&#94;2,1/b&#94;2,1/c&#94;2)*basis' real(kind=Float64), public, dimension(3,3) :: basis = 0.d0 Basis of coordinate system of gyrosurface Functions public function pp_add (p1, p2) result(p3) Defines how to add two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function pp_subtract (p1, p2) result(p3) Defines how to subtract two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_add (p1, p2) result(p3) Defines how to add two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function lplp_subtract (p1, p2) result(p3) Defines how to subtract two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ps_multiply (p1, real_scalar) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) public function sp_multiply (real_scalar, p1) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( Profiles ), intent(in) :: p1 Return Value type( Profiles ) public function ps_divide (p1, real_scalar) result(p3) Defines how to divide Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_multiply (p1, real_scalar) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function slp_multiply (real_scalar, p1) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalProfiles ), intent(in) :: p1 Return Value type( LocalProfiles ) public function lps_divide (p1, real_scalar) result(p3) Defines how to divide LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function ff_add (p1, p2) result(p3) Defines how to add two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function ff_subtract (p1, p2) result(p3) Defines how to subtract two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function fs_multiply (p1, real_scalar) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) public function sf_multiply (real_scalar, p1) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( EMFields ), intent(in) :: p1 Return Value type( EMFields ) public function fs_divide (p1, real_scalar) result(p3) Defines how to divide EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) public function lflf_add (p1, p2) result(p3) Defines how to add two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) public function lflf_subtract (p1, p2) result(p3) Defines how to subtract two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) public function lfs_multiply (p1, real_scalar) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields ) public function slf_multiply (real_scalar, p1) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalEMFields ), intent(in) :: p1 Return Value type( LocalEMFields ) public function lfs_divide (p1, real_scalar) result(p3) Defines how to divide LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields ) public function approx_eq (x, y, tol) result(a) Inexact equality comparison: x ~= y true if abs(x-y) <= tol else false Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: x First value in comparison real(kind=Float64), intent(in) :: y Second value in comparison real(kind=Float64), intent(in) :: tol Equality tolerance Return Value logical public function approx_ge (x, y, tol) result(a) Inexact greater than or equal to comparison: x >~= y Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: x First value in comparison real(kind=Float64), intent(in) :: y Second value in comparison real(kind=Float64), intent(in) :: tol Equality tolerance Return Value logical public function approx_le (x, y, tol) result(a) Inexact less then or equal to comparison: x <~= y Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: x First value in comparison real(kind=Float64), intent(in) :: y Second value in comparison real(kind=Float64), intent(in) :: tol Equality tolerance Return Value logical public function cross_product (u, v) result(s) Calculates the cross product of two vectors: u x v Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: u real(kind=Float64), intent(in), dimension(3) :: v Return Value real(kind=Float64),\n  dimension(3) public function in_boundary (bplane, p) result(in_b) Indicator function for determining if a point on a plane is within the plane boundary Arguments Type Intent Optional Attributes Name type( BoundedPlane ), intent(in) :: bplane Plane with boundary real(kind=Float64), intent(in), dimension(3) :: p Point on plane Return Value logical public function in_gyro_surface (gs, p) result(in_gs) Indicator function for determining if a point is inside the gyro_surface Arguments Type Intent Optional Attributes Name type( GyroSurface ), intent(in) :: gs Gyro-surface real(kind=Float64), intent(in), dimension(3) :: p Point Return Value logical public function in_grid (xyz) result(ing) Determines if a position pos is in the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: xyz Position in beam grid coordinates [cm] Return Value logical Indicates whether the position is in the beam grid public function in_passive_grid (uvw) result(ing) Determines if a position pos is in the pass_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: uvw Position in machine coordinates [cm] Return Value logical Indicates whether the position is in the passive neutral grid public function gyro_radius (fields, energy, pitch) result(gyro_rad) Calculates mean gyro-radius Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: fields Electromagnetic fields at guiding center real(kind=Float64), intent(in) :: energy Energy of particle real(kind=Float64), intent(in) :: pitch Particle pitch w.r.t the magnetic field Return Value real(kind=Float64) Mean gyro-radius Subroutines public subroutine print_banner () Prints FIDASIM banner Arguments None public subroutine fast_ion_assign (p1, p2) Defines how to assign FastIon types to eachother Arguments Type Intent Optional Attributes Name type( FastIon ), intent(out) :: p1 type( FastIon ), intent(in) :: p2 public subroutine npa_part_assign (p1, p2) Defines how to assign NPAParticle types to eachother Arguments Type Intent Optional Attributes Name type( NPAParticle ), intent(out) :: p1 type( NPAParticle ), intent(in) :: p2 public subroutine birth_part_assign (p1, p2) Defines how to assign BirthParticle types to eachother Arguments Type Intent Optional Attributes Name type( BirthParticle ), intent(out) :: p1 type( BirthParticle ), intent(in) :: p2 public subroutine pp_assign (p1, p2) Defines how to assign Profiles types to eachother Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 public subroutine lpp_assign (p1, p2) Defines how to assign a Profiles type to a LocalProfiles type Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 public subroutine plp_assign (p1, p2) Defines how to assign a LocalProfiles type to a Profiles type Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine lplp_assign (p1, p2) Defines how to assign LocalProfiles types to eachother Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine ff_assign (p1, p2) Defines how to assign EMFields types to eachother Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 public subroutine lff_assign (p1, p2) Defines how to assign a EMFields type to a LocalEMFields type Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 public subroutine flf_assign (p1, p2) Defines how to assign a LocalEMFields type to a EMFields type Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine lflf_assign (p1, p2) Defines how to assign LocalEMFields types to eachother Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine read_inputs () Reads input namelist file and stores the results into inputs , nbi , and beam_grid 20 for suffixes and seperators e.g. /, _npa.h5, ... Arguments None public subroutine make_beam_grid () Makes [[libfida:beam_grid] from user defined inputs Arguments None public subroutine make_passive_grid () Makes [[libfida:pass_grid] from user defined inputs Arguments None public subroutine make_diagnostic_grids () Makes [[libfida:pass_grid] from user defined inputs, and stores the quantities in spec_chords and npa_chords Arguments None public subroutine read_beam () Reads neutral beam geometry and stores the quantities in nbi Arguments None public subroutine read_chords () Reads the spectral geometry and stores the quantities in spec_chords Arguments None public subroutine read_npa () Reads the NPA geometry and stores the quantities in npa_chords Arguments None public subroutine read_equilibrium () Reads in the interpolation grid, plasma parameters, and fields\n and stores the quantities in inter_grid and equil Arguments None public subroutine read_f (fid, error) Reads in the fast-ion distribution function and stores the quantities in fbm Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: fid HDF5 file ID integer, intent(out) :: error Error code public subroutine read_mc (fid, error) Reads in a MC particle fast-ion distribution and puts them in particles Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: fid HDF5 file ID integer, intent(out) :: error Error code public subroutine read_distribution () Reads in the fast-ion distribution Arguments None public subroutine read_atomic_cross (fid, grp, cross) Reads in a cross section table from file\n and puts it into a AtomicCrossSection type Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid HDF5 file ID character(len=*), intent(in) :: grp HDF5 group to read from type( AtomicCrossSection ), intent(inout) :: cross Atomic cross section public subroutine read_atomic_rate (fid, grp, b_amu, t_amu, rates) Reads in a atomic rate table from file\n and puts it into a AtomicRates type Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid HDF5 file ID character(len=*), intent(in) :: grp HDF5 group to read from real(kind=Float64), intent(in), dimension(2) :: b_amu Atomic masses of \"beam\" species (beam ion and thermal ion) real(kind=Float64), intent(in) :: t_amu Atomic mass of \"target\" species (thermal ion) type( AtomicRates ), intent(inout) :: rates Atomic reaction rates public subroutine read_atomic_transitions (fid, grp, b_amu, t_amu, rates) Reads in a atomic transitions table from file\n and puts it into a AtomicTransitions type Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid HDF5 file ID character(len=*), intent(in) :: grp HDF5 group to read from real(kind=Float64), intent(in), dimension(2) :: b_amu Atomic masses of \"beam\" species (beam ion and thermal ion) real(kind=Float64), intent(in) :: t_amu Atomic mass of \"target\" species (thermal ion) type( AtomicTransitions ), intent(inout) :: rates Atomic transitions public subroutine read_nuclear_rates (fid, grp, rates) Reads in a nuclear reaction rates table from file\n and puts it into a NuclearRates type Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid HDF5 file ID character(len=*), intent(in) :: grp HDF5 group to read from type( NuclearRates ), intent(inout) :: rates Atomic reaction rates public subroutine read_tables () Reads in atomic tables from file and stores them in tables Arguments None public subroutine write_beam_grid (id, error) Write beam_grid to an HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file ID integer, intent(out) :: error Error code public subroutine write_birth_profile () Writes birth to a HDF5 file Arguments None public subroutine write_neutrals () Writes neut to a HDF5 file Arguments None public subroutine write_npa () Writes npa to a HDF5 file Arguments None public subroutine write_spectra () Writes Spectra to a HDF5 file Arguments None public subroutine write_neutrons () Writes neutron to a HDF5 file Arguments None public subroutine write_fida_weights () Writes fweight to a HDF5 file Arguments None public subroutine write_npa_weights () Writes nweight to a HDF5 file Arguments None public subroutine read_neutrals () Reads neutral density from file and puts it in neut Arguments None public subroutine tb_zyx (alpha, beta, gamma, basis, inv_basis) Creates active rotation matrix for z-y'-x\" rotation given Tait-Bryan angles Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: alpha Angle of rotation about z real(kind=Float64), intent(in) :: beta Angle of rotation about y' real(kind=Float64), intent(in) :: gamma Angle of rotation about x\" real(kind=Float64), intent(out), dimension(3,3) :: basis Rotation matrix/basis for transforming from rotated to non-rotated coordinates real(kind=Float64), intent(out), optional dimension(3,3) :: inv_basis Inverse basis for reverse transformation public subroutine line_basis (r0, v0, basis, inv_basis) Calculates basis from a line with +x in the direction of line Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Starting point of line [cm] real(kind=Float64), intent(in), dimension(3) :: v0 Direction of line real(kind=Float64), intent(out), dimension(3,3) :: basis Basis for transforming from line coordinates to cartesian real(kind=Float64), intent(out), optional dimension(3,3) :: inv_basis Inverse basis for the reverse transformation cartesian to line public subroutine plane_basis (center, redge, tedge, basis, inv_basis) Calculates basis from 3 points on a plane with +z being the plane normal Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: center Plane origin real(kind=Float64), intent(in), dimension(3) :: redge Right edge of plane real(kind=Float64), intent(in), dimension(3) :: tedge Top edge of plane real(kind=Float64), intent(out), dimension(3,3) :: basis Basis for transforming from plane to cartesian coordinates real(kind=Float64), intent(out), optional dimension(3,3) :: inv_basis Inverse basis for the reverse transformation cartesian to plane public subroutine line_plane_intersect (l0, l, p0, n, p, t) Calculates the intersection of a line and a plane Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: l0 Point on line real(kind=Float64), intent(in), dimension(3) :: l Ray of line real(kind=Float64), intent(in), dimension(3) :: p0 Point on plane real(kind=Float64), intent(in), dimension(3) :: n Normal vector of plane real(kind=Float64), intent(out), dimension(3) :: p Line-plane intersect point real(kind=Float64), intent(out) :: t \"time\" to intersect public subroutine line_cylinder_intersect (l0, l, p0, p, t) Calculates the intersection of a line and a cylinder Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: l0 Point on line real(kind=Float64), intent(in), dimension(3) :: l Ray of line real(kind=Float64), intent(in), dimension(3) :: p0 Point on cylinder real(kind=Float64), intent(out), dimension(3) :: p Line-cylinder intersect point real(kind=Float64), intent(out) :: t \"time\" to intersect public subroutine boundary_edge (bplane, bedge, nb) Returns 3 x nb array containing points along the BoundedPlane's boundary edge Arguments Type Intent Optional Attributes Name type( BoundedPlane ), intent(in) :: bplane Bounded plane real(kind=Float64), intent(out), dimension(:,:) :: bedge Boundary edge points of bounded plane integer, intent(out) :: nb Number of points in boundary edge public subroutine gyro_surface (fields, energy, pitch, gs) Calculates the surface of all possible trajectories Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: fields Electromagnetic fields at guiding center real(kind=Float64), intent(in) :: energy Energy of particle real(kind=Float64), intent(in) :: pitch Particle pitch w.r.t the magnetic field type( GyroSurface ), intent(out) :: gs Gyro-surface public subroutine line_gyro_surface_intersect (r0, v0, gs, t) Calculates the times of intersection of a line and a gyro-surface Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Point on line real(kind=Float64), intent(in), dimension(3) :: v0 Direction of line type( GyroSurface ), intent(in) :: gs Gyro-surface real(kind=Float64), intent(out), dimension(2) :: t \"time\" to intersect public subroutine gyro_surface_coordinates (gs, p, u) Calculates the parametric coordinates, u , of point p on the gyro_surface Arguments Type Intent Optional Attributes Name type( GyroSurface ), intent(in) :: gs Gyro_surface real(kind=Float64), intent(in), dimension(3) :: p Point on gyro_surface real(kind=Float64), intent(out), dimension(2) :: u Parametric coordinates (gyro-angle, t) public subroutine gyro_trajectory (gs, theta, ri, vi) Calculate particle trajectory for a given gyro-angle and gyro-surface Arguments Type Intent Optional Attributes Name type( GyroSurface ), intent(in) :: gs Gyro-Surface real(kind=Float64), intent(in) :: theta Gyro-angle real(kind=Float64), dimension(3) :: ri Particle position real(kind=Float64), dimension(3) :: vi Particle Velocity public subroutine gyro_range (b, gs, gyrange, nrange) Calculates the range(s) of gyro-angles that would land within a bounded plane Arguments Type Intent Optional Attributes Name type( BoundedPlane ), intent(in) :: b Bounded Plane type( GyroSurface ), intent(in) :: gs Gyro-surface real(kind=Float64), intent(out), dimension(2,4) :: gyrange (theta, dtheta) values integer, intent(out) :: nrange Number of ranges. 1 <= nrange <= 4 public subroutine npa_gyro_range (ichan, gs, gyrange, nrange) Calculates range of gyro-angles that would hit the NPA detector Arguments Type Intent Optional Attributes Name integer, intent(in) :: ichan Index of NPA detector type( GyroSurface ), intent(in) :: gs real(kind=Float64), intent(out), dimension(2,4) :: gyrange integer, intent(out) :: nrange public subroutine hit_npa_detector (r0, v0, d_index, rd, det) Routine to check if a particle will hit a NPA detector Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Starting point of particle real(kind=Float64), intent(in), dimension(3) :: v0 Particle velocity integer, intent(out) :: d_index Index of NPA detector. Zero if particle doesn't hit real(kind=Float64), intent(out), optional dimension(3) :: rd Point where particle hit detector integer, intent(in), optional :: det Index of NPA detector to check public subroutine xyz_to_uvw (xyz, uvw) Convert beam coordinate xyz to machine coordinate uvw Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: xyz real(kind=Float64), intent(out), dimension(3) :: uvw public subroutine xyz_to_cyl (xyz, cyl) Convert beam coordinate xyz to cylindrical coordinate cyl Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: xyz real(kind=Float64), intent(out), dimension(3) :: cyl public subroutine uvw_to_xyz (uvw, xyz) Convert machine coordinate uvw to beam coordinate xyz Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: uvw real(kind=Float64), intent(out), dimension(3) :: xyz public subroutine cyl_to_uvw (cyl, uvw) Convert cylindrical coordinate cyl to machine coordinate uvw Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: cyl real(kind=Float64), intent(out), dimension(3) :: uvw public subroutine cyl_to_xyz (cyl, xyz) Convert cylindrical coordinate cyl to beam coordinate xyz Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: cyl real(kind=Float64), intent(out), dimension(3) :: xyz public subroutine uvw_to_cyl (uvw, cyl) Convert machine coordinate uvw to cylindrical coordinate cyl Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: uvw real(kind=Float64), intent(out), dimension(3) :: cyl public subroutine grid_intersect (r0, v0, length, r_enter, r_exit, center_in, lwh_in, passive) Calculates a particles intersection length with the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Initial position of particle [cm] real(kind=Float64), intent(in), dimension(3) :: v0 Velocity of particle [cm/s] real(kind=Float64), intent(out) :: length Intersection length [cm] real(kind=Float64), intent(out), dimension(3) :: r_enter Point where particle enters real(kind=Float64), intent(out), dimension(3) :: r_exit Point where particle exits real(kind=Float64), intent(in), optional dimension(3) :: center_in Alternative grid center real(kind=Float64), intent(in), optional dimension(3) :: lwh_in Alternative grid [length,width,height] logical, intent(in), optional :: passive Calculates a particles intersection length with the pass_grid public subroutine circle_grid_intersect (r0, e1, e2, radius, beam_grid_phi_enter, beam_grid_phi_exit) Calculates the intersection arclength of a circle with the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Position of center enter of the circle in beam grid coordinates [cm] real(kind=Float64), intent(in), dimension(3) :: e1 Unit vector pointing towards (R, 0) (r,phi) position of the circle in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: e2 Unit vector pointing towards (R, pi/2) (r,phi) position of the circle in beam grid coordinates real(kind=Float64), intent(in) :: radius Radius of circle [cm] real(kind=Float64), intent(out) :: beam_grid_phi_enter Phi value where the circle entered the beam_grid [rad] real(kind=Float64), intent(out) :: beam_grid_phi_exit Phi value where the circle exits the beam_grid [rad] public subroutine get_indices (pos, ind) Find closests beam_grid indices ind to position pos Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position [cm] integer(kind=Int32), intent(out), dimension(3) :: ind Closest indices to position public subroutine get_passive_grid_indices (pos, ind, input_coords) Find closest pass_grid indices ind to position pos Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position [cm] integer(kind=Int32), intent(out), dimension(3) :: ind Closest indices to position integer, intent(in), optional :: input_coords Indicates coordinate system of pos . Beam grid (0), machine (1) and cylindrical (2) public subroutine get_plasma_extrema (r0, v0, extrema, x0, y0) Returns extrema points where line(s) parametrized by r0 and v0 intersect the plasma boudnary Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:) :: r0 Arrays the define line(s) in machine coordinates real(kind=Float64), intent(in), dimension(:,:) :: v0 Arrays the define line(s) in machine coordinates real(kind=Float64), intent(out), dimension(2,3) :: extrema Minimum and maximumm R, Z, and Phi points real(kind=Float64), intent(in), optional dimension(:) :: x0 Additional x and y points to consider real(kind=Float64), intent(in), optional dimension(:) :: y0 Additional x and y points to consider public subroutine get_position (ind, pos, input_coords) Get position pos given indices ind Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind Indices real(kind=Float64), intent(out), dimension(3) :: pos Position in beam_grid coordinates [cm] integer, intent(in), optional :: input_coords Indicates coordinate system of ind . Beam grid (0) and cylindrical (2) public subroutine track (rin, vin, tracks, ntrack, los_intersect) Computes the path of a neutral through the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: rin Initial position of particle real(kind=Float64), intent(in), dimension(3) :: vin Initial velocity of particle type( ParticleTrack ), intent(inout), dimension(:) :: tracks Array of ParticleTrack type integer(kind=Int32), intent(out) :: ntrack Number of cells that a particle crosses logical, intent(out), optional :: los_intersect Indicator whether particle intersects a LOS in spec_chords public subroutine track_cylindrical (rin, vin, tracks, ntrack, los_intersect) Computes the path of a neutral through the pass_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: rin Initial position of particle real(kind=Float64), intent(in), dimension(3) :: vin Initial velocity of particle type( ParticleTrack ), intent(inout), dimension(:) :: tracks Array of ParticleTrack type integer(kind=Int32), intent(out) :: ntrack Number of cells that a particle crosses logical, intent(out), optional :: los_intersect Indicator whether particle intersects a LOS in spec_chords public subroutine interpol1D_coeff (xmin, dx, nx, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa value real(kind=Float64), intent(in) :: dx Absissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol1D_coeff_arr (x, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol2D_coeff (xmin, dx, nx, ymin, dy, ny, xout, yout, c, err) Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa real(kind=Float64), intent(in) :: dx Abscissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: ymin Minimum ordinate real(kind=Float64), intent(in) :: dy Ordinate spacing integer, intent(in) :: ny Number of ordinates points real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol2D_coeff_arr (x, y, xout, yout, c, err) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in), dimension(:) :: y Ordinate values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine cyl_interpol3D_coeff (rmin, dr, nr, zmin, dz, nz, phimin, dphi, nphi, rout, zout, phiout, c, err) Cylindrical interpolation coefficients and indicies for a 3D grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: rmin Minimum R real(kind=Float64), intent(in) :: dr R spacing integer, intent(in) :: nr Number of R points real(kind=Float64), intent(in) :: zmin Minimum Z real(kind=Float64), intent(in) :: dz Z spacing integer, intent(in) :: nz Number of Z points real(kind=Float64), intent(in) :: phimin Minimum phi real(kind=Float64), intent(in) :: dphi Phi spacing integer, intent(in) :: nphi Number of phi points real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate type( InterpolCoeffs3D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine cyl_interpol3D_coeff_arr (r, z, phi, rout, zout, phiout, c, err) Cylindrical interpolation coefficients and indicies for a 3D grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: r R values real(kind=Float64), intent(in), dimension(:) :: z Z values real(kind=Float64), intent(in), dimension(:) :: phi Phi values real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate type( InterpolCoeffs3D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol1D_arr (x, y, xout, yout, err, coeffs) Performs linear interpolation on a uniform 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of y real(kind=Float64), intent(in), dimension(:) :: y Values at abscissa values x : y(x) real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(out) :: yout Interpolant: y(xout) integer, intent(out), optional :: err Error code type( InterpolCoeffs1D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol2D_arr (x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:) :: z Values at the abscissa/ordinates: z(x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out) :: zout Interpolant: z(xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol2D_2D_arr (x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid of 2D arrays z(:,:,x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:,:,:) :: z Values at the abscissa/ordinates: z(:,:,x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out), dimension(:,:) :: zout Interpolant: z(:,:,xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol3D_arr (r, z, phi, d, rout, zout, phiout, dout, err, coeffs) Performs cylindrical interpolation on a 3D grid f(r,z,phi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: r R values real(kind=Float64), intent(in), dimension(:) :: z Z values real(kind=Float64), intent(in), dimension(:) :: phi Phi values real(kind=Float64), intent(in), dimension(:,:,:) :: d Values at r,z,phi: d(r,z,phi) real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate real(kind=Float64), intent(out) :: dout Interpolant: d(rout,zout,phiout) integer, intent(out), optional :: err Error code type( InterpolCoeffs3D ), intent(in), optional :: coeffs Precomputed Interpolation Coefficients public subroutine interpol3D_2D_arr (r, z, phi, f, rout, zout, phiout, fout, err, coeffs) Performs cylindrical interpolation on a 3D grid of 2D arrays\n f(:,:,r,z,phi) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: r R values real(kind=Float64), intent(in), dimension(:) :: z Z values real(kind=Float64), intent(in), dimension(:) :: phi Phi values real(kind=Float64), intent(in), dimension(:,:,:,:,:) :: f Values at r,z,phi: f(:,:,r,z,phi) real(kind=Float64), intent(in) :: rout R value to interpolate real(kind=Float64), intent(in) :: zout Z value to interpolate real(kind=Float64), intent(in) :: phiout Phi value to interpolate real(kind=Float64), intent(out), dimension(:,:) :: fout Interpolant: f(:,:,rout,zout,phiout) integer, intent(out), optional :: err Error code type( InterpolCoeffs3D ), intent(in), optional :: coeffs Precomputed Interpolation Coefficients public subroutine in_plasma (xyz, inp, input_coords, coeffs, uvw_out) Indicator subroutine to determine if a position is in a region where\n the plasma parameter and fields are valid/known Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: xyz Position in beam coordinates logical, intent(out) :: inp Indicates whether plasma parameters and fields are valid/known integer, intent(in), optional :: input_coords Indicates coordinate system of xyz. Beam grid (0), machine (1) and cylindrical (2) type( InterpolCoeffs3D ), intent(out), optional :: coeffs Interpolation coefficients used in calculation real(kind=Float64), intent(out), optional dimension(3) :: uvw_out Position in machine coordinates public subroutine get_plasma (plasma, pos, ind, input_coords, output_coords) Gets plasma parameters at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(out) :: plasma Plasma parameters at pos / ind real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices integer(kind=Int32), intent(in), optional :: input_coords Indicates coordinate system of inputs. Beam grid (0), machine (1) and cylindrical (2) integer(kind=Int32), intent(in), optional :: output_coords Indicates coordinate system of outputs. Beam grid (0), machine (1) and cylindrical (2) public subroutine calc_perp_vectors (b, a, c) Calculates normalized vectors that are perpendicular to b\n such that a x c = b_norm Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: b real(kind=Float64), intent(out), dimension(3) :: a real(kind=Float64), intent(out), dimension(3) :: c public subroutine get_fields (fields, pos, ind, input_coords, output_coords) Gets electro-magnetic fields at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(out) :: fields Electro-magnetic fields at pos / ind real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices integer(kind=Int32), intent(in), optional :: input_coords Indicates coordinate system of inputs. Beam grid (0), machine (1) and cylindrical (2) integer(kind=Int32), intent(in), optional :: output_coords Indicates coordinate system of outputs. Beam grid (0), machine (1) and cylindrical (2) public subroutine get_distribution (fbeam, denf, pos, ind, coeffs) Gets Guiding Center distribution at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:,:) :: fbeam Guiding Center Fast-ion distribution at pos / ind : F(E,p) real(kind=Float64), intent(out) :: denf Guiding Center Fast-ion density at pos / ind [fast-ions/cm&#94;3] real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices type( InterpolCoeffs3D ), intent(in), optional :: coeffs Precomputed interpolation coefficients public subroutine get_ep_denf (energy, pitch, denf, pos, ind, coeffs) Get guiding center fast-ion density at given energy and pitch\n at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: energy Energy [keV] real(kind=Float64), intent(in) :: pitch Pitch real(kind=Float64), intent(out) :: denf Fast-ion density [fast-ions/(cm&#94;3 dE dp)] real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices type( InterpolCoeffs3D ), intent(in), optional :: coeffs Precomputed interpolation coefficients public subroutine store_neutrals (ind, neut_type, dens, vn, store_iter) Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind beam_grid indices integer, intent(in) :: neut_type Neutral type real(kind=Float64), intent(in), dimension(:) :: dens Neutral density [neutrals/cm&#94;3] real(kind=Float64), intent(in), dimension(3) :: vn Neutral particle velocity [cm/s] logical, intent(in), optional :: store_iter Store DCX/Halo iteration density in halo_iter_dens public subroutine store_births (ind, neut_type, dflux) Store birth particles/density in birth Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind beam_grid indices integer(kind=Int32), intent(in) :: neut_type Neutral type real(kind=Float64), intent(in) :: dflux Deposited flux public subroutine store_npa (det, ri, rf, vn, flux, orbit_class, passive) Store NPA particles in npa Arguments Type Intent Optional Attributes Name integer, intent(in) :: det Detector/Channel Number real(kind=Float64), intent(in), dimension(3) :: ri Birth position in beam coordinates [cm] real(kind=Float64), intent(in), dimension(3) :: rf Detector position in beam coordinates [cm] real(kind=Float64), intent(in), dimension(3) :: vn Particle velocity [cm/s] real(kind=Float64), intent(in) :: flux Neutral flux [neutrals/s] integer, intent(in), optional :: orbit_class Orbit class ID logical, intent(in), optional :: passive Indicates whether npa particle is passive public subroutine bb_cx_rates (denn, vi, vn, rates) Get beam-beam neutralization/cx rates Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(nlevs) :: denn Neutral density [cm&#94;-3] real(kind=Float64), intent(in), dimension(3) :: vi Ion velocity [cm/s] real(kind=Float64), intent(in), dimension(3) :: vn Neutral velocity [cm/s] real(kind=Float64), intent(out), dimension(nlevs) :: rates Reaction rates [1/s] public subroutine bt_cx_rates (plasma, denn, vi, i_type, rates) Get beam-target neutralization/cx rates Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma Plasma parameters real(kind=Float64), intent(in), dimension(nlevs) :: denn Neutral density [cm&#94;-3] real(kind=Float64), intent(in), dimension(3) :: vi Ion velocity [cm/s] integer, intent(in) :: i_type Ion type real(kind=Float64), intent(out), dimension(nlevs) :: rates Reaction rates [1/s] public subroutine get_neutron_rate (plasma, eb, rate) Gets neutron rate for a beam with energy eb interacting with a target plasma Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma Plasma Paramters real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(out) :: rate Neutron reaction rate [1/s] public subroutine get_beam_cx_rate (ind, pos, v_ion, i_type, types, rate_tot) Get probability of a thermal ion charge exchanging with types neutrals Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind beam_grid indices real(kind=Float64), intent(in), dimension(3) :: pos Interaction position in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: v_ion Ion velocity [cm/s] integer, intent(in) :: i_type Ion type integer(kind=Int32), intent(in), dimension(:) :: types Neutral types real(kind=Float64), intent(out), dimension(nlevs) :: rate_tot Total charge exchange rate [1/s] public subroutine get_rate_matrix (plasma, i_type, eb, rmat) Gets rate matrix for use in colrad Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma Plasma parameters integer, intent(in) :: i_type Ion type real(kind=Float64), intent(in) :: eb Ion energy [keV] real(kind=Float64), intent(out), dimension(nlevs,nlevs) :: rmat Rate matrix public subroutine colrad (plasma, i_type, vn, dt, states, dens, photons) Evolve density of states in time dt via collisional radiative model Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma Plasma parameters integer, intent(in) :: i_type Ion/Neutral type (beam,thermal) real(kind=Float64), intent(in), dimension(:) :: vn Neutral velocitiy [cm/s] real(kind=Float64), intent(in) :: dt Time interval [s] real(kind=Float64), intent(inout), dimension(:) :: states Density of states real(kind=Float64), intent(out), dimension(nlevs) :: dens Density of neutrals real(kind=Float64), intent(out) :: photons Emitted photons(3->2) public subroutine attenuate (ri, rf, vi, states, dstep_in) Attenuate states along a trajectory Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: ri Initial position in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: rf Final position in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: vi Initial velocity of neutral real(kind=Float64), intent(inout), dimension(nlevs) :: states Density of states real(kind=Float64), intent(in), optional :: dstep_in Step length [cm] public subroutine doppler_stark (vecp, vi, fields, lambda) Calculates doppler shift and stark split wavelengths Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: vecp Vector directing towards optical head real(kind=Float64), intent(in), dimension(3) :: vi Particle velocity type( LocalEMFields ), intent(in) :: fields Electro-magnetic fields real(kind=Float64), intent(out), dimension(n_stark) :: lambda Wavelengths [nm] public subroutine spectrum (vecp, vi, fields, sigma_pi, photons, dlength, lambda, intensity) Calculates doppler shift, stark splitting, and intensities Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: vecp Vector directing towards optical head real(kind=Float64), intent(in), dimension(3) :: vi Particle velocity type( LocalEMFields ), intent(in) :: fields Electro-magnetic fields real(kind=Float64), intent(in) :: sigma_pi Sigma-pi ratio real(kind=Float64), intent(in) :: photons Photon density from colrad real(kind=Float64), intent(in) :: dlength LOS intersection length with beam_grid cell particle is in real(kind=Float64), intent(out), dimension(n_stark) :: lambda Wavelengths [nm] real(kind=Float64), intent(out), dimension(n_stark) :: intensity Spectra intensities [Ph/(s cm&#94;2 starkline)] public subroutine store_photons (pos, vi, photons, spectra, passive) Store photons in spectra Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position of neutral real(kind=Float64), intent(in), dimension(3) :: vi Velocitiy of neutral [cm/s] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] real(kind=Float64), intent(inout), dimension(:,:) :: spectra logical, intent(in), optional :: passive Indicates whether photon is passive FIDA public subroutine store_bes_photons (pos, vi, photons, neut_type) Store BES photons in Spectra Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position of neutral in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: vi Velocitiy of neutral [cm/s] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] integer, intent(in) :: neut_type Neutral type (full,half,third,halo) public subroutine store_fida_photons (pos, vi, photons, orbit_class, passive) Store fida photons in Spectra Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position of neutral in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: vi Velocitiy of neutral [cm/s] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] integer, intent(in), optional :: orbit_class Orbit class ID logical, intent(in), optional :: passive Indicates whether photon is passive FIDA public subroutine store_neutrons (rate, orbit_class) Store neutron rate in neutron Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: rate Neutron rate [neutrons/sec] integer, intent(in), optional :: orbit_class Orbit class ID public subroutine store_fw_photons_at_chan (ichan, eind, pind, vp, vi, fields, dlength, sigma_pi, denf, photons) Store FIDA weight photons in fweight for a specific channel Arguments Type Intent Optional Attributes Name integer, intent(in) :: ichan Channel index integer, intent(in) :: eind Energy index integer, intent(in) :: pind Pitch index real(kind=Float64), intent(in), dimension(3) :: vp Vector pointing toward optical head real(kind=Float64), intent(in), dimension(3) :: vi Velocity of neutral [cm/s] type( LocalEMFields ), intent(in) :: fields Electro-magnetic fields real(kind=Float64), intent(in) :: dlength LOS intersection length with beam_grid cell particle is in real(kind=Float64), intent(in) :: sigma_pi Sigma-pi ratio for channel real(kind=Float64), intent(in) :: denf Fast-ion density [cm&#94;-3] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] public subroutine store_fw_photons (eind, pind, pos, vi, denf, photons) Store FIDA weight photons in fweight Arguments Type Intent Optional Attributes Name integer, intent(in) :: eind Energy index integer, intent(in) :: pind Pitch index real(kind=Float64), intent(in), dimension(3) :: pos Position of neutral real(kind=Float64), intent(in), dimension(3) :: vi Velocity of neutral [cm/s] real(kind=Float64), intent(in) :: denf Fast-ion density [cm&#94;-3] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] public subroutine get_nlaunch (nr_markers, papprox, nlaunch) Sets the number of MC markers launched from each beam_grid cell Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: nr_markers Approximate total number of markers to launch real(kind=Float64), intent(in), dimension(:,:,:), target :: papprox beam_grid cell weights integer(kind=Int32), intent(out), dimension(:,:,:) :: nlaunch Number of mc markers to launch for each cell: nlaunch(x,y,z) public subroutine get_nlaunch_pass_grid (nr_markers, papprox, nlaunch) Sets the number of MC markers launched from each pass_grid cell Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: nr_markers Approximate total number of markers to launch real(kind=Float64), intent(in), dimension(:,:,:) :: papprox pass_grid cell weights integer(kind=Int32), intent(out), dimension(:,:,:) :: nlaunch Number of mc markers to launch for each cell: nlaunch(r,z,phi) public subroutine pitch_to_vec (pitch, gyroangle, fields, vi_norm) Calculates velocity vector from pitch, gyroangle and fields Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: pitch Pitch real(kind=Float64), intent(in) :: gyroangle Gyroangle [radians] type( LocalEMFields ), intent(in) :: fields Electromagnetic fields real(kind=Float64), intent(out), dimension(3) :: vi_norm Normalized velocity vector public subroutine gyro_step (vi, fields, r_gyro) Calculates gyro-step Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: vi Ion velocity type( LocalEMFields ), intent(in) :: fields Electro-magnetic fields real(kind=Float64), intent(out), dimension(3) :: r_gyro Gyro-step\n Gyro-radius vector from particle position to guiding center public subroutine gyro_correction (fields, energy, pitch, rp, vp, theta_in) Calculates gyro correction for Guiding Center MC distribution calculation Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: fields Electromagnetic fields at guiding center real(kind=Float64), intent(in) :: energy Energy of particle real(kind=Float64), intent(in) :: pitch Particle pitch w.r.t the magnetic field real(kind=Float64), intent(out), dimension(3) :: rp Particle position real(kind=Float64), intent(out), dimension(3) :: vp Particle velocity real(kind=Float64), intent(in), optional :: theta_in Gyro-angle public subroutine mc_fastion (ind, fields, eb, ptch, denf) Samples a Guiding Center Fast-ion distribution function at a given beam_grid index Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind beam_grid index type( LocalEMFields ), intent(out) :: fields Electromagnetic fields at the guiding center real(kind=Float64), intent(out) :: eb Energy of the fast ion real(kind=Float64), intent(out) :: ptch Pitch of the fast ion real(kind=Float64), intent(out) :: denf Fast-ion density at guiding center public subroutine mc_fastion_pass_grid (ind, fields, eb, ptch, denf, output_coords) Samples a Guiding Center Fast-ion distribution function at a given pass_grid index Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind pass_grid index type( LocalEMFields ), intent(out) :: fields Electromagnetic fields at the guiding center real(kind=Float64), intent(out) :: eb Energy of the fast ion real(kind=Float64), intent(out) :: ptch Pitch of the fast ion real(kind=Float64), intent(out) :: denf Fast-ion density at guiding center integer, intent(in), optional :: output_coords Indicates coordinate system of fields . Beam grid (0), machine (1) and cylindrical (2) public subroutine mc_halo (ind, vhalo, ri, plasma_in) Sample thermal Maxwellian distribution at beam_grid indices ind Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind beam_grid indices real(kind=Float64), intent(out), dimension(3) :: vhalo Velocity [cm/s] real(kind=Float64), intent(out), optional dimension(3) :: ri Position in beam_grid cell type( LocalProfiles ), intent(in), optional :: plasma_in Plasma parameters public subroutine mc_nbi (vnbi, efrac, rnbi, err) Generates a neutral beam particle trajectory Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(3) :: vnbi Velocity [cm/s] integer, intent(in) :: efrac Beam neutral type (1,2,3) real(kind=Float64), intent(out), dimension(3) :: rnbi Starting position on beam_grid logical, intent(out) :: err Error Code public subroutine mc_nbi_cell (ind, neut_type, vnbi, weight) Generates a neutral beam velocity vector\n that passes through cell at ind with weight weight Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind Cell index integer, intent(in) :: neut_type Neutral Type (1=Full,2=Half,3=Third) real(kind=Float64), intent(out), dimension(3) :: vnbi Normalized Velocity real(kind=Float64), intent(out) :: weight Weigth/probability of trajectory public subroutine ndmc () Calculates neutral beam deposition and spectra Arguments None public subroutine bremsstrahlung () Calculates bremsstrahlung Arguments None public subroutine dcx () Calculates Direct Charge Exchange (DCX) neutral density and spectra Arguments None public subroutine halo () Calculates halo neutral density and spectra Arguments None public subroutine nbi_spec () Calculates approximate neutral beam emission (full, half, third)\n from user supplied neutrals file Arguments None public subroutine dcx_spec () Calculates DCX emission from user supplied neutrals file Arguments None public subroutine halo_spec () Calculates halo emission from user supplied neutrals file Arguments None public subroutine cold_spec () Calculates cold D-alpha emission Arguments None public subroutine fida_f () Calculate Active FIDA emission using a Fast-ion distribution function F(E,p,r,z) Arguments None public subroutine pfida_f () Calculate Passive FIDA emission using a Fast-ion distribution function F(E,p,r,z) Arguments None public subroutine fida_mc () Calculate Active FIDA emission using a Monte Carlo Fast-ion distribution Arguments None public subroutine pfida_mc () Calculate Passive FIDA emission using a Monte Carlo Fast-ion distribution Arguments None public subroutine npa_f () Calculate Active NPA flux using a fast-ion distribution function F(E,p,r,z) Arguments None public subroutine pnpa_f () Calculate Passive NPA flux using a fast-ion distribution function F(E,p,r,z) Arguments None public subroutine npa_mc () Calculate Active NPA flux using a Monte Carlo fast-ion distribution Arguments None public subroutine pnpa_mc () Calculate Passive NPA flux using a Monte Carlo fast-ion distribution Arguments None public subroutine neutron_f () Calculate neutron emission rate using a fast-ion distribution function F(E,p,r,z) Arguments None public subroutine neutron_mc () Calculate neutron flux using a Monte Carlo Fast-ion distribution Arguments None public subroutine fida_weights_mc () Calculates FIDA weights Arguments None public subroutine fida_weights_los () Calculates LOS averaged FIDA weights Arguments None public subroutine npa_weights () Calculates NPA weights Arguments None","tags":"","loc":"module/libfida.html","title":"libfida – FIDASIM"},{"text":"A basic libary for calculating matrix eigen-decompositions and inverses Used by module~~eigensystem~~UsedByGraph module~eigensystem eigensystem module~libfida libfida module~libfida->module~eigensystem program~fidasim fidasim program~fidasim->module~libfida Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables long float double ONE TWO ZERO XMACH_EPS MAXIT Functions comabs outerprod Subroutines RSWAP balance balback elmhes elmtrans Comdiv hqrvec hqr2 eigen swap ludcmp lubksb matinv linsolve Variables Type Visibility Attributes Name Initial integer, public, parameter :: long = kind(int(1)) integer, public, parameter :: float = kind(1.e0) integer, public, parameter :: double = kind(1.d0) real(kind=double), public, parameter :: ONE = 1.d0 real(kind=double), public, parameter :: TWO = 2.d0 real(kind=double), public, parameter :: ZERO = 0.d0 real(kind=double), public, parameter :: XMACH_EPS = 2.22d-16 integer, public, parameter :: MAXIT = 50 Functions public function comabs (ar, ai) Calculates absolute value of a complex number a Arguments Type Intent Optional Attributes Name real(kind=double) :: ar Real part of a real(kind=double) :: ai Imaginary part of a Return Value real(kind=double) Absolute value of a public function outerprod (a, b) Calculates outer product Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: a real(kind=double), intent(in), dimension(:) :: b Return Value real(kind=double),\n  dimension(size(a),size(b)) Subroutines public subroutine RSWAP (a, b) Swaps values a and b Arguments Type Intent Optional Attributes Name real(kind=double) :: a real(kind=double) :: b public subroutine balance (n, mat, scal, low, high) Balances the matrix so that the rows with zero entries\noff the diagonal are isolated and the remaining columns and rows\nare resized to have one norm close to 1. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of mat real(kind=double) :: mat (0:n-1,0:n-1) n x n scaled matrix real(kind=double) :: scal (0:n-1) Contains isolated eigenvalue in the positions 0- low and high - n -1\n its other components contain the scaling factors for transforming mat integer, intent(out) :: low integer, intent(out) :: high public subroutine balback (n, low, high, scal, eivec) Reverses the balancing of balance for the eigenvectors Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of matrix integer, intent(in) :: low First nonzero row integer, intent(in) :: high Last nonzero row real(kind=double), intent(in) :: scal (0:n-1) Scaling data from balance real(kind=double), intent(inout) :: eivec (0:n-1,0:n-1) public subroutine elmhes (n, low, high, mat, perm) Transforms the matrix mat to upper Hessenberg form. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of mat integer, intent(in) :: low First nonzero row integer, intent(in) :: high Last nonzero row real(kind=double), intent(inout) :: mat (0:n-1,0:n-1) is stored in the lower triangle integer, intent(out) :: perm (0:n-1) Permutation vector for elmtrans public subroutine elmtrans (n, low, high, mat, perm, h) Elmtrans copies the Hessenberg matrix stored in mat to h Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of mat integer, intent(in) :: low First nonzero row integer, intent(in) :: high Last nonzero row real(kind=double), intent(in) :: mat (0:n-1,0:n-1) n x n input matrix integer, intent(in) :: perm (0:n-1) Permutation data from elmhes real(kind=double), intent(out) :: h (0:n-1,0:n-1) Hessenberg matrix public subroutine Comdiv (ar, ai, br, bi, cr, ci, rc) Performs complex division c = a / b Arguments Type Intent Optional Attributes Name real(kind=double) :: ar Real part of numerator real(kind=double) :: ai Imaginary part of numerator real(kind=double) :: br Real part of denominator real(kind=double) :: bi Imaginary part of denominator real(kind=double) :: cr Real part of quotient real(kind=double) :: ci Imaginary part of quotient integer :: rc return code public subroutine hqrvec (n, low, high, h, wr, wi, eivec, rc) Computes the eigenvectors for the eigenvalues found in hqr2 Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double) :: h (0:n-1,0:n-1) real(kind=double), intent(in) :: wr (0:n-1) real(kind=double), intent(in) :: wi (0:n-1) real(kind=double), intent(out) :: eivec (0:n-1,0:n-1) integer :: rc public subroutine hqr2 (n, low, high, h, wr, wi, eivec, cnt, rc) Computes the eigenvalues and (if vec = True) the eigenvectors\nof an  n * n upper Hessenberg matrix. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double), intent(out) :: h (0:n-1,0:n-1) real(kind=double), intent(out) :: wr (0:n-1) real(kind=double), intent(out) :: wi (0:n-1) real(kind=double), intent(out) :: eivec (0:n-1,0:n-1) integer, intent(out) :: cnt (0:n-1) integer, intent(out) :: rc public subroutine eigen (n, matrix, eigvec, eigval) The subroutine eigen  determines all eigenvalues and (if desired)\nall eigenvectors of a real square  n * n  matrix via the QR method\nin the version of Martin, Parlett, Peters, Reinsch and Wilkinson. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=double), intent(in), dimension(n,n) :: matrix real(kind=double), intent(out), dimension(n,n) :: eigvec real(kind=double), intent(out), dimension(n) :: eigval public subroutine swap (a, b) Swap arrays a and b Arguments Type Intent Optional Attributes Name real(kind=double), intent(inout), dimension(:) :: a real(kind=double), intent(inout), dimension(:) :: b public subroutine ludcmp (a, indx, d) Calculates LU decomposition Arguments Type Intent Optional Attributes Name real(kind=double), intent(inout), dimension(:,:) :: a integer, intent(out), dimension(:) :: indx real(kind=double), intent(out) :: d public subroutine lubksb (a, indx, b) Does LU back substitution Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:,:) :: a integer, intent(in), dimension(:) :: indx real(kind=double), intent(inout), dimension(:) :: b public subroutine matinv (a, b) Matrix inversion with LU-decomposition Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:,:) :: a real(kind=double), intent(out), dimension(:,:) :: b public subroutine linsolve (a, b, x) Solve linear equations A * X = B Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:,:) :: a real(kind=double), intent(in), dimension(:) :: b real(kind=double), intent(out), dimension(:) :: x","tags":"","loc":"module/eigensystem.html","title":"eigensystem – FIDASIM"},{"text":"Utilities for parallel random number generation and sparse arrays Uses omp_lib iso_c_binding module~~utilities~~UsesGraph module~utilities utilities omp_lib omp_lib module~utilities->omp_lib iso_c_binding iso_c_binding module~utilities->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~utilities~~UsedByGraph module~utilities utilities program~generate_tables generate_tables program~generate_tables->module~utilities module~libfida libfida module~libfida->module~utilities program~fidasim fidasim program~fidasim->module~libfida Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables rng Interfaces randu randn randind_cdf randind sparse deriv Derived Types rng_type SparseArray Functions sub2ind rng_seed get_rng rng_uniform rng_normal get_value time norm2 Subroutines ind2sub rng_init cumsum Variables Type Visibility Attributes Name Initial type( rng_type ), public, dimension(:), allocatable :: rng Interfaces public interface randu private subroutine randu_arr(randomu) Generate an array of uniformally-distributed random deviates Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:) :: randomu Array of uniform random deviates private subroutine randu_r_arr(r, randomu) Generate an array of uniformally-distributed random deviates Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(out), dimension(:) :: randomu Array of uniform random deviates public interface randn private subroutine randn_arr(randomn) Generate an array of normally-distributed random deviates Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:) :: randomn Array of normal random deviates private subroutine randn_r_arr(r, randomn) Generate an array of normally-distributed random deviates Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(out), dimension(:) :: randomn Array of normal random deviates public interface randind_cdf Procedure for generating a random array index/subscripts private subroutine randind_r_cdf_1(r, cdf, randomi) Generate an array of random indices of an 1D array distributed according to cdf Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(in), dimension(:) :: cdf 1D array of index weights integer, intent(out), dimension(:) :: randomi Random indices private subroutine randind_cdf_1(cdf, randomi) Generate an array of random indices of an 1D array distributed according to cdf Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: cdf 1D array of index weights integer, intent(out), dimension(:) :: randomi Random indices public interface randind Procedure for generating a random array index/subscripts private subroutine randind_n(n, randomi) Generate a array of uniformally-distributed random integers in the range [1, n] Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Largest possible value integer, intent(out), dimension(:) :: randomi Array of uniform deviates private subroutine randind_w_1(w, randomi) Generate an array of random indices of an 1D array distributed according to w Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: w 1D array of index weights integer, intent(out), dimension(:) :: randomi Random indices private subroutine randind_w_2(w, randomi) Generate an array of random subscripts of an 2D array distributed according to w Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:) :: w 2D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts private subroutine randind_w_3(w, randomi) Generate an array of random subscripts of an 3D array distributed according to w Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:,:) :: w 3D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts private subroutine randind_w_4(w, randomi) Generate an array of random subscripts of an 4D array distributed according to w Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:,:,:) :: w 4D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts private subroutine randind_w_5(w, randomi) Generate an array of random subscripts of an 5D array distributed according to w Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:,:,:,:) :: w 5D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts private subroutine randind_r_n(r, n, randomi) Generate a array of uniformally-distributed random integers in the range [1, n] Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator integer, intent(in) :: n Largest possible value integer, intent(out), dimension(:) :: randomi Array of uniform deviates private subroutine randind_r_w_1(r, w, randomi) Generate an array of random indices of an 1D array distributed according to w Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(in), dimension(:) :: w 1D array of index weights integer, intent(out), dimension(:) :: randomi Random indices private subroutine randind_r_w_2(r, w, randomi) Generate an array of random subscripts of an 2D array distributed according to w Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(in), dimension(:,:), target :: w 2D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts private subroutine randind_r_w_3(r, w, randomi) Generate an array of random subscripts of an 3D array distributed according to w Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(in), dimension(:,:,:), target :: w 3D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts private subroutine randind_r_w_4(r, w, randomi) Generate an array of random subscripts of an 4D array distributed according to w Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(in), dimension(:,:,:,:), target :: w 4D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts private subroutine randind_r_w_5(r, w, randomi) Generate an array of random subscripts of an 5D array distributed according to w Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: r Random Number Generator real(kind=Float64), intent(in), dimension(:,:,:,:,:), target :: w 5D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts public interface sparse Creates a sparse array from a dense array private subroutine sparse_1(A, SA) Routine to create a 1D sparse array from a 1D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array private subroutine sparse_2(A, SA) Routine to create a 2D sparse array from a 2D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array private subroutine sparse_3(A, SA) Routine to create a 3D sparse array from a 3D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:,:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array private subroutine sparse_4(A, SA) Routine to create a 4D sparse array from a 4D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:,:,:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array public interface deriv Procedure for finding derivatives from an array private subroutine deriv_1d(x, y, yp) Uses 3 point lagrangian method to calculate the derivative of an array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x X Values real(kind=Float64), intent(in), dimension(:) :: y Y Values real(kind=Float64), intent(out), dimension(:) :: yp Derivative of Y w.r.t. X private subroutine deriv_2d(x, y, z, zxp, zyp) Uses 3 point lagrangian method to calculate the partial derivative\n of an array Z w.r.t X and Y Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x X Values real(kind=Float64), intent(in), dimension(:) :: y Y Values real(kind=Float64), intent(in), dimension(:,:) :: z Z Values real(kind=Float64), intent(out), dimension(:,:) :: zxp Derivative of Z w.r.t. X real(kind=Float64), intent(out), dimension(:,:) :: zyp Derivative of Z w.r.t. Y private subroutine deriv_3d(r, z, phi, f, frp, fzp, fphip) Uses 3 point lagrangian method to calculate the partial derivative\n of an array F w.r.t R, Z and Phi Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: r R Values real(kind=Float64), intent(in), dimension(:) :: z Z Values real(kind=Float64), intent(in), dimension(:) :: phi Phi Values real(kind=Float64), intent(in), dimension(:,:,:) :: f F Values real(kind=Float64), intent(out), dimension(:,:,:) :: frp Derivative of F w.r.t. R real(kind=Float64), intent(out), dimension(:,:,:) :: fzp Derivative of F w.r.t. Z real(kind=Float64), intent(out), dimension(:,:,:) :: fphip Derivative of F w.r.t. Phi Derived Types type, public :: rng_type Random Number Generator Derived Type Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: seed integer(kind=Int32), public, dimension(ns) :: state type, public :: SparseArray Components Type Visibility Attributes Name Initial integer, public :: nnz = 0 Number of non-zero elements integer, public :: nd = 0 Number of dimensions integer, public, dimension(:), allocatable :: dims Dimensions of array integer, public, dimension(:), allocatable :: inds Linear index of non-zero elements real(kind=Float64), public, dimension(:), allocatable :: vals Array values Functions public function sub2ind (dims, subs) result(ind) Calculates the linear index of an array with dimensions dims and\n subcripts subs Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: dims Dimension of Array integer, intent(in), dimension(:) :: subs Subscripts to convert Return Value integer Linear index public function rng_seed () result(seed) Generates random 32-bit integer seed from /dev/urandom Arguments None Return Value integer(kind=Int32) Seed value public function get_rng () result(r) Arguments None Return Value type( rng_type ) public function rng_uniform (self) result(u) Generate a uniformally-distributed random number in the range [0,1) Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator Return Value real(kind=Float64) Uniform random deviate public function rng_normal (self) result(n) Generate a normally-distributed random number with mean 0 and standard deviation 1 Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator Return Value real(kind=Float64) Normal random deviate public function get_value (SA, subs) result(val) Gets value of sparse array SA at the subscripts subs Arguments Type Intent Optional Attributes Name type( SparseArray ), intent(in) :: SA Sparse Array integer, intent(in), dimension(:) :: subs Subscripts of Sparse Array Return Value real(kind=Float64) Value of SA at subs public function time (time_start) result(time_str) Returns time string Arguments Type Intent Optional Attributes Name integer, intent(in), optional dimension(8) :: time_start Optional start time Return Value character(len=30) Time string public function norm2 (in) result(res) Arguments Type Intent Optional Attributes Name real(kind=Float64), dimension(:) :: in Return Value real(kind=Float64) Subroutines public subroutine ind2sub (dims, ind, subs) Calculate the subscripts subs into an array with dimensions dims given the corresponding linear index ind Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: dims Dimensions of array integer, intent(in) :: ind Linear index integer, intent(out), dimension(:) :: subs Subscripts corresponding to the linear index public subroutine rng_init (self, seed) Procedure to initialize a random number generator with a seed.\n If seed is negative then random seed is used Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator integer(kind=Int32), intent(in) :: seed Initial Seed Value public subroutine cumsum (x, cs) Calculate cumulative sum Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Array to sum real(kind=Float64), intent(out), dimension(:) :: cs Cumulative sum of x","tags":"","loc":"module/utilities.html","title":"utilities – FIDASIM"},{"text":"A library for writing compressed HDF5 files Uses H5LT HDF5 module~~hdf5_utils~~UsesGraph module~hdf5_utils hdf5_utils H5LT H5LT module~hdf5_utils->H5LT HDF5 HDF5 module~hdf5_utils->HDF5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~hdf5_utils~~UsedByGraph module~hdf5_utils hdf5_utils program~generate_tables generate_tables program~generate_tables->module~hdf5_utils module~atomic_tables atomic_tables program~generate_tables->module~atomic_tables module~libfida libfida module~libfida->module~hdf5_utils program~fidasim fidasim program~fidasim->module~hdf5_utils program~fidasim->module~libfida module~atomic_tables->module~hdf5_utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_int_f Subroutines check_compression_availability h5ltread_dataset_int_scalar_f h5ltread_dataset_double_scalar_f chunk_size h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_7 Interfaces public interface h5ltmake_compressed_dataset_double_f Write a compressed datasets of 64-bit floats public subroutine h5ltmake_compressed_dataset_double_f_1 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_2 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_3 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_4 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_5 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_6 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_7 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public interface h5ltmake_compressed_dataset_int_f Write a compressed dataset of 32-bit integers public subroutine h5ltmake_compressed_dataset_int_f_1 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_2 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_3 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_4 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_5 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_6 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_7 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Subroutines public subroutine check_compression_availability () Checks whether dataset compression is available Arguments None public subroutine h5ltread_dataset_int_scalar_f (loc_id, dset_name, x, error) Write a scalar 32-bit integer Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(inout) :: x Data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltread_dataset_double_scalar_f (loc_id, dset_name, x, error) Write a scalar 64-bit float Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create real(kind=Float64), intent(inout) :: x Data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine chunk_size (elsize, dims, cdims) Arguments Type Intent Optional Attributes Name integer, intent(in) :: elsize Size of elements in bytes integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Dimensions of dataset integer(kind=HSIZE_T), intent(out), dimension(:) :: cdims Maximum allowed chunk size/dims public subroutine h5ltmake_compressed_dataset_double_f_1 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_2 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_3 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_4 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_5 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_6 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_7 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=Float64), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_1 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_2 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_3 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_4 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_5 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_6 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_7 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code","tags":"","loc":"module/hdf5_utils.html","title":"hdf5_utils – FIDASIM"},{"text":"Library for calculating atomic cross sections and reaction rate coefficients for Hydrogen interactions References W.L. Wiese, M.W. Smith, and B.M. Glennon. Atomic Transition Probabilities. Volume 1. Hydrogen through Neon .\nNational Bureau of Standards Washington DC Institute for Basic Standards, 1966. R.K. Janev, D. Reiter, and  U. Samm. Collision processes in low-temperature hydrogen plasmas .\nForschungszentrum Jülich, Zentralbibliothek, 2003. M. O'Mullane. Review of proton impact driven ionisation from the excited levels in neutral hydrogen beams .\nADAS note, 2009. ADAS: Atomic Data and Analysis Structure R.K. Janev and J.J. Smith. Cross sections for collision processes of hydrogen atoms\nwith electrons, protons and multiply charged ions. Atomic and Plasma-Material Interaction Data for Fusion:\nVolume 4, 1993. Reinhold, C. O., R. E. Olson, and W. Fritsch. Excitation of atomic hydrogen by fully stripped ions. Physical Review A 41.9 1990. Bosch, H-S., and G. M. Hale. Improved formulas for fusion cross-sections and thermal reactivities. Nuclear fusion 32.4 1992. Aladdin Database: R.K. Janev, W.D. Langer, K. Evans Jr., D.E. Post Jr. H-HE-PLASMA (1987) Uses H5LT HDF5 hdf5_utils mpi_utils module~~atomic_tables~~UsesGraph module~atomic_tables atomic_tables module~mpi_utils mpi_utils module~atomic_tables->module~mpi_utils H5LT H5LT module~atomic_tables->H5LT module~hdf5_utils hdf5_utils module~atomic_tables->module~hdf5_utils HDF5 HDF5 module~atomic_tables->HDF5 module~hdf5_utils->H5LT module~hdf5_utils->HDF5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~atomic_tables~~UsedByGraph module~atomic_tables atomic_tables program~generate_tables generate_tables program~generate_tables->module~atomic_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables PI e_amu H1_amu H2_amu H3_amu He3_amu B_amu C_amu B_q C_q EINSTEIN istart istep verbose Interfaces bt_maxwellian Functions p_cx_1_janev p_cx_2_janev p_cx_3_janev p_cx_n_janev p_cx_janev aljan1 p_cx_1_2_janev p_cx_1_1_adas p_cx_1_2_adas p_cx_1_3_adas p_cx_1_4_adas p_cx_1 p_cx_2_2_adas p_cx_2_3_adas p_cx_2 p_cx_3_2_adas p_cx_3_3_adas p_cx_3_4_adas p_cx_3_5_adas p_cx_3_6inf_adas p_cx_3 p_cx_n p_cx_n_m p_cx p_ioniz_1_janev p_ioniz_2_omullane p_ioniz_3_omullane p_ioniz_4_omullane p_ioniz_5_omullane p_ioniz_n p_ioniz p_excit_1_2_janev p_excit_1_3_janev p_excit_1_4_janev p_excit_1_5_janev p_excit_1_6_janev p_excit_1_janev p_excit_2_3_janev p_excit_2_4_janev p_excit_2_5_janev p_excit_2_6_janev p_excit_2_7_janev p_excit_2_8_janev p_excit_2_9_janev p_excit_2_10_janev p_excit_2_janev p_excit_3_4_janev p_excit_3_5_janev p_excit_3_6_janev p_excit_3_7_janev p_excit_3_8_janev p_excit_3_9_janev p_excit_3_10_janev p_excit_3_janev p_excit_n p_excit_n_m p_excit e_ioniz_1_janev e_ioniz_2_janev e_ioniz_3_janev e_ioniz_n e_ioniz e_excit_1_2_janev e_excit_1_3_janev e_excit_1_4_janev e_excit_1_5_janev e_excit_f e_excit_1_janev e_excit_2_3_janev e_excit_n e_excit_n_m e_excit B5_cx_1_adas B5_cx_2_adas C6_cx_1_adas C6_cx_2_adas C6_cx_3_adas Aq_cx_n_adas B5_cx_1_janev C6_cx_1_janev Aq_cx_n_janev Aq_cx_n Aq_cx B5_ioniz_1_janev C6_ioniz_1_janev Aq_ioniz_n_janev Aq_ioniz_n Aq_ioniz Aq_excit_1_2_janev Aq_excit_1_3_janev Aq_excit_1_4_janev Aq_excit_1_5_janev Aq_excit_1_janev Aq_excit_2_3_janev Aq_excit_2_4_janev Aq_excit_2_5_janev Aq_excit_2_6_janev Aq_excit_2_7_janev Aq_excit_2_8_janev Aq_excit_2_9_janev Aq_excit_2_10_janev Aq_excit_2_janev Aq_excit_3_4_janev Aq_excit_3_5_janev Aq_excit_3_6_janev Aq_excit_3_7_janev Aq_excit_3_8_janev Aq_excit_3_9_janev Aq_excit_3_10_janev Aq_excit_3_janev Aq_excit_n_janev Aq_excit_n Aq_excit_n_m Aq_excit d_d_fusion_t d_d_fusion_he d_t_fusion simpsons_rule Subroutines m_spread bt_maxwellian_eb bt_maxwellian_n bt_maxwellian_q_n bt_maxwellian_n_m bt_maxwellian_q_n_m write_einstein write_bb_H_H write_bb_H_e write_bb_H_Aq write_bb_D_D write_bb_D_T write_bt_H_H write_bt_H_e write_bt_H_Aq write_bt_D_D write_bt_D_T print_default_namelist Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: PI = 3.14159265d0 real(kind=Float64), public, parameter :: e_amu = 5.48579909070d-4 Atomic mass of an electron [amu] real(kind=Float64), public, parameter :: H1_amu = 1.007276466879d0 Atomic mass of Hydrogen-1 (protium) [amu] real(kind=Float64), public, parameter :: H2_amu = 2.013553212745d0 Atomic mass of Hydrogen-2 (deuterium) [amu] real(kind=Float64), public, parameter :: H3_amu = 3.01550071632d0 Atomic mass of Hydrogen-3 (tritium) [amu] real(kind=Float64), public, parameter :: He3_amu = 3.01602931914d0 Atomic mass of Helium-3 [amu] real(kind=Float64), public, parameter :: B_amu = 10.81d0 Atomic mass of Boron [amu] real(kind=Float64), public, parameter :: C_amu = 12.011d0 Atomic mass of Carbon [amu] integer, public, parameter :: B_q = 5 Proton number of Boron integer, public, parameter :: C_q = 6 Proton number of Carbon real(kind=Float64), public, parameter, dimension(15,15) :: EINSTEIN = reshape([0.d0, 4.699d8, 5.575d7, 1.278d7, 4.125d6, 1.644d6, 7.568d5, 3.869d5, 2.143d5, 1.263d5, 7.834d4, 5.066d4, 3.393d4, 2.341d4, 1.657d4, 0.d0, 0.d0, 4.410d7, 8.419d6, 2.530d6, 9.732d5, 4.389d5, 2.215d5, 1.216d5, 7.122d4, 4.397d4, 2.834d4, 1.893d4, 1.303d4, 9.210d3, 0.d0, 0.d0, 0.d0, 8.986d6, 2.201d6, 7.783d5, 3.358d5, 1.651d5, 8.905d4, 5.156d4, 3.156d4, 2.021d4, 1.343d4, 9.211d3, 6.490d3, 0.d0, 0.d0, 0.d0, 0.d0, 2.699d6, 7.711d5, 3.041d5, 1.424d5, 7.459d4, 4.235d4, 2.556d4, 1.620d4, 1.069d4, 7.288d3, 5.110d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.025d6, 3.253d5, 1.388d5, 6.908d4, 3.800d4, 2.246d4, 1.402d4, 9.148d3, 6.185d3, 4.308d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 4.561d5, 1.561d5, 7.065d4, 3.688d4, 2.110d4, 1.288d4, 8.271d3, 5.526d3, 3.815d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 2.272d5, 8.237d4, 3.905d4, 2.117d4, 1.250d4, 7.845d3, 5.156d3, 3.516d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.233d5, 4.676d4, 2.301d4, 1.287d4, 7.804d3, 5.010d3, 3.359d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 7.141d4, 2.812d4, 1.427d4, 8.192d3, 5.080d3, 3.325d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 4.377d4, 1.774d4, 9.231d3, 5.417d3, 3.324d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 2.799d4, 1.163d4, 6.186d3, 3.699d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.857d4, 7.884d3, 4.271d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.271d4, 5.496d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 8.933d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0], [15, 15]) Einstein coefficients for spontaneous emission from state initial state n to final state m References: H - Table A in Ref. 1 atomic_tables integer, public :: istart = 1 Starting loop counter (1 if OpenMP, processor number if MPI) integer, public :: istep = 1 Loop step size (1 if OpenMP, number of processes if MPI) logical, public :: verbose = .True. Indicates whether process is verbose Interfaces public interface bt_maxwellian Calculates the reaction rate coefficients given beam energy eb and target temperature T where the velocity distribution of the target is a Maxwellian public subroutine bt_maxwellian_eb (fn, T, eb, am, ab, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] public subroutine bt_maxwellian_n (fn, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a, b) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] public subroutine bt_maxwellian_n_m (fnm, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fnm Arguments Type Intent Optional Attributes Name public function fnm(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate public subroutine bt_maxwellian_q_n (fqn, q, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqn Arguments Type Intent Optional Attributes Name public function fqn(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] public subroutine bt_maxwellian_q_n_m (fqnm, q, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqnm Arguments Type Intent Optional Attributes Name public function fqnm(a, b, c, d) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate Functions public function p_cx_1_janev (Erel) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=1 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_2_janev (Erel) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=2 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_3_janev (Erel) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=3 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_n_janev (Erel, n) result(sigma) Calculates cross section for proton-Hydrogen charge exchange interactions from the n \\geq 4 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_janev (Erel, n) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function aljan1 (energy, pcf) result(sigma) Fit function for p_cx_1_2_janev Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: energy Relative collision energy [eV] real(kind=Float64), intent(in), dimension(:) :: pcf Fit Coefficients Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_1_2_janev (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=2 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_1_1_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=1 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_1_2_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=2 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_1_3_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=3 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_1_4_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=4 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_1 (Erel, m_max) result(sigma) Calculates an array of cross section for proton-Hydrogen charge exchange interactions\nfrom the n=1 state to m = 1.. m_max states at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [ cm&#94;2 ] public function p_cx_2_2_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=2 state to the m=2 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_2_3_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=2 state to the m=3 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_2 (Erel, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n=2 state to m = 1.. m_max states at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [ cm&#94;2 ] public function p_cx_3_2_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=2 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_3_3_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=3 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_3_4_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=4 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_3_5_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=5 state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_3_6inf_adas (Erel) result(sigma) Calculates total cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to \\forall \\; m \\geq 6 states at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx_3 (Erel, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n=3 state to m = 1.. m_max states at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [ cm&#94;2 ] public function p_cx_n (Erel, n, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n state to m = 1.. m_max states at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [ cm&#94;2 ] public function p_cx_n_m (Erel, n, m) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n state to the m state at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_cx (Erel, n_max, m_max) result(sigma) Calculates a matrix of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy Erel Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of initial atomic energy levels/states integer, intent(in) :: m_max Number of final atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max,m_max) Matrix of cross sections where the subscripts correspond\n to the n \\rightarrow m transitions: p_cx[n,m] [ cm&#94;2 ] public function p_ioniz_1_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=1 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_ioniz_2_omullane (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=2 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_ioniz_3_omullane (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=3 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_ioniz_4_omullane (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=4 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_ioniz_5_omullane (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=5 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_ioniz_n (eb, n) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n th state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_ioniz (eb, n_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen impact ionization interactions\nfrom the n = 1.. n_max state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of initial atomic energy level/state Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the index refers to the n 'th state [ cm&#94;2 ] public function p_excit_1_2_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=2 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_1_3_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=3 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_1_4_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=4 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_1_5_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=5 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_1_6_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=6 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_1_janev (eb, m_max) result(sigma) Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from\nthe n=1 state to the m=1..{m_max} state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n=1 to m [ cm&#94;2 ] public function p_excit_2_3_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=3 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_2_4_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=4 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_2_5_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=5 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_2_6_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=6 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_2_7_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=7 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_2_8_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=8 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_2_9_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=9 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_2_10_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=10 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_2_janev (eb, m_max) result(sigma) Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from\nthe n=2 state to the m=1..{m_max} state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n=2 to m [ cm&#94;2 ] public function p_excit_3_4_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=4 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_3_5_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=5 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_3_6_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=6 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_3_7_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=7 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_3_8_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=8 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_3_9_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=9 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_3_10_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=10 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit_3_janev (eb, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen impact excitation transitions from\nthe n=3 state to the m=1..{m_max} state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n=3 to m [ cm&#94;2 ] public function p_excit_n (eb, n, m_max) result(sigma) Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from\nthe n state to the m=1..{m_max} state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n to m [ cm&#94;2 ] public function p_excit_n_m (eb, n, m) result(sigma) Calculates the cross section for a proton-Hydrogen impact excitation transition from\nthe n state to the m state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function p_excit (eb, n_max, m_max) result(sigma) Calculates a matrix of cross sections for a proton-Hydrogen impact excitation transitions\nfrom the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of final atomic energy levels/states integer, intent(in) :: m_max Number of initial atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max,m_max) Matrix of cross sections where the subscripts correspond\n to the n \\rightarrow m transitions: p_excit[n,m] [ cm&#94;2 ] public function e_ioniz_1_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n=1 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function e_ioniz_2_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n=2 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function e_ioniz_3_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n=3 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function e_ioniz_n (eb, n) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function e_ioniz (eb, n_max) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact ionization from\nthe n=1..n_{max} states at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n_max Number of initial atomic energy levels/states to calculate Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the n'th index refers to a ionization from the n'th state [ cm&#94;2 ] public function e_excit_1_2_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=2 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function e_excit_1_3_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=3 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function e_excit_1_4_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=4 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function e_excit_1_5_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=5 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function e_excit_f (n, m) result(fnm) Oscillator strength for a n \\rightarrow m transition due to electron-Hydrogen impact excitation Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Oscillator strength public function e_excit_1_janev (eb, m_max) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=1..m_{max} state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=1 state to the m'th state [ cm&#94;2 ] public function e_excit_2_3_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=2 state to the m=3 state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function e_excit_n (eb, n, m_max) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from\nthe n state to the m=1..m_{max} state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n \\rightarrow m state [ cm&#94;2 ] public function e_excit_n_m (eb, n, m) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from\nthe n \\rightarrow m state at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function e_excit (eb, n_max, m_max) result(sigma) Calculates a matrix of cross section for a proton-Hydrogen impact excitation transition\nfrom the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of final atomic energy levels/states integer, intent(in) :: m_max Number of initial atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max,m_max) Matrix of cross sections where the subscripts correspond\n to the n \\rightarrow m transitions: e_excit[n,m] [ cm&#94;2 ] public function B5_cx_1_adas (eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Boron ion at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function B5_cx_2_adas (eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=2 state colliding with a fully stripped Boron ion at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function C6_cx_1_adas (eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Carbon ion at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function C6_cx_2_adas (eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=2 state colliding with a fully stripped Carbon ion at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function C6_cx_3_adas (eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=3 state colliding with a fully stripped Carbon ion at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_cx_n_adas (eb, q, n) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function B5_cx_1_janev (eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Boron ion at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function C6_cx_1_janev (eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Carbon ion at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_cx_n_janev (eb, q, n) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_cx_n (eb, q, n) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_cx (eb, q, n_max) result(sigma) Calculates an array of total charge exchange cross sections for a Neutral Hydrogen atom\nin the n=1...n_max states colliding with a ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n_max Number of initial atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the n'th index refers to a charge exchange from the n'th state [ cm&#94;2 ] public function B5_ioniz_1_janev (eb) result(sigma) Calculates the total ionization cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Boron ion at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function C6_ioniz_1_janev (eb) result(sigma) Calculates the total ionization cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Carbon ion at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function Aq_ioniz_n_janev (eb, q, n) result(sigma) Calculates the generic total ionization cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_ioniz_n (eb, q, n) result(sigma) Calculates the total ionization cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_ioniz (eb, q, n_max) result(sigma) Calculates an array of total ionization cross sections for a Neutral Hydrogen atom\nin the n=1...n_max states colliding with a ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n_max Number of initial states n to calculate Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the n'th index refers to a ionization from the n'th state [ cm&#94;2 ] public function Aq_excit_1_2_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=2 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_1_3_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=3 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_1_4_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=4 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_1_5_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=5 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_1_janev (eb, q, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=1 state to the m'th state [ cm&#94;2 ] public function Aq_excit_2_3_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=3 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_2_4_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=4 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_2_5_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=5 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_2_6_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=6 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_2_7_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=7 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_2_8_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=8 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_2_9_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=9 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_2_10_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=10 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_2_janev (eb, q, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=2 state to the m'th state [ cm&#94;2 ] public function Aq_excit_3_4_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=4 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_3_5_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=5 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_3_6_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=6 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_3_7_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=7 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_3_8_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=8 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_3_9_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=9 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_3_10_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=10 state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit_3_janev (eb, q, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=3 state to the m'th state [ cm&#94;2 ] public function Aq_excit_n_janev (eb, q, n, m_max) result(sigma) Calculates an array of the generic excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n state to the m'th state [ cm&#94;2 ] public function Aq_excit_n (eb, q, n, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n state to the m'th state [ cm&#94;2 ] public function Aq_excit_n_m (eb, q, n, m) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n \\rightarrow m state due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function Aq_excit (eb, q, n_max, m_max) result(sigma) Calculates an matrix of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=1.. n_max state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n_max Number of n states to calculate integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(n_max, m_max) Matrix of cross sections where the subscripts refers to\nan excitation from the n state to the m'th state: Aq_excit[n,m] [ cm&#94;2 ] public function d_d_fusion_t (eb) result(sigma) Calculates total cross section at a given Deuterium energy, eb ,\nfor the Tritium branch of Deuterium-Deutrium nuclear reactions Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Deuterium energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function d_d_fusion_he (eb) result(sigma) Calculates total cross section at a given deuterium energy, eb ,\nfor the Helium-3 branch of Deuterium-Deutrium nuclear reactions Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Deuterium energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function d_t_fusion (eb) result(sigma) Calculates total cross section at a given deuterium energy, eb ,\nfor Deuterium-Tritium nuclear reactions in the range [0.5-550 keV] Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Deuterium energy [keV] Return Value real(kind=Float64) Cross Section [ cm&#94;2 ] public function simpsons_rule (f, dx) result(I) Performs 1D integration using Simpsons rule Read more… Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: f Array of equally spaced f(x) values real(kind=Float64), intent(in) :: dx Spacing between x values Return Value real(kind=Float64) Subroutines public subroutine m_spread (n, m_max, sigma_tot, sigma) Spreads the total charge exchange cross section, sigma_tot ,\n among the non-filled m states of sigma according to an exponential Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states in sigma real(kind=Float64), intent(in) :: sigma_tot Amount of \"cross section\" to spread about the non-filled m state of sigma real(kind=Float64), intent(inout), dimension(m_max) :: sigma Array of cross sections from the n state to m=1.. m_max [ cm&#94;2 ] public subroutine bt_maxwellian_eb (fn, T, eb, am, ab, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] public subroutine bt_maxwellian_n (fn, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a, b) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] public subroutine bt_maxwellian_q_n (fqn, q, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqn Arguments Type Intent Optional Attributes Name public function fqn(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] public subroutine bt_maxwellian_n_m (fnm, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fnm Arguments Type Intent Optional Attributes Name public function fnm(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate public subroutine bt_maxwellian_q_n_m (fqnm, q, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqnm Arguments Type Intent Optional Attributes Name public function fqnm(a, b, c, d) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [ cm&#94;3/s ] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate public subroutine write_einstein (id, n_max, m_max) Write Einstein coefficients to HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate public subroutine write_bb_H_H (id, namelist_file, n_max, m_max) Write Hydrogen-Hydrogen interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate public subroutine write_bb_H_e (id, namelist_file, n_max, m_max) Write Hydrogen-Electron interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate public subroutine write_bb_H_Aq (id, namelist_file, n_max, m_max) Write Hydrogen-Impurity interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate public subroutine write_bb_D_D (id, namelist_file) Write Deuterium-Deuterium interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings public subroutine write_bb_D_T (id, namelist_file) Write Deuterium-Tritium interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings public subroutine write_bt_H_H (id, namelist_file, n_max, m_max) Write Hydrogen-Hydrogen reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate public subroutine write_bt_H_e (id, namelist_file, n_max, m_max) Write Hydrogen-Electron reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate public subroutine write_bt_H_Aq (id, namelist_file, n_max, m_max) Write Hydrogen-Impurity reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate public subroutine write_bt_D_D (id, namelist_file) Write Deuterium-Deuterium reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings public subroutine write_bt_D_T (id, namelist_file) Write Deuterium-Tritium reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings public subroutine print_default_namelist () Prints out the default settings as a namelist Arguments None","tags":"","loc":"module/atomic_tables.html","title":"atomic_tables – FIDASIM"},{"text":"Uses libfida hdf5_utils omp_lib mpi_utils program~~fidasim~~UsesGraph program~fidasim fidasim module~mpi_utils mpi_utils program~fidasim->module~mpi_utils omp_lib omp_lib program~fidasim->omp_lib module~hdf5_utils hdf5_utils program~fidasim->module~hdf5_utils module~libfida libfida program~fidasim->module~libfida H5LT H5LT module~hdf5_utils->H5LT HDF5 HDF5 module~hdf5_utils->HDF5 module~libfida->module~mpi_utils module~libfida->module~hdf5_utils module~libfida->H5LT module~utilities utilities module~libfida->module~utilities module~eigensystem eigensystem module~libfida->module~eigensystem iso_c_binding iso_c_binding module~libfida->iso_c_binding module~libfida->HDF5 module~utilities->omp_lib module~utilities->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. FIDASIM 2.0.0-dev Calls program~~fidasim~~CallsGraph program~fidasim fidasim proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~pnpa_f pnpa_f program~fidasim->proc~pnpa_f proc~dcx_spec dcx_spec program~fidasim->proc~dcx_spec proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~print_banner print_banner program~fidasim->proc~print_banner proc~ndmc ndmc program~fidasim->proc~ndmc proc~read_neutrals read_neutrals program~fidasim->proc~read_neutrals proc~nbi_spec nbi_spec program~fidasim->proc~nbi_spec proc~read_npa read_npa program~fidasim->proc~read_npa proc~read_equilibrium read_equilibrium program~fidasim->proc~read_equilibrium proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~read_inputs read_inputs program~fidasim->proc~read_inputs proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~write_neutrals write_neutrals program~fidasim->proc~write_neutrals proc~make_beam_grid make_beam_grid program~fidasim->proc~make_beam_grid proc~pfida_f pfida_f program~fidasim->proc~pfida_f proc~write_spectra write_spectra program~fidasim->proc~write_spectra proc~check_compression_availability check_compression_availability program~fidasim->proc~check_compression_availability proc~pnpa_mc pnpa_mc program~fidasim->proc~pnpa_mc proc~halo halo program~fidasim->proc~halo proc~write_npa write_npa program~fidasim->proc~write_npa proc~pfida_mc pfida_mc program~fidasim->proc~pfida_mc proc~cleanup_mpi cleanup_mpi program~fidasim->proc~cleanup_mpi proc~dcx dcx program~fidasim->proc~dcx proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los rng rng program~fidasim->rng proc~num_ranks num_ranks program~fidasim->proc~num_ranks proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~read_chords read_chords program~fidasim->proc~read_chords proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~read_tables read_tables program~fidasim->proc~read_tables proc~write_birth_profile write_birth_profile program~fidasim->proc~write_birth_profile proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~halo_spec halo_spec program~fidasim->proc~halo_spec omp_set_num_threads omp_set_num_threads program~fidasim->omp_set_num_threads proc~make_diagnostic_grids make_diagnostic_grids program~fidasim->proc~make_diagnostic_grids proc~cold_spec cold_spec program~fidasim->proc~cold_spec proc~npa_f npa_f program~fidasim->proc~npa_f proc~neutron_f neutron_f program~fidasim->proc~neutron_f omp_get_num_procs omp_get_num_procs program~fidasim->omp_get_num_procs proc~init_mpi init_mpi program~fidasim->proc~init_mpi proc~my_rank my_rank program~fidasim->proc~my_rank h5fclose_f h5fclose_f proc~read_distribution->h5fclose_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_distribution->proc~h5ltread_dataset_int_scalar_f h5close_f h5close_f proc~read_distribution->h5close_f proc~read_mc read_mc proc~read_distribution->proc~read_mc h5fopen_f h5fopen_f proc~read_distribution->h5fopen_f proc~read_f read_f proc~read_distribution->proc~read_f h5open_f h5open_f proc~read_distribution->h5open_f proc~mc_fastion_pass_grid mc_fastion_pass_grid proc~pnpa_f->proc~mc_fastion_pass_grid proc~bt_cx_rates bt_cx_rates proc~pnpa_f->proc~bt_cx_rates proc~gyro_surface gyro_surface proc~pnpa_f->proc~gyro_surface proc~ind2sub ind2sub proc~pnpa_f->proc~ind2sub proc~hit_npa_detector hit_npa_detector proc~pnpa_f->proc~hit_npa_detector proc~get_nlaunch_pass_grid get_nlaunch_pass_grid proc~pnpa_f->proc~get_nlaunch_pass_grid proc~store_npa store_npa proc~pnpa_f->proc~store_npa proc~gyro_trajectory gyro_trajectory proc~pnpa_f->proc~gyro_trajectory proc~attenuate attenuate proc~pnpa_f->proc~attenuate proc~npa_gyro_range npa_gyro_range proc~pnpa_f->proc~npa_gyro_range proc~get_plasma get_plasma proc~pnpa_f->proc~get_plasma interface~parallel_sum parallel_sum proc~pnpa_f->interface~parallel_sum proc~dcx_spec->proc~ind2sub proc~store_photons store_photons proc~dcx_spec->proc~store_photons proc~in_plasma in_plasma proc~dcx_spec->proc~in_plasma interface~randu randu proc~dcx_spec->interface~randu proc~dcx_spec->proc~get_plasma proc~dcx_spec->interface~parallel_sum interface~randn randn proc~dcx_spec->interface~randn proc~bremsstrahlung->interface~randu proc~bremsstrahlung->proc~get_plasma proc~line_basis line_basis proc~bremsstrahlung->proc~line_basis proc~bremsstrahlung->interface~parallel_sum proc~track track proc~ndmc->proc~track proc~gyro_step gyro_step proc~ndmc->proc~gyro_step proc~ndmc->interface~randu proc~store_neutrals store_neutrals proc~ndmc->proc~store_neutrals proc~get_fields get_fields proc~ndmc->proc~get_fields proc~mc_nbi mc_nbi proc~ndmc->proc~mc_nbi proc~ndmc->interface~parallel_sum h5gclose_f h5gclose_f proc~read_neutrals->h5gclose_f proc~read_neutrals->h5fclose_f proc~read_neutrals->proc~h5ltread_dataset_int_scalar_f proc~read_neutrals->h5close_f h5ltpath_valid_f h5ltpath_valid_f proc~read_neutrals->h5ltpath_valid_f proc~read_neutrals->h5fopen_f h5gopen_f h5gopen_f proc~read_neutrals->h5gopen_f proc~read_neutrals->h5open_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_neutrals->h5ltread_dataset_double_f proc~nbi_spec->proc~ind2sub proc~mc_nbi_cell mc_nbi_cell proc~nbi_spec->proc~mc_nbi_cell proc~nbi_spec->proc~store_photons proc~nbi_spec->proc~in_plasma proc~nbi_spec->interface~randu proc~nbi_spec->interface~parallel_sum proc~plane_basis plane_basis proc~read_npa->proc~plane_basis proc~read_npa->h5gclose_f proc~read_npa->h5fclose_f proc~read_npa->proc~h5ltread_dataset_int_scalar_f proc~read_npa->h5close_f proc~read_npa->h5ltpath_valid_f h5ltread_dataset_string_f h5ltread_dataset_string_f proc~read_npa->h5ltread_dataset_string_f proc~read_npa->h5fopen_f proc~read_npa->h5gopen_f proc~read_npa->h5open_f proc~read_npa->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_equilibrium->h5ltread_dataset_int_f proc~read_equilibrium->h5gclose_f proc~read_equilibrium->proc~ind2sub proc~read_equilibrium->h5fclose_f proc~read_equilibrium->proc~h5ltread_dataset_int_scalar_f proc~read_equilibrium->h5close_f proc~read_equilibrium->h5ltpath_valid_f proc~colrad colrad proc~read_equilibrium->proc~colrad interface~deriv deriv proc~read_equilibrium->interface~deriv proc~read_equilibrium->h5fopen_f proc~read_equilibrium->h5gopen_f proc~read_equilibrium->h5open_f proc~read_equilibrium->h5ltread_dataset_double_f proc~read_equilibrium->interface~randn proc~npa_weights->proc~my_rank proc~npa_weights->proc~hit_npa_detector proc~npa_weights->proc~gyro_step proc~npa_weights->proc~attenuate proc~get_beam_cx_rate get_beam_cx_rate proc~npa_weights->proc~get_beam_cx_rate proc~npa_weights->proc~get_fields proc~write_npa_weights write_npa_weights proc~npa_weights->proc~write_npa_weights proc~npa_weights->interface~parallel_sum proc~read_inputs->proc~my_rank proc~rng_seed rng_seed proc~read_inputs->proc~rng_seed proc~uvw_to_xyz uvw_to_xyz proc~fida_mc->proc~uvw_to_xyz proc~fida_mc->proc~track proc~fida_mc->interface~randu proc~fida_mc->proc~get_fields proc~gyro_correction gyro_correction proc~fida_mc->proc~gyro_correction proc~fida_mc->interface~parallel_sum proc~write_neutrals->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_neutrals->h5ltmake_dataset_int_f proc~write_neutrals->h5close_f proc~write_beam_grid write_beam_grid proc~write_neutrals->proc~write_beam_grid interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->h5open_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_neutrals->h5ltset_attribute_string_f h5fcreate_f h5fcreate_f proc~write_neutrals->h5fcreate_f proc~tb_zyx tb_zyx proc~make_beam_grid->proc~tb_zyx proc~make_beam_grid->proc~in_plasma proc~pfida_f->proc~mc_fastion_pass_grid proc~pfida_f->proc~bt_cx_rates proc~pfida_f->proc~ind2sub proc~track_cylindrical track_cylindrical proc~pfida_f->proc~track_cylindrical proc~pfida_f->proc~get_nlaunch_pass_grid proc~pfida_f->proc~get_plasma proc~pfida_f->proc~gyro_correction proc~pfida_f->interface~parallel_sum proc~write_spectra->h5fclose_f proc~write_spectra->h5ltmake_dataset_int_f proc~write_spectra->h5close_f proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_spectra->h5open_f proc~write_spectra->h5ltset_attribute_string_f proc~write_spectra->h5fcreate_f h5zget_filter_info_f h5zget_filter_info_f proc~check_compression_availability->h5zget_filter_info_f h5zfilter_avail_f h5zfilter_avail_f proc~check_compression_availability->h5zfilter_avail_f proc~check_compression_availability->h5close_f proc~check_compression_availability->h5open_f proc~pnpa_mc->proc~uvw_to_xyz proc~pnpa_mc->proc~bt_cx_rates proc~pnpa_mc->proc~gyro_surface proc~pnpa_mc->proc~hit_npa_detector proc~pnpa_mc->proc~store_npa proc~pnpa_mc->interface~randu proc~pnpa_mc->proc~gyro_trajectory proc~pnpa_mc->proc~attenuate proc~pnpa_mc->proc~get_fields proc~pnpa_mc->proc~npa_gyro_range proc~pnpa_mc->proc~get_plasma proc~pnpa_mc->interface~parallel_sum omp_get_thread_num omp_get_thread_num proc~halo->omp_get_thread_num proc~halo->proc~track proc~halo->proc~ind2sub proc~get_nlaunch get_nlaunch proc~halo->proc~get_nlaunch proc~mc_halo mc_halo proc~halo->proc~mc_halo omp_get_max_threads omp_get_max_threads proc~halo->omp_get_max_threads proc~halo->proc~get_plasma proc~halo->interface~parallel_sum proc~write_npa->proc~num_ranks proc~write_npa->proc~my_rank proc~write_npa->h5gclose_f proc~write_npa->h5fclose_f proc~write_npa->h5ltmake_dataset_int_f proc~write_npa->h5close_f h5gcreate_f h5gcreate_f proc~write_npa->h5gcreate_f interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f proc~write_npa->interface~h5ltmake_compressed_dataset_int_f proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_npa->h5open_f proc~write_npa->h5ltset_attribute_string_f proc~write_npa->h5fcreate_f proc~write_npa->interface~parallel_sum proc~pfida_mc->proc~bt_cx_rates proc~pfida_mc->proc~track_cylindrical proc~pfida_mc->interface~randu proc~pfida_mc->proc~get_fields proc~pfida_mc->proc~get_plasma proc~pfida_mc->proc~gyro_correction proc~pfida_mc->interface~parallel_sum mpi_barrier mpi_barrier proc~cleanup_mpi->mpi_barrier mpi_finalize mpi_finalize proc~cleanup_mpi->mpi_finalize proc~dcx->proc~track proc~dcx->proc~ind2sub proc~dcx->proc~get_nlaunch proc~dcx->proc~mc_halo proc~dcx->proc~get_plasma proc~dcx->interface~parallel_sum proc~fida_weights_los->proc~my_rank proc~fida_weights_los->proc~bt_cx_rates proc~fida_weights_los->proc~track proc~write_fida_weights write_fida_weights proc~fida_weights_los->proc~write_fida_weights proc~pitch_to_vec pitch_to_vec proc~fida_weights_los->proc~pitch_to_vec proc~grid_intersect grid_intersect proc~fida_weights_los->proc~grid_intersect proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~fida_weights_los->proc~store_fw_photons_at_chan proc~fida_weights_los->proc~in_plasma proc~fida_weights_los->proc~colrad proc~fida_weights_los->proc~get_fields proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->interface~parallel_sum proc~bb_cx_rates bb_cx_rates proc~fida_weights_los->proc~bb_cx_rates proc~neutron_mc->proc~my_rank proc~get_neutron_rate get_neutron_rate proc~neutron_mc->proc~get_neutron_rate proc~neutron_mc->proc~get_fields proc~neutron_mc->proc~get_plasma proc~neutron_mc->proc~gyro_correction proc~store_neutrons store_neutrons proc~neutron_mc->proc~store_neutrons proc~write_neutrons write_neutrons proc~neutron_mc->proc~write_neutrons proc~neutron_mc->interface~parallel_sum proc~read_chords->h5gclose_f proc~read_chords->h5fclose_f proc~read_chords->proc~h5ltread_dataset_int_scalar_f proc~read_chords->h5close_f proc~read_chords->h5ltpath_valid_f proc~read_chords->h5ltread_dataset_string_f proc~read_chords->h5fopen_f proc~read_chords->h5gopen_f proc~read_chords->h5open_f proc~read_chords->h5ltread_dataset_double_f proc~npa_mc->proc~uvw_to_xyz proc~get_indices get_indices proc~npa_mc->proc~get_indices proc~npa_mc->proc~gyro_surface proc~npa_mc->proc~hit_npa_detector proc~npa_mc->proc~store_npa proc~npa_mc->interface~randu proc~npa_mc->proc~gyro_trajectory proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_rate proc~npa_mc->proc~get_fields proc~npa_mc->proc~npa_gyro_range proc~npa_mc->interface~parallel_sum proc~fida_f->proc~track proc~fida_f->proc~ind2sub proc~fida_f->proc~get_nlaunch proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~fida_f->proc~get_plasma proc~fida_f->proc~gyro_correction proc~fida_f->interface~parallel_sum proc~read_atomic_transitions read_atomic_transitions proc~read_tables->proc~read_atomic_transitions proc~read_tables->h5fclose_f proc~read_atomic_rate read_atomic_rate proc~read_tables->proc~read_atomic_rate proc~read_tables->proc~h5ltread_dataset_int_scalar_f proc~read_tables->h5close_f proc~read_tables->h5fopen_f proc~read_tables->h5open_f proc~read_tables->h5ltread_dataset_double_f proc~read_atomic_cross read_atomic_cross proc~read_tables->proc~read_atomic_cross proc~read_nuclear_rates read_nuclear_rates proc~read_tables->proc~read_nuclear_rates proc~write_birth_profile->proc~num_ranks proc~write_birth_profile->proc~my_rank proc~write_birth_profile->h5fclose_f proc~write_birth_profile->h5ltmake_dataset_int_f proc~write_birth_profile->h5close_f proc~xyz_to_uvw xyz_to_uvw proc~write_birth_profile->proc~xyz_to_uvw proc~write_birth_profile->proc~write_beam_grid proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile->h5open_f proc~write_birth_profile->h5ltset_attribute_string_f proc~write_birth_profile->h5fcreate_f proc~write_birth_profile->interface~parallel_sum proc~fida_weights_mc->proc~my_rank proc~fida_weights_mc->proc~track proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_mc->proc~ind2sub proc~fida_weights_mc->proc~get_nlaunch proc~fida_weights_mc->interface~randu proc~get_ep_denf get_ep_denf proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~get_fields interface~randind randind proc~fida_weights_mc->interface~randind proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~gyro_correction proc~fida_weights_mc->interface~parallel_sum proc~halo_spec->proc~ind2sub proc~halo_spec->proc~store_photons proc~halo_spec->proc~in_plasma proc~halo_spec->interface~randu proc~halo_spec->proc~get_plasma proc~halo_spec->interface~parallel_sum proc~halo_spec->interface~randn proc~make_diagnostic_grids->proc~track proc~make_diagnostic_grids->proc~ind2sub proc~make_diagnostic_grids->proc~track_cylindrical proc~make_diagnostic_grids->proc~hit_npa_detector proc~make_diagnostic_grids->proc~grid_intersect proc~make_diagnostic_grids->interface~randu proc~make_diagnostic_grids->proc~get_fields proc~make_diagnostic_grids->proc~line_basis proc~make_diagnostic_grids->interface~parallel_sum proc~make_passive_grid make_passive_grid proc~make_diagnostic_grids->proc~make_passive_grid proc~cold_spec->proc~ind2sub proc~cold_spec->proc~store_photons proc~cold_spec->proc~get_plasma proc~cold_spec->interface~parallel_sum proc~cold_spec->interface~randn proc~npa_f->proc~get_indices proc~npa_f->proc~gyro_surface proc~npa_f->proc~ind2sub proc~npa_f->proc~hit_npa_detector proc~npa_f->proc~get_nlaunch proc~npa_f->proc~mc_fastion proc~npa_f->proc~store_npa proc~npa_f->proc~gyro_trajectory proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_rate proc~npa_f->proc~npa_gyro_range proc~npa_f->proc~get_plasma proc~npa_f->interface~parallel_sum proc~neutron_f->proc~my_rank proc~neutron_f->proc~get_neutron_rate proc~neutron_f->proc~get_fields proc~neutron_f->proc~get_plasma proc~neutron_f->proc~gyro_correction proc~neutron_f->proc~store_neutrons proc~neutron_f->proc~write_neutrons proc~neutron_f->interface~parallel_sum mpi_comm_rank mpi_comm_rank proc~init_mpi->mpi_comm_rank mpi_init_thread mpi_init_thread proc~init_mpi->mpi_init_thread mpi_comm_size mpi_comm_size proc~init_mpi->mpi_comm_size mpi_init mpi_init proc~init_mpi->mpi_init proc~mc_fastion_pass_grid->interface~randu proc~mc_fastion_pass_grid->proc~get_fields proc~mc_fastion_pass_grid->interface~randind proc~get_distribution get_distribution proc~mc_fastion_pass_grid->proc~get_distribution proc~cyl_to_uvw cyl_to_uvw proc~mc_fastion_pass_grid->proc~cyl_to_uvw proc~cross_product cross_product proc~plane_basis->proc~cross_product interface~interpol_coeff interpol_coeff proc~bt_cx_rates->interface~interpol_coeff proc~track->proc~get_indices proc~track->proc~in_plasma proc~track->proc~get_fields proc~doppler_stark doppler_stark proc~track->proc~doppler_stark proc~write_fida_weights->h5fclose_f proc~write_fida_weights->h5ltmake_dataset_int_f proc~write_fida_weights->h5close_f proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_fida_weights->h5open_f proc~write_fida_weights->h5ltset_attribute_string_f proc~write_fida_weights->h5fcreate_f proc~read_atomic_transitions->proc~h5ltread_dataset_int_scalar_f proc~read_atomic_transitions->h5ltpath_valid_f proc~read_atomic_transitions->h5ltread_dataset_double_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_atomic_transitions->proc~h5ltread_dataset_double_scalar_f h5ltget_dataset_ndims_f h5ltget_dataset_ndims_f proc~read_atomic_transitions->h5ltget_dataset_ndims_f proc~mc_nbi_cell->interface~randu proc~read_atomic_rate->proc~h5ltread_dataset_int_scalar_f proc~read_atomic_rate->h5ltpath_valid_f proc~read_atomic_rate->h5ltread_dataset_double_f proc~read_atomic_rate->proc~h5ltread_dataset_double_scalar_f proc~read_atomic_rate->h5ltget_dataset_ndims_f proc~store_photons->proc~uvw_to_xyz proc~store_photons->proc~get_indices proc~store_photons->proc~get_fields proc~get_passive_grid_indices get_passive_grid_indices proc~store_photons->proc~get_passive_grid_indices proc~spectrum spectrum proc~store_photons->proc~spectrum proc~track_cylindrical->proc~plane_basis proc~track_cylindrical->proc~in_plasma proc~track_cylindrical->proc~get_fields proc~track_cylindrical->proc~cyl_to_uvw proc~track_cylindrical->proc~get_passive_grid_indices proc~track_cylindrical->proc~doppler_stark proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector->proc~line_plane_intersect proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary interface~randind_cdf randind_cdf proc~get_nlaunch->interface~randind_cdf proc~cumsum cumsum proc~get_nlaunch->proc~cumsum proc~rng_init rng_init proc~get_nlaunch->proc~rng_init proc~gyro_step->proc~cross_product proc~in_passive_grid in_passive_grid proc~grid_intersect->proc~in_passive_grid proc~get_nlaunch_pass_grid->interface~randind_cdf proc~get_nlaunch_pass_grid->proc~rng_init proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~store_fw_photons_at_chan->proc~spectrum proc~mc_fastion->interface~randu proc~mc_fastion->proc~get_fields proc~mc_fastion->interface~randind proc~mc_fastion->proc~get_distribution proc~store_npa->proc~xyz_to_uvw proc~store_npa->proc~get_fields proc~read_mc->proc~uvw_to_xyz proc~read_mc->h5ltread_dataset_int_f proc~read_mc->proc~h5ltread_dataset_int_scalar_f proc~read_mc->h5ltpath_valid_f proc~read_mc->proc~in_plasma proc~read_mc->h5ltread_dataset_double_f proc~in_grid in_grid proc~read_mc->proc~in_grid proc~circle_grid_intersect circle_grid_intersect proc~read_mc->proc~circle_grid_intersect proc~write_beam_grid->h5gclose_f proc~write_beam_grid->h5gcreate_f proc~write_beam_grid->proc~xyz_to_uvw proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->h5ltset_attribute_string_f proc~mc_halo->interface~randu proc~mc_halo->proc~get_plasma proc~mc_halo->interface~randn proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->proc~cyl_to_uvw proc~in_plasma->interface~interpol_coeff proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 proc~eigen eigen proc~colrad->proc~eigen proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~linsolve linsolve proc~colrad->proc~linsolve proc~get_ep_denf->proc~xyz_to_uvw interface~interpol interpol proc~get_ep_denf->interface~interpol proc~attenuate->proc~colrad proc~attenuate->proc~get_plasma proc~get_beam_cx_rate->proc~bt_cx_rates proc~get_beam_cx_rate->proc~get_plasma proc~get_beam_cx_rate->proc~bb_cx_rates proc~get_neutron_rate->interface~interpol_coeff proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~get_fields->proc~uvw_to_xyz proc~get_fields->proc~xyz_to_uvw proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~read_f->proc~h5ltread_dataset_int_scalar_f proc~read_f->h5ltpath_valid_f proc~approx_eq approx_eq proc~npa_gyro_range->proc~approx_eq proc~gyro_range gyro_range proc~npa_gyro_range->proc~gyro_range proc~mc_nbi->proc~grid_intersect proc~mc_nbi->proc~in_plasma proc~mc_nbi->interface~randu proc~mc_nbi->interface~randn proc~write_npa_weights->h5fclose_f proc~write_npa_weights->h5ltmake_dataset_int_f proc~write_npa_weights->h5close_f proc~write_npa_weights->proc~write_beam_grid proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->h5open_f proc~write_npa_weights->h5ltset_attribute_string_f proc~write_npa_weights->h5fcreate_f proc~get_plasma->proc~uvw_to_xyz proc~get_plasma->proc~xyz_to_uvw proc~get_plasma->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~gyro_correction->proc~pitch_to_vec proc~gyro_correction->proc~gyro_step proc~gyro_correction->interface~randu proc~write_neutrons->h5fclose_f proc~write_neutrons->h5ltmake_dataset_int_f proc~write_neutrons->h5close_f proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons->h5open_f proc~write_neutrons->h5ltset_attribute_string_f proc~write_neutrons->h5fcreate_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_neutrons->h5ltmake_dataset_double_f proc~line_basis->proc~tb_zyx proc~read_atomic_cross->proc~h5ltread_dataset_int_scalar_f proc~read_atomic_cross->h5ltpath_valid_f proc~read_atomic_cross->h5ltread_dataset_double_f proc~read_atomic_cross->proc~h5ltread_dataset_double_scalar_f proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~get_plasma_extrema get_plasma_extrema proc~make_passive_grid->proc~get_plasma_extrema proc~bb_cx_rates->interface~interpol_coeff proc~read_nuclear_rates->proc~h5ltread_dataset_int_scalar_f proc~read_nuclear_rates->h5ltpath_valid_f proc~read_nuclear_rates->h5ltread_dataset_double_f proc~read_nuclear_rates->proc~h5ltread_dataset_double_scalar_f mpi_allreduce mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~parallel_sum_d0->mpi_allreduce proc~get_distribution->proc~xyz_to_uvw proc~get_distribution->interface~interpol proc~gyro_range->proc~line_plane_intersect proc~gyro_range->proc~in_boundary proc~gyro_surface_coordinates gyro_surface_coordinates proc~gyro_range->proc~gyro_surface_coordinates proc~in_gyro_surface in_gyro_surface proc~gyro_range->proc~in_gyro_surface proc~boundary_edge boundary_edge proc~gyro_range->proc~boundary_edge proc~line_gyro_surface_intersect line_gyro_surface_intersect proc~gyro_range->proc~line_gyro_surface_intersect proc~approx_ge approx_ge proc~in_grid->proc~approx_ge proc~approx_le approx_le proc~in_grid->proc~approx_le proc~circle_grid_intersect->proc~grid_intersect proc~circle_grid_intersect->proc~approx_eq proc~circle_grid_intersect->proc~in_grid proc~cyl_to_xyz cyl_to_xyz proc~get_position->proc~cyl_to_xyz proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~parallel_sum_d1->mpi_allreduce proc~h5ltmake_compressed_dataset_int_f_2->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_3->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_1->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_6->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_7->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_7->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_4->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_5->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_int_f_5->h5pset_shuffle_f proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~balance balance proc~eigen->proc~balance proc~interpol3d_2d_arr interpol3D_2D_arr interface~interpol->proc~interpol3d_2d_arr proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol3d_arr interpol3D_arr interface~interpol->proc~interpol3d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~get_rate_matrix->interface~interpol_coeff proc~rng_init->proc~my_rank proc~rng_init->proc~rng_seed proc~cyl_interpol3d_coeff cyl_interpol3D_coeff interface~interpol_coeff->proc~cyl_interpol3d_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~cyl_interpol3d_coeff_arr cyl_interpol3D_coeff_arr interface~interpol_coeff->proc~cyl_interpol3d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~parallel_sum_d3->mpi_allreduce proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f proc~matinv matinv proc~linsolve->proc~matinv dgetrf dgetrf proc~linsolve->dgetrf dgetrs dgetrs proc~linsolve->dgetrs proc~get_plasma_extrema->proc~in_plasma proc~in_passive_grid->proc~approx_ge proc~in_passive_grid->proc~approx_le proc~uvw_to_cyl uvw_to_cyl proc~in_passive_grid->proc~uvw_to_cyl proc~cyl_to_xyz->proc~uvw_to_xyz proc~cyl_to_xyz->proc~cyl_to_uvw proc~approx_ge->proc~approx_eq proc~cyl_interpol3d_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~cyl_interpol3d_coeff_arr->proc~cyl_interpol3d_coeff proc~cyl_interpol3d_coeff_arr->proc~interpol2d_coeff proc~approx_le->proc~approx_eq proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~interpol3d_2d_arr->interface~interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol3d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol1d_arr->interface~interpol_coeff proc~outerprod outerprod proc~ludcmp->proc~outerprod var panprogramfidasimCallsGraph = svgPanZoom('#programfidasimCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables arg i narg nthreads max_threads seed Source Code fidasim Variables Type Attributes Name Initial character(len=3) :: arg = '' integer :: i integer :: narg integer :: nthreads integer :: max_threads integer :: seed Source Code program fidasim !+ FIDASIM {!../VERSION!} use libfida use hdf5_utils #ifdef _OMP use omp_lib #endif #ifdef _MPI use mpi_utils #endif implicit none character ( 3 ) :: arg = '' integer :: i , narg , nthreads , max_threads , seed #ifdef _VERSION version = _ VERSION #endif #ifdef _MPI call init_mpi () if ( my_rank (). eq . 0 ) call print_banner () #else call print_banner () #endif narg = command_argument_count () if ( narg . eq . 0 ) then #ifdef _MPI if ( my_rank (). eq . 0 ) write ( * , '(a)' ) \"usage: mpirun -np [num_processes] ./fidasim namelist_file\" call cleanup_mpi () #else write ( * , '(a)' ) \"usage: ./fidasim namelist_file [num_threads]\" #endif stop else call get_command_argument ( 1 , namelist_file ) endif !! Check if compression is possible call check_compression_availability () !! measure time call date_and_time ( values = time_start ) call read_inputs () #ifdef _OMP max_threads = OMP_get_num_procs () if ( narg . ge . 2 ) then call get_command_argument ( 2 , arg ) read ( arg , '(i3)' ) nthreads else nthreads = max_threads endif max_threads = min ( nthreads , max_threads ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- OpenMP settings ----\" write ( * , '(T2,\"Number of threads: \",i2)' ) max_threads write ( * , * ) '' endif call OMP_set_num_threads ( max_threads ) #else max_threads = 1 #endif #ifdef _MPI istart = my_rank () + 1 istep = num_ranks () if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- MPI settings ----\" write ( * , '(T2,\"Number of processes: \",i3)' ) istep write ( * , * ) '' endif #endif !! ---------------------------------------------------------- !! ------ INITIALIZE THE RANDOM NUMBER GENERATOR  ----------- !! ---------------------------------------------------------- allocate ( rng ( max_threads )) #ifdef _OMP do i = 1 , max_threads if ( inputs % seed . lt . 0 ) then call rng_init ( rng ( i ), inputs % seed ) else call rng_init ( rng ( i ), inputs % seed + i ) endif enddo #else call rng_init ( rng ( 1 ), inputs % seed ) #endif if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Random Number Generator settings ----\" write ( * , '(T2,\"RNG Seed: \",i10)' ) inputs % seed write ( * , * ) '' endif !! ---------------------------------------------------------- !! ------- READ GRIDS, PROFILES, LOS, TABLES, & FBM -------- !! ---------------------------------------------------------- call read_tables () call read_equilibrium () call make_beam_grid () if ( inputs % calc_beam . ge . 1 ) call read_beam () call read_distribution () allocate ( spec_chords % inter ( beam_grid % nx , beam_grid % ny , beam_grid % nz )) if (( inputs % calc_spec . ge . 1 ). or .( inputs % calc_fida_wght . ge . 1 )) then call read_chords () endif if (( inputs % calc_npa . ge . 1 ). or .( inputs % calc_npa_wght . ge . 1 ). or .( inputs % calc_pnpa . ge . 1 )) then call read_npa () endif call make_diagnostic_grids () !! ---------------------------------------------------------- !! --------------- ALLOCATE THE RESULT ARRAYS --------------- !! ---------------------------------------------------------- !! neutral density array! allocate ( neut % full ( nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz )) allocate ( neut % half ( nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz )) allocate ( neut % third ( nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz )) allocate ( neut % dcx ( nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz )) allocate ( neut % halo ( nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz )) neut % full = 0.d0 neut % half = 0.d0 neut % third = 0.d0 neut % dcx = 0.d0 neut % halo = 0.d0 !! birth profile if ( inputs % calc_birth . ge . 1 ) then allocate ( birth % dens ( 3 , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz )) allocate ( birth % part ( int ( 3 * inputs % n_birth * inputs % n_nbi ))) endif if ( inputs % calc_spec . ge . 1 ) then if ( inputs % calc_brems . ge . 1 ) then allocate ( spec % brems ( inputs % nlambda , spec_chords % nchan )) spec % brems = 0.d0 endif if ( inputs % calc_bes . ge . 1 ) then allocate ( spec % full ( inputs % nlambda , spec_chords % nchan )) allocate ( spec % half ( inputs % nlambda , spec_chords % nchan )) allocate ( spec % third ( inputs % nlambda , spec_chords % nchan )) spec % full = 0.d0 spec % half = 0.d0 spec % third = 0.d0 endif if ( inputs % calc_dcx . ge . 1 ) then allocate ( spec % dcx ( inputs % nlambda , spec_chords % nchan )) spec % dcx = 0.d0 endif if ( inputs % calc_halo . ge . 1 ) then allocate ( spec % halo ( inputs % nlambda , spec_chords % nchan )) spec % halo = 0.d0 endif if ( inputs % calc_cold . ge . 1 ) then allocate ( spec % cold ( inputs % nlambda , spec_chords % nchan )) spec % cold = 0.d0 endif if ( inputs % calc_fida . ge . 1 ) then allocate ( spec % fida ( inputs % nlambda , spec_chords % nchan , particles % nclass )) spec % fida = 0.d0 endif if ( inputs % calc_pfida . ge . 1 ) then allocate ( spec % pfida ( inputs % nlambda , spec_chords % nchan , particles % nclass )) spec % pfida = 0.d0 endif endif if ( inputs % calc_npa . ge . 1 ) then npa % nchan = npa_chords % nchan allocate ( npa % part ( npa % nmax )) if ( inputs % dist_type . eq . 1 ) then npa % nenergy = fbm % nenergy allocate ( npa % energy ( npa % nenergy )) npa % energy = fbm % energy else allocate ( npa % energy ( npa % nenergy )) do i = 1 , npa % nenergy npa % energy ( i ) = real ( i - 0.5 ) enddo endif allocate ( npa % flux ( npa % nenergy , npa % nchan , particles % nclass )) npa % flux = 0.0 endif if ( inputs % calc_pnpa . ge . 1 ) then pnpa % nchan = npa_chords % nchan allocate ( pnpa % part ( pnpa % nmax )) if ( inputs % dist_type . eq . 1 ) then pnpa % nenergy = fbm % nenergy allocate ( pnpa % energy ( pnpa % nenergy )) pnpa % energy = fbm % energy else allocate ( pnpa % energy ( pnpa % nenergy )) do i = 1 , pnpa % nenergy pnpa % energy ( i ) = real ( i - 0.5 ) enddo endif allocate ( pnpa % flux ( pnpa % nenergy , pnpa % nchan , particles % nclass )) pnpa % flux = 0.0 endif if ( inputs % calc_neutron . ge . 1 ) then allocate ( neutron % rate ( particles % nclass )) neutron % rate = 0.d0 endif !! ----------------------------------------------------------------------- !! --------------- CALCULATE/LOAD the BEAM and HALO DENSITY--------------- !! ----------------------------------------------------------------------- if ( inputs % load_neutrals . eq . 1 ) then call read_neutrals () if ( inputs % calc_bes . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'nbi:     ' , time ( time_start ) endif call nbi_spec () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_dcx . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'dcx:     ' , time ( time_start ) endif call dcx_spec () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_halo . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'halo:    ' , time ( time_start ) endif call halo_spec () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif else if ( inputs % calc_beam . ge . 1 ) then !! ----------- BEAM NEUTRALS ---------- !! if ( inputs % calc_nbi_dens . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'nbi:     ' , time ( time_start ) endif call ndmc if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' if ( inputs % calc_birth . eq . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'write birth:    ' , time ( time_start ) endif call write_birth_profile () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif endif !! ---------- DCX (Direct charge exchange) ---------- !! if ( inputs % calc_dcx_dens . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'dcx:     ' , time ( time_start ) endif call dcx () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ---------- HALO ---------- !! if ( inputs % calc_halo_dens . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'halo:    ' , time ( time_start ) endif call halo () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ---------- WRITE NEUTRALS ---------- !! if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'write neutrals:    ' , time ( time_start ) endif #ifdef _MPI if ( my_rank (). eq . 0 ) call write_neutrals () #else call write_neutrals () #endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif endif !! ----------------------------------------------------------------------- !!------------------------------ COLD D-ALPHA ---------------------------- !! ----------------------------------------------------------------------- if ( inputs % calc_cold . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'cold:    ' , time ( time_start ) endif call cold_spec () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ----------------------------------------------------------------------- !!----------------------------- BREMSSTRAHLUNG --------------------------- !! ----------------------------------------------------------------------- if ( inputs % calc_brems . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'bremsstrahlung:    ' , time ( time_start ) endif call bremsstrahlung () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ----------------------------------------------------------------------- !! --------------------- CALCULATE the FIDA RADIATION -------------------- !! ----------------------------------------------------------------------- if ( inputs % calc_fida . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'fida:    ' , time ( time_start ) endif if ( inputs % dist_type . eq . 1 ) then call fida_f () else call fida_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_pfida . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'pfida:   ' , time ( time_start ) endif if ( inputs % dist_type . eq . 1 ) then call pfida_f () else call pfida_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_spec . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'write spectra:    ' , time ( time_start ) endif #ifdef _MPI if ( my_rank (). eq . 0 ) call write_spectra () #else call write_spectra () #endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ----------------------------------------------------------------------- !! ----------------------- CALCULATE the NPA FLUX ------------------------ !! ----------------------------------------------------------------------- if ( inputs % calc_npa . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'npa:     ' , time ( time_start ) endif if ( inputs % dist_type . eq . 1 ) then call npa_f () else call npa_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_pnpa . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'pnpa:     ' , time ( time_start ) endif if ( inputs % dist_type . eq . 1 ) then call pnpa_f () else call pnpa_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if (( inputs % calc_npa . ge . 1 ). or .( inputs % calc_pnpa . ge . 1 )) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'write npa:    ' , time ( time_start ) endif call write_npa () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ------------------------------------------------------------------- !! ------------------- Calculation of neutron flux ------------------- !! ------------------------------------------------------------------- if ( inputs % calc_neutron . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'neutron rate:    ' , time ( time_start ) endif if ( inputs % dist_type . eq . 1 ) then call neutron_f () else call neutron_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ------------------------------------------------------------------- !! ----------- Calculation of weight functions ----------------------- !! ------------------------------------------------------------------- if ( inputs % calc_fida_wght . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'fida weight function:    ' , time ( time_start ) endif if ( inputs % calc_fida_wght . eq . 1 ) then call fida_weights_los () else call fida_weights_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_npa_wght . ge . 1 ) then if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'npa weight function:    ' , time ( time_start ) endif call npa_weights () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif #ifdef _MPI call cleanup_mpi () #endif if ( inputs % verbose . ge . 1 ) then write ( * , * ) 'END: hour:minute:second ' , time ( time_start ) endif end program fidasim","tags":"","loc":"program/fidasim.html","title":"fidasim – FIDASIM"},{"text":"Uses atomic_tables H5LT HDF5 hdf5_utils utilities omp_lib program~~generate_tables~~UsesGraph program~generate_tables generate_tables HDF5 HDF5 program~generate_tables->HDF5 H5LT H5LT program~generate_tables->H5LT module~hdf5_utils hdf5_utils program~generate_tables->module~hdf5_utils module~utilities utilities program~generate_tables->module~utilities omp_lib omp_lib program~generate_tables->omp_lib module~atomic_tables atomic_tables program~generate_tables->module~atomic_tables module~hdf5_utils->HDF5 module~hdf5_utils->H5LT module~utilities->omp_lib iso_c_binding iso_c_binding module~utilities->iso_c_binding module~atomic_tables->HDF5 module~atomic_tables->H5LT module~atomic_tables->module~hdf5_utils module~mpi_utils mpi_utils module~atomic_tables->module~mpi_utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Tabulates cross sections and reaction rates and writes them to a HDF5 file Calls program~~generate_tables~~CallsGraph program~generate_tables generate_tables proc~write_bt_d_d write_bt_D_D program~generate_tables->proc~write_bt_d_d my_rank my_rank program~generate_tables->my_rank h5gclose_f h5gclose_f program~generate_tables->h5gclose_f init_mpi init_mpi program~generate_tables->init_mpi h5fclose_f h5fclose_f program~generate_tables->h5fclose_f proc~check_compression_availability check_compression_availability program~generate_tables->proc~check_compression_availability proc~write_bt_h_h write_bt_H_H program~generate_tables->proc~write_bt_h_h num_ranks num_ranks program~generate_tables->num_ranks proc~print_default_namelist print_default_namelist program~generate_tables->proc~print_default_namelist proc~write_bt_h_e write_bt_H_e program~generate_tables->proc~write_bt_h_e proc~write_einstein write_einstein program~generate_tables->proc~write_einstein h5close_f h5close_f program~generate_tables->h5close_f proc~write_bb_h_aq write_bb_H_Aq program~generate_tables->proc~write_bb_h_aq h5ltset_attribute_string_f h5ltset_attribute_string_f program~generate_tables->h5ltset_attribute_string_f proc~write_bb_h_h write_bb_H_H program~generate_tables->proc~write_bb_h_h proc~write_bt_h_aq write_bt_H_Aq program~generate_tables->proc~write_bt_h_aq proc~write_bb_h_e write_bb_H_e program~generate_tables->proc~write_bb_h_e omp_get_num_procs omp_get_num_procs program~generate_tables->omp_get_num_procs h5fcreate_f h5fcreate_f program~generate_tables->h5fcreate_f omp_set_num_threads omp_set_num_threads program~generate_tables->omp_set_num_threads h5open_f h5open_f program~generate_tables->h5open_f cleanup_mpi cleanup_mpi program~generate_tables->cleanup_mpi h5gcreate_f h5gcreate_f program~generate_tables->h5gcreate_f proc~write_bb_d_d write_bb_D_D program~generate_tables->proc~write_bb_d_d proc~write_bt_d_d->h5gclose_f proc~write_bt_d_d->h5ltset_attribute_string_f proc~write_bt_d_d->h5gcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_d_d->h5ltmake_dataset_int_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_d_d->h5ltmake_dataset_double_f interface~parallel_sum parallel_sum proc~write_bt_d_d->interface~parallel_sum interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~check_compression_availability->h5close_f proc~check_compression_availability->h5open_f h5zget_filter_info_f h5zget_filter_info_f proc~check_compression_availability->h5zget_filter_info_f h5zfilter_avail_f h5zfilter_avail_f proc~check_compression_availability->h5zfilter_avail_f proc~write_bt_h_h->h5gclose_f proc~write_bt_h_h->h5ltset_attribute_string_f proc~write_bt_h_h->h5gcreate_f proc~write_bt_h_h->h5ltmake_dataset_int_f proc~write_bt_h_h->h5ltmake_dataset_double_f proc~write_bt_h_h->interface~parallel_sum proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e->h5gclose_f proc~write_bt_h_e->h5ltset_attribute_string_f proc~write_bt_h_e->h5gcreate_f proc~write_bt_h_e->h5ltmake_dataset_int_f proc~write_bt_h_e->h5ltmake_dataset_double_f proc~write_bt_h_e->interface~parallel_sum proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein->h5gclose_f proc~write_einstein->h5ltset_attribute_string_f proc~write_einstein->h5gcreate_f proc~write_einstein->h5ltmake_dataset_int_f proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq->h5gclose_f proc~write_bb_h_aq->h5ltset_attribute_string_f proc~aq_cx Aq_cx proc~write_bb_h_aq->proc~aq_cx proc~aq_excit Aq_excit proc~write_bb_h_aq->proc~aq_excit proc~write_bb_h_aq->h5ltmake_dataset_int_f proc~write_bb_h_aq->h5ltmake_dataset_double_f proc~write_bb_h_aq->interface~parallel_sum proc~aq_ioniz Aq_ioniz proc~write_bb_h_aq->proc~aq_ioniz proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h->h5gclose_f proc~write_bb_h_h->h5ltset_attribute_string_f proc~write_bb_h_h->h5gcreate_f proc~p_ioniz p_ioniz proc~write_bb_h_h->proc~p_ioniz proc~write_bb_h_h->h5ltmake_dataset_int_f proc~p_excit p_excit proc~write_bb_h_h->proc~p_excit proc~write_bb_h_h->h5ltmake_dataset_double_f proc~write_bb_h_h->interface~parallel_sum proc~p_cx p_cx proc~write_bb_h_h->proc~p_cx proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq->h5gclose_f proc~write_bt_h_aq->h5ltset_attribute_string_f proc~write_bt_h_aq->h5ltmake_dataset_int_f proc~write_bt_h_aq->h5ltmake_dataset_double_f proc~write_bt_h_aq->interface~parallel_sum proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e->h5gclose_f proc~write_bb_h_e->h5ltset_attribute_string_f proc~write_bb_h_e->h5gcreate_f proc~e_excit e_excit proc~write_bb_h_e->proc~e_excit proc~write_bb_h_e->h5ltmake_dataset_int_f proc~write_bb_h_e->h5ltmake_dataset_double_f proc~write_bb_h_e->interface~parallel_sum proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~e_ioniz e_ioniz proc~write_bb_h_e->proc~e_ioniz proc~write_bb_d_d->h5gclose_f proc~write_bb_d_d->h5ltset_attribute_string_f proc~write_bb_d_d->h5gcreate_f proc~d_d_fusion_t d_d_fusion_t proc~write_bb_d_d->proc~d_d_fusion_t proc~d_d_fusion_he d_d_fusion_he proc~write_bb_d_d->proc~d_d_fusion_he proc~write_bb_d_d->h5ltmake_dataset_int_f proc~write_bb_d_d->h5ltmake_dataset_double_f proc~write_bb_d_d->interface~parallel_sum proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~aq_cx_n Aq_cx_n proc~aq_cx->proc~aq_cx_n proc~e_excit_n e_excit_n proc~e_excit->proc~e_excit_n proc~p_ioniz_n p_ioniz_n proc~p_ioniz->proc~p_ioniz_n proc~aq_excit_n Aq_excit_n proc~aq_excit->proc~aq_excit_n proc~p_excit_n p_excit_n proc~p_excit->proc~p_excit_n proc~parallel_sum_d5 parallel_sum_d5 interface~parallel_sum->proc~parallel_sum_d5 proc~parallel_sum_d4 parallel_sum_d4 interface~parallel_sum->proc~parallel_sum_d4 proc~parallel_sum_d0 parallel_sum_d0 interface~parallel_sum->proc~parallel_sum_d0 proc~parallel_sum_d1 parallel_sum_d1 interface~parallel_sum->proc~parallel_sum_d1 proc~parallel_sum_d2 parallel_sum_d2 interface~parallel_sum->proc~parallel_sum_d2 proc~parallel_sum_i1 parallel_sum_i1 interface~parallel_sum->proc~parallel_sum_i1 proc~parallel_sum_i0 parallel_sum_i0 interface~parallel_sum->proc~parallel_sum_i0 proc~parallel_sum_i2 parallel_sum_i2 interface~parallel_sum->proc~parallel_sum_i2 proc~parallel_sum_d3 parallel_sum_d3 interface~parallel_sum->proc~parallel_sum_d3 proc~p_cx_n p_cx_n proc~p_cx->proc~p_cx_n proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz->proc~aq_ioniz_n proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~e_ioniz_n e_ioniz_n proc~e_ioniz->proc~e_ioniz_n proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n->proc~e_ioniz_2_janev proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n->proc~e_ioniz_1_janev proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n->proc~e_ioniz_3_janev proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n->proc~aq_cx_n_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 mpi_allreduce mpi_allreduce proc~parallel_sum_d5->mpi_allreduce proc~parallel_sum_d4->mpi_allreduce proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~chunk_size chunk_size proc~h5ltmake_compressed_dataset_double_f_7->proc~chunk_size h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n->proc~p_ioniz_2_omullane proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n->proc~p_ioniz_5_omullane proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz_1_janev p_ioniz_1_janev proc~p_ioniz_n->proc~p_ioniz_1_janev proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~parallel_sum_d0->mpi_allreduce proc~parallel_sum_d1->mpi_allreduce proc~parallel_sum_d2->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~parallel_sum_i1->mpi_allreduce proc~parallel_sum_i0->mpi_allreduce proc~parallel_sum_i2->mpi_allreduce proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->proc~chunk_size proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~parallel_sum_d3->mpi_allreduce proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n->proc~c6_ioniz_1_janev proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n->proc~aq_ioniz_n_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_1 proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1->proc~p_cx_janev proc~p_cx_1_2_janev p_cx_1_2_janev proc~p_cx_1->proc~p_cx_1_2_janev proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aljan1 aljan1 proc~p_cx_1_2_janev->proc~aljan1 proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev var panprogramgenerate_tablesCallsGraph = svgPanZoom('#programgenerate_tablesCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables namelist_file arg tables_file n_max m_max time_start hour minu sec argc max_threads nthreads fid gid error exis Variables Type Attributes Name Initial character(len=200) :: namelist_file character(len=3) :: arg character(len=200) :: tables_file = '' integer :: n_max integer :: m_max integer, dimension(8) :: time_start integer :: hour integer :: minu integer :: sec integer :: argc integer :: max_threads integer :: nthreads integer(kind=HID_T) :: fid integer(kind=HID_T) :: gid integer :: error logical :: exis","tags":"","loc":"program/generate_tables.html","title":"generate_tables – FIDASIM"},{"text":"Introduction In fusion plasmas fast-ions can undergo the following process with injected neutral Hydrogen: H&#94;+ + H(n) \\rightarrow H&#94;\\ast(m) + H&#94;+ where H&#94;\\ast(m) is an excited state of Hydrogen.\nThe newly created fast-neutral H&#94;\\ast(m) can then be collisionally de-excited to a lower state, emitting a doppler shifted photon as illustrated below. Both the fast-neutral and the photon contain information about the velocity of fast-ion before it was neutralized.\nThere are two types diagnostics that take advantage of this fact: Fast-ion D-α (FIDA) diagnostics and Neutral Particle Analyzers (NPA).\nThe interpretation of the diagnostic signals requires modeling of the above process which has a complicated dependence on the plasma parameters, electromagnetic fields, and neutral beam and diagnostic geometry. Towards this end, FIDASIM was created. History The very first implementation of FIDASIM was written by Yadong Luo and Bill Heidbrink while Yadong was working on his thesis .\nSubsequently, Deyong Liu added features to simulate NPA signals. The IDL version of the code was distributed for public use and documented in a journal publication . Originally, FIDASIM was written in the IDL programming language and was prohibitively slow.\nAs a part of his thesis Ben Geiger wrote a version of FIDASIM written in Fortran 90.\nThis prototype version was parallelized using OpenMP and was orders of magnitude faster but was not as easy to use as the IDL version and was difficult to port to different devices. Luke Stagner as a part of his thesis has rewritten Ben Geiger's Fortran 90 version to be compatible with any axisymmetric fusion device as well as additional functionality.\nLuke has also put special effort on making FIDASIM user friendly; the result of which you are currently reading and should be eternally grateful. \nCurrently, he is the FIDASIM expert. Most recently, the primary responsibility for FIDASIM support has been transferred to UC Irvine PhD student Alvin Garcia . Alvin helped introduce passive signals, incorporated 3D geometry capabilities and created 'out-of-the-box' visualization tools. Capabilities Currently, FIDASIM has routines for calculating: Neutral beam deposition and birth profile Halo neutral density Visible Bremsstrahlung Beam and Halo spectra FIDA spectra NPA Flux FIDA and NPA phase-space sensitivities i.e. weight functions Installation For installation instructions check out our Getting Started guide.","tags":"","loc":"page//index.html","title":"User Guide – FIDASIM"},{"text":"Getting Started Welcome the the FIDASIM Getting Started guide. Click the section that catches your fancy. Installation Preprocessing Inputs Running FIDASIM Reading Outputs Devices using FIDASIM Visualization","tags":"","loc":"page/01_getting_started/index.html","title":"Getting Started – FIDASIM"},{"text":"Installing FIDASIM So you have decided to install FIDASIM. Don't worry this should be relatively painless. Note If you experiance problems installing FIDASIM you did something wrong and you should let us know so we can laugh at you (and also help you) The following code snippets assumes you are using a BASH shell.\nTo figure out what shell you currently have run echo $SHELL to find out. Installing FIDASIM Dependencies Getting FIDASIM source Downloading source directly Cloning the git repository Setting up environmental variables Building FIDASIM Generating Atomic Tables Run a test case Now what Dependencies FIDASIM has the following dependencies: Linux because all other operating systems are inferior Make for building FIDASIM. (Required) Fortran, C, and C++ compilers. (Required) GNU(>v4.6) and Intel(>13) compilers are supported.\n  Note you cannot mix and match different compilers. zlib for file compression. (Required) Anaconda Python for python scripts and pre-processing. (Optional) IDL for pre-processing (Optional) HDF5 1.8.16 for reading and writing data files (Included) EFIT for electro-magnetic fields (Partially Included) git for version control (Optional) Ford for creating HTML documentation (Optional) LinkChecker for validating HTML documentation (Optional) The following commands will install the required dependencies (Tested on Ubuntu 16.04) sudo apt-get update\nsudo apt-get install build-essential\nsudo apt-get install gfortran\nsudo apt-get install zlib1g-dev Getting FIDASIM source It's rather difficult to run software you haven't downloaded. There are two ways of getting the source code. Downloading source directly The most recent version of FIDASIM (2.0.0-dev) can be downloaded from here Once you have downloaded the .tar.gz or .zip file unpack it using the following commands. tar -zxf FIDASIM-2.0.0-dev.tar.gz or if you downloaded the .zip file unzip FIDASIM-2.0.0-dev.zip There should now be a directory named FIDASIM-2.0.0-dev in your current directory. Enter the directory using cd FIDASIM-2.0.0-dev Cloning the git repository If you are planning to develop FIDASIM it is best to use git. git clone https://github.com/D3DEnergetic/FIDASIM.git FIDASIM cd FIDASIM By default you will be on the master branch which may or may not be in a usable state.\nTo use the release version run the command git checkout v2.0.0-dev Setting up environmental variables FIDASIM needs to know where some things are so you have to set the following environmental variables in your .bashrc file located in your home directory. export FIDASIM_DIR = /path/to/fidasim/install/directory export FC = gfortran #use 'ifort' for Intel Fortran compiler export CC = gcc #use 'icc' for Intel C compiler export CXX = g++ #use 'icpc' for Intel C++ compiler #For using helper routines export PATH = $FIDASIM_DIR /deps/hdf5/bin: $FIDASIM_DIR /lib/scripts: $PATH export PATH = $FIDASIM_DIR /deps/efit: $FIDASIM_DIR /test: $PATH export IDL_PATH = \"+ $FIDASIM_DIR : $IDL_PATH :<IDL_DEFAULT>\" export PYTHONPATH = $FIDASIM_DIR /lib/python: $PYTHONPATH ulimit -s unlimited #Omit this if you like segfaults replacing /path/to/fidasim/install/directory with the real directory. To set the environmental variables in the current shell run source ~/.bashrc Building FIDASIM Once you are in the source directory (and have all the dependencies installed) run the following make Once running, go get a coffee since it will take a while because HDF5 is being built as well. Once make has completed check if FIDASIM compiled correctly. user@computer:~/FIDASIM-2.0.0-dev$ ./fidasim\n   ____ ____ ___   ___    ____ ____ __  ___\n  / __//  _// _ \\ / _ | / __//  _// | /  /\n / _/ _/ / / // // __ | _ \\ \\ _/ / / / | _/ /\n/_/  /___//____//_/ | _ | /___//___//_/  /_/\n\nVersion: v2.0.0-dev\n\nFIDASIM is released as open source code under the MIT Licence.\nFor more information visit http://d3denergetic.github.io/FIDASIM/ Good job! You installed FIDASIM! But wait there's more. Generating Atomic Tables Calculating reaction rates on the fly is time consuming so we need to pre-compute them to save time.\nThe following code snippit will generate the atomic tables using the default settings.\nThe default settings should be appropriate for most use cases, however, it may be necessary to generate custom atomic tables.\nIn that case edit the file tables/table_settings.dat before running the following command ./tables/generate_tables ./tables/default_settings.dat [ num_threads ] Warning This is computationally expensive so make sure you run this on a computer\nwhere you won't get angry emails for using up all the CPU's Now would be a good time to get more coffee... or maybe a nap. Run a test case From the command line run_tests.py, \"/place/where/you/want/the/output\" Note: This requires python Or from within IDL IDL > run_tests, \"/place/where/you/want/the/output\" Some stuff that will make sense later will flash by and when its done you should see something like SUCCESS: FIDASIM pre-processing completed\nTo run FIDASIM use the following command\n/u/lstagner/FIDASIM/fidasim /p/fida/lstagner/TEST/test_1a_inputs.dat Now do what the computer says.\nThink of as good practice for when the robots take over . It should print out the following. [ lstagner@dawson061 ]% / u / lstagner / FIDASIM / fidasim / p / fida / lstagner / TEST / test_1a_inputs . dat ____ ____ ___ ___ ____ ____ __ ___ / __ // _ // _ \\ / _ | / __ // _ // |/ / / _ / _ / / / // // __ | _ \\ \\ _ / / / /| _ / / / _ / / ___ // ____ // _ / | _ |/ ___ // ___ // _ / / _ / Version : v2 .0.0 - dev FIDASIM is released as open source code under the MIT Licence . For more information visit http : // d3denergetic . github . io / FIDASIM / ---- Shot settings ---- Shot : 1 Time : 1000 [ ms ] Runid : test ---- Input files ---- Tables file : / p / fida / FIDASIM / tables / atomic_tables . h5 Geometry file : / p / fida / lstagner / TEST / test_geometry . h5 Equilibrium file : / p / fida / lstagner / TEST / test_equilibrium . h5 Distribution file : / p / fida / lstagner / TEST / test_distribution . h5 ---- OpenMP settings ---- Number of threads : 16 ---- Atomic tables settings ---- Maximum n / m : 6 Beam / Fast - ion mass : 2.014 [ amu ] Thermal / Bulk - ion mass : 2.014 [ amu ] Impurity mass : 12.011 [ amu ] ---- Interpolation grid settings ---- Nr : 70 Nz : 100 Nphi : 1 dA : 4.00 [ cm&#94;2 ] ---- Beam grid settings ---- Nx : 50 Ny : 60 Nz : 70 dV : 8.00 [ cm&#94;3 ] alpha : 0.00 [ rad ] beta : 0.00 [ rad ] gamma : 0.00 [ rad ] origin : [ 0.00,   0.00,   0.00 ] [ cm ] Number of cells in plasma : 184494 ---- Neutral beam settings ---- Beam : test_beam Power : 1.70 [ MW ] Voltage : 72.50 [ keV ] ---- Passive neutral grid settings ---- Nr : 70 Nz : 100 Nphi : 10 R range = [ 100.00,238.00 ] Z range = [ -100.00, 98.00 ] Phi range = [ 4.25, 5.15 ] dA : 4.00 [ cm&#94;3 ] ---- Fast-ion distribution settings ---- Distribution type : Fast - ion Density Function F ( energy , pitch , R , Z , Phi ) Nenergy = 75 Npitch = 50 Nr = 70 Nz = 100 Nphi = 1 Energy range = [ 0.81,120.87 ] Pitch range = [ -0.98, 0.98 ] R range = [ 100.00,238.00 ] Z range = [ -100.00, 98.00 ] Phi range = [ 0.00, 0.00 ] Ntotal = 1.214E+19 ---- FIDA/BES settings ---- FIDA / BES System : SPECTRAL Number of channels : 3 ---- NPA settings ---- NPA System : NPA Number of channels : 3 nbi : 19 : 06 : 28 --- elapsed: 0:00:23 # of markers : 50000 birth profile written to : / p / fida / lstagner / TEST / test_birth . h5 dcx : 19 : 06 : 42 --- elapsed: 0:00:37 # of markers : 500000 halo : 19 : 07 : 13 --- elapsed: 0:01:08 # of markers : 527175 --- Seed/DCX: 1.000 # of markers : 672040 --- Seed/DCX: 0.600 # of markers : 792640 --- Seed/DCX: 0.366 # of markers : 873160 --- Seed/DCX: 0.225 # of markers : 900615 --- Seed/DCX: 0.139 # of markers : 913130 --- Seed/DCX: 0.086 # of markers : 919085 --- Seed/DCX: 0.053 # of markers : 921060 --- Seed/DCX: 0.033 # of markers : 921935 --- Seed/DCX: 0.020 # of markers : 922180 --- Seed/DCX: 0.013 write neutrals : 19 : 14 : 31 --- elapsed: 0:08:26 neutral density written to : / p / fida / lstagner / TEST / test_neutrals . h5 cold : 19 : 14 : 35 --- elapsed: 0:08:30 bremsstrahlung : 19 : 14 : 36 --- elapsed: 0:08:31 fida : 19 : 14 : 36 --- elapsed: 0:08:31 # of markers : 5000000 pfida : 19 : 15 : 19 --- elapsed: 0:09:14 # of markers : 50000000 write spectra : 19 : 20 : 47 --- elapsed: 0:14:42 Spectra written to : / p / fida / lstagner / TEST / test_spectra . h5 npa : 19 : 20 : 47 --- elapsed: 0:14:42 # of markers : 5000000 Number of Active NPA particles that hit a detector : 40733 pnpa : 19 : 21 : 21 --- elapsed: 0:15:16 # of markers : 50000000 Number of Passive NPA particles that hit a detector : 116510 write npa : 19 : 26 : 47 --- elapsed: 0:20:42 NPA data written to : / p / fida / lstagner / TEST / test_npa . h5 neutron rate : 19 : 26 : 47 --- elapsed: 0:20:42 Rate : 5.97592E+14 [ neutrons/s ] write neutrons : 19 : 28 : 16 --- elapsed: 0:22:11 Neutrons written to : / p / fida / lstagner / TEST / test_neutrons . h5 fida weight function : 19 : 28 : 25 --- elapsed: 0:22:20 Number of Channels : 3 Nlambda : 1000 Nenergy : 50 Npitch : 50 Ngyro : 100 Maximum Energy : 100.00 LOS averaged : True Channel : 1 Radius : 200.00 Mean Fast - ion Density : 5.00757E+11 Channel : 2 Radius : 170.00 Mean Fast - ion Density : 5.00757E+11 Channel : 3 Radius : 140.00 Mean Fast - ion Density : 5.00757E+11 write fida weights : 19 : 28 : 41 --- elapsed: 0:22:36 FIDA weights written to : / p / fida / lstagner / TEST / test_fida_weights . h5 npa weight function : 19 : 28 : 48 --- elapsed: 0:22:43 Number of Channels : 3 Nenergy : 50 Npitch : 50 Maximum energy : 100.00 Channel : 1 Radius : 200.000 Flux : 0.00000E+00 Weight : 3.48351E+03 Channel : 2 Radius : 170.000 Flux : 0.00000E+00 Weight : 1.41572E+03 Channel : 3 Radius : 140.000 Flux : 0.00000E+00 Weight : 8.38209E+02 write npa weights : 19 : 33 : 50 --- elapsed: 0:27:45 NPA weights written to : / p / fida / lstagner / TEST / test_npa_weights . h5 END : hour : minute : second 19 : 33 : 50 --- elapsed: 0:27:45 Congratulations! You followed the instructions. Now what Most likely you won't be satisfied by just running a test case. Click here to learn how to make the input files used by FIDASIM.","tags":"","loc":"page/01_getting_started/01_install.html","title":"Installation – FIDASIM"},{"text":"Preprocessing Inputs Preprocessing Inputs Create FIDASIM input files using PREFIDA Making Grids Reading GEQDSK files Extracting GEQDSK file and Plasma Parameters from TRANSP Translating NUBEAM Neutral Beam Geometry Extracting the Fast-ion Distribution Function from TRANSP/NUBEAM Reading NUBEAM/SPIRAL Fast-ion Distributions Visualization: Inputs Create FIDASIM input files using PREFIDA FIDASIM requires inputs to be in a specific format.\nPREFIDA( IDL , Python ) is an routine that takes the required inputs, checks their validity, and transforms them into a form FIDASIM understands. PREFIDA is called as follows IDL > prefida, inputs, grid, nbi, plasma, fields, dist , spec = spec, npa = npa or using Python >>> import preprocessing >>> preprocessing . prefida ( inputs , grid , nbi , plasma , fields , dist , spec = spec , npa = npa ) where arguments are defined as follows. Click the argument's description for extreme detail. inputs : General Settings grid : Interpolation grid nbi : Neutral Beam Geometry fields : Electromagnetic Fields plasma : Plasma Parameters dist : Fast-ion Distribution spec : Spectral Geometry npa : NPA Geometry PREFIDA will create the following files Namelist File Geometry File Equilibrium File Distribution File Most devices may have already setup helper routines to make running FIDASIM and Prefida easy. \nClick here to find out if someone has done your work for you. Making Grids PREFIDA uses two types of grids**: the Interpolation Grid and the Beam Grid . \nBy default, axisymmetry is assumed and the Interpolation Grid is a 2D grid in the R-Z plane that is used for interpolating the plasma parameters and the electromagnetic fields .\nA 3D cylindrical grid in R, Z and Phi can be created if the user inputs phi variable information. \nThe routine rz_grid ( IDL , Python ) accomplishes the task and creates the grid structure. For example, the command below will create a 2D grid, IDL > grid = rz_grid(rmin,rmax,nr,zmin,zmax,nz) whereas the following command will create a 3D grid, IDL > grid = rz_grid(rmin,rmax,nr,zmin,zmax,nz,phimin = phimin,phimax = phimax,nphi = nphi) In Python, the 2D grid can be created with, >>> from fidasim.utils import rz_grid >>> grid = rz_grid ( rmin , rmax , nr , zmin , zmax , nz ) and the 3D grid with, >>> from fidasim.utils import rz_grid >>> grid = rz_grid ( rmin , rmax , nr , zmin , zmax , nz , phimin = phimin , phimax = phimax , nphi = nphi ) The output 2D grid structure will have Phi = 0.0 and nphi = 1, but the 3D grid structure will have values based on what the user input. The beam grid is a 3D grid used for most of the calculations in FIDASIM. It represents the 3D volume where the neutral beam lives and interacts with the plasma. \nTo maximize the resolution of this grid it is useful to align the beam grid with the beam centerline.\nThe routine beam_grid ( IDL , Python ) calculates from the neutral beam geometry the optimal beam grid settings that would align the grid with the beam sightline. IDL > bgrid = beam_grid(nbi,rstart) or in Python >>> from fidasim.utils import beam_grid >>> bgrid = beam_grid ( nbi , rstart ) **FIDASIM creates a third grid for passive calculations . Reading GEQDSK files Most tokamaks use EFIT to reconstruct the MHD equilibrium.\nTo make things easy we provide the IDL routine read_geqdsk.pro to calculate the fields structure from EFITs GEQDSK file. IDL> fields = read_geqdsk('g159243.00300',grid,rho=rho,btipsign=btipsign) or in Python >>> from fidasim.utils import read_geqdsk >>> fields , rho , btipsign = read_geqdsk ( 'g159243.00300' , grid ) where grid is the interpolation grid, rho keyword is a named variable that recieves the sqrt(normalized torodial flux) upon executation, and btipsign is a named variable that recieves the Bt-Ip sign (-1 for anti-parallel, 1 for parallel). Extracting GEQDSK file and Plasma Parameters from TRANSP It is convenient to grab FIDASIM inputs from previously calculated TRANSP runs. The python script, extract_transp_geqdsk , can be used to extract the MHD equilibrium from TRANSP's .DATA* files .\nFor example: extract_transp_geqdsk /p/transparch/result/NSTX/14 159243H06 will create a GEQDSK file for every .DATA* file in the 159243H06 TRANSP run.\nRun extract_transp_geqdsk -h for the full documentation. The IDL routine extract_transp_plasma.pro or the equivalent Python function creates the plasma structure at a given time. IDL> plasma = extract_transp_plasma(\"159243H06.CDF\",1.02,grid,rho) or in Python >>> from fidasim.utils import extract_transp_plasma >>> plasma = extract_transp_plasma ( \"159243H06.CDF\" , 1.02 , grid , rho ) where grid is the interpolation grid and rho is the sqrt(normalized torodial flux). Translating NUBEAM Neutral Beam Geometry The IDL routine nubeam_geometry.pro can be used to translate the NUBEAM neutral beam geometry definition into the correct format . IDL> nbi = nubeam_geometry(nubeam) or in Python >>> from fidasim.utils import nubeam_geometry >>> nbi = nubeam_geometry ( nubeam ) where nubeam is a structure/dictionary containing the NUBEAM geometry variables taken from the TRANSP namelist. Extracting the Fast-ion Distribution Function from TRANSP/NUBEAM The python script, extract_transp_fbm , provides a easy way to extract the fast-ion distribution. For example: extract_transp_fbm /p/transparch/result/NSTX/14 159243H06 extracts a distribution function for every .DATA* file in the 159243H06 TRANSP run.\nRun extract_transp_fbm -h for the full documentation. Reading NUBEAM/SPIRAL Fast-ion Distributions Out of the box, FIDASIM provides IDL and Python routines for reading different fast-ion distributions.\nWe provide routines for: read_nubeam.pro : TRANSP/NUBEAM distribution functions read_mc_nubeam.pro : Monte Carlo TRANSP/NUBEAM Guiding Center distribution read_spiral.pro : SPIRAL Guiding Center distribution IDL> f = read_nubeam(nubeam_distribution_file,grid,btipsign = -1) IDL> mcf = read_mc_nubeam(mc_nubeam_distribution_file,Ntotal=1e19,btipsign=-1) IDL> s = read_spiral(spiral_file,Ntotal=1e19,btipsign=-1) or in Python >>> from fidasim.utils import read_nubeam >>> f = read_nubeam ( nubeam_distribution_file , grid , btipsign =- 1 ) Visualization: Inputs Visualizing your inputs can be done by executing plot_inputs found in lib/scripts/ Depending on what you wish to plot, your inputs, geometry, equilibrium and/or distribution files will need to be located in the same folder.\nBelow are brief descriptions and examples of what the script can currently handle: To plot all of your inputs, simply indicate the directory and run ID. plot_inputs /p/fida/lstagner/TEST/ test_1a To plot only the beam and diagnostic geometry, append the optional argument -g plot_inputs /p/fida/lstagner/TEST/ test_1a -g In a similar fashion, append -p, -f and/or -d to plot the plasma, fields and/or distribution function inputs, respectively. If you are plotting many FIDA or NPA line of sights, then it might be beneficial for you to append -l to remove the legend from the 3D plot. If you wish to plot lineouts on your figures, simply indicate the value and dimension you want to cut through.\nFor example, if you are interested in seeing what the plasma lineout looks like at R = 170 cm along the z axis, execute the following command plot_inputs /p/fida/lstagner/TEST/ test_1a -p -rz 170 There are many more possible lineouts that can be viewed, so run plot_inputs -h to look at the help documentation.","tags":"","loc":"page/01_getting_started/02_preprocess.html","title":"Preprocessing Inputs – FIDASIM"},{"text":"Running FIDASIM Running FIDASIM Recommended Hardware Running Interactively Submitting to a clusters job schedular using submit_fidasim Running FIDASIM is as easy as running lstagner @computer : ~/ FIDASIM $ . / fidasim ____ ____ ___ ___ ____ ____ __ ___ / __ // _ // _ \\ / _ | / __ // _ // |/ / / _ / _ / / / // // __ | _ \\ \\ _ / / / /| _ / / / _ / / ___ // ____ // _ / | _ |/ ___ // ___ // _ / / _ / Version : v2 .0.0 - dev FIDASIM is released as open source code under the MIT Licence . For more information visit http : // d3denergetic . github . io / FIDASIM / Actually having FIDASIM produce something takes a bit of thought Recommended Hardware The following settings will give a reasonable runtime. 32 threads on a shared memory node (All calculations are done on a single node) At least 2 GB of memory Warning By default FIDASIM will use all the threads available. If another process is hogging a core it will cause FIDASIM to stall. To prevent this use the num_threads optional argument Running Interactively [ lstagner@dawson061 ]% . / fidasim / p / fida / lstagner / TEST / test_inputs . dat 16 ____ ____ ___ ___ ____ ____ __ ___ / __ // _ // _ \\ / _ | / __ // _ // |/ / / _ / _ / / / // // __ | _ \\ \\ _ / / / /| _ / / / _ / / ___ // ____ // _ / | _ |/ ___ // ___ // _ / / _ / Version : v2 .0.0 - dev FIDASIM is released as open source code under the MIT Licence . For more information visit http : // d3denergetic . github . io / FIDASIM / ---- Shot settings ---- Shot : 1 Time : 1000 [ ms ] Runid : test ---- Input files ---- Tables file : / p / fida / FIDASIM / tables / atomic_tables . h5 Geometry file : / p / fida / lstagner / TEST / test_geometry . h5 Equilibrium file : / p / fida / lstagner / TEST / test_equilibrium . h5 Distribution file : / p / fida / lstagner / TEST / test_distribution . h5 ---- OpenMP settings ---- Number of threads : 16 ---- Atomic tables settings ---- Maximum n / m : 6 Beam / Fast - ion mass : 2.014 [ amu ] Thermal / Bulk - ion mass : 2.014 [ amu ] Impurity mass : 12.011 [ amu ] ---- Interpolation grid settings ---- Nr : 70 Nz : 100 Nphi : 1 dA : 4.00 [ cm&#94;2 ] ---- Beam grid settings ---- Nx : 50 Ny : 60 Nz : 70 dV : 8.00 [ cm&#94;3 ] alpha : 0.00 [ rad ] beta : 0.00 [ rad ] gamma : 0.00 [ rad ] origin : [ 0.00,   0.00,   0.00 ] [ cm ] Number of cells in plasma : 184494 ---- Neutral beam settings ---- Beam : test_beam Power : 1.70 [ MW ] Voltage : 72.50 [ keV ] ---- Passive neutral grid settings ---- Nr : 70 Nz : 100 Nphi : 10 R range = [ 100.00,238.00 ] Z range = [ -100.00, 98.00 ] Phi range = [ 4.25, 5.15 ] dA : 4.00 [ cm&#94;3 ] ---- Fast-ion distribution settings ---- Distribution type : Fast - ion Density Function F ( energy , pitch , R , Z , Phi ) Nenergy = 75 Npitch = 50 Nr = 70 Nz = 100 Nphi = 1 Energy range = [ 0.81,120.87 ] Pitch range = [ -0.98, 0.98 ] R range = [ 100.00,238.00 ] Z range = [ -100.00, 98.00 ] Phi range = [ 0.00, 0.00 ] Ntotal = 1.214E+19 ---- FIDA/BES settings ---- FIDA / BES System : SPECTRAL Number of channels : 3 ---- NPA settings ---- NPA System : NPA Number of channels : 3 nbi : 19 : 06 : 28 --- elapsed: 0:00:23 # of markers : 50000 birth profile written to : / p / fida / lstagner / TEST / test_birth . h5 dcx : 19 : 06 : 42 --- elapsed: 0:00:37 # of markers : 500000 halo : 19 : 07 : 13 --- elapsed: 0:01:08 # of markers : 527175 --- Seed/DCX: 1.000 # of markers : 672040 --- Seed/DCX: 0.600 # of markers : 792640 --- Seed/DCX: 0.366 # of markers : 873160 --- Seed/DCX: 0.225 # of markers : 900615 --- Seed/DCX: 0.139 # of markers : 913130 --- Seed/DCX: 0.086 # of markers : 919085 --- Seed/DCX: 0.053 # of markers : 921060 --- Seed/DCX: 0.033 # of markers : 921935 --- Seed/DCX: 0.020 # of markers : 922180 --- Seed/DCX: 0.013 write neutrals : 19 : 14 : 31 --- elapsed: 0:08:26 neutral density written to : / p / fida / lstagner / TEST / test_neutrals . h5 cold : 19 : 14 : 35 --- elapsed: 0:08:30 bremsstrahlung : 19 : 14 : 36 --- elapsed: 0:08:31 fida : 19 : 14 : 36 --- elapsed: 0:08:31 # of markers : 5000000 pfida : 19 : 15 : 19 --- elapsed: 0:09:14 # of markers : 50000000 write spectra : 19 : 20 : 47 --- elapsed: 0:14:42 Spectra written to : / p / fida / lstagner / TEST / test_spectra . h5 npa : 19 : 20 : 47 --- elapsed: 0:14:42 # of markers : 5000000 Number of Active NPA particles that hit a detector : 40733 pnpa : 19 : 21 : 21 --- elapsed: 0:15:16 # of markers : 50000000 Number of Passive NPA particles that hit a detector : 116510 write npa : 19 : 26 : 47 --- elapsed: 0:20:42 NPA data written to : / p / fida / lstagner / TEST / test_npa . h5 neutron rate : 19 : 26 : 47 --- elapsed: 0:20:42 Rate : 5.97592E+14 [ neutrons/s ] write neutrons : 19 : 28 : 16 --- elapsed: 0:22:11 Neutrons written to : / p / fida / lstagner / TEST / test_neutrons . h5 fida weight function : 19 : 28 : 25 --- elapsed: 0:22:20 Number of Channels : 3 Nlambda : 1000 Nenergy : 50 Npitch : 50 Ngyro : 100 Maximum Energy : 100.00 LOS averaged : True Channel : 1 Radius : 200.00 Mean Fast - ion Density : 5.00757E+11 Channel : 2 Radius : 170.00 Mean Fast - ion Density : 5.00757E+11 Channel : 3 Radius : 140.00 Mean Fast - ion Density : 5.00757E+11 write fida weights : 19 : 28 : 41 --- elapsed: 0:22:36 FIDA weights written to : / p / fida / lstagner / TEST / test_fida_weights . h5 npa weight function : 19 : 28 : 48 --- elapsed: 0:22:43 Number of Channels : 3 Nenergy : 50 Npitch : 50 Maximum energy : 100.00 Channel : 1 Radius : 200.000 Flux : 0.00000E+00 Weight : 3.48351E+03 Channel : 2 Radius : 170.000 Flux : 0.00000E+00 Weight : 1.41572E+03 Channel : 3 Radius : 140.000 Flux : 0.00000E+00 Weight : 8.38209E+02 write npa weights : 19 : 33 : 50 --- elapsed: 0:27:45 NPA weights written to : / p / fida / lstagner / TEST / test_npa_weights . h5 END : hour : minute : second 19 : 33 : 50 --- elapsed: 0:27:45 Submitting to a clusters job schedular using submit_fidasim submit_fidasim is a python routine that schedules a FIDASIM job on a cluster. For example lstagner@computer:~$ submit_fidasim /u/lstagner/TEST will submit any incomplete FIDASIM runs in the /u/lstagner/TEST directory. Alternatively lstagner@computer:~$ submit_fidasim /u/lstagner/TEST/test_inputs.dat will submit just the test FIDASIM run.\nSlurm and PBS resource managers are supported. Run submit_fidasim -h for the full documentation.","tags":"","loc":"page/01_getting_started/03_running.html","title":"Running FIDASIM – FIDASIM"},{"text":"Reading FIDASIM Outputs Reading FIDASIM Outputs Using HDF5 tools Using IDL Using Python Using Julia Using HDF5 tools The HDF5 installation provides several useful tools for inspecting HDF5 files. lstagner@computer:~/TEST$ h5ls test_geometry.h5 nbi                      Group npa                      Group spec                     Group lstagner@computer:~/TEST$ h5ls test_geometry.h5/nbi adist                    Dataset {1} aoffy                    Dataset {1} aoffz                    Dataset {1} ashape                   Dataset {1} awidy                    Dataset {1} awidz                    Dataset {1} axis                     Dataset {3} data_source              Dataset {SCALAR} divy                     Dataset {3} divz                     Dataset {3} focy                     Dataset {SCALAR} focz                     Dataset {SCALAR} name                     Dataset {SCALAR} naperture                Dataset {SCALAR} shape                    Dataset {SCALAR} src                      Dataset {3} widy                     Dataset {SCALAR} widz                     Dataset {SCALAR} lstagner@computer:~/TEST$ h5ls -v test_geometry.h5/nbi/src Opened \"test_geometry.h5\" with sec2 driver. src                      Dataset {3/3} Attribute: description scalar Type:      47-byte null-terminated ASCII string Data:  \"Position of the center of the beam source grid\" Attribute: units scalar Type:      3-byte null-terminated ASCII string Data:  \"cm\" Location:  1:5024 Links:     1 Chunks:    {3} 24 bytes Storage:   24 logical bytes, 20 allocated bytes, 120.00% utilization Filter-0:  shuffle-2 OPT {8} Filter-1:  deflate-1 OPT {9} Type:      native double lstagner@computer:~/TEST$ h5ls -d test_geometry.h5/nbi/src src                      Dataset {3} Data: (0) 0, -532, 0 Using IDL The IDL routine read_hdf5.pro is provided to read any HDF5 file. IDL > f = read_hdf5( \"./test_geometry.h5\" )\nIDL > help ,f ** Structure < 284b698 > , 4 tags, length = 2224 , data length = 2194 , refs = 1 : NBI             STRUCT -> < Anonymous > Array[ 1 ]\n   NPA             STRUCT -> < Anonymous > Array[ 1 ]\n   SPEC            STRUCT -> < Anonymous > Array[ 1 ]\n   DESCRIPTION STRING 'Geometric quantities for FIDASIM' IDL > help ,f.nbi ** Structure < 27fb4d8 > , 20 tags, length = 752 , data length = 734 , refs = 2 : ADIST           STRUCT -> < Anonymous > Array[ 1 ]\n   AOFFY           STRUCT -> < Anonymous > Array[ 1 ]\n   AOFFZ           STRUCT -> < Anonymous > Array[ 1 ]\n   ASHAPE          STRUCT -> < Anonymous > Array[ 1 ]\n   AWIDY           STRUCT -> < Anonymous > Array[ 1 ]\n   AWIDZ           STRUCT -> < Anonymous > Array[ 1 ] AXIS STRUCT -> < Anonymous > Array[ 1 ]\n   DATA_SOURCE     STRUCT -> < Anonymous > Array[ 1 ]\n   DIVY            STRUCT -> < Anonymous > Array[ 1 ]\n   DIVZ            STRUCT -> < Anonymous > Array[ 1 ]\n   FOCY            STRUCT -> < Anonymous > Array[ 1 ]\n   FOCZ            STRUCT -> < Anonymous > Array[ 1 ]\n   NAME            STRUCT -> < Anonymous > Array[ 1 ]\n   NAPERTURE       STRUCT -> < Anonymous > Array[ 1 ]\n   SHAPE           STRUCT -> < Anonymous > Array[ 1 ]\n   SRC             STRUCT -> < Anonymous > Array[ 1 ]\n   WIDY            STRUCT -> < Anonymous > Array[ 1 ]\n   WIDZ            STRUCT -> < Anonymous > Array[ 1 ]\n   DESCRIPTION STRING 'Neutral Beam Geometry' COORDINATE_SYSTEM STRING 'Right-handed cartesian' IDL > help ,f.nbi.src ** Structure < 27f5908 > , 3 tags, length = 56 , data length = 56 , refs = 2 : DESCRIPTION STRING 'Position of the center of the beam source grid' UNITS STRING 'cm' DATA DOUBLE Array[ 3 ] Using Python The h5py library can be used to read and write HDF5 files. >>> import h5py as h5 >>> f = h5 . File ( \"./test_geometry.h5\" ) >>> [ k for k in f . keys ()] [ 'nbi' , 'npa' , 'spec' ] >>> [ k for k in f [ 'nbi' ] . keys ()] [ 'adist' , 'aoffy' , 'aoffz' , 'ashape' , 'awidy' , 'awidz' , 'axis' , 'data_source' , 'divy' , 'divz' , 'focy' , 'focz' , 'name' , 'naperture' , 'shape' , 'src' , 'widy' , 'widz' ] >>> f [ \"/nbi/src\" ] . value array ([ 0. , - 532. , 0. ]) Using Julia The HDF5.jl library can be used to read and write HDF5 files. julia > using HDF5 julia > f = h5open ( \"test_geometry.h5\" ) HDF5 data file : test_geometry . h5 julia > names ( f ) 3 - element Array { ByteString , 1 } : \"nbi\" \"npa\" \"spec\" julia > names ( f [ \"/nbi\" ]) 11 - element Array { ByteString , 1 } : \"adist\" \"aoffy\" \"aoffz\" \"ashape\" \"awidy\" \"awidz\" \"axis\" \"data_source\" \"divy\" \"divz\" \"focy\" \"focz\" \"name\" \"naperture\" \"shape\" \"src\" \"widy\" \"widz\" julia > read ( f [ \"/nbi/src\" ]) 3 - element Array { Float64 , 1 } : 0.0 - 532.0 0.0 julia > h5read ( \"test_geometry.h5\" , \"/nbi/src\" ) 3 - element Array { Float64 , 1 } : 0.0 - 532.0 0.0","tags":"","loc":"page/01_getting_started/04_reading.html","title":"Reading Outputs – FIDASIM"},{"text":"DIII-D FIDASIM is being used at DIII-D for simulating and validating their FIDA, NPA and neutron diagnostics.\nIt it also being used in charge exchange recombination spectroscopy to validate deuterium density measurements. The routines for running a DIII-D FIDASIM run are available here A FIDASIM module containing the DIII-D specific routines is available on the Iris cluster. module load fidasim fidasim NSTX-U FIDASIM is being used at NSTX-U for simulating and validating their FIDA and NPA diagnostics. The routines for running a NSTX-U FIDASIM run are available here","tags":"","loc":"page/01_getting_started/05_devices.html","title":"Devices using FIDASIM – FIDASIM"},{"text":"Visualizing Inputs and Outputs Visualizing Inputs and Outputs Visualization: Inputs Visualization: Outputs Visualization: Inputs Visualizing your inputs can be done by executing plot_inputs found in lib/scripts/ Depending on what you wish to plot, your inputs, geometry, equilibrium and/or distribution files will need to be located in the same folder.\nBelow are brief descriptions and examples of what the script can currently handle: To plot all of your inputs, simply indicate the directory and run ID. plot_inputs /p/fida/lstagner/TEST/ test_1a To plot only the beam and diagnostic geometry, append the optional argument -g plot_inputs /p/fida/lstagner/TEST/ test_1a -g In a similar fashion, append -p, -f and/or -d to plot the plasma, fields and/or distribution function inputs, respectively. If you are plotting many FIDA or NPA line of sights, then it might be beneficial for you to append -l to remove the legend from the 3D plot. If you wish to plot lineouts on your figures, simply indicate the value and dimension you want to cut through.\nFor example, if you are interested in seeing what the plasma lineout looks like at R = 170 cm along the z axis, execute the following command plot_inputs /p/fida/lstagner/TEST/ test_1a -p -rz 170 There are many more possible lineouts that can be viewed, so run plot_inputs -h to look at the help documentation. Visualization: Outputs Visualizing your outputs can be done by executing plot_outputs found in lib/scripts/ Plotting data from your spectra or npa files, and printing the neutron rate can be done in various ways.\nLet's start with the easiest method first.\nAssuming all of your output files are located in the same folder, the following command will search that folder for all run IDs present.\nThen, it will plot all of the spectra and npa data for each run ID on every FIDA and NPA channel.\nFurthermore, it will also print out the neutron rate. plot_outputs -d /p/fida/lstagner/TEST/ -s -as -n -an If you are interested in only one shot, e.g. test_1a, add -r test_1a to your command. Let's now consider a more specific example.\nWhat if your files are scattered around in different folders?\nWhat if you are only interested in the active FIDA emission?\nWhat if you only want to view channels 1 and 3?\nThe example below does this for two different files located in different folders. plot_outputs -p /p/fida/lstagner/TEST/test_1a_spectra.h5 /different_path/test_2a_spectra.h5 -f -ls 1 3 Now that you have a grasp on how the script works, take a look at the help documentation plot_outputs -h to see what else the code is capable of.","tags":"","loc":"page/01_getting_started/06_visual.html","title":"Visualization – FIDASIM"},{"text":"Physics Plasma Parameters, Fields, and Distributions Atomic Tables Collisional Radiative Model Neutral Beam and Halo Spectroscopy Neutral Particle Analyzer Phase-space Sensitivities Cold Neutrals and Passive Signals","tags":"","loc":"page/02_physics/index.html","title":"Physics – FIDASIM"},{"text":"Plasma Parameters and Fields Distributions Guiding Center Distribution Function: F(E,p,R,Z[,Phi]) Guiding Center Monte Carlo Distribution Full-orbit Monte Carlo Distribution Relevent Namelist Settings Fortran References table {\nwidth: 100%;\n}\ntable,th,td {\nborder: 1px solid black;\nborder-collapse: collapse;\n}\nth, td {\npadding: 5px;\n}\nth {\ntext-align: center;\n} Plasma Parameters and Fields It is common in Tokamaks to input the plasma parameters and fields as flux functions.\nHowever, this approach makes several assumptions that may not be true in non-tokamak devices.\nThe default settings of FIDASIM are to map the plasma parameters and fields onto the 2D R-Z grid. If the user inputs any Phi variable information, the plasma parameters and fields will be mapped onto a 3D R-Z-Phi cylindrical grid. Furthermore, a boolean mask is used to indicate where the plasma and fields are well defined. FIDASIM reads the plasma parameters and fields from an HDF5 file structured as follows... [ runid ] _equilibrium . h5 ├── plasma └── fields where the plasma group has the following datasets Variable Type Rank Dimensions Units Description nr Int16 0 NA NA Number of radii nz Int16 0 NA NA Number of z values nphi Int16 0 NA NA Number of phi values (Optional) r Float64 1 [ nr ] cm Array of radii z Float64 1 [ nz ] cm Array of z values phi Float64 1 [ nphi ] rad Array of phi values (Optional) r2d Float64 2 [ nr , nz ] cm 2D array of radii r = r2d(r,z) z2d Float64 2 [ nr , nz ] cm 2D array of z values z = z2d(r,z) time Float64 0 NA s Time when the plasma parameter data was collected data_source String 0 NA NA Source of the plasma parameter data mask Int16 2 [ nr , nz ] NA Boolean mask that indicates where the plasma is well defined te Float64 2 [ nr , nz ] keV Electron temperature ti Float64 2 [ nr , nz ] keV Ion temperature dene Float64 2 [ nr , nz ] cm&#94;-3 Electron density denn Float64 2 [ nr , nz ] cm&#94;-3 Cold neutral density zeff Float64 2 [ nr , nz ] NA Z-effective vr Float64 2 [ nr , nz ] cm/s Radial component of the bulk plasma rotation/flow vt Float64 2 [ nr , nz ] cm/s Torodial/Phi component of the bulk plasma rotation/flow vz Float64 2 [ nr , nz ] cm/s Z component of the bulk plasma rotation/flow description String 0 NA NA Plasma Parameters coordinate system String 0 NA NA Cylindrical and where the fields group has the following datasets Variable Type Rank Dimensions Units Description nr Int16 0 NA NA Number of radii nz Int16 0 NA NA Number of z values nphi Int16 0 NA NA Number of phi values (Optional) r Float64 1 [ nr ] cm Array of radii z Float64 1 [ nz ] cm Array of z values phi Float64 1 [ nphi ] rad Array of phi values (Optional) r2d Float64 2 [ nr , nz ] cm 2D array of radii r = r2d(r,z) z2d Float64 2 [ nr , nz ] cm 2D array of z values z = z2d(r,z) time Float64 0 NA s Time when the fields data were collected/reconstructed data_source String 0 NA NA Source of the fields data mask Int16 2 [ nr , nz ] NA Boolean mask that indicates where the fields are well defined br Float64 2 [ nr , nz ] T Radial component of the magnetic field bt Float64 2 [ nr , nz ] T Torodial/Phi component of the magnetic field bz Float64 2 [ nr , nz ] T Z component of the magnetic field er Float64 2 [ nr , nz ] V/m Radial component of the electric field et Float64 2 [ nr , nz ] V/m Torodial/Phi component of the electric field ez Float64 2 [ nr , nz ] V/m Z component of the electric field description String 0 NA NA Electromagnetic Field coordinate system String 0 NA NA Cylindrical Distributions The fast-ion distribution function typically does not have a functional form.\nThis means that we need to input the fast-ion distribution function into FIDASIM.\nFIDASIM accepts three different types of fast-ion distributions. Guiding Center Distribution Function: F(E,p,R,Z[,Phi]) Guiding Center Monte Carlo distribution Full-orbit Monte Carlo distribution Supporting different types of distributions greatly facilitates the study of fast-ion transport. FIDASIM reads the fast-ion distribution from an HDF5 file that has the following variables depending on the distribution type. Guiding Center Distribution Function: F(E,p,R,Z[,Phi]) Variable Type Rank Dimensions Units Description type Int16 0 NA NA Distribution type (1) nr Int16 0 NA NA Number of radii nz Int16 0 NA NA Number of z values nphi Int16 0 NA NA Number of phi values (Optional) r Float64 1 [ nr ] cm Array of radii z Float64 1 [ nz ] cm Array of z values phi Float64 1 [ nphi ] cm Array of phi values (Optional) r2d Float64 2 [ nr , nz ] cm 2D array of radii r = r2d(r,z) z2d Float64 2 [ nr , nz ] cm 2D array of z values z = z2d(r,z) time Float64 0 NA s Time of the distribution data_source String 0 NA NA Source of the distribution data nenergy Int16 0 NA NA Number of energy values npitch Int16 0 NA NA Number of pitch values energy Float64 1 [ nenergy ] keV Energy array pitch Float64 1 [ npitch ] NA Pitch array w.r.t magnetic field denf Float64 3 [ nr , nz [, nphi ]] cm&#94;-3 Fast-ion density f Float64 5 [ nenergy , npitch , nr , nz [, nphi ]] fast-ions/(dE dP cm&#94;3) Fast-ion distribution F(E,p,R,Z[,Phi]) The Guiding Center Distribution Function is a function of Energy, pitch, R, Z and Phi.\nThe distribution can be mapped onto the 2D R-Z grid or 3D cylindrical grid, where the plasma parameters and fields are defined. Guiding Center Monte Carlo Distribution Variable Type Rank Dimensions Units Description type Int16 0 NA NA Distribution type (2) time Float64 0 NA s Time of the distribution data_source String 0 NA NA Source of the distribution data nparticle Int32 0 NA NA Number of MC particles nclass Int16 0 NA NA Number of orbit classes class Int16 1 [ nparticle ] NA Orbit class of the MC particle weight Float64 1 [ nparticle ] fast-ions Weight of the MC particle r Float64 1 [ nparticle ] cm R positions of the MC particle z Float64 1 [ nparticle ] cm Z positions of the MC particle phi Float64 1 [ nparticle ] rad Phi positions of the MC particle (Optional) energy Float64 1 [ nparticle ] keV Energy of the MC particle pitch Float64 1 [ nparticle ] NA Pitch w.r.t the magnetic field of the MC particle The sum( weight ) = # of Fast-ions in phase space sampled by the MC particles. The class variable can take values in the range of 1: nclass . \nIf there are multiple classes of particles the FIDA signal for each class will be calculated. Full-orbit Monte Carlo Distribution Variable Type Rank Dimensions Units Description type Int16 0 NA NA Distribution type (3) time Float64 0 NA s Time of the distribution data_source String 0 NA NA Source of the distribution data nparticle Int32 0 NA NA Number of MC particles nclass Int16 0 NA NA Number of orbit classes class Int16 1 [ nparticle ] NA Orbit class of the MC particle weight Float64 1 [ nparticle ] fast-ions Weight of the MC particle r Float64 1 [ nparticle ] cm R positions of the MC particle z Float64 1 [ nparticle ] cm Z positions of the MC particle phi Float64 1 [ nparticle ] rad Phi positions of the MC particle (Optional) vr Float64 1 [ nparticle ] cm/s Radial component of the MC particle velocity vt Float64 1 [ nparticle ] cm/s Torodial/Phi component of the MC particle velocity vz Float64 1 [ nparticle ] cm/s Z component of the MC particle velocity The sum( weight ) = # of Fast-ions in phase space sampled by the MC particles. The class variable can take values in the range of 1: nclass .\nIf there are multiple classes of particles the FIDA signal for each class will be calculated. Relevent Namelist Settings ai : Ion mass [amu] impurity_charge : Impurity charge number 5=Boron, 6=Carbon, ... ab : Fast/Beam-ion mass [amu] equilibrium_file : Equilibrium file location distribution_file : Distribution file location Fortran References InterpolationGrid : Definition of R-Z grid Profiles and LocalProfiles : Derived type for Plasma parameters EMFields and LocalEMFields : Derived type for Fields get_plasma : Gets plasma parameters at a given position get_fields : Gets fields at a given position get_distribution : Gets fast-ion distribution at a given position read_equilibrium : Reads equilbrium file into Equilibrium structure FastIonDistribution : Derived type for describing GC distribution functions FastIon : Derived type for describing a Monte Carlo particle FastIonParticles : Defines a distribution of Monte Carlo particles read_distribution : Reads distribution file","tags":"","loc":"page/02_physics/01_plasma.html","title":"Plasma Parameters, Fields, and Distributions – FIDASIM"},{"text":"Atomic Cross Sections Approximate Hydrogen Charge Exchange Cross Sections Generating Tables Atomic & Nuclear Data References Relevent Namelist Settings Fortran References Hydrogen-Hydrogen Interactions H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m), \\, m \\gt n H&#94;+ + H(n) \\rightarrow H&#94;+ + H&#94;+ + e Hydrogen-Electron Interactions e + H(n) \\rightarrow e + H(m),\\, m \\gt n e + H(n) \\rightarrow e + H&#94;+ + e Hydrogen-Carbon₆ Interactions C&#94;{6+} + H(n) \\rightarrow C&#94;{5+} + H&#94;+ C&#94;{6+} + H(n) \\rightarrow C&#94;{6+} + H(m), \\, m \\gt n C&#94;{6+} + H(n) \\rightarrow C&#94;{6+} + H&#94;+ + e Atomic Cross Sections As a neutral particle travels through a plasma it undergoes several different types of interactions Charge Exchange with Hydrogen and Impurities Excitation with Electrons, Hydrogen, and Impurities Ionization with Electrons, Hydrogen, and Impurities These cross sections, as well as Maxwellian averaged reaction rates, are pre-computed over a range of logarithmically spaced collision energies and target temperatures. Approximate Hydrogen Charge Exchange Cross Sections Some of atomic transitions needed by FIDASIM are not available.\nIn particular, FIDASIM needs the n/m-resolved charge exchange cross sections.\nWhile certain transitions are available through ADAS [4] others are not, as such, certain approximations are needed to fill out the table. For instance, we use the equivalence principle (reversibility formula) to mirror the known ADAS cross sections. \\sigma(n_f \\rightarrow n_i) = \\frac{E_i}{E_f} \\frac{n_i&#94;2}{n_f&#94;2} \\sigma(n_i \\rightarrow n_f) This however is insufficient to completly fill out the table. Additionally, since the total cross sections for a transition from a given n to any m are given by Janev[2] we can then also assume that the probability of a transition from the n \\rightarrow m state decreases exponentially with energy difference between the states we can \"spread\" the total cross section amoung the different m levels. Note Total cross sections for n>4 are not available so the n=4 total cross sections are used.\nAlso we normalize the m levels to the Janev tables for consistancy. A summary of the various approximations used in the charge exchange tables is given in the table below. (Spreading is done over m/rows) .tg  {border-collapse:collapse;border-spacing:0;margin:0 auto;}\n.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}\n.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}\n.tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}\n.tg .tg-fo0g{font-weight:bold;background-color:#009901;color:#ffffff;text-align:center;vertical-align:top}\n.tg .tg-0mq6{font-weight:bold;background-color:#fe0000;color:#ffffff;text-align:center;vertical-align:top}\n.tg .tg-bq31{font-weight:bold;background-color:#3166ff;color:#ffffff;text-align:center;vertical-align:top} H-H Charge Exchange Data Source n \\ m 1 2 3 4 5 6 Total 1 ADAS ADAS ADAS ADAS Spread Spread Janev(n=1) 2 Equivalence ADAS ADAS Spread Spread Spread Janev(n=2) 3 Equivalence ADAS ADAS ADAS ADAS Spread ADAS/Janev(n=3) 4 Equivalence Equivalence Equivalence Spread Spread Spread Janev(n=4) 5 Spread Equivalence Equivalence Spread Spread Spread Janev(n=4) 6 Spread Equivalence Equivalence Spread Spread Spread Janev(n=4) Generating Tables FIDASIM provides a routine, generate_tables to generate the atomic tables. The default settings should be appropriate for most devices but in some cases it may be necessary to generate custom tables.\nFor instance, the default tables are calculated assuming the main impurity is Carbon-6 so it would be inappropriate to the default tables if you have a different main impurity.\nTo generate custom tables from the tables directory run ./generate_tables > table_settings.dat to generate the namelist file that contains the default settings. Edit this file to change the settings. After editing the namelist file run ./generate_tables table_settings.dat [ NUM_THREADS ] <-- NUM_THREADS is optional and wait for a couple of hours depending on the number of threads used. Atomic & Nuclear Data References The atomic data is taken from a variety of sources [1-5] W.L. Wiese, M.W. Smith, and B.M. Glennon. Atomic Transition Probabilities. Volume 1. Hydrogen through Neon . National Bureau of Standards Washington DC Institute for Basic Standards, 1966. R.K. Janev, D. Reiter, and  U. Samm. Collision processes in low-temperature hydrogen plasmas . Forschungszentrum Jülich, Zentralbibliothek, 2003. M. O'Mullane. Review of proton impact driven ionisation from the excited levels in neutral hydrogen beams . ADAS note, 2009. ADAS: Atomic Data and Analysis Structure R.K. Janev and J.J. Smith. Cross sections for collision processes of hydrogen atoms with electrons, protons and multiply charged ions. Atomic and Plasma-Material Interaction Data for Fusion: Volume 4, 1993. Reinhold, C. O., R. E. Olson, and W. Fritsch. Excitation of atomic hydrogen by fully stripped ions. Physical Review A 41.9 1990. Bosch, H-S., and G. M. Hale. Improved formulas for fusion cross-sections and thermal reactivities. !+ Nuclear fusion 32.4 1992. Aladdin Database: R.K. Janev, W.D. Langer, K. Evans Jr., D.E. Post Jr. H-HE-PLASMA (1987) A more precice references can be found in the Fortran function documentation. For example, p_cx_janev Relevent Namelist Settings tables_file : Location of atomic tables file Fortran References atomic_tables : Module containing routines to calculate atomic tables and reaction rates generate_tables : Program to create atomic tables file AtomicCrossSection : Defines a n/m-resolved atomic cross section table AtomicRates : Defines a n/m-resolved atomic cross section table AtomicTransitions : Defines an atomic table for populating and de-populating reaction rates AtomicTables : Atomic tables for various types of interactions need by FIDASIM NuclearRates : Defines nuclear fusion reaction rate table read_atomic_cross : Reads atomic cross section from file read_atomic_rate : Reads atomic rates from file read_atomic_transitions : Reads in a atomic transitions table from file read_nuclear_rates : Reads in nuclear reaction rates from file read_tables : Reads all cross sections and rates needed by FIDASIM m_spread : Spreads total n cross section amoung m states Hydrogen-Hydrogen Interactions H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m), \\, m \\gt n H&#94;+ + H(n) \\rightarrow H&#94;+ + H&#94;+ + e Hydrogen-Electron Interactions e + H(n) \\rightarrow e + H(m),\\, m \\gt n e + H(n) \\rightarrow e + H&#94;+ + e Hydrogen-Carbon₆ Interactions C&#94;{6+} + H(n) \\rightarrow C&#94;{5+} + H&#94;+ C&#94;{6+} + H(n) \\rightarrow C&#94;{6+} + H(m), \\, m \\gt n C&#94;{6+} + H(n) \\rightarrow C&#94;{6+} + H&#94;+ + e","tags":"","loc":"page/02_physics/02_atomic_tables.html","title":"Atomic Tables – FIDASIM"},{"text":"Collisional Radiative Model Fortran References Collisional Radiative Model The collisions that a neutral particle experiences as it travels through a plasma changes the distribution of its energy level population.\nThe types of collisions that FIDASIM takes into account is as follows Spontaneous decay: A_{m \\rightarrow n} / A_{n \\rightarrow m} Electron-impact excitation/de-excitation: q&#94;e_{m \\rightarrow n} / q&#94;e_{n \\rightarrow m} Ion-impact excitation/de-excitation: q&#94;i_{m \\rightarrow n} / q&#94;i_{n \\rightarrow m} Impurity-impact excitation/de-excitation: q&#94;Z_{m \\rightarrow n} / q&#94;Z_{n \\rightarrow m} Electron-impact ionization: I&#94;e_n Ion-impact ionization: I&#94;i_n Impurity-impact ionization: I&#94;Z_n Charge exchange with ions: X&#94;i_n Charge exchange with impurities: X&#94;Z_n The above rate coefficients have units of cm&#94;3/s and are calculated by averaging the respective collisional cross sections with a Maxwellian of the relevent species.\nThe population of the n&#94;{th} energy level of a neutral atom, f_n , can be described by the following time dependent differential equation \\frac{df_n}{dt} = - \\left ( \\sum_{k=i,Z} f_n d_k X&#94;k_n + \\sum_{k=e,i,Z} f_n d_k I&#94;k_n \\right ) \\\\\n+ \\sum_{m>n} \\left (f_m A_{m \\rightarrow n} + \\sum_{k=e,i,Z} (f_m d_k q&#94;k_{m \\rightarrow n} - f_n d_k q&#94;k_{n \\rightarrow m}) \\right ) \\\\\n+ \\sum_{n>m} \\left (-f_n A_{n \\rightarrow m} + \\sum_{k=e,i,Z} (f_m d_k q&#94;k_{m \\rightarrow n} - f_n d_k q&#94;k_{n \\rightarrow m}) \\right ) where the d_k are the respective target densities. By rearranging the terms and letting q&#94;k_{n \\rightarrow m} represent excitation/de-excitation depending on the order of the indices we can get the following equation \\frac{df_n}{dt} = C_{n,n} f_n + \\sum_{m \\ne n} C_{n,m} f_m where C_{n,n} = - \\left [ \\sum_{k=i,Z} d_k X&#94;k_n + \\sum_{k=e,i,Z} d_k I&#94;k_n + \\sum_{m \\ne n} \\left ( A_{n \\rightarrow m} + \\sum_{k=e,i,Z} d_k q&#94;k_{n \\rightarrow m} \\right ) \\right ] and C_{n,m} = A_{m \\rightarrow n} + \\sum_{k=e,i,Z} d_k q&#94;k_{m \\rightarrow n} The system of differential equations can be compactly represented as a matrix multiplication. \\frac{d \\mathbf{f}}{dt} = \\mathbf{C} \\cdot \\mathbf{f} The solution of this matrix differential equation takes the form of a matrix exponential \\mathbf{f}(t) = e&#94;{\\mathbf{C} t} \\cdot \\mathbf{f}(0) = \\mathbf{S} \\cdot e&#94;{\\mathbf{\\Lambda} t} \\cdot \\mathbf{S}&#94;{-1} \\cdot \\mathbf{f}(0) where \\mathbf{f}(t) is a vector of the neutral population flux [1/s] for each energy state at time t , \\mathbf{S} is the matrix of the eigenvectors of \\mathbf{C} and \\mathbf{\\Lambda} is a diagonal matrix containing the eigenvalues of \\mathbf{C} . \nThe fractional flux of a neutral traveling through a uniform plasma is shown below. As you can see the relative populations between states converges fairly quickly. The number of neutrals in a given state after a time t , \\mathbf{n}(t) , is given by \\mathbf{n}(t) = \\mathbf{S} \\cdot ( \\mathbf{\\Lambda}&#94;{-1} \\cdot e&#94;{\\mathbf{\\Lambda} t} - \\mathbf{\\Lambda}&#94;{-1} ) \\cdot \\mathbf{S}&#94;{-1} \\cdot \\mathbf{f}(0) If t represents the time spent inside a grid cell the neutral density can be calculated by dividing the above equation by V_{cell} .\nThe total neutral density of a mc marker is shown below. As you can see over time the total number of neutrals decreases exponentially. Fortran References colrad : Fortran implementation get_rate_matrix : Constructs rate matrix A AtomicRates : Derived type that stores populating and de-populating transitions","tags":"","loc":"page/02_physics/03_colrad.html","title":"Collisional Radiative Model – FIDASIM"},{"text":"table {\nwidth: 100%;\n}\ntable,th,td {\nborder: 1px solid black;\nborder-collapse: collapse;\n}\nth, td {\npadding: 5px;\n}\nth {\ntext-align: center;\n} Beam Grid Neutral Beam Geometry Neutral Beam Density DCX and Halo Density Relevent Namelist Settings Fortran References Beam Grid The neutrals densities calculated by FIDASIM are stored in a 3D grid.\nFIDASIM requires that the grid be axis-aligned to easily track particles through the grid.\nHowever, it is extremely useful to be able to align the grid along the beam centerline.\nTo facilitate this FIDASIM allows the user to define arbitrary Cartesian coordinate system (beam grid coordinates) that all calculations are done in. FIDASIM uses Tait-Bryan rotation angles ( alpha , beta , gamma ) to define a intrinsic rotation matrix, R , that is used to transform from beam grid coordinates(xyz) to machine coordinates(uvw) \\mathrm{uvw = R \\cdot xyz + origin} If the rotation angles and origin are set to zero then the rotation matrix is the Identity matrix and the coordinate system is identical to machine coordinates (Standard Cartesian). Understanding these variables can be difficult and can best be described by an example. With your right hand point your index finger pointing in the +x direction with your middle finger and thumb pointing in the +y and +z direction respectively. Rotate about your thumb (z-axis) by alpha (ccw = +angle, cw = -angle) Rotate about your middle finger (y'-axis) by beta Rotate about your index finger (x\"-axis) by gamma Move your right hand to the origin Define (x|y|z)_(min|max) by this coordinate system with your index finger being the new +x-axis The beam grid is defined in the namelist file ( [runid]_inputs.dat ) and are defined as follows Variable Type Rank Dimensions Units Description nx Int16 0 NA NA Number of cells in the X direction ny Int16 0 NA NA Number of cells in the Y direction nz Int16 0 NA NA Number of cells in the Z direction xmin Float64 0 NA cm Minimum X value in beam grid coordinates xmax Float64 0 NA cm Maximum X value in beam grid coordinates ymin Float64 0 NA cm Minimum Y value in beam grid coordinates ymax Float64 0 NA cm Maximum Y value in beam grid coordinates zmin Float64 0 NA cm Minimum Z value in beam grid coordinates zmax Float64 0 NA cm Maximum Z value in beam grid coordinates alpha Float64 0 NA rad Tait-Bryan rotation angle about z-axis beta Float64 0 NA rad Tait-Bryan rotation angle about y'-axis gamma Float64 0 NA rad Tait-Bryan rotation angle about x\"-axis origin Float64 1 [3] cm Beam grid origin in Machine Coordinates Neutral Beam Geometry A neutral beam is defined by a source position and an axis such that a position along the beam centerline is defined as \\vec{C}(t) = \\vec{s} + \\vec{a} \\cdot t where \\vec{C}(t) is the position along the centerline parameterized by t , \\vec{s} is the source position in machine coordinates, and \\vec{a} is the axis. The ion source is defined by its shape (circular or rectangular), size (half width and height), focal length (vertical and horizontal), and divergence (energy dependent).\nThe neutral beam is simulated by firing particles from random positions on the source plate.\nThe trajectory of the particles is determined by the following equations (+x into the plasma) v_x = 1 v_y = -\\frac{y_s}{f_y} + \\tan(\\mathcal{N}(0,\\beta_y&#94;2)) v_z = -\\frac{z_s}{f_z} + \\tan(\\mathcal{N}(0,\\beta_z&#94;2)) where y_s and z_s are random positions on the source plate in the horizontal and vertical directions respectively, f_{y/z} are the focal lengths, and \\beta_{y/z} are the divergences. Examples of different trajectories are shown below. Not shown above are the beam aperture(s) which collimates the neutral beam.\nApertures are represented in FIDASIM by their shape (circular or rectangular), size (half width and\nheight), offsets relative to the +x aligned beam centerline, and their distance from the source grid.\nIt is assumed that the plane of the aperture(s) is parallel to the plane of the source grid. The routine nubeam_geometry.pro ( IDL ) can be used to easily generate the NBI geometry from the TRANSP/NUBEAM beam definition. FIDASIM reads in the neutral beam geometry from a HDF5 file ( [runid]_geometry.h5 ) that has the group nbi with the following datasets Variable Type Rank Dimensions Units Description name String 0 NA NA Name of the neutral beam shape Int16 0 NA NA Shape of the beam source grid (1=rect or 2=circ) data_source String 0 NA NA Source of the neutral beam geometry src Float64 1 [3] cm Position of the source grid in machine coordinates axis Float64 1 [3] NA Direction of the beam center line widy Float64 0 NA cm Source grid half-width in the horizontal direction widz Float64 0 NA cm Source grid half-height in the vertical direction divy Float64 1 [3] rad Horizontal beam divergence divz Float64 1 [3] rad Vertical beam divergence focy Float64 0 NA cm Horizontal focal length focz Float64 0 NA cm Vertical focal length naperture Int16 0 NA NA Number of apertures ashape Int16 1 [ naperture ] NA Shape of the aperture(s) (1=rect or 2=circ) awidy Float64 1 [ naperture ] cm Half-width of the aperture(s) awidz Float64 1 [ naperture ] cm Half-height of the aperture(s) aoffy Float64 1 [ naperture ] cm Horizontal (y) offset of the aperture(s) relative to the +x aligned beam centerline aoffz Float64 1 [ naperture ] cm Vertical (z) offset of the aperture(s) relative to the +x aligned beam centerline adist Float64 1 [ naperture ] cm Distance from the center of the beam source grid to the aperture(s) plane Neutral Beam Density Neutral Hydrogen beams usually contain atoms with different energies: H(E_{inj}) (Full), H(E_{inj}/2) (Half), H(E_{inj}/3) (Third).\nThis splitting of energy is due to multiple atomic and molecular species being accelerated to the same kinetic energy, E_{inj} .\nEach beam species will attenuate differently into the plasma and need to be treated separetely.\nIt is assumed that each neutral is in the ground state with initial flux given by F_i(n=1) = \\frac{dN_i}{dt} = C_i \\cdot \\frac{dN_{tot}}{dt} where C_i is current fraction for the i_{th} energy component and dN_{tot}/dt is the total flux of neutrals given by \\frac{dN_{tot}}{dt} = \\frac{P_{inj}}{C_1 E_{inj}+ C_2 E_{inj}/2 + C_3 E_{inj}/3} where P_{inj} is the beam power. Within each beam grid cell along the neutral trajectory the flux is modified using the collisional radiative model and the neutral density is calculated.\nThe figure below illustrates the different beam attenuation profiles. DCX and Halo Density A secondary source of neutrals come from the charge exchange reaction between beam neutrals and thermal ions (DCX).\nAfter neutralization, the newly created thermal neutrals travel ballistically and charge exchange with other thermal ions creating more neutrals (Halo).\nThis process is then repeated multiple times in a recursive fashion producing fewer and fewer neutrals.\nThe effect of this process is a Halo of neutrals surrounding the neutral beam. FIDASIM uses the following scheme to calculate the DCX+Halo contribution. \\rm{DCX:\\,\\,\\,} \\quad H_{t_0}&#94;+ + H_b \\rightarrow H_{t_0} + H_b&#94;+ \\rm{Halo\\,1:} \\quad H_{t_1}&#94;+ + H_{t_0} \\rightarrow H_{t_1} + H_{t_0}&#94;+ \\rm{Halo\\,2:} \\quad H_{t_2}&#94;+ + H_{t_1} \\rightarrow H_{t_2} + H_{t_1}&#94;+ \\vdots \\rm{Halo\\,n:} \\quad H_{t_n}&#94;+ + H_{t_{(n-1)}} \\rightarrow H_{t_n} + H_{t_{(n-1)}}&#94;+ After a few iterations the halo density converges and the calculation ends. Relevent Namelist Settings ab : Beam/Fast-ion mass [amu] pinj : Beam power [MW] einj : Beam Energy [keV] current_fractions : Current fractions load_neutrals : Load neutrals from file neutrals_file : Optional neutrals file n_nbi : Number of NBI MC particles n_halo : Number of HALO MC particles n_dcx : Number of DCX MC particles calc_birth : Calculate birth profile (density & birth position and velocity) n_birth : Number of birth particles outputed Fortran References xyz_to_uvw : Transforms a point from beam grid coordinates to machine coordinates uvw_to_xyz : Transforms a point from machine coordinates to beam grid coordinates mc_nbi : Generates beam neutral trajectory ndmc : Calculates neutral beam density dcx : Calculates DCX contribution halo : Calculates Halo contribution write_dcx : Writes DCX neutrals to file write_neutrals : Writes neutrals to file","tags":"","loc":"page/02_physics/04_neutrals.html","title":"Neutral Beam and Halo – FIDASIM"},{"text":"table {\nwidth: 100%;\n}\ntable,th,td {\nborder: 1px solid black;\nborder-collapse: collapse;\n}\nth, td {\npadding: 5px;\n}\nth {\ntext-align: center;\n} Spectroscopic Geometry Types of Spectra Bremsstrahlung Emission by Neutrals Relevant Namelist Settings Fortran References Spectroscopic Geometry The spectroscopic geometry is defined similarily to the neutral beam.\nIt is defined by the lens position in machine coordinates and an optical axis.\nThe volume of the sightline is assumed to be cylindrical with radius, spot_size . If mirrors are present then the apparent positions of the lens as seen from the plasma are used.\nAdditionally, mirrors reflect the sigma and pi Stark lines differently due to a difference in polarization.\nThe experimentally determined ratio of the intensties of the sigma and pi lines, sigma_pi , is used to correct for this.\nIf there are no mirrors then sigma_pi is set to 1.0 . The full geometry specification is given below. Variable Type Rank Dimensions Units Description nchan Int32 0 NA NA Number of channels system String 0 NA NA Name of the spectrocopic system(s) data_source String 0 NA NA Source of the spectral geometry data id String 1 [ nchan ] NA Channel ID radius Float64 1 [ nchan ] cm Line of sight radius at midplane or tangency point lens Float64 2 [3, nchan ] cm Lens location in machine coordinates axis Float64 2 [3, nchan ] NA Optical axis/direction of the lines of sight spot_size Float64 1 [ nchan ] cm Radius of the collecting volume sigma_pi Float64 1 [ nchan ] NA Ratio of the intensities of the sigma and pi stark lines Types of Spectra FIDASIM can calculate the following spectra Bremsstrahlung Beam Emission (BES: Full, Half, Third) Halo Emission Thermal Ion direct charge exchange (DCX) Fast-ion D- \\alpha (active and passive FIDA) Cold D- \\alpha Bremsstrahlung The largest source of background emission is visible bremsstrahlung. The local bremsstrahlung emissivity per unit wavelength is given by \\frac{dN_B}{d\\lambda} = 7.57 \\times 10&#94;{-9} \\,  g \\,  \\frac{n_e&#94;2 \\, Z_{eff}}{\\lambda \\, T_e&#94;{1/2}} e&#94;{-hc/\\lambda \\,T_e} where \\lambda is the wavelength in angstroms, n_e is the electron density in cm&#94;{-3} , T_e is the electron temperature in eV.\nThe gaunt factor, g , depends on T_e and Z_{eff} . It can be approximated by g = 5.542 - (3.108 - \\ln(T_e/1000))(0.6905 - 0.1323/Z_{eff}) To calculate the total emission \"seen\" by the line of sight the the local emissivity is integrated over the line of sight. Emission by Neutrals There are two processes in which neutrals can emit light: Excitation and Charge Exchange. Excitation is the primary method in which beam neutrals emit light (BES).\nIn short, a neutral particle collides with a charged particle, exciting into a higher energy ( n=3 ) state.\nWhen the neutral particle relaxes ( n: 3 \\rightarrow 2 ) it emits a doppler shifted (656.1 nm) photon. Charge Exchange is the process by which the Halo and FIDA light is created.\nIn a charge exchange reaction a thermal (DCX, Halo) or fast (FIDA) ion steals an electron from a neutral particle.\nThe newly created neutral is born in an excited ( n=3 state and like the collisionally excited neutral it relaxes to a lower energy state (\\n=2) and emits a doppler shifted (656.1 nm) photon. The motion of a ion in a magnetic field induces an electric field which causes Stark Spitting of the the atoms energy levels.\nMost atoms the strength of the Stark effect is quadratic in low electric fields and linear for strong electric fields. \nUsually atoms never the linear regime but, due to degenerency between states of different angular momentum, hydrogenic atoms exhibit a linear Stark effect.\nThe linear Stark energy component shifts are given by the following equations. \\Delta \\mathcal{E} = 3nk\\frac{E}{Ze/4\\pi\\epsilon_0a_0&#94;2}R_y\\;\\, \\mathrm{for} \\;\\,k=0,\\pm 1,\\dots,\\pm (n-1) As seen from the above equation, each energy level is split into 2n-1 parts.\nFor the Balmer-alpha transition, this creates 15 distinct transitions from the n=3 \\rightarrow 2 state. The relative intensity of the different Stark lines is given by I_{rel}(i) = S_I(i)\\,(1 \\pm (\\vec{v}_{ph} \\cdot \\vec{E})&#94;2) I_{rel}(i) = \\frac{I_{rel}(i)}{\\sum_i I_{rel}(i)} where positive and negative sums refer to \\sigma and \\pi lines respectively and S_I are the calculated relative Stark intensities for each transition given by S_I = [1, 18, 16, 1681, 2304, 729, 1936, 5490, 1936, 729, 2304, 1681, 16, 18, 1] Relevant Namelist Settings calc_bes : Calculate NBI spectra (approximate calculations if neutrals are loaded, i.e., load_neutrals=1) calc_dcx : Calculate DCX spectra (approximate calculations if neutrals are loaded, i.e., load_neutrals=1) calc_halo : Calculate Halo spectra(approximate calculations if neutrals are loaded, i.e., load_neutrals=1) calc_cold : Calculate Cold D-alpha spectra calc_brems : Calculate Bremsstrahlung calc_fida : Calculate FIDA spectra calc_pfida : Calculate pFIDA spectra calc_fida_wght : Calculate FIDA weight function and emission using the weight function method n_fida : Number of Monte Carlo particles used in FIDA spectra calculation n_pfida : Number of Monte Carlo particles used in passive FIDA spectra calculation n_nbi : Number of Monte Carlo particles used in NBI spectra calculation n_halo : Number of Monte Carlo particles used in Halo spectra calculation n_dcx : Number of Monte Carlo particles used in DCX spectra calculation n_birth : Number of Monte Carlo particles used in BIRTH calculation nlambda : Number of wavelength bins lambdamin : Minimum wavelength [nm] lambdamax : Maximum wavelength [nm] nlambda_wght : Number of wavelength bins for weights lambdamin_wght : Minimum wavelength for weights [nm] lambdamax_wght : Maximum wavelength for weights [nm] Fortran References bremsstrahlung : Calculates Bremsstrahlung spectrum : Calculates Doppler shift and Stark splitting. ndmc : Calculates BES spectra dcx : Calculates DCX neutrals contribution to the DCX spectra halo : Calculates thermal neutrals contribution to the Halo Spectra fida_f : Calculates FIDA light using a distribution function fida_mc : Calculates FIDA light using a particle distribution","tags":"","loc":"page/02_physics/05_spectra.html","title":"Spectra – FIDASIM"},{"text":"table {\nwidth: 100%;\n}\ntable,th,td {\nborder: 1px solid black;\nborder-collapse: collapse;\n}\nth, td {\npadding: 5px;\n}\nth {\ntext-align: center;\n} NPA Geometry Monte Carlo NPA calculation Relevant Namelist Settings Fortran References NPA Geometry An NPA detector is defined by an aperture for which neutral particles must pass through and an detector.\nThe aperture/detectors are defined by three points and a shape as shown in the figures above.\nIt is assumed that between the aperture and the detector that particles travel in straight lines i.e. there is no stripping foil at the aperture. The full definition of the NPA detector is given below (right and left as implied by looking through the aperture at the detector) Variable Type Rank Dimensions Units Description nchan Int32 0 NA NA Number of channels system String 0 NA NA Name of the NPA system(s) data_source String 0 NA NA Source of the NPA geometry data id String 1 [ nchan ] NA Channel ID radius Float64 1 [ nchan ] cm Line of sight radius at midplane or tangency point a_shape Int16 1 [ nchan ] NA Shape of the aperture (1=rect, 2=circ) d_shape Int16 1 [ nchan ] NA Shape of the detector (1=rect, 2=circ) a_cent Float64 2 [3, nchan ] cm Position of the center of the aperture a_redge Float64 2 [3, nchan ] cm Position of the apertures right edge a_tedge Float64 2 [3, nchan ] cm Position of the apertures top edge d_cent Float64 2 [3, nchan ] cm Position of the center of the detector d_redge Float64 2 [3, nchan ] cm Position of the detectors right edge d_tedge Float64 2 [3, nchan ] cm Position of the detectors top edge Monte Carlo NPA calculation The Monte Carlo method of calculating the NPA flux (MC-NPA) is as follows Sample Fast-ion distribution function and get initial position, energy, and pitch Determine the range of gyro-angles ( d\\gamma ) that would allow a neutral particle to go through the NPA aperture and hit the detecting region. If the range is zero increase counter and goto 1 else goto 3 Choose the gyro-angle to be in the middle of the range calculated in step 2. Charge exchange the ion (set initial state) and solve the collisional radiative model along particle track. Scale by the gyro-range d\\gamma . Sum the final state of the neutral and bin the particle by its energy. Increase counter. Repeat N times Note The Monte Carlo NPA calculation assumes that the second order gyro-correction is small and the gyro-ring is circular. This assumption is often safe to make in conventional tokamaks but it may cause problems in spherical tokamaks or at the plasma edge where the torodial magnetic field is small. In these cases the alternative approach (detailed below) is suggested. An alternative approach is to fire the particles directly at the NPA detector and then scale the resultant flux by the probability of that trajectory occuring.\nThis approach is taken in the weight function method (WF-NPA) detailed here . An example of the calculated NPA flux for the two different methods are shown below. Relevant Namelist Settings n_npa : Number of Monte Carlo particles used in MC-NPA calculation n_pnpa : Number of Monte Carlo particles used in passive MC-NPA calculation calc_npa : Calculate NPA flux using the Monte Carlo Method calc_npa_wght : Calculate NPA weight function and flux using the weight function method ne_wght : Number of energies in weight function calculation np_wght : Number of pitches in weight function calculation emax_wght : Maximum energy in weight function calculation Fortran References read_npa : Reads NPA geometry and calculates NPA geometric factor npa_f : MC-NPA routine pnpa_f : passive MC-NPA routine npa_weights : WF-NPA routine","tags":"","loc":"page/02_physics/06_npa.html","title":"Neutral Particle Analyzer – FIDASIM"},{"text":"Weight Functions FIDA NPA Weight Functions FIDASIM is capable of calculating phase space sensitivities, also known as \"weight\" functions.\nThese weight functions describe how sensitive a diagnostic is to a region of fast-ion phase space (Energy/pitch).\nAlternatively, you can think of weight functions as the probability of a region of phase space contributing to the diagnostic signal. When a weight function is convolved with a theoretical fast-ion distribution, the expected diagnostic signal is calculated.\nAn example of this process is shown below. FIDASIM can calculate weight functions for the FIDA and NPA diagnostics. FIDA The calculation of the FIDA weight function can be broken up into 3 parts. Probability of a fast-ion charge exchanging with a neutral to create a fast neutral. Probability of a fast neutral undergoing a Balmer- \\alpha transition and emitting a photon within the LOS. Probability of a photon landing in a certain wavelength region. The product of these probabilities will be proportional to the FIDA weight function. The probabilities mentioned above are implicitly local quantities, however, in reality the neutral population and the diagnostic geometry have spatial extent. \nThe (exact) expected FIDA signal is given by S(\\lambda) = \\sum_{cells} \\left (\\sum_{E,p} W_i(E,p,\\lambda) \\times F_i(E,p) \\, \\Delta E \\Delta p \\right ) In order to calculate a single representative weight function for a given diagnostic ( W(\\lambda,E,p) , spatial averaging is needed. FIDASIM offers two different ways of calculating the FIDA weight functions; each using a different spatial averaging method. calc_fida_wght = 1 With this switch the FIDA weight function is calculated using LOS integrated neutral density and weighted plasma parameters given by k_{mean} = \\frac{\\int k \\times (d_{beam} + d_{halo}) \\,dl}{\\int (d_{beam} + d_{halo}) \\, dl} where k represents the various plasma parameters and distribution function. Using this method the FIDA spectra can be estimated by S_{approx}(\\lambda) = \\sum_{E,p} \\overline{W}(E,p,\\lambda) \\times \\overline{F}(E,p) \\Delta E \\Delta p where \\overline{W} is the weight function calculated with LOS-averaged quantities and \\overline{F} is the LOS-averaged fast-ion distribution function. calc_fida_wght = 2 With this switch it is assumed that over the line of sight the fast-ion distribution is approximately constant. S_{approx}(\\lambda) = \\sum_{E,p} \\overline{F}(E,p) \\times \\overline{W}(E,p,\\lambda) \\, \\Delta E \\Delta p where \\overline{W} = \\sum_{cells} W_i and \\overline{F}(E,p) = \\frac{\\sum_{cells} \\sum_{\\lambda} W_i(E,p,\\lambda) \\times F_i(E,p)}{\\sum_{\\lambda}\\overline{W}(E,p,\\lambda)} This method is more computationally intensive and uses a Monte Carlo method which introduces some noise.\nRegardless, this method is more accurate then the previous method and should be used in analysis where accuracy is paramount, e.g. velocity space tomography. Note The FIDA signal produced by calc_fida = 1 will sometimes significantly differ from the estimated FIDA spectra produced by convolving the weight functions with the fast-ion distribution. This is due to the approximations made in the weight function calculation. In general you can use the calc_fida=1 result to test the approximations used by calc_fida_wght=1/2 NPA The calculation of the NPA weight function can be broken up into 3 parts. Probability of a fast-ion charge exchanging with a neutral to create a fast neutral. Probability of a the fast neutrals trajectory hitting the NPA detector. See this paper Probability of a the fast neutral not being reabsorbed back into the plasma. The product of these probabilities will be proportional to the NPA weight function. The probabilities mentioned above are implicitly local quantities, however, in reality the neutral population and the diagnostic geometry have spatial extent. \nThe (exact) expected NPA signal is given by flux(E) = \\sum_{cells} \\left (\\sum_{p} W_i(E,p) \\times F_i(E,p) \\, \\Delta p \\right ) The NPA weight functions are calculated using the same assumptions as the FIDA weight functions ( calc_fida_wght=2 ). If calc_npa_wght = 2 is set then the individual compenents of the npa weight function are also outputed.","tags":"","loc":"page/02_physics/07_weights.html","title":"Weight Functions – FIDASIM"},{"text":"Originally, FIDASIM assumed axisymmetry and included active signals produced only by charge exchange (CX) with injected neutrals.\nHowever, passive signals produced by CX with cold neutrals can also be important.\nTherefore, FIDASIM is improved to predict passive signals for a given edge-cold neutral population. Introduction Time evolution of cold neutrals Types of Passive Signals Passive Neutral Grid Relevant Namelist Settings Fortran References Introduction Active diagnostic signals are produced from charge exchange with injected neutrals, and passive signals are produced from charge exchange with cold neutrals.\nPassive signals must be treated to get valid active FIDA data.\nFor example, passive-FIDA (p-FIDA) signals of comparable magnitude with active signals were experimentally measured on NSTX-U. Time evolution of cold neutrals FIDASIM accepts 2D and 3D cold neutral density input (TRANSP output variable is dn0wd ).\nFIDASIM will assume that all neutrals are in the ground state.\nUsing local plasma parameters, the neutrals are time evolved by solving the collisional radiative model until equilibrium is achieved.\nThen, the neutrals are distributed throughout the interpolation grid for subsequent passive calculations. Types of Passive Signals FIDASIM can calculate passive signals for the following diagnostics Fast-ion D- \\alpha (FIDA) Neutral Particle Analyzer (NPA) Passive Neutral Grid By default, FIDASIM will define the passive neutral grid to encompass the beam grid and the entire plasma volume.\nIf the interpolation grid is 3D, then the passive neutral grid is the interpolation grid.\nFIDASIM writes the passive neutral grid information in the output file. Relevant Namelist Settings calc_pfida : Calculate pFIDA spectra n_pfida : Number of Monte Carlo particles used in passive FIDA spectra calculation nlambda : Number of wavelength bins lambdamin : Minimum wavelength [nm] lambdamax : Maximum wavelength [nm] Fortran References read_chords : Reads FIDA geometry pfida_f : Calculates FIDA light using a distribution function pfida_mc : Calculates FIDA light using a Monte Carlo fast-ion distribution read_npa : Reads NPA geometry and calculates NPA geometric factor pnpa_f : Calculates passive MC-NPA routine using a distribution function pnpa_mc : Calculates passive NPA flux using a Monte Carlo fast-ion distribution","tags":"","loc":"page/02_physics/08_passive.html","title":"Cold Neutrals and Passive Signals – FIDASIM"},{"text":"Technical Details PREFIDA Inputs","tags":"","loc":"page/03_technical/index.html","title":"Technical Details – FIDASIM"},{"text":"PREFIDA Inputs PREFIDA Inputs Inputs Structure General Settings Simulation Switches Monte Carlo Settings Neutral Beam Settings Plasma Settings Beam Grid Settings Wavelength Grid Settings Weight Function Settings Interpolation Grid Structure Neutral Beam Geometry Structure Fields Structure Plasma Structure Distribution Structure Fast-ion Distribution Function Guiding Center Monte Carlo Distribution Full-Orbit Monte Carlo Distribution Spectral Geometry Structure NPA Geometry Structure Inputs Structure The inputs structure contains the basic information needed by FIDASIM. General Settings table {\nwidth: 100%;\n}\ntable,th,td {\nborder: 1px solid black;\nborder-collapse: collapse;\n}\nth, td {\npadding: 5px;\n}\nth {\ntext-align: center;\n} Variable Type Rank Dimensions Units Description shot Int32 0 NA NA Shot Number time Float64 0 NA s Time runid String 0 NA NA Run ID comment String 0 NA NA Comment result_dir String 0 NA NA Result directory tables_file String 0 NA NA Atomic Tables file Simulation Switches The simulation switches can take values 0, 1, or 2. A value of zero and one will turn the calculation off and on respectively. \nA value of two will turn on additional functionality. Variable Type Rank Dimensions Units Description calc_bes Int16 0 NA NA Calculate NBI Spectra calc_dcx Int16 0 NA NA Calculate Direct Charge Exchange Spectra calc_halo Int16 0 NA NA Calculate HALO spectra calc_cold Int16 0 NA NA Calculate COLD spectra calc_brems Int16 0 NA NA Calculate Bremsstrahlung calc_fida Int16 0 NA NA Calculate FIDA spectra calc_npa Int16 0 NA NA Calculate NPA flux calc_pfida Int16 0 NA NA Calculate passive FIDA spectra calc_pnpa Int16 0 NA NA Calculate passive NPA flux calc_neutron Int16 0 NA NA Calculate B-T Neutron rate calc_birth Int16 0 NA NA Calculate Birth profile calc_fida_wght Int16 0 NA NA Calculate FIDA weight functions calc_npa_wght Int16 0 NA NA Calculate NPA weight functions Monte Carlo Settings These settings control the number of Monte Carlo particles used by FIDASIM.\nUsing too few particles will execute quickly but will be extremely noisy.\nContrarily, using too many particles will increase runtime but will have small Monte Carlo noise.\nThe following settings provide a good balance between runtime and Monte Carlo noise. n_fida = 5000000L n_pfida = 50000000L n_npa = 5000000L n_pnpa = 50000000L n_nbi = 50000L n_halo = 500000L n_dcx = 500000L n_birth = 10000L Variable Type Rank Dimensions Units Description n_fida Int32 0 NA NA Number of FIDA MC particles n_pfida Int32 0 NA NA Number of passive FIDA MC particles n_npa Int32 0 NA NA Number of NPA MC particles n_pnpa Int32 0 NA NA Number of passive NPA MC particles n_nbi Int32 0 NA NA Number of NBI MC particles n_halo Int32 0 NA NA Number of HALO MC particles n_dcx Int32 0 NA NA Number of DCX MC particles n_birth Int32 0 NA NA Number of Birth particles outputed Neutral Beam Settings These variables define the neutral beam properties.\nCurrently the mass of the beam species, ab , can only be the mass either protium or deuterium.\nThe current_fractions variable must sum to one.\nClick here for more information. Variable Type Rank Dimensions Units Description ab Float64 0 NA amu Beam species mass pinj Float64 0 NA MW Beam power einj Float64 0 NA keV Beam energy current_fractions Float64 1 [3] NA Current fractions (Full, Half, Third) Plasma Settings These variables define the properties of the thermal plasma species.\nLike the ab variable, ai can only be the mass of either protium or deuterium\nClick here for more information. Variable Type Rank Dimensions Units Description ai Float64 0 NA amu Thermal Ion species mass impurity_charge Int16 0 NA NA Impurity Charge Beam Grid Settings These variables define a rotated coordinate system.\nClick here for more details. Variable Type Rank Dimensions Units Description nx Int16 0 NA NA Number of cells in the X direction ny Int16 0 NA NA Number of cells in the Y direction nz Int16 0 NA NA Number of cells in the Z direction xmin Float64 0 NA cm Minimum X value in beam grid coordinates xmax Float64 0 NA cm Maximum X value in beam grid coordinates ymin Float64 0 NA cm Minimum Y value in beam grid coordinates ymax Float64 0 NA cm Maximum Y value in beam grid coordinates zmin Float64 0 NA cm Minimum Z value in beam grid coordinates zmax Float64 0 NA cm Maximum Z value in beam grid coordinates alpha Float64 0 NA rad Tait-Bryan rotation angle about z-axis beta Float64 0 NA rad Tait-Bryan rotation angle about y'-axis gamma Float64 0 NA rad Tait-Bryan rotation angle about x\"-axis origin Float64 1 [3] cm Beam grid origin in Machine Coordinates Wavelength Grid Settings These variables define the wavelength grid. Using a fine wavelength has no performance penalty.\nClick here for more more information. Variable Type Rank Dimensions Units Description nlambda Int16 0 NA NA Number of wavelengths lambdamin Float64 0 NA nm Minimum wavelength lambdamax Float64 0 NA nm Maximum wavelength Weight Function Settings These variables define the setting for the calculation of weight functions.\nClick here for more information. Variable Type Rank Dimensions Units Description ne_wght Int16 0 NA NA Number of weight function energies np_wght Int16 0 NA NA Number of weight function pitches nphi_wght Int16 0 NA NA Number of gyro-angles emax_wght Float64 0 NA keV Maximum energy of weight functions nlambda_wght Int16 0 NA NA Number of weight function wavelengths lambdamin_wght Float64 0 NA nm Minimum weight function wavelength lambdamax_wght Float64 0 NA nm Maximum weight function wavelength Interpolation Grid Structure The grid structure contains the definition of the 2D/3D cylindrical grid that the plasma parameters and electromagnetic fields are mapped onto. Variable Type Rank Dimensions Units Description nr Int16 0 NA NA Number of radii nz Int16 0 NA NA Number of z values nphi Int16 0 NA NA Number of phi values (Optional) r Float64 1 [ nr ] cm Array of radii z Float64 1 [ nz ] cm Array of z values phi Float64 1 [ nphi ] rad Array of phi values (Optional) Neutral Beam Geometry Structure The nbi structure contains the neutral beam geometry.\nThe (a)shape of the source grid and apertures take the value of 1 or 2 for a rectangular and circular respectively.\nClick here for more information. Variable Type Rank Dimensions Units Description name String 0 NA NA Name of the neutral beam shape Int16 0 NA NA Shape of the beam source grid (1 or 2) data_source String 0 NA NA Source of the neutral beam geometry src Float64 1 [3] cm Position of the source grid in machine coordinates axis Float64 1 [3] NA Direction of the beam center line widy Float64 0 NA cm Source grid half-width in the horizontal direction widz Float64 0 NA cm Source grid half-height in the vertical direction divy Float64 1 [3] rad Horizontal beam divergence divz Float64 1 [3] rad Vertical beam divergence focy Float64 0 NA cm Horizontal focal length focz Float64 0 NA cm Vertical focal length naperture Int16 0 NA NA Number of apertures ashape Int16 1 [ naperture ] NA Shape of the aperture(s) (1 or 2) awidy Float64 1 [ naperture ] cm Half-width of the aperture(s) awidz Float64 1 [ naperture ] cm Half-height of the aperture(s) aoffy Float64 1 [ naperture ] cm Horizontal (y) offset of the aperture(s) relative to the +x aligned beam centerline aoffz Float64 1 [ naperture ] cm Vertical (z) offset of the aperture(s) relative to the +x aligned beam centerline adist Float64 1 [ naperture ] cm Distance from the center of the beam source grid to the aperture(s) plane Fields Structure This structure contain the electromagnetic fields mapped onto the interpolation grid.\nClick here for more information. Variable Type Rank Dimensions Units Description time Float64 0 NA s Time when the fields data were collected/reconstructed data_source String 0 NA NA Source of the fields data mask Int16 2/3 [ nr , nz [, nphi ]] NA Boolean mask that indicates where the fields are well defined br Float64 2/3 [ nr , nz [, nphi ]] T Radial component of the magnetic field bt Float64 2/3 [ nr , nz [, nphi ]] T Torodial/Phi component of the magnetic field bz Float64 2/3 [ nr , nz [, nphi ]] T Z component of the magnetic field er Float64 2/3 [ nr , nz [, nphi ]] V/m Radial component of the electric field et Float64 2/3 [ nr , nz [, nphi ]] V/m Torodial/Phi component of the electric field ez Float64 2/3 [ nr , nz [, nphi ]] V/m Z component of the electric field description String 0 NA NA Electromagnetic Field coordinate system String 0 NA NA Cylindrical Plasma Structure This structure contain the plasma parameters mapped onto the interpolation grid.\nClick here for more information. Variable Type Rank Dimensions Units Description time Float64 0 NA s Time when the plasma parameter data was collected data_source String 0 NA NA Source of the plasma parameter data mask Int16 2/3 [ nr , nz [, nphi ]] NA Boolean mask that indicates where the plasma is well defined te Float64 2/3 [ nr , nz [, nphi ]] keV Electron temperature ti Float64 2/3 [ nr , nz [, nphi ]] keV Ion temperature dene Float64 2/3 [ nr , nz [, nphi ]] cm&#94;-3 Electron density zeff Float64 2/3 [ nr , nz [, nphi ]] NA Z-effective vr Float64 2/3 [ nr , nz [, nphi ]] cm/s Radial component of the bulk plasma rotation/flow vt Float64 2/3 [ nr , nz [, nphi ]] cm/s Torodial/Phi component of the bulk plasma rotation/flow vz Float64 2/3 [ nr , nz [, nphi ]] cm/s Z component of the bulk plasma rotation/flow description String 0 NA NA Plasma Parameters coordinate system String 0 NA NA Cylindrical Distribution Structure The dist structure contains the fast-ion distribution which can be one of three different types.\nClick here for more information. Fast-ion Distribution Function Variable Type Rank Dimensions Units Description type Int16 0 NA NA Distribution type (1) r Float64 1 [ nr ] cm Array of radii z Float64 1 [ nz ] cm Array of z values phi Float64 1 [ nphi ] cm Array of phi values (Optional) time Float64 0 NA s Time of the distribution data_source String 0 NA NA Source of the distribution data nenergy Int16 0 NA NA Number of energy values npitch Int16 0 NA NA Number of pitch values energy Float64 1 [ nenergy ] keV Energy array pitch Float64 1 [ npitch ] NA Pitch array w.r.t magnetic field denf Float64 3 [ nr , nz [, nphi ]] cm&#94;-3 Fast-ion density f Float64 5 [ nenergy , npitch , nr , nz [, nphi ]] fast-ions/(dE dP cm&#94;3) Fast-ion distribution F(E,p,R,Z[,Phi]) Guiding Center Monte Carlo Distribution The sum( weight ) = # of Fast-ions in phase space sampled by the MC particles. The class variable can take values in the range of 1: nclass . Variable Type Rank Dimensions Units Description type Int16 0 NA NA Distribution type (2) time Float64 0 NA s Time of the distribution data_source String 0 NA NA Source of the distribution data nparticle Int32 0 NA NA Number of MC particles nclass Int16 0 NA NA Number of orbit classes class Int16 1 [ nparticle ] NA Orbit class of the MC particle weight Float64 1 [ nparticle ] fast-ions Weight of the MC particle r Float64 1 [ nparticle ] cm R positions of the MC particle z Float64 1 [ nparticle ] cm Z positions of the MC particle phi Float64 1 [ nparticle ] rad Phi positions of the MC particle (Optional) energy Float64 1 [ nparticle ] keV Energy of the MC particle pitch Float64 1 [ nparticle ] NA Pitch w.r.t the magnetic field of the MC particle Full-Orbit Monte Carlo Distribution The sum( weight ) = # of Fast-ions in phase space sampled by the MC particles The class variable can take values in the range of 1: nclass . Variable Type Rank Dimensions Units Description type Int16 0 NA NA Distribution type (3) time Float64 0 NA s Time of the distribution data_source String 0 NA NA Source of the distribution data nparticle Int32 0 NA NA Number of MC particles nclass Int16 0 NA NA Number of orbit classes class Int16 1 [ nparticle ] NA Orbit class of the MC particle weight Float64 1 [ nparticle ] fast-ions Weight of the MC particle r Float64 1 [ nparticle ] cm R positions of the MC particle z Float64 1 [ nparticle ] cm Z positions of the MC particle phi Float64 1 [ nparticle ] rad Phi positions of the MC particle (Optional) vr Float64 1 [ nparticle ] cm/s Radial component of the MC particle velocity vt Float64 1 [ nparticle ] cm/s Torodial/Phi component of the MC particle velocity vz Float64 1 [ nparticle ] cm/s Z component of the MC particle velocity Spectral Geometry Structure This structure contains the geometry of the spectroscopic systems \nClick here for more more information. Variable Type Rank Dimensions Units Description nchan Int32 0 NA NA Number of channels system String 0 NA NA Name of the spectrocopic system(s) data_source String 0 NA NA Source of the spectral geometry data id String 1 [ nchan ] NA Channel ID radius Float64 1 [ nchan ] cm Line of sight radius at midplane or tangency point lens Float64 2 [3, nchan ] cm Lens location in machine coordinates axis Float64 2 [3, nchan ] NA Optical axis/direction of the lines of sight spot_size Float64 1 [ nchan ] cm Radius of the collecting volume sigma_pi Float64 1 [ nchan ] NA Ratio of the intensities of the sigma and pi stark lines NPA Geometry Structure This structure contains the geometry of the spectroscopic systems \nThe shapes of the detector and aperture can take the value 1 or 2 for a rectangular and circular aperture/detector respectively.\nClick here for more more information. Variable Type Rank Dimensions Units Description nchan Int32 0 NA NA Number of channels system String 0 NA NA Name of the NPA system(s) data_source String 0 NA NA Source of the NPA geometry data id String 1 [ nchan ] NA Channel ID radius Float64 1 [ nchan ] cm Line of sight radius at midplane or tangency point a_shape Int16 1 [ nchan ] NA Shape of the aperture d_shape Int16 1 [ nchan ] NA Shape of the detector a_cent Float64 2 [3, nchan ] cm Position of the center of the aperture a_redge Float64 2 [3, nchan ] cm Position of the apertures right edge a_tedge Float64 2 [3, nchan ] cm Position of the apertures top edge d_cent Float64 2 [3, nchan ] cm Position of the center of the detector d_redge Float64 2 [3, nchan ] cm Position of the detectors right edge d_tedge Float64 2 [3, nchan ] cm Position of the detectors top edge","tags":"","loc":"page/03_technical/01_prefida_inputs.html","title":"PREFIDA Inputs – FIDASIM"},{"text":"This page documents the common problems people encounter while running FIDASIM.\nPlease try these solutions before opening an issue on Github. Segfaults Execution Hangs Segfaults If you encounter a segfault make sure you have set the stacksize limit to unlimited. To do this for the bash shell run ulimit -s unlimited or for the tcsh shell run limit stacksize unlimited Execution Hangs By default FIDASIM will use all the threads available. \nIf another process is hogging a core it will cause FIDASIM to stall.\nTo prevent this use the num_threads optional argument as shown below fidasim ./test_inputs.dat 8","tags":"","loc":"page/03_technical/02_trouble.html","title":"Troubleshooting – FIDASIM"}]}