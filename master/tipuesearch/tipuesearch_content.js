var tipuesearch = {"pages":[{"text":"FIDASIM Note This is the documentation for the release version of FIDASIM.\nClick here for the current development documentation. FIDASIM is a fast Fortran 90 code that simulates neutral beam deposition and various fast-ion diagnostics in axisyimmetric fusion devices. For more information, check out the user guide . Developer Info Luke Stagner Physics Ph.D. Candidate at University of California, Irvine","tags":"","loc":"index.html","title":" FIDASIM "},{"text":"This file contains all the linear algebra routines FIDASIM uses Files Dependent On This One sourcefile~~eigensystem.f90~~AfferentGraph sourcefile~eigensystem.f90 eigensystem.f90 sourcefile~fidasim.f90 fidasim.f90 sourcefile~eigensystem.f90->sourcefile~fidasim.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules eigensystem Source Code eigensystem.f90 Source Code !+ This file contains all the linear algebra routines FIDASIM uses module eigensystem !+ A basic libary for calculating matrix eigen-decompositions and inverses implicit none !!Definition for the kind of the variables: integer , parameter :: long = kind ( int ( 1 )) integer , parameter :: float = kind ( 1.e0 ) integer , parameter :: double = kind ( 1.d0 ) !! eigenvalue decomposition values real ( double ), parameter :: ONE = 1.d0 , TWO = 2.d0 , ZERO = 0.d0 real ( double ), parameter :: XMACH_EPS = 2.22d-16 integer , parameter :: MAXIT = 50 contains ! first subroutines for eigenvalue decomposition subroutine RSWAP ( a , b ) !+ Swaps values `a` and `b` real ( double ) :: a , b , t t = a ; a = b ; b = t end subroutine RSWAP subroutine balance ( n , mat , scal , low , high ) !+Balances the matrix so that the rows with zero entries !+off the diagonal are isolated and the remaining columns and rows !+are resized to have one norm close to 1. integer , intent ( in ) :: n !+ Dimension of `mat` real ( double ) :: mat ( 0 : n , 0 : n ) !+ `n`x`n` scaled matrix real ( double ) :: scal ( 0 : n ) !+ Contains isolated eigenvalue in the positions 0-`low` and `high`-`n`-1 !+ its other components contain the scaling factors for transforming `mat` integer , intent ( out ) :: high integer , intent ( out ) :: low integer , parameter :: basis = 2 real ( double ) :: b2 , r , c , f , g , s integer :: m , k , i , j , iter scal = 0.d0 b2 = basis * basis m = 0 k = n - 1 iter = 1 do while ( iter == 1 ) iter = 0 do j = k , 0 , - 1 r = ZERO do i = 0 , k if ( i . ne . j ) r = r + DABS ( mat ( j , i )) enddo if ( r == ZERO ) then scal ( k ) = j if ( j . ne . k ) then do i = 0 , k call RSWAP ( mat ( i , j ), mat ( i , k )) enddo do i = m , n - 1 call RSWAP ( mat ( j , i ), mat ( k , i )) enddo endif k = k - 1 iter = 1 endif enddo !j loop enddo !while iter=1 iter = 1 do while ( iter == 1 ) iter = 0 do j = m , k c = ZERO do i = m , k if ( i . ne . j ) c = c + DABS ( mat ( i , j )) enddo if ( c == ZERO ) then scal ( m ) = j if ( j . ne . m ) then do i = 0 , k call RSWAP ( mat ( i , j ), mat ( i , m )) enddo do i = m , n - 1 call RSWAP ( mat ( j , i ), mat ( m , i )) enddo endif m = m + 1 iter = 1 endif enddo !j loop enddo !while iter=1 low = m high = k do i = m , k scal ( i ) = ONE enddo iter = 1 do while ( iter == 1 ) iter = 0 do i = m , k c = ZERO ; r = ZERO do j = m , k if ( j . ne . i ) then c = c + DABS ( mat ( j , i )) r = r + DABS ( mat ( i , j )) endif enddo g = r / basis f = ONE s = c + r do while ( c < g ) f = f * basis c = c * b2 enddo g = r * basis do while ( c >= g ) f = f / basis c = c / b2 enddo if (( c + r ) / f < 0.95 * s ) then g = ONE / f scal ( i ) = scal ( i ) * f iter = 1 do j = m , n - 1 mat ( i , j ) = mat ( i , j ) * g enddo do j = 0 , k mat ( j , i ) = mat ( j , i ) * f enddo endif enddo !i loop enddo !while iter=1 return end subroutine balance subroutine balback ( n , low , high , scal , eivec ) !+  Reverses the balancing of balance for the eigenvectors integer , intent ( in ) :: n !+ Dimension of matrix integer , intent ( in ) :: low !+ First nonzero row integer , intent ( in ) :: high !+ Last nonzero row real ( double ), intent ( in ) :: scal ( 0 : n ) !+ Scaling data from balance real ( double ), intent ( inout ) :: eivec ( 0 : n , 0 : n ) !+ Input: n x n matrix of eigenvectors, as computed in qr2 !+ Output: Non-normalized eigenvectors of the original matrix real ( double ) :: s integer :: i , j , k do i = low , high s = scal ( i ) do j = 0 , n - 1 eivec ( i , j ) = eivec ( i , j ) * s enddo enddo do i = low - 1 , 0 , - 1 k = Int ( scal ( i )) if ( k . ne . i ) then do j = 0 , n - 1 call RSWAP ( eivec ( i , j ), eivec ( k , j )) enddo endif enddo do i = high + 1 , n - 1 k = Int ( scal ( i )) if ( k . ne . i ) then do j = 0 , n - 1 call RSWAP ( eivec ( i , j ), eivec ( k , j )) enddo endif enddo return end subroutine balback subroutine elmhes ( n , low , high , mat , perm ) !+Transforms the matrix `mat` to upper Hessenberg form. integer , intent ( in ) :: n !+Dimension of `mat` integer , intent ( in ) :: low !+First nonzero row integer , intent ( in ) :: high !+Last nonzero row real ( double ), intent ( inout ) :: mat ( 0 : n , 0 : n ) !+Input: `n`x`n` matrix !+Output: Upper Hessenberg matrix; additional information on the tranformation !+is stored in the lower triangle integer , intent ( out ) :: perm ( 0 : n ) !+Permutation vector for elmtrans integer :: i , j , m real ( double ) :: x , y do m = low + 1 , high - 1 i = m x = ZERO do j = m , high if ( DABS ( mat ( j , m - 1 )) > DABS ( x )) then x = mat ( j , m - 1 ) i = j endif enddo perm ( m ) = i if ( i . ne . m ) then do j = m - 1 , n - 1 call RSWAP ( mat ( i , j ), mat ( m , j )) enddo do j = 0 , high call RSWAP ( mat ( j , i ), mat ( j , m )) enddo endif if ( x . ne . ZERO ) then do i = m + 1 , high y = mat ( i , m - 1 ) if ( y . ne . ZERO ) then y = y / x mat ( i , m - 1 ) = y do j = m , n - 1 mat ( i , j ) = mat ( i , j ) - y * mat ( m , j ) enddo do j = 0 , high mat ( j , m ) = mat ( j , m ) + y * mat ( j , i ) enddo endif enddo !i loop endif !x <> ZERO enddo !m loop end subroutine elmhes Subroutine elmtrans ( n , low , high , mat , perm , h ) !+  Elmtrans copies the Hessenberg matrix stored in `mat` to `h` integer , intent ( in ) :: n !+ Dimension of mat integer , intent ( in ) :: low !+ First nonzero row integer , intent ( in ) :: high !+ Last nonzero row real ( double ), intent ( in ) :: mat ( 0 : n , 0 : n ) !+ `n`x`n` input matrix integer , intent ( in ) :: perm ( 0 : n ) !+ Permutation data from elmhes real ( double ), intent ( out ) :: h ( 0 : n , 0 : n ) !+ Hessenberg matrix integer :: i , j , k do i = 0 , n - 1 do k = 0 , n - 1 h ( i , k ) = ZERO enddo h ( i , i ) = ONE enddo do i = high - 1 , low + 1 , - 1 j = perm ( i ) do k = i + 1 , high h ( k , i ) = mat ( k , i - 1 ) enddo if ( i . ne . j ) then do k = i , high h ( i , k ) = h ( j , k ) h ( j , k ) = ZERO enddo h ( j , i ) = ONE endif enddo end subroutine elmtrans subroutine Comdiv ( ar , ai , br , bi , cr , ci , rc ) !+ Performs complex division `c` = `a` / `b` real ( double ) :: ar !+ Real part of numerator real ( double ) :: ai !+ Imaginary part of numerator real ( double ) :: br !+ Real part of denominator real ( double ) :: bi !+ Imaginary part of denominator real ( double ) :: cr !+ Real part of quotient real ( double ) :: ci !+ Imaginary part of quotient integer :: rc !+ return code real ( double ) :: tmp if ( br == ZERO . AND . bi == ZERO ) then rc = 1 return endif if ( dabs ( br ) > dabs ( bi )) then tmp = bi / br br = tmp * bi + br cr = ( ar + tmp * ai ) / br ci = ( ai - tmp * ar ) / br else tmp = br / bi bi = tmp * br + bi cr = ( tmp * ar + ai ) / bi ci = ( tmp * ai - ar ) / bi endif rc = 0 end subroutine Comdiv !Comdiv function comabs ( ar , ai ) !+ Calculates absolute value of a complex number `a` real ( double ) :: ar !+ Real part of `a` real ( double ) :: ai !+ Imaginary part of `a` real ( double ) :: comabs !+ Absolute value of `a` if ( ar == ZERO . and . ai == ZERO ) then Comabs = ZERO return endif ar = DABS ( ar ) ai = DABS ( ai ) if ( ai > ar ) then !Switch  ai and ar call RSWAP ( ai , ar ) endif if ( ai == ZERO ) then Comabs = ar else Comabs = ar * DSQRT ( ONE + ai / ar * ai / ar ) endif end function comabs subroutine hqrvec ( n , & !Dimension of matrix ....... low , & !first nonzero row ......... high , & !last nonzero row .......... h , & !upper Hessenberg matrix ... wr , & !Real parts of evalues ..... wi , & !Imaginary parts of evalues eivec , & !Eigenvectors .............. rc ) !return code ............... !+Computes the eigenvectors for the eigenvalues found in hqr2 !+ !+###Input parameters !+   n     :   int n;  ( n > 0 ) !+         :   Dimension of  mat and eivec, number of eigenvalues. !+ !+   low   :   int low; !+ !+   high  :   int high; see  balance !+ !+   h     :   n x n upper Hessenberg matrix !+ !+   wr    :   vector of size n; !+         :   Real parts of the n eigenvalues. !+ !+   wi    :   vector of size n; Imaginary parts of the n eigenvalues. !+ !+###Output parameter: !+   eivec :  n x n matrix, whose columns are the eigenvectors integer , intent ( in ) :: n integer , intent ( in ) :: high , low real ( double ), intent ( in ) :: wr ( 0 : n ), wi ( 0 : n ) real ( double ), intent ( out ) :: eivec ( 0 : n , 0 : n ) real ( double ) :: h ( 0 : n , 0 : n ) integer :: rc integer :: i , j , m , k , na , l integer :: code , en real ( double ) :: p , q , r , s , t , w , x , y , z , ra , sa , vr , vi , norm , temp r = ZERO ; s = ZERO ; z = ZERO ; norm = ZERO do i = 0 , n - 1 !find norm of h do j = i , n - 1 norm = norm + DABS ( h ( i , j )) enddo enddo if ( norm == ZERO ) then rc = 1 !zero matrix return endif do en = n - 1 , 0 , - 1 !transform back p = wr ( en ) q = wi ( en ) na = en - 1 if ( q == ZERO ) then m = en h ( en , en ) = ONE do i = na , 0 , - 1 w = h ( i , i ) - p r = h ( i , en ) do j = m , na r = r + h ( i , j ) * h ( j , en ) enddo if ( wi ( i ) < ZERO ) then z = w s = r else m = i if ( wi ( i ) == ZERO ) then if ( w . ne . ZERO ) then temp = w else temp = XMACH_EPS * norm endif h ( i , en ) = - r / temp else !Solve the linear system: !| w   x |  | h[i][en]   |   | -r | !|       |  |            | = |    | !| y   z |  | h[i+1][en] |   | -s | x = h ( i , i + 1 ) y = h ( i + 1 , i ) q = ( wr ( i ) - p ) ** 2 + wi ( i ) ** 2 h ( i , en ) = ( x * s - z * r ) / q t = h ( i , en ) if ( DABS ( x ) > DABS ( z )) then temp = ( - r - w * t ) / x else temp = ( - s - y * t ) / z endif h ( i + 1 , en ) = temp endif endif !wi[i] < 0 enddo !i loop else if ( q < ZERO ) then m = na if ( DABS ( h ( en , na )) > DABS ( h ( na , en ))) then h ( na , na ) = - ( h ( en , en ) - p ) / h ( en , na ) h ( na , en ) = - q / h ( en , na ) else call Comdiv ( - h ( na , en ), 0.d0 , h ( na , na ) - p , q , h ( na , na ), h ( na , en ), code ) endif h ( en , na ) = ONE h ( en , en ) = ZERO do i = na - 1 , 0 , - 1 w = h ( i , i ) - p ra = h ( i , en ) sa = ZERO do j = m , na ra = ra + h ( i , j ) * h ( j , na ) sa = sa + h ( i , j ) * h ( j , en ) enddo if ( wi ( i ) < ZERO ) then z = w r = ra s = sa else m = i if ( wi ( i ) == ZERO ) then call Comdiv ( - ra , - sa , w , q , h ( i , na ), h ( i , en ), code ) else !  solve complex linear system: !| w+i*q     x | | h[i][na] + i*h[i][en]  |   | -ra+i*sa | !|             | |                        | = |          | !|   y    z+i*q| | h[i+1][na]+i*h[i+1][en]|   | -r+i*s   | x = h ( i , i + 1 ) y = h ( i + 1 , i ) vr = ( wr ( i ) - p ) ** 2 + wi ( i ) ** 2 - q * q vi = TWO * q * ( wr ( i ) - p ) if ( vr == ZERO . AND . vi == ZERO ) then vr = XMACH_EPS * norm * ( DABS ( w ) + DABS ( q ) & + DABS ( x ) + DABS ( y ) + DABS ( z )) endif call Comdiv ( x * r - z * ra + q * sa , x * s - z * sa - q * ra & , vr , vi , h ( i , na ), h ( i , en ), code ) if ( DABS ( x ) > DABS ( z ) + DABS ( q )) then h ( i + 1 , na ) = ( - ra - w * h ( i , na ) + q * h ( i , en )) / x h ( i + 1 , en ) = ( - sa - w * h ( i , en ) - q * h ( i , na )) / x else call Comdiv ( - r - y * h ( i , na ), - s - y * h ( i , en ) & , z , q , h ( i + 1 , na ), h ( i + 1 , en ), code ) endif endif !wi[i] = 0 endif !wi[i] < 0 enddo !i loop endif !else if q < 0 enddo !en loop do i = 0 , n - 1 !Eigenvectors for the evalues for if ( i < low . or . i > high ) then !rows < low  and rows  > high do k = i + 1 , n - 1 eivec ( i , k ) = h ( i , k ) enddo endif enddo j = n - 1 do while ( j >= low ) if ( j <= high ) then m = j else j = high endif if ( wi ( j ) < ZERO ) then l = j - 1 do i = low , high y = ZERO ; z = ZERO do k = low , m y = y + eivec ( i , k ) * h ( k , l ) z = z + eivec ( i , k ) * h ( k , j ) enddo eivec ( i , l ) = y eivec ( i , j ) = z enddo else if ( wi ( j ) == ZERO ) then do i = low , high z = ZERO do k = low , m z = z + eivec ( i , k ) * h ( k , j ) enddo eivec ( i , j ) = z enddo endif endif j = j - 1 enddo !j loop rc = 0 end subroutine hqrvec subroutine hqr2 ( n , & !Dimension of matrix ......... low , & !first nonzero row ........... high , & !last nonzero row ............ h , & !Hessenberg matrix ........... wr , & !Real parts of eigenvalues ... wi , & !Imaginary parts of evalues .. eivec ,& !Matrix of eigenvectors ...... cnt , & !Iteration counter ........... rc ) !return code ................. !+Computes the eigenvalues and (if vec = True) the eigenvectors !+of an  n * n upper Hessenberg matrix. !+ !+###Input parameters !+   n     :  integer;  ( n > 0 ) !+            Dimension of  h and eivec, !+            length of the real parts vector  wr and of the !+            imaginary parts vector  wi of the eigenvalues. !+ !+   low   :  integer; !+ !+   high  :  integer;  see balance !+ !+   h     :  n x n matrix; !+            upper Hessenberg matrix as output of Elmhes !+            (destroyed in the process). !+###Output parameters !+   eivec :  n x n matrix;  (only if vec = 1) !+            Matrix, which for vec = 1 contains the !+            eigenvectors as follows: !+            For real eigebvalues the corresponding column !+            contains the corresponding eigenvactor, while for !+            complex eigenvalues the corresponding column contains !+            the real part of the eigenvactor with its imaginary !+            part is stored in the subsequent column of eivec. !+            The eigenvactor for the complex conjugate eigenvactor !+            is given by the complex conjugate eigenvactor. !+ !+   wr    :  vector of size n; !+            Real part of the n eigenvalues. !+ !+   wi    :  vector of size n; !+            Imaginary parts of the eigenvalues !+ !+   cnt   :  Integer vector of size n; !+            vector of iterations used for each eigenvalue. !+            For a complex conjugate eigenvalue pair the second !+            entry is negative. integer , intent ( in ) :: n integer , intent ( in ) :: high , low real ( double ) , intent ( out ) :: h ( 0 : n , 0 : n ) real ( double ), intent ( out ) :: wr ( 0 : n ), wi ( 0 : n ) real ( double ), intent ( out ) :: eivec ( 0 : n , 0 : n ) integer , intent ( out ) :: rc integer , intent ( out ) :: cnt ( 0 : n ) integer :: en integer :: i , j , na , iter , l , ll , m , k real ( double ) :: p , q , r , s , t , w , x , y , z p = ZERO ; q = ZERO ; r = ZERO do i = 0 , n - 1 if ( i < low . or . i > high ) then wr ( i ) = h ( i , i ) wi ( i ) = ZERO cnt ( i ) = 0 endif enddo en = high t = ZERO do while ( en >= low ) iter = 0 na = en - 1 do while ( 1 < 2 ) ll = 999 do l = en , low + 1 , - 1 !search for small !subdiagonal element if ( DABS ( h ( l , l - 1 )) <= XMACH_EPS * ( DABS ( h ( l - 1 , l - 1 )) + DABS ( h ( l , l )))) then ll = l ; !save current index goto 10 !exit l loop endif enddo 10 if ( ll . ne . 999 ) then l = ll else l = 0 !restore l endif x = h ( en , en ) if ( l == en ) then !found one evalue wr ( en ) = x + t h ( en , en ) = x + t wi ( en ) = ZERO cnt ( en ) = iter en = en - 1 goto 15 !exit from loop while(True) endif y = h ( na , na ) w = h ( en , na ) * h ( na , en ) if ( l == na ) then !found two evalues p = ( y - x ) * 0.5d0 q = p * p + w z = DSQRT ( DABS ( q )) x = x + t h ( en , en ) = x + t h ( na , na ) = y + t cnt ( en ) = - iter cnt ( na ) = iter if ( q >= ZERO ) then !real eigenvalues if ( p < ZERO ) then z = p - z else z = p + z endif wr ( na ) = x + z wr ( en ) = x - w / z s = w - w / z wi ( na ) = ZERO wi ( en ) = ZERO x = h ( en , na ) r = DSQRT ( x * x + z * z ) p = x / r q = z / r do j = na , n - 1 z = h ( na , j ) h ( na , j ) = q * z + p * h ( en , j ) h ( en , j ) = q * h ( en , j ) - p * z enddo do i = 0 , en z = h ( i , na ) h ( i , na ) = q * z + p * h ( i , en ) h ( i , en ) = q * h ( i , en ) - p * z enddo do i = low , high z = eivec ( i , na ) eivec ( i , na ) = q * z + p * eivec ( i , en ) eivec ( i , en ) = q * eivec ( i , en ) - p * z enddo else !pair of complex wr ( na ) = x + p wr ( en ) = x + p wi ( na ) = z wi ( en ) = - z endif !if q>=ZERO en = en - 2 goto 15 !exit while(1<2) endif !if l = na if ( iter >= MAXIT ) then cnt ( en ) = MAXIT + 1 rc = en write ( * , * ) ' stop at iter >= MAXIT.' return endif if ( iter . ne . 0. and . MOD ( iter , 10 ) == 0 ) then t = t + x do i = low , en h ( i , i ) = h ( i , i ) - x enddo s = DABS ( h ( en , na )) + DABS ( h ( na , en - 2 )) x = 0.75d0 * s ; y = x w = - 0.4375d0 * s * s endif iter = iter + 1 do m = en - 2 , l , - 1 z = h ( m , m ) r = x - z s = y - z p = ( r * s - w ) / h ( m + 1 , m ) + h ( m , m + 1 ) q = h ( m + 1 , m + 1 ) - z - r - s r = h ( m + 2 , m + 1 ) s = DABS ( p ) + DABS ( q ) + DABS ( r ) p = p / s q = q / s r = r / s if ( m == l ) goto 12 if ( DABS ( h ( m , m - 1 )) * ( DABS ( q ) + DABS ( r )) <= XMACH_EPS * DABS ( p ) & * ( DABS ( h ( m - 1 , m - 1 )) + DABS ( z ) + DABS ( h ( m + 1 , m + 1 )))) then goto 12 !exit m loop endif enddo 12 do i = m + 2 , en h ( i , i - 2 ) = ZERO enddo do i = m + 3 , en h ( i , i - 3 ) = ZERO enddo do k = m , na if ( k . ne . m ) then !double QR step, for rows l to en and columns m to en p = h ( k , k - 1 ) q = h ( k + 1 , k - 1 ) if ( k . ne . na ) then r = h ( k + 2 , k - 1 ) else r = ZERO endif x = DABS ( p ) + DABS ( q ) + DABS ( r ) if ( x == ZERO ) goto 30 !next k p = p / x q = q / x r = r / x endif s = DSQRT ( p * p + q * q + r * r ) if ( p < ZERO ) s = - s if ( k . ne . m ) then h ( k , k - 1 ) = - s * x else if ( l . ne . m ) then h ( k , k - 1 ) = - h ( k , k - 1 ) endif p = p + s x = p / s y = q / s z = r / s q = q / p r = r / p do j = k , n - 1 !modify rows p = h ( k , j ) + q * h ( k + 1 , j ) if ( k . ne . na ) then p = p + r * h ( k + 2 , j ) h ( k + 2 , j ) = h ( k + 2 , j ) - p * z endif h ( k + 1 , j ) = h ( k + 1 , j ) - p * y h ( k , j ) = h ( k , j ) - p * x enddo if ( k + 3 < en ) then j = k + 3 else j = en endif do i = 0 , j !modify columns p = x * h ( i , k ) + y * h ( i , k + 1 ) if ( k . ne . na ) then p = p + z * h ( i , k + 2 ) h ( i , k + 2 ) = h ( i , k + 2 ) - p * r endif h ( i , k + 1 ) = h ( i , k + 1 ) - p * q h ( i , k ) = h ( i , k ) - p enddo do i = low , high p = x * eivec ( i , k ) + y * eivec ( i , k + 1 ) if ( k . ne . na ) then p = p + z * eivec ( i , k + 2 ) eivec ( i , k + 2 ) = eivec ( i , k + 2 ) - p * r endif eivec ( i , k + 1 ) = eivec ( i , k + 1 ) - p * q eivec ( i , k ) = eivec ( i , k ) - p enddo 30 continue enddo !k loop enddo !while(1<2) 15 continue enddo !while en >= low                         All evalues found !transform evectors back call hqrvec ( n , low , high , h , wr , wi , eivec , rc ) end subroutine hqr2 subroutine eigen ( n , matrix , eigvec , eigval ) !+The subroutine eigen  determines all eigenvalues and (if desired) !+all eigenvectors of a real square  n * n  matrix via the QR method !+in the version of Martin, Parlett, Peters, Reinsch and Wilkinson. !+ !+###Literature !+1. Peters, Wilkinson: Eigenvectors of real and complex !+   matrices by LR and QR triangularisations, !+   Num. Math. 16, p.184-204, (1970); [PETE70]; contribution !+   II/15, p. 372 - 395 in [WILK71]. !+2. Martin, Wilkinson: Similarity reductions of a general !+   matrix to Hessenberg form, Num. Math. 12, p. 349-368,(1968) !+   [MART 68]; contribution II,13, p. 339 - 358 in [WILK71]. !+3. Parlett, Reinsch: Balancing a matrix for calculations of !+   eigenvalues and eigenvectors, Num. Math. 13, p. 293-304, !+   (1969); [PARL69]; contribution II/11, p.315 - 326 in !+   [WILK71]. !+ !+###Input parameters !+   n     :  integer; ( n > 0 ) !+            size of matrix, number of eigenvalues !+ !+   mat   :  n x n matrix; !+            input matrix !+ !+###Output parameters !+   eivec :  n x n matrix;     (only if vec = 1) !+            matrix, if  vec = 1  that holds the eigenvectors !+            thus : !+            If the jth eigenvalue of the matrix is real then the !+            jth column is the corresponding real eigenvector; !+            if the jth eigenvalue is complex then the jth column !+            of eivec contains the real part of the eigenvector !+            while its imaginary part is in column j+1. !+            (the j+1st eigenvector is the complex conjugate !+            vector.) !+ !+   valre :  vector of size n; !+            Real parts of the eigenvalues. !+ !+   valim :  vector of size n; !+            Imaginary parts of the eigenvalues !+ !+   cnt   :  Integer vector of size n; !+            vector containing the number of iterations for each !+            eigenvalue. (for a complex conjugate pair the second !+            entry is negative). integer , intent ( in ) :: n ! nlevels real ( double ) , intent ( in ), dimension ( n , n ) :: matrix real ( double ) , intent ( out ), dimension ( n , n ) :: eigvec real ( double ) , intent ( out ), dimension ( n ) :: eigval real ( double ) :: mat ( 0 : n , 0 : n ) real ( double ) :: eivec ( 0 : n , 0 : n ) real ( double ) :: valre ( 0 : n ) !real parts of eigenvalues real ( double ) :: valim ( 0 : n ) !imaginary parts of eigenvalues integer :: rc !return code integer :: cnt ( 0 : n ) !Iteration counter integer :: high , low real ( double ) :: d ( 0 : n ), scale ( 0 : n ) integer :: perm ( 0 : n ) cnt = 0 ; d = 0.d0 mat ( 0 : n - 1 , 0 : n - 1 ) = matrix ( 1 : n , 1 : n ) !balance mat for nearly call balance ( n , mat , scale , low , high ) !equal row and column !reduce mat to upper call elmhes ( n , low , high , mat , perm ) !reduce mat to upper !Hessenberg form call elmtrans ( n , low , high , mat , perm , eivec ) !QR algorithm for eigenvalues and eigenvectors call hqr2 ( n , low , high , mat , valre , valim , eivec , cnt , rc ) !reverse balancing to determine eigenvectors call balback ( n , low , high , scale , eivec ) if ( rc . ne . 0 ) then print * , 'matrix = ' print * , matrix stop 'problem in eigen!' endif eigval ( 1 : n ) = valre ( 0 : n - 1 ) eigvec ( 1 : n , 1 : n ) = eivec ( 0 : n - 1 , 0 : n - 1 ) end subroutine eigen function outerprod ( a , b ) !+ Calculates outer product real ( double ), dimension (:), intent ( IN ) :: a , b real ( double ), dimension ( size ( a ), size ( b )) :: outerprod outerprod = spread ( a , dim = 2 , ncopies = size ( b )) * & spread ( b , dim = 1 , ncopies = size ( a )) end function outerprod subroutine swap ( a , b ) !+Swap arrays `a` and `b` real ( double ), dimension (:), intent ( INOUT ) :: a , b real ( double ), dimension ( size ( a )) :: dum dum = a a = b b = dum end subroutine swap subroutine ludcmp ( a , indx , d ) !+Calculates LU decomposition real ( double ), dimension (:,:), intent ( INOUT ) :: a integer , dimension (:), intent ( OUT ) :: indx real ( double ), intent ( OUT ) :: d real ( double ), dimension ( size ( a , 1 )) :: vv integer , dimension ( 1 ) :: imaxloc integer :: j , n , imax n = size ( indx ) d = 1.0 vv = maxval ( abs ( a ), dim = 2 ) if ( any ( vv . eq . 0. )) stop 'singular matrix in ludcmp' vv = 1.d0 / vv do j = 1 , n imaxloc = maxloc ( vv ( j : n ) * abs ( a ( j : n , j ))) imax = ( j - 1 ) + imaxloc ( 1 ) if ( j /= imax ) then call swap ( a ( imax ,:), a ( j ,:)) d =- d vv ( imax ) = vv ( j ) endif indx ( j ) = imax if ( a ( j , j ) == 0.0 ) a ( j , j ) = 1.0d-20 a ( j + 1 : n , j ) = a ( j + 1 : n , j ) / a ( j , j ) a ( j + 1 : n , j + 1 : n ) = a ( j + 1 : n , j + 1 : n ) - outerprod ( a ( j + 1 : n , j ), a ( j , j + 1 : n )) enddo end subroutine ludcmp subroutine lubksb ( a , indx , b ) !+ Does LU back substitution real ( double ), dimension (:,:), intent ( IN ) :: a integer , dimension (:), intent ( IN ) :: indx real ( double ), dimension (:), intent ( INOUT ) :: b integer :: i , n , ii , ll real ( double ) :: summ n = size ( indx ) ii = 0 do i = 1 , n ll = indx ( i ) summ = b ( ll ) b ( ll ) = b ( i ) if ( ii /= 0 ) then summ = summ - dot_product ( a ( i , ii : i - 1 ), b ( ii : i - 1 )) else if ( summ /= 0.0 ) then ii = i endif b ( i ) = summ enddo do i = n , 1 , - 1 b ( i ) = ( b ( i ) - dot_product ( a ( i , i + 1 : n ), b ( i + 1 : n ))) / a ( i , i ) enddo end subroutine lubksb subroutine matinv ( a , b ) !+ Matrix inversion with LU-decomposition !==================================================== real ( double ), dimension (:,:), intent ( IN ) :: a real ( double ), dimension (:,:), intent ( OUT ) :: b real ( double ), dimension ( size ( a , dim = 1 ), size ( a , dim = 2 )) :: ah , y integer :: i , N integer , dimension ( size ( a , dim = 1 )) :: indx real ( double ) :: d N = size ( a , dim = 1 ) if ( N /= size ( a , dim = 2 )) stop 'SUB matinv: ludcmp matrix must be square!' ah = a y = 0. do i = 1 , N y ( i , i ) = 1.d0 enddo call ludcmp ( ah , indx , d ) do i = 1 , N call lubksb ( ah , indx , y (:, i )) enddo b = y end subroutine matinv end module eigensystem","tags":"","loc":"sourcefile/eigensystem.f90.html","title":"eigensystem.f90 – FIDASIM"},{"text":"This file contains the main routines for FIDASIM 1.0.1 This File Depends On sourcefile~~fidasim.f90~~EfferentGraph sourcefile~fidasim.f90 fidasim.f90 sourcefile~utilities.f90 utilities.f90 sourcefile~utilities.f90->sourcefile~fidasim.f90 sourcefile~hdf5_extra.f90 hdf5_extra.f90 sourcefile~hdf5_extra.f90->sourcefile~fidasim.f90 sourcefile~eigensystem.f90 eigensystem.f90 sourcefile~eigensystem.f90->sourcefile~fidasim.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs fidasim Modules libfida Source Code fidasim.f90 Source Code !+ This file contains the main routines for FIDASIM {!../VERSION!} module libfida !+ Main FIDASIM library USE H5LT !! High level HDF5 Interface USE HDF5 !! Base HDF5 USE hdf5_extra !! Additional HDF5 routines USE eigensystem , ONLY : eigen , matinv USE utilities implicit none character ( 30 ) :: version = '' !+ FIDASIM version number integer , parameter , private :: Int32 = 4 !+ Defines a 32 bit integer integer , parameter , private :: Int64 = 8 !+ Defines a 64 bit integer integer , parameter , private :: Float32 = 4 !+ Defines a 32 bit floating point real integer , parameter , private :: Float64 = 8 !+ Defines a 64 bit floating point real integer , parameter :: charlim = 150 !+ Defines character limit for files and directories character ( charlim ) :: namelist_file !+ Input namelist file integer , parameter :: nbif_type = 1 !+ Identifier for full energy NBI neutral interaction integer , parameter :: nbih_type = 2 !+ Identifier for half energy NBI neutral interaction integer , parameter :: nbit_type = 3 !+ Identifier for third energy NBI neutral interaction integer , parameter :: halo_type = 4 !+ Identifier for halo neutral interaction integer , parameter :: fida_type = 5 !+ Identifier for fida neutral interaction integer , parameter :: brems_type = 6 !+ Identifier for bremsstrahlung interaction. Acts as dummy type integer , parameter :: ntypes = 6 !+ Number of different types of neutrals integer , parameter :: beam_ion = 1 !+ Identifier for a beam ion integer , parameter :: thermal_ion = 2 !+ Identifier for a thermal ion !! Physical units real ( Float64 ), parameter :: e_amu = 5.485799093287202d-4 !+ Atomic mass of an electron [amu] real ( Float64 ), parameter :: H_1_amu = 1.00782504d0 !+ Atomic mass of Hydrogen-1 [amu] real ( Float64 ), parameter :: H_2_amu = 2.0141017778d0 !+ Atomic mass of Hydrogen-2 [amu] real ( Float64 ), parameter :: B5_amu = 1 0.81d0 !+ Atomic mass of Boron [amu] real ( Float64 ), parameter :: C6_amu = 1 2.011d0 !+ Atomic mass of Carbon [amu] real ( Float64 ), parameter :: mass_u = 1.6605402d-27 !+ Atomic mass unit [kg] real ( Float64 ), parameter :: e0 = 1.60217733d-19 !+ Electron charge [C] real ( Float64 ), parameter :: pi = 3.14159265358979323846264d0 !+ Pi real ( Float64 ), parameter :: c0 = 2.99792458d+08 !+ Speed of light [m/s] real ( Float64 ), parameter :: h_planck = 4.135667516d-15 !+ Planck's constant [eV*s] real ( Float64 ), parameter :: lambda0 = 65 6.1d0 !+ D-alpha emission line [nm] real ( Float64 ), parameter :: v2_to_E_per_amu = mass_u / ( 2. * e0 * 1.d3 ) * 1.d-4 !+ cm&#94;2/s&#94;2 to keV conversion factor integer , parameter :: n_stark = 15 !+ Number of Stark lines real ( Float64 ), parameter , dimension ( n_stark ) :: stark_wavel = & [ - 2.20200d-07 , - 1.65200d-07 , - 1.37700d-07 , - 1.10200d-07 , & - 8.26400d-08 , - 5.51000d-08 , - 2.75600d-08 , 0.00000d0 , & 2.75700d-08 , 5.51500d-08 , 8.27400d-08 , 1.10300d-07 , & 1.38000d-07 , 1.65600d-07 , 2.20900d-07 ] !+ Stark wavelengths [nm*m/V] real ( Float64 ), parameter , dimension ( n_stark ) :: stark_intens = & [ 1.000d0 , 1 8.00d0 , 1 6.00d0 , 168 1.d0 , 230 4.d0 , & 72 9.0d0 , 193 6.d0 , 549 0.d0 , 193 6.d0 , 72 9.0d0 , & 230 4.d0 , 168 1.d0 , 1 6.00d0 , 1 8.00d0 , 1.000d0 ] !+ Stark Intensities integer , parameter , dimension ( n_stark ) :: stark_pi = & [ 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 ] !+ Pi line indicators integer , parameter , dimension ( n_stark ) :: stark_sigma = 1 - stark_pi !+ Sigma line indicators !!Numerical Settings integer , parameter :: nlevs = 6 !+ Number of atomic energy levels real ( Float64 ), parameter :: n_halo_neutrate = 2 0. !+ Number of times to average halo H_H_cx real ( Float64 ) :: colrad_threshold = 1.d6 !+ colrad threshold real ( Float64 ), dimension ( ntypes ) :: halo_iter_dens = 0.d0 !+ Keeps track of how of each generations halo density integer :: nbi_outside = 0 !+ Keeps track of how many beam neutrals do not hit the [[libfida:beam_grid]] type InterpolCoeffs1D !+ Linear Interpolation Coefficients and indices integer :: i = 0 !+ Index of position right before `xout` real ( Float64 ) :: b1 = 0.d0 !+ Coefficient for y(i) term real ( Float64 ) :: b2 = 0.d0 !+ Coefficient for y(i+1) term end type InterpolCoeffs1D type InterpolCoeffs2D !+ 2D Linear Interpolation Coefficients and indices integer :: i = 0 !+ Index of abscissa before `xout` integer :: j = 0 !+ Index of ordinate before `yout` real ( Float64 ) :: b11 = 0.d0 !+ Coefficient for z(i,j) term real ( Float64 ) :: b12 = 0.d0 !+ Coefficient for z(i,j+1) term real ( Float64 ) :: b21 = 0.d0 !+ Coefficient for z(i+1,j) term real ( Float64 ) :: b22 = 0.d0 !+ Coefficient for z(i+1,j+1) term end type InterpolCoeffs2D type BeamGrid !+ Defines a 3D grid for neutral beam calculations integer ( Int32 ) :: nx !+ Number of cells in the x direction integer ( Int32 ) :: ny !+ Number of cells in the y direction integer ( Int32 ) :: nz !+ Number of cells in the z direction real ( Float64 ) :: xmin !+ Minimum x value real ( Float64 ) :: xmax !+ Maximum x value real ( Float64 ) :: ymin !+ Minimum y value real ( Float64 ) :: ymax !+ Maximum y value real ( Float64 ) :: zmin !+ Minimum z value real ( Float64 ) :: zmax !+ Maximum z value real ( Float64 ) :: alpha !+ Tait-Bryan angle for a rotation about z [radians] real ( Float64 ) :: beta !+ Tait-Bryan angle for a rotation about y' [radians] real ( Float64 ) :: gamma !+ Tait-Bryan angle for a rotation about x\" [radians] real ( Float64 ) :: drmin !+ Minimum cell spacing: `min(dx,dy,dz)` real ( Float64 ) :: dv !+ Cell volume [cm&#94;3] real ( Float64 ) :: volume !+ Grid volume [cm&#94;3] integer ( Int32 ) :: ntrack !+ Maximum number of cell for particle tracking integer ( Int32 ) :: ngrid !+ Number of cells real ( Float64 ), dimension ( 3 ) :: origin !+ Origin of beam grid in machine coordinates real ( Float64 ), dimension ( 3 ) :: center !+ Center of beam grid in beam coordinates real ( Float64 ), dimension ( 3 ) :: dr !+ Cell spacings [dx, dy, dz] real ( Float64 ), dimension ( 3 ) :: lwh !+ Grid [length(x), width(y), height(z)] real ( Float64 ), dimension ( 3 , 3 ) :: basis !+Beam grid basis for converting from beam coordinates(xyz) !+to machine coordinates(uvw): (\\uvw = B*xyz + origin real ( Float64 ), dimension ( 3 , 3 ) :: inv_basis !+Inverse basis for reverse transformation: (\\xyz = B&#94;{-1}*(uvw - origin) real ( Float64 ), dimension (:), allocatable :: xc !+ x positions of cell centers real ( Float64 ), dimension (:), allocatable :: yc !+ y positions of cell centers real ( Float64 ), dimension (:), allocatable :: zc !+ z positions of cell centers end type BeamGrid type InterpolationGrid !+ Defines a 2D R-Z grid for interpolating plasma parameters and fields integer ( Int32 ) :: nr !+ Number of Radii integer ( Int32 ) :: nz !+ Number of Z values real ( Float64 ) :: dr !+ Radial spacing [cm] real ( Float64 ) :: dz !+ Vertical spacing [cm] real ( Float64 ) :: da !+ Grid element area [cm&#94;2] real ( Float64 ), dimension (:), allocatable :: r !+ Radii values [cm] real ( Float64 ), dimension (:), allocatable :: z !+ Z values [cm] real ( Float64 ), dimension (:,:), allocatable :: r2d !+ 2D R grid [cm] real ( Float64 ), dimension (:,:), allocatable :: z2d !+ 2D Z grid [cm] end type InterpolationGrid type Profiles !+ Torodial symmetric plasma parameters at a given R-Z real ( Float64 ) :: dene = 0.d0 !+ Electron density [cm&#94;{-3}] real ( Float64 ) :: denp = 0.d0 !+ Ion density [cm&#94;{-3}] real ( Float64 ) :: denimp = 0.d0 !+ Impurity density [cm&#94;{-3}] real ( Float64 ) :: denf = 0.d0 !+ Fast-ion density [cm&#94;{-3}] real ( Float64 ) :: te = 0.d0 !+ Electron temperature [kev] real ( Float64 ) :: ti = 0.d0 !+ Ion temperature [kev] real ( Float64 ) :: zeff = 0.d0 !+ Effective Nuclear Charge real ( Float64 ) :: vr = 0.d0 !+ Plasma rotation in radial direction real ( Float64 ) :: vt = 0.d0 !+ Plasma rotation in torodial/phi direction real ( Float64 ) :: vz = 0.d0 !+ Plasma rotation in z direction end type Profiles type , extends ( Profiles ) :: LocalProfiles !+ Plasma parameters at given position logical :: in_plasma = . False . !+ Indicates whether plasma parameters are valid/known logical :: machine_coords = . False . !+ Indicates whether vectors are in machine coordinates real ( Float64 ), dimension ( 3 ) :: pos = 0.d0 !+ Position in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: uvw = 0.d0 !+ Position in machine coordinates real ( Float64 ), dimension ( 3 ) :: vrot = 0.d0 !+ Plasma rotation in beam grid coordinates type ( InterpolCoeffs2D ) :: c !+ Linear Interpolation Coefficients and indicies for interpolation at `pos` end type LocalProfiles type EMFields !+ Torodial symmetric electro-magnetic fields at given R-Z real ( Float64 ) :: br = 0.d0 !+ Radial magnetic field [T] real ( Float64 ) :: bt = 0.d0 !+ Torodial magnetic field [T] real ( Float64 ) :: bz = 0.d0 !+ Vertical magnetic field [T] real ( Float64 ) :: er = 0.d0 !+ Radial electric field [V/m] real ( Float64 ) :: et = 0.d0 !+ Torodial electric field [V/m] real ( Float64 ) :: ez = 0.d0 !+ Vertical electric field [V/m] real ( Float64 ) :: dbr_dr = 0.d0 !+ Radial derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbr_dz = 0.d0 !+ Vertical derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbt_dr = 0.d0 !+ Radial derivative of the torodial magnetic field [T/m] real ( Float64 ) :: dbt_dz = 0.d0 !+ Vertical derivative of the torodial magnetic field [T/m] real ( Float64 ) :: dbz_dr = 0.d0 !+ Radial derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbz_dz = 0.d0 !+ Vertical derivative of the vertical magnetic field [T/m] end type EMFields type , extends ( EMFields ) :: LocalEMFields !+ Electro-magnetic fields at given position logical :: in_plasma = . False . !+ Indicates whether fields are valid/known logical :: machine_coords = . False . !+ Indicates whether vectors are in machine coordinates real ( Float64 ) :: b_abs = 0.d0 !+ Magnitude of magnetic field real ( Float64 ) :: e_abs = 0.d0 !+ Magnitude of electrin field real ( Float64 ), dimension ( 3 ) :: pos = 0.d0 !+ Position in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: uvw = 0.d0 !+ Position in machine coordinates real ( Float64 ), dimension ( 3 ) :: b_norm = 0.d0 !+ Direction of magnetic field in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: a_norm = 0.d0 !+ Vector perpendicular to `b_norm` and `c_norm` real ( Float64 ), dimension ( 3 ) :: c_norm = 0.d0 !+ Vector perpendicular to `b_norm` and `a_norm` real ( Float64 ), dimension ( 3 ) :: e_norm = 0.d0 !+ Direction of electric field in beam grid coordinates type ( InterpolCoeffs2D ) :: c !+ Linear Interpolation Coefficients and indicies for interpolation at `pos` end type LocalEMFields type Equilibrium !+MHD Equilbrium type ( EMFields ), dimension (:,:), allocatable :: fields !+ Electro-magnetic fields at points defined in [[libfida:inter_grid]] type ( Profiles ), dimension (:,:), allocatable :: plasma !+ Plasma parameters at points defined in [[libfida:inter_grid]] real ( Float64 ), dimension (:,:), allocatable :: mask !+ Indicates whether fields and plasma are well-defined at points defined in [[libfida:inter_grid]] end type Equilibrium type FastIonDistribution !+ Defines a Guiding Center Fast-ion Distribution Function: F(E,p,R,Z) integer ( Int32 ) :: nenergy !+ Number of energies integer ( Int32 ) :: npitch !+ Number of pitches integer ( Int32 ) :: nr !+ Number of radii integer ( Int32 ) :: nz !+ Number of z values real ( Float64 ) :: dE !+ Energy spacing [keV] real ( Float64 ) :: dp !+ Pitch spacing real ( Float64 ) :: dr !+ Radial spacing [cm] real ( Float64 ) :: dz !+ Z spacing [cm] real ( Float64 ) :: emin !+ Minimum energy [keV] real ( Float64 ) :: emax !+ Maximum energy [keV] real ( Float64 ) :: e_range !+ Energy interval length [keV] real ( Float64 ) :: pmin !+ Minimum pitch real ( Float64 ) :: pmax !+ Maximum pitch real ( Float64 ) :: p_range !+ Pitch interval length real ( Float64 ) :: n_tot = 0.d0 !+ Total Number of fast-ions real ( Float64 ), dimension (:), allocatable :: energy !+ Energy values [keV] real ( Float64 ), dimension (:), allocatable :: pitch !+ Pitch w.r.t. the magnetic field real ( Float64 ), dimension (:), allocatable :: r !+ Radius [cm] real ( Float64 ), dimension (:), allocatable :: z !+ Z [cm] real ( Float64 ), dimension (:,:), allocatable :: denf !+ Fast-ion density defined on the [[libfida:inter_grid]]: denf(R,Z) real ( Float64 ), dimension (:,:,:,:), allocatable :: f !+ Fast-ion distribution function defined on the [[libfida:inter_grid]]: F(E,p,R,Z) end type FastIonDistribution type FastIon !+ Defines a fast-ion logical :: cross_grid = . False . !+ Indicates whether the fast-ion crosses the [[libfida:beam_grid]] real ( Float64 ) :: r = 0.d0 !+ Radial position of fast-ion [cm] real ( Float64 ) :: z = 0.d0 !+ Vertical position of fast-ion [cm] real ( Float64 ) :: phi_enter = 0.d0 !+ Torodial/phi position where fast-ion enters the [[libfida:beam_grid]] [radians] real ( Float64 ) :: delta_phi = 2 * pi !+ Angle subtended by the [[libfida:beam_grid]] at (r,z) real ( Float64 ) :: energy = 0.d0 !+ Energy [keV] real ( Float64 ) :: pitch = 0.d0 !+ Pitch w.r.t. the magnetic field real ( Float64 ) :: vabs = 0.d0 !+ Speed [cm/s] real ( Float64 ) :: vr = 0.d0 !+ Radial velocity [cm/s] real ( Float64 ) :: vt = 0.d0 !+ Torodial velocity [cm/s] real ( Float64 ) :: vz = 0.d0 !+ Z velocity [cm/s] real ( Float64 ) :: weight = 0.d0 !+ Particle weight: How many fast-ions does particle represent. integer ( Int32 ) :: class = 0 !+ Orbit class id end type FastIon type FastIonParticles !+ Collection of fast-ion particles integer ( Int32 ) :: nparticle = 0 !+ Number of particles integer ( Int32 ) :: nclass = 1 !+ Number of orbit classes type ( FastIon ), dimension (:), allocatable :: fast_ion !+ Fast-ion particles end type FastIonParticles type NeutralBeam !+ Defines a neutral beam with +x defined to be into the plasma character ( 25 ) :: name = '' !+ Beam name integer :: shape !+ Beam source shape 1=\"rectangular\", 2=\"circular\" real ( Float64 ) :: widy !+ Half width of source in y direction real ( Float64 ) :: widz !+ Half height of source in z direction real ( Float64 ) :: focy !+ Focal length in y direction real ( Float64 ) :: focz !+ Focal length in z direction real ( Float64 ) :: einj !+ NBI voltage  [kV] real ( Float64 ) :: pinj !+ NBI power    [MW] real ( Float64 ) :: vinj !+ NBI velocity [cm/s] real ( Float64 ) :: alpha !+ Z rotation not same as [[libfida:beam_grid]] alpha real ( Float64 ) :: beta !+ Tilt rotation not same as [[libfida:beam_grid]] beta real ( Float64 ), dimension ( 3 ) :: divy !+ Energy dependent divergence in y direction real ( Float64 ), dimension ( 3 ) :: divz !+ Energy dependent divergence in z direction real ( Float64 ), dimension ( 3 ) :: current_fractions !+ Fractions of full, half, and third energy neutrals real ( Float64 ), dimension ( 3 ) :: src !+ Position of source in beam grid coordinates [cm] real ( Float64 ), dimension ( 3 ) :: axis !+ Beam centerline integer :: naperture !+ Number of beam apertures integer , dimension (:), allocatable :: ashape !+ Aperture shape 1=\"rectangular\", 2=\"circular\" real ( Float64 ), dimension (:), allocatable :: awidy !+ Half width of the aperture(s) in y direction real ( Float64 ), dimension (:), allocatable :: awidz !+ Half height of the aperture(s) in z direction real ( Float64 ), dimension (:), allocatable :: aoffy !+ Horizontal (y) offset of the aperture(s) relative to the beam centerline [cm] real ( Float64 ), dimension (:), allocatable :: aoffz !+ Vertical (z) offset of the aperture(s) relative to the beam centerline [cm] real ( Float64 ), dimension (:), allocatable :: adist !+ Distance from the center of the beam source grid to the aperture(s) plane [cm] real ( Float64 ), dimension ( 3 , 3 ) :: basis !+ Beam basis for converting from centerline coordinates to beam grid coordinates real ( Float64 ), dimension ( 3 , 3 ) :: inv_basis !+ Inverse basis for reverse transfomation end type NeutralBeam type AtomicCrossSection !+ Defines a n/m-resolved atomic cross section table integer :: nenergy = 1 !+ Number of beam energies real ( Float64 ) :: logemin = 0.d0 !+ Log-10 minimum energy real ( Float64 ) :: logemax = 0.d0 !+ Log-10 maximum energy integer :: n_max = nlevs !+ Number of initial atomic energy levels integer :: m_max = nlevs !+ Number of final atomic energy levels real ( Float64 ) :: dlogE = 0.d0 !+ Log-10 energy spacing real ( Float64 ) :: minlog_cross !+ Log-10 minimum cross section real ( Float64 ), dimension (:,:,:), allocatable :: log_cross !+ Log-10 cross sections end type AtomicCrossSection type AtomicRates !+ Defines an atomic table for populating and de-populating reaction rates integer :: nenergy = 1 !+ Number of beam energies real ( Float64 ) :: logemin = 0.d0 !+ Log-10 minimum energy real ( Float64 ) :: logemax = 0.d0 !+ Log-10 maximum energy integer :: ntemp = 1 !+ Number of target temperatures real ( Float64 ) :: logtmin = 0.d0 !+ Log-10 minimum temperature real ( Float64 ) :: logtmax = 0.d0 !+ Log-10 maximum temperature integer :: n_max = nlevs !+ Number of initial atomic energy levels integer :: m_max = nlevs !+ Number of final atomic energy levels real ( Float64 ) :: dlogE = 0.d0 !+ Log-10 energy spacing real ( Float64 ) :: dlogT = 0.d0 !+ Log-10 temperature spacing real ( Float64 ) :: minlog_pop = 0.d0 !+ Log-10 minimum reaction rates for populating transistions real ( Float64 ) :: minlog_depop = 0.d0 !+ Log-10 minimum reaction rates for de-populating transistions real ( Float64 ), dimension ( 2 ) :: ab = 0.d0 !+ Atomic mass of beam and thermal ions respectively [amu] real ( Float64 ), dimension (:,:,:,:,:), allocatable :: log_pop !+ Log-10 reaction rates for populating transistions real ( Float64 ), dimension (:,:,:,:), allocatable :: log_depop !+ Log-10 reaction rates for de-populating transistions end type AtomicRates type NuclearRates !+ Nuclear reaction rates integer :: nbranch = 1 !+ Number of reaction branches integer :: nenergy = 1 !+ Number of beam energies real ( Float64 ) :: logemin = 0.d0 !+ Log-10 minimum energy real ( Float64 ) :: logemax = 0.d0 !+ Log-10 maximum energy integer :: ntemp = 1 !+ Number of target temperatures real ( Float64 ) :: logtmin = 0.d0 !+ Log-10 minimum temperature real ( Float64 ) :: logtmax = 0.d0 !+ Log-10 maximum temperature real ( Float64 ) :: dlogE = 0.d0 !+ Log-10 energy spacing real ( Float64 ) :: dlogT = 0.d0 !+ Log-10 temperature spacing real ( Float64 ) :: minlog_rate = 0.d0 !+ Log-10 minimum reaction rate real ( Float64 ), dimension ( 2 ) :: bt_amu = 0.d0 !+ Isotope mass of beam and thermal ions respectively [amu] real ( Float64 ), dimension (:,:,:), allocatable :: log_rate !+ Log-10 reaction rates: log_rate(energy, temperature, branch) end type NuclearRates type AtomicTables !+ Atomic tables for various types of interactions type ( AtomicCrossSection ) :: H_H_cx !+ Hydrogen-Hydrogen charge exchange n/m-resolved cross sections type ( AtomicRates ) :: H_H !+ Hydrogen-Hydrogen reaction rates type ( AtomicRates ) :: H_e !+ Hydrogen-Electron reaction rates type ( AtomicRates ) :: H_Aq !+ Hydrogen-Impurity reaction rates real ( Float64 ), dimension ( nlevs , nlevs ) :: einstein !+ Einstein coefficients for spontaneous emission type ( NuclearRates ) :: D_D !+ Deuterium-Deuterium reaction rates end type AtomicTables type LineOfSight !+ Defines a line of sight real ( Float64 ) :: sigma_pi = 1.d0 !+ Ratio of sigma to pi line intensity real ( Float64 ) :: spot_size = 0.d0 !+ Radius of spot size [cm] real ( Float64 ), dimension ( 3 ) :: lens = 0.d0 !+ Lens location in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: axis = 0.d0 !+ Optical axis in beam grid coordinates end type LineOfSight type LOSElement !+ Defines a element of a line of sight and cell intersection integer :: id !+ Line of sight index real ( Float64 ) :: length !+ Length of crossing end type LOSElement type LOSInters !+ Defines the channels that intersect a cell integer :: nchan = 0 !+ Number of channels that intersect type ( LOSElement ), dimension (:), allocatable :: los_elem !+ Array of crossing end type LOSInters type SpectralChords !+ Defines an spectral diagnostic system integer :: nchan = 0 !+ Number of channels type ( LineOfSight ), dimension (:), allocatable :: los !+ Line of sight array real ( Float64 ), dimension (:), allocatable :: radius !+ Radius of each line of sight type ( LOSInters ), dimension (:,:,:), allocatable :: inter !+ Array of LOS intersections with [[libfida:beam_grid]] end type SpectralChords type BoundedPlane !+ Defines a plane with a circular or rectangular boundary integer :: shape = 0 !+ Boundary shape 1=\"Rectangular\", 2=\"circular\" real ( Float64 ) :: hh = 0.d0 !+ Half height of boundary [cm] real ( Float64 ) :: hw = 0.d0 !+ Half width of boundary [cm] real ( Float64 ), dimension ( 3 ) :: origin = 0.d0 !+ Origin of plane in machine coordinates real ( Float64 ), dimension ( 3 , 3 ) :: basis = 0.d0 !+ Basis vectors basis(:,1) = u_1 is plane normal real ( Float64 ), dimension ( 3 , 3 ) :: inv_basis = 0.d0 !+ Inverse basis end type BoundedPlane type NPADetector !+ Defines a NPA detector type ( BoundedPlane ) :: detector !+ Detecting plane of NPA detector type ( BoundedPlane ) :: aperture !+ Aperture plane of NPA detector end type NPADetector type NPAProbability !+ Type to contain the probability of hitting a NPA detector real ( Float64 ) :: p = 0.d0 !+ Hit probability real ( Float64 ) :: pitch = - 2.d0 !+ Pitch real ( Float64 ), dimension ( 3 ) :: eff_rd = 0.d0 !+ Effective position of detector real ( Float64 ), dimension ( 3 ) :: dir = 0.d0 !+ Trajectory direction end type NPAProbability type NPAChords !+ Defines a NPA system integer :: nchan = 0 !+ Number of channels type ( NPADetector ), dimension (:), allocatable :: det !+ NPA detector array real ( Float64 ), dimension (:), allocatable :: radius !+ Radius [cm] logical , dimension (:,:,:), allocatable :: hit !+ Indicates whether a particle can hit any NPA detector from a grid cell: hit(x,y,z) type ( NPAProbability ), dimension (:,:,:,:), allocatable :: phit !+ Probability of hitting a detector from a grid cell: phit(x,y,z,chan) end type NPAChords type NPAParticle !+ Defines a NPA particle integer :: detector = 0 !+ Detector NPA particle hit real ( Float64 ) :: xi = 0.d0 !+ Initial x position real ( Float64 ) :: yi = 0.d0 !+ Initial y position real ( Float64 ) :: zi = 0.d0 !+ Initial z position real ( Float64 ) :: xf = 0.d0 !+ Final x position real ( Float64 ) :: yf = 0.d0 !+ Final y position real ( Float64 ) :: zf = 0.d0 !+ Final z position real ( Float64 ) :: weight = 0.d0 !+ NPA particle weight real ( Float64 ) :: energy = 0.d0 !+ Birth Energy [keV] real ( Float64 ) :: pitch = 0.d0 !+ Birth Pitch end type NPAParticle type NPAResults !+ MC NPA result structure integer ( Int32 ) :: nchan = 0 !+ Number of NPA channels integer ( Int32 ) :: npart = 0 !+ Number of particles that hit a detector integer ( Int32 ) :: nmax = 1000000 !+ Maximum allowed number of particles grows if necessary integer ( Int32 ) :: nenergy = 100 !+ Number of energy values type ( NPAParticle ), dimension (:), allocatable :: part !+ Array of NPA particles real ( Float64 ), dimension (:), allocatable :: energy !+ Energy array [keV] real ( Float64 ), dimension (:,:,:), allocatable :: flux !+ Neutral particle flux: flux(energy,chan, orbit_type) [neutrals/(s*dE)] end type NPAResults type BirthProfile !+ Birth profile structure integer :: cnt = 1 !+ Particle counter integer , dimension (:), allocatable :: neut_type !+ Particle birth type (1=Full, 2=Half, 3=Third) real ( Float64 ), dimension (:,:), allocatable :: ri !+ Particle birth position [cm] real ( Float64 ), dimension (:,:), allocatable :: vi !+ Particle birth velocity [cm/s] integer , dimension (:,:), allocatable :: ind !+ Particle [[libfida:beam_grid]] indices real ( Float64 ), dimension (:,:,:,:), allocatable :: dens !+ Birth density: dens(neutral_type,x,y,z) [fast-ions/(s*cm&#94;3)] end type BirthProfile type Spectra !+ Spectra storage structure real ( Float64 ), dimension (:,:), allocatable :: brems !+ Bremsstruhlung: brems(lambda,chan) real ( Float64 ), dimension (:,:,:), allocatable :: bes !+ Beam emission: bes(lambda,chan,neutral_type) real ( Float64 ), dimension (:,:,:), allocatable :: fida !+ FIDA emission: fida(lambda,chan,orbit_type) end type Spectra type NeutronRate !+ Neutron storage structure real ( Float64 ), dimension (:), allocatable :: rate !+ Neutron rate: rate(orbit_type) [neutrons/sec] real ( Float64 ), dimension (:,:,:,:), allocatable :: weight !+ Neutron rate weight: weight(E,p,R,Z) end type NeutronRate type NeutralDensity !+ Neutral density structure real ( Float64 ), dimension (:,:,:,:,:), allocatable :: dens !+ Neutral density: dens(lev,neutral_type,x,y,z) end type NeutralDensity type FIDAWeights !+ FIDA weights structure real ( Float64 ), dimension (:,:,:), allocatable :: mean_f !+ Estimate of mean fast-ion distribution function \"seen\" by LOS: mean_f(E,p,chan) real ( Float64 ), dimension (:,:,:,:), allocatable :: weight !+ FIDA weight function: weight(lambda,E,p,chan) end type FIDAWeights type NPAWeights !+ NPA weights structure real ( Float64 ), dimension (:,:,:,:,:), allocatable :: attenuation !+ Attenuation fraction: attenuation(E,x,y,z,chan) real ( Float64 ), dimension (:,:,:,:,:), allocatable :: cx !+ Charge Exchange reaction rates: cx(E,x,y,z,chan) real ( Float64 ), dimension (:,:,:,:), allocatable :: emissivity !+ Emissivity: emissivity(x,y,z,chan) [neutrals/(s*dV)] real ( Float64 ), dimension (:,:,:), allocatable :: weight !+ NPA weight function: weight(E,p,chan) [neutrals/(s*fast-ion*dE*dP)] real ( Float64 ), dimension (:,:), allocatable :: flux !+ Neutral particle flux: flux(E,chan) [neutrals/(s*dE)] end type NPAWeights type SimulationInputs !+ Simulation settings structure integer ( Int32 ) :: shot_number !+ Shot Number real ( Float64 ) :: time !+ Shot time [s] character ( charlim ) :: runid = '' !+ FIDASIM run ID character ( charlim ) :: result_dir = '' !+ Result directory character ( charlim ) :: tables_file = '' !+ Atomic tables file character ( charlim ) :: geometry_file = '' !+ FIDASIM input file containing geometric quantities character ( charlim ) :: equilibrium_file = '' !+ FIDASIM input file containing the plasma parameters and fields character ( charlim ) :: distribution_file = '' !+ FIDASIM input file containing the fast-ion distribution character ( charlim ) :: neutrals_file = '' !+ FIDASIM output/input file containing beam neutral density. !+ Used when [[SimulationInputs:load_neutrals]] is set. !! Monte Carlo settings integer ( Int64 ) :: n_fida !+ Number of FIDA mc markers integer ( Int64 ) :: n_npa !+ Number of NPA mc markers integer ( Int64 ) :: n_nbi !+ Number of neutral beam mc markers integer ( Int64 ) :: n_dcx !+ Number of direct charge exchange (DCX) mc markers integer ( Int64 ) :: n_halo !+ Number of halo mc markers integer ( Int64 ) :: n_birth !+ Number of birth particles per [[SimulationInputs:n_nbi]] !! Simulation switches integer ( Int32 ) :: calc_spec !+ Calculate spectra: 0 = off, 1=on integer ( Int32 ) :: calc_brems !+ Calculate bremmstruhlung: 0 = off, 1=on integer ( Int32 ) :: calc_bes !+ Calculate BES: 0 = off, 1=on integer ( Int32 ) :: calc_fida !+ Calculate FIDA: 0 = off, 1=on integer ( Int32 ) :: load_neutrals !+ Load neutrals from file: 0 = off, 1=on integer ( Int32 ) :: calc_npa !+ Calculate NPA: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: calc_fida_wght !+ Calculate FIDA weight: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: calc_npa_wght !+ Calculate NPA weights: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: calc_birth !+ Calculate birth profile: 0 = off, 1=on integer ( Int32 ) :: calc_neutron !+ Calculate neutron flux: 0 = off, 1=on integer ( Int32 ) :: no_flr !+ Turns off Finite Larmor Radius effects: 0=off, 1=on integer ( Int32 ) :: dump_dcx !+ Output DCX density and spectra: 0 = off, 1=on integer ( Int32 ) :: verbose !+ Verbosity: <0 = off++, 0 = off, 1=on, 2=on++ !! Neutral Beam Settings real ( Float64 ) :: ab !+ Atomic mass of beam neutrals !! Plasma parameters integer ( Int32 ) :: impurity_charge !+ Impurity proton number real ( Float64 ) :: ai !+ Atomic mass of thermal ions !! Distribution settings integer ( Int32 ) :: dist_type !+ Type of fast-ion distribution !! Spectrum parameters integer ( Int32 ) :: nlambda !+ Number of wavelength to calculate real ( Float64 ) :: dlambda !+ Wavelength spacing [nm] real ( Float64 ) :: lambdamin !+ Minimum wavelength [nm] real ( Float64 ) :: lambdamax !+ Maximum wavelength [nm] !! Weight function settings integer ( Int32 ) :: ne_wght !+ Number of energies in weight functions integer ( Int32 ) :: np_wght !+ Number of pitches in weight functions integer ( Int32 ) :: nphi_wght !+ Number of gyro-angles to average over in weight functions integer ( Int32 ) :: nlambda_wght !+ Number of wavelength to calculate in weight functions real ( Float64 ) :: emax_wght !+ Maximum energy in weight functions [keV] real ( Float64 ) :: lambdamin_wght !+ Minimum wavelength in weight functions [nm] real ( Float64 ) :: lambdamax_wght !+ Maximum wavelength in weight functions [nm] end type SimulationInputs type ParticleTrack !+ Stores properties seen when traveling through a 3D grid real ( Float64 ) :: time = 0.d0 !+ Time/distance/... in cell real ( Float64 ) :: flux = 0.d0 !+ Flux/density/... in cell integer ( Int32 ), dimension ( 3 ) :: ind = 0 !+ Indices of cell real ( Float64 ), dimension ( 3 ) :: pos = 0.d0 !+ Midpoint of track in cell [cm] end type ParticleTrack type GyroSurface !+ Surface containing the fast-ion velocity vectors for all values of the !+ gyro-angle. It takes the form of a hyperboloid !+ (x(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(cos(\\gamma + \\pi/2) - \\omega_i t sin(\\gamma + \\pi/2))  !+ (y(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(sin(\\gamma + \\pi/2) + \\omega_i t cos(\\gamma + \\pi/2))  !+ (z(\\gamma,t) = \\alpha \\omega_i \\rm{pitch} t !+ where \\gamma is the gyro-angle, \\omega_i is the ion !+ gyro-frequency and \\alpha = V/\\omega_i  real ( Float64 ) :: v = 0.d0 !+ Particle speed real ( Float64 ) :: omega = 0.d0 !+ Ion gyro-frequency real ( Float64 ), dimension ( 3 ) :: axes !+ Semi-axes of the hyperboloid, i.e. a, b, c coefficients real ( Float64 ), dimension ( 3 ) :: center = 0.d0 !+ Center of the gyrosurface real ( Float64 ), dimension ( 3 , 3 ) :: A = 0.d0 !+ Coefficients of quartic surface i.e. `basis*diagm(1/a&#94;2,1/b&#94;2,1/c&#94;2)*basis'` real ( Float64 ), dimension ( 3 , 3 ) :: basis = 0.d0 !+ Basis of coordinate system of gyrosurface end type GyroSurface interface assignment ( = ) !+ Allows for assigning [[Profiles]],[[LocalProfiles]], !+ [[EMFields]],[[LocalEMFields]],[[FastIon]], and [[NPAParticle]] module procedure pp_assign , lpp_assign , plp_assign , lplp_assign , & ff_assign , lff_assign , flf_assign , lflf_assign , & fast_ion_assign , npa_part_assign end interface interface operator ( + ) !+ Allows for adding [[Profiles]],[[LocalProfiles]], !+ [[EMFields]], and [[LocalEMFields]] module procedure pp_add , lplp_add , ff_add , lflf_add end interface interface operator ( - ) !+ Allows for subtracting [[Profiles]],[[LocalProfiles]], !+ [[EMFields]], and [[LocalEMFields]] module procedure pp_subtract , lplp_subtract , ff_subtract , lflf_subtract end interface interface operator ( * ) !+ Allows for multiplying [[Profiles]],[[LocalProfiles]], !+ [[EMFields]], and [[LocalEMFields]] by scalars module procedure sp_multiply , ps_multiply , lps_multiply , slp_multiply , & sf_multiply , fs_multiply , lfs_multiply , slf_multiply end interface interface operator ( / ) !+ Allows for dividing [[Profiles]],[[LocalProfiles]], !+ [[EMFields]], and [[LocalEMFields]] by scalars module procedure ps_divide , lps_divide , fs_divide , lfs_divide end interface interface interpol_coeff !+ Calculates linear interpolation coefficients module procedure interpol1D_coeff , interpol1D_coeff_arr module procedure interpol2D_coeff , interpol2D_coeff_arr end interface interface interpol !+ Performs linear/bilinear interpolation module procedure interpol1D_arr module procedure interpol2D_arr , interpol2D_2D_arr end interface !! definition of the structures: type ( BeamGrid ), save :: beam_grid !+ Variable containing beam grid definition type ( InterpolationGrid ), save :: inter_grid !+ Variable containing interpolation grid definition type ( FastIonDistribution ), save :: fbm !+ Variable containing the fast-ion distribution function type ( FastIonParticles ), save :: particles !+ Variable containing a MC fast-ion distribution type ( Equilibrium ), save :: equil !+ Variable containing the plasma parameters and fields type ( NeutralBeam ), save :: nbi !+ Variable containing the neutral beam geometry and settings type ( AtomicTables ), save :: tables !+ Variable containing the atomic tables type ( NPAResults ), save :: npa !+ Variable for storing the calculated NPA results type ( SpectralChords ), save :: spec_chords !+ Variable containing the spectral system definition type ( NPAChords ), save :: npa_chords !+ Variable containing the NPA system definition type ( SimulationInputs ), save :: inputs !+ Variable containing the simulation inputs type ( BirthProfile ), save :: birth !+ Variable for storing the calculated birth profile type ( NeutralDensity ), save :: neut !+ Variable for storing the calculated beam density type ( Spectra ), save :: spec !+ Variable for storing the calculated spectra type ( NeutronRate ), save :: neutron !+ Variable for storing the neutron rate type ( FIDAWeights ), save :: fweight !+ Variable for storing the calculated FIDA weights type ( NPAWeights ), save :: nweight !+ Variable for storing the calculated NPA weights contains subroutine print_banner () !+ Prints FIDASIM banner write ( * , '(a)' ) \"   ____ ____ ___   ___    ____ ____ __  ___\" write ( * , '(a)' ) \"  / __//  _// _ \\ / _ |  / __//  _//  |/  /\" write ( * , '(a)' ) \" / _/ _/ / / // // __ | _\\ \\ _/ / / /|_/ / \" write ( * , '(a)' ) \"/_/  /___//____//_/ |_|/___//___//_/  /_/  \" write ( * , '(a)' ) \"                                           \" if ( version . ne . \"\" ) then write ( * , '(a,a)' ) \"Version: \" , trim ( version ) endif write ( * , '(a)' ) \"\" write ( * , '(a)' ) \"FIDASIM is released as open source code under the MIT Licence.\" write ( * , '(a)' ) \"For more information visit http://d3denergetic.github.io/FIDASIM/\" write ( * , '(a)' ) \"\" #ifdef _DEBUG write ( * , '(a)' ) \"########################### ATTENTION ###########################\" write ( * , '(a)' ) \"# Running in debug mode. All optimizations have been turned off #\" write ( * , '(a)' ) \"#################################################################\" write ( * , '(a)' ) \"\" #endif #ifdef _PROF write ( * , '(a)' ) \"########################### ATTENTION ###########################\" write ( * , '(a)' ) \"#                   Running in profiling mode                   #\" write ( * , '(a)' ) \"#################################################################\" write ( * , '(a)' ) \"\" #endif #ifdef _OMP #else write ( * , '(a)' ) \"########################### ATTENTION ###########################\" write ( * , '(a)' ) \"#              OpenMP threading has been disabled               #\" write ( * , '(a)' ) \"#################################################################\" write ( * , '(a)' ) \"\" #endif end subroutine print_banner !============================================================================ !---------------------------Operator Overloading----------------------------- !============================================================================ subroutine fast_ion_assign ( p1 , p2 ) !+ Defines how to assign [[FastIon]] types to eachother type ( FastIon ), intent ( in ) :: p2 type ( FastIon ), intent ( out ) :: p1 p1 % cross_grid = p2 % cross_grid p1 % r = p2 % r p1 % z = p2 % z p1 % phi_enter = p2 % phi_enter p1 % delta_phi = p2 % delta_phi p1 % energy = p2 % energy p1 % pitch = p2 % pitch p1 % vabs = p2 % vabs p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % weight = p2 % weight p1 % class = p2 % class end subroutine fast_ion_assign subroutine npa_part_assign ( p1 , p2 ) !+ Defines how to assign [[NPAParticle]] types to eachother type ( NPAParticle ), intent ( in ) :: p2 type ( NPAParticle ), intent ( out ) :: p1 p1 % xi = p2 % xi p1 % yi = p2 % yi p1 % zi = p2 % zi p1 % xf = p2 % xf p1 % yf = p2 % yf p1 % zf = p2 % zf p1 % weight = p2 % weight p1 % energy = p2 % energy p1 % pitch = p2 % pitch p1 % detector = p2 % detector end subroutine npa_part_assign subroutine pp_assign ( p1 , p2 ) !+ Defines how to assign [[Profiles]] types to eachother type ( Profiles ), intent ( in ) :: p2 type ( Profiles ), intent ( inout ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz end subroutine pp_assign subroutine lpp_assign ( p1 , p2 ) !+ Defines how to assign a [[Profiles]] type to a [[LocalProfiles]] type type ( Profiles ), intent ( in ) :: p2 type ( LocalProfiles ), intent ( inout ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz end subroutine lpp_assign subroutine plp_assign ( p1 , p2 ) !+ Defines how to assign a [[LocalProfiles]] type to a [[Profiles]] type type ( LocalProfiles ), intent ( in ) :: p2 type ( Profiles ), intent ( inout ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz end subroutine plp_assign subroutine lplp_assign ( p1 , p2 ) !+ Defines how to assign [[LocalProfiles]] types to eachother type ( LocalProfiles ), intent ( in ) :: p2 type ( LocalProfiles ), intent ( inout ) :: p1 p1 % pos = p2 % pos p1 % uvw = p2 % uvw p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % vrot = p2 % vrot end subroutine lplp_assign subroutine ff_assign ( p1 , p2 ) !+ Defines how to assign [[EMFields]] types to eachother type ( EMFields ), intent ( in ) :: p2 type ( EMFields ), intent ( inout ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine ff_assign subroutine lff_assign ( p1 , p2 ) !+ Defines how to assign a [[EMFields]] type to a [[LocalEMFields]] type type ( EMFields ), intent ( in ) :: p2 type ( LocalEMFields ), intent ( inout ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine lff_assign subroutine flf_assign ( p1 , p2 ) !+ Defines how to assign a [[LocalEMFields]] type to a [[EMFields]] type type ( LocalEMFields ), intent ( in ) :: p2 type ( EMFields ), intent ( inout ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine flf_assign subroutine lflf_assign ( p1 , p2 ) !+ Defines how to assign [[LocalEMFields]] types to eachother type ( LocalEMFields ), intent ( in ) :: p2 type ( LocalEMFields ), intent ( inout ) :: p1 p1 % pos = p2 % pos p1 % uvw = p2 % uvw p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % b_abs = p2 % b_abs p1 % e_abs = p2 % e_abs p1 % a_norm = p2 % a_norm p1 % b_norm = p2 % b_norm p1 % c_norm = p2 % c_norm p1 % e_norm = p2 % e_norm p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine lflf_assign function pp_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[Profiles]] types type ( Profiles ), intent ( in ) :: p1 , p2 type ( Profiles ) :: p3 p3 % dene = p1 % dene + p2 % dene p3 % ti = p1 % ti + p2 % ti p3 % te = p1 % te + p2 % te p3 % denp = p1 % denp + p2 % denp p3 % denf = p1 % denf + p2 % denf p3 % denimp = p1 % denimp + p2 % denimp p3 % zeff = p1 % zeff + p2 % zeff p3 % vr = p1 % vr + p2 % vr p3 % vt = p1 % vt + p2 % vt p3 % vz = p1 % vz + p2 % vz end function pp_add function pp_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[Profiles]] types type ( Profiles ), intent ( in ) :: p1 , p2 type ( Profiles ) :: p3 p3 % dene = p1 % dene - p2 % dene p3 % ti = p1 % ti - p2 % ti p3 % te = p1 % te - p2 % te p3 % denp = p1 % denp - p2 % denp p3 % denf = p1 % denf - p2 % denf p3 % denimp = p1 % denimp - p2 % denimp p3 % zeff = p1 % zeff - p2 % zeff p3 % vr = p1 % vr - p2 % vr p3 % vt = p1 % vt - p2 % vt p3 % vz = p1 % vz - p2 % vz end function pp_subtract function lplp_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[LocalProfiles]] types type ( LocalProfiles ), intent ( in ) :: p1 , p2 type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos + p2 % pos p3 % uvw = p1 % uvw + p2 % uvw p3 % dene = p1 % dene + p2 % dene p3 % ti = p1 % ti + p2 % ti p3 % te = p1 % te + p2 % te p3 % denp = p1 % denp + p2 % denp p3 % denf = p1 % denf + p2 % denf p3 % denimp = p1 % denimp + p2 % denimp p3 % zeff = p1 % zeff + p2 % zeff p3 % vr = p1 % vr + p2 % vr p3 % vt = p1 % vt + p2 % vt p3 % vz = p1 % vz + p2 % vz p3 % vrot = p1 % vrot + p2 % vrot end function lplp_add function lplp_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[LocalProfiles]] types type ( LocalProfiles ), intent ( in ) :: p1 , p2 type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos - p2 % pos p3 % uvw = p1 % uvw - p2 % uvw p3 % dene = p1 % dene - p2 % dene p3 % ti = p1 % ti - p2 % ti p3 % te = p1 % te - p2 % te p3 % denp = p1 % denp - p2 % denp p3 % denf = p1 % denf - p2 % denf p3 % denimp = p1 % denimp - p2 % denimp p3 % zeff = p1 % zeff - p2 % zeff p3 % vr = p1 % vr - p2 % vr p3 % vt = p1 % vt - p2 % vt p3 % vz = p1 % vz - p2 % vz p3 % vrot = p1 % vrot - p2 % vrot end function lplp_subtract function ps_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[Profiles]] types by a scalar type ( Profiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 % dene = p1 % dene * real_scalar p3 % ti = p1 % ti * real_scalar p3 % te = p1 % te * real_scalar p3 % denp = p1 % denp * real_scalar p3 % denf = p1 % denf * real_scalar p3 % denimp = p1 % denimp * real_scalar p3 % zeff = p1 % zeff * real_scalar p3 % vr = p1 % vr * real_scalar p3 % vt = p1 % vt * real_scalar p3 % vz = p1 % vz * real_scalar end function ps_multiply function sp_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[Profiles]] types by a scalar type ( Profiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 = p1 * real_scalar end function sp_multiply function ps_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[Profiles]] types by a scalar type ( Profiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function ps_divide function lps_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[LocalProfiles]] types by a scalar type ( LocalProfiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos * real_scalar p3 % uvw = p1 % uvw * real_scalar p3 % dene = p1 % dene * real_scalar p3 % ti = p1 % ti * real_scalar p3 % te = p1 % te * real_scalar p3 % denp = p1 % denp * real_scalar p3 % denf = p1 % denf * real_scalar p3 % denimp = p1 % denimp * real_scalar p3 % zeff = p1 % zeff * real_scalar p3 % vr = p1 % vr * real_scalar p3 % vt = p1 % vt * real_scalar p3 % vz = p1 % vz * real_scalar p3 % vrot = p1 % vrot * real_scalar end function lps_multiply function slp_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[LocalProfiles]] types by a scalar type ( LocalProfiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 = p1 * real_scalar end function slp_multiply function lps_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[LocalProfiles]] types by a scalar type ( LocalProfiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function lps_divide function ff_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[EMFields]] types type ( EMFields ), intent ( in ) :: p1 , p2 type ( EMFields ) :: p3 p3 % br = p1 % br + p2 % br p3 % bt = p1 % bt + p2 % bt p3 % bz = p1 % bz + p2 % bz p3 % er = p1 % er + p2 % er p3 % et = p1 % et + p2 % et p3 % ez = p1 % ez + p2 % ez p3 % dbr_dr = p1 % dbr_dr + p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz + p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr + p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz + p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr + p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz + p2 % dbz_dz end function ff_add function ff_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[EMFields]] types type ( EMFields ), intent ( in ) :: p1 , p2 type ( EMFields ) :: p3 p3 % br = p1 % br - p2 % br p3 % bt = p1 % bt - p2 % bt p3 % bz = p1 % bz - p2 % bz p3 % er = p1 % er - p2 % er p3 % et = p1 % et - p2 % et p3 % ez = p1 % ez - p2 % ez p3 % dbr_dr = p1 % dbr_dr - p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz - p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr - p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz - p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr - p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz - p2 % dbz_dz end function ff_subtract function fs_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[EMFields]] types by a scalar type ( EMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 % br = p1 % br * real_scalar p3 % bt = p1 % bt * real_scalar p3 % bz = p1 % bz * real_scalar p3 % er = p1 % er * real_scalar p3 % et = p1 % et * real_scalar p3 % ez = p1 % ez * real_scalar p3 % dbr_dr = p1 % dbr_dr * real_scalar p3 % dbr_dz = p1 % dbr_dz * real_scalar p3 % dbt_dr = p1 % dbt_dr * real_scalar p3 % dbt_dz = p1 % dbt_dz * real_scalar p3 % dbz_dr = p1 % dbz_dr * real_scalar p3 % dbz_dz = p1 % dbz_dz * real_scalar end function fs_multiply function sf_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[EMFields]] types by a scalar type ( EMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 = p1 * real_scalar end function sf_multiply function fs_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[EMFields]] types by a scalar type ( EMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function fs_divide function lflf_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[LocalEMFields]] types type ( LocalEMFields ), intent ( in ) :: p1 , p2 type ( LocalEMFields ) :: p3 real ( Float64 ), dimension ( 3 ) :: bfield , efield p3 % pos = p1 % pos + p2 % pos p3 % uvw = p1 % uvw + p2 % uvw p3 % br = p1 % br + p2 % br p3 % bt = p1 % bt + p2 % bt p3 % bz = p1 % bz + p2 % bz p3 % er = p1 % er + p2 % er p3 % et = p1 % et + p2 % et p3 % ez = p1 % ez + p2 % ez bfield = p1 % b_abs * p1 % b_norm + p2 % b_abs * p2 % b_norm p3 % b_abs = norm2 ( bfield ) if ( p3 % b_abs . gt . 0.d0 ) then p3 % b_norm = bfield / p3 % b_abs call calc_perp_vectors ( p3 % b_norm , p3 % a_norm , p3 % c_norm ) endif efield = p1 % e_abs * p1 % e_norm + p2 % e_abs * p2 % e_norm p3 % e_abs = norm2 ( efield ) if ( p3 % e_abs . gt . 0.d0 ) p3 % e_norm = efield / p3 % e_abs p3 % dbr_dr = p1 % dbr_dr + p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz + p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr + p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz + p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr + p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz + p2 % dbz_dz end function lflf_add function lflf_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[LocalEMFields]] types type ( LocalEMFields ), intent ( in ) :: p1 , p2 type ( LocalEMFields ) :: p3 real ( Float64 ), dimension ( 3 ) :: bfield , efield p3 % pos = p1 % pos - p2 % pos p3 % uvw = p1 % uvw - p2 % uvw p3 % br = p1 % br - p2 % br p3 % bt = p1 % bt - p2 % bt p3 % bz = p1 % bz - p2 % bz p3 % er = p1 % er - p2 % er p3 % et = p1 % et - p2 % et p3 % ez = p1 % ez - p2 % ez bfield = p1 % b_abs * p1 % b_norm - p2 % b_abs * p2 % b_norm p3 % b_abs = norm2 ( bfield ) if ( p3 % b_abs . gt . 0.d0 ) then p3 % b_norm = bfield / p3 % b_abs call calc_perp_vectors ( p3 % b_norm , p3 % a_norm , p3 % c_norm ) endif efield = p1 % e_abs * p1 % e_norm - p2 % e_abs * p2 % e_norm p3 % e_abs = norm2 ( efield ) if ( p3 % e_abs . gt . 0.d0 ) p3 % e_norm = efield / p3 % e_abs p3 % dbr_dr = p1 % dbr_dr - p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz - p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr - p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz - p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr - p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz - p2 % dbz_dz end function lflf_subtract function lfs_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[LocalEMFields]] types by a scalar type ( LocalEMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 % pos = p1 % pos * real_scalar p3 % uvw = p1 % uvw * real_scalar p3 % br = p1 % br * real_scalar p3 % bt = p1 % bt * real_scalar p3 % bz = p1 % bz * real_scalar p3 % er = p1 % er * real_scalar p3 % et = p1 % et * real_scalar p3 % ez = p1 % ez * real_scalar p3 % b_abs = p1 % b_abs * real_scalar p3 % e_abs = p1 % e_abs * real_scalar p3 % a_norm = p1 % a_norm p3 % b_norm = p1 % b_norm p3 % c_norm = p1 % c_norm p3 % e_norm = p1 % e_norm p3 % dbr_dr = p1 % dbr_dr * real_scalar p3 % dbr_dz = p1 % dbr_dz * real_scalar p3 % dbt_dr = p1 % dbt_dr * real_scalar p3 % dbt_dz = p1 % dbt_dz * real_scalar p3 % dbz_dr = p1 % dbz_dr * real_scalar p3 % dbz_dz = p1 % dbz_dz * real_scalar end function lfs_multiply function slf_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[LocalEMFields]] types by a scalar type ( LocalEMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 = p1 * real_scalar end function slf_multiply function lfs_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[LocalEMFields]] types by a scalar type ( LocalEMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function lfs_divide !============================================================================ !-------------------------------I/O Routines--------------------------------- !============================================================================ subroutine read_inputs !+ Reads input namelist file and stores the results into [[libfida:inputs]], !+ [[libfida:nbi]], and [[libfida:beam_grid]] character ( charlim ) :: runid , result_dir , tables_file character ( charlim ) :: distribution_file , equilibrium_file character ( charlim ) :: geometry_file , neutrals_file integer :: pathlen , calc_neutron integer :: calc_brems , calc_bes , calc_fida , calc_npa integer :: calc_birth , calc_fida_wght , calc_npa_wght integer :: load_neutrals , verbose , dump_dcx , no_flr integer ( Int64 ) :: n_fida , n_npa , n_nbi , n_halo , n_dcx , n_birth integer ( Int32 ) :: shot , nlambda , ne_wght , np_wght , nphi_wght , nlambda_wght real ( Float64 ) :: time , lambdamin , lambdamax , emax_wght real ( Float64 ) :: lambdamin_wght , lambdamax_wght real ( Float64 ) :: ai , ab , pinj , einj , current_fractions ( 3 ) integer ( Int32 ) :: impurity_charge integer ( Int32 ) :: nx , ny , nz real ( Float64 ) :: xmin , xmax , ymin , ymax , zmin , zmax real ( Float64 ) :: alpha , beta , gamma , origin ( 3 ) logical :: exis , error NAMELIST / fidasim_inputs / result_dir , tables_file , distribution_file , & geometry_file , equilibrium_file , neutrals_file , shot , time , runid , & calc_brems , calc_bes , calc_fida , calc_npa , calc_birth , no_flr , & calc_fida_wght , calc_npa_wght , load_neutrals , dump_dcx , verbose , & calc_neutron , n_fida , n_npa , n_nbi , n_halo , n_dcx , n_birth , & ab , pinj , einj , current_fractions , ai , impurity_charge , & nx , ny , nz , xmin , xmax , ymin , ymax , zmin , zmax , & origin , alpha , beta , gamma , & ne_wght , np_wght , nphi_wght , & nlambda , lambdamin , lambdamax , emax_wght , & nlambda_wght , lambdamin_wght , lambdamax_wght inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'READ_INPUTS: Input file does not exist: ' , trim ( namelist_file ) stop endif !!Set Defaults TODO: remove at next major release no_flr = 0 calc_neutron = 0 open ( 13 , file = namelist_file ) read ( 13 , NML = fidasim_inputs ) close ( 13 ) !!General Information inputs % shot_number = shot inputs % time = time inputs % runid = runid inputs % result_dir = result_dir !!Input Files inputs % tables_file = tables_file inputs % geometry_file = geometry_file inputs % equilibrium_file = equilibrium_file inputs % distribution_file = distribution_file inputs % neutrals_file = neutrals_file !!Simulation Switches if (( calc_brems + calc_bes + calc_fida ). gt . 0 ) then inputs % calc_spec = 1 else inputs % calc_spec = 0 endif inputs % calc_brems = calc_brems inputs % calc_bes = calc_bes inputs % calc_fida = calc_fida inputs % calc_npa = calc_npa inputs % calc_birth = calc_birth inputs % calc_fida_wght = calc_fida_wght inputs % calc_npa_wght = calc_npa_wght inputs % calc_neutron = calc_neutron inputs % load_neutrals = load_neutrals inputs % dump_dcx = dump_dcx inputs % verbose = verbose inputs % no_flr = no_flr !!Monte Carlo Settings inputs % n_fida = max ( 10 , n_fida ) inputs % n_npa = max ( 10 , n_npa ) inputs % n_nbi = max ( 10 , n_nbi ) inputs % n_halo = max ( 10 , n_halo ) inputs % n_dcx = max ( 10 , n_dcx ) inputs % n_birth = max ( 1 , nint ( n_birth / real ( n_nbi ))) !!Plasma Settings inputs % ai = ai inputs % impurity_charge = impurity_charge !!Neutral Beam Settings inputs % ab = ab nbi % current_fractions = current_fractions nbi % einj = einj nbi % pinj = pinj !!Weight Function Settings inputs % ne_wght = ne_wght inputs % np_wght = np_wght inputs % nphi_wght = nphi_wght inputs % emax_wght = emax_wght inputs % nlambda_wght = nlambda_wght inputs % lambdamin_wght = lambdamin_wght inputs % lambdamax_wght = lambdamax_wght !!Wavelength Grid Settings inputs % nlambda = nlambda inputs % lambdamin = lambdamin inputs % lambdamax = lambdamax inputs % dlambda = ( inputs % lambdamax - inputs % lambdamin ) / inputs % nlambda !!Beam Grid Settings beam_grid % nx = nx beam_grid % ny = ny beam_grid % nz = nz beam_grid % xmin = xmin beam_grid % xmax = xmax beam_grid % ymin = ymin beam_grid % ymax = ymax beam_grid % zmin = zmin beam_grid % zmax = zmax beam_grid % alpha = alpha beam_grid % beta = beta beam_grid % gamma = gamma beam_grid % origin = origin if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Shot settings ----\" write ( * , '(T2,\"Shot: \",i8)' ) inputs % shot_number write ( * , '(T2,\"Time: \",i4,\" [ms]\")' ) int ( inputs % time * 1.d3 ) write ( * , '(T2,\"Runid: \",a)' ) trim ( adjustl ( inputs % runid )) write ( * , * ) '' write ( * , '(a)' ) \"---- Input files ----\" endif error = . False . inquire ( file = inputs % tables_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Tables file: \",a)' ) trim ( inputs % tables_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Tables file does not exist: ' , & trim ( inputs % tables_file ) endif error = . True . endif inquire ( file = inputs % geometry_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Geometry file: \",a)' ) trim ( inputs % geometry_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Geometry file does not exist: ' , & trim ( inputs % geometry_file ) endif error = . True . endif inquire ( file = inputs % equilibrium_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Equilibrium file: \",a)' ) trim ( inputs % equilibrium_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Equilibrium file does not exist: ' , & trim ( inputs % equilibrium_file ) endif error = . True . endif inquire ( file = inputs % distribution_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Distribution file: \",a)' ) trim ( inputs % distribution_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Distribution file does not exist: ' , & trim ( inputs % distribution_file ) endif error = . True . endif pathlen = len_trim ( inputs % result_dir ) + len_trim ( inputs % runid ) + 20 !+20 for suffixes and seperators e.g. /, _npa.h5, ... if ( pathlen . gt . charlim ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,i3,a,i3)' ) 'READ_INPUTS: Result directory path + runID use too many characters: ' , & pathlen - 20 , '>' , charlim - 20 endif error = . True . endif if ( inputs % verbose . ge . 1 ) then write ( * , * ) '' endif if ( error ) then stop endif end subroutine read_inputs subroutine make_beam_grid !+ Makes [[libfida:beam_grid] from user defined inputs integer ( Int32 ) :: i real ( Float64 ) :: dx , dy , dz allocate ( beam_grid % xc ( beam_grid % nx ), & beam_grid % yc ( beam_grid % ny ), & beam_grid % zc ( beam_grid % nz )) dx = ( beam_grid % xmax - beam_grid % xmin ) / beam_grid % nx dy = ( beam_grid % ymax - beam_grid % ymin ) / beam_grid % ny dz = ( beam_grid % zmax - beam_grid % zmin ) / beam_grid % nz do i = 1 , beam_grid % nx beam_grid % xc ( i ) = beam_grid % xmin + ( i - 0.5 ) * dx enddo do i = 1 , beam_grid % ny beam_grid % yc ( i ) = beam_grid % ymin + ( i - 0.5 ) * dy enddo do i = 1 , beam_grid % nz beam_grid % zc ( i ) = beam_grid % zmin + ( i - 0.5 ) * dz enddo beam_grid % dr ( 1 ) = abs ( beam_grid % xc ( 2 ) - beam_grid % xc ( 1 )) beam_grid % dr ( 2 ) = abs ( beam_grid % yc ( 2 ) - beam_grid % yc ( 1 )) beam_grid % dr ( 3 ) = abs ( beam_grid % zc ( 2 ) - beam_grid % zc ( 1 )) beam_grid % lwh ( 1 ) = abs ( beam_grid % xc ( beam_grid % nx ) - beam_grid % xc ( 1 )) + beam_grid % dr ( 1 ) beam_grid % lwh ( 2 ) = abs ( beam_grid % yc ( beam_grid % ny ) - beam_grid % yc ( 1 )) + beam_grid % dr ( 2 ) beam_grid % lwh ( 3 ) = abs ( beam_grid % zc ( beam_grid % nz ) - beam_grid % zc ( 1 )) + beam_grid % dr ( 3 ) beam_grid % volume = beam_grid % lwh ( 1 ) * beam_grid % lwh ( 2 ) * beam_grid % lwh ( 3 ) beam_grid % center ( 1 ) = ( minval ( beam_grid % xc ) - 0.5 * beam_grid % dr ( 1 )) + 0.5 * beam_grid % lwh ( 1 ) beam_grid % center ( 2 ) = ( minval ( beam_grid % yc ) - 0.5 * beam_grid % dr ( 2 )) + 0.5 * beam_grid % lwh ( 2 ) beam_grid % center ( 3 ) = ( minval ( beam_grid % zc ) - 0.5 * beam_grid % dr ( 3 )) + 0.5 * beam_grid % lwh ( 3 ) beam_grid % drmin = minval ( beam_grid % dr ) beam_grid % dv = beam_grid % dr ( 1 ) * beam_grid % dr ( 2 ) * beam_grid % dr ( 3 ) beam_grid % ntrack = beam_grid % nx + beam_grid % ny + beam_grid % nz beam_grid % ngrid = beam_grid % nx * beam_grid % ny * beam_grid % nz call tb_zyx ( beam_grid % alpha , beam_grid % beta , beam_grid % gamma , & beam_grid % basis , beam_grid % inv_basis ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Beam grid settings ----\" write ( * , '(T2,\"Nx: \", i3)' ) beam_grid % nx write ( * , '(T2,\"Ny: \", i3)' ) beam_grid % ny write ( * , '(T2,\"Nz: \", i3)' ) beam_grid % nz write ( * , '(T2,\"dV: \", f5.2,\" [cm&#94;3]\")' ) beam_grid % dv write ( * , '(T2,\"alpha: \",f5.2,\" [rad]\")' ) beam_grid % alpha write ( * , '(T2,\"beta:  \",f5.2,\" [rad]\")' ) beam_grid % beta write ( * , '(T2,\"gamma: \",f5.2,\" [rad]\")' ) beam_grid % gamma write ( * , '(T2,\"origin: [\",f7.2,\",\",f7.2,\",\",f7.2,\"] [cm]\")' ) beam_grid % origin write ( * , * ) '' endif end subroutine make_beam_grid subroutine read_beam !+ Reads neutral beam geometry and stores the quantities in [[libfida:nbi]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 1 ) :: dims real ( Float64 ), dimension ( 3 ) :: uvw_src , uvw_axis , pos real ( Float64 ) :: dis logical :: path_valid integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDONLY_F , fid , error ) !!Open NBI group call h5gopen_f ( fid , \"/nbi\" , gid , error ) !!Read in beam definitions call h5ltread_dataset_string_f ( gid , \"/nbi/name\" , nbi % name , error ) dims ( 1 ) = 3 call h5ltread_dataset_double_f ( gid , \"/nbi/src\" , uvw_src , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/axis\" , uvw_axis , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/divy\" , nbi % divy , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/divz\" , nbi % divz , dims , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/nbi/shape\" , nbi % shape , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/focy\" , nbi % focy , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/focz\" , nbi % focz , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/widy\" , nbi % widy , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/widz\" , nbi % widz , error ) !!Read in aperture definitions !! Check for naperture for compatibility with old runs call h5ltpath_valid_f ( gid , \"/nbi/naperture\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltread_dataset_int_scalar_f ( gid , \"/nbi/naperture\" , nbi % naperture , error ) else nbi % naperture = 0 endif if ( nbi % naperture . gt . 0 ) then allocate ( nbi % ashape ( nbi % naperture ), nbi % adist ( nbi % naperture ), & nbi % awidy ( nbi % naperture ), nbi % awidz ( nbi % naperture ), & nbi % aoffy ( nbi % naperture ), nbi % aoffz ( nbi % naperture ) ) dims ( 1 ) = nbi % naperture call h5ltread_dataset_int_f ( gid , \"/nbi/ashape\" , nbi % ashape , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/awidy\" , nbi % awidy , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/awidz\" , nbi % awidz , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/aoffy\" , nbi % aoffy , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/aoffz\" , nbi % aoffz , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/adist\" , nbi % adist , dims , error ) endif !!Close NBI group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) !!Convert to beam grid coordinates call uvw_to_xyz ( uvw_src , nbi % src ) nbi % axis = matmul ( beam_grid % inv_basis , uvw_axis ) nbi % vinj = sqrt ( 2.d0 * nbi % einj * 1.d3 * e0 / ( inputs % ab * mass_u )) * 1.d2 !! [cm/s] pos = nbi % src + 20 0.0 * nbi % axis dis = sqrt ( sum (( pos - nbi % src ) ** 2 )) nbi % beta = asin (( nbi % src ( 3 ) - pos ( 3 )) / dis ) nbi % alpha = atan2 ( pos ( 2 ) - nbi % src ( 2 ), pos ( 1 ) - nbi % src ( 1 )) call tb_zyx ( nbi % alpha , nbi % beta , 0.d0 , nbi % basis , nbi % inv_basis ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Neutral beam settings ----' write ( * , '(T2,\"Beam: \",a)' ) nbi % name write ( * , '(T2,\"Power:   \",f5.2,\" [MW]\")' ) nbi % pinj write ( * , '(T2,\"Voltage: \",f6.2,\" [keV]\")' ) nbi % einj write ( * , * ) '' endif end subroutine read_beam subroutine read_chords !+ Reads the spectral geometry and stores the quantities in [[libfida:spec_chords]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 2 ) :: dims logical :: path_valid real ( Float64 ), dimension (:,:), allocatable :: lenses real ( Float64 ), dimension (:,:), allocatable :: axes real ( Float64 ), dimension (:,:,:), allocatable :: dlength real ( Float64 ), dimension (:), allocatable :: spot_size , sigma_pi type ( LOSElement ), dimension (:), allocatable :: los_elem real ( Float64 ) :: r0 ( 3 ), v0 ( 3 ), r_enter ( 3 ), r_exit ( 3 ) real ( Float64 ) :: xyz_lens ( 3 ), xyz_axis ( 3 ), length real ( Float64 ), dimension ( 3 , 3 ) :: basis real ( Float64 ), dimension ( 2 ) :: randomu real ( Float64 ) :: theta , sqrt_rho type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks character ( len = 20 ) :: system = '' integer :: i , j , ic , nc , ncell , ind ( 3 ), ii , jj , kk integer :: error if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- FIDA/BES settings ----' endif !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDONLY_F , fid , error ) !!Check if SPEC group exists call h5ltpath_valid_f ( fid , \"/spec\" , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'FIDA/BES geometry is not in the geometry file' write ( * , '(a)' ) 'Continuing without spectral diagnostics' endif inputs % calc_spec = 0 inputs % calc_fida = 0 inputs % calc_bes = 0 inputs % calc_brems = 0 inputs % calc_fida_wght = 0 call h5fclose_f ( fid , error ) call h5close_f ( error ) return endif !!Open SPEC group call h5gopen_f ( fid , \"/spec\" , gid , error ) call h5ltread_dataset_string_f ( gid , \"/spec/system\" , system , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/spec/nchan\" , spec_chords % nchan , error ) allocate ( lenses ( 3 , spec_chords % nchan )) allocate ( axes ( 3 , spec_chords % nchan )) allocate ( spot_size ( spec_chords % nchan )) allocate ( sigma_pi ( spec_chords % nchan )) allocate ( spec_chords % los ( spec_chords % nchan )) allocate ( spec_chords % radius ( spec_chords % nchan )) allocate ( dlength ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz ) ) dims = [ 3 , spec_chords % nchan ] call h5ltread_dataset_double_f ( gid , \"/spec/lens\" , lenses , dims , error ) call h5ltread_dataset_double_f ( gid , \"/spec/axis\" , axes , dims , error ) call h5ltread_dataset_double_f ( gid , \"/spec/spot_size\" , spot_size , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/spec/sigma_pi\" , sigma_pi , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/spec/radius\" , spec_chords % radius , dims ( 2 : 2 ), error ) !!Close SPEC group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) chan_loop : do i = 1 , spec_chords % nchan call uvw_to_xyz ( lenses (:, i ), xyz_lens ) xyz_axis = matmul ( beam_grid % inv_basis , axes (:, i )) spec_chords % los ( i )% lens = xyz_lens spec_chords % los ( i )% axis = xyz_axis spec_chords % los ( i )% sigma_pi = sigma_pi ( i ) spec_chords % los ( i )% spot_size = spot_size ( i ) r0 = xyz_lens v0 = xyz_axis v0 = v0 / norm2 ( v0 ) call line_basis ( r0 , v0 , basis ) call grid_intersect ( r0 , v0 , length , r_enter , r_exit ) if ( length . le . 0.d0 ) then if ( inputs % verbose . ge . 0 ) then WRITE ( * , '(\"Channel \",i5,\" missed the beam grid\")' ), i endif cycle chan_loop endif if ( spot_size ( i ). le . 0.d0 ) then nc = 1 else nc = 100 endif dlength = 0.d0 !$OMP PARALLEL DO schedule(guided) private(ic,randomu,sqrt_rho,theta,r0, & !$OMP& length, r_enter, r_exit, j, tracks, ncell, ind) do ic = 1 , nc ! Uniformally sample within spot size call randu ( randomu ) sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) r0 ( 1 ) = 0.d0 r0 ( 2 ) = spot_size ( i ) * sqrt_rho * cos ( theta ) r0 ( 3 ) = spot_size ( i ) * sqrt_rho * sin ( theta ) r0 = matmul ( basis , r0 ) + xyz_lens call grid_intersect ( r0 , v0 , length , r_enter , r_exit ) call track ( r_enter , v0 , tracks , ncell ) track_loop : do j = 1 , ncell ind = tracks ( j )% ind !inds can repeat so add rather than assign !$OMP CRITICAL(read_chords_1) dlength ( ind ( 1 ), ind ( 2 ), ind ( 3 )) = & dlength ( ind ( 1 ), ind ( 2 ), ind ( 3 )) + tracks ( j )% time / real ( nc ) !time == distance !$OMP END CRITICAL(read_chords_1) enddo track_loop enddo !$OMP END PARALLEL DO do kk = 1 , beam_grid % nz do jj = 1 , beam_grid % ny xloop : do ii = 1 , beam_grid % nx if ( dlength ( ii , jj , kk ). ne . 0.d0 ) then nc = spec_chords % inter ( ii , jj , kk )% nchan + 1 if ( nc . eq . 1 ) then allocate ( spec_chords % inter ( ii , jj , kk )% los_elem ( nc )) spec_chords % inter ( ii , jj , kk )% los_elem ( nc ) = LOSElement ( i , dlength ( ii , jj , kk )) else allocate ( los_elem ( nc )) los_elem ( 1 :( nc - 1 )) = spec_chords % inter ( ii , jj , kk )% los_elem los_elem ( nc ) = LOSElement ( i , dlength ( ii , jj , kk )) deallocate ( spec_chords % inter ( ii , jj , kk )% los_elem ) call move_alloc ( los_elem , spec_chords % inter ( ii , jj , kk )% los_elem ) endif spec_chords % inter ( ii , jj , kk )% nchan = nc endif enddo xloop enddo enddo enddo chan_loop if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"FIDA/BES System: \",a)' ) trim ( adjustl ( system )) write ( * , '(T2,\"Number of channels: \",i5)' ) spec_chords % nchan write ( * , * ) '' endif deallocate ( lenses , axes , spot_size , sigma_pi ) end subroutine read_chords subroutine read_npa !+ Reads the NPA geometry and stores the quantities in [[libfida:npa_chords]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 2 ) :: dims logical :: path_valid real ( Float64 ), dimension (:,:), allocatable :: a_tedge , a_redge , a_cent real ( Float64 ), dimension (:,:), allocatable :: d_tedge , d_redge , d_cent integer , dimension (:), allocatable :: a_shape , d_shape character ( len = 20 ) :: system = '' real ( Float64 ), parameter :: inv_4pi = ( 4.d0 * pi ) ** ( - 1 ) real ( Float64 ), dimension ( 3 ) :: xyz_a_tedge , xyz_a_redge , xyz_a_cent real ( Float64 ), dimension ( 3 ) :: xyz_d_tedge , xyz_d_redge , xyz_d_cent real ( Float64 ), dimension ( 3 ) :: eff_rd , rd , rd_d , r0 , r0_d , v0 real ( Float64 ), dimension ( 3 , 3 ) :: basis , inv_basis real ( Float64 ), dimension ( 50 ) :: xd , yd type ( LocalEMFields ) :: fields real ( Float64 ) :: length , total_prob , hh , hw , dprob , dx , dy , r , pitch integer :: ichan , i , j , k , ix , iy , d_index , nd , cnt integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDWR_F , fid , error ) !!Check if NPA group exists call h5ltpath_valid_f ( fid , \"/npa\" , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'NPA geometry is not in the geometry file' write ( * , '(a)' ) 'Continuing without NPA diagnostics' endif inputs % calc_npa = 0 inputs % calc_npa_wght = 0 call h5fclose_f ( fid , error ) call h5close_f ( error ) return endif !!Open NPA group call h5gopen_f ( fid , \"/npa\" , gid , error ) call h5ltread_dataset_string_f ( gid , \"/npa/system\" , system , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/npa/nchan\" , npa_chords % nchan , error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- NPA settings ----\" write ( * , '(T2,\"NPA System: \", a)' ) trim ( adjustl ( system )) write ( * , '(T2,\"Number of channels: \",i3)' ) npa_chords % nchan endif allocate ( a_tedge ( 3 , npa_chords % nchan )) allocate ( a_redge ( 3 , npa_chords % nchan )) allocate ( a_cent ( 3 , npa_chords % nchan )) allocate ( a_shape ( npa_chords % nchan )) allocate ( d_tedge ( 3 , npa_chords % nchan )) allocate ( d_redge ( 3 , npa_chords % nchan )) allocate ( d_cent ( 3 , npa_chords % nchan )) allocate ( d_shape ( npa_chords % nchan )) allocate ( npa_chords % radius ( npa_chords % nchan )) allocate ( npa_chords % det ( npa_chords % nchan )) allocate ( npa_chords % phit ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan ) ) allocate ( npa_chords % hit ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz ) ) npa_chords % hit = . False . dims = [ 3 , spec_chords % nchan ] call h5ltread_dataset_double_f ( gid , \"/npa/radius\" , npa_chords % radius , dims ( 2 : 2 ), error ) call h5ltread_dataset_int_f ( gid , \"/npa/a_shape\" , a_shape , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_tedge\" , a_tedge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_redge\" , a_redge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_cent\" , a_cent , dims , error ) call h5ltread_dataset_int_f ( gid , \"/npa/d_shape\" , d_shape , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_tedge\" , d_tedge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_redge\" , d_redge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_cent\" , d_cent , dims , error ) !!Close NPA group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) ! Define detector/aperture shape npa_chords % det % detector % shape = d_shape npa_chords % det % aperture % shape = a_shape chan_loop : do ichan = 1 , npa_chords % nchan ! Convert to beam grid coordinates call uvw_to_xyz ( a_cent (:, ichan ), xyz_a_cent ) call uvw_to_xyz ( a_redge (:, ichan ), xyz_a_redge ) call uvw_to_xyz ( a_tedge (:, ichan ), xyz_a_tedge ) call uvw_to_xyz ( d_cent (:, ichan ), xyz_d_cent ) call uvw_to_xyz ( d_redge (:, ichan ), xyz_d_redge ) call uvw_to_xyz ( d_tedge (:, ichan ), xyz_d_tedge ) ! Define detector/aperture hh/hw npa_chords % det ( ichan )% detector % hw = norm2 ( xyz_d_redge - xyz_d_cent ) npa_chords % det ( ichan )% aperture % hw = norm2 ( xyz_a_redge - xyz_a_cent ) npa_chords % det ( ichan )% detector % hh = norm2 ( xyz_d_tedge - xyz_d_cent ) npa_chords % det ( ichan )% aperture % hh = norm2 ( xyz_a_tedge - xyz_a_cent ) ! Define detector/aperture origin npa_chords % det ( ichan )% detector % origin = xyz_d_cent npa_chords % det ( ichan )% aperture % origin = xyz_a_cent ! Define detector/aperture basis call plane_basis ( xyz_d_cent , xyz_d_redge , xyz_d_tedge , & npa_chords % det ( ichan )% detector % basis , & npa_chords % det ( ichan )% detector % inv_basis ) call plane_basis ( xyz_a_cent , xyz_a_redge , xyz_a_tedge , & npa_chords % det ( ichan )% aperture % basis , & npa_chords % det ( ichan )% aperture % inv_basis ) v0 = xyz_a_cent - xyz_d_cent v0 = v0 / norm2 ( v0 ) call grid_intersect ( xyz_d_cent , v0 , length , r0 , r0_d ) if ( length . le . 0.0 ) then if ( inputs % verbose . ge . 0 ) then WRITE ( * , '(\"Channel \",i3,\" centerline missed the beam grid\")' ), ichan endif endif if ( inputs % calc_npa_wght . ge . 1 ) then hw = npa_chords % det ( ichan )% detector % hw hh = npa_chords % det ( ichan )% detector % hh nd = size ( xd ) do i = 1 , nd xd ( i ) = - hw + 2 * hw * ( i - 0.5 ) / real ( nd ) yd ( i ) = - hh + 2 * hh * ( i - 0.5 ) / real ( nd ) enddo dx = abs ( xd ( 2 ) - xd ( 1 )) dy = abs ( yd ( 2 ) - yd ( 1 )) basis = npa_chords % det ( ichan )% detector % basis inv_basis = npa_chords % det ( ichan )% detector % inv_basis cnt = 0 ! For each grid point find the probability of hitting the detector given an isotropic source !$OMP PARALLEL DO schedule(guided) collapse(3) private(i,j,k,ix,iy,total_prob,eff_rd,r0,r0_d, & !$OMP& rd_d,rd,d_index,v0,dprob,r,fields) do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx cnt = cnt + 1 total_prob = 0.d0 eff_rd = eff_rd * 0.d0 r0 = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] r0_d = matmul ( inv_basis , r0 - xyz_d_cent ) do ix = 1 , nd do iy = 1 , nd rd_d = [ xd ( ix ), yd ( iy ), 0.d0 ] rd = matmul ( basis , rd_d ) + xyz_d_cent v0 = rd - r0 d_index = 0 call hit_npa_detector ( r0 , v0 , d_index , det = ichan ) if ( d_index . ne . 0 ) then r = norm2 ( rd_d - r0_d ) ** 2 dprob = ( dx * dy ) * inv_4pi * r0_d ( 3 ) / ( r * sqrt ( r )) eff_rd = eff_rd + dprob * rd total_prob = total_prob + dprob endif enddo !yd loop enddo !xd loop if ( total_prob . gt . 0.0 ) then eff_rd = eff_rd / total_prob call get_fields ( fields , pos = r0 ) v0 = ( eff_rd - r0 ) / norm2 ( eff_rd - r0 ) npa_chords % phit ( i , j , k , ichan )% pitch = dot_product ( fields % b_norm , v0 ) npa_chords % phit ( i , j , k , ichan )% p = total_prob npa_chords % phit ( i , j , k , ichan )% dir = v0 npa_chords % phit ( i , j , k , ichan )% eff_rd = eff_rd npa_chords % hit ( i , j , k ) = . True . endif if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(T4,\"Channel: \",i5,\" \",f7.2,\"% completed\",a,$)' ) & ichan , cnt / real ( beam_grid % ngrid ) * 100 , char ( 13 ) endif enddo !x loop enddo !y loop enddo !z loop !$OMP END PARALLEL DO total_prob = sum ( npa_chords % phit (:,:,:, ichan )% p ) if ( total_prob . le . 0.d0 ) then if ( inputs % verbose . ge . 0 ) then WRITE ( * , '(\"Channel \",i3,\" missed the beam grid\")' ), ichan endif cycle chan_loop endif endif enddo chan_loop if ( inputs % verbose . ge . 1 ) write ( * , '(50X,a)' ) \"\" deallocate ( a_shape , a_cent , a_redge , a_tedge ) deallocate ( d_shape , d_cent , d_redge , d_tedge ) end subroutine read_npa subroutine read_equilibrium !+ Reads in the interpolation grid, plasma parameters, and fields !+ and stores the quantities in [[libfida:inter_grid]] and [[libfida:equil]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 2 ) :: dims integer :: impc integer :: error integer , dimension (:,:), allocatable :: p_mask , f_mask integer :: iz , ir !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % equilibrium_file , H5F_ACC_RDONLY_F , fid , error ) !!Open PLASMA group call h5gopen_f ( fid , \"/plasma\" , gid , error ) !!Read in interpolation grid call h5ltread_dataset_int_scalar_f ( gid , \"/plasma/nr\" , inter_grid % nr , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/plasma/nz\" , inter_grid % nz , error ) allocate ( inter_grid % r ( inter_grid % nr ), inter_grid % z ( inter_grid % nz )) allocate ( inter_grid % r2d ( inter_grid % nr , inter_grid % nz )) allocate ( inter_grid % z2d ( inter_grid % nr , inter_grid % nz )) allocate ( p_mask ( inter_grid % nr , inter_grid % nz )) allocate ( f_mask ( inter_grid % nr , inter_grid % nz )) dims = [ inter_grid % nr , inter_grid % nz ] call h5ltread_dataset_double_f ( gid , \"/plasma/r\" , inter_grid % r , dims ( 1 : 1 ), error ) call h5ltread_dataset_double_f ( gid , \"/plasma/z\" , inter_grid % z , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/plasma/r2d\" , inter_grid % r2d , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/z2d\" , inter_grid % z2d , dims , error ) inter_grid % dr = abs ( inter_grid % r ( 2 ) - inter_grid % r ( 1 )) inter_grid % dz = abs ( inter_grid % z ( 2 ) - inter_grid % z ( 1 )) inter_grid % da = inter_grid % dr * inter_grid % dz if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Interpolation grid settings ----' write ( * , '(T2,\"Nr: \",i3)' ) inter_grid % nr write ( * , '(T2,\"Nz: \",i3)' ) inter_grid % nz write ( * , '(T2,\"dA: \", f5.2,\" [cm&#94;2]\")' ) inter_grid % da write ( * , * ) '' endif !!Read in plasma parameters allocate ( equil % plasma ( inter_grid % nr , inter_grid % nz )) call h5ltread_dataset_double_f ( gid , \"/plasma/dene\" , equil % plasma % dene , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/te\" , equil % plasma % te , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/ti\" , equil % plasma % ti , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/zeff\" , equil % plasma % zeff , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vr\" , equil % plasma % vr , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vt\" , equil % plasma % vt , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vz\" , equil % plasma % vz , dims , error ) call h5ltread_dataset_int_f ( gid , \"/plasma/mask\" , p_mask , dims , error ) impc = inputs % impurity_charge where ( equil % plasma % zeff . lt . 1.0 ) equil % plasma % zeff = 1 endwhere where ( equil % plasma % zeff . gt . impc ) equil % plasma % zeff = impc endwhere where ( equil % plasma % dene . lt . 0.0 ) equil % plasma % dene = 0.0 endwhere where ( equil % plasma % te . lt . 0.0 ) equil % plasma % te = 0.0 endwhere where ( equil % plasma % ti . lt . 0.0 ) equil % plasma % ti = 0.0 endwhere equil % plasma % denimp = (( equil % plasma % zeff - 1.d0 ) / ( impc * ( impc - 1.d0 ))) * equil % plasma % dene equil % plasma % denp = equil % plasma % dene - impc * equil % plasma % denimp !!Close PLASMA group call h5gclose_f ( gid , error ) !!Open FIELDS group call h5gopen_f ( fid , \"/fields\" , gid , error ) allocate ( equil % fields ( inter_grid % nr , inter_grid % nz )) !!Read in electromagnetic fields call h5ltread_dataset_double_f ( gid , \"/fields/br\" , equil % fields % br , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/bt\" , equil % fields % bt , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/bz\" , equil % fields % bz , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/er\" , equil % fields % er , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/et\" , equil % fields % et , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/ez\" , equil % fields % ez , dims , error ) call h5ltread_dataset_int_f ( gid , \"/fields/mask\" , f_mask , dims , error ) !!Calculate B field derivatives call deriv ( inter_grid % r , inter_grid % z , equil % fields % br , equil % fields % dbr_dr , equil % fields % dbr_dz ) call deriv ( inter_grid % r , inter_grid % z , equil % fields % bt , equil % fields % dbt_dr , equil % fields % dbt_dz ) call deriv ( inter_grid % r , inter_grid % z , equil % fields % bz , equil % fields % dbz_dr , equil % fields % dbz_dz ) !!Close FIELDS group call h5gclose_f ( gid , error ) !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) allocate ( equil % mask ( inter_grid % nr , inter_grid % nz )) equil % mask = 0.d0 where (( p_mask . eq . 1 ). and .( f_mask . eq . 1 )) equil % mask = 1.d0 end subroutine read_equilibrium subroutine read_f ( fid , error ) !+ Reads in the fast-ion distribution function and stores the quantities in [[libfida:fbm]] integer ( HID_T ), intent ( inout ) :: fid !+ HDF5 file ID integer , intent ( out ) :: error !+ Error code integer ( HSIZE_T ), dimension ( 4 ) :: dims real ( Float64 ) :: dummy ( 1 ) integer :: ir if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Fast-ion distribution settings ----' endif call h5ltread_dataset_int_scalar_f ( fid , \"/nenergy\" , fbm % nenergy , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/npitch\" , fbm % npitch , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/nr\" , fbm % nr , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/nz\" , fbm % nz , error ) if (( fbm % nr . ne . inter_grid % nr ). or .( fbm % nz . ne . inter_grid % nz )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"READ_F: Distribution file has incompatable grid dimensions\" endif stop endif allocate ( fbm % energy ( fbm % nenergy ), fbm % pitch ( fbm % npitch ), fbm % r ( fbm % nr ), fbm % z ( fbm % nz )) allocate ( fbm % denf ( fbm % nr , fbm % nz )) allocate ( fbm % f ( fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz )) dims = [ fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz ] call h5ltread_dataset_double_f ( fid , \"/energy\" , fbm % energy , dims ( 1 : 1 ), error ) call h5ltread_dataset_double_f ( fid , \"/pitch\" , fbm % pitch , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( fid , \"/r\" , fbm % r , dims ( 3 : 3 ), error ) call h5ltread_dataset_double_f ( fid , \"/z\" , fbm % z , dims ( 4 : 4 ), error ) call h5ltread_dataset_double_f ( fid , \"/denf\" , fbm % denf , dims ( 3 : 4 ), error ) call h5ltread_dataset_double_f ( fid , \"/f\" , fbm % f , dims , error ) equil % plasma % denf = fbm % denf fbm % dE = abs ( fbm % energy ( 2 ) - fbm % energy ( 1 )) fbm % dp = abs ( fbm % pitch ( 2 ) - fbm % pitch ( 1 )) fbm % dr = abs ( fbm % r ( 2 ) - fbm % r ( 1 )) fbm % dz = abs ( fbm % z ( 2 ) - fbm % z ( 1 )) dummy = minval ( fbm % energy ) fbm % emin = dummy ( 1 ) dummy = maxval ( fbm % energy ) fbm % emax = dummy ( 1 ) fbm % e_range = fbm % emax - fbm % emin dummy = minval ( fbm % pitch ) fbm % pmin = dummy ( 1 ) dummy = maxval ( fbm % pitch ) fbm % pmax = dummy ( 1 ) fbm % p_range = fbm % pmax - fbm % pmin do ir = 1 , fbm % nr fbm % n_tot = fbm % n_tot + 2 * pi * fbm % dr * fbm % dz * sum ( fbm % denf ( ir ,:)) * fbm % r ( ir ) enddo if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Distribution type: \",a)' ) \"Fast-ion Density Function F(energy,pitch,R,Z)\" write ( * , '(T2,\"Nenergy = \",i3)' ), fbm % nenergy write ( * , '(T2,\"Npitch  = \",i3)' ), fbm % npitch write ( * , '(T2,\"Energy range = [\",f5.2,\",\",f6.2,\"]\")' ), fbm % emin , fbm % emax write ( * , '(T2,\"Pitch  range = [\",f5.2,\",\",f5.2,\"]\")' ), fbm % pmin , fbm % pmax write ( * , '(T2,\"Ntotal = \",ES10.3)' ) fbm % n_tot write ( * , * ) '' endif end subroutine read_f subroutine read_mc ( fid , error ) !+ Reads in a MC particle fast-ion distribution and puts them in [[libfida:particles]] integer ( HID_T ), intent ( inout ) :: fid !+ HDF5 file ID integer , intent ( out ) :: error !+ Error code integer ( HSIZE_T ), dimension ( 1 ) :: dims integer ( Int32 ) :: i , j , ii , ir , iz real ( Float64 ) :: phi , phi_enter , phi_exit , delta_phi real ( Float64 ), dimension ( 3 ) :: uvw , ri , vi , e1_xyz , e2_xyz , C_xyz , dum integer ( Int32 ), dimension ( 1 ) :: minpos real ( Float64 ), dimension (:), allocatable :: weight type ( LocalEMFields ) :: fields integer :: cnt , num logical :: inp character ( len = 32 ) :: dist_type_name = '' if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Fast-ion distribution settings ----' endif call h5ltread_dataset_int_scalar_f ( fid , \"/nparticle\" , particles % nparticle , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/nclass\" , particles % nclass , error ) !!ALLOCATE SPACE allocate ( particles % fast_ion ( particles % nparticle )) allocate ( weight ( particles % nparticle )) dims ( 1 ) = particles % nparticle call h5ltread_dataset_double_f ( fid , \"/r\" , particles % fast_ion % r , dims , error ) call h5ltread_dataset_double_f ( fid , \"/z\" , particles % fast_ion % z , dims , error ) call h5ltread_dataset_int_f ( fid , \"/class\" , particles % fast_ion % class , dims , error ) if ( any ( particles % fast_ion % class . gt . particles % nclass )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_MC: Orbit class ID greater then the number of classes' endif stop endif if ( inputs % dist_type . eq . 2 ) then dist_type_name = \"Guiding Center Monte Carlo\" call h5ltread_dataset_double_f ( fid , \"/energy\" , particles % fast_ion % energy , dims , error ) call h5ltread_dataset_double_f ( fid , \"/pitch\" , particles % fast_ion % pitch , dims , error ) particles % fast_ion % vabs = sqrt ( particles % fast_ion % energy / ( v2_to_E_per_amu * inputs % ab )) else dist_type_name = \"Full Orbit Monte Carlo\" call h5ltread_dataset_double_f ( fid , \"/vr\" , particles % fast_ion % vr , dims , error ) call h5ltread_dataset_double_f ( fid , \"/vt\" , particles % fast_ion % vt , dims , error ) call h5ltread_dataset_double_f ( fid , \"/vz\" , particles % fast_ion % vz , dims , error ) particles % fast_ion % vabs = sqrt ( particles % fast_ion % vr ** 2 + & particles % fast_ion % vt ** 2 + & particles % fast_ion % vz ** 2 ) particles % fast_ion % energy = v2_to_E_per_amu * inputs % ab * particles % fast_ion % vabs ** 2 endif call h5ltread_dataset_double_f ( fid , \"/weight\" , weight , dims , error ) cnt = 0 e1_xyz = matmul ( beam_grid % inv_basis ,[ 1.0 , 0.0 , 0.0 ]) e2_xyz = matmul ( beam_grid % inv_basis ,[ 0.0 , 1.0 , 0.0 ]) !$OMP PARALLEL DO schedule(guided) private(i,ii,j,ir,iz,minpos,fields,uvw,phi,ri,vi, & !$OMP& delta_phi,phi_enter,phi_exit,C_xyz) particle_loop : do i = 1 , particles % nparticle if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt / real ( particles % nparticle ) * 100 , char ( 13 ) endif uvw = [ particles % fast_ion ( i )% r , 0.d0 , particles % fast_ion ( i )% z ] call in_plasma ( uvw , inp , machine_coords = . True .) if (. not . inp ) cycle particle_loop phi_enter = 0.0 phi_exit = 0.0 dum = [ 0.d0 , 0.d0 , particles % fast_ion ( i )% z ] call uvw_to_xyz ( dum , C_xyz ) call circle_grid_intersect ( C_xyz , e1_xyz , e2_xyz , particles % fast_ion ( i )% r , phi_enter , phi_exit ) delta_phi = phi_exit - phi_enter if ( delta_phi . gt . 0 ) then particles % fast_ion ( i )% cross_grid = . True . else particles % fast_ion ( i )% cross_grid = . False . delta_phi = 2 * pi endif particles % fast_ion ( i )% phi_enter = phi_enter particles % fast_ion ( i )% delta_phi = delta_phi particles % fast_ion ( i )% weight = weight ( i ) * ( delta_phi / ( 2 * pi )) / beam_grid % dv minpos = minloc ( abs ( inter_grid % r - particles % fast_ion ( i )% r )) ir = minpos ( 1 ) minpos = minloc ( abs ( inter_grid % z - particles % fast_ion ( i )% z )) iz = minpos ( 1 ) !$OMP CRITICAL(mc_denf) equil % plasma ( ir , iz )% denf = equil % plasma ( ir , iz )% denf + weight ( i ) / & ( 2 * pi * particles % fast_ion ( i )% r * inter_grid % da ) !$OMP END CRITICAL(mc_denf) cnt = cnt + 1 enddo particle_loop !$OMP END PARALLEL DO num = count ( particles % fast_ion % cross_grid ) if ( num . le . 0 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_MC: No mc particles in beam grid' endif stop endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Distribution type: \",a)' ) dist_type_name write ( * , '(T2,\"Number of mc particles: \",i9)' ) particles % nparticle write ( * , '(T2,\"Number of orbit classes: \",i6)' ) particles % nclass write ( * , * ) '' endif end subroutine read_mc subroutine read_distribution !+ Reads in the fast-ion distribution integer ( HID_T ) :: fid integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % distribution_file , H5F_ACC_RDONLY_F , fid , error ) !!Get distribution type call h5ltread_dataset_int_scalar_f ( fid , \"/type\" , inputs % dist_type , error ) if ( inputs % dist_type . eq . 1 ) then call read_f ( fid , error ) else !2 or 3 call read_mc ( fid , error ) endif !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) end subroutine read_distribution subroutine read_atomic_cross ( fid , grp , cross ) !+ Reads in a cross section table from file !+ and puts it into a [[AtomicCrossSection]] type integer ( HID_T ), intent ( in ) :: fid !+ HDF5 file ID character ( len =* ), intent ( in ) :: grp !+ HDF5 group to read from type ( AtomicCrossSection ), intent ( inout ) :: cross !+ Atomic cross section integer ( HSIZE_T ), dimension ( 3 ) :: dim3 real ( Float64 ) :: emin , emax , rmin integer :: i , n_max , m_max , error real ( Float64 ), dimension (:,:,:), allocatable :: dummy3 logical :: path_valid call h5ltpath_valid_f ( fid , grp , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_ATOMIC_CROSS: Unknown atomic interaction: ' , trim ( grp ) endif stop endif call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , cross % nenergy , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/m_max\" , m_max , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , cross % dlogE , error ) cross % logemin = log10 ( emin ) cross % logemax = log10 ( emax ) allocate ( dummy3 ( n_max , m_max , cross % nenergy )) allocate ( cross % log_cross ( cross % m_max , cross % n_max , cross % nenergy )) dim3 = [ n_max , m_max , tables % H_H_cx % nenergy ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy3 , dim3 , error ) rmin = minval ( dummy3 , dummy3 . gt . 0.d0 ) where ( dummy3 . le . 0.0 ) dummy3 = 0.9 * rmin end where cross % minlog_cross = log10 ( rmin ) do i = 1 , cross % nenergy cross % log_cross (:,:, i ) = log10 ( transpose ( dummy3 ( 1 : nlevs , 1 : nlevs , i ))) enddo deallocate ( dummy3 ) end subroutine read_atomic_cross subroutine read_atomic_rates ( fid , grp , b_amu , t_amu , rates ) !+ Reads in a atomic reaction rates table from file !+ and puts it into a [[AtomicRates]] type integer ( HID_T ), intent ( in ) :: fid !+ HDF5 file ID character ( len =* ), intent ( in ) :: grp !+ HDF5 group to read from real ( Float64 ), dimension ( 2 ), intent ( in ) :: b_amu !+ Atomic masses of \"beam\" species (beam ion and thermal ion) real ( Float64 ), intent ( in ) :: t_amu !+ Atomic mass of \"target\" species (thermal ion) type ( AtomicRates ), intent ( inout ) :: rates !+ Atomic reaction rates integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 logical :: path_valid integer :: i , j , n , n_max , m_max , error integer :: n_bt_amu , tt_ind , bt_ind , drank real ( Float64 ) :: emin , emax , tmin , tmax , rmin real ( Float64 ) :: bt_min , tt_min , tt_dum , bt_dum real ( Float64 ), dimension ( 2 ) :: bt_amu , tt_amu real ( Float64 ), dimension (:,:), allocatable :: dummy2 real ( Float64 ), dimension (:,:,:,:), allocatable :: dummy4 real ( Float64 ), dimension (:,:,:,:,:), allocatable :: dummy5 call h5ltpath_valid_f ( fid , grp , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_ATOMIC_RATES: Unknown atomic interaction: ' , trim ( grp ) endif stop endif call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_bt_amu\" , n_bt_amu , error ) allocate ( dummy2 ( 2 , n_bt_amu )) dim2 = [ 2 , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/bt_amu\" , dummy2 , dim2 , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/m_max\" , m_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , rates % nenergy , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , rates % dlogE , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/ntemp\" , rates % ntemp , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmin\" , tmin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmax\" , tmax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogT\" , rates % dlogT , error ) rates % logemin = log10 ( emin ) rates % logemax = log10 ( emax ) rates % logtmin = log10 ( tmin ) rates % logtmax = log10 ( tmax ) bt_ind = 1 tt_ind = 1 bt_amu = [ b_amu ( 1 ), t_amu ] tt_amu = [ b_amu ( 2 ), t_amu ] bt_min = norm2 ( bt_amu - dummy2 (:, 1 )) tt_min = norm2 ( tt_amu - dummy2 (:, 1 )) do i = 2 , n_bt_amu bt_dum = norm2 ( bt_amu - dummy2 (:, i )) tt_dum = norm2 ( tt_amu - dummy2 (:, i )) if ( bt_dum . lt . bt_min ) then bt_min = bt_dum bt_ind = i endif if ( tt_dum . lt . tt_min ) then tt_min = tt_dum tt_ind = i endif enddo rates % ab ( 1 ) = dummy2 ( 1 , bt_ind ) rates % ab ( 2 ) = dummy2 ( 1 , tt_ind ) deallocate ( dummy2 ) allocate ( rates % log_pop (& rates % m_max , & rates % n_max , & rates % nenergy , & rates % ntemp , 2 )) allocate ( rates % log_depop (& rates % n_max , & rates % nenergy , & rates % ntemp , 2 )) rates % log_pop = 0.d0 rates % log_depop = 0.d0 !!Read CX call h5ltpath_valid_f ( fid , grp // \"/cx\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltget_dataset_ndims_f ( fid , grp // \"/cx\" , drank , error ) if ( drank . eq . 4 ) then allocate ( dummy4 ( n_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim4 = [ n_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy4 , dim4 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = dummy4 ( n , i , j , bt_ind ) rates % log_depop ( n , i , j , 2 ) = dummy4 ( n , i , j , tt_ind ) enddo enddo enddo deallocate ( dummy4 ) endif if ( drank . eq . 5 ) then allocate ( dummy5 ( n_max , m_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim5 = [ n_max , m_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy5 , dim5 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = sum ( dummy5 ( n ,:, i , j , bt_ind )) rates % log_depop ( n , i , j , 2 ) = sum ( dummy5 ( n ,:, i , j , tt_ind )) enddo enddo enddo deallocate ( dummy5 ) endif endif !!Read ionization call h5ltpath_valid_f ( fid , grp // \"/ionization\" , . True ., path_valid , error ) if ( path_valid ) then allocate ( dummy4 ( n_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim4 = [ n_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/ionization\" , dummy4 , dim4 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = rates % log_depop ( n , i , j , 1 ) + & dummy4 ( n , i , j , bt_ind ) rates % log_depop ( n , i , j , 2 ) = rates % log_depop ( n , i , j , 2 ) + & dummy4 ( n , i , j , tt_ind ) enddo enddo enddo deallocate ( dummy4 ) endif !!Read excitation call h5ltpath_valid_f ( fid , grp // \"/excitation\" , . True ., path_valid , error ) if ( path_valid ) then allocate ( dummy5 ( n_max , m_max ,& rates % nenergy , & rates % ntemp , n_bt_amu )) dim5 = [ n_max , m_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/excitation\" , dummy5 , dim5 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy rates % log_pop (:,:, i , j , 1 ) = transpose ( dummy5 ( 1 : nlevs , 1 : nlevs , i , j , bt_ind )) rates % log_pop (:,:, i , j , 2 ) = transpose ( dummy5 ( 1 : nlevs , 1 : nlevs , i , j , tt_ind )) do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = rates % log_depop ( n , i , j , 1 ) + & sum ( dummy5 ( n ,:, i , j , bt_ind )) rates % log_depop ( n , i , j , 2 ) = rates % log_depop ( n , i , j , 2 ) + & sum ( dummy5 ( n ,:, i , j , tt_ind )) enddo enddo enddo deallocate ( dummy5 ) endif rmin = minval ( rates % log_depop , rates % log_depop . gt . 0.d0 ) where ( rates % log_depop . le . 0.d0 ) rates % log_depop = 0.9 * rmin end where rates % minlog_depop = log10 ( rmin ) rates % log_depop = log10 ( rates % log_depop ) rmin = minval ( rates % log_pop , rates % log_pop . gt . 0.d0 ) where ( rates % log_pop . le . 0.d0 ) rates % log_pop = 0.9 * rmin end where rates % minlog_pop = log10 ( rmin ) rates % log_pop = log10 ( rates % log_pop ) end subroutine read_atomic_rates subroutine read_nuclear_rates ( fid , grp , rates ) !+ Reads in a nuclear reaction rates table from file !+ and puts it into a [[NuclearRates]] type integer ( HID_T ), intent ( in ) :: fid !+ HDF5 file ID character ( len =* ), intent ( in ) :: grp !+ HDF5 group to read from type ( NuclearRates ), intent ( inout ) :: rates !+ Atomic reaction rates integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 logical :: path_valid integer :: i , j , error real ( Float64 ) :: emin , emax , tmin , tmax , rmin call h5ltpath_valid_f ( fid , grp , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_NUCLEAR_RATES: Unknown nuclear interaction: ' , trim ( grp ) write ( * , '(a)' ) 'Continuing without neutron calculation' endif inputs % calc_neutron = 0 return endif call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nbranch\" , rates % nbranch , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , rates % nenergy , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , rates % dlogE , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/ntemp\" , rates % ntemp , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmin\" , tmin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmax\" , tmax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogT\" , rates % dlogT , error ) rates % logemin = log10 ( emin ) rates % logemax = log10 ( emax ) rates % logtmin = log10 ( tmin ) rates % logtmax = log10 ( tmax ) allocate ( rates % log_rate ( rates % nenergy , & rates % ntemp , & rates % nbranch )) dim1 = [ 2 ] call h5ltread_dataset_double_f ( fid , grp // \"/bt_amu\" , rates % bt_amu , dim1 , error ) if ( abs ( inputs % ab - rates % bt_amu ( 1 )). gt . 0.2 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,f6.3,a,f6.3,a)' ) 'READ_NUCLEAR_RATES: Unexpected beam species mass. Expected ' ,& rates % bt_amu ( 1 ), ' amu got ' , inputs % ab , ' amu' endif endif if ( abs ( inputs % ai - rates % bt_amu ( 2 )). gt . 0.2 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,f6.3,a,f6.3,a)' ) 'READ_NUCLEAR_RATES: Unexpected thermal species mass. Expected ' ,& rates % bt_amu ( 2 ), ' amu got ' , inputs % ai , ' amu' endif endif dim3 = [ rates % nenergy , rates % ntemp , rates % nbranch ] call h5ltread_dataset_double_f ( fid , grp // \"/fusion\" , rates % log_rate , dim3 , error ) rmin = minval ( rates % log_rate , rates % log_rate . gt . 0.d0 ) where ( rates % log_rate . le . 0.d0 ) rates % log_rate = 0.9 * rmin end where rates % minlog_rate = log10 ( rmin ) rates % log_rate = log10 ( rates % log_rate ) end subroutine read_nuclear_rates subroutine read_tables !+ Reads in atomic tables from file and stores them in [[libfida:tables]] integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: error integer :: n_max , m_max character ( len = 4 ) :: impname real ( Float64 ) :: imp_amu real ( Float64 ), dimension ( 2 ) :: b_amu real ( Float64 ), dimension (:,:), allocatable :: dummy2 if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Atomic tables settings ----\" endif !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % tables_file , H5F_ACC_RDONLY_F , fid , error ) !!Read Hydrogen-Hydrogen CX Cross Sections call read_atomic_cross ( fid , \"/cross/H_H\" , tables % H_H_cx ) !!Read Hydrogen-Hydrogen Rates b_amu = [ inputs % ab , inputs % ai ] call read_atomic_rates ( fid , \"/rates/H_H\" , b_amu , inputs % ai , tables % H_H ) inputs % ab = tables % H_H % ab ( 1 ) inputs % ai = tables % H_H % ab ( 2 ) !!Read Hydrogen-Electron Rates call read_atomic_rates ( fid , \"/rates/H_e\" , b_amu , e_amu , tables % H_e ) !!Read Hydrogen-Impurity rates impname = '' select case ( inputs % impurity_charge ) case ( 5 ) impname = \"B5\" imp_amu = B5_amu case ( 6 ) impname = \"C6\" imp_amu = C6_amu case DEFAULT impname = \"Aq\" imp_amu = 2.d0 * inputs % impurity_charge end select call read_atomic_rates ( fid , \"/rates/H_\" // trim ( adjustl ( impname )), b_amu , imp_amu , tables % H_Aq ) !!Read Einstein coefficients call h5ltread_dataset_int_scalar_f ( fid , \"/rates/spontaneous/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/rates/spontaneous/m_max\" , m_max , error ) allocate ( dummy2 ( n_max , m_max )) dim2 = [ n_max , m_max ] call h5ltread_dataset_double_f ( fid , \"/rates/spontaneous/einstein\" , dummy2 , dim2 , error ) tables % einstein (:,:) = transpose ( dummy2 ( 1 : nlevs , 1 : nlevs )) deallocate ( dummy2 ) !!Read nuclear Deuterium-Deuterium rates call read_nuclear_rates ( fid , \"/rates/D_D\" , tables % D_D ) !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Maximum n/m: \",i2)' ) nlevs write ( * , '(T2,\"Beam/Fast-ion mass: \",f6.3,\" [amu]\")' ) inputs % ab write ( * , '(T2,\"Thermal/Bulk-ion mass: \",f6.3,\" [amu]\")' ) inputs % ai write ( * , '(T2,\"Impurity mass: \",f6.3,\" [amu]\")' ) imp_amu write ( * , * ) '' endif end subroutine read_tables subroutine write_beam_grid ( id , error ) !+ Write [[libfida:beam_grid]] to an HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file ID integer , intent ( out ) :: error !+ Error code integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 3 ) :: dims real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: u_grid , v_grid , w_grid real ( Float64 ) :: xyz ( 3 ), uvw ( 3 ) integer :: i , j , k !Create uvw grids do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx xyz = [ beam_grid % xc ( i ), & beam_grid % yc ( j ), & beam_grid % zc ( k )] call xyz_to_uvw ( xyz , uvw ) u_grid ( i , j , k ) = uvw ( 1 ) v_grid ( i , j , k ) = uvw ( 2 ) w_grid ( i , j , k ) = uvw ( 3 ) enddo enddo enddo !Create grid group call h5gcreate_f ( id , \"grid\" , gid , error ) !Write variables dims ( 1 ) = 1 call h5ltmake_dataset_int_f ( gid , \"nx\" , 0 , dims ( 1 : 1 ), [ beam_grid % nx ], error ) call h5ltmake_dataset_int_f ( gid , \"ny\" , 0 , dims ( 1 : 1 ), [ beam_grid % ny ], error ) call h5ltmake_dataset_int_f ( gid , \"nz\" , 0 , dims ( 1 : 1 ), [ beam_grid % nz ], error ) dims = [ beam_grid % nx , beam_grid % ny , beam_grid % nz ] call h5ltmake_compressed_dataset_double_f ( gid , \"x\" , 1 , dims ( 1 : 1 ), beam_grid % xc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"y\" , 1 , dims ( 2 : 2 ), beam_grid % yc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"z\" , 1 , dims ( 3 : 3 ), beam_grid % zc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"x_grid\" , 3 , dims , u_grid , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"y_grid\" , 3 , dims , v_grid , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"z_grid\" , 3 , dims , w_grid , error ) !Write attributes call h5ltset_attribute_string_f ( gid , \"nx\" , \"description\" , & \"Number of cells in the X direction\" , error ) call h5ltset_attribute_string_f ( gid , \"ny\" , \"description\" , & \"Number of cells in the Y direction\" , error ) call h5ltset_attribute_string_f ( gid , \"nz\" , \"description\" , & \"Number of cells in the Z direction\" , error ) call h5ltset_attribute_string_f ( gid , \"x\" , \"description\" , & \"X value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"x\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"y\" , \"description\" , & \"Y value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"y\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"z\" , \"description\" , & \"Z value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"z\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"x_grid\" , \"description\" , & \"X value of cell center in machine coordinates: x_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"x_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"y_grid\" , \"description\" , & \"Y value of cell center in machine coordinates: y_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"y_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"z_grid\" , \"description\" , & \"Z value of cell center in machine coordinates: z_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"z_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( id , \"grid\" , \"coordinate_system\" , & \"Right-handed cartesian\" , error ) !Close grid group call h5gclose_f ( gid , error ) end subroutine write_beam_grid subroutine write_birth_profile !+ Writes [[libfida:birth]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error , i , npart character ( charlim ) :: filename real ( Float64 ), dimension (:,:), allocatable :: ri real ( Float64 ), dimension (:,:), allocatable :: vi real ( Float64 ), dimension ( 3 ) :: xyz , uvw , v_uvw npart = birth % cnt - 1 allocate ( ri ( 3 , npart )) allocate ( vi ( 3 , npart )) do i = 1 , npart ! Convert position to rzphi xyz = birth % ri (:, i ) call xyz_to_uvw ( xyz , uvw ) ri ( 1 , i ) = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) ri ( 2 , i ) = uvw ( 3 ) ri ( 3 , i ) = atan2 ( uvw ( 2 ), uvw ( 1 )) ! Convert velocity to rzphi v_uvw = matmul ( beam_grid % basis , birth % vi (:, i )) vi ( 1 , i ) = v_uvw ( 1 ) * cos ( ri ( 3 , i )) + v_uvw ( 2 ) * sin ( ri ( 3 , i )) vi ( 2 , i ) = v_uvw ( 3 ) vi ( 3 , i ) = - v_uvw ( 1 ) * sin ( ri ( 3 , i )) + v_uvw ( 2 ) * cos ( ri ( 3 , i )) enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_birth.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables call write_beam_grid ( fid , error ) d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/n_birth\" , 0 , d , [ npart ], error ) dim4 = shape ( birth % dens ) call h5ltmake_compressed_dataset_double_f ( fid , \"/dens\" , 4 , dim4 , birth % dens , error ) dim2 = [ 3 , npart ] call h5ltmake_compressed_dataset_double_f ( fid , \"/ri\" , 2 , dim2 , ri , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vi\" , 2 , dim2 , vi , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/ind\" , 2 , dim2 , birth % ind , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/type\" , 1 , dim2 ( 2 : 2 ), birth % neut_type , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/n_birth\" , \"description\" , & \"Number of birth mc particles deposited\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"description\" , & \"Birth density: dens(beam_component,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"units\" , & \"fast-ions/(s*cm&#94;3)\" , error ) call h5ltset_attribute_string_f ( fid , \"/ri\" , \"description\" , & \"Fast-ion birth position in R-Z-Phi: ri([r,z,phi],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/ri\" , \"units\" , \"cm, radians\" , error ) call h5ltset_attribute_string_f ( fid , \"/vi\" , \"description\" , & \"Fast-ion birth velocity in R-Z-Phi: vi([r,z,phi],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/vi\" , \"units\" , \"cm/s\" , error ) call h5ltset_attribute_string_f ( fid , \"/ind\" , \"description\" , & \"Fast-ion birth beam grid indices: ind([i,j,k],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/type\" , \"description\" , & \"Fast-ion birth type (1=Full, 2=Half, 3=Third)\" , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"coordinate_system\" , & \"Cylindrical (R,Z,Phi)\" , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Birth density and particles calculated by FIDASIM\" , error ) !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) deallocate ( ri , vi ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'birth profile written to: ' , trim ( filename ) endif end subroutine write_birth_profile subroutine write_dcx !+ Writes the direct charge exchange (DCX) neutrals and spectra to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dims integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error character ( charlim ) :: filename character ( 15 ) :: spec_str integer :: i real ( Float64 ), dimension (:), allocatable :: lambda_arr real ( Float64 ), dimension (:,:), allocatable :: dcx_spec filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_dcx.h5\" spec_str = \"\" if ( inputs % calc_spec . ge . 1 ) then spec_str = \" spectra and\" allocate ( lambda_arr ( inputs % nlambda )) do i = 1 , inputs % nlambda lambda_arr ( i ) = ( i - 0.5 ) * inputs % dlambda + inputs % lambdamin ! [nm] enddo allocate ( dcx_spec ( inputs % nlambda , spec_chords % nchan )) !! convert [Ph/(s*wavel_bin*cm&#94;2*all_directions)] to [Ph/(s*nm*sr*m&#94;2)]! dcx_spec = spec % bes (:,:, halo_type ) / ( inputs % dlambda ) / ( 4.d0 * pi ) * 1.d4 endif !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables call write_beam_grid ( fid , error ) d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nlevel\" , 0 , d , [ nlevs ], error ) dims = [ nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz ] call h5ltmake_compressed_dataset_double_f ( fid , \"/dens\" , 4 , dims , & neut % dens (:, halo_type ,:,:,:), error ) if ( inputs % calc_spec . ge . 1 ) then call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ spec_chords % nchan ], error ) call h5ltmake_dataset_int_f ( fid , \"/nlambda\" , 0 , d , [ inputs % nlambda ], error ) dims ( 1 ) = inputs % nlambda dims ( 2 ) = spec_chords % nchan call h5ltmake_compressed_dataset_double_f ( fid , \"/spec\" , 2 , dims ( 1 : 2 ), & dcx_spec , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/lambda\" , 1 , dims ( 1 : 1 ), & lambda_arr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dims ( 2 : 2 ), & spec_chords % radius , error ) endif !Add attributes call h5ltset_attribute_string_f ( fid , \"/nlevel\" , \"description\" , & \"Number of atomic energy levels\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"description\" , & \"Direct Charge Exchange (DCX) neutral density: dcx(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) if ( inputs % calc_spec . ge . 1 ) then call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nlambda\" , \"description\" , & \"Number of wavelengths\" , error ) call h5ltset_attribute_string_f ( fid , \"/spec\" , \"description\" , & \"Direct Charge Exchange (DCX) beam emission: spec(lambda, chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/spec\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"description\" , & \"Wavelength array\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"units\" , \"nm\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Direct Charge Exchange (DCX)\" // trim ( spec_str ) // \" neutral density calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % calc_spec . ge . 1 ) then deallocate ( dcx_spec , lambda_arr ) endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'dcx written to: ' , trim ( filename ) endif end subroutine write_dcx subroutine write_neutrals !+ Writes [[libfida:neut]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dims integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error character ( charlim ) :: filename filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_neutrals.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables call write_beam_grid ( fid , error ) dims = [ nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz ] d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nlevel\" , 0 , d , [ nlevs ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/fdens\" , 4 , dims , & neut % dens (:, nbif_type ,:,:,:), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/hdens\" , 4 , dims , & neut % dens (:, nbih_type ,:,:,:), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/tdens\" , 4 , dims , & neut % dens (:, nbit_type ,:,:,:), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/halodens\" , 4 , dims , & neut % dens (:, halo_type ,:,:,:), error ) !Write attributes call h5ltset_attribute_string_f ( fid , \"/nlevel\" , \"description\" , & \"Number of atomic energy levels\" , error ) call h5ltset_attribute_string_f ( fid , \"/fdens\" , \"description\" , & \"Neutral density for the full energy component of the beam: fdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/fdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/hdens\" , \"description\" , & \"Neutral density for the half energy component of the beam: hdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/hdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/tdens\" , \"description\" , & \"Neutral density for the third energy component of the beam: tdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/tdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/halodens\" , \"description\" , & \"Neutral density of the beam halo(including dcx): halodens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/halodens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Beam neutral density calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'neutral density written to: ' , trim ( filename ) endif end subroutine write_neutrals subroutine write_npa !+ Writes [[libfida:npa]] to a HDF5 file integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error integer , dimension (:), allocatable :: dcount real ( Float64 ), dimension (:,:), allocatable :: ri , rf integer :: i , n character ( charlim ) :: filename = '' allocate ( dcount ( npa_chords % nchan )) do i = 1 , npa_chords % nchan dcount ( i ) = count ( npa % part % detector . eq . i ) enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_npa.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write Flux d ( 1 ) = 1 dim2 = [ npa % nenergy , npa % nchan ] dim3 = [ npa % nenergy , npa % nchan , particles % nclass ] if ( particles % nclass . gt . 1 ) then call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , d , [ particles % nclass ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/flux\" , 3 , dim3 , npa % flux , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"description\" , & \"Neutral flux: flux(energy,chan,class)\" , error ) else call h5ltmake_compressed_dataset_double_f ( fid , \"/flux\" , 2 , dim3 ( 1 : 2 ), npa % flux (:,:, 1 ), error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"description\" , & \"Neutral flux: flux(energy,chan)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/flux\" , \"units\" , \"neutrals/(s*dE)\" , error ) call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , d , [ npa % nenergy ], error ) call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ npa % nchan ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim2 ( 1 : 1 ),& npa % energy , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dim2 ( 2 : 2 ),& npa_chords % radius , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/count\" , 1 , dim2 ( 2 : 2 ), dcount , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"NPA flux calculated by FIDASIM\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" ,& \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" ,& \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Detector line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/count\" , \"description\" , & \"Number of particles that hit the detector: count(chan)\" , error ) deallocate ( dcount ) if (( npa % npart . ne . 0 ). and .( inputs % calc_npa . ge . 2 )) then n = npa % npart allocate ( ri ( 3 , n ), rf ( 3 , n )) ri ( 1 ,:) = npa % part ( 1 : n )% xi ri ( 2 ,:) = npa % part ( 1 : n )% yi ri ( 3 ,:) = npa % part ( 1 : n )% zi rf ( 1 ,:) = npa % part ( 1 : n )% xf rf ( 2 ,:) = npa % part ( 1 : n )% yf rf ( 3 ,:) = npa % part ( 1 : n )% zf !Create Group call h5gcreate_f ( fid , \"/particles\" , gid , error ) call h5ltmake_dataset_int_f ( gid , \"nparticle\" , 0 , d , [ npa % npart ], error ) d ( 1 ) = npa % npart dim2 = [ 3 , n ] call h5ltmake_compressed_dataset_double_f ( gid , \"ri\" , 2 , dim2 , ri , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"rf\" , 2 , dim2 , rf , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"pitch\" , 1 , d , & npa % part ( 1 : n )% pitch , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , d ,& npa % part ( 1 : n )% energy , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"weight\" , 1 , d ,& npa % part ( 1 : n )% weight , error ) call h5ltmake_compressed_dataset_int_f ( gid , \"detector\" , 1 , d ,& npa % part ( 1 : n )% detector , error ) !Add attributes call h5ltset_attribute_string_f ( gid , \"nparticle\" , \"description\" , & \"Number of particles that hit a detector\" , error ) call h5ltset_attribute_string_f ( gid , \"ri\" , \"description\" , & \"Neutral particle's birth position in machine coordinates: ri([x,y,z],particle)\" , error ) call h5ltset_attribute_string_f ( gid , \"ri\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"rf\" , \"description\" , & \"Neutral particle's hit position in machine coordinates: rf([x,y,z],particle)\" , error ) call h5ltset_attribute_string_f ( gid , \"rf\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"pitch\" , \"description\" , & \"Pitch value of the neutral particle: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy value of the neutral particle\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"weight\" , \"description\" , & \"Neutral particle's contribution to the flux\" , error ) call h5ltset_attribute_string_f ( gid , \"weight\" , \"units\" , \"neutrals/s\" , error ) call h5ltset_attribute_string_f ( gid , \"detector\" , \"description\" , & \"Detector that the neutral particle hit\" , error ) call h5ltset_attribute_string_f ( fid , \"/particles\" , \"coordinate_system\" , & \"Right-handed cartesian\" , error ) call h5ltset_attribute_string_f ( fid , \"/particles\" , \"description\" , & \"Monte Carlo particles\" , error ) !Close group call h5gclose_f ( gid , error ) deallocate ( ri , rf ) endif !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'NPA data written to: ' , trim ( filename ) endif end subroutine write_npa subroutine write_spectra !+ Writes [[libfida:spectra]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 3 ) :: dims integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error character ( charlim ) :: filename integer :: i real ( Float64 ), dimension (:), allocatable :: lambda_arr allocate ( lambda_arr ( inputs % nlambda )) do i = 1 , inputs % nlambda lambda_arr ( i ) = ( i - 0.5 ) * inputs % dlambda + inputs % lambdamin enddo !! convert [Ph/(s*wavel_bin*cm&#94;2*all_directions)] to [Ph/(s*nm*sr*m&#94;2)]! spec % brems = spec % brems / ( inputs % dlambda ) / ( 4.d0 * pi ) * 1.d4 spec % bes = spec % bes / ( inputs % dlambda ) / ( 4.d0 * pi ) * 1.d4 spec % fida = spec % fida / ( inputs % dlambda ) / ( 4.d0 * pi ) * 1.d4 !! write to file filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_spectra.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ spec_chords % nchan ], error ) call h5ltmake_dataset_int_f ( fid , \"/nlambda\" , 0 , d , [ inputs % nlambda ], error ) dims ( 1 ) = inputs % nlambda dims ( 2 ) = spec_chords % nchan dims ( 3 ) = particles % nclass call h5ltmake_compressed_dataset_double_f ( fid , \"/lambda\" , 1 , dims ( 1 : 1 ), & lambda_arr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dims ( 2 : 2 ), & spec_chords % radius , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nlambda\" , \"description\" , & \"Number of wavelengths\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"description\" , & \"Wavelength array\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"units\" , \"nm\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) if ( inputs % calc_brems . ge . 1 ) then !Write variables call h5ltmake_compressed_dataset_double_f ( fid , \"/brems\" , 2 , & dims ( 1 : 2 ), spec % brems , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/brems\" , \"description\" , & \"Visible Bremsstrahlung: brems(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/brems\" , \"units\" ,& \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_bes . ge . 1 ) then !Write variables call h5ltmake_compressed_dataset_double_f ( fid , \"/full\" , 2 , dims ( 1 : 2 ), & spec % bes (:,:, nbif_type ), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/half\" , 2 , dims ( 1 : 2 ), & spec % bes (:,:, nbih_type ), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/third\" , 2 , dims ( 1 : 2 ),& spec % bes (:,:, nbit_type ), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/halo\" , 2 , dims ( 1 : 2 ), & spec % bes (:,:, halo_type ), error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/full\" , \"description\" , & \"Full energy component of the beam emmision: full(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/full\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/half\" , \"description\" , & \"Half energy component of the beam emmision: half(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/half\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/third\" , \"description\" , & \"Third energy component of the beam emmision: third(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/third\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/halo\" , \"description\" , & \"Halo component of the beam emmision (includes dcx): halo(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/halo\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_fida . ge . 1 ) then !Write variables if ( particles % nclass . le . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 2 , & dims ( 1 : 2 ), spec % fida (:,:, 1 ), error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Fast-ion D-alpha (FIDA) emmision: fida(lambda,chan)\" , error ) else call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , d , [ particles % nclass ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 3 , & dims , spec % fida , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Fast-ion D-alpha (FIDA) emmision: fida(lambda,chan,class)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/fida\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" ,& \"Spectra calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'Spectra written to: ' , trim ( filename ) endif end subroutine write_spectra subroutine write_neutrons !+ Writes [[libfida:neutron]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer :: error character ( charlim ) :: filename !! write to file filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_neutrons.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables if ( particles % nclass . gt . 1 ) then dim1 ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , dim1 , [ particles % nclass ], error ) dim1 ( 1 ) = particles % nclass call h5ltmake_compressed_dataset_double_f ( fid , \"/rate\" , 1 , dim1 , neutron % rate , error ) call h5ltset_attribute_string_f ( fid , \"/rate\" , \"description\" , & \"Neutron rate: rate(orbit_class)\" , error ) else dim1 ( 1 ) = 1 call h5ltmake_dataset_double_f ( fid , \"/rate\" , 0 , dim1 , neutron % rate , error ) call h5ltset_attribute_string_f ( fid , \"/rate\" , \"description\" , & \"Neutron rate\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/rate\" , \"units\" , \"neutrons/s\" , error ) if ( inputs % dist_type . eq . 1 ) then dim1 ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , dim1 ,[ fbm % nenergy ], error ) call h5ltmake_dataset_int_f ( fid , \"/npitch\" , 0 , dim1 ,[ fbm % npitch ], error ) call h5ltmake_dataset_int_f ( fid , \"/nr\" , 0 , dim1 ,[ fbm % nr ], error ) call h5ltmake_dataset_int_f ( fid , \"/nz\" , 0 , dim1 ,[ fbm % nz ], error ) dim4 = shape ( neutron % weight ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 4 , dim4 , neutron % weight , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim4 ( 1 : 1 ), fbm % energy , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , dim4 ( 2 : 2 ), fbm % pitch , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/r\" , 1 , dim4 ( 3 : 3 ), fbm % r , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/z\" , 1 , dim4 ( 4 : 4 ), fbm % z , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/npitch\" , \"description\" , & \"Number of pitch values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nr\" , \"description\" , & \"Number of R values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nz\" , \"description\" , & \"Number of Z values\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"Neutron Weight Function: weight(E,p,R,Z), rate = sum(f*weight)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , \"neutrons*cm&#94;3*dE*dp/fast-ion*s\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Pitch array: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( fid , \"/r\" , \"description\" , & \"Radius array\" , error ) call h5ltset_attribute_string_f ( fid , \"/r\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/z\" , \"description\" , & \"Z array\" , error ) call h5ltset_attribute_string_f ( fid , \"/z\" , \"units\" , \"cm\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" ,& \"Neutron rate calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'Neutrons written to: ' , trim ( filename ) endif end subroutine write_neutrons subroutine write_fida_weights !+ Writes [[libfida:fweight]] to a HDF5 file !! HDF5 variables integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer :: error character ( charlim ) :: filename integer :: i , ie , ip , ic , iwav real ( Float64 ), dimension (:), allocatable :: lambda_arr real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr real ( Float64 ), dimension (:,:), allocatable :: jacobian , e_grid , p_grid real ( Float64 ), dimension (:,:), allocatable :: vpa_grid , vpe_grid , fida real ( Float64 ) :: dlambda , wtot , dE , dP dlambda = ( inputs % lambdamax_wght - inputs % lambdamin_wght ) / inputs % nlambda_wght allocate ( lambda_arr ( inputs % nlambda_wght )) do i = 1 , inputs % nlambda_wght lambda_arr ( i ) = ( i - 0.5 ) * dlambda + inputs % lambdamin_wght enddo !! define arrays !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) !! define 2d grids !! define energy grid allocate ( e_grid ( inputs % ne_wght , inputs % np_wght )) do i = 1 , inputs % ne_wght e_grid ( i ,:) = ebarr ( i ) enddo !! define pitch grid allocate ( p_grid ( inputs % ne_wght , inputs % np_wght )) do i = 1 , inputs % np_wght p_grid (:, i ) = ptcharr ( i ) enddo !! define velocity space grid allocate ( vpe_grid ( inputs % ne_wght , inputs % np_wght )) !! V perpendicular allocate ( vpa_grid ( inputs % ne_wght , inputs % np_wght )) !! V parallel vpa_grid = 100 * sqrt (((( 2.0d3 ) * e0 ) / ( mass_u * inputs % ab )) * e_grid ) * p_grid ! [cm/s] vpe_grid = 100 * sqrt (((( 2.0d3 ) * e0 ) / ( mass_u * inputs % ab )) * e_grid * ( 1.0 - p_grid ** 2 )) ![cm/s] !! define jacobian to convert between E-p to velocity allocate ( jacobian ( inputs % ne_wght , inputs % np_wght )) jacobian = (( inputs % ab * mass_u ) / ( e0 * 1.0d3 )) * vpe_grid / sqrt ( vpa_grid ** 2 + vpe_grid ** 2 ) !! normalize mean_f do ic = 1 , spec_chords % nchan do ip = 1 , inputs % np_wght do ie = 1 , inputs % ne_wght wtot = sum ( fweight % weight (:, ie , ip , ic )) if (( wtot . gt . 0.d0 )) then fweight % mean_f ( ie , ip , ic ) = fweight % mean_f ( ie , ip , ic ) / wtot endif enddo enddo enddo !! Calculate FIDA estimate allocate ( fida ( inputs % nlambda_wght , spec_chords % nchan )) do iwav = 1 , size ( fida , 1 ) fida ( iwav ,:) = ( dE * dP * 1 d4 ) * sum ( sum ( fweight % mean_f (:,:,:) * fweight % weight ( iwav ,:,:,:), 1 ), 1 ) enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_fida_weights.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) dim1 ( 1 ) = 1 dim2 = [ inputs % nlambda_wght , spec_chords % nchan ] dim4 = [ inputs % nlambda_wght , inputs % ne_wght , inputs % np_wght , spec_chords % nchan ] call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , dim1 ,[ inputs % ne_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/npitch\" , 0 , dim1 ,[ inputs % np_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , dim1 ,[ spec_chords % nchan ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 4 , dim4 , fweight % weight , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 2 , dim2 , fida , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/mean_f\" , 3 , dim4 ( 2 : 4 ), fweight % mean_f , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/lambda\" , 1 , dim4 ( 1 : 1 ), lambda_arr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim4 ( 2 : 2 ), ebarr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , dim4 ( 3 : 3 ), ptcharr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dim4 ( 4 : 4 ), spec_chords % radius , error ) dim2 = [ inputs % ne_wght , inputs % np_wght ] call h5ltmake_compressed_dataset_double_f ( fid , \"/jacobian\" , 2 , dim2 , jacobian , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vpe_grid\" , 2 , dim2 , vpe_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vpa_grid\" , 2 , dim2 , vpa_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/e_grid\" , 2 , dim2 , e_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/p_grid\" , 2 , dim2 , p_grid , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) if ( inputs % calc_fida_wght . eq . 1 ) then call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Line of Sight averaged FIDA E-p space sensitivity/weights \" // & \"and spectra calculated by FIDASIM\" , error ) else call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Full FIDA E-p space sensitivity/weights and spectra calculated \" // & \"by FIDASIM via Monte Carlo method\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"E-p space sensivity/weight of FIDA diagnostic: weight(lambda,energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , & \"(Ph*cm)/(s*nm*sr*fast-ion*dE*dP)\" , error ) call h5ltset_attribute_string_f ( fid , \"/fida\" , \"units\" , & \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Estimate of Fast-ion D-alpha (FIDA) emmision calculated by 1e4*weight*mean_f*dEdP: fida(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/mean_f\" , \"description\" , & \"Estimated mean fast-ion distribution function seen by los: mean_f(energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/mean_f\" , \"units\" , & \"fast-ion/(dE*dP*cm&#94;3)\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"description\" , & \"Wavelength array\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"units\" , \"nm\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/npitch\" , \"description\" , & \"Number of pitch value\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Pitch array: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/jacobian\" , \"description\" , & \"Jacobian used to convert from E-p space to velocity space\" , error ) call h5ltset_attribute_string_f ( fid , \"/jacobian\" , \"units\" , & \"(dE*dP)/(dvpa*dvpe)\" , error ) call h5ltset_attribute_string_f ( fid , \"/e_grid\" , \"description\" , & \"2D energy grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/e_grid\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/p_grid\" , \"description\" , & \"2D pitch grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpe_grid\" , \"description\" , & \"2D perpendicular velocity grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpe_grid\" , \"units\" , \"cm/s\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpa_grid\" , \"description\" , & \"2D parallel velocity grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpa_grid\" , \"units\" , \"cm/s\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'FIDA weights written to: ' , trim ( filename ) endif end subroutine write_fida_weights subroutine write_npa_weights !+ Writes [[libfida:nweight]] to a HDF5 file character ( charlim ) :: filename integer :: i real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr !! HDF5 variables integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_npa_weights.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables d ( 1 ) = 1 dim2 = [ inputs % ne_wght , npa_chords % nchan ] dim3 = [ inputs % ne_wght , inputs % np_wght , npa_chords % nchan ] dim5 = [ inputs % ne_wght , beam_grid % nx , beam_grid % ny , beam_grid % nz , npa_chords % nchan ] call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ npa_chords % nchan ], error ) call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , d , [ inputs % ne_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/npitch\" , 0 , d , [ inputs % np_wght ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , & dim2 ( 2 : 2 ), npa_chords % radius , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , & dim2 ( 1 : 1 ), ebarr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , & dim3 ( 2 : 2 ), ptcharr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/flux\" , 2 , & dim2 , nweight % flux , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 3 , & dim3 , nweight % weight , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"NPA E-p space sensitivity/weights and Flux calculated by FIDASIM\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/npitch\" , \"description\" , & \"Number of pitch value\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Pitch array: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"description\" , & \"Neutral flux: flux(energy,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"units\" , & \"neutrals/(s*dE)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"E-p space sensivity/weight of NPA diagnostics: weight(energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , & \"neutrals/(s*fast-ion*dE*dP)\" , error ) if ( inputs % calc_npa_wght . ge . 2 ) then !Write diagnostic variables call write_beam_grid ( fid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/emissivity\" , 4 , & dim5 ( 2 : 5 ), nweight % emissivity , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/attenuation\" , 5 , & dim5 , nweight % attenuation , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/cx\" , 5 , & dim5 , nweight % cx , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/phit\" , 4 , & dim5 ( 2 : 5 ), npa_chords % phit % p , error ) call h5ltset_attribute_string_f ( fid , \"/emissivity\" , \"description\" , & \"Neutral emissivity: emissivity(x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/emissivity\" , \"units\" , & \"neutrals/(s*dV)\" , error ) call h5ltset_attribute_string_f ( fid , \"/cx\" , \"description\" , & \"Charge-exchange rate: cx(energy,x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/cx\" , \"units\" , \"s&#94;(-1)\" , error ) call h5ltset_attribute_string_f ( fid , \"/attenuation\" , \"description\" , & \"Attenuation factor i.e. survival probability: attenuation(energy,x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/phit\" , \"description\" , & \"Probability of hitting the detector given an isotropic source: phit(x,y,z,chan)\" , error ) endif !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'NPA weights written to: ' , trim ( filename ) endif end subroutine write_npa_weights subroutine read_neutrals !+ Reads neutral density from file and puts it in [[libfida:neut]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 4 ) :: dims integer :: error , nx , ny , nz logical :: exis if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- loading neutrals ----' endif inquire ( file = inputs % neutrals_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Neutrals file: \",a)' ) trim ( inputs % neutrals_file ) write ( * , * ) '' endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_NEUTRALS: Neutrals file does not exist: ' , inputs % neutrals_file endif stop endif !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fopen_f ( inputs % neutrals_file , H5F_ACC_RDONLY_F , fid , error ) call h5gopen_f ( fid , \"/grid\" , gid , error ) call h5ltread_dataset_int_scalar_f ( gid , \"nx\" , nx , error ) call h5ltread_dataset_int_scalar_f ( gid , \"ny\" , ny , error ) call h5ltread_dataset_int_scalar_f ( gid , \"nz\" , nz , error ) call h5gclose_f ( gid , error ) if (( nx . ne . beam_grid % nx ). or . & ( ny . ne . beam_grid % ny ). or . & ( nz . ne . beam_grid % nz )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_NEUTRALS: Neutrals file has incompatable grid dimensions' endif stop endif dims = [ nlevs , nx , ny , nz ] call h5ltread_dataset_double_f ( fid , \"/fdens\" , & neut % dens (:, nbif_type ,:,:,:), dims , error ) call h5ltread_dataset_double_f ( fid , \"/hdens\" , & neut % dens (:, nbih_type ,:,:,:), dims , error ) call h5ltread_dataset_double_f ( fid , \"/tdens\" , & neut % dens (:, nbit_type ,:,:,:), dims , error ) call h5ltread_dataset_double_f ( fid , \"/halodens\" , & neut % dens (:, halo_type ,:,:,:), dims , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) end subroutine read_neutrals !============================================================================= !-----------------------------Geometry Routines------------------------------- !============================================================================= function approx_eq ( x , y , tol ) result ( a ) !+ Inexact equality comparison: `x ~= y` true if `abs(x-y) <= tol` else false real ( Float64 ), intent ( in ) :: x !+First value in comparison real ( Float64 ), intent ( in ) :: y !+Second value in comparison real ( Float64 ), intent ( in ) :: tol !+Equality tolerance logical :: a a = abs ( x - y ). le . tol end function approx_eq function approx_ge ( x , y , tol ) result ( a ) !+ Inexact greater than or equal to comparison: `x >~= y` real ( Float64 ), intent ( in ) :: x !+First value in comparison real ( Float64 ), intent ( in ) :: y !+Second value in comparison real ( Float64 ), intent ( in ) :: tol !+Equality tolerance logical :: a a = ( x . gt . y ). or .( approx_eq ( x , y , tol )) end function approx_ge function approx_le ( x , y , tol ) result ( a ) !+ Inexact less then or equal to comparison: `x <~= y` real ( Float64 ), intent ( in ) :: x !+First value in comparison real ( Float64 ), intent ( in ) :: y !+Second value in comparison real ( Float64 ), intent ( in ) :: tol !+Equality tolerance logical :: a a = ( x . lt . y ). or .( approx_eq ( x , y , tol )) end function approx_le function cross_product ( u , v ) result ( s ) !+ Calculates the cross product of two vectors: `u`x`v` real ( Float64 ), dimension ( 3 ), intent ( in ) :: u real ( Float64 ), dimension ( 3 ), intent ( in ) :: v real ( Float64 ), dimension ( 3 ) :: s s ( 1 ) = u ( 2 ) * v ( 3 ) - u ( 3 ) * v ( 2 ) s ( 2 ) = u ( 3 ) * v ( 1 ) - u ( 1 ) * v ( 3 ) s ( 3 ) = u ( 1 ) * v ( 2 ) - u ( 2 ) * v ( 1 ) end function cross_product subroutine tb_zyx ( alpha , beta , gamma , basis , inv_basis ) !+ Creates active rotation matrix for z-y'-x\" rotation given Tait-Bryan angles real ( Float64 ), intent ( in ) :: alpha !+ Angle of rotation about z real ( Float64 ), intent ( in ) :: beta !+ Angle of rotation about y' real ( Float64 ), intent ( in ) :: gamma !+ Angle of rotation about x\" real ( Float64 ), dimension ( 3 , 3 ), intent ( out ) :: basis !+ Rotation matrix/basis for transforming from rotated to non-rotated coordinates real ( Float64 ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis !+ Inverse basis for reverse transformation real ( Float64 ) :: sa , sb , sg , ca , cb , cg sa = sin ( alpha ) ; sb = sin ( beta ) ; sg = sin ( gamma ) ca = cos ( alpha ) ; cb = cos ( beta ) ; cg = cos ( gamma ) basis ( 1 , 1 ) = ca * cb ; basis ( 1 , 2 ) = ca * sb * sg - cg * sa ; basis ( 1 , 3 ) = sa * sg + ca * cg * sb basis ( 2 , 1 ) = cb * sa ; basis ( 2 , 2 ) = ca * cg + sa * sb * sg ; basis ( 2 , 3 ) = cg * sa * sb - ca * sg basis ( 3 , 1 ) = - sb ; basis ( 3 , 2 ) = cb * sg ; basis ( 3 , 3 ) = cb * cg if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine tb_zyx subroutine line_basis ( r0 , v0 , basis , inv_basis ) !+ Calculates basis from a line with +x in the direction of line real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Starting point of line [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Direction of line real ( Float64 ), dimension ( 3 , 3 ), intent ( out ) :: basis !+ Basis for transforming from line coordinates to cartesian real ( Float64 ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis !+ Inverse basis for the reverse transformation cartesian to line real ( Float64 ), dimension ( 3 ) :: rf real ( Float64 ) :: alpha , beta , dis rf = r0 + v0 dis = sqrt ( sum (( rf - r0 ) ** 2 )) beta = asin (( r0 ( 3 ) - rf ( 3 )) / dis ) alpha = atan2 ( rf ( 2 ) - r0 ( 2 ), rf ( 1 ) - r0 ( 1 )) call tb_zyx ( alpha , beta , 0.d0 , basis ) if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine line_basis subroutine plane_basis ( center , redge , tedge , basis , inv_basis ) !+ Calculates basis from 3 points on a plane with +z being the plane normal real ( Float64 ), dimension ( 3 ), intent ( in ) :: center !+ Plane origin real ( Float64 ), dimension ( 3 ), intent ( in ) :: redge !+ Right edge of plane real ( Float64 ), dimension ( 3 ), intent ( in ) :: tedge !+ Top edge of plane real ( Float64 ), dimension ( 3 , 3 ), intent ( out ) :: basis !+ Basis for transforming from plane to cartesian coordinates real ( Float64 ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis !+ Inverse basis for the reverse transformation cartesian to plane real ( Float64 ), dimension ( 3 ) :: u1 , u2 , u3 u1 = ( redge - center ) u1 = u1 / norm2 ( u1 ) u2 = ( tedge - center ) u2 = u2 / norm2 ( u2 ) u3 = cross_product ( u1 , u2 ) u3 = u3 / norm2 ( u3 ) basis (:, 1 ) = u1 basis (:, 2 ) = u2 basis (:, 3 ) = u3 if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine plane_basis subroutine line_plane_intersect ( l0 , l , p0 , n , p , t ) !+ Calculates the intersection of a line and a plane real ( Float64 ), dimension ( 3 ), intent ( in ) :: l0 !+ Point on line real ( Float64 ), dimension ( 3 ), intent ( in ) :: l !+ Ray of line real ( Float64 ), dimension ( 3 ), intent ( in ) :: p0 !+ Point on plane real ( Float64 ), dimension ( 3 ), intent ( in ) :: n !+ Normal vector of plane real ( Float64 ), dimension ( 3 ), intent ( out ) :: p !+ Line-plane intersect point real ( Float64 ), intent ( out ) :: t !+ \"time\" to intersect real ( Float64 ) :: ldotn ldotn = dot_product ( l , n ) if ( ldotn . eq . 0.0 ) then t = 0.0 else t = dot_product ( p0 - l0 , n ) / ldotn endif p = l0 + t * l end subroutine line_plane_intersect function in_boundary ( bplane , p ) result ( in_b ) !+ Indicator function for determining if a point on a plane is within the plane boundary type ( BoundedPlane ), intent ( in ) :: bplane !+ Plane with boundary real ( Float64 ), dimension ( 3 ), intent ( in ) :: p !+ Point on plane logical :: in_b real ( Float64 ), dimension ( 3 ) :: pp real ( Float64 ) :: hh , hw hh = bplane % hh hw = bplane % hw pp = matmul ( bplane % inv_basis , p - bplane % origin ) in_b = . False . SELECT CASE ( bplane % shape ) CASE ( 1 ) !Rectangular boundary if (( abs ( pp ( 1 )). le . hw ). and . & ( abs ( pp ( 2 )). le . hh )) then in_b = . True . endif CASE ( 2 ) !Circular/Ellipsoidal boundary if ((( hh * pp ( 1 )) ** 2 + ( hw * pp ( 2 )) ** 2 ). le .(( hh * hw ) ** 2 )) then in_b = . True . endif CASE DEFAULT if ( inputs % verbose . ge . 0 ) then write ( * , '(\"IN_BOUNDARY: Unknown boundary shape: \",i2)' ), bplane % shape endif stop END SELECT end function in_boundary subroutine boundary_edge ( bplane , bedge , nb ) !+ Returns 3 x `nb` array containing points along the BoundedPlane's boundary edge type ( BoundedPlane ), intent ( in ) :: bplane !+ Bounded plane real ( Float64 ), dimension (:,:), intent ( out ) :: bedge !+ Boundary edge points of bounded plane integer , intent ( out ) :: nb !+ Number of points in boundary edge integer :: i real ( Float64 ) :: th , dth , x , y real ( Float64 ), dimension ( 4 ) :: xx , yy select case ( bplane % shape ) case ( 1 ) !Rectangular boundary nb = 4 if ( nb . gt . size ( bedge , 2 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(\"BOUNDARY_EDGE: Incompatible boundary edge array : \",i2,\" > \",i2)' ) nb , size ( bedge , 2 ) endif stop endif xx = [ - bplane % hw , - bplane % hw , bplane % hw , bplane % hw ] yy = [ - bplane % hh , bplane % hh , bplane % hh , - bplane % hh ] do i = 1 , nb bedge (:, i ) = matmul ( bplane % basis ,[ xx ( i ), yy ( i ), 0.d0 ]) + bplane % origin enddo case ( 2 ) nb = 50 if ( nb . gt . size ( bedge , 2 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(\"BOUNDARY_EDGE: Incompatible boundary edge array : \",i2,\" > \",i2)' ) nb , size ( bedge , 2 ) endif stop endif dth = 2 * pi / nb do i = 1 , nb th = i * dth x = bplane % hw * cos ( th ) y = bplane % hh * sin ( th ) bedge (:, i ) = matmul ( bplane % basis ,[ x , y , 0.d0 ]) + bplane % origin enddo case default if ( inputs % verbose . ge . 0 ) then write ( * , '(\"BOUNDARY_EDGE: Unknown boundary shape: \",i2)' ), bplane % shape endif stop end select end subroutine boundary_edge subroutine gyro_surface ( fields , energy , pitch , gs ) !+ Calculates the surface of all possible trajectories type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields at guiding center real ( Float64 ), intent ( in ) :: energy !+ Energy of particle real ( Float64 ), intent ( in ) :: pitch !+ Particle pitch w.r.t the magnetic field type ( GyroSurface ), intent ( out ) :: gs !+ Gyro-surface integer :: i real ( Float64 ) :: alpha , vabs , omega real ( Float64 ), dimension ( 3 , 3 ) :: s vabs = sqrt ( energy / ( v2_to_E_per_amu * inputs % ab )) omega = ( fields % b_abs * e0 ) / ( inputs % ab * mass_u ) alpha = vabs / omega gs % omega = omega gs % v = vabs gs % axes ( 1 ) = alpha * sqrt ( 1 - pitch ** 2 ) gs % axes ( 2 ) = alpha * sqrt ( 1 - pitch ** 2 ) gs % axes ( 3 ) = pitch * alpha s = 0.d0 s ( 1 , 1 ) = gs % axes ( 1 ) ** ( - 2 ) s ( 2 , 2 ) = gs % axes ( 2 ) ** ( - 2 ) s ( 3 , 3 ) = - gs % axes ( 3 ) ** ( - 2 ) gs % center = fields % pos gs % basis (:, 1 ) = fields % a_norm gs % basis (:, 2 ) = fields % c_norm gs % basis (:, 3 ) = fields % b_norm gs % A = matmul ( gs % basis , matmul ( s , transpose ( gs % basis ))) end subroutine gyro_surface subroutine line_gyro_surface_intersect ( r0 , v0 , gs , t ) !+ Calculates the times of intersection of a line and a gyro-surface real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Point on line real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Direction of line type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-surface real ( Float64 ), dimension ( 2 ), intent ( out ) :: t !+ \"time\" to intersect real ( Float64 ), dimension ( 3 ) :: rr real ( Float64 ) :: a , b , c , d , tp , tm rr = r0 - gs % center a = dot_product ( v0 , matmul ( gs % A , v0 )) b = dot_product ( rr , matmul ( gs % A , v0 )) + dot_product ( v0 , matmul ( gs % A , rr )) c = dot_product ( rr , matmul ( gs % A , rr )) - 1.0 d = b ** 2 - 4 * a * c if ( d . lt . 0.0 ) then t = 0.0 return endif t ( 1 ) = ( - b - sqrt ( d )) / ( 2 * a ) t ( 2 ) = ( - b + sqrt ( d )) / ( 2 * a ) end subroutine line_gyro_surface_intersect subroutine gyro_surface_coordinates ( gs , p , u ) !+ Calculates the parametric coordinates, `u`, of point `p` on the gyro_surface type ( GyroSurface ), intent ( in ) :: gs !+ Gyro_surface real ( Float64 ), dimension ( 3 ), intent ( in ) :: p !+ Point on gyro_surface real ( Float64 ), dimension ( 2 ), intent ( out ) :: u !+ Parametric coordinates (gyro-angle, t) real ( Float64 ), dimension ( 3 ) :: pp real ( Float64 ) :: t , a , b , c , d , thm , thp , dp , dm , th integer :: i pp = matmul ( transpose ( gs % basis ), p - gs % center ) t = pp ( 3 ) / gs % axes ( 3 ) a = gs % axes ( 1 ) + gs % axes ( 2 ) * t b = gs % axes ( 2 ) - gs % axes ( 1 ) * t d = pp ( 1 ) + pp ( 2 ) c = max ( min ( d / sqrt ( a ** 2 + b ** 2 ), 1.d0 ), - 1.d0 ) thm = - acos ( c ) + atan2 ( b , a ) thp = acos ( c ) + atan2 ( b , a ) dm = norm2 ([ gs % axes ( 1 ) * ( cos ( thm ) - t * sin ( thm )), & gs % axes ( 2 ) * ( sin ( thm ) + t * cos ( thm )), & gs % axes ( 3 ) * t ] - pp ) dp = norm2 ([ gs % axes ( 1 ) * ( cos ( thp ) - t * sin ( thp )), & gs % axes ( 2 ) * ( sin ( thp ) + t * cos ( thp )), & gs % axes ( 3 ) * t ] - pp ) th = thm - pi / 2 if ( dp . le . dm ) th = thp - pi / 2 if ( th . lt . 0.0 ) th = th + 2 * pi u = [ th , t / gs % omega ] end subroutine gyro_surface_coordinates subroutine gyro_trajectory ( gs , theta , ri , vi ) !+ Calculate particle trajectory for a given gyro-angle and gyro-surface type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-Surface real ( Float64 ), intent ( in ) :: theta !+ Gyro-angle real ( Float64 ), dimension ( 3 ) :: ri !+ Particle position real ( Float64 ), dimension ( 3 ) :: vi !+ Particle Velocity real ( Float64 ) :: a , b , c , th a = gs % axes ( 1 ) b = gs % axes ( 2 ) c = gs % axes ( 3 ) th = theta + pi / 2 ri = matmul ( gs % basis , [ a * cos ( th ), b * sin ( th ), 0.d0 ]) + gs % center vi = gs % omega * matmul ( gs % basis , [ - a * sin ( th ), b * cos ( th ), c ]) end subroutine gyro_trajectory function in_gyro_surface ( gs , p ) result ( in_gs ) !+ Indicator function for determining if a point is inside the gyro_surface type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-surface real ( Float64 ), dimension ( 3 ), intent ( in ) :: p !+ Point logical :: in_gs real ( Float64 ), dimension ( 3 ) :: pp pp = p - gs % center in_gs = dot_product ( pp , matmul ( gs % A , pp )). le . 1.d0 end function in_gyro_surface subroutine gyro_range ( b , gs , gyrange , nrange ) !+ Calculates the range(s) of gyro-angles that would land within a bounded plane type ( BoundedPlane ), intent ( in ) :: b !+ Bounded Plane type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-surface real ( Float64 ), dimension ( 2 , 4 ), intent ( out ) :: gyrange !+ (theta, dtheta) values integer , intent ( out ) :: nrange !+ Number of ranges. `1 <= nrange <= 4` integer :: nb , i , j , ninter logical :: in_gs , bin_gs logical , dimension ( 8 ) :: cross = . False . real ( Float64 ) :: t_p , th1 , th2 , dth real ( Float64 ), dimension ( 2 ) :: u_cur , t_i real ( Float64 ), dimension ( 3 ) :: rc , p_pre , p_cur , v0 , ri real ( Float64 ), dimension ( 2 , 8 ) :: u real ( Float64 ), dimension ( 3 , 50 ) :: bedge nrange = 0 call line_plane_intersect ( gs % center , gs % basis (:, 3 ), b % origin , b % basis (:, 3 ), rc , t_p ) if ( t_p . eq . 0.0 ) return call boundary_edge ( b , bedge , nb ) p_pre = bedge (:, 1 ) in_gs = in_gyro_surface ( gs , p_pre ) bin_gs = . False . ninter = 0 u = 0.d0 boundary_loop : do i = 1 , nb p_cur = bedge (:, modulo ( i , nb ) + 1 ) v0 = p_cur - p_pre call line_gyro_surface_intersect ( p_pre , v0 , gs , t_i ) do j = 1 , 2 if (( t_i ( j ). gt . 0.0 ). and .( t_i ( j ). lt . 1.0 )) then ri = p_pre + t_i ( j ) * v0 call gyro_surface_coordinates ( gs , ri , u_cur ) if ( u_cur ( 2 ). gt . 0.0 ) then in_gs = . not . in_gs ninter = ninter + 1 cross ( ninter ) = in_gs u (:, ninter ) = u_cur endif endif enddo p_pre = p_cur enddo boundary_loop gyrange = 0.d0 if (( ninter . eq . 0 ). and .(. not . bin_gs )) then if ( in_boundary ( b , rc )) then nrange = 1 gyrange (:, 1 ) = [ 0.d0 , 2 * pi ] endif return endif do i = 1 , ninter if ( cross ( i )) then th1 = u ( 1 , i ) j = modulo ( i , ninter ) + 1 th2 = u ( 1 , j ) dth = th2 - th1 nrange = nrange + 1 if ( dth . gt . 0.0 ) then gyrange (:, nrange ) = [ th1 , dth ] else gyrange (:, nrange ) = [ th2 , - dth ] endif endif enddo end subroutine gyro_range subroutine npa_gyro_range ( ichan , gs , gyrange , nrange ) !+ Calculates range of gyro-angles that would hit the NPA detector integer , intent ( in ) :: ichan !+ Index of NPA detector type ( GyroSurface ), intent ( in ) :: gs real ( Float64 ), dimension ( 2 , 4 ), intent ( out ) :: gyrange integer , intent ( out ) :: nrange type ( LocalEMFields ) :: fields integer :: i , j , a_nrange , d_nrange real ( Float64 ) :: a0 , a , b , c , d real ( Float64 ), dimension ( 2 , 4 ) :: a_gyrange , d_gyrange nrange = 0 gyrange = 0.d0 call gyro_range ( npa_chords % det ( ichan )% aperture , gs , a_gyrange , a_nrange ) if ( a_nrange . eq . 0 ) return call gyro_range ( npa_chords % det ( ichan )% detector , gs , d_gyrange , d_nrange ) if ( d_nrange . eq . 0 ) return if (( a_nrange . eq . 1 ). and . approx_eq ( a_gyrange ( 2 , 1 ), 2 * pi , 1 d - 6 )) then gyrange = d_gyrange nrange = d_nrange return endif if (( d_nrange . eq . 1 ). and . approx_eq ( d_gyrange ( 2 , 1 ), 2 * pi , 1 d - 6 )) then gyrange = a_gyrange nrange = a_nrange return endif do i = 1 , a_nrange do j = 1 , d_nrange a0 = 0.d0 if ( d_gyrange ( 1 , j ). gt . a_gyrange ( 1 , i )) then a0 = a_gyrange ( 1 , i ) a = 0.d0 b = modulo ( a_gyrange ( 1 , i ) + a_gyrange ( 2 , i ) - a0 , 2 * pi ) c = modulo ( d_gyrange ( 1 , j ) - a0 , 2 * pi ) d = modulo ( d_gyrange ( 1 , j ) + d_gyrange ( 2 , j ) - a0 , 2 * pi ) else a0 = d_gyrange ( 1 , j ) a = 0.d0 b = modulo ( d_gyrange ( 1 , j ) + d_gyrange ( 2 , j ) - a0 , 2 * pi ) c = modulo ( a_gyrange ( 1 , i ) - a0 , 2 * pi ) d = modulo ( a_gyrange ( 1 , i ) + a_gyrange ( 2 , i ) - a0 , 2 * pi ) endif if (( c . lt . b ). or .( d . lt . c )) then if ( c . lt . d ) then nrange = nrange + 1 gyrange (:, nrange ) = [ a0 + c , min ( d - c , b - c )] else nrange = nrange + 1 gyrange (:, nrange ) = [ a0 , d ] nrange = nrange + 1 gyrange (:, nrange ) = [ a0 + c , b - c ] endif endif enddo enddo end subroutine npa_gyro_range subroutine hit_npa_detector ( r0 , v0 , d_index , rd , det ) !+ Routine to check if a particle will hit a NPA detector real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Starting point of particle real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Particle velocity integer , intent ( out ) :: d_index !+ Index of NPA detector. Zero if particle doesn't hit real ( Float64 ), dimension ( 3 ), intent ( out ), optional :: rd !+ Point where particle hit detector integer , intent ( in ), optional :: det !+ Index of NPA detector to check real ( Float64 ), dimension ( 3 ) :: d , a real ( Float64 ) :: t_a , t_d integer :: i , s , ndet if ( present ( det )) then s = det ndet = det else s = 1 ndet = npa_chords % nchan endif d_index = 0 detector_loop : do i = s , ndet !! Find where trajectory crosses detector plane call line_plane_intersect ( r0 , v0 , npa_chords % det ( i )% detector % origin , & npa_chords % det ( i )% detector % basis (:, 3 ), d , t_d ) !! Find where trajectory crosses aperture plane call line_plane_intersect ( r0 , v0 , npa_chords % det ( i )% aperture % origin , & npa_chords % det ( i )% aperture % basis (:, 3 ), a , t_a ) !! If both points are in plane boundaries and the !! particle is heading toward the detector then its a hit if ( in_boundary ( npa_chords % det ( i )% aperture , a ) . and . & in_boundary ( npa_chords % det ( i )% detector , d ) . and . & ( t_d . gt . 0.0 ) ) then d_index = i exit detector_loop endif enddo detector_loop if ( present ( rd )) rd = d end subroutine hit_npa_detector subroutine xyz_to_uvw ( xyz , uvw ) !+ Convert beam coordinate `xyz` to machine coordinate `uvw` real ( Float64 ), dimension ( 3 ), intent ( in ) :: xyz real ( Float64 ), dimension ( 3 ), intent ( out ) :: uvw real ( Float64 ), dimension ( 3 ) :: origin real ( Float64 ), dimension ( 3 , 3 ) :: basis origin = beam_grid % origin basis = beam_grid % basis uvw = matmul ( basis , xyz ) uvw = uvw + origin end subroutine xyz_to_uvw subroutine uvw_to_xyz ( uvw , xyz ) !+ Convert machine coordinate `uvw` to beam coordinate `xyz` real ( Float64 ), dimension ( 3 ), intent ( in ) :: uvw real ( Float64 ), dimension ( 3 ), intent ( out ) :: xyz real ( Float64 ), dimension ( 3 ) :: origin , uvw_p real ( Float64 ), dimension ( 3 , 3 ) :: basis origin = beam_grid % origin basis = beam_grid % inv_basis uvw_p = uvw - origin xyz = matmul ( basis , uvw_p ) end subroutine uvw_to_xyz subroutine grid_intersect ( r0 , v0 , length , r_enter , r_exit , center_in , lwh_in ) !+ Calculates a particles intersection length with the [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Initial position of particle [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Velocity of particle [cm/s] real ( Float64 ), intent ( out ) :: length !+ Intersection length [cm] real ( Float64 ), dimension ( 3 ), intent ( out ) :: r_enter !+ Point where particle enters [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( out ) :: r_exit !+ Point where particle exits [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: center_in !+ Alternative grid center real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: lwh_in !+ Alternative grid [length,width,height] real ( Float64 ), dimension ( 3 , 6 ) :: ipnts real ( Float64 ), dimension ( 3 ) :: vi real ( Float64 ), dimension ( 3 ) :: center real ( Float64 ), dimension ( 3 ) :: lwh integer , dimension ( 6 ) :: side_inter integer , dimension ( 2 ) :: ind integer :: i , j , nunique , ind1 , ind2 if ( present ( center_in )) then center = center_in else center = beam_grid % center endif if ( present ( lwh_in )) then lwh = lwh_in else lwh = beam_grid % lwh endif side_inter = 0 ipnts = 0.d0 do i = 1 , 6 j = int ( ceiling ( i / 2.0 )) if ( j . eq . 1 ) ind = [ 2 , 3 ] if ( j . eq . 2 ) ind = [ 1 , 3 ] if ( j . eq . 3 ) ind = [ 1 , 2 ] if ( abs ( v0 ( j )). gt . 0.d0 ) then ipnts (:, i ) = r0 + v0 * ( ( ( center ( j ) + & ( mod ( i , 2 ) - 0.5 ) * lwh ( j )) - r0 ( j )) / v0 ( j ) ) if (( abs ( ipnts ( ind ( 1 ), i ) - center ( ind ( 1 ))). le .( 0.5 * lwh ( ind ( 1 )))). and . & ( abs ( ipnts ( ind ( 2 ), i ) - center ( ind ( 2 ))). le .( 0.5 * lwh ( ind ( 2 ))))) then side_inter ( i ) = 1 endif endif enddo length = 0.d0 r_enter = r0 r_exit = r0 ind1 = 0 ind2 = 0 if ( sum ( side_inter ). ge . 2 ) then ! Find first intersection side i = 1 do while ( i . le . 6 ) if ( side_inter ( i ). eq . 1 ) exit i = i + 1 enddo ind1 = i !Find number of unique points nunique = 0 do i = ind1 + 1 , 6 if ( side_inter ( i ). ne . 1 ) cycle if ( sqrt ( sum ( ( ipnts (:, i ) - ipnts (:, ind1 ) ) ** 2 ) ). gt . 0.001 ) then ind2 = i nunique = 2 exit endif enddo if ( nunique . eq . 2 ) then vi = ipnts (:, ind2 ) - ipnts (:, ind1 ) if ( dot_product ( v0 , vi ). gt . 0.0 ) then r_enter = ipnts (:, ind1 ) r_exit = ipnts (:, ind2 ) else r_enter = ipnts (:, ind2 ) r_exit = ipnts (:, ind1 ) endif length = sqrt ( sum (( r_exit - r_enter ) ** 2 )) endif endif end subroutine grid_intersect function in_grid ( xyz ) result ( ing ) !+ Determines if a position `pos` is in the [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: xyz !+ Position in beam grid coordinates [cm] logical :: ing !+ Indicates whether the position is in the beam grid real ( Float64 ) :: tol = 1.0d-10 if (( approx_ge ( xyz ( 1 ), beam_grid % xmin , tol ). and . approx_le ( xyz ( 1 ), beam_grid % xmax , tol )). and . & ( approx_ge ( xyz ( 2 ), beam_grid % ymin , tol ). and . approx_le ( xyz ( 2 ), beam_grid % ymax , tol )). and . & ( approx_ge ( xyz ( 3 ), beam_grid % zmin , tol ). and . approx_le ( xyz ( 3 ), beam_grid % zmax , tol ))) then ing = . True . else ing = . False . endif end function subroutine circle_grid_intersect ( r0 , e1 , e2 , radius , phi_enter , phi_exit ) !+ Calculates the intersection arclength of a circle with the [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Position of center enter of the circle in beam grid coordinates [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: e1 !+ Unit vector pointing towards (R, 0) (r,phi) position of the circle in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: e2 !+ Unit vector pointing towards (R, pi/2) (r,phi) position of the circle in beam grid coordinates real ( Float64 ), intent ( in ) :: radius !+ Radius of circle [cm] real ( Float64 ), intent ( out ) :: phi_enter !+ Phi value where the circle entered the [[libfida:beam_grid]] [rad] real ( Float64 ), intent ( out ) :: phi_exit !+ Phi value where the circle exits the [[libfida:beam_grid]] [rad] real ( Float64 ), dimension ( 3 ) :: i1_p , i1_n , i2_p , i2_n real ( Float64 ), dimension ( 4 ) :: d real ( Float64 ), dimension ( 6 ) :: p , gams real ( Float64 ), dimension ( 4 , 6 ) :: phi logical , dimension ( 4 , 6 ) :: inter integer , dimension ( 6 ) :: n integer :: i real ( Float64 ) :: alpha , beta , delta , sinx1 , cosx1 , sinx2 , cosx2 , tmp real ( Float64 ) :: tol = 1.0d-10 logical :: r0_ing p = [ beam_grid % xmin , beam_grid % xmax , & beam_grid % ymin , beam_grid % ymax , & beam_grid % zmin , beam_grid % zmax ] n = [ 1 , 1 , 2 , 2 , 3 , 3 ] inter = . False . phi = 0.d0 r0_ing = in_grid ( r0 ) do i = 1 , 6 alpha = e2 ( n ( i )) beta = e1 ( n ( i )) if (( alpha . eq . 0.0 ). and .( beta . eq . 0.0 )) cycle gams ( i ) = ( p ( i ) - r0 ( n ( i ))) / radius delta = alpha ** 4 + ( alpha ** 2 ) * ( beta ** 2 - gams ( i ) ** 2 ) if ( delta . ge . 0.0 ) then cosx1 = ( gams ( i ) * beta + sqrt ( delta )) / ( alpha ** 2 + beta ** 2 ) if (( cosx1 ** 2 ). le . 1.0 ) then sinx1 = sqrt ( 1 - cosx1 ** 2 ) i1_p = r0 + radius * cosx1 * e1 + radius * sinx1 * e2 i1_n = r0 + radius * cosx1 * e1 - radius * sinx1 * e2 if ( approx_eq ( i1_p ( n ( i )), p ( i ), tol ). and . in_grid ( i1_p )) then inter ( 1 , i ) = . True . phi ( 1 , i ) = atan2 ( sinx1 , cosx1 ) endif if ( approx_eq ( i1_n ( n ( i )), p ( i ), tol ). and . in_grid ( i1_n )) then inter ( 2 , i ) = . True . phi ( 2 , i ) = atan2 ( - sinx1 , cosx1 ) endif endif if ( delta . gt . 0.0 ) then cosx2 = ( gams ( i ) * beta - sqrt ( delta )) / ( alpha ** 2 + beta ** 2 ) if (( cosx2 ** 2 ). le . 1.0 ) then sinx2 = sqrt ( 1 - cosx2 ** 2 ) i2_p = r0 + radius * cosx2 * e1 + radius * sinx2 * e2 i2_n = r0 + radius * cosx2 * e1 - radius * sinx2 * e2 if ( approx_eq ( i2_p ( n ( i )), p ( i ), tol ). and . in_grid ( i2_p )) then inter ( 3 , i ) = . True . phi ( 3 , i ) = atan2 ( sinx2 , cosx2 ) endif if ( approx_eq ( i2_n ( n ( i )), p ( i ), tol ). and . in_grid ( i2_n )) then inter ( 4 , i ) = . True . phi ( 4 , i ) = atan2 ( - sinx2 , cosx2 ) endif endif endif endif enddo phi_enter = 0.d0 phi_exit = 0.d0 if ( count ( inter ). gt . 2 ) return if ( any ( inter )) then phi_enter = minval ( phi , inter ) phi_exit = maxval ( phi , inter ) if ( r0_ing . and . any ( count ( inter , 1 ). ge . 2 )) then if (( phi_exit - phi_enter ) . lt . pi ) then tmp = phi_enter phi_enter = phi_exit phi_exit = tmp + 2 * pi endif else if (( phi_exit - phi_enter ) . gt . pi ) then tmp = phi_enter phi_enter = phi_exit phi_exit = tmp + 2 * pi endif endif if ( approx_eq ( phi_exit - phi_enter , pi , tol ). and . r0_ing ) then phi_enter = 0.0 phi_exit = 2 * pi endif else if ( r0_ing ) then call grid_intersect ( r0 , e1 , tmp , i1_n , i1_p ) call grid_intersect ( r0 , e2 , tmp , i2_n , i2_p ) d ( 1 ) = norm2 ( r0 - i1_n ) / radius d ( 2 ) = norm2 ( r0 - i1_p ) / radius d ( 3 ) = norm2 ( r0 - i2_n ) / radius d ( 4 ) = norm2 ( r0 - i2_p ) / radius if ( all ( d . ge . 1.0 )) then phi_enter = 0.d0 phi_exit = 2.d0 * pi endif endif endif end subroutine circle_grid_intersect subroutine get_indices ( pos , ind ) !+ Find closests [[libfida:beam_grid]] indices `ind` to position `pos` real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position [cm] integer ( Int32 ), dimension ( 3 ), intent ( out ) :: ind !+ Closest indices to position real ( Float64 ), dimension ( 3 ) :: mini integer ( Int32 ), dimension ( 3 ) :: maxind integer :: i maxind ( 1 ) = beam_grid % nx maxind ( 2 ) = beam_grid % ny maxind ( 3 ) = beam_grid % nz mini ( 1 ) = minval ( beam_grid % xc ) - 0.5 * beam_grid % dr ( 1 ) mini ( 2 ) = minval ( beam_grid % yc ) - 0.5 * beam_grid % dr ( 2 ) mini ( 3 ) = minval ( beam_grid % zc ) - 0.5 * beam_grid % dr ( 3 ) do i = 1 , 3 ind ( i ) = floor (( pos ( i ) - mini ( i )) / beam_grid % dr ( i )) + 1 if ( ind ( i ). gt . maxind ( i )) ind ( i ) = maxind ( i ) if ( ind ( i ). lt . 1 ) ind ( i ) = 1 enddo end subroutine get_indices subroutine get_position ( ind , pos ) !+ Get position `pos` given [[libfida:beam_grid]] indices `ind` integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices real ( Float64 ), dimension ( 3 ), intent ( out ) :: pos !+ Position [cm] pos ( 1 ) = beam_grid % xc ( ind ( 1 )) pos ( 2 ) = beam_grid % yc ( ind ( 2 )) pos ( 3 ) = beam_grid % zc ( ind ( 3 )) end subroutine get_position subroutine track ( rin , vin , tracks , ncell , los_intersect ) !+ Computes the path of a neutral through the [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: rin !+ Initial position of particle real ( Float64 ), dimension ( 3 ), intent ( in ) :: vin !+ Initial velocity of particle type ( ParticleTrack ), dimension (:), intent ( inout ) :: tracks !+ Array of [[ParticleTrack]] type integer ( Int32 ), intent ( out ) :: ncell !+ Number of cells that a particle crosses logical , intent ( out ), optional :: los_intersect !+ Indicator whether particle intersects a LOS in [[libfida:spec_chords]] integer :: cc , i , ii , mind integer , dimension ( 3 ) :: ind logical :: in_plasma1 , in_plasma2 , in_plasma_tmp , los_inter real ( Float64 ) :: dT , dt1 , inv_50 real ( Float64 ), dimension ( 3 ) :: dt_arr , dr real ( Float64 ), dimension ( 3 ) :: vn , inv_vn real ( Float64 ), dimension ( 3 ) :: ri , ri_tmp , ri_cell integer , dimension ( 3 ) :: sgn integer , dimension ( 3 ) :: gdims integer , dimension ( 1 ) :: minpos vn = vin ; ri = rin ; sgn = 0 ; ncell = 0 if ( dot_product ( vin , vin ). eq . 0.0 ) then return endif gdims ( 1 ) = beam_grid % nx gdims ( 2 ) = beam_grid % ny gdims ( 3 ) = beam_grid % nz !! define actual cell call get_indices ( ri , ind ) ri_cell = [ beam_grid % xc ( ind ( 1 )), & beam_grid % yc ( ind ( 2 )), & beam_grid % zc ( ind ( 3 ))] do i = 1 , 3 if ( vn ( i ). gt . 0.0 ) sgn ( i ) = 1 if ( vn ( i ). lt . 0.0 ) sgn ( i ) =- 1 if ( vn ( i ). eq . 0.0 ) vn ( i ) = 1.0d-3 enddo dr = beam_grid % dr * sgn inv_vn = 1 / vn inv_50 = 1.0 / 5 0.0 cc = 1 los_inter = . False . tracks % time = 0.d0 tracks % flux = 0.d0 call in_plasma ( ri , in_plasma1 ) track_loop : do i = 1 , beam_grid % ntrack if ( cc . gt . beam_grid % ntrack ) exit track_loop if (( spec_chords % inter ( ind ( 1 ), ind ( 2 ), ind ( 3 ))% nchan . ne . 0 ) & . and .(. not . los_inter )) then los_inter = . True . endif dt_arr = abs (( ( ri_cell + 0.5 * dr ) - ri ) * inv_vn ) minpos = minloc ( dt_arr ) mind = minpos ( 1 ) dT = dt_arr ( mind ) ri_tmp = ri + dT * vn call in_plasma ( ri_tmp , in_plasma2 ) if ( in_plasma1 . neqv . in_plasma2 ) then dt1 = 0.0 track_fine : do ii = 1 , 50 dt1 = dt1 + dT * inv_50 ri_tmp = ri + vn * dt1 call in_plasma ( ri_tmp , in_plasma_tmp ) if ( in_plasma2 . eqv . in_plasma_tmp ) exit track_fine enddo track_fine tracks ( cc )% pos = ri + 0.5 * dt1 * vn tracks ( cc + 1 )% pos = ri + 0.5 * ( dt1 + dT ) * vn tracks ( cc )% time = dt1 tracks ( cc + 1 )% time = dT - dt1 tracks ( cc )% ind = ind tracks ( cc + 1 )% ind = ind cc = cc + 2 else tracks ( cc )% pos = ri + 0.5 * dT * vn tracks ( cc )% time = dT tracks ( cc )% ind = ind cc = cc + 1 endif in_plasma1 = in_plasma2 ri = ri + dT * vn ind ( mind ) = ind ( mind ) + sgn ( mind ) ri_cell ( mind ) = ri_cell ( mind ) + dr ( mind ) if ( ind ( mind ). gt . gdims ( mind )) exit track_loop if ( ind ( mind ). lt . 1 ) exit track_loop enddo track_loop ncell = cc - 1 if ( present ( los_intersect )) then los_intersect = los_inter endif end subroutine track !============================================================================ !---------------------------Interpolation Routines--------------------------- !============================================================================ subroutine interpol1D_coeff ( xmin , dx , nx , xout , c , err ) !+ Linear interpolation coefficients and index for a 1D grid y(x) real ( Float64 ), intent ( in ) :: xmin !+ Minimum abscissa value real ( Float64 ), intent ( in ) :: dx !+ Absissa spacing integer , intent ( in ) :: nx !+ Number of abscissa real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate type ( InterpolCoeffs1D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: x1 , xp , b1 , b2 integer :: i , err_status err_status = 1 xp = max ( xout , xmin ) i = floor (( xp - xmin ) / dx ) + 1 if (( i . gt . 0 ). and .( i . le .( nx - 1 ))) then x1 = xmin + ( i - 1 ) * dx b2 = ( xp - x1 ) / dx b1 = ( 1.0 - b2 ) c % i = i c % b1 = b1 c % b2 = b2 err_status = 0 endif if ( present ( err )) err = err_status end subroutine interpol1D_coeff subroutine interpol1D_coeff_arr ( x , xout , c , err ) !+ Linear interpolation coefficients and index for a 1D grid y(x) real ( Float64 ), dimension (:), intent ( in ) :: x !+ Abscissa values real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate type ( InterpolCoeffs1D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: xmin , dx integer :: sx , err_status err_status = 1 sx = size ( x ) xmin = x ( 1 ) dx = abs ( x ( 2 ) - x ( 1 )) call interpol1D_coeff ( xmin , dx , sx , xout , c , err_status ) if ( present ( err )) err = err_status end subroutine interpol1D_coeff_arr subroutine interpol2D_coeff ( xmin , dx , nx , ymin , dy , ny , xout , yout , c , err ) !+ Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) real ( Float64 ), intent ( in ) :: xmin !+ Minimum abscissa real ( Float64 ), intent ( in ) :: dx !+ Abscissa spacing integer , intent ( in ) :: nx !+ Number of abscissa real ( Float64 ), intent ( in ) :: ymin !+ Minimum ordinate real ( Float64 ), intent ( in ) :: dy !+ Ordinate spacing integer , intent ( in ) :: ny !+ Number of ordinates points real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ Ordinate value to interpolate type ( InterpolCoeffs2D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: x1 , x2 , y1 , y2 , xp , yp integer :: i , j , err_status err_status = 1 xp = max ( xout , xmin ) yp = max ( yout , ymin ) i = floor (( xp - xmin ) / dx ) + 1 j = floor (( yp - ymin ) / dy ) + 1 if ((( i . gt . 0 ). and .( i . le .( nx - 1 ))). and .(( j . gt . 0 ). and .( j . le .( ny - 1 )))) then x1 = xmin + ( i - 1 ) * dx x2 = x1 + dx y1 = ymin + ( j - 1 ) * dy y2 = y1 + dy c % b11 = (( x2 - xp ) * ( y2 - yp )) / ( dx * dy ) c % b21 = (( xp - x1 ) * ( y2 - yp )) / ( dx * dy ) c % b12 = (( x2 - xp ) * ( yp - y1 )) / ( dx * dy ) c % b22 = (( xp - x1 ) * ( yp - y1 )) / ( dx * dy ) c % i = i c % j = j err_status = 0 endif if ( present ( err )) err = err_status end subroutine interpol2D_coeff subroutine interpol2D_coeff_arr ( x , y , xout , yout , c , err ) !!Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) real ( Float64 ), dimension (:), intent ( in ) :: x !+ Abscissa values real ( Float64 ), dimension (:), intent ( in ) :: y !+ Ordinate values real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ Ordinate value to interpolate type ( InterpolCoeffs2D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: xmin , ymin , dx , dy integer :: sx , sy , err_status err_status = 1 sx = size ( x ) sy = size ( y ) xmin = x ( 1 ) ymin = y ( 1 ) dx = abs ( x ( 2 ) - x ( 1 )) dy = abs ( y ( 2 ) - y ( 1 )) call interpol2D_coeff ( xmin , dx , sx , ymin , dy , sy , xout , yout , c , err_status ) if ( present ( err )) err = err_status end subroutine interpol2D_coeff_arr subroutine interpol1D_arr ( x , y , xout , yout , err , coeffs ) !+ Performs linear interpolation on a uniform 1D grid y(x) real ( Float64 ), dimension (:), intent ( in ) :: x !+ The abscissa values of `y` real ( Float64 ), dimension (:), intent ( in ) :: y !+ Values at abscissa values `x`: y(x) real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate real ( Float64 ), intent ( out ) :: yout !+ Interpolant: y(xout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs1D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients type ( InterpolCoeffs1D ) :: c integer :: i , err_status err_status = 1 if ( present ( coeffs )) then c = coeffs err_status = 0 else call interpol_coeff ( x , xout , c , err_status ) endif if ( err_status . eq . 0 ) then i = c % i yout = c % b1 * y ( i ) + c % b2 * y ( i + 1 ) else yout = 0.d0 endif if ( present ( err )) err = err_status end subroutine interpol1D_arr subroutine interpol2D_arr ( x , y , z , xout , yout , zout , err , coeffs ) !+ Performs bilinear interpolation on a 2D grid z(x,y) real ( Float64 ), dimension (:), intent ( in ) :: x !+ The abscissa values of `z` real ( Float64 ), dimension (:), intent ( in ) :: y !+ The ordinate values of `z` real ( Float64 ), dimension (:,:), intent ( in ) :: z !+ Values at the abscissa/ordinates: z(x,y) real ( Float64 ), intent ( in ) :: xout !+ The abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ The ordinate value to interpolate real ( Float64 ), intent ( out ) :: zout !+ Interpolant: z(xout,yout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs2D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients type ( InterpolCoeffs2D ) :: c integer :: i , j , err_status err_status = 1 if ( present ( coeffs )) then c = coeffs err_status = 0 else call interpol_coeff ( x , y , xout , yout , c , err_status ) endif if ( err_status . eq . 0 ) then i = c % i j = c % j zout = c % b11 * z ( i , j ) + c % b12 * z ( i , j + 1 ) + c % b21 * z ( i + 1 , j ) + c % b22 * z ( i + 1 , j + 1 ) else zout = 0.d0 endif if ( present ( err )) err = err_status end subroutine interpol2D_arr subroutine interpol2D_2D_arr ( x , y , z , xout , yout , zout , err , coeffs ) !+ Performs bilinear interpolation on a 2D grid of 2D arrays z(:,:,x,y) real ( Float64 ), dimension (:), intent ( in ) :: x !+ The abscissa values of `z` real ( Float64 ), dimension (:), intent ( in ) :: y !+ The ordinate values of `z` real ( Float64 ), dimension (:,:,:,:), intent ( in ) :: z !+ Values at the abscissa/ordinates: z(:,:,x,y) real ( Float64 ), intent ( in ) :: xout !+ The abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ The ordinate value to interpolate real ( Float64 ), dimension (:,:), intent ( out ) :: zout !+ Interpolant: z(:,:,xout,yout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs2D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients type ( InterpolCoeffs2D ) :: c integer :: i , j , err_status err_status = 1 if ( present ( coeffs )) then c = coeffs err_status = 0 else call interpol_coeff ( x , y , xout , yout , c , err_status ) endif if ( err_status . eq . 0 ) then i = c % i j = c % j zout = c % b11 * z (:,:, i , j ) + c % b12 * z (:,:, i , j + 1 ) + c % b21 * z (:,:, i + 1 , j ) + c % b22 * z (:,:, i + 1 , j + 1 ) else zout = 0.0 endif if ( present ( err )) err = err_status end subroutine interpol2D_2D_arr !============================================================================= !-------------------------Profiles and Fields Routines------------------------ !============================================================================= subroutine in_plasma ( xyz , inp , machine_coords , coeffs , uvw_out ) !+ Indicator subroutine to determine if a position is in a region where !+ the plasma parameter and fields are valid/known real ( Float64 ), dimension ( 3 ), intent ( in ) :: xyz !+ Position in beam coordinates logical , intent ( out ) :: inp !+ Indicates whether plasma parameters and fields are valid/known logical , intent ( in ), optional :: machine_coords !+ Indicates that xyz is in machine coordinates type ( InterpolCoeffs2D ), intent ( out ), optional :: coeffs !+ Linear Interpolation coefficients used in calculation real ( Float64 ), dimension ( 3 ), intent ( out ), optional :: uvw_out !+ Position in machine coordinates real ( Float64 ), dimension ( 3 ) :: uvw type ( InterpolCoeffs2D ) :: c real ( Float64 ) :: R , W , mask logical :: mc integer :: i , j , err err = 1 mc = . False . if ( present ( machine_coords )) mc = machine_coords if ( mc ) then uvw = xyz else !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) endif R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) W = uvw ( 3 ) !! Interpolate mask value call interpol_coeff ( inter_grid % r , inter_grid % z , R , W , c , err ) inp = . False . if ( err . eq . 0 ) then i = c % i j = c % j mask = c % b11 * equil % mask ( i , j ) + c % b12 * equil % mask ( i , j + 1 ) + & c % b21 * equil % mask ( i + 1 , j ) + c % b22 * equil % mask ( i + 1 , j + 1 ) if (( mask . ge . 0.5 ). and .( err . eq . 0 )) then inp = . True . endif endif if ( present ( coeffs )) coeffs = c if ( present ( uvw_out )) uvw_out = uvw end subroutine in_plasma subroutine get_plasma ( plasma , pos , ind ) !+ Gets plasma parameters at position `pos` or [[libfida:beam_grid]] indices `ind` type ( LocalProfiles ), intent ( out ) :: plasma !+ Plasma parameters at `pos`/`ind` real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices logical :: inp type ( InterpolCoeffs2D ) :: coeffs real ( Float64 ), dimension ( 3 ) :: xyz , uvw , vrot_uvw real ( Float64 ) :: phi , s , c integer :: i , j plasma % in_plasma = . False . if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos call in_plasma ( xyz , inp ,. False ., coeffs , uvw ) if ( inp ) then phi = atan2 ( uvw ( 2 ), uvw ( 1 )) i = coeffs % i j = coeffs % j plasma = coeffs % b11 * equil % plasma ( i , j ) + coeffs % b12 * equil % plasma ( i , j + 1 ) + & coeffs % b21 * equil % plasma ( i + 1 , j ) + coeffs % b22 * equil % plasma ( i + 1 , j + 1 ) s = sin ( phi ) ; c = cos ( phi ) vrot_uvw ( 1 ) = plasma % vr * c - plasma % vt * s vrot_uvw ( 2 ) = plasma % vr * s + plasma % vt * c vrot_uvw ( 3 ) = plasma % vz plasma % vrot = matmul ( beam_grid % inv_basis , vrot_uvw ) plasma % pos = xyz plasma % uvw = uvw plasma % in_plasma = . True . plasma % c = coeffs endif end subroutine get_plasma subroutine calc_perp_vectors ( b , a , c ) !+ Calculates normalized vectors that are perpendicular to b !+ such that `a` x `c` = `b_norm` real ( Float64 ), dimension ( 3 ), intent ( in ) :: b real ( Float64 ), dimension ( 3 ), intent ( out ) :: a real ( Float64 ), dimension ( 3 ), intent ( out ) :: c real ( Float64 ), dimension ( 3 ) :: bnorm bnorm = b / norm2 ( b ) if ( abs ( bnorm ( 3 )). eq . 1 ) then a = [ 1.d0 , 0.d0 , 0.d0 ] c = [ 0.d0 , 1.d0 , 0.d0 ] else if ( bnorm ( 3 ). eq . 0. ) then a = [ 0.d0 , 0.d0 , 1.d0 ] c = [ bnorm ( 2 ), - bnorm ( 1 ), 0.d0 ] / sqrt ( bnorm ( 1 ) ** 2 + bnorm ( 2 ) ** 2 ) else a = [ bnorm ( 2 ), - bnorm ( 1 ), 0.d0 ] / sqrt ( bnorm ( 1 ) ** 2 + bnorm ( 2 ) ** 2 ) c =- [ a ( 2 ) , - a ( 1 ) , ( a ( 1 ) * bnorm ( 2 ) - a ( 2 ) * bnorm ( 1 )) / bnorm ( 3 ) ] c = c / norm2 ( c ) if ( bnorm ( 3 ). lt . 0.0 ) then c =- c endif endif endif end subroutine calc_perp_vectors subroutine get_fields ( fields , pos , ind , machine_coords ) !+ Gets electro-magnetic fields at position `pos` or [[libfida:beam_grid]] indices `ind` type ( LocalEMFields ), intent ( out ) :: fields !+ Electro-magnetic fields at `pos`/`ind` real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices logical , intent ( in ), optional :: machine_coords !+ Indicates that pos is machine coordinates logical :: inp , mc real ( Float64 ), dimension ( 3 ) :: xyz , uvw real ( Float64 ), dimension ( 3 ) :: uvw_bfield , uvw_efield real ( Float64 ), dimension ( 3 ) :: xyz_bfield , xyz_efield real ( Float64 ) :: phi , s , c type ( InterpolCoeffs2D ) :: coeffs integer :: i , j fields % in_plasma = . False . if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos mc = . False . if ( present ( machine_coords )) mc = machine_coords call in_plasma ( xyz , inp , mc , coeffs , uvw ) if ( inp ) then phi = atan2 ( uvw ( 2 ), uvw ( 1 )) i = coeffs % i j = coeffs % j fields = coeffs % b11 * equil % fields ( i , j ) + coeffs % b12 * equil % fields ( i , j + 1 ) + & coeffs % b21 * equil % fields ( i + 1 , j ) + coeffs % b22 * equil % fields ( i + 1 , j + 1 ) phi = atan2 ( uvw ( 2 ), uvw ( 1 )) s = sin ( phi ) ; c = cos ( phi ) !Convert cylindrical coordinates to uvw uvw_bfield ( 1 ) = c * fields % br - s * fields % bt uvw_bfield ( 2 ) = s * fields % br + c * fields % bt uvw_bfield ( 3 ) = fields % bz uvw_efield ( 1 ) = c * fields % er - s * fields % et uvw_efield ( 2 ) = s * fields % er + c * fields % et uvw_efield ( 3 ) = fields % ez if ( mc ) then xyz_bfield = uvw_bfield xyz_efield = uvw_efield else !Represent fields in beam grid coordinates xyz_bfield = matmul ( beam_grid % inv_basis , uvw_bfield ) xyz_efield = matmul ( beam_grid % inv_basis , uvw_efield ) endif !Calculate field directions and magnitudes fields % b_abs = norm2 ( xyz_bfield ) fields % e_abs = norm2 ( xyz_efield ) if ( fields % b_abs . gt . 0.d0 ) fields % b_norm = xyz_bfield / fields % b_abs if ( fields % e_abs . gt . 0.d0 ) fields % e_norm = xyz_efield / fields % e_abs call calc_perp_vectors ( fields % b_norm , fields % a_norm , fields % c_norm ) fields % pos = xyz fields % uvw = uvw fields % in_plasma = . True . fields % machine_coords = mc fields % c = coeffs endif end subroutine get_fields subroutine get_distribution ( fbeam , denf , pos , ind , coeffs ) !+ Gets Guiding Center distribution at position `pos` or [[libfida:beam_grid]] indices `ind` real ( Float64 ), dimension (:,:), intent ( out ) :: fbeam !+ Guiding Center Fast-ion distribution at `pos`/`ind`: F(E,p) real ( Float64 ), intent ( out ) :: denf !+ Guiding Center Fast-ion density at `pos`/`ind` [fast-ions/cm&#94;3] real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices type ( InterpolCoeffs2D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients real ( Float64 ), dimension ( 3 ) :: xyz , uvw real ( Float64 ) :: R , Z integer :: err if ( present ( coeffs )) then call interpol ( fbm % r , fbm % z , fbm % f , R , Z , fbeam , err , coeffs ) call interpol ( fbm % r , fbm % z , fbm % denf , R , Z , denf , err , coeffs ) else if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) Z = uvw ( 3 ) call interpol ( fbm % r , fbm % z , fbm % f , R , Z , fbeam , err ) call interpol ( fbm % r , fbm % z , fbm % denf , R , Z , denf , err ) endif end subroutine get_distribution subroutine get_ep_denf ( energy , pitch , denf , pos , ind , coeffs ) !+ Get guiding center fast-ion density at given energy and pitch !+ at position `pos` or [[libfida:beam_grid]] indices `ind` real ( Float64 ), intent ( in ) :: energy !+ Energy [keV] real ( Float64 ), intent ( in ) :: pitch !+ Pitch real ( Float64 ), intent ( out ) :: denf !+ Fast-ion density [fast-ions/(cm&#94;3*dE*dp)] real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices type ( InterpolCoeffs2D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients real ( Float64 ), dimension ( 3 ) :: xyz , uvw real ( Float64 ), dimension ( fbm % nenergy , fbm % npitch ) :: fbeam integer ( Int32 ), dimension ( 2 ) :: epi integer ( Int32 ), dimension ( 1 ) :: dummy real ( Float64 ) :: R , Z real ( Float64 ) :: dE , dp integer :: err dummy = minloc ( abs ( fbm % energy - energy )) epi ( 1 ) = dummy ( 1 ) dummy = minloc ( abs ( fbm % pitch - pitch )) epi ( 2 ) = dummy ( 1 ) dE = abs ( fbm % energy ( epi ( 1 )) - energy ) dp = abs ( fbm % pitch ( epi ( 2 )) - pitch ) if (( dE . le . fbm % dE ). and .( dp . le . fbm % dp )) then if ( present ( coeffs )) then call interpol ( inter_grid % r , inter_grid % z , fbm % f , R , Z , fbeam , err , coeffs ) else if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) Z = uvw ( 3 ) call interpol ( inter_grid % r , inter_grid % z , fbm % f , R , Z , fbeam , err ) endif denf = fbeam ( epi ( 1 ), epi ( 2 )) else denf = 0.0 endif end subroutine get_ep_denf !============================================================================= !--------------------------Result Storage Routines---------------------------- !============================================================================= subroutine store_neutrals ( ind , neut_type , dens , store_iter ) !Store neutrals in [[libfida:neut]] at indices `ind` integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices integer , intent ( in ) :: neut_type !+ Neutral type real ( Float64 ), dimension (:), intent ( in ) :: dens !+ Neutral density [neutrals/cm&#94;3] logical , intent ( in ), optional :: store_iter !+ Store DCX/Halo iteration density in [[libfida:halo_iter_dens]] logical :: iter if ( present ( store_iter )) then iter = store_iter else iter = . False . endif !$OMP CRITICAL(store_neutrals_1) if ( iter ) halo_iter_dens ( neut_type ) = halo_iter_dens ( neut_type ) + sum ( dens ) neut % dens (:, neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) = & neut % dens (:, neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) + dens ![neutrals/cm&#94;3] !$OMP END CRITICAL(store_neutrals_1) end subroutine store_neutrals subroutine store_births ( ind , neut_type , dflux ) !+ Store birth particles/density in [[libfida:birth]] integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices integer ( Int32 ), intent ( in ) :: neut_type !+ Neutral type real ( Float64 ), intent ( in ) :: dflux !+ Deposited flux !$OMP CRITICAL(store_births_1) birth % dens ( neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) = & birth % dens ( neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) + dflux !$OMP END CRITICAL(store_births_1) end subroutine store_births subroutine store_npa ( det , ri , rf , vn , flux , orbit_class ) !+ Store NPA particles in [[libfida:npa]] integer , intent ( in ) :: det !+ Detector/Channel Number real ( Float64 ), dimension ( 3 ), intent ( in ) :: ri !+ Birth position in beam coordinates [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: rf !+ Detector position in beam coordinates [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vn !+ Particle velocity [cm/s] real ( Float64 ), intent ( in ) :: flux !+ Neutral flux [neutrals/s] integer , intent ( in ), optional :: orbit_class !+ Orbit class ID integer :: iclass type ( LocalEMFields ) :: fields real ( Float64 ), dimension ( 3 ) :: uvw_ri , uvw_rf , vn_norm real ( Float64 ) :: energy , pitch , dE integer ( Int32 ), dimension ( 1 ) :: ienergy type ( NPAParticle ), dimension (:), allocatable :: parts if ( present ( orbit_class )) then iclass = orbit_class else iclass = 1 endif ! Convert to machine coordinates call xyz_to_uvw ( ri , uvw_ri ) call xyz_to_uvw ( rf , uvw_rf ) ! Calculate energy energy = inputs % ab * v2_to_E_per_amu * dot_product ( vn , vn ) dE = npa % energy ( 2 ) - npa % energy ( 1 ) ! Calculate pitch if distribution actually uses pitch if ( inputs % dist_type . le . 2 ) then call get_fields ( fields , pos = ri ) vn_norm = vn / norm2 ( vn ) pitch = dot_product ( fields % b_norm , vn_norm ) else pitch = 0.d0 endif !$OMP CRITICAL(store_npa_1) npa % npart = npa % npart + 1 if ( npa % npart . gt . npa % nmax ) then npa % nmax = int ( npa % nmax * 2 ) allocate ( parts ( npa % nmax )) parts ( 1 :( npa % npart - 1 )) = npa % part deallocate ( npa % part ) call move_alloc ( parts , npa % part ) endif npa % part ( npa % npart )% detector = det npa % part ( npa % npart )% xi = uvw_ri ( 1 ) npa % part ( npa % npart )% yi = uvw_ri ( 2 ) npa % part ( npa % npart )% zi = uvw_ri ( 3 ) npa % part ( npa % npart )% xf = uvw_rf ( 1 ) npa % part ( npa % npart )% yf = uvw_rf ( 2 ) npa % part ( npa % npart )% zf = uvw_rf ( 3 ) npa % part ( npa % npart )% energy = energy npa % part ( npa % npart )% pitch = pitch npa % part ( npa % npart )% weight = flux ienergy = minloc ( abs ( npa % energy - energy )) npa % flux ( ienergy ( 1 ), det , iclass ) = & npa % flux ( ienergy ( 1 ), det , iclass ) + flux / dE !$OMP END CRITICAL(store_npa_1) end subroutine store_npa !============================================================================= !--------------------------Atomic Physics Routines---------------------------- !============================================================================= subroutine neut_rates ( denn , vi , vn , rates ) !+ Get neutralization/cx rates real ( Float64 ), dimension ( nlevs ), intent ( in ) :: denn !+ Neutral density [cm&#94;-3] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Ion velocity [cm/s] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vn !+ Neutral velocity [cm/s] real ( Float64 ), dimension ( nlevs ), intent ( out ) :: rates !+ Reaction rates [1/s] real ( Float64 ), dimension ( nlevs , nlevs ) :: neut !!rate coeff real ( Float64 ) :: eb !! relative Energy type ( InterpolCoeffs1D ) :: c real ( Float64 ) :: dlogE , logEmin , logeb real ( Float64 ) :: vrel !! relative velocity integer :: ebi , neb , err !Eeff vrel = norm2 ( vi - vn ) eb = v2_to_E_per_amu * vrel ** 2 ! [kev/amu] logeb = log10 ( eb ) logEmin = tables % H_H_cx % logemin dlogE = tables % H_H_cx % dlogE neb = tables % H_H_cx % nenergy call interpol_coeff ( logEmin , dlogE , neb , logeb , c , err ) ebi = c % i if ( err . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"NEUT_RATES: Eb out of range of H_H_cx table. Using nearest energy value.\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb endif if ( ebi . lt . 1 ) then ebi = 1 c % b1 = 1.0 ; c % b2 = 0.0 else ebi = neb c % b1 = 0.0 ; c % b2 = 1.0 endif endif neut (:,:) = ( c % b1 * tables % H_H_cx % log_cross (:,:, ebi ) + & c % b2 * tables % H_H_cx % log_cross (:,:, ebi + 1 )) where ( neut . lt . tables % H_H_cx % minlog_cross ) neut = 0.d0 elsewhere neut = 1 0.d0 ** neut end where rates = matmul ( neut , denn ) * vrel end subroutine neut_rates subroutine get_neutron_rate ( plasma , eb , rate ) !+ Gets neutron rate for a beam with energy `eb` interacting with a target plasma type ( LocalProfiles ), intent ( in ) :: plasma !+ Plasma Paramters real ( Float64 ), intent ( in ) :: eb !+ Beam energy [keV] real ( Float64 ), intent ( out ) :: rate !+ Neutron reaction rate [1/s] integer :: err_status , neb , nt , ebi , tii real ( Float64 ) :: dlogE , dlogT , logEmin , logTmin real ( Float64 ) :: logeb , logti , lograte , denp type ( InterpolCoeffs2D ) :: c real ( Float64 ) :: b11 , b12 , b21 , b22 logeb = log10 ( eb ) logti = log10 ( plasma % ti ) denp = plasma % denp !!D_D err_status = 1 logEmin = tables % D_D % logemin logTmin = tables % D_D % logtmin dlogE = tables % D_D % dlogE dlogT = tables % D_D % dlogT neb = tables % D_D % nenergy nt = tables % D_D % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , c , err_status ) ebi = c % i tii = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_NEUTRON_RATE: Eb or Ti out of range of D_D table. Setting D_D rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",ES10.3,\" [keV]\")' ) plasma % ti endif denp = 0.d0 endif lograte = ( b11 * tables % D_D % log_rate ( ebi , tii , 2 ) + & b12 * tables % D_D % log_rate ( ebi , tii + 1 , 2 ) + & b21 * tables % D_D % log_rate ( ebi + 1 , tii , 2 ) + & b22 * tables % D_D % log_rate ( ebi + 1 , tii + 1 , 2 )) if ( lograte . lt . tables % D_D % minlog_rate ) then rate = 0.d0 else rate = denp * 1 0.d0 ** lograte endif end subroutine get_neutron_rate subroutine get_beam_cx_prob ( ind , pos , v_ion , types , prob ) !+ Get probability of a thermal ion charge exchanging with `types` neutrals integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Interaction position in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: v_ion !+ Ion velocity [cm/s] integer ( Int32 ), dimension (:), intent ( in ) :: types !+ Neutral types real ( Float64 ), dimension ( nlevs ), intent ( out ) :: prob !+ Charge exchange rate/probability [1/s] integer :: ntypes , i , ii real ( Float64 ), dimension ( nlevs ) :: rates , denn real ( Float64 ), dimension ( 3 ) :: vhalo , vnbi , vn vnbi = pos - nbi % src vnbi = vnbi / norm2 ( vnbi ) * nbi % vinj ntypes = size ( types ) prob = 0 do i = 1 , ntypes if (( types ( i ). le . 3 ). and .( types ( i ). ne . 0 )) then ! CX with full type'th energy NBI neutrals denn = neut % dens (:, types ( i ), ind ( 1 ), ind ( 2 ), ind ( 3 )) vn = vnbi / sqrt ( real ( types ( i ))) call neut_rates ( denn , v_ion , vn , rates ) prob = prob + rates else denn = neut % dens (:, types ( i ), ind ( 1 ), ind ( 2 ), ind ( 3 )) do ii = 1 , int ( n_halo_neutrate ) call mc_halo ( ind , vhalo ) call neut_rates ( denn , v_ion , vhalo , rates ) prob = prob + rates / n_halo_neutrate enddo endif enddo end subroutine get_beam_cx_prob subroutine get_rate_matrix ( plasma , i_type , eb , rmat ) !+ Gets rate matrix for use in [[libfida:colrad]] type ( LocalProfiles ), intent ( in ) :: plasma !+ Plasma parameters integer , intent ( in ) :: i_type !+ Ion type real ( Float64 ), intent ( in ) :: eb !+ Ion energy [keV] real ( Float64 ), dimension ( nlevs , nlevs ), intent ( out ) :: rmat !+ Rate matrix real ( Float64 ) :: logEmin , dlogE , logeb real ( Float64 ) :: logTmin , dlogT , logti , logte integer :: neb , nt type ( InterpolCoeffs2D ) :: c real ( Float64 ) :: b11 , b12 , b21 , b22 , dene , denp , denimp real ( Float64 ), dimension ( nlevs , nlevs ) :: H_H_pop , H_e_pop , H_Aq_pop real ( Float64 ), dimension ( nlevs ) :: H_H_depop , H_e_depop , H_Aq_depop integer :: ebi , tii , tei , n , err_status H_H_pop = 0.d0 H_e_pop = 0.d0 H_Aq_pop = 0.d0 H_H_depop = 0.d0 H_e_depop = 0.d0 H_Aq_depop = 0.d0 denp = plasma % denp dene = plasma % dene denimp = plasma % denimp logeb = log10 ( eb ) logti = log10 ( plasma % ti ) logte = log10 ( plasma % te ) !!H_H err_status = 1 logEmin = tables % H_H % logemin logTmin = tables % H_H % logtmin dlogE = tables % H_H % dlogE dlogT = tables % H_H % dlogT neb = tables % H_H % nenergy nt = tables % H_H % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , c , err_status ) ebi = c % i tii = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Ti out of range of H_H table. Setting H_H rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",ES10.3,\" [keV]\")' ) plasma % ti endif denp = 0.d0 endif H_H_pop = ( b11 * tables % H_H % log_pop (:,:, ebi , tii , i_type ) + & b12 * tables % H_H % log_pop (:,:, ebi , tii + 1 , i_type ) + & b21 * tables % H_H % log_pop (:,:, ebi + 1 , tii , i_type ) + & b22 * tables % H_H % log_pop (:,:, ebi + 1 , tii + 1 , i_type )) where ( H_H_pop . lt . tables % H_H % minlog_pop ) H_H_pop = 0.d0 elsewhere H_H_pop = denp * 1 0.d0 ** H_H_pop end where H_H_depop = ( b11 * tables % H_H % log_depop (:, ebi , tii , i_type ) + & b12 * tables % H_H % log_depop (:, ebi , tii + 1 , i_type ) + & b21 * tables % H_H % log_depop (:, ebi + 1 , tii , i_type ) + & b22 * tables % H_H % log_depop (:, ebi + 1 , tii + 1 , i_type )) where ( H_H_depop . lt . tables % H_H % minlog_depop ) H_H_depop = 0.d0 elsewhere H_H_depop = denp * 1 0.d0 ** H_H_depop end where !!H_e err_status = 1 logEmin = tables % H_e % logemin logTmin = tables % H_e % logtmin dlogE = tables % H_e % dlogE dlogT = tables % H_e % dlogT neb = tables % H_e % nenergy nt = tables % H_e % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logte , c , err_status ) ebi = c % i tei = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Te out of range of H_e table. Setting H_e rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"te = \",ES10.3,\" [keV]\")' ) plasma % te endif dene = 0.d0 endif H_e_pop = ( b11 * tables % H_e % log_pop (:,:, ebi , tei , i_type ) + & b12 * tables % H_e % log_pop (:,:, ebi , tei + 1 , i_type ) + & b21 * tables % H_e % log_pop (:,:, ebi + 1 , tei , i_type ) + & b22 * tables % H_e % log_pop (:,:, ebi + 1 , tei + 1 , i_type )) where ( H_e_pop . lt . tables % H_e % minlog_pop ) H_e_pop = 0.d0 elsewhere H_e_pop = dene * 1 0.d0 ** H_e_pop end where H_e_depop = ( b11 * tables % H_e % log_depop (:, ebi , tei , i_type ) + & b12 * tables % H_e % log_depop (:, ebi , tei + 1 , i_type ) + & b21 * tables % H_e % log_depop (:, ebi + 1 , tei , i_type ) + & b22 * tables % H_e % log_depop (:, ebi + 1 , tei + 1 , i_type )) where ( H_e_depop . lt . tables % H_e % minlog_depop ) H_e_depop = 0.d0 elsewhere H_e_depop = dene * 1 0.d0 ** H_e_depop end where !!H_Aq err_status = 1 logEmin = tables % H_Aq % logemin logTmin = tables % H_Aq % logtmin dlogE = tables % H_Aq % dlogE dlogT = tables % H_Aq % dlogT neb = tables % H_Aq % nenergy nt = tables % H_Aq % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , c , err_status ) ebi = c % i tii = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Ti out of range of H_Aq table. Setting H_Aq rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",ES10.3,\" [keV]\")' ) plasma % ti endif denimp = 0.d0 endif H_Aq_pop = ( b11 * tables % H_Aq % log_pop (:,:, ebi , tii , i_type ) + & b12 * tables % H_Aq % log_pop (:,:, ebi , tii + 1 , i_type ) + & b21 * tables % H_Aq % log_pop (:,:, ebi + 1 , tii , i_type ) + & b22 * tables % H_Aq % log_pop (:,:, ebi + 1 , tii + 1 , i_type )) where ( H_Aq_pop . lt . tables % H_Aq % minlog_pop ) H_Aq_pop = 0.d0 elsewhere H_Aq_pop = denimp * 1 0.d0 ** H_Aq_pop end where H_Aq_depop = ( b11 * tables % H_Aq % log_depop (:, ebi , tii , i_type ) + & b12 * tables % H_Aq % log_depop (:, ebi , tii + 1 , i_type ) + & b21 * tables % H_Aq % log_depop (:, ebi + 1 , tii , i_type ) + & b22 * tables % H_Aq % log_depop (:, ebi + 1 , tii + 1 , i_type )) where ( H_Aq_depop . lt . tables % H_Aq % minlog_depop ) H_Aq_depop = 0.d0 elsewhere H_Aq_depop = denimp * 1 0.d0 ** H_Aq_depop end where rmat = tables % einstein + H_H_pop + H_e_pop + H_Aq_pop do n = 1 , nlevs rmat ( n , n ) = - sum ( tables % einstein (:, n )) - H_H_depop ( n ) - H_e_depop ( n ) - H_Aq_depop ( n ) enddo end subroutine get_rate_matrix subroutine colrad ( plasma , i_type , vn , dt , states , dens , photons ) !+ Evolve density of states in time `dt` via collisional radiative model type ( LocalProfiles ), intent ( in ) :: plasma !+ Plasma parameters integer , intent ( in ) :: i_type !+ Ion/Neutral type (beam,thermal) real ( Float64 ), dimension (:), intent ( in ) :: vn !+ Neutral velocitiy [cm/s] real ( Float64 ), intent ( in ) :: dt !+ Time interval [s] real ( Float64 ), dimension (:), intent ( inout ) :: states !+ Density of states real ( Float64 ), dimension ( nlevs ), intent ( out ) :: dens !+ Density of neutrals real ( Float64 ), intent ( out ) :: photons !+ Emitted photons(3->2) real ( Float64 ), dimension ( nlevs , nlevs ) :: matrix !! Matrix real ( Float64 ) :: b_amu real ( Float64 ) :: vnet_square !! net velocity of neutrals squared real ( Float64 ) :: eb !! Energy of the fast neutral real ( Float64 ), dimension ( nlevs , nlevs ) :: eigvec , eigvec_inv real ( Float64 ), dimension ( nlevs ) :: eigval , coef real ( Float64 ), dimension ( nlevs ) :: exp_eigval_dt real ( Float64 ) :: iflux !!Initial total flux integer :: n photons = 0.d0 dens = 0.d0 iflux = sum ( states ) if ( iflux . lt . colrad_threshold . and . inputs % calc_npa . eq . 0 ) then return endif if (. not . plasma % in_plasma ) then dens = states * dt return endif if ( i_type . eq . beam_ion ) then b_amu = inputs % ab else b_amu = inputs % ai endif vnet_square = dot_product ( vn - plasma % vrot , vn - plasma % vrot ) ![cm/s] eb = v2_to_E_per_amu * b_amu * vnet_square ![kev] call get_rate_matrix ( plasma , i_type , eb , matrix ) call eigen ( nlevs , matrix , eigvec , eigval ) call matinv ( eigvec , eigvec_inv ) coef = matmul ( eigvec_inv , states ) !coeffs determined from states at t=0 exp_eigval_dt = exp ( eigval * dt ) ! to improve speed (used twice) do n = 1 , nlevs if ( eigval ( n ). eq . 0.0 ) eigval ( n ) = eigval ( n ) + 1 !protect against dividing by zero enddo states = matmul ( eigvec , coef * exp_eigval_dt ) ![neutrals/cm&#94;3/s]! dens = matmul ( eigvec , coef * ( exp_eigval_dt - 1.d0 ) / eigval ) if (( minval ( states ). lt . 0 ). or .( minval ( dens ). lt . 0 )) then do n = 1 , nlevs if ( states ( n ). lt . 0 ) states ( n ) = 0.d0 if ( dens ( n ). lt . 0 ) dens ( n ) = 0.d0 enddo endif photons = dens ( 3 ) * tables % einstein ( 2 , 3 ) !! - [Ph/(s*cm&#94;3)] - !! end subroutine colrad subroutine attenuate ( ri , rf , vi , states , dstep_in ) !+ Attenuate `states` along a trajectory real ( Float64 ), dimension ( 3 ), intent ( in ) :: ri !+ Initial position in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: rf !+ Final position in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Initial velocity of neutral real ( Float64 ), dimension ( nlevs ), intent ( inout ) :: states !+ Density of states real ( Float64 ), intent ( in ), optional :: dstep_in !+ Step length [cm] type ( LocalProfiles ) :: plasma real ( Float64 ) :: photons , vabs , dt , dstep , dis , max_dis real ( Float64 ), dimension ( 3 ) :: r0 real ( Float64 ), dimension ( nlevs ) :: dens if ( present ( dstep_in )) then dstep = dstep_in else dstep = sqrt ( inter_grid % da ) !cm endif max_dis = norm2 ( rf - ri ) vabs = norm2 ( vi ) dt = dstep / vabs call get_plasma ( plasma , pos = ri ) r0 = ri dis = 0.d0 do while ( dis . le . max_dis ) call colrad ( plasma , beam_ion , vi , dt , states , dens , photons ) r0 = r0 + vi * dt dis = dis + dstep call get_plasma ( plasma , pos = r0 ) enddo end subroutine attenuate subroutine spectrum ( vecp , vi , fields , sigma_pi , photons , dlength , lambda , intensity ) !+ Calculates doppler shift and stark splitting real ( Float64 ), dimension ( 3 ), intent ( in ) :: vecp !+ Vector directing towards optical head real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Particle velocity type ( LocalEMFields ), intent ( in ) :: fields !+ Electro-magnetic fields real ( Float64 ), intent ( in ) :: sigma_pi !+ Sigma-pi ratio real ( Float64 ), intent ( in ) :: photons !+ Photon density from [[libfida:colrad]] real ( Float64 ), intent ( in ) :: dlength !+ LOS intersection length with [[libfida:beam_grid]] cell particle is in real ( Float64 ), dimension ( n_stark ), intent ( out ) :: lambda !+ Wavelengths [nm] real ( Float64 ), dimension ( n_stark ), intent ( out ) :: intensity !+ Spectra intensities [Ph/(s cm&#94;2 starkline)] real ( Float64 ), dimension ( 3 ) :: vp , vn real ( Float64 ), dimension ( 3 ) :: bfield , efield real ( Float64 ) :: E , cos_los_Efield , lambda_shifted integer , parameter , dimension ( n_stark ) :: stark_sign = + 1 * stark_sigma - 1 * stark_pi !! vector directing towards the optical head vp = vecp / norm2 ( vecp ) ! Calculate Doppler shift vn = vi * 0.01d0 ! [m/s] lambda_shifted = lambda0 * ( 1.d0 + dot_product ( vn , vp ) / c0 ) !! Calculate Stark Splitting ! Calculate E-field bfield = fields % b_norm * fields % b_abs efield = fields % e_norm * fields % e_abs efield ( 1 ) = efield ( 1 ) + vn ( 2 ) * bfield ( 3 ) - vn ( 3 ) * bfield ( 2 ) efield ( 2 ) = efield ( 2 ) - ( vn ( 1 ) * bfield ( 3 ) - vn ( 3 ) * bfield ( 1 )) efield ( 3 ) = efield ( 3 ) + vn ( 1 ) * bfield ( 2 ) - vn ( 2 ) * bfield ( 1 ) E = norm2 ( efield ) !Stark Splitting lambda = lambda_shifted + E * stark_wavel ![nm] !Intensities of stark components if ( E . eq . 0.d0 ) then cos_los_Efield = 0.d0 else cos_los_Efield = dot_product ( vp , efield ) / E endif intensity = stark_intens * ( 1.d0 + stark_sign * cos_los_Efield ** 2 ) !! E.g. mirrors may change the pi to sigma intensity ratio where ( stark_sigma . eq . 1 ) intensity = intensity * sigma_pi endwhere !! normalize and multiply with photon density from colrad intensity = intensity / sum ( intensity ) * photons * dlength endsubroutine spectrum subroutine store_bes_photons ( pos , vi , photons , neut_type ) !+ Store BES photons in [[libfida:spectra]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position of neutral in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocitiy of neutral [cm/s] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] integer , intent ( in ) :: neut_type !+ Neutral type (full,half,third,halo) real ( Float64 ), dimension ( n_stark ) :: lambda , intensity real ( Float64 ) :: dlength , sigma_pi type ( LocalEMFields ) :: fields integer ( Int32 ), dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: vp type ( LOSInters ) :: inter integer :: ichan , i , j , bin , nchan call get_indices ( pos , ind ) inter = spec_chords % inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) nchan = inter % nchan if ( nchan . eq . 0 ) return call get_fields ( fields , pos = pos ) loop_over_channels : do j = 1 , nchan ichan = inter % los_elem ( j )% id dlength = inter % los_elem ( j )% length sigma_pi = spec_chords % los ( ichan )% sigma_pi vp = pos - spec_chords % los ( ichan )% lens call spectrum ( vp , vi , fields , sigma_pi , photons , & dlength , lambda , intensity ) loop_over_stark : do i = 1 , n_stark bin = floor (( lambda ( i ) - inputs % lambdamin ) / inputs % dlambda ) + 1 if ( bin . lt . 1 ) cycle loop_over_stark if ( bin . gt . inputs % nlambda ) cycle loop_over_stark !$OMP CRITICAL(bes_spectrum) spec % bes ( bin , ichan , neut_type ) = & spec % bes ( bin , ichan , neut_type ) + intensity ( i ) !$OMP END CRITICAL(bes_spectrum) enddo loop_over_stark enddo loop_over_channels end subroutine store_bes_photons subroutine store_fida_photons ( pos , vi , photons , orbit_class ) !+ Store fida photons in [[libfida:spectra]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position of neutral in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocitiy of neutral [cm/s] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] integer , intent ( in ), optional :: orbit_class !+ Orbit class ID real ( Float64 ), dimension ( n_stark ) :: lambda , intensity real ( Float64 ) :: dlength , sigma_pi type ( LocalEMFields ) :: fields integer ( Int32 ), dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: vp type ( LOSInters ) :: inter integer :: ichan , i , j , bin , iclass , nchan if ( present ( orbit_class )) then iclass = orbit_class else iclass = 1 endif call get_indices ( pos , ind ) inter = spec_chords % inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) nchan = inter % nchan if ( nchan . eq . 0 ) return call get_fields ( fields , pos = pos ) loop_over_channels : do j = 1 , nchan ichan = inter % los_elem ( j )% id dlength = inter % los_elem ( j )% length sigma_pi = spec_chords % los ( ichan )% sigma_pi vp = pos - spec_chords % los ( ichan )% lens call spectrum ( vp , vi , fields , sigma_pi , photons , & dlength , lambda , intensity ) loop_over_stark : do i = 1 , n_stark bin = floor (( lambda ( i ) - inputs % lambdamin ) / inputs % dlambda ) + 1 if ( bin . lt . 1 ) cycle loop_over_stark if ( bin . gt . inputs % nlambda ) cycle loop_over_stark !$OMP CRITICAL(fida_spectrum) spec % fida ( bin , ichan , iclass ) = & spec % fida ( bin , ichan , iclass ) + intensity ( i ) !$OMP END CRITICAL(fida_spectrum) enddo loop_over_stark enddo loop_over_channels end subroutine store_fida_photons subroutine store_neutrons ( rate , orbit_class ) !+ Store neutron rate in [[libfida:neutron]] real ( Float64 ), intent ( in ) :: rate !+ Neutron rate [neutrons/sec] integer , intent ( in ), optional :: orbit_class !+ Orbit class ID integer :: iclass if ( present ( orbit_class )) then iclass = orbit_class else iclass = 1 endif !$OMP CRITICAL(neutron_rate) neutron % rate ( iclass ) = neutron % rate ( iclass ) + rate !$OMP END CRITICAL(neutron_rate) end subroutine store_neutrons subroutine store_fw_photons_at_chan ( ichan , eind , pind , vp , vi , fields , dlength , sigma_pi , denf , photons ) !+ Store FIDA weight photons in [[libfida:fweight]] for a specific channel integer , intent ( in ) :: ichan !+ Channel index integer , intent ( in ) :: eind !+ Energy index integer , intent ( in ) :: pind !+ Pitch index real ( Float64 ), dimension ( 3 ), intent ( in ) :: vp !+ Vector pointing toward optical head real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocity of neutral [cm/s] type ( LocalEMFields ), intent ( in ) :: fields !+ Electro-magnetic fields real ( Float64 ), intent ( in ) :: dlength !+ LOS intersection length with [[libfida:beam_grid]] cell particle is in real ( Float64 ), intent ( in ) :: sigma_pi !+ Sigma-pi ratio for channel real ( Float64 ), intent ( in ) :: denf !+ Fast-ion density [cm&#94;-3] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] real ( Float64 ), dimension ( n_stark ) :: lambda , intensity real ( Float64 ) :: dlambda , intens_fac integer :: i , bin dlambda = ( inputs % lambdamax_wght - inputs % lambdamin_wght ) / inputs % nlambda_wght intens_fac = ( 1.d0 ) / ( 4.d0 * pi * dlambda ) call spectrum ( vp , vi , fields , sigma_pi , photons , & dlength , lambda , intensity ) !$OMP CRITICAL(fida_wght) loop_over_stark : do i = 1 , n_stark bin = floor (( lambda ( i ) - inputs % lambdamin_wght ) / dlambda ) + 1 if ( bin . lt . 1 ) cycle loop_over_stark if ( bin . gt . inputs % nlambda_wght ) cycle loop_over_stark !fida(bin,ichan)= fida(bin,ichan) + & !  (denf*intens_fac*1.d4)*intensity(i) !ph/(s*nm*sr*m&#94;2) fweight % weight ( bin , eind , pind , ichan ) = & fweight % weight ( bin , eind , pind , ichan ) + intensity ( i ) * intens_fac !(ph*cm)/(s*nm*sr*fast-ion*dE*dp) enddo loop_over_stark if ( denf . gt . 0.d0 ) then fweight % mean_f ( eind , pind , ichan ) = fweight % mean_f ( eind , pind , ichan ) + & ( denf * intens_fac ) * sum ( intensity ) endif !$OMP END CRITICAL(fida_wght) end subroutine store_fw_photons_at_chan subroutine store_fw_photons ( eind , pind , pos , vi , denf , photons ) !+ Store FIDA weight photons in [[libfida:fweight]] integer , intent ( in ) :: eind !+ Energy index integer , intent ( in ) :: pind !+ Pitch index real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position of neutral real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocity of neutral [cm/s] real ( Float64 ), intent ( in ) :: denf !+ Fast-ion density [cm&#94;-3] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] real ( Float64 ) :: dlength , sigma_pi type ( LocalEMFields ) :: fields integer ( Int32 ), dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: vp type ( LOSInters ) :: inter integer :: ichan , nchan , i call get_indices ( pos , ind ) inter = spec_chords % inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) nchan = inter % nchan if ( nchan . eq . 0 ) return call get_fields ( fields , pos = pos ) loop_over_channels : do i = 1 , nchan ichan = inter % los_elem ( i )% id dlength = inter % los_elem ( i )% length sigma_pi = spec_chords % los ( ichan )% sigma_pi vp = pos - spec_chords % los ( ichan )% lens call store_fw_photons_at_chan ( ichan , eind , pind , & vp , vi , fields , dlength , sigma_pi , denf , photons ) enddo loop_over_channels end subroutine store_fw_photons !============================================================================= !---------------------------Monte Carlo Routines------------------------------ !============================================================================= subroutine get_nlaunch ( nr_markers , papprox , papprox_tot , nlaunch ) !+ Sets the number of MC markers launched from each [[libfida:beam_grid]] cell integer ( Int64 ), intent ( in ) :: nr_markers !+ Approximate total number of markers to launch real ( Float64 ), dimension (:,:,:), intent ( in ) :: papprox !+ [[libfida:beam_grid]] cell weights real ( Float64 ), intent ( in ) :: papprox_tot !+ Total cell weights real ( Float64 ), dimension (:,:,:), intent ( out ) :: nlaunch !+ Number of mc markers to launch for each cell: nlaunch(x,y,z) integer :: i , j , k , cc real ( Float64 ), dimension (:), allocatable :: randomu do i = 1 , 1000 nlaunch (:,:,:) = papprox (:,:,:) / papprox_tot * nr_markers * ( 1. + i * 0.01 ) if ( sum ( nlaunch ). gt . nr_markers ) then exit endif enddo allocate ( randomu ( count ( nlaunch . gt . 0 ))) call randu ( randomu ) cc = 1 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx if ( nlaunch ( i , j , k ). gt . 0. ) then if ( mod ( nlaunch ( i , j , k ), 1. ). gt . randomu ( cc )) then nlaunch ( i , j , k ) = nlaunch ( i , j , k ) + 1. endif cc = cc + 1 endif enddo enddo enddo do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx nlaunch ( i , j , k ) = floor ( nlaunch ( i , j , k )) enddo enddo enddo deallocate ( randomu ) end subroutine get_nlaunch subroutine pitch_to_vec ( pitch , gyroangle , fields , vi_norm ) !+ Calculates velocity vector from pitch, gyroangle and fields real ( Float64 ), intent ( in ) :: pitch !+ Pitch real ( Float64 ), intent ( in ) :: gyroangle !+ Gyroangle [radians] type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields real ( Float64 ), dimension ( 3 ), intent ( out ) :: vi_norm !+ Normalized velocity vector real ( Float64 ) :: sinus sinus = sqrt ( max ( 1.d0 - pitch ** 2 , 0.d0 )) vi_norm = ( sinus * cos ( gyroangle ) * fields % a_norm + & pitch * fields % b_norm + & sinus * sin ( gyroangle ) * fields % c_norm ) end subroutine pitch_to_vec subroutine gyro_step ( vi , fields , r_gyro ) !+ Calculates gyro-step real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Ion velocity type ( LocalEMFields ), intent ( in ) :: fields !+ Electro-magnetic fields real ( Float64 ), dimension ( 3 ), intent ( out ) :: r_gyro !+ Gyro-step !+ Gyro-radius vector from particle position to guiding center real ( Float64 ), dimension ( 3 ) :: vxB , rg_uvw , uvw , cuvrxb , b_rtz , grad_B , rg_rtz real ( Float64 ) :: one_over_omega , phi , R , rg_r , vpar , term1 , term2 if ( inputs % no_flr . eq . 0 ) then one_over_omega = inputs % ab * mass_u / ( fields % b_abs * e0 ) vxB = cross_product ( vi , fields % b_norm ) vpar = dot_product ( vi , fields % b_norm ) r_gyro = vxB * one_over_omega !points towards gyrocenter !! Second order correction approximation derived from !! Belova, E. V., N. N. Gorelenkov, and C. Z. Cheng. !! \"Self-consistent equilibrium model of low aspect-ratio !! toroidal plasma with energetic beam ions.\" !! Physics of Plasmas (1994-present) 10.8 (2003): 3240-3251. !! Appendix A: Last equation uvw = fields % uvw R = sqrt ( uvw ( 1 ) ** 2 + uvw ( 2 ) ** 2 ) phi = atan2 ( uvw ( 2 ), uvw ( 1 )) if ( fields % machine_coords ) then rg_uvw = r_gyro else rg_uvw = matmul ( beam_grid % basis , r_gyro ) endif rg_r = rg_uvw ( 1 ) * cos ( phi ) + rg_uvw ( 2 ) * sin ( phi ) b_rtz ( 1 ) = fields % br / fields % b_abs b_rtz ( 2 ) = fields % bt / fields % b_abs b_rtz ( 3 ) = fields % bz / fields % b_abs cuvrxb ( 1 ) = - fields % dbt_dz / fields % b_abs cuvrxb ( 2 ) = ( fields % dbr_dz - fields % dbz_dr ) / fields % b_abs cuvrxb ( 3 ) = fields % dbt_dr / fields % b_abs term1 = vpar * one_over_omega * dot_product ( b_rtz , cuvrxb ) grad_B ( 1 ) = ( fields % br * fields % dbr_dr + fields % bt * fields % dbt_dr + fields % bz * fields % dbz_dr ) / & fields % b_abs grad_B ( 2 ) = 0.0 grad_B ( 3 ) = ( fields % br * fields % dbr_dz + fields % bt * fields % dbt_dz + fields % bz * fields % dbz_dz ) / & fields % b_abs rg_rtz ( 1 ) = rg_uvw ( 1 ) * cos ( phi ) + rg_uvw ( 2 ) * sin ( phi ) rg_rtz ( 2 ) = 0.0 rg_rtz ( 3 ) = rg_uvw ( 3 ) term2 = - 1.0 / ( 2.0 * fields % b_abs ) * dot_product ( rg_rtz , grad_B ) r_gyro = r_gyro * ( 1.0 - term1 - term2 ) if ( 1.0 - term1 - term2 . le . 0.0 ) then write ( * , * ) 'GYRO_STEP: Gyro correction results in negative distances: ' , & 1.0 - term1 - term2 stop endif else r_gyro = 0.d0 endif end subroutine gyro_step subroutine gyro_correction ( fields , energy , pitch , rp , vp , phi_in ) !+ Calculates gyro correction for Guiding Center MC distribution calculation type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields at guiding center real ( Float64 ), intent ( in ) :: energy !+ Energy of particle real ( Float64 ), intent ( in ) :: pitch !+ Particle pitch w.r.t the magnetic field real ( Float64 ), dimension ( 3 ), intent ( out ) :: rp !+ Particle position real ( Float64 ), dimension ( 3 ), intent ( out ) :: vp !+ Particle velocity real ( Float64 ), intent ( in ), optional :: phi_in !+ Gyro-angle real ( Float64 ), dimension ( 3 ) :: vi_norm , r_step real ( Float64 ), dimension ( 1 ) :: randomu real ( Float64 ) :: vabs , phi vabs = sqrt ( energy / ( v2_to_E_per_amu * inputs % ab )) if ( present ( phi_in )) then phi = phi_in else !! Sample gyroangle call randu ( randomu ) phi = 2 * pi * randomu ( 1 ) endif !! Calculate velocity vector call pitch_to_vec ( pitch , phi , fields , vi_norm ) vp = vabs * vi_norm !! Move to particle location call gyro_step ( vp , fields , r_step ) rp = fields % pos - r_step end subroutine gyro_correction function gyro_radius ( fields , energy , pitch ) result ( gyro_rad ) !+ Calculates mean gyro-radius type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields at guiding center real ( Float64 ), intent ( in ) :: energy !+ Energy of particle real ( Float64 ), intent ( in ) :: pitch !+ Particle pitch w.r.t the magnetic field real ( Float64 ) :: gyro_rad !+ Mean gyro-radius real ( Float64 ), dimension ( 3 ) :: vi_norm , r_step real ( Float64 ) :: vabs , phi integer :: i , n vabs = sqrt ( energy / ( v2_to_E_per_amu * inputs % ab )) gyro_rad = 0.d0 n = 6 do i = 1 , n phi = i * 2 * pi / n call pitch_to_vec ( pitch , phi , fields , vi_norm ) call gyro_step ( vabs * vi_norm , fields , r_step ) gyro_rad = gyro_rad + norm2 ( r_step ) / n enddo end function gyro_radius subroutine mc_fastion ( ind , fields , eb , ptch , denf ) !+ Samples a Guiding Center Fast-ion distribution function at a given [[libfida:beam_grid]] index integer , dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] index type ( LocalEMFields ), intent ( out ) :: fields !+ Electromagnetic fields at the guiding center real ( Float64 ), intent ( out ) :: eb !+ Energy of the fast ion real ( Float64 ), intent ( out ) :: ptch !+ Pitch of the fast ion real ( Float64 ), intent ( out ) :: denf !+ Fast-ion density at guiding center real ( Float64 ), dimension ( fbm % nenergy , fbm % npitch ) :: fbeam real ( Float64 ), dimension ( 3 ) :: rg real ( Float64 ), dimension ( 3 ) :: randomu3 integer , dimension ( 2 , 1 ) :: ep_ind call randu ( randomu3 ) rg ( 1 ) = beam_grid % xc ( ind ( 1 )) + beam_grid % dr ( 1 ) * ( randomu3 ( 1 ) - 0.5 ) rg ( 2 ) = beam_grid % yc ( ind ( 2 )) + beam_grid % dr ( 2 ) * ( randomu3 ( 2 ) - 0.5 ) rg ( 3 ) = beam_grid % zc ( ind ( 3 )) + beam_grid % dr ( 3 ) * ( randomu3 ( 3 ) - 0.5 ) denf = 0.d0 call get_fields ( fields , pos = rg ) if (. not . fields % in_plasma ) return call get_distribution ( fbeam , denf , pos = rg , coeffs = fields % c ) call randind ( fbeam , ep_ind ) call randu ( randomu3 ) eb = fbm % energy ( ep_ind ( 1 , 1 )) + fbm % dE * ( randomu3 ( 1 ) - 0.5 ) ptch = fbm % pitch ( ep_ind ( 2 , 1 )) + fbm % dp * ( randomu3 ( 2 ) - 0.5 ) end subroutine mc_fastion subroutine mc_halo ( ind , vhalo , ri , plasma_in ) !+ Sample thermal Maxwellian distribution at [[libfida:beam_grid]] indices `ind` integer , dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices real ( Float64 ), dimension ( 3 ), intent ( out ) :: vhalo !+ Velocity [cm/s] real ( Float64 ), dimension ( 3 ), intent ( out ), optional :: ri !+ Position in [[libfida:beam_grid]] cell type ( LocalProfiles ), intent ( in ), optional :: plasma_in !+ Plasma parameters type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( 3 ) :: random3 if (. not . present ( plasma_in )) then if ( present ( ri )) then call randu ( random3 ) ri ( 1 ) = beam_grid % xc ( ind ( 1 )) + beam_grid % dr ( 1 ) * ( random3 ( 1 ) - 0.5 ) ri ( 2 ) = beam_grid % yc ( ind ( 2 )) + beam_grid % dr ( 2 ) * ( random3 ( 2 ) - 0.5 ) ri ( 3 ) = beam_grid % zc ( ind ( 3 )) + beam_grid % dr ( 3 ) * ( random3 ( 3 ) - 0.5 ) call get_plasma ( plasma , pos = ri ) else call get_plasma ( plasma , ind = ind ) endif else plasma = plasma_in endif call randn ( random3 ) vhalo = plasma % vrot + sqrt ( plasma % ti * 0.5 / ( v2_to_E_per_amu * inputs % ai )) * random3 !![cm/s] end subroutine mc_halo subroutine mc_nbi ( vnbi , efrac , rnbi , err ) !+ Generates a neutral beam particle trajectory integer , intent ( in ) :: efrac !+ Beam neutral type (1,2,3) real ( Float64 ), dimension ( 3 ), intent ( out ) :: vnbi !+ Velocity [cm/s] real ( Float64 ), dimension ( 3 ), intent ( out ) :: rnbi !+ Starting position on [[libfida:beam_grid]] logical , intent ( out ) :: err !+ Error Code real ( Float64 ), dimension ( 3 ) :: r_exit real ( Float64 ), dimension ( 3 ) :: uvw_src !! Start position on ion source real ( Float64 ), dimension ( 3 ) :: xyz_src !! Start position on ion source real ( Float64 ), dimension ( 3 ) :: uvw_ray !! NBI velocity in uvw coords real ( Float64 ), dimension ( 3 ) :: xyz_ray !! NBI velocity in xyz coords real ( Float64 ), dimension ( 3 ) :: xyz_ape !! Aperture plane intersection point real ( Float64 ), dimension ( 2 ) :: randomu !! uniform random numbers real ( Float64 ), dimension ( 2 ) :: randomn !! normal random numbers real ( Float64 ) :: length , sqrt_rho , theta integer :: i , j logical :: inp , valid_trajectory err = . False . valid_trajectory = . False . rejection_loop : do i = 1 , 1000 call randu ( randomu ) select case ( nbi % shape ) case ( 1 ) ! Uniformally sample in rectangle xyz_src ( 1 ) = 0.d0 xyz_src ( 2 ) = nbi % widy * 2.d0 * ( randomu ( 1 ) - 0.5d0 ) xyz_src ( 3 ) = nbi % widz * 2.d0 * ( randomu ( 2 ) - 0.5d0 ) case ( 2 ) ! Uniformally sample in ellipse sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) xyz_src ( 1 ) = 0.d0 xyz_src ( 2 ) = nbi % widy * sqrt_rho * cos ( theta ) xyz_src ( 3 ) = nbi % widz * sqrt_rho * sin ( theta ) end select !! Create random velocity vector call randn ( randomn ) xyz_ray ( 1 ) = 1.d0 xyz_ray ( 2 ) = ( - xyz_src ( 2 ) / nbi % focy + tan ( nbi % divy ( efrac ) * randomn ( 1 ))) xyz_ray ( 3 ) = ( - xyz_src ( 3 ) / nbi % focz + tan ( nbi % divz ( efrac ) * randomn ( 2 ))) aperture_loop : do j = 1 , nbi % naperture xyz_ape = xyz_ray * nbi % adist ( j ) + xyz_src select case ( nbi % ashape ( j )) case ( 1 ) if (( abs ( xyz_ape ( 2 ) - nbi % aoffy ( j )). gt . nbi % awidy ( j )). or .& ( abs ( xyz_ape ( 3 ) - nbi % aoffz ( j )). gt . nbi % awidz ( j ))) then cycle rejection_loop endif case ( 2 ) if (((( xyz_ape ( 2 ) - nbi % aoffy ( j )) * nbi % awidz ( j )) ** 2 + & (( xyz_ape ( 3 ) - nbi % aoffz ( j )) * nbi % awidy ( j )) ** 2 ). gt . & ( nbi % awidy ( j ) * nbi % awidz ( j )) ** 2 ) then cycle rejection_loop endif end select enddo aperture_loop valid_trajectory = . True . !! Convert to beam centerline coordinates to beam grid coordinates uvw_src = matmul ( nbi % basis , xyz_src ) + nbi % src uvw_ray = matmul ( nbi % basis , xyz_ray ) exit rejection_loop enddo rejection_loop !Set Default trajectory in case rejection sampling fails if (. not . valid_trajectory ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"MC_NBI: Failed to find trajectory though aperture(s). Using beam centerline.\" endif uvw_src = nbi % src uvw_ray = nbi % axis endif vnbi = uvw_ray / norm2 ( uvw_ray ) !! Determine start position on beam grid call grid_intersect ( uvw_src , vnbi , length , rnbi , r_exit ) if ( length . le . 0.0 ) then err = . True . nbi_outside = nbi_outside + 1 endif !! Check if start position is in the plasma call in_plasma ( rnbi , inp ) if ( inp ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"MC_NBI: A beam neutral has started inside the plasma.\" write ( * , '(a)' ) \"Move the beam grid closer to the source to fix\" endif stop endif !! Determine velocity of neutrals corrected by efrac vnbi = vnbi * nbi % vinj / sqrt ( real ( efrac )) end subroutine mc_nbi !============================================================================= !------------------------Primary Simulation Routines-------------------------- !============================================================================= subroutine ndmc !+ Calculates neutral beam deposition and spectra integer :: neut_type !! full half third energy real ( Float64 ) :: nlaunch !! nr. of markers real ( Float64 ) :: nneutrals !! # NBI particles real ( Float64 ), dimension ( 3 ) :: vnbi !! velocities(full..) real ( Float64 ), dimension ( 3 ) :: rnbi !! initial position integer ( Int64 ) :: jj , ii , kk , cnt integer :: ncell type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks integer ( Int64 ), dimension ( 3 ) :: nl_birth type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: states , dens real ( Float64 ) :: photons , iflux integer ( Int32 ), dimension ( 3 ) :: ind real ( Float64 ), dimension ( 1 ) :: randomu integer , dimension ( 1 ) :: randi logical :: err if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) inputs % n_nbi endif !! # of injected neutrals = NBI power/energy_per_particle nneutrals = 1.d6 * nbi % pinj / ( 1.d3 * nbi % einj * e0 & * ( nbi % current_fractions ( 1 ) & + nbi % current_fractions ( 2 ) / 2.d0 & + nbi % current_fractions ( 3 ) / 3.d0 ) ) nlaunch = real ( inputs % n_nbi ) cnt = 0 !$OMP PARALLEL DO schedule(guided) & !$OMP& private(vnbi,rnbi,tracks,ncell,plasma,nl_birth,randi, & !$OMP& states,dens,iflux,photons,neut_type,jj,ii,kk,ind,err) loop_over_markers : do ii = 1 , inputs % n_nbi if ( inputs % calc_birth . ge . 1 ) then !! Determine the type of birth particle (1, 2, or 3) nl_birth = 0 do kk = 1 , inputs % n_birth call randind ( nbi % current_fractions , randi ) nl_birth ( randi ( 1 )) = nl_birth ( randi ( 1 )) + 1 enddo endif energy_fractions : do neut_type = 1 , 3 !! (type = 1: full energy, =2: half energy, =3: third energy call mc_nbi ( vnbi , neut_type , rnbi , err ) if ( err ) cycle energy_fractions call track ( rnbi , vnbi , tracks , ncell ) if ( ncell . eq . 0 ) cycle energy_fractions !! Solve collisional radiative model along track states = 0.d0 states ( 1 ) = nneutrals * nbi % current_fractions ( neut_type ) / beam_grid % dv loop_along_track : do jj = 1 , ncell iflux = sum ( states ) ind = tracks ( jj )% ind call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vnbi , tracks ( jj )% time , states , dens , photons ) call store_neutrals ( ind , neut_type , dens / nlaunch ) tracks ( jj )% flux = ( iflux - sum ( states )) * beam_grid % dv / nlaunch if ( inputs % calc_birth . ge . 1 ) then call store_births ( ind , neut_type , tracks ( jj )% flux ) endif if (( photons . gt . 0.d0 ). and .( inputs % calc_bes . ge . 1 )) then call store_bes_photons ( tracks ( jj )% pos , vnbi , photons / nlaunch , neut_type ) endif enddo loop_along_track if ( inputs % calc_birth . ge . 1 ) then !! Sample according to deposited flux along neutral trajectory !$OMP CRITICAL(ndmc_birth) do kk = 1 , nl_birth ( neut_type ) call randind ( tracks ( 1 : ncell )% flux , randi ) call randu ( randomu ) birth % neut_type ( birth % cnt ) = neut_type birth % ind (:, birth % cnt ) = tracks ( randi ( 1 ))% ind birth % vi (:, birth % cnt ) = vnbi birth % ri (:, birth % cnt ) = tracks ( randi ( 1 ))% pos + & vnbi * ( tracks ( randi ( 1 ))% time * ( randomu ( 1 ) - 0.5 )) birth % cnt = birth % cnt + 1 enddo !$OMP END CRITICAL(ndmc_birth) endif enddo energy_fractions if ( inputs % verbose . ge . 2 ) then cnt = cnt + 1 WRITE ( * , '(f7.2,\"% completed\",a,$)' ) 100 * cnt / nlaunch , char ( 13 ) endif enddo loop_over_markers !$OMP END PARALLEL DO if ( nbi_outside . gt . 0 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(T4,a, f6.2)' ) 'Percent of markers outside the grid: ' , & 10 0. * nbi_outside / ( 3. * inputs % n_nbi ) endif if ( sum ( neut % dens ). eq . 0 ) stop 'Beam does not intersect the grid!' endif end subroutine ndmc subroutine bremsstrahlung !+ Calculates bremsstrahlung type ( LocalProfiles ) :: plasma integer :: i , ichan , nc , ic real ( Float64 ) :: dlength , dlambda , gaunt , max_length real ( Float64 ) :: spot_size , theta , sqrt_rho real ( Float64 ), dimension ( 2 ) :: randomu real ( Float64 ), dimension ( 3 ) :: vi , xyz , r0 real ( Float64 ), dimension ( 3 , 3 ) :: basis real ( Float64 ), dimension (:), allocatable :: lambda_arr , brems allocate ( lambda_arr ( inputs % nlambda )) allocate ( brems ( inputs % nlambda )) do i = 1 , inputs % nlambda lambda_arr ( i ) = 10 * (( i - 0.5 ) * inputs % dlambda + inputs % lambdamin ) ! [A] enddo dlambda = 10 * inputs % dlambda ![A] dlength = 0.3 !cm !! $OMP PARALLEL DO schedule(guided) private(ichan,xyz,vi,basis,spot_size, & !! $OMP& ic, nc,randomu,sqrt_rho,theta,r0,plasma,gaunt,brems) loop_over_channels : do ichan = 1 , spec_chords % nchan xyz = spec_chords % los ( ichan )% lens vi = spec_chords % los ( ichan )% axis vi = vi / norm2 ( vi ) spot_size = spec_chords % los ( ichan )% spot_size call line_basis ( xyz , vi , basis ) if ( spot_size . le . 0.d0 ) then nc = 1 else nc = 100 endif do ic = 1 , nc call randu ( randomu ) sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) r0 ( 1 ) = 0.d0 r0 ( 2 ) = spot_size * sqrt_rho * cos ( theta ) r0 ( 3 ) = spot_size * sqrt_rho * sin ( theta ) r0 = matmul ( basis , r0 ) + xyz ! Find edge of plasma call get_plasma ( plasma , pos = r0 ) max_length = 0.0 do while (. not . plasma % in_plasma ) r0 = r0 + vi * dlength ! move dlength call get_plasma ( plasma , pos = r0 ) max_length = max_length + dlength if ( max_length . gt . 300 ) cycle loop_over_channels enddo ! Calculate bremsstrahlung along los do while ( plasma % in_plasma ) if ( plasma % te . gt . 0.0 ) then gaunt = 5.542 - ( 3.108 - log ( plasma % te )) * ( 0.6905 - 0.1323 / plasma % zeff ) brems = 7.57d-9 * gaunt * plasma % dene ** 2 * plasma % zeff / ( lambda_arr & * sqrt ( plasma % te * 100 0.0 )) * exp ( - h_planck * c0 / ( lambda_arr * plasma % te * 100 0.0 )) & * dlambda * ( 4.d0 * pi ) * 1.d-4 spec % brems (:, ichan ) = spec % brems (:, ichan ) + ( brems * dlength * 1.d-2 ) / nc endif ! Take a step r0 = r0 + vi * dlength call get_plasma ( plasma , pos = r0 ) enddo enddo if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) 100 * ichan / real ( spec_chords % nchan ), char ( 13 ) endif enddo loop_over_channels !! $OMP END PARALLEL DO deallocate ( lambda_arr , brems ) end subroutine bremsstrahlung subroutine dcx !+ Calculates Direct Charge Exchange (DCX) neutral density and spectra integer :: i , j , k !indices of cells integer ( Int64 ) :: idcx !! counter real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vihalo integer , dimension ( 3 ) :: ind !! actual cell integer , dimension ( 3 ) :: neut_types = [ 1 , 2 , 3 ] !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( Float64 ), dimension ( nlevs ) :: prob !!  Prob. for CX !! Collisiional radiative model along track real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states integer :: ncell type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks !! Particle tracks integer :: jj !! counter along track real ( Float64 ) :: tot_denn , photons !! photon flux real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch !! approx. density real ( Float64 ) :: papprox_tot , ccnt , inv_ng halo_iter_dens ( halo_type ) = 0.d0 papprox = 0.d0 papprox_tot = 0.d0 tot_denn = 0.d0 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) tot_denn = sum ( neut % dens (:, nbif_type , i , j , k )) + & sum ( neut % dens (:, nbih_type , i , j , k )) + & sum ( neut % dens (:, nbit_type , i , j , k )) papprox ( i , j , k ) = tot_denn * ( plasma % denp - plasma % denf ) if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo call get_nlaunch ( inputs % n_dcx , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( sum ( nlaunch ), Int64 ) endif ccnt = 0.d0 inv_ng = 10 0.0 / real ( beam_grid % ngrid ) loop_along_z : do k = 1 , beam_grid % nz loop_along_y : do j = 1 , beam_grid % ny loop_along_x : do i = 1 , beam_grid % nx !! Loop over the markers !$OMP PARALLEL DO schedule(guided) private(idcx,ind,vihalo, & !$OMP& ri,tracks,ncell,prob,denn,states,jj,photons,plasma) loop_over_dcx : do idcx = 1 , int ( nlaunch ( i , j , k ), Int64 ) !! Calculate ri,vhalo and track ind = [ i , j , k ] call mc_halo ( ind , vihalo , ri ) call track ( ri , vihalo , tracks , ncell ) if ( ncell . eq . 0 ) cycle loop_over_dcx !! Calculate CX probability call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vihalo , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle loop_over_dcx !! Solve collisional radiative model along track call get_plasma ( plasma , pos = tracks ( 1 )% pos ) states = prob * ( plasma % denp - plasma % denf ) loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , thermal_ion , vihalo , tracks ( jj )% time , states , denn , photons ) call store_neutrals ( tracks ( jj )% ind , halo_type , denn / nlaunch ( i , j , k ), plasma % in_plasma ) if (( photons . gt . 0.d0 ). and .( inputs % calc_bes . ge . 1 )) then call store_bes_photons ( tracks ( jj )% pos , vihalo , photons / nlaunch ( i , j , k ), halo_type ) endif enddo loop_along_track enddo loop_over_dcx !$OMP END PARALLEL DO ccnt = ccnt + 1 if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) ccnt * inv_ng , char ( 13 ) endif enddo loop_along_x enddo loop_along_y enddo loop_along_z end subroutine dcx subroutine halo !+ Calculates halo neutral density and spectra integer :: i , j , k !indices of cells integer ( Int64 ) :: ihalo !! counter real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vihalo !! velocity bulk plasma ion integer , dimension ( 3 ) :: ind !! actual cell !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( Float64 ), dimension ( nlevs ) :: prob !!  Prob. for CX !! Collisiional radiative model along track real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states integer :: ncell type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks !! Particle Tracks integer :: jj !! counter along track real ( Float64 ) :: tot_denn , photons !! photon flux real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch !! approx. density real ( Float64 ) :: papprox_tot , ccnt , inv_ng !! Halo iteration integer :: hh !! counters real ( Float64 ) :: dcx_dens , halo_iteration_dens integer :: s1type ! halo iteration integer :: s2type ! halo iteration s1type = fida_type s2type = brems_type dcx_dens = halo_iter_dens ( halo_type ) if ( dcx_dens . eq . 0 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'HALO: Density of DCX-neutrals is zero' endif stop endif inv_ng = 10 0.0 / real ( beam_grid % ngrid ) neut % dens (:, s1type ,:,:,:) = neut % dens (:, halo_type ,:,:,:) iterations : do hh = 1 , 200 papprox = 0.d0 papprox_tot = 0.d0 tot_denn = 0.d0 halo_iter_dens ( s2type ) = 0.d0 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) tot_denn = sum ( neut % dens (:, s1type , i , j , k )) papprox ( i , j , k ) = tot_denn * ( plasma % denp - plasma % denf ) if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo call get_nlaunch ( inputs % n_halo , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( sum ( nlaunch ), Int64 ) endif ccnt = 0.d0 !$OMP PARALLEL DO schedule(guided) collapse(3) private(i,j,k,ihalo,ind,vihalo, & !$OMP& ri,tracks,ncell,prob,denn,states,jj,photons,plasma) loop_along_z : do k = 1 , beam_grid % nz loop_along_y : do j = 1 , beam_grid % ny loop_along_x : do i = 1 , beam_grid % nx !! Loop over the markers loop_over_halos : do ihalo = 1 , int ( nlaunch ( i , j , k ), Int64 ) !! Calculate ri,vhalo and track ind = [ i , j , k ] call mc_halo ( ind , vihalo , ri ) call track ( ri , vihalo , tracks , ncell ) if ( ncell . eq . 0 ) cycle loop_over_halos !! Calculate CX probability call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vihalo ,[ s1type ], prob ) if ( sum ( prob ). le . 0. ) cycle loop_over_halos !! Solve collisional radiative model along track call get_plasma ( plasma , pos = tracks ( 1 )% pos ) states = prob * plasma % denp loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , thermal_ion , vihalo , tracks ( jj )% time , states , denn , photons ) call store_neutrals ( tracks ( jj )% ind , s2type , & denn / nlaunch ( i , j , k ), plasma % in_plasma ) if (( photons . gt . 0.d0 ). and .( inputs % calc_bes . ge . 1 )) then call store_bes_photons ( tracks ( jj )% pos , vihalo , photons / nlaunch ( i , j , k ), halo_type ) endif enddo loop_along_track enddo loop_over_halos ccnt = ccnt + 1 if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) ccnt * inv_ng , char ( 13 ) endif enddo loop_along_x enddo loop_along_y enddo loop_along_z !$OMP END PARALLEL DO halo_iteration_dens = halo_iter_dens ( s2type ) neut % dens (:, halo_type ,:,:,:) = neut % dens (:, halo_type ,:,:,:) & + neut % dens (:, s2type ,:,:,:) neut % dens (:, s1type ,:,:,:) = neut % dens (:, s2type ,:,:,:) neut % dens (:, s2type ,:,:,:) = 0. if ( halo_iteration_dens / dcx_dens . gt . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"HALO: Halo generation density exceeded DCX density. This shouldn't happen.\" endif exit iterations endif inputs % n_halo = int ( inputs % n_dcx * halo_iteration_dens / dcx_dens , Int64 ) if ( inputs % n_halo . lt . inputs % n_dcx * 0.01 ) exit iterations enddo iterations !! set the neutral density in s1type(fida_type) and s2type (brems) to 0! neut % dens (:, s1type ,:,:,:) = 0.d0 neut % dens (:, s2type ,:,:,:) = 0.d0 end subroutine halo subroutine fida_f !+ Calculate FIDA emission using a Fast-ion distribution function F(E,p,r,z) integer :: i , j , k , ip !! indices  x,y,z of cells integer ( Int64 ) :: iion real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions real ( Float64 ) :: denf !! fast-ion density integer , dimension ( 3 ) :: ind !! new actual cell integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] logical :: los_intersect !! Determination of the CX probability type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: prob !! Prob. for CX !! Collisiional radiative model along track integer :: ncell integer :: jj !! counter along track type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks real ( Float64 ) :: photons !! photon flux real ( Float64 ), dimension ( nlevs ) :: states !! Density of n-states real ( Float64 ), dimension ( nlevs ) :: denn !! Number of particles to launch integer ( kind = 8 ) :: pcnt real ( Float64 ) :: papprox_tot , inv_maxcnt , cnt , eb , ptch integer , dimension ( 3 , beam_grid % ngrid ) :: pcell real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch !! approx. density !! Estimate how many particles to launch in each cell papprox = 0.d0 papprox_tot = 0.d0 pcnt = 1 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) papprox ( i , j , k ) = ( sum ( neut % dens (:, nbif_type , i , j , k )) + & sum ( neut % dens (:, nbih_type , i , j , k )) + & sum ( neut % dens (:, nbit_type , i , j , k )) + & sum ( neut % dens (:, halo_type , i , j , k ))) * & plasma % denf if ( papprox ( i , j , k ). gt . 0 ) then pcell (:, pcnt ) = ind pcnt = pcnt + 1 endif if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo pcnt = pcnt - 1 inv_maxcnt = 10 0.0 / real ( pcnt ) call get_nlaunch ( inputs % n_fida , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( sum ( nlaunch ), Int64 ) endif !! Loop over all cells that have neutrals cnt = 0.d0 loop_over_cells : do ip = 1 , int ( pcnt ) i = pcell ( 1 , ip ) j = pcell ( 2 , ip ) k = pcell ( 3 , ip ) ind = [ i , j , k ] !$OMP PARALLEL DO schedule(guided) private(ip,iion,vi,ri,fields, & !$OMP tracks,ncell,jj,plasma,prob,denn,states,photons,denf,eb,ptch) loop_over_fast_ions : do iion = 1 , int ( nlaunch ( i , j , k ), Int64 ) !! Sample fast ion distribution for velocity and position call mc_fastion ( ind , fields , eb , ptch , denf ) if ( denf . eq . 0.0 ) cycle loop_over_fast_ions !! Correct for gyro motion and get particle position and velocity call gyro_correction ( fields , eb , ptch , ri , vi ) !! Find the particles path through the beam grid call track ( ri , vi , tracks , ncell , los_intersect ) if (. not . los_intersect ) cycle loop_over_fast_ions if ( ncell . eq . 0 ) cycle loop_over_fast_ions !! Calculate CX probability with beam and halo neutrals call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle loop_over_fast_ions !! Calculate initial states of particle states = prob * denf !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fida_photons ( tracks ( jj )% pos , vi , photons / nlaunch ( i , j , k )) enddo loop_along_track enddo loop_over_fast_ions !$OMP END PARALLEL DO cnt = cnt + 1 if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_cells end subroutine fida_f subroutine fida_mc !+ Calculate FIDA emission using a Monte Carlo Fast-ion distribution integer :: iion , iphi , nphi type ( FastIon ) :: fast_ion type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma real ( Float64 ) :: phi real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions !! Determination of the CX probability real ( Float64 ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( Float64 ), dimension ( nlevs ) :: prob !! Prob. for CX !! Collisiional radiative model along track real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states integer :: ncell type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks logical :: los_intersect integer :: jj !! counter along track real ( Float64 ) :: photons !! photon flux integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ) :: s , c real ( Float64 ) :: maxcnt , inv_maxcnt , cnt real ( Float64 ), dimension ( 1 ) :: randomu maxcnt = particles % nparticle inv_maxcnt = 10 0.d0 / maxcnt nphi = ceiling ( dble ( inputs % n_fida ) / particles % nparticle ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( particles % nparticle * nphi , Int64 ) endif cnt = 0.0 !$OMP PARALLEL DO schedule(guided) private(iion,iphi,fast_ion,vi,ri,phi,tracks,s,c, & !$OMP& randomu,plasma,fields,uvw,uvw_vi,ncell,jj,prob,denn,los_intersect,states,photons) loop_over_fast_ions : do iion = 1 , particles % nparticle fast_ion = particles % fast_ion ( iion ) cnt = cnt + 1 if ( fast_ion % vabs . eq . 0 ) cycle loop_over_fast_ions if (. not . fast_ion % cross_grid ) cycle loop_over_fast_ions phi_loop : do iphi = 1 , nphi !! Pick random torodial angle call randu ( randomu ) phi = fast_ion % phi_enter + fast_ion % delta_phi * randomu ( 1 ) s = sin ( phi ) ; c = cos ( phi ) !! Calculate position in machine coordinates uvw ( 1 ) = fast_ion % r * c uvw ( 2 ) = fast_ion % r * s uvw ( 3 ) = fast_ion % z !! Convert to beam grid coordinates call uvw_to_xyz ( uvw , ri ) if ( inputs % dist_type . eq . 2 ) then !! Get electomagnetic fields call get_fields ( fields , pos = ri ) !! Correct for gyro motion and get particle position and velocity call gyro_correction ( fields , fast_ion % energy , fast_ion % pitch , ri , vi ) else !! Full Orbit !! Calculate velocity vector uvw_vi ( 1 ) = c * fast_ion % vr - s * fast_ion % vt uvw_vi ( 2 ) = s * fast_ion % vr + c * fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) endif !! Track particle through grid call track ( ri , vi , tracks , ncell , los_intersect ) if (. not . los_intersect ) cycle phi_loop if ( ncell . eq . 0 ) cycle phi_loop !! Calculate CX probability call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle phi_loop !! Calculate the spectra produced in each cell along the path states = prob * fast_ion % weight / nphi loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fida_photons ( tracks ( jj )% pos , vi , photons , fast_ion % class ) enddo loop_along_track enddo phi_loop if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_fast_ions !$OMP END PARALLEL DO end subroutine fida_mc subroutine npa_f !+ Calculate NPA flux using a fast-ion distribution function F(E,p,r,z) integer :: i , j , k , det , ip integer ( Int64 ) :: iion real ( Float64 ), dimension ( 3 ) :: rg , ri , rf , vi integer , dimension ( 3 ) :: ind , pind real ( Float64 ) :: denf integer , dimension ( 3 , beam_grid % ngrid ) :: pcell type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields type ( GyroSurface ) :: gs real ( Float64 ), dimension ( 2 , 4 ) :: gyrange integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] real ( Float64 ), dimension ( nlevs ) :: prob real ( Float64 ), dimension ( nlevs ) :: states real ( Float64 ) :: flux , theta , dtheta , eb , ptch integer :: inpa , pcnt , ichan , nrange , ir real ( Float64 ) :: papprox_tot , maxcnt , cnt , inv_maxcnt real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch papprox = 0.d0 papprox_tot = 0.d0 pcnt = 1 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) papprox ( i , j , k ) = ( sum ( neut % dens (:, nbif_type , i , j , k )) + & sum ( neut % dens (:, nbih_type , i , j , k )) + & sum ( neut % dens (:, nbit_type , i , j , k )) + & sum ( neut % dens (:, halo_type , i , j , k ))) * & plasma % denf if ( papprox ( i , j , k ). gt . 0 ) then pcell (:, pcnt ) = ind pcnt = pcnt + 1 endif if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo pcnt = pcnt - 1 maxcnt = real ( pcnt ) inv_maxcnt = 10 0.0 / maxcnt call get_nlaunch ( inputs % n_npa , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i12)' ) int ( sum ( nlaunch ), Int64 ) endif !! Loop over all cells that can contribute to NPA signal cnt = 0.d0 loop_over_cells : do ip = 1 , int ( pcnt ) i = pcell ( 1 , ip ) j = pcell ( 2 , ip ) k = pcell ( 3 , ip ) ind = [ i , j , k ] !$OMP PARALLEL DO schedule(guided) private(iion,ichan,fields,nrange,gyrange, & !$OMP& pind,vi,ri,rf,det,plasma,prob,states,flux,denf,eb,ptch,gs,ir,theta,dtheta) loop_over_fast_ions : do iion = 1 , int ( nlaunch ( i , j , k ), Int64 ) !! Sample fast ion distribution for energy and pitch call mc_fastion ( ind , fields , eb , ptch , denf ) if ( denf . eq . 0.0 ) cycle loop_over_fast_ions call gyro_surface ( fields , eb , ptch , gs ) detector_loop : do ichan = 1 , npa_chords % nchan call npa_gyro_range ( ichan , gs , gyrange , nrange ) if ( nrange . eq . 0 ) cycle detector_loop gyro_range_loop : do ir = 1 , nrange dtheta = gyrange ( 2 , ir ) theta = gyrange ( 1 , ir ) + 0.5 * dtheta call gyro_trajectory ( gs , theta , ri , vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf , ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"NPA_F: Missed Detector \" , ichan endif cycle gyro_range_loop endif !! Get beam grid indices at ri call get_indices ( ri , pind ) !! Calculate CX probability with beam and halo neutrals call get_beam_cx_prob ( pind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle gyro_range_loop !! Attenuate states as the particle move through plasma states = prob * denf call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = ( dtheta / ( 2 * pi )) * sum ( states ) * beam_grid % dv / nlaunch ( i , j , k ) call store_npa ( det , ri , rf , vi , flux ) enddo gyro_range_loop enddo detector_loop enddo loop_over_fast_ions !$OMP END PARALLEL DO cnt = cnt + 1 if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_cells if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Number of NPA particles that hit a detector: \",i8)' ) npa % npart endif end subroutine npa_f subroutine npa_mc !+ Calculate NPA flux using a Monte Carlo fast-ion distribution integer :: iion , iphi , nphi type ( FastIon ) :: fast_ion real ( Float64 ) :: phi , theta , dtheta real ( Float64 ), dimension ( 3 ) :: ri , rf , rg , vi integer :: det , j , ichan , ir , nrange type ( LocalEMFields ) :: fields type ( GyroSurface ) :: gs real ( Float64 ), dimension ( nlevs ) :: prob real ( Float64 ), dimension ( nlevs ) :: states real ( Float64 ) :: flux integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] integer , dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ), dimension ( 2 , 4 ) :: gyrange real ( Float64 ) :: s , c real ( Float64 ) :: maxcnt , inv_maxcnt , cnt real ( Float64 ), dimension ( 1 ) :: randomu maxcnt = particles % nparticle inv_maxcnt = 10 0.d0 / maxcnt nphi = ceiling ( dble ( inputs % n_npa ) / particles % nparticle ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( particles % nparticle * nphi , Int64 ) endif cnt = 0.0 !$OMP PARALLEL DO schedule(guided) private(iion,iphi,ind,fast_ion,vi,ri,rf,phi,s,c,ir, & !$OMP& randomu,rg,fields,uvw,uvw_vi,prob,states,flux,det,ichan,gs,nrange,gyrange,theta,dtheta) loop_over_fast_ions : do iion = 1 , particles % nparticle cnt = cnt + 1 fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0 ) cycle loop_over_fast_ions if (. not . fast_ion % cross_grid ) cycle loop_over_fast_ions phi_loop : do iphi = 1 , nphi !! Pick random torodial angle call randu ( randomu ) phi = fast_ion % phi_enter + fast_ion % delta_phi * randomu ( 1 ) s = sin ( phi ) ; c = cos ( phi ) !! Calculate position in machine coordinates uvw ( 1 ) = fast_ion % r * c uvw ( 2 ) = fast_ion % r * s uvw ( 3 ) = fast_ion % z if ( inputs % dist_type . eq . 2 ) then !! Convert to beam grid coordinates call uvw_to_xyz ( uvw , rg ) !! Get electomagnetic fields call get_fields ( fields , pos = rg ) !! Correct for gyro motion and get position and velocity call gyro_surface ( fields , fast_ion % energy , fast_ion % pitch , gs ) detector_loop : do ichan = 1 , npa_chords % nchan call npa_gyro_range ( ichan , gs , gyrange , nrange ) if ( nrange . eq . 0 ) cycle detector_loop gyro_range_loop : do ir = 1 , nrange dtheta = gyrange ( 2 , ir ) theta = gyrange ( 1 , ir ) + 0.5 * dtheta call gyro_trajectory ( gs , theta , ri , vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf , det = ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"NPA_MC: Missed Detector \" , ichan endif cycle gyro_range_loop endif !! Get beam grid indices at ri call get_indices ( ri , ind ) !! Calculate CX probability with beam and halo neutrals call get_beam_cx_prob ( ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle gyro_range_loop !! Attenuate states as the particle move through plasma states = prob * fast_ion % weight / nphi call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = ( dtheta / ( 2 * pi )) * sum ( states ) * beam_grid % dv call store_npa ( det , ri , rf , vi , flux , fast_ion % class ) enddo gyro_range_loop enddo detector_loop else !! Full Orbit !! Convert to beam grid coordinates call uvw_to_xyz ( uvw , ri ) !! Calculate velocity vector uvw_vi ( 1 ) = c * fast_ion % vr - s * fast_ion % vt uvw_vi ( 2 ) = s * fast_ion % vr + c * fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf ) if ( det . eq . 0 ) cycle phi_loop !! Get beam grid indices at ri call get_indices ( ri , ind ) !! Calculate CX probability with beam and halo neutrals call get_beam_cx_prob ( ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle phi_loop !! Attenuate states as the particle moves though plasma states = prob * fast_ion % weight / nphi call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = sum ( states ) * beam_grid % dv call store_npa ( det , ri , rf , vi , flux , fast_ion % class ) endif enddo phi_loop if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_fast_ions !$OMP END PARALLEL DO if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Number of NPA particles that hit a detector: \",i8)' ) npa % npart endif end subroutine npa_mc subroutine neutron_f !+ Calculate neutron emission rate using a fast-ion distribution function F(E,p,r,z) integer :: ir , iz , ie , ip , iphi , nphi type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( Float64 ) :: eb , pitch , r , z real ( Float64 ) :: erel , rate real ( Float64 ), dimension ( 3 ) :: rg , ri real ( Float64 ), dimension ( 3 ) :: vi real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ) :: vnet_square , factor real ( Float64 ) :: maxcnt , inv_maxcnt , cnt allocate ( neutron % weight ( fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz )) neutron % weight = 0.d0 nphi = 20 maxcnt = fbm % nr * fbm % nz inv_maxcnt = 10 0.d0 / maxcnt cnt = 0.0 !$OMP PARALLEL DO schedule(guided) private(fields,vi,ri,rg,pitch,eb,& !$OMP& ir,iz,ie,ip,iphi,plasma,factor,uvw,uvw_vi,vnet_square,rate,erel) z_loop : do iz = 1 , fbm % nz r_loop : do ir = 1 , fbm % nr cnt = cnt + 1 !! Calculate position uvw ( 1 ) = fbm % r ( ir ) uvw ( 2 ) = 0.d0 uvw ( 3 ) = fbm % z ( iz ) call uvw_to_xyz ( uvw , rg ) !! Get fields call get_fields ( fields , pos = rg ) if (. not . fields % in_plasma ) cycle r_loop factor = 2 * pi * fbm % r ( ir ) * fbm % dE * fbm % dp * fbm % dr * fbm % dz / nphi !! Loop over energy/pitch/phi pitch_loop : do ip = 1 , fbm % npitch pitch = fbm % pitch ( ip ) energy_loop : do ie = 1 , fbm % nenergy eb = fbm % energy ( ie ) gyro_loop : do iphi = 1 , nphi call gyro_correction ( fields , eb , pitch , ri , vi ) !! Get plasma parameters at particle position call get_plasma ( plasma , pos = ri ) if (. not . plasma % in_plasma ) cycle gyro_loop !! Calculate effective beam energy vnet_square = dot_product ( vi - plasma % vrot , vi - plasma % vrot ) ![cm/s] erel = v2_to_E_per_amu * inputs % ab * vnet_square ![kev] !! Get neutron production rate call get_neutron_rate ( plasma , erel , rate ) neutron % weight ( ie , ip , ir , iz ) = neutron % weight ( ie , ip , ir , iz ) & + rate * factor rate = rate * fbm % f ( ie , ip , ir , iz ) * factor !! Store neutrons call store_neutrons ( rate ) enddo gyro_loop enddo energy_loop enddo pitch_loop if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo r_loop enddo z_loop !$OMP END PARALLEL DO if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,A,ES14.5,\" [neutrons/s]\")' ), 'Rate:   ' , sum ( neutron % rate ) write ( * , '(30X,a)' ) '' endif call write_neutrons () end subroutine neutron_f subroutine neutron_mc !+ Calculate neutron flux using a Monte Carlo Fast-ion distribution integer :: iion , nphi , iphi type ( FastIon ) :: fast_ion type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( Float64 ) :: eb , rate real ( Float64 ), dimension ( 3 ) :: ri , rg real ( Float64 ), dimension ( 3 ) :: vi real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ) :: vnet_square real ( Float64 ) :: maxcnt , inv_maxcnt , cnt maxcnt = particles % nparticle inv_maxcnt = 10 0.d0 / maxcnt if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) particles % nparticle endif cnt = 0.0 rate = 0.0 nphi = 20 !$OMP PARALLEL DO schedule(guided) private(iion,fast_ion,vi,ri,rg, & !$OMP& plasma,fields,uvw,uvw_vi,vnet_square,rate,eb,iphi) loop_over_fast_ions : do iion = 1 , particles % nparticle cnt = cnt + 1 fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0.d0 ) cycle loop_over_fast_ions !! Calculate position uvw ( 1 ) = fast_ion % r uvw ( 2 ) = 0.0 uvw ( 3 ) = fast_ion % z if ( inputs % dist_type . eq . 2 ) then call uvw_to_xyz ( uvw , rg ) !! Get electomagnetic fields call get_fields ( fields , pos = rg ) if (. not . fields % in_plasma ) cycle loop_over_fast_ions gyro_loop : do iphi = 1 , nphi !! Correct for Gyro-motion call gyro_correction ( fields , fast_ion % energy , fast_ion % pitch , ri , vi ) !! Get plasma parameters call get_plasma ( plasma , pos = ri ) if (. not . plasma % in_plasma ) cycle gyro_loop !! Calculate effective beam energy vnet_square = dot_product ( vi - plasma % vrot , vi - plasma % vrot ) ![cm/s] eb = v2_to_E_per_amu * inputs % ab * vnet_square ![kev] !! Get neutron production rate call get_neutron_rate ( plasma , eb , rate ) rate = rate * fast_ion % weight * ( 2 * pi / fast_ion % delta_phi ) * beam_grid % dv / nphi !! Store neutrons call store_neutrons ( rate , fast_ion % class ) enddo gyro_loop else call uvw_to_xyz ( uvw , ri ) !! Get plasma parameters call get_plasma ( plasma , pos = ri ) if (. not . plasma % in_plasma ) cycle loop_over_fast_ions !! Calculate effective beam energy uvw_vi ( 1 ) = fast_ion % vr uvw_vi ( 2 ) = fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) vnet_square = dot_product ( vi - plasma % vrot , vi - plasma % vrot ) ![cm/s] eb = v2_to_E_per_amu * inputs % ab * vnet_square ![kev] !! Get neutron production rate call get_neutron_rate ( plasma , eb , rate ) rate = rate * fast_ion % weight * ( 2 * pi / fast_ion % delta_phi ) * beam_grid % dv !! Store neutrons call store_neutrons ( rate , fast_ion % class ) endif if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_fast_ions !$OMP END PARALLEL DO if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,A,ES14.5,\" [neutrons/s]\")' ), 'Rate:   ' , sum ( neutron % rate ) write ( * , '(30X,a)' ) '' endif call write_neutrons () end subroutine neutron_mc subroutine fida_weights_mc !+ Calculates FIDA weights integer :: i , j , k !! indices  x,y,z of cells integer ( Int64 ) :: iion , ip real ( Float64 ), dimension ( 3 ) :: ri , rg !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions integer , dimension ( 3 ) :: ind !! new actual cell integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] logical :: los_intersect !! Determination of the CX probability type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( Float64 ), dimension ( nlevs ) :: prob !! Prob. for CX !! Collisiional radiative model along track integer :: ncell integer :: jj !! counter along track type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks real ( Float64 ) :: photons !! photon flux real ( Float64 ), dimension ( nlevs ) :: states !! Density of n-states real ( Float64 ), dimension ( nlevs ) :: denn integer :: nwav real ( Float64 ) :: etov2 , energy , pitch real ( Float64 ) :: dE , dP , dEdP real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr integer , dimension ( 1 ) :: ienergy , ipitch real ( Float64 ), dimension ( 3 ) :: randomu3 !! Number of particles to launch integer ( kind = 8 ) :: pcnt real ( Float64 ) :: papprox_tot , inv_maxcnt , cnt , fbm_denf , phase_area integer , dimension ( 3 , beam_grid % ngrid ) :: pcell real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch !! approx. density nwav = inputs % nlambda_wght !! define arrays !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) dEdP = dE * dP phase_area = dEdP * real ( inputs % np_wght ) * real ( inputs % ne_wght ) !! allocate storage arrays allocate ( fweight % weight ( nwav , inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( fweight % mean_f ( inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Number of Channels: \",i5)' ) spec_chords % nchan write ( * , '(T2,\"Nlambda: \",i4)' ) nwav write ( * , '(T2,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T2,\"Maximum Energy: \",f7.2)' ) inputs % emax_wght write ( * , '(T2,\"LOS averaged: \",a)' ) \"False\" endif !! zero out arrays fweight % weight = 0.d0 fweight % mean_f = 0.d0 etov2 = 1.d0 / ( v2_to_E_per_amu * inputs % ab ) !! Estimate how many particles to launch in each cell papprox = 0.d0 papprox_tot = 0.d0 pcnt = 1 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) papprox ( i , j , k ) = ( sum ( neut % dens (:, nbif_type , i , j , k )) + & sum ( neut % dens (:, nbih_type , i , j , k )) + & sum ( neut % dens (:, nbit_type , i , j , k )) + & sum ( neut % dens (:, halo_type , i , j , k ))) if ( papprox ( i , j , k ). gt . 0 ) then pcell (:, pcnt ) = ind pcnt = pcnt + 1 endif if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo pcnt = pcnt - 1 inv_maxcnt = 10 0.0 / real ( pcnt ) call get_nlaunch ( 10 * inputs % n_fida , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( sum ( nlaunch ), Int64 ) endif !! Loop over all cells that have neutrals cnt = 0.d0 loop_over_cells : do ip = 1 , int ( pcnt ) i = pcell ( 1 , ip ) j = pcell ( 2 , ip ) k = pcell ( 3 , ip ) ind = [ i , j , k ] !$OMP PARALLEL DO schedule(guided) private(iion,vi,ri,rg,ienergy,ipitch, & !$OMP tracks,ncell,jj,plasma,fields,prob,denn,states,photons,energy,pitch, & !$OMP los_intersect,randomu3,fbm_denf) loop_over_fast_ions : do iion = 1 , int ( nlaunch ( i , j , k ), Int64 ) !! Sample fast ion distribution uniformally call randind ( inputs % ne_wght , ienergy ) call randind ( inputs % np_wght , ipitch ) call randu ( randomu3 ) energy = ebarr ( ienergy ( 1 )) + dE * ( randomu3 ( 1 ) - 0.5 ) pitch = ptcharr ( ipitch ( 1 )) + dP * ( randomu3 ( 2 ) - 0.5 ) if ( energy . le . 0 ) cycle loop_over_fast_ions call randu ( randomu3 ) rg = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] + beam_grid % dr * ( randomu3 - 0.5 ) !! Get velocity call get_fields ( fields , pos = rg ) if (. not . fields % in_plasma ) cycle loop_over_fast_ions call gyro_correction ( fields , energy , pitch , ri , vi ) fbm_denf = 0.0 if ( inputs % dist_type . eq . 1 ) then call get_ep_denf ( energy , pitch , fbm_denf , coeffs = fields % c ) endif !! Find the particles path through the beam grid call track ( ri , vi , tracks , ncell , los_intersect ) if (. not . los_intersect ) cycle loop_over_fast_ions if ( ncell . eq . 0 ) cycle loop_over_fast_ions !! Calculate CX probability with beam and halo neutrals call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle loop_over_fast_ions states = prob * 1.d20 !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fw_photons ( ienergy ( 1 ), ipitch ( 1 ), & tracks ( jj )% pos , vi , fbm_denf , photons / nlaunch ( i , j , k )) enddo loop_along_track enddo loop_over_fast_ions !$OMP END PARALLEL DO cnt = cnt + 1 if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_cells fweight % weight = (( 1.d-20 ) * phase_area / dEdP ) * fweight % weight fweight % mean_f = (( 1.d-20 ) * phase_area / dEdP ) * fweight % mean_f call write_fida_weights () end subroutine fida_weights_mc subroutine fida_weights_los !+ Calculates LOS averaged FIDA weights type ( LocalProfiles ) :: plasma , plasma_cell type ( LocalEMFields ) :: fields , fields_cell real ( Float64 ) :: denf real ( Float64 ) :: wght , wght_tot real ( Float64 ) :: photons !! photon flux real ( Float64 ) :: length type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks integer :: nwav integer ( Int32 ) :: i , j , k , ienergy , cid , cind integer ( Int32 ) :: ipitch , igyro , icell , ichan real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr , phiarr real ( Float64 ), dimension (:,:), allocatable :: mean_f real ( Float64 ), dimension ( 3 ) :: vi , vi_norm , vp real ( Float64 ), dimension ( 3 ) :: vnbi_f , vnbi_h , vnbi_t , vhalo real ( Float64 ), dimension ( 3 ) :: r_enter , r_exit real ( Float64 ) :: vabs , dE , dP !! Determination of the CX probability real ( Float64 ), dimension ( nlevs ) :: fdens , hdens , tdens , halodens real ( Float64 ), dimension ( nlevs ) :: rates real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states real ( Float64 ), dimension ( nlevs ) :: denn ! Density of n-states !! COLRAD real ( Float64 ) :: dt , max_dens , dlength , sigma_pi type ( LOSInters ) :: inter real ( Float64 ) :: eb , ptch , phi !! Solution of differential equation integer , dimension ( 3 ) :: ind !!actual cell real ( Float64 ), dimension ( 3 ) :: ri integer ( Int32 ) :: ncell real ( Float64 ) :: etov2 , dEdP nwav = inputs % nlambda_wght !! Define energy array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! Define pitch array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) dEdP = dE * dP !! define gyro - array allocate ( phiarr ( inputs % nphi_wght )) do i = 1 , inputs % nphi_wght phiarr ( i ) = real ( i - 0.5 ) * 2.d0 * pi / real ( inputs % nphi_wght ) enddo !! allocate storage arrays allocate ( fweight % mean_f ( inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( fweight % weight ( nwav , inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( mean_f ( inputs % ne_wght , inputs % np_wght )) !! zero out arrays fweight % weight = 0.d0 fweight % mean_f = 0.d0 mean_f = 0.d0 if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Number of Channels: \",i5)' ) spec_chords % nchan write ( * , '(T2,\"Nlambda: \",i4)' ) nwav write ( * , '(T2,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T2,\"Npitch: \",i3)' ) inputs % np_wght write ( * , '(T2,\"Ngyro: \", i3)' ) inputs % nphi_wght write ( * , '(T2,\"Maximum Energy: \",f7.2)' ) inputs % emax_wght write ( * , '(T2,\"LOS averaged: \",a)' ) \"True\" write ( * , * ) '' endif etov2 = 1.0 / ( v2_to_E_per_amu * inputs % ab ) chan_loop : do ichan = 1 , spec_chords % nchan fdens = 0.d0 ; hdens = 0.d0 ; tdens = 0.d0 ; halodens = 0.d0 plasma = plasma * 0.d0 fields = fields * 0.d0 wght_tot = 0.d0 mean_f = 0.d0 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx inter = spec_chords % inter ( i , j , k ) cid = 0 cind = 0 do while ( cid . ne . ichan . and . cind . lt . inter % nchan ) cind = cind + 1 cid = inter % los_elem ( cind )% id enddo if ( cid . eq . ichan ) then ind = [ i , j , k ] dlength = inter % los_elem ( cind )% length fdens = fdens + neut % dens (:, nbif_type , i , j , k ) * dlength hdens = hdens + neut % dens (:, nbih_type , i , j , k ) * dlength tdens = tdens + neut % dens (:, nbit_type , i , j , k ) * dlength halodens = halodens + neut % dens (:, halo_type , i , j , k ) * dlength wght = sum ( neut % dens ( 3 , 1 : 4 , i , j , k )) * dlength call get_plasma ( plasma_cell , ind = ind ) call get_fields ( fields_cell , ind = ind ) plasma = plasma + wght * plasma_cell fields = fields + wght * fields_cell if ( inputs % dist_type . eq . 1 ) then do ipitch = 1 , inputs % np_wght do ienergy = 1 , inputs % ne_wght call get_ep_denf ( ebarr ( ienergy ), ptcharr ( ipitch ), denf , coeffs = fields_cell % c ) mean_f ( ienergy , ipitch ) = mean_f ( ienergy , ipitch ) + wght * denf enddo enddo endif wght_tot = wght_tot + wght endif enddo enddo enddo if ( wght_tot . le . 0 ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Skipping channel \",i5,\": Neutral density is zero\")' ) ichan endif cycle chan_loop else plasma = plasma / wght_tot plasma % in_plasma = . True . fields = fields / wght_tot fields % in_plasma = . True . mean_f = mean_f / wght_tot if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Channel: \",i5)' ) ichan write ( * , '(T4,\"Radius: \",f7.2)' ) spec_chords % radius ( ichan ) write ( * , '(T4,\"Mean Fast-ion Density: \",ES14.5)' ) sum ( mean_f ) * dEdP write ( * , * ) '' endif endif ri = plasma % pos vp = ri - spec_chords % los ( ichan )% lens vnbi_f = ri - nbi % src vnbi_f = vnbi_f / norm2 ( vnbi_f ) * nbi % vinj vnbi_h = vnbi_f / sqrt ( 2.d0 ) vnbi_t = vnbi_f / sqrt ( 3.d0 ) sigma_pi = spec_chords % los ( ichan )% sigma_pi dlength = 1.d0 !$OMP PARALLEL DO schedule(guided) collapse(3) private(eb,vabs,ptch,phi,vi,vi_norm, & !$OMP& r_enter,r_exit,length,max_dens,ind,tracks,ncell,dt,icell,states,rates, & !$OMP& vhalo,denn,denf,photons,ienergy,ipitch,igyro) do ienergy = 1 , inputs % ne_wght do ipitch = 1 , inputs % np_wght do igyro = 1 , inputs % nphi_wght eb = ebarr ( ienergy ) vabs = sqrt ( eb * etov2 ) ptch = ptcharr ( ipitch ) phi = phiarr ( igyro ) call pitch_to_vec ( ptch , phi , fields , vi_norm ) vi = vabs * vi_norm call grid_intersect ( ri , vi , length , r_enter , r_exit ) call track ( r_enter , vi , tracks , ncell ) max_dens = 0.d0 do icell = 1 , ncell ind = tracks ( icell )% ind tracks ( icell )% flux = sum ( neut % dens ( 3 , 1 : 4 , ind ( 1 ), ind ( 2 ), ind ( 3 ))) if ( tracks ( icell )% flux . gt . max_dens ) max_dens = tracks ( icell )% flux enddo dt = 0.d0 do icell = 1 , ncell if ( tracks ( icell )% flux . gt .( 0.5 * max_dens )) then dt = dt + tracks ( icell )% time endif enddo states = 0.d0 call neut_rates ( fdens , vi , vnbi_f , rates ) states = states + rates call neut_rates ( hdens , vi , vnbi_h , rates ) states = states + rates call neut_rates ( tdens , vi , vnbi_t , rates ) states = states + rates do i = 1 , int ( n_halo_neutrate ) call mc_halo ( ind , vhalo , plasma_in = plasma ) call neut_rates ( halodens , vi , vhalo , rates ) states = states + rates / real ( n_halo_neutrate ) enddo call colrad ( plasma , beam_ion , vi , dt , states , denn , photons ) denf = mean_f ( ienergy , ipitch ) * dEdP photons = photons / real ( inputs % nphi_wght ) call store_fw_photons_at_chan ( ichan , ienergy , ipitch , & vp , vi , fields , dlength , sigma_pi , denf , photons ) enddo enddo enddo !$OMP END PARALLEL DO enddo chan_loop fweight % mean_f = fweight % mean_f / ( dEdP ) call write_fida_weights () end subroutine fida_weights_los subroutine npa_weights !+ Calculates NPA weights type ( LocalEMFields ) :: fields type ( NPAProbability ) :: phit real ( Float64 ) :: pitch real ( Float64 ) :: pcxa integer ( Int32 ) :: det integer ( Int32 ) :: ii , jj , kk , i , ic !!indices integer , dimension ( 1 ) :: ipitch real ( Float64 ), dimension ( 3 ) :: vi , vi_norm real ( Float64 ) :: vabs , fbm_denf , dE , dP , ccnt real ( Float64 ), dimension ( nlevs ) :: pcx !! Rate coefficiants for CX real ( Float64 ), dimension ( nlevs ) :: states , states_i ! Density of n-states integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] real ( Float64 ), dimension ( 3 ) :: pos , dpos , r_gyro integer ( Int32 ) :: ichan real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Number of Channels: \",i3)' ) npa_chords % nchan write ( * , '(T2,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T2,\"Npitch: \",i3)' ) inputs % np_wght write ( * , '(T2,\"Maximum energy: \",f7.2)' ) inputs % emax_wght write ( * , * ) '' endif !! define storage arrays allocate ( nweight % emissivity ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % attenuation ( inputs % ne_wght , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % cx ( inputs % ne_wght , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % weight ( inputs % ne_wght , & inputs % np_wght , & npa_chords % nchan )) allocate ( nweight % flux ( inputs % ne_wght , npa_chords % nchan )) nweight % emissivity = 0.d0 nweight % attenuation = 0.d0 nweight % cx = 0.d0 nweight % weight = 0.d0 nweight % flux = 0.d0 loop_over_channels : do ichan = 1 , npa_chords % nchan if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Channel: \",i3)' ) ichan write ( * , '(T4,\"Radius: \",f10.3)' ) npa_chords % radius ( ichan ) endif ccnt = 0.d0 !$OMP PARALLEL DO schedule(guided) collapse(3) private(ii,jj,kk,fields,phit,& !$OMP& ic,det,pos,dpos,r_gyro,pitch,ipitch,vabs,vi,pcx,pcxa,states,states_i,vi_norm,fbm_denf) loop_along_z : do kk = 1 , beam_grid % nz loop_along_y : do jj = 1 , beam_grid % ny loop_along_x : do ii = 1 , beam_grid % nx phit = npa_chords % phit ( ii , jj , kk , ichan ) if ( phit % p . gt . 0.d0 ) then pos = [ beam_grid % xc ( ii ), beam_grid % yc ( jj ), beam_grid % zc ( kk )] call get_fields ( fields , pos = pos ) if (. not . fields % in_plasma ) cycle loop_along_x !!Check if it hits a detector just to make sure dpos = phit % eff_rd vi_norm = phit % dir call hit_npa_detector ( pos , vi_norm , det ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'NPA_WEIGHTS: Missed detector' endif cycle loop_along_x endif !! Determine the angle between the B-field and the Line of Sight pitch = phit % pitch ipitch = minloc ( abs ( ptcharr - pitch )) loop_over_energy : do ic = 1 , inputs % ne_wght !! energy loop vabs = sqrt ( ebarr ( ic ) / ( v2_to_E_per_amu * inputs % ab )) vi = vi_norm * vabs !!Correct for gyro orbit call gyro_step ( vi , fields , r_gyro ) fbm_denf = 0 if ( inputs % dist_type . eq . 1 ) then !get dist at guiding center call get_ep_denf ( ebarr ( ic ), pitch , fbm_denf , pos = ( pos + r_gyro )) endif if ( fbm_denf . ne . fbm_denf ) cycle loop_over_energy !! -------------- calculate CX probability -------!! call get_beam_cx_prob ([ ii , jj , kk ], pos , vi , neut_types , pcx ) if ( sum ( pcx ). le . 0 ) cycle loop_over_energy !!Calculate attenuation states = pcx * 1.0d14 !!needs to be large aribitrary number so colrad works states_i = states call attenuate ( pos , dpos , vi , states ) pcxa = sum ( states ) / sum ( states_i ) !$OMP CRITICAL(npa_wght) nweight % attenuation ( ic , ii , jj , kk , ichan ) = pcxa nweight % cx ( ic , ii , jj , kk , ichan ) = sum ( pcx ) nweight % weight ( ic , ipitch ( 1 ), ichan ) = nweight % weight ( ic , ipitch ( 1 ), ichan ) + & 2 * sum ( pcx ) * pcxa * phit % p * beam_grid % dv / dP nweight % flux ( ic , ichan ) = nweight % flux ( ic , ichan ) + & 2 * beam_grid % dv * fbm_denf * sum ( pcx ) * pcxa * phit % p !Factor of 2 above is to convert fbm to ions/(cm&#94;3 dE (domega/4pi)) nweight % emissivity ( ii , jj , kk , ichan ) = nweight % emissivity ( ii , jj , kk , ichan ) + & 2 * fbm_denf * sum ( pcx ) * pcxa * phit % p * dE !$OMP END CRITICAL(npa_wght) enddo loop_over_energy endif ccnt = ccnt + 1 if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) ccnt / real ( beam_grid % ngrid ) * 100 , char ( 13 ) endif enddo loop_along_x enddo loop_along_y enddo loop_along_z !$OMP END PARALLEL DO if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,A,ES14.5)' ), 'Flux:   ' , sum ( nweight % flux (:, ichan )) * dE write ( * , '(T4,A,ES14.5)' ), 'Weight: ' , sum ( nweight % weight (:,:, ichan )) * dE * dP write ( * , * ) '' endif enddo loop_over_channels call write_npa_weights () end subroutine npa_weights end module libfida !============================================================================= !-------------------------------Main Program---------------------------------- !============================================================================= program fidasim !+ FIDASIM {!../VERSION!} use libfida use hdf5_extra #ifdef _OMP use omp_lib #endif implicit none character ( 3 ) :: arg = '' integer , dimension ( 8 ) :: time_arr , time_start , time_end !Time array integer :: i , narg , nthreads , max_threads integer :: hour , minu , sec #ifdef _VERSION version = _ VERSION #endif call print_banner () narg = command_argument_count () if ( narg . eq . 0 ) then write ( * , '(a)' ) \"usage: ./fidasim namelist_file [num_threads]\" stop else call get_command_argument ( 1 , namelist_file ) endif !! Check if compression is possible call check_compression_availability () !! measure time call date_and_time ( values = time_start ) call read_inputs () #ifdef _OMP max_threads = OMP_get_num_procs () if ( narg . ge . 2 ) then call get_command_argument ( 2 , arg ) read ( arg , '(i3)' ) nthreads else nthreads = max_threads endif max_threads = min ( nthreads , max_threads ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- OpenMP settings ----\" write ( * , '(T2,\"Number of threads: \",i2)' ) max_threads write ( * , * ) '' endif call OMP_set_num_threads ( max_threads ) #else max_threads = 1 #endif !! ---------------------------------------------------------- !! ------ INITIALIZE THE RANDOM NUMBER GENERATOR  ----------- !! ---------------------------------------------------------- allocate ( rng ( max_threads )) do i = 1 , max_threads call rng_init ( rng ( i ), 932117 + i ) enddo !! ---------------------------------------------------------- !! ------- READ GRIDS, PROFILES, LOS, TABLES, & FBM -------- !! ---------------------------------------------------------- call make_beam_grid () call read_equilibrium () call read_beam () call read_tables () call read_distribution () allocate ( spec_chords % inter ( beam_grid % nx , beam_grid % ny , beam_grid % nz )) if (( inputs % calc_spec . ge . 1 ). or .( inputs % calc_fida_wght . ge . 1 )) then call read_chords () endif if (( inputs % calc_npa . ge . 1 ). or .( inputs % calc_npa_wght . ge . 1 )) then call read_npa () endif !! ---------------------------------------------------------- !! --------------- ALLOCATE THE RESULT ARRAYS --------------- !! ---------------------------------------------------------- !! neutral density array! allocate ( neut % dens ( nlevs , ntypes , beam_grid % nx , beam_grid % ny , beam_grid % nz )) neut % dens = 0.d0 !! birth profile if ( inputs % calc_birth . ge . 1 ) then allocate ( birth % dens ( 3 , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz )) allocate ( birth % neut_type ( int ( inputs % n_birth * inputs % n_nbi ))) allocate ( birth % ind ( 3 , int ( inputs % n_birth * inputs % n_nbi ))) allocate ( birth % ri ( 3 , int ( inputs % n_birth * inputs % n_nbi ))) allocate ( birth % vi ( 3 , int ( inputs % n_birth * inputs % n_nbi ))) birth % neut_type = 0 birth % dens = 0.d0 birth % ind = 0 birth % ri = 0.d0 birth % vi = 0.d0 endif if ( inputs % calc_spec . ge . 1 ) then allocate ( spec % brems ( inputs % nlambda , spec_chords % nchan )) allocate ( spec % bes ( inputs % nlambda , spec_chords % nchan , 4 )) allocate ( spec % fida ( inputs % nlambda , spec_chords % nchan , particles % nclass )) spec % brems = 0.d0 spec % bes = 0.d0 spec % fida = 0.d0 endif if ( inputs % calc_npa . ge . 1 ) then npa % nchan = npa_chords % nchan allocate ( npa % part ( npa % nmax )) if ( inputs % dist_type . eq . 1 ) then npa % nenergy = fbm % nenergy allocate ( npa % energy ( npa % nenergy )) npa % energy = fbm % energy else allocate ( npa % energy ( npa % nenergy )) do i = 1 , npa % nenergy npa % energy ( i ) = real ( i - 0.5 ) enddo endif allocate ( npa % flux ( npa % nenergy , npa % nchan , particles % nclass )) npa % flux = 0.0 endif if ( inputs % calc_neutron . ge . 1 ) then allocate ( neutron % rate ( particles % nclass )) neutron % rate = 0.d0 endif !! ----------------------------------------------------------------------- !! --------------- CALCULATE/LOAD the BEAM and HALO DENSITY--------------- !! ----------------------------------------------------------------------- if ( inputs % load_neutrals . eq . 1 ) then call read_neutrals () else !! ----------- BEAM NEUTRALS ---------- !! call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'ndmc:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call ndmc if ( inputs % calc_birth . eq . 1 ) then call write_birth_profile () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' !! ---------- DCX (Direct charge exchange) ---------- !! call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'dcx:     ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call dcx () if ( inputs % dump_dcx . eq . 1 ) call write_dcx () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' !! ---------- HALO ---------- !! call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'halo:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call halo () !! ---------- WRITE NEUTRALS ---------- !! call write_neutrals () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ----------------------------------------------------------------------- !!----------------------------- BREMSSTRAHLUNG --------------------------- !! ----------------------------------------------------------------------- if ( inputs % calc_brems . ge . 1 ) then call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'bremsstrahlung:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call bremsstrahlung () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ----------------------------------------------------------------------- !! --------------------- CALCULATE the FIDA RADIATION -------------------- !! ----------------------------------------------------------------------- if ( inputs % calc_fida . ge . 1 ) then call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'fida:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif if ( inputs % dist_type . eq . 1 ) then call fida_f () else call fida_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_spec . ge . 1 ) then call write_spectra () write ( * , '(30X,a)' ) '' endif !! ----------------------------------------------------------------------- !! ----------------------- CALCULATE the NPA FLUX ------------------------ !! ----------------------------------------------------------------------- if ( inputs % calc_npa . ge . 1 ) then call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'npa:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif if ( inputs % dist_type . eq . 1 ) then call npa_f () else call npa_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_npa . ge . 1 ) then call write_npa () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ------------------------------------------------------------------- !! ------------------- Calculation of neutron flux ------------------- !! ------------------------------------------------------------------- if ( inputs % calc_neutron . ge . 1 ) then call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'neutron rate:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif if ( inputs % dist_type . eq . 1 ) then call neutron_f () else call neutron_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ------------------------------------------------------------------- !! ----------- Calculation of weight functions ----------------------- !! ------------------------------------------------------------------- if ( inputs % calc_fida_wght . ge . 1 ) then colrad_threshold = 0. !! to speed up simulation! call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'fida weight function:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif if ( inputs % calc_fida_wght . eq . 1 ) then call fida_weights_los () else call fida_weights_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_npa_wght . ge . 1 ) then call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'npa weight function:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call npa_weights () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'END: hour, minute, second: ' ,& time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call date_and_time ( values = time_end ) hour = time_end ( 5 ) - time_start ( 5 ) minu = time_end ( 6 ) - time_start ( 6 ) sec = time_end ( 7 ) - time_start ( 7 ) if ( minu . lt . 0. ) then minu = minu + 60 hour = hour - 1 endif if ( sec . lt . 0. ) then sec = sec + 60 minu = minu - 1 endif if ( inputs % verbose . ge . 1 ) then write ( * , '(A,18X,I2,\":\",I2.2,\":\",I2.2)' ) 'duration:' , hour , minu , sec endif end program fidasim","tags":"","loc":"sourcefile/fidasim.f90.html","title":"fidasim.f90 – FIDASIM"},{"text":"This file contains HDF5 helper routines for writing compressed data files Files Dependent On This One sourcefile~~hdf5_extra.f90~~AfferentGraph sourcefile~hdf5_extra.f90 hdf5_extra.f90 sourcefile~fidasim.f90 fidasim.f90 sourcefile~hdf5_extra.f90->sourcefile~fidasim.f90 sourcefile~atomic_tables.f90 atomic_tables.f90 sourcefile~hdf5_extra.f90->sourcefile~atomic_tables.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules hdf5_extra Source Code hdf5_extra.f90 Source Code !+This file contains HDF5 helper routines for writing compressed data files MODULE hdf5_extra !+ A library for writing compressed HDF5 files USE H5LT USE HDF5 IMPLICIT NONE public :: h5ltmake_compressed_dataset_double_f public :: h5ltmake_compressed_dataset_double_f_1 public :: h5ltmake_compressed_dataset_double_f_2 public :: h5ltmake_compressed_dataset_double_f_3 public :: h5ltmake_compressed_dataset_double_f_4 public :: h5ltmake_compressed_dataset_double_f_5 public :: h5ltmake_compressed_dataset_double_f_6 public :: h5ltmake_compressed_dataset_double_f_7 public :: h5ltmake_compressed_dataset_int_f public :: h5ltmake_compressed_dataset_int_f_1 public :: h5ltmake_compressed_dataset_int_f_2 public :: h5ltmake_compressed_dataset_int_f_3 public :: h5ltmake_compressed_dataset_int_f_4 public :: h5ltmake_compressed_dataset_int_f_5 public :: h5ltmake_compressed_dataset_int_f_6 public :: h5ltmake_compressed_dataset_int_f_7 public :: h5ltread_dataset_int_scalar_f public :: h5ltread_dataset_double_scalar_f public :: check_compression_availability integer , parameter , private :: long = 4 !bytes = 32 bits (-2,147,483,648 to 2,147,483,647) integer , parameter , private :: long64 = 8 !bytes = 64 bits (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807) integer , parameter , private :: float = 4 !bytes = 32 bits (1.2E-38 to 3.4E+38) at 6 decimal places integer , parameter , private :: double = 8 !bytes = 64 bits (2.3E-308 to 1.7E+308) at 15 decimal places logical , private :: compress_data = . True . interface h5ltmake_compressed_dataset_double_f !+ Write a compressed datasets of 64-bit floats module procedure h5ltmake_compressed_dataset_double_f_1 module procedure h5ltmake_compressed_dataset_double_f_2 module procedure h5ltmake_compressed_dataset_double_f_3 module procedure h5ltmake_compressed_dataset_double_f_4 module procedure h5ltmake_compressed_dataset_double_f_5 module procedure h5ltmake_compressed_dataset_double_f_6 module procedure h5ltmake_compressed_dataset_double_f_7 end interface interface h5ltmake_compressed_dataset_int_f !+ Write a compressed dataset of 32-bit integers module procedure h5ltmake_compressed_dataset_int_f_1 module procedure h5ltmake_compressed_dataset_int_f_2 module procedure h5ltmake_compressed_dataset_int_f_3 module procedure h5ltmake_compressed_dataset_int_f_4 module procedure h5ltmake_compressed_dataset_int_f_5 module procedure h5ltmake_compressed_dataset_int_f_6 module procedure h5ltmake_compressed_dataset_int_f_7 end interface contains subroutine check_compression_availability !+ Checks whether dataset compression is available IMPLICIT NONE logical :: shuffle_avail , gzip_avail integer :: gzip_info , shuf_info , filter_info_both integer :: error call h5open_f ( error ) filter_info_both = ior ( H5Z_FILTER_ENCODE_ENABLED_F , H5Z_FILTER_DECODE_ENABLED_F ) !! Check for GZIP filter call h5zfilter_avail_f ( H5Z_FILTER_DEFLATE_F , gzip_avail , error ) call h5zget_filter_info_f ( H5Z_FILTER_DEFLATE_F , gzip_info , error ) if (. not . gzip_avail ) then print * , 'HDF5: gzip filter is not available' compress_data = . False . endif if ( filter_info_both . ne . gzip_info ) then print * , 'HDF5: gzip filter is not available for encoding and decoding' compress_data = . False . endif !! Check for SHUFFLE filter call h5zfilter_avail_f ( H5Z_FILTER_SHUFFLE_F , shuffle_avail , error ) call h5zget_filter_info_f ( H5Z_FILTER_SHUFFLE_F , shuf_info , error ) if (. not . shuffle_avail ) then print * , 'HDF5: shuffle filter is not available' compress_data = . False . endif if ( filter_info_both . ne . shuf_info ) then print * , 'HDF5: shuffle filter is not available for encoding and decoding' compress_data = . False . endif if (. not . compress_data ) then print * , 'HDF5: Compression is not available. Proceeding without compression.' endif call h5close_f ( error ) end subroutine check_compression_availability subroutine h5ltread_dataset_int_scalar_f ( loc_id , dset_name , x , error ) !+ Write a scalar 32-bit integer IMPLICIT NONE integer ( HID_T ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( inout ) :: x !+ Data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HSIZE_T ), dimension ( 1 ) :: dims ( 1 ) = 1 integer , dimension ( 1 ) :: dummy call h5ltread_dataset_int_f ( loc_id , dset_name , dummy , dims , error ) x = dummy ( 1 ) end subroutine h5ltread_dataset_int_scalar_f subroutine h5ltread_dataset_double_scalar_f ( loc_id , dset_name , x , error ) !+ Write a scalar 64-bit float IMPLICIT NONE integer ( HID_T ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create real ( double ), intent ( inout ) :: x !+ Data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HSIZE_T ), dimension ( 1 ) :: dims ( 1 ) = 1 real ( double ), dimension ( 1 ) :: dummy call h5ltread_dataset_double_f ( loc_id , dset_name , dummy , dims , error ) x = dummy ( 1 ) end subroutine h5ltread_dataset_double_scalar_f !Compressed Doubles subroutine h5ltmake_compressed_dataset_double_f_1 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 1 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), dimension ( dims ( 1 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_1 subroutine h5ltmake_compressed_dataset_double_f_2 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 2 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), dimension ( dims ( 1 ), dims ( 2 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_2 subroutine h5ltmake_compressed_dataset_double_f_3 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 3 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_3 subroutine h5ltmake_compressed_dataset_double_f_4 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 4 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_4 subroutine h5ltmake_compressed_dataset_double_f_5 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 5 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_5 subroutine h5ltmake_compressed_dataset_double_f_6 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 6 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_6 subroutine h5ltmake_compressed_dataset_double_f_7 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 7 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 ), dims ( 7 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_7 !Compressed Integers subroutine h5ltmake_compressed_dataset_int_f_1 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 1 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_1 subroutine h5ltmake_compressed_dataset_int_f_2 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 2 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_2 subroutine h5ltmake_compressed_dataset_int_f_3 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 3 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_3 subroutine h5ltmake_compressed_dataset_int_f_4 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 4 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_4 subroutine h5ltmake_compressed_dataset_int_f_5 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 5 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_5 subroutine h5ltmake_compressed_dataset_int_f_6 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 6 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_6 subroutine h5ltmake_compressed_dataset_int_f_7 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 7 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 ), dims ( 7 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_7 END MODULE hdf5_extra","tags":"","loc":"sourcefile/hdf5_extra.f90.html","title":"hdf5_extra.f90 – FIDASIM"},{"text":"This file contains routines for parallel random number generation and a basic\nsparse array implementation Files Dependent On This One sourcefile~~utilities.f90~~AfferentGraph sourcefile~utilities.f90 utilities.f90 sourcefile~fidasim.f90 fidasim.f90 sourcefile~utilities.f90->sourcefile~fidasim.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules utilities Source Code utilities.f90 Source Code !+This file contains routines for parallel random number generation and a basic !+sparse array implementation module utilities !+ Utilities for parallel random number generation and sparse arrays #ifdef _OMP use omp_lib #endif implicit none private public :: ind2sub , sub2ind public :: rng_type , rng_init , rng , rng_uniform , rng_normal , randu , randn , randind public :: SparseArray , get_value , sparse public :: deriv integer , parameter :: Int32 = 4 integer , parameter :: Int64 = kind ( int8 ( 1 )) integer , parameter :: Float32 = kind ( 1.e0 ) integer , parameter :: Float64 = kind ( 1.d0 ) integer ( Int32 ), parameter :: IA = 16807 integer ( Int32 ), parameter :: IM = 2147483647 integer ( Int32 ), parameter :: IQ = 127773 integer ( Int32 ), parameter :: IR = 2836 real ( Float64 ), protected :: AM = nearest ( 1.0 , - 1.0 ) / IM integer , parameter :: ns = 2 type :: rng_type !+ Random Number Generator Derived Type integer ( Int32 ), dimension ( ns ) :: state end type rng_type type ( rng_type ), dimension (:), allocatable :: rng type SparseArray integer :: nnz = 0 !+ Number of non-zero elements integer :: nd = 0 !+ Number of dimensions integer , dimension (:), allocatable :: dims !+ Dimensions of array integer , dimension (:), allocatable :: inds !+ Linear index of non-zero elements real ( Float64 ), dimension (:), allocatable :: vals !+ Array values end type SparseArray interface randind !+ Procedure for generating a random array index/subscripts module procedure randind_n module procedure randind_w_1 module procedure randind_w_2 end interface interface search_sorted_first !+ Function for searching a sorted array module procedure search_sorted_first_integer module procedure search_sorted_first_float64 end interface interface sparse !+ Creates a sparse array from a dense array module procedure sparse_1 module procedure sparse_2 module procedure sparse_3 module procedure sparse_4 end interface interface deriv !+ Procedure for finding derivatives from an array module procedure deriv_1d module procedure deriv_2d end interface contains !============================================================================ !---------------------------Array Indexing Routines-------------------------- !============================================================================ subroutine ind2sub ( dims , ind , subs ) !+ Calculate the subscripts `subs` into an array with dimensions `dims` !+ given the corresponding linear index `ind` integer , dimension (:), intent ( in ) :: dims !+ Dimensions of array integer , intent ( in ) :: ind !+ Linear index integer , dimension (:), intent ( out ) :: subs !+ Subscripts corresponding to the linear index integer :: i , ndims , ind1 , ind2 ind1 = ind ndims = size ( dims ) do i = 1 , ndims - 1 ind2 = ( ind1 - 1 ) / dims ( i ) + 1 subs ( i ) = ind1 - dims ( i ) * ( ind2 - 1 ) ind1 = ind2 enddo subs ( ndims ) = ind1 end subroutine ind2sub function sub2ind ( dims , subs ) result ( ind ) !+ Calculates the linear index of an array with dimensions `dims` and !+ subcripts `subs` integer , dimension (:), intent ( in ) :: dims !+ Dimension of Array integer , dimension (:), intent ( in ) :: subs !+ Subscripts to convert integer :: ind !+ Linear index integer :: k , l , p ind = subs ( 1 ) do k = 2 , size ( dims ) p = dims ( 1 ) do l = 2 , k - 1 p = p * dims ( l ) enddo ind = ind + p * ( subs ( k ) - 1 ) enddo end function sub2ind !============================================================================ !-------------------------------Search Routines------------------------------ !============================================================================ function search_sorted_first_integer ( x , v ) result ( hi ) !+ Returns the index of the first value in `x` greater or equal to `v`. !+ Returns `length(x)+1` if `v` is greater then all values in `x`. integer , dimension (:), intent ( in ) :: x !+ Monotonically increasing array integer , intent ( in ) :: v !+ Value to search integer :: hi , lo , m lo = 0 hi = size ( x ) + 1 do while ( lo . lt .( hi - 1 )) m = rshift ( lo + hi , 1 ) if ( x ( m ). lt . v ) then lo = m else hi = m endif enddo end function search_sorted_first_integer function search_sorted_first_float64 ( x , v ) result ( hi ) !+ Returns the index of the first value in `x` greater or equal to `v`. !+ Returns `length(x)+1` if `v` is greater then all values in `x`. real ( Float64 ), dimension (:), intent ( in ) :: x !+ Monotonically increasing array real ( Float64 ), intent ( in ) :: v !+ Value to search integer :: hi , lo , m lo = 0 hi = size ( x ) + 1 do while ( lo . lt .( hi - 1 )) m = rshift ( lo + hi , 1 ) if ( x ( m ). lt . v ) then lo = m else hi = m endif enddo end function search_sorted_first_float64 !============================================================================ !-----------------------Parallel Random Number Routines---------------------- !============================================================================ subroutine rng_init ( self , seed ) !+ Procedure to initialize a random number generator with a seed type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator integer ( Int32 ), intent ( in ) :: seed !+ Initial Seed Value self % state ( 1 ) = ieor ( 777755555 , abs ( seed )) self % state ( 2 ) = ior ( ieor ( 888889999 , abs ( seed )), 1 ) end subroutine rng_init function rng_uniform ( self ) result ( u ) !+ Generate a uniformally-distributed random number in the range [0,1) type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator real ( Float64 ) :: u !+ Uniform random deviate integer ( Int32 ) :: ix , iy , k ix = self % state ( 1 ) iy = self % state ( 2 ) ix = ieor ( ix , ishft ( ix , 13 )) ix = ieor ( ix , ishft ( ix , - 17 )) ix = ieor ( ix , ishft ( ix , 5 )) k = iy / IQ iy = IA * ( iy - k * IQ ) - IR * k if ( iy . lt . 0 ) iy = iy + IM self % state ( 1 ) = ix self % state ( 2 ) = iy u = am * ior ( iand ( IM , ieor ( ix , iy )), 1 ) end function rng_uniform function rng_normal ( self ) result ( n ) !+ Generate a normally-distributed random number with mean 0 and standard deviation 1 type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator real ( Float64 ) :: n !+ Normal random deviate real ( Float64 ), parameter :: s = 0.449871d0 real ( Float64 ), parameter :: t = 0.386595d0 real ( Float64 ), parameter :: a = 0.196000d0 real ( Float64 ), parameter :: b = 0.254720d0 real ( Float64 ), parameter :: r1 = 0.27597d0 real ( Float64 ), parameter :: r2 = 0.27846d0 real ( Float64 ) :: u , v , x , y , q do u = rng_uniform ( self ) v = rng_uniform ( self ) v = 1.7156d0 * ( v - 0.5d0 ) x = u - s y = abs ( v ) + t q = x ** 2 + y * ( a * y - b * x ) if ( q . lt . r1 ) exit if ( q . gt . r2 ) cycle if (( v ** 2 ). lt .( - 4.0 * log ( u ) * u ** 2 )) exit enddo n = v / u end function rng_normal subroutine randu ( randomu ) !+ Generate an array of uniformally-distributed random deviates real ( Float64 ), dimension (:), intent ( out ) :: randomu !+ Array of uniform random deviates integer :: i , thread_id #ifdef _OMP thread_id = OMP_get_thread_num () + 1 #else thread_id = 1 #endif randomu = 0.d0 do i = 1 , size ( randomu ) randomu ( i ) = rng_uniform ( rng ( thread_id )) enddo end subroutine randu subroutine randn ( randomn ) !+ Generate an array of normally-distributed random deviates real ( Float64 ), dimension (:), intent ( out ) :: randomn !+ Array of normal random deviates integer :: i , thread_id #ifdef _OMP thread_id = OMP_get_thread_num () + 1 #else thread_id = 1 #endif randomn = 0.d0 do i = 1 , size ( randomn ) randomn ( i ) = rng_normal ( rng ( thread_id )) enddo end subroutine randn subroutine randind_n ( n , randomi ) !+ Generate a array of uniformally-distributed random integers in the range [1, n] integer , intent ( in ) :: n !+ Largest possible value integer , dimension (:), intent ( out ) :: randomi !+ Array of uniform deviates integer :: i real ( Float64 ), dimension ( 1 ) :: randomu randomi = 0 do i = 1 , size ( randomi ) call randu ( randomu ) randomi ( i ) = ceiling ( randomu ( 1 ) * n ) enddo end subroutine randind_n subroutine randind_w_1 ( w , randomi ) !+ Generate an array of random indices of an 1D array distributed according to `w` real ( Float64 ), dimension (:), intent ( in ) :: w !+ 1D array of index weights integer , dimension (:), intent ( out ) :: randomi !+ Random indices integer :: i , nw real ( Float64 ) :: cdf_val , t real ( Float64 ), dimension ( size ( w )) :: cdf real ( Float64 ), dimension ( 1 ) :: randomu nw = size ( w ) t = 0.d0 do i = 1 , nw cdf ( i ) = t + w ( i ) t = cdf ( i ) enddo randomi = 0 do i = 1 , size ( randomi ) call randu ( randomu ) cdf_val = randomu ( 1 ) * cdf ( nw ) randomi ( i ) = min ( search_sorted_first ( cdf , cdf_val ), nw ) enddo end subroutine randind_w_1 subroutine randind_w_2 ( w , randomi ) !+ Generate an array of random subscripts of an 2D array distributed according to `w` real ( Float64 ), dimension (:,:), intent ( in ) :: w !+ 2D array of subscript weights integer , dimension (:,:), intent ( out ) :: randomi !+ A 2D (ndim, :) array of random subscripts integer :: i , nw integer , dimension ( 2 ) :: subs integer , dimension ( size ( randomi , 2 )) :: randi randomi = 0 nw = size ( w ) call randind_w_1 ( reshape ( w ,[ nw ]), randi ) do i = 1 , size ( randomi , 2 ) call ind2sub ( shape ( w ), randi ( i ), subs ) randomi (:, i ) = subs enddo end subroutine randind_w_2 !============================================================================ !------------------------------Sparse Routines------------------------------- !============================================================================ subroutine sparse_1 ( A , SA ) !+ Routine to create a 1D sparse array from a 1D dense array real ( Float64 ), dimension (:), intent ( in ) :: A !+ Dense Array type ( SparseArray ), intent ( out ) :: SA !+ Sparse Array integer :: n , i , c SA % nd = 1 allocate ( SA % dims ( SA % nd )) SA % dims = shape ( A ) SA % nnz = count ( A . ne . 0.d0 ) if ( SA % nnz . eq . 0 ) return allocate ( SA % vals ( SA % nnz ), SA % inds ( SA % nnz )) n = size ( A ) c = 1 do i = 1 , n if ( A ( i ). ne . 0.d0 ) then SA % inds ( c ) = i SA % vals ( c ) = A ( i ) c = c + 1 endif if ( c . gt . SA % nnz ) exit enddo end subroutine sparse_1 subroutine sparse_2 ( A , SA ) !+ Routine to create a 2D sparse array from a 2D dense array real ( Float64 ), dimension (:,:), intent ( in ) :: A !+ Dense Array type ( SparseArray ), intent ( out ) :: SA !+ Sparse Array integer :: subs ( 2 ) integer :: n , i , c SA % nd = 2 allocate ( SA % dims ( SA % nd )) SA % dims = shape ( A ) SA % nnz = count ( A . ne . 0.d0 ) if ( SA % nnz . eq . 0 ) return allocate ( SA % vals ( SA % nnz ), SA % inds ( SA % nnz )) n = size ( A ) c = 1 do i = 1 , n call ind2sub ( SA % dims , i , subs ) if ( A ( subs ( 1 ), subs ( 2 )). ne . 0.d0 ) then SA % inds ( c ) = i SA % vals ( c ) = A ( subs ( 1 ), subs ( 2 )) c = c + 1 endif if ( c . gt . SA % nnz ) exit enddo end subroutine sparse_2 subroutine sparse_3 ( A , SA ) !+ Routine to create a 3D sparse array from a 3D dense array real ( Float64 ), dimension (:,:,:), intent ( in ) :: A !+ Dense Array type ( SparseArray ), intent ( out ) :: SA !+ Sparse Array integer :: subs ( 3 ) integer :: n , i , c SA % nd = 3 allocate ( SA % dims ( SA % nd )) SA % dims = shape ( A ) SA % nnz = count ( A . ne . 0.d0 ) if ( SA % nnz . eq . 0 ) return allocate ( SA % vals ( SA % nnz ), SA % inds ( SA % nnz )) n = size ( A ) c = 1 do i = 1 , n call ind2sub ( SA % dims , i , subs ) if ( A ( subs ( 1 ), subs ( 2 ), subs ( 3 )). ne . 0.d0 ) then SA % inds ( c ) = i SA % vals ( c ) = A ( subs ( 1 ), subs ( 2 ), subs ( 3 )) c = c + 1 endif if ( c . gt . SA % nnz ) exit enddo end subroutine sparse_3 subroutine sparse_4 ( A , SA ) !+ Routine to create a 4D sparse array from a 4D dense array real ( Float64 ), dimension (:,:,:,:), intent ( in ) :: A !+ Dense Array type ( SparseArray ), intent ( out ) :: SA !+ Sparse Array integer :: subs ( 4 ) integer :: n , i , c SA % nd = 4 allocate ( SA % dims ( SA % nd )) SA % dims = shape ( A ) SA % nnz = count ( A . ne . 0.d0 ) if ( SA % nnz . eq . 0 ) return allocate ( SA % vals ( SA % nnz ), SA % inds ( SA % nnz )) n = size ( A ) c = 1 do i = 1 , n call ind2sub ( SA % dims , i , subs ) if ( A ( subs ( 1 ), subs ( 2 ), subs ( 3 ), subs ( 4 )). ne . 0.d0 ) then SA % inds ( c ) = i SA % vals ( c ) = A ( subs ( 1 ), subs ( 2 ), subs ( 3 ), subs ( 4 )) c = c + 1 endif if ( c . gt . SA % nnz ) exit enddo end subroutine sparse_4 function get_value ( SA , subs ) result ( val ) !+ Gets value of sparse array `SA` at the subscripts `subs` type ( SparseArray ), intent ( in ) :: SA !+ Sparse Array integer , dimension (:), intent ( in ) :: subs !+ Subscripts of Sparse Array real ( Float64 ) :: val !+ Value of `SA` at `subs` integer :: ind , cind val = 0.d0 if ( SA % nnz . eq . 0 ) return ind = sub2ind ( SA % dims , subs ) cind = search_sorted_first ( SA % inds , ind ) if ( ind . eq . SA % inds ( cind )) then val = SA % vals ( cind ) endif end function get_value !============================================================================ !--------------------------------Deriv Routines------------------------------ !============================================================================ subroutine deriv_1d ( x , y , yp ) !+ Uses 3 point lagrangian method to calculate the derivative of an array real ( Float64 ), dimension (:), intent ( in ) :: x !+ X Values real ( Float64 ), dimension (:), intent ( in ) :: y !+ Y Values real ( Float64 ), dimension (:), intent ( out ) :: yp !+ Derivative of Y w.r.t. X integer :: i , n !! temporary values for loops real ( Float64 ) :: p1 , p2 , p3 !! intermeadiate values for 3 point lagrangian n = size ( x ) - 1 do i = 2 , n p1 = x ( i - 1 ) p2 = x ( i ) p3 = x ( i + 1 ) yp ( i ) = ( y ( i - 1 ) * ( p2 - p3 ) / (( p1 - p2 ) * ( p1 - p3 ))) + & ( y ( i ) * (( 1 / ( p2 - p3 )) - ( 1 / ( p1 - p2 )))) - & ( y ( i + 1 ) * ( p1 - p2 ) / (( p1 - p3 ) * ( p2 - p3 ))) enddo yp ( 1 ) = ( y ( 1 ) * (( x ( 1 ) - x ( 2 )) + ( x ( 1 ) - x ( 3 ))) / (( x ( 1 ) - x ( 2 )) * ( x ( 1 ) - x ( 3 )))) - & ( y ( 2 ) * ( x ( 1 ) - x ( 3 )) / (( x ( 1 ) - x ( 2 )) * ( x ( 2 ) - x ( 3 )))) + & ( y ( 3 ) * ( x ( 1 ) - x ( 2 )) / (( x ( 1 ) - x ( 3 )) * ( x ( 2 ) - x ( 3 )))) yp ( n + 1 ) = - ( y ( n - 1 ) * ( x ( n ) - x ( n + 1 )) / (( x ( n - 1 ) - x ( n )) * ( x ( n - 1 ) - x ( n + 1 )))) + & ( y ( n ) * ( x ( n - 1 ) - x ( n + 1 )) / (( x ( n - 1 ) - x ( n )) * ( x ( n ) - x ( n + 1 )))) - & ( y ( n + 1 ) * (( x ( n - 1 ) - x ( n + 1 )) + ( x ( n ) - x ( n + 1 ))) / (( x ( n - 1 ) - x ( n + 1 )) * & ( x ( n ) - x ( n + 1 )))) end subroutine deriv_1d subroutine deriv_2d ( x , y , z , zxp , zyp ) !+ Uses 3 point lagrangian method to calculate the partial derivative !+ of an array Z w.r.t X and Y real ( Float64 ), dimension (:), intent ( in ) :: x !+ X Values real ( Float64 ), dimension (:), intent ( in ) :: y !+ Y Values real ( Float64 ), dimension (:,:), intent ( in ) :: z !+ Z Values real ( Float64 ), dimension (:,:), intent ( out ) :: zxp !+ Derivative of Z w.r.t. X real ( Float64 ), dimension (:,:), intent ( out ) :: zyp !+ Derivative of Z w.r.t. Y integer :: i , n !! temporary values for loops n = size ( y ) do i = 1 , n call deriv_1d ( x , z (:, i ), zxp (:, i )) enddo n = size ( x ) do i = 1 , n call deriv_1d ( y , z ( i ,:), zyp ( i ,:)) enddo end subroutine deriv_2d end module utilities","tags":"","loc":"sourcefile/utilities.f90.html","title":"utilities.f90 – FIDASIM"},{"text":"This file contains the routines for calculating atomic cross sections and reaction rates for FIDASIM This File Depends On sourcefile~~atomic_tables.f90~~EfferentGraph sourcefile~atomic_tables.f90 atomic_tables.f90 sourcefile~hdf5_extra.f90 hdf5_extra.f90 sourcefile~hdf5_extra.f90->sourcefile~atomic_tables.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs generate_tables Modules atomic_tables Source Code atomic_tables.f90 Source Code !+This file contains the routines for calculating atomic cross sections and reaction rates for FIDASIM module atomic_tables !+Library for calculating atomic cross sections and reaction rate coefficients for Hydrogen interactions !+ !+###References !+ !+1. [W.L. Wiese, M.W. Smith, and B.M. Glennon. *Atomic Transition Probabilities. Volume 1. Hydrogen through Neon*. !+National Bureau of Standards Washington DC Institute for Basic Standards, 1966.](http://www.dtic.mil/dtic/tr/fulltext/u2/634145.pdf) !+2. [R.K. Janev, D. Reiter, and  U. Samm. *Collision processes in low-temperature hydrogen plasmas*. !+Forschungszentrum Jülich, Zentralbibliothek, 2003.](http://www.eirene.de/report_4105.pdf) !+3. [M. O'Mullane. *Review of proton impact driven ionisation from the excited levels in neutral hydrogen beams*. !+ADAS note, 2009.](http://www.adas.ac.uk/notes/adas_c09-01.pdf) !+4. [ADAS: Atomic Data and Analysis Structure](http://www.adas.ac.uk/) !+5. [R.K. Janev and J.J. Smith. *Cross sections for collision processes of hydrogen atoms !+with electrons, protons and multiply charged ions.* Atomic and Plasma-Material Interaction Data for Fusion: !+Volume 4, 1993.](http://www-pub.iaea.org/books/IAEABooks/1839/Atomic-and-Plasma-Material-Interaction-Data-for-Fusion) !+6. [Reinhold, C. O., R. E. Olson, and W. Fritsch. *Excitation of atomic hydrogen by fully stripped ions.* !+Physical Review A 41.9 1990.](http://journals.aps.org/pra/abstract/10.1103/PhysRevA.41.4837) !+7. [Bosch, H-S., and G. M. Hale. *Improved formulas for fusion cross-sections and thermal reactivities.* !+ Nuclear fusion 32.4 1992.](http://iopscience.iop.org/article/10.1088/0029-5515/32/4/I07/meta) use H5LT use HDF5 use hdf5_extra IMPLICIT NONE interface bt_maxwellian !+Calculates the reaction rate coefficients given beam energy `eb` and target temperature `T` !+where the velocity distribution of the target is a Maxwellian module procedure bt_maxwellian_eb module procedure bt_maxwellian_n , bt_maxwellian_n_m module procedure bt_maxwellian_q_n , bt_maxwellian_q_n_m end interface integer , parameter , private :: Int32 = 4 !+ Defines a 32 bit integer integer , parameter , private :: Int64 = 8 !+ Defines a 64 bit integer integer , parameter , private :: Float32 = 4 !+ Defines a 32 bit floating point real integer , parameter , private :: Float64 = 8 !+ Defines a 64 bit floating point real real ( Float64 ), parameter :: PI = 3.14159265d0 real ( Float64 ), parameter :: e_amu = 5.485799093287202d-4 !+ Atomic mass of an electron [amu] real ( Float64 ), parameter :: H1_amu = 1.00782504d0 !+ Atomic mass of Hydrogen-1 (protium) [amu] real ( Float64 ), parameter :: H2_amu = 2.0141017778d0 !+ Atomic mass of Hydrogen-2 (deuterium) [amu] real ( Float64 ), parameter :: H3_amu = 3.0160492d0 !+ Atomic mass of Hydrogen-3 (tritium) [amu] real ( Float64 ), parameter :: He3_amu = 3.0160293d0 !+ Atomic mass of Helium-3 [amu] real ( Float64 ), parameter :: B_amu = 1 0.81d0 !+ Atomic mass of Boron [amu] real ( Float64 ), parameter :: C_amu = 1 2.011d0 !+ Atomic mass of Carbon [amu] integer , parameter :: B_q = 5 !+ Proton number of Boron integer , parameter :: C_q = 6 !+ Proton number of Carbon real ( Float64 ), dimension ( 15 , 15 ), parameter :: EINSTEIN = reshape ([ & !(n,m) 0.d0 , 4.699d8 , 5.575d7 , 1.278d7 , 4.125d6 , 1.644d6 , 7.568d5 , 3.869d5 , 2.143d5 , 1.263d5 , 7.834d4 , 5.066d4 , 3.393d4 , 2.341d4 , 1.657d4 ,& !(:,1) 0.d0 , 0.d0 , 4.410d7 , 8.419d6 , 2.530d6 , 9.732d5 , 4.389d5 , 2.215d5 , 1.216d5 , 7.122d4 , 4.397d4 , 2.834d4 , 1.893d4 , 1.303d4 , 9.210d3 ,& !(:,2) 0.d0 , 0.d0 , 0.d0 , 8.986d6 , 2.201d6 , 7.783d5 , 3.358d5 , 1.651d5 , 8.905d4 , 5.156d4 , 3.156d4 , 2.021d4 , 1.343d4 , 9.211d3 , 6.490d3 ,& !(:,3) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 2.699d6 , 7.711d5 , 3.041d5 , 1.424d5 , 7.459d4 , 4.235d4 , 2.556d4 , 1.620d4 , 1.069d4 , 7.288d3 , 5.110d3 ,& !(:,4) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 1.025d6 , 3.253d5 , 1.388d5 , 6.908d4 , 3.800d4 , 2.246d4 , 1.402d4 , 9.148d3 , 6.185d3 , 4.308d3 ,& !(:,5) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 4.561d5 , 1.561d5 , 7.065d4 , 3.688d4 , 2.110d4 , 1.288d4 , 8.271d3 , 5.526d3 , 3.815d3 ,& !(:,6) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 2.272d5 , 8.237d4 , 3.905d4 , 2.117d4 , 1.250d4 , 7.845d3 , 5.156d3 , 3.516d3 ,& !(:,7) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 1.233d5 , 4.676d4 , 2.301d4 , 1.287d4 , 7.804d3 , 5.010d3 , 3.359d3 ,& !(:,8) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 7.141d4 , 2.812d4 , 1.427d4 , 8.192d3 , 5.080d3 , 3.325d3 ,& !(:,9) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 4.377d4 , 1.774d4 , 9.231d3 , 5.417d3 , 3.324d3 ,& !(:,10) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 2.799d4 , 1.163d4 , 6.186d3 , 3.699d3 ,& !(:,11) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 1.857d4 , 7.884d3 , 4.271d3 ,& !(:,12) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 1.271d4 , 5.496d3 ,& !(:,13) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 8.933d3 ,& !(:,14) 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 , 0.d0 ]& !(:,15) , [ 15 , 15 ]) !+ Einstein coefficients for spontaneous emission from state initial state `n` to final state `m` !+ !+References: !+ !+* H - Table A in Ref. 1 [[atomic_tables(module)]] contains function p_cx_1_janev ( Erel ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=1 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 3.2345d0 , 2.3588d2 , 2.3713d0 , & 3.8371d-2 , 3.8068d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ), parameter :: n = 1.d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_1_janev function p_cx_2_janev ( Erel ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 9.2750d-1 , 6.5040d3 , 2.0699d1 , & 1.3405d-2 , 3.0842d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ), parameter :: n = 2.d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_2_janev function p_cx_3_janev ( Erel ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 3.7271d-1 , 2.7645d6 , 1.4857d3 , & 1.5720d-3 , 3.0842d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ), parameter :: n = 3.d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_3_janev function p_cx_n_janev ( Erel , n ) result ( sigma ) !+Calculates cross section for proton-Hydrogen charge exchange interactions from the n \\geq 4 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n \\geq 4) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 2.1336d-1 , 1.0000d10 , 1.3426d6 , & 1.8184d-3 , 3.0842d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ) :: Ehat if ( n . lt . 4 ) then write ( * , '(a)' ) \"P_CX_N_JANEV: n cannot be less than 4\" stop endif Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_n_janev function p_cx_janev ( Erel , n ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the `n` state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer :: i i = min ( n , 4 ) select case ( i ) case ( 0 ) stop case ( 1 ) sigma = p_cx_1_janev ( Erel ) case ( 2 ) sigma = p_cx_2_janev ( Erel ) case ( 3 ) sigma = p_cx_3_janev ( Erel ) case DEFAULT sigma = p_cx_n_janev ( Erel , n ) end select end function p_cx_janev function p_cx_1_1_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=1 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(1) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 7 ), parameter :: a = [ - 3.496092687d2 , 4.724931484d2 , & - 2.720493064d2 , 8.158564625d1 , & - 1.339790721d1 , 1.138706949d0 , & - 3.914774156d-2 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 1.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 1.0d3 fac = Erel ** ( - 0.2 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_1_1_adas function p_cx_1_2_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(2) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 9 ), parameter :: a = [ - 4.036239511d3 , 6.941235312d3 , & - 5.186974866d3 , 2.194885201d3 , & - 5.765960509d2 , 9.653534186d1 , & - 1.008066138d1 , 6.010731909d-1 ,& - 1.567417031d-2 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 1.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 1.0d3 fac = Erel ** ( 0.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_1_2_adas function p_cx_1_3_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(3) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ 7.037287586d4 , - 1.479161477d5 , & 1.370120708d5 , - 7.343180122d4 , & 2.509832081d4 , - 5.674317075d3 , & 8.487767749d2 , - 8.102284612d1 , & 4.480007503d0 , - 1.093512342d-1 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 2.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 2.0d3 fac = ( Erel ** ( 1.4 )) / 2.8 endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_1_3_adas function p_cx_1_4_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=4 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(4) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ 6.826447557d4 , - 1.431980004d5 , & 1.323968679d5 , - 7.083995050d4 , & 2.417608863d4 , - 5.458418789d3 , & 8.154875237d2 , - 7.776012846d1 , & 4.295431731d0 , - 1.047567211d-1 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 2.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 2.0d3 fac = ( Erel ** ( 2.0 )) / 4.0 endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_1_4_adas function p_cx_1 ( Erel , m_max ) result ( sigma ) !+Calculates an array of cross section for proton-Hydrogen charge exchange interactions !+from the n=1 state to m = 1..`m_max` states at energy `Erel` !+ !+@note Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]] !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] integer :: i real ( Float64 ) :: norm_fac sigma = 0.d0 do i = 1 , m_max select case ( i ) case ( 1 ) sigma ( 1 ) = p_cx_1_1_adas ( Erel ) case ( 2 ) sigma ( 2 ) = p_cx_1_2_adas ( Erel ) case ( 3 ) sigma ( 3 ) = p_cx_1_3_adas ( Erel ) case ( 4 ) sigma ( 4 ) = p_cx_1_4_adas ( Erel ) case DEFAULT sigma ( i ) = 0.d0 end select enddo !Normalize to Janev norm_fac = p_cx_janev ( Erel , 1 ) / sum ( sigma ) sigma = norm_fac * sigma end function p_cx_1 function p_cx_2_2_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=2 state to the m=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(2) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a2s = [ - 1.896015167d6 , 4.431727330d6 , & - 4.627815357d6 , 2.843068107d6 , & - 1.137952956d6 , 3.100801094d5 , & - 5.825744660d4 , 7.452319142d3 , & - 6.212350647d2 , 3.047712749d1 , & - 6.682658463d-1 ] real ( Float64 ), dimension ( 11 ), parameter :: a2p = [ - 1.614213508d5 , 3.772469288d5 , & - 3.924736424d5 , 2.393127027d5 , & - 9.470300966d4 , 2.541276100d4 , & - 4.682860453d3 , 5.851219013d2 , & - 4.744504549d1 , 2.254460913d0 , & - 4.767235839d-2 ] real ( Float64 ), parameter :: n = 2.d0 real ( Float64 ) :: e , ee , fac , l , sigma2s , sigma2p e = Erel * 1.d3 * n ** 2.0 if ( Erel . le . 1.5d2 ) then ee = max ( e , 1.d3 ) fac = 1.d0 else ee = 1.5e5 * n ** 2.d0 fac = 2.d15 * (( e * 1.d-3 ) ** ( - 5.5 )) endif l = log10 ( ee ) sigma2s = a2s ( 1 ) + a2s ( 2 ) * l + a2s ( 3 ) * l ** 2.0 + a2s ( 4 ) * l ** 3.0 + & a2s ( 5 ) * l ** 4.0 + a2s ( 6 ) * l ** 5.0 + a2s ( 7 ) * l ** 6.0 + & a2s ( 8 ) * l ** 7.0 + a2s ( 9 ) * l ** 8.0 + a2s ( 10 ) * l ** 9.0 + a2s ( 11 ) * l ** 1 0.0 sigma2s = 1 0.d0 ** ( sigma2s ) sigma2p = a2p ( 1 ) + a2p ( 2 ) * l + a2p ( 3 ) * l ** 2.0 + a2p ( 4 ) * l ** 3.0 + & a2p ( 5 ) * l ** 4.0 + a2p ( 6 ) * l ** 5.0 + a2p ( 7 ) * l ** 6.0 + & a2p ( 8 ) * l ** 7.0 + a2p ( 9 ) * l ** 8.0 + a2p ( 10 ) * l ** 9.0 + a2p ( 11 ) * l ** 1 0.0 sigma2p = 1 0.d0 ** ( sigma2p ) sigma = fac * ( 0.25 * sigma2s + 0.75 * sigma2p ) end function p_cx_2_2_adas function p_cx_2_3_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=2 state to the m=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(3) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a2s = [ - 3.513030327d5 , 9.281116596d5 , & - 1.086843398d6 , 7.437325055d5 , & - 3.296609685d5 , 9.897503768d4 , & - 2.039707143d4 , 2.850670244d3 , & - 2.587092857d2 , 1.377382945d1 , & - 3.268306303d-1 ] real ( Float64 ), dimension ( 11 ), parameter :: a2p = [ - 1.901264631d5 , 5.124716103d5 , & - 6.101921504d5 , 4.234717934d5 , & - 1.899866398d5 , 5.764464326d4 , & - 1.199087959d4 , 1.689900512d3 , & - 1.545334374d2 , 8.285001228d0 , & - 1.978656474d-1 ] real ( Float64 ), parameter :: n = 2.d0 real ( Float64 ) :: ee , l , sigma2s , sigma2p ee = max ( Erel * 1.d3 * n ** 2.d0 , 1.d3 ) l = log10 ( ee ) sigma2s = a2s ( 1 ) + a2s ( 2 ) * l + a2s ( 3 ) * l ** 2.0 + a2s ( 4 ) * l ** 3.0 + & a2s ( 5 ) * l ** 4.0 + a2s ( 6 ) * l ** 5.0 + a2s ( 7 ) * l ** 6.0 + & a2s ( 8 ) * l ** 7.0 + a2s ( 9 ) * l ** 8.0 + a2s ( 10 ) * l ** 9.0 + a2s ( 11 ) * l ** 1 0.0 sigma2s = 1 0.d0 ** ( sigma2s ) sigma2p = a2p ( 1 ) + a2p ( 2 ) * l + a2p ( 3 ) * l ** 2.0 + a2p ( 4 ) * l ** 3.0 + & a2p ( 5 ) * l ** 4.0 + a2p ( 6 ) * l ** 5.0 + a2p ( 7 ) * l ** 6.0 + & a2p ( 8 ) * l ** 7.0 + a2p ( 9 ) * l ** 8.0 + a2p ( 10 ) * l ** 9.0 + a2p ( 11 ) * l ** 1 0.0 sigma2p = 1 0.d0 ** ( sigma2p ) sigma = ( 0.25 * sigma2s + 0.75 * sigma2p ) end function p_cx_2_3_adas subroutine m_spread ( n , m_max , sigma_tot , sigma ) !+ Spreads the total charge exchange cross section, `sigma_tot`, !+ among the non-filled m states of `sigma` according to an exponential integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states in `sigma` real ( Float64 ), intent ( in ) :: sigma_tot !+ Amount of \"cross section\" to spread about the non-filled m state of sigma real ( Float64 ), dimension ( m_max ), intent ( inout ) :: sigma !+ Array of cross sections from the `n` state to m=1..`m_max` [cm&#94;2] real ( Float64 ) :: En , Em real ( Float64 ) :: norm_fac real ( Float64 ), dimension ( m_max ) :: sigma_m integer :: m sigma_m = 0.d0 En = 1 3.6 / ( real ( n ) ** 2.0 ) do m = 1 , m_max Em = 1 3.6 / ( real ( m ) ** 2.0 ) if ( sigma ( m ). eq . 0.d0 ) then sigma_m ( m ) = ( sigma_tot / sqrt ( 2.0 * PI )) * exp ( - 0.5 * ( En - Em ) ** 2.0 ) endif enddo norm_fac = sigma_tot / sum ( sigma_m ) do m = 1 , m_max if ( sigma ( m ). eq . 0.d0 ) sigma ( m ) = sigma_m ( m ) * norm_fac if ( sigma ( m ). ne . sigma ( m )) sigma ( m ) = 0.d0 enddo end subroutine m_spread function p_cx_2 ( Erel , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen charge exchange interactions !+from the n=2 state to m = 1..`m_max` states at energy `Erel` !+ !+@note !+Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]]. !+ !+@note !+Cross sections for the n=2 \\rightarrow m=1 states are calculated via !+equivalence principle using [[p_cx_1_2_adas(proc)]]. !+ !+@note !+Cross Sections for m \\geq 4 are calculated by \"spreading\" their !+expected total cross sections among the m \\geq 4 states. !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] real ( Float64 ), parameter :: n2 = 4.d0 integer :: i real ( Float64 ) :: En , Em , sigma_n , norm_fac sigma = 0.d0 do i = 1 , min ( m_max , 3 ) select case ( i ) case ( 1 ) sigma ( 1 ) = p_cx_1_2_adas ( Erel * n2 ) / n2 case ( 2 ) sigma ( 2 ) = p_cx_2_2_adas ( Erel ) case ( 3 ) sigma ( 3 ) = p_cx_2_3_adas ( Erel ) end select enddo sigma_n = max ( p_cx_janev ( Erel , 2 ) - sum ( sigma ), 0.d0 ) call m_spread ( 2 , m_max , sigma_n , sigma ) norm_fac = p_cx_janev ( Erel , 2 ) / sum ( sigma ) sigma = sigma * norm_fac end function p_cx_2 function p_cx_3_2_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(2) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a = [ - 1.149224555d6 , 2.750368877d6 , & - 2.942222842d6 , 1.852584954d6 , & - 7.603284323d5 , 2.125284465d5 , & - 4.097580431d4 , 5.380901722d3 , & - 4.606297192d2 , 2.321345254d1 , & - 5.230186707d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2.0 fac = 1.d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0.d0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_2_adas function p_cx_3_3_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(3) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ - 4.302808608d4 , 9.499298161d4 , & - 9.264698488d4 , 5.236947172d4 , & - 1.890479538d4 , 4.519068626d3 , & - 7.152485009d2 , 7.227063167d1 , & - 4.230036444d0 , 1.092702525d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2 fac = 0.85d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_3_adas function p_cx_3_4_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=4 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(4) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 9 ), parameter :: a = [ 1.705303425d4 , - 3.316878090d4 , & 2.792556433d4 , - 1.330264490d4 , & 3.921666688d3 , - 7.327555138d2 , & 8.476342861d1 , - 5.551987930d0 , & 1.577120745d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2.0 fac = 0.82d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_4_adas function p_cx_3_5_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=5 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(5) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a = [ - 2.786268232d2 , 4.269683825d4 , & - 8.973561028d4 , 8.365732310d4 , & - 4.524587937d4 , 1.563630402d4 , & - 3.580391824d3 , 5.432527332d2 , & - 5.267599631d1 , 2.962329657d0 , & - 7.362649692d-2 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_5_adas function p_cx_3_6inf_adas ( Erel ) result ( sigma ) !+Calculates total cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to \\forall \\; m \\geq 6 states at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(\\forall \\; m \\geq 6) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a = [ 7.146969470d5 , - 1.665413326d6 , & 1.735840441d6 , - 1.065792786d6 , & 4.269334710d5 , - 1.165954977d5 , & 2.198700496d4 , - 2.827160468d3 , & 2.372409350d2 , - 1.173264972d1 , & 2.596865877d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2.0 fac = 2.d20 * ( Erel * n ** 2.0 ) ** ( - 7.0 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_6inf_adas function p_cx_3 ( Erel , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen charge exchange interactions !+from the n=3 state to m = 1..`m_max` states at energy `Erel` !+ !+@note !+Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]]. !+ !+@note !+Cross sections for the n=3 \\rightarrow m=1 states are calculated via !+equivalence principle using [[p_cx_1_3_adas(proc)]]. !+ !+@note !+Cross Sections for m \\geq 6 are calculated by \"spreading\" their !+expected total cross sections among the  m \\geq 6 states. !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] real ( Float64 ), parameter :: n2 = 9.d0 real ( Float64 ) :: eb , En , Em , sigma_m6 , norm_fac real ( Float64 ), dimension ( m_max ) :: sigma1 sigma = 0.d0 sigma1 = 0.d0 sigma1 = p_cx_1 ( Erel * n2 , m_max ) sigma ( 1 ) = p_cx_1_3_adas ( Erel * n2 ) / n2 sigma ( 2 ) = p_cx_3_2_adas ( Erel ) sigma ( 3 ) = p_cx_3_3_adas ( Erel ) sigma ( 4 ) = p_cx_3_4_adas ( Erel ) if ( m_max . ge . 5 ) then sigma ( 5 ) = p_cx_3_5_adas ( Erel ) endif if ( m_max . ge . 6 ) then sigma_m6 = p_cx_3_6inf_adas ( Erel ) call m_spread ( 3 , m_max , sigma_m6 , sigma ) endif norm_fac = p_cx_janev ( Erel , 3 ) / sum ( sigma ) sigma = sigma * norm_fac end function p_cx_3 function p_cx_n ( Erel , n , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen charge exchange interactions !+from the `n` state to m = 1..`m_max` states at energy `Erel` !+ !+@note !+Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]]. !+ !+@note !+Cross sections for some transitions are calculated via the equivalence principle or !+by \"spreading\" their expected total cross sections among the non-filled m states. !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] real ( Float64 ), dimension ( m_max ) :: sigma2 , sigma3 real ( Float64 ) :: sigma_n , e , norm_fac sigma = 0.d0 select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_cx_1 ( Erel , m_max ) return case ( 2 ) sigma = p_cx_2 ( Erel , m_max ) return case ( 3 ) sigma = p_cx_3 ( Erel , m_max ) return case ( 4 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 1 ) = p_cx_1_4_adas ( e / ( 1.0 ** 2.0 )) * ( 1.d0 / n ) ** 2.0 sigma ( 2 ) = sigma2 ( 4 ) * ( 2.d0 / n ) ** 2.0 sigma ( 3 ) = p_cx_3_4_adas ( e / ( 3.0 ** 2.0 )) * ( 3.d0 / n ) ** 2.0 case ( 5 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 2 ) = sigma2 ( 5 ) * ( 2.d0 / n ) ** 2.0 sigma ( 3 ) = p_cx_3_5_adas ( e / ( 3.0 ** 2.0 )) * ( 3.d0 / n ) ** 2.0 case ( 6 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 2 ) = sigma2 ( 6 ) * ( 2.d0 / n ) ** 2.0 sigma3 = p_cx_3 ( e / ( 3.0 ** 2.0 ), m_max ) * ( 3.d0 / n ) ** 2.0 sigma ( 3 ) = sigma3 ( 6 ) case DEFAULT end select sigma_n = max ( p_cx_janev ( Erel , n ) - sum ( sigma ), 0.0 ) call m_spread ( n , m_max , sigma_n , sigma ) norm_fac = p_cx_janev ( Erel , n ) / sum ( sigma ) sigma = norm_fac * sigma end function p_cx_n function p_cx_n_m ( Erel , n , m ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the `n` state to the `m` state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer :: m_max = 12 real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = p_cx_n ( Erel , n , m_max ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function p_cx_n_m function p_cx ( Erel , n_max , m_max ) result ( sigma ) !+Calculates a matrix of cross sections for proton-Hydrogen charge exchange interactions !+from the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n=1..n_{max}) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n_max !+ Number of initial atomic energy levels/states integer , intent ( in ) :: m_max !+ Number of final atomic energy levels/states real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts correspond !+ to the n \\rightarrow m transitions: p_cx[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = p_cx_n ( Erel , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function p_cx !proton-Hydrogen impact ionization function p_ioniz_1_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=1 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 40 and Table 8 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 2.0160d-3 , 3.7154d0 , & 3.9890d-2 , 3.1413d-1 , & 2.1254d0 , 6.3990d3 , & 6.1897d1 , 9.2731d3 ] !+ Fitting Parameters from Table 8 in Ref. 2 real ( Float64 ), parameter :: n2 = 1.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_1_janev function p_ioniz_2_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=2 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 3.9330d-3 , 1.8188d0 , & 1.8870d-2 , 6.7489d-3 , & 1.3768d0 , 6.8852d2 , & 9.6435d1 , 5.6515d23 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 4.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_2_omullane function p_ioniz_3_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=3 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1076d-2 , 1.6197d0 , & 6.7154d-3 , 5.1188d-3 , & 1.8549d0 , 2.3696d2 , & 7.8286d1 , 1.0926d23 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 9.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_3_omullane function p_ioniz_4_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(4) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1033d-2 , 1.6281d0 , & 5.5955d-3 , 7.2023d-3 , & 1.7358d0 , 2.2755d2 , & 8.6339d1 , 3.9151d29 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 1 6.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_4_omullane function p_ioniz_5_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(5) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1297d-2 , 1.8685d0 , & 1.5038d-2 , 1.1195d-1 , & 1.0538d0 , 8.6096d2 , & 8.9939d1 , 1.9249d4 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 2 5.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_5_omullane function p_ioniz_n ( eb , n ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the `n`th state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 40 and Table 8 in Ref. 2 for n=1 [[atomic_tables(module)]] !+* Eq. 5 and Table 1 in Ref. 3 for n \\geq 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_ioniz_1_janev ( eb ) case ( 2 ) sigma = p_ioniz_2_omullane ( eb ) case ( 3 ) sigma = p_ioniz_3_omullane ( eb ) case ( 4 ) sigma = p_ioniz_4_omullane ( eb ) case DEFAULT sigma = p_ioniz_5_omullane ( eb ) * ( n / 5.d0 ) ** 4 end select end function p_ioniz_n function p_ioniz ( eb , n_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen impact ionization interactions !+from the n = 1..`n_max` state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n=1..n_{max}) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 40 and Table 8 in Ref. 2 for n=1 [[atomic_tables(module)]] !+* Eq. 5 and Table 1 in Ref. 3 for n \\geq 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n_max !+ Number of initial atomic energy level/state real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the index refers to the `n`'th state [cm&#94;2] integer :: i do i = 1 , n_max sigma ( i ) = p_ioniz_n ( eb , i ) enddo end function p_ioniz !! proton-Hydrogen impact excitation function p_excit_1_2_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=2 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(2)  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ 3 4.433d0 , 8.5476d0 , & 7.8501d0 , - 9.2217d0 , & 1.8020d-2 , 1.6931d0 , & 1.9422d-3 , 2.9068d0 , & 4 4.507d0 , 0.56870d0 ] !+ Fitting parameters from Table 4 in Ref. 2 sigma = 1.d-16 * a ( 1 ) * ( a ( 2 ) * exp ( - a ( 3 ) * eb ) / ( eb ** a ( 4 )) + & a ( 5 ) * exp ( - a ( 6 ) / eb ) / ( 1. + a ( 7 ) * eb ** a ( 8 )) + & exp ( - a ( 9 ) / eb ) * log ( 1. + a ( 10 ) * eb ) / eb ) end function p_excit_1_2_janev function p_excit_1_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=3 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(3)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 6.1950d0 , 5.5162d-3 , & 0.29114d0 , - 4.5264d0 , & 6.0311d0 , - 2.0679d0 , & 3 5.773d0 , 0.54818d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_3_janev function p_excit_1_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(4)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 2.0661d0 , 5.1335d-4 , & 0.28953d0 , - 2.2849d0 , & 0.11528d0 , - 4.8970d0 , & 3 4.975d0 , 0.91213d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_4_janev function p_excit_1_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(5)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.2449d0 , 3.0826d-4 , & 0.31063d0 , - 2.4161d0 , & 0.024664d0 , - 6.3726d0 , & 3 2.291d0 , 0.21176d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_5_janev function p_excit_1_6_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=6 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(6)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 0.63771d0 , 3.2949d-4 , & 0.25757d0 , - 2.2950d0 , & 0.050796d0 , - 5.5986d0 , & 3 7.174d0 , 0.39265d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_6_janev function p_excit_1_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from !+the n=1 state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 1  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for m \\gt 6 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from n=1 to m [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = p_excit_1_2_janev ( eb ) case ( 3 ) sigma ( 3 ) = p_excit_1_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = p_excit_1_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_1_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_1_6_janev ( eb ) case DEFAULT sigma ( m ) = p_excit_1_6_janev ( eb ) * ( 6.0 / real ( m )) ** 3.0 end select enddo end function p_excit_1_janev function p_excit_2_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=3 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(3)  !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 39 4.51d0 , 0.013597d0 , & 0.16565d0 , - 0.8949d0 , & 2 1.606d0 , 0.62426d0 ] !+ Fitting parameters from Table 6 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_3_janev function p_excit_2_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(4)  !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 5 0.744d0 , 0.014398d0 , & 0.31584d0 , - 1.4799d0 , & 1 9.416d0 , 4.0262d0 ] !+ Fitting parameters from Table 6 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_4_janev function p_excit_2_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(5)  !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 1 8.264d0 , 0.013701d0 , & 0.31711d0 , - 1.4775d0 , & 1 8.973d0 , 2.9056d0 ] !+ Fitting parameters from Table 6 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_5_janev function p_excit_2_6_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=6 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(6)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 4.61d-1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_6_janev function p_excit_2_7_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=7 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(7)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 2.475d-1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_7_janev function p_excit_2_8_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=8 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(8)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.465d-1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_8_janev function p_excit_2_9_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=9 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(9)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 9.2d-2 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_9_janev function p_excit_2_10_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=10 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(10)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 6.05d-2 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_10_janev function p_excit_2_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from !+the n=2 state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 2 !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 for m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for m \\gt 10 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from n=2 to m [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = p_excit_2_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = p_excit_2_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_2_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_2_6_janev ( eb ) case ( 7 ) sigma ( 7 ) = p_excit_2_7_janev ( eb ) case ( 8 ) sigma ( 8 ) = p_excit_2_8_janev ( eb ) case ( 9 ) sigma ( 9 ) = p_excit_2_9_janev ( eb ) case ( 10 ) sigma ( 10 ) = p_excit_2_10_janev ( eb ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / real ( m )) ** 3.0 end select enddo end function p_excit_2_janev function p_excit_3_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(4)  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 124 7.5d0 , 0.068781d0 , & 0.521176d0 , - 1.2722d0 , & 1 1.319d0 , 2.6235d0 ] !+ Fitting parameters from Table 7 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_4_janev function p_excit_3_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(5)  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 19 0.59d0 , 0.073307d0 , & 0.54177d0 , - 1.2894d0 , & 1 1.096d0 , 2.9098d0 ] !+ Fitting parameters from Table 7 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_5_janev function p_excit_3_6_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=6 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(6)  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 6 3.494d0 , 0.077953d0 , & 0.53461d0 , - 1.2881d0 , & 1 1.507d0 , 4.3417d0 ] !+ Fitting parameters from Table 7 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_6_janev function p_excit_3_7_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=7 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(7)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 4.67d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_7_janev function p_excit_3_8_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=8 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(8)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 2.545d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_8_janev function p_excit_3_9_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=9 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(9)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.54d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_9_janev function p_excit_3_10_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=10 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(10)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.0d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_10_janev function p_excit_3_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen impact excitation transitions from !+the n=3 state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 3  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 for m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for m \\gt 10 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from n=3 to m [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = 0.d0 case ( 4 ) sigma ( 4 ) = p_excit_3_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_3_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_3_6_janev ( eb ) case ( 7 ) sigma ( 7 ) = p_excit_3_7_janev ( eb ) case ( 8 ) sigma ( 8 ) = p_excit_3_8_janev ( eb ) case ( 9 ) sigma ( 9 ) = p_excit_3_9_janev ( eb ) case ( 10 ) sigma ( 10 ) = p_excit_3_10_janev ( eb ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / real ( m )) ** 3.0 end select enddo end function p_excit_3_janev function p_excit_n ( eb , n , m_max ) result ( sigma ) !+Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from !+the `n` state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 [[atomic_tables(module)]] !+* Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from `n` to m [cm&#94;2] integer :: m real ( Float64 ) :: nf , mf , Etil , s , D , A , G , L , F real ( Float64 ) :: y , zpl , zmi , C2pl , C2mi , H sigma = 0.d0 select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_excit_1_janev ( eb , m_max ) case ( 2 ) sigma = p_excit_2_janev ( eb , m_max ) case ( 3 ) sigma = p_excit_3_janev ( eb , m_max ) case DEFAULT nf = real ( n ) m_loop : do m = 1 , m_max if ( n . ge . m ) then sigma ( m ) = 0.d0 cycle m_loop endif mf = real ( m ) Etil = Eb / 2 5.0 s = ( mf - nf ) D = exp ( - 1.0 / ( nf * mf * Etil ** 2.0 )) A = 8.0 / ( 3.0 * s ) * ( mf / ( s * nf )) ** 3 * ( 0.184 - 0.04 / s ** ( 2.0 / 3.0 )) * & ( 1.0 - 0.2 * s / ( nf * mf )) ** ( 1.0 + 2.0 * s ) G = 0.5 * ( Etil * nf ** 2.0 / ( mf - 1.0 / mf ) ) ** 3. L = log ( 1.0 + 0.53 * Etil ** 2.0 * nf * ( mf - 2.0 / mf ) / ( 1.0 + 0.4 * Etil )) F = ( 1.0 - 0.3 * s * D / ( nf * mf ) ) ** ( 1.0 + 2.0 * s ) y = 1.0 / ( 1.0 - D * log ( 18 * s ) / ( 4.0 * s ) ) zpl = 2.0 / ( Etil * nf ** 2 * ( ( 2.0 - ( nf / mf ) ** 2 ) ** 0.5 + 1.0 )) zmi = 2.0 / ( Etil * nf ** 2 * ( ( 2.0 - ( nf / mf ) ** 2 ) ** 0.5 - 1.0 )) C2pl = zpl ** 2 * log ( 1.0 + 2.0 * zpl / 3.0 ) / ( 2.0 * y + 3.0 * zpl / 2.0 ) C2mi = zmi ** 2 * log ( 1.0 + 2.0 * zmi / 3.0 ) / ( 2.0 * y + 3.0 * zmi / 2.0 ) H = C2mi - C2pl sigma ( m ) = (( 8.8d-17 * n ** 4 ) / Etil ) * ( A * L * D + F * G * H ) enddo m_loop end select end function p_excit_n function p_excit_n_m ( eb , n , m ) result ( sigma ) !+Calculates the cross section for a proton-Hydrogen impact excitation transition from !+the `n` state to the `m` state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m), m \\gt n  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 [[atomic_tables(module)]] !+* Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = p_excit_n ( eb , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function p_excit_n_m function p_excit ( eb , n_max , m_max ) result ( sigma ) !+Calculates a matrix of cross sections for a proton-Hydrogen impact excitation transitions !+from the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n=1..n_{max}) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 [[atomic_tables(module)]] !+* Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of initial atomic energy levels/states integer , intent ( in ) :: n_max !+ Number of final atomic energy levels/states real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts correspond !+ to the n \\rightarrow m transitions: p_excit[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = p_excit_n ( eb , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function p_excit function e_ioniz_1_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the n=1 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer , parameter :: n = 1 !+ Initial atomic energy level/state real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.18450d0 , - 0.032226d0 , & - 0.034539d0 , 1.4003d0 , & - 2.8115d0 , 2.2986d0 ] !+ Fitting parameters from Table 3 in Ref. 2 real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1.d3 !keV to eV x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1.d-13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) sigma = max ( sigma , 0.d0 ) end function e_ioniz_1_janev function e_ioniz_2_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the n=2 state at energy `eb` !+ !+###Equation !+ e + H(2) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer , parameter :: n = 2 !+ Initial atomic energy level/state real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.14784d0 , 0.0080871d0 , & - 0.062270d0 , 1.9414d0 , & - 2.1980d0 , 0.95894d0 ] !+ Fitting parameters from Table 3 in Ref. 2 real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1.d3 !keV to eV x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1.d-13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) sigma = max ( sigma , 0.d0 ) end function e_ioniz_2_janev function e_ioniz_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the n=3 state at energy `eb` !+ !+###Equation !+ e + H(3) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer , parameter :: n = 3 !+ Initial atomic energy level/state real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.058463d0 , - 0.051272d0 , & 0.85310d0 , - 0.57014d0 , & 0.76684d0 , 0.00d0 ] !+ Fitting parameters from Table 3 in Ref. 2 real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1.d3 !keV to eV if ( e . ge . 1.5 ) then x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1.d-13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) else sigma = 0.d0 endif end function e_ioniz_3_janev function e_ioniz_n ( eb , n ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the `n` state at energy `eb` !+ !+###Equation !+ e + H(n) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+* Eq. 15-16 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ) :: rn , xn , Edn2 real ( Float64 ) :: g0 , g1 , g2 , An , b , Bn select case ( n ) case ( 0 ) stop case ( 1 ) sigma = e_ioniz_1_janev ( eb ) case ( 2 ) sigma = e_ioniz_2_janev ( eb ) case ( 3 ) sigma = e_ioniz_3_janev ( eb ) case DEFAULT rn = 1.94 / n ** 1.57 Edn2 = 1 3.6 / n ** 2.0 xn = ( eb * 1.d3 ) / Edn2 g0 = 0.9935 + 0.2328 / n - 0.1296 / n ** 2.0 g1 = - ( 1.0 / n ) * ( 0.6282 - 0.5598 / n + 0.5299 / n ** 2.0 ) g2 = ( 1.0 / n ** 2.0 ) * ( 0.3887 - 1.181 / n + 1.47 / n ** 2.0 ) An = 3 2.0 * n / ( 3.0 * sqrt ( 3.0 ) * PI ) * ( g0 / 3.0 + g1 / 4.0 + g2 / 5.0 ) b = ( 1.0 / n ) * ( 4.0 - 1 8.63 / n + 3 6.24 / n ** 2.0 - 2 8.09 / n ** 3.0 ) Bn = ( 2.0 / 3.0 ) * ( n ** 2.0 ) * ( 5.0 + b ) if ( xn . gt . 1 ) then sigma = 1.76 * n ** 2 / xn * ( 1.0 - exp ( - rn * xn )) * & ( An * log ( xn ) + ( Bn - An * log ( 2.0 * n ** 2 )) * & ( 1.0 - 1.0 / xn ) ** 2 ) * 1.e-16 else sigma = 0.d0 endif end select end function e_ioniz_n function e_ioniz ( eb , n_max ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact ionization from !+the n=1..n_{max} states at energy `eb` !+ !+###Equation !+ e + H(n=1..n_{max}) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+* Eq. 15-16 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n_max !+ Number of initial atomic energy levels/states to calculate real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the n'th index refers to a ionization from the n'th state [cm&#94;2] integer :: i do i = 1 , n_max sigma ( i ) = e_ioniz_n ( eb , i ) enddo end function e_ioniz function e_excit_1_2_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=2 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(2)  !+ !+###References !+* Eq. 4 and Table 1 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 0.2d0 real ( Float64 ), parameter :: a = 0.228d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: b = 0.1865d0 !+ Fitting paramter from Table 2 in Ref. 2 real ( Float64 ), parameter :: c = 0.5025d0 !+ Fitting paramter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 6 ), parameter :: An = [ 4.4979d0 , 1.4182d0 , & - 2 0.877d0 , 4 9.735d0 , & - 4 6.249d0 , 1 7.442d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ( ecoll ) / deltaE if (( ecoll . gt . 1 0.2 ). and .( ecoll . le . 1 1.56 )) then sigma = 1.d-16 * ( a + b * ( ecoll - deltaE )) return endif if (( ecoll . ge . 1 1.56 ). and .( ecoll . le . 1 2.23 )) then sigma = 1.d-16 * c return endif if ( ecoll . ge . 1 2.23 ) then s = An ( 2 ) + An ( 3 ) / x + An ( 4 ) / x ** 2.0 + An ( 5 ) / x ** 3.0 + An ( 6 ) / x ** 4.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( An ( 1 ) * log ( x ) + s ) return endif if ( x . le . 1.0 ) then sigma = 0.0 return endif end function e_excit_1_2_janev function e_excit_1_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=3 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(3)  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 2.09d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: alpha = 0.38277d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.75448d0 , 0.42956d0 , & - 0.58288d0 , 1.0693d0 , & 0.d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_1_3_janev function e_excit_1_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=4 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(4)  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 2.75d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: alpha = 0.41844d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.24300d0 , 0.24846d0 , & 0.19701d0 , 0.d0 , & 0.d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_1_4_janev function e_excit_1_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=5 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(5)  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 3.06d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: alpha = 0.45929d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.11508d0 , 0.13092d0 , & 0.23581d0 , 0.d0 , & 0.d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_1_5_janev function e_excit_f ( n , m ) result ( fnm ) !+ Oscillator strength for a `n`\\rightarrow`m` transition due to electron-Hydrogen impact excitation !+ !+###References !+* Eqs. 11-13 in Ref. 2 [[atomic_tables(module)]] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: fnm !+ Oscillator strength real ( Float64 ), dimension ( 3 ) :: g real ( Float64 ) :: x , nf , mf , gs nf = real ( n ) mf = real ( m ) x = 1.0 - ( nf / mf ) ** 2.0 select case ( n ) case ( 1 ) g = [ 1.133 , - 0.4059 , 0.0714 ] case ( 2 ) g = [ 1.0785 , - 0.2319 , 0.02947 ] case DEFAULT g ( 1 ) = 0.9935 + 0.2328 / nf - 0.1296 / nf ** 2 g ( 2 ) =- 1.0 / nf * ( 0.6282 - 0.5598 / nf + 0.5299 / nf ** 2 ) g ( 3 ) = 1.0 / nf ** 2.0 * ( 0.3887 - 1.1810 / nf + 1.4700 / nf ** 2 ) end select gs = g ( 1 ) + g ( 2 ) / x + g ( 3 ) / x ** 2 fnm = 3 2.0 / ( 3.0 * sqrt ( 3.0 ) * PI ) * nf / mf ** 3 * 1 / x ** 3 * gs end function e_excit_f function e_excit_1_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=1..m_{max} state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(m=1..m_{max})  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=1 state to the m'th state [cm&#94;2] integer :: m real ( Float64 ) :: x , y , A , B , deltaE do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = e_excit_1_2_janev ( eb ) case ( 3 ) sigma ( 3 ) = e_excit_1_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = e_excit_1_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = e_excit_1_5_janev ( eb ) case DEFAULT y = 1.0 - ( 1.d0 / m ) ** 2.0 deltaE = 1 3.6 * y x = ( eb * 1.d3 ) / deltaE A = 2.0 * e_excit_f ( 1 , m ) / y B = 4.0 / ( m ** 3.0 * y ) * ( 1.0 + 4.0 / ( 3.0 * y ) - 0.603 / y ** 2.0 ) sigma ( m ) = 1.76e-16 / ( y * x ) * ( 1.0 - exp ( - 0.45 * y * x )) * & ( A * ( log ( x ) + 1.0 / ( 2.0 * x )) + ( B - A * log ( 2.0 / y )) * & ( 1.0 - 1.0 / x )) if ( x . le . 1.0 ) sigma ( m ) = 0.d0 end select enddo end function e_excit_1_janev function e_excit_2_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=2 state to the m=3 state at energy `eb` !+ !+###Equation !+ e + H(2) \\rightarrow e + H(3)  !+ !+###References !+* Eq. 5 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1.8888d0 !+ Energy difference between n=1 and n=3: !+ \\Delta E = 13.6\\left (\\frac{1}{2&#94;2} - \\frac{1}{3&#94;2}\\right ) real ( Float64 ), parameter :: alpha = 1.3196d0 !+ Fitting parameter from Section 2.1.1 B in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 3 8.906d0 , 5.2373d0 , 11 9.25d0 , & - 59 5.39d0 , 81 6.71d0 ] !+ Fitting parameters from Section 2.1.1 B in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_2_3_janev function e_excit_n ( eb , n , m_max ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from !+the `n` state to the m=1..m_{max} state at energy `eb` !+ !+###Equation !+ e + H(n) \\rightarrow e + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the `n`\\rightarrow`m` state [cm&#94;2] integer :: m real ( Float64 ) :: nf , mf real ( Float64 ) :: x , y , A , B , bn , r , deltaE nf = real ( n ) if ( n . eq . 1 ) then sigma = e_excit_1_janev ( eb , m_max ) else m_loop : do m = 1 , m_max mf = real ( m ) if ( n . ge . m ) then sigma ( m ) = 0.d0 cycle m_loop endif if (( n . eq . 2 ). and .( m . eq . 3 )) then sigma ( m ) = e_excit_2_3_janev ( eb ) else deltaE = 1 3.6 * ( 1.0 / nf ** 2 - 1.0 / mf ** 2 ) x = ( eb * 1.d3 ) / deltaE y = 1.0 - ( nf / mf ) ** 2 r = 1.94 / nf ** 1.57 A = 2.0 * nf ** 2 * e_excit_f ( n , m ) / y bn = 1.0 / nf * ( 4.0 - 1 8.63 / nf + 3 6.24 / nf ** 2 - 2 8.09 / nf ** 3 ) B = 4.0 * nf ** 4 / ( mf ** 3 * y ** 2 ) * ( 1.0 + 4.0 / ( 3.0 * y ) + bn / y ** 2.0 ) sigma ( m ) = 1.76e-16 * nf ** 2 / ( y * x ) * ( 1.0 - exp ( - r * y * x )) * & ( A * ( log ( x ) + 1.0 / ( 2.0 * x )) + ( B - A * log ( 2.0 * n ** 2.0 / y )) * & ( 1.0 - 1.0 / x )) if ( x . le . 1.0 ) sigma ( m ) = 0.d0 endif enddo m_loop endif end function e_excit_n function e_excit_n_m ( eb , n , m ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from !+the `n` \\rightarrow `m` state at energy `eb` !+ !+###Equation !+ e + H(n) \\rightarrow e + H(m), m \\gt n  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = e_excit_n ( eb , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function e_excit_n_m function e_excit ( eb , n_max , m_max ) result ( sigma ) !+Calculates a matrix of cross section for a proton-Hydrogen impact excitation transition !+from the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy `eb` !+ !+###Equation !+ e + H(n=1..n_{max}) \\rightarrow e + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of initial atomic energy levels/states integer , intent ( in ) :: n_max !+ Number of final atomic energy levels/states real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts correspond !+ to the n \\rightarrow m transitions: e_excit[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n do n = 1 , 12 sigma_full ( n ,:) = e_excit_n ( eb , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function e_excit !Impurities !A[q]_cx_[n]_[source] function B5_cx_1_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(1) \\rightarrow B&#94;{4+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 7 ), parameter :: A = [ 1.174052518d3 , - 1.793561728d3 , & 1.117522436d3 , - 3.679435571d2 , & 6.750816878d1 , - 6.542029074d0 , & 2.614113716d-1 ] real ( Float64 ) :: e , l , p e = max ( eb * 1.d3 , 1 0.0 ) l = log10 ( e ) if ( e . le . 4.d5 ) then p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 sigma = 1 0.d0 ** p else sigma = 0.d0 endif end function B5_cx_1_adas function B5_cx_2_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=2 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(2) \\rightarrow B&#94;{4+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: A = [ 6.603246818d1 , - 3.072575676d2 , & 5.030801019d2 , - 4.585636345d2 , & 2.568666393d2 , - 9.185150382d1 , & 2.100012584d1 , - 2.964174788d0 , & 2.346396110d-1 , - 7.943766873d-3 ] real ( Float64 ) :: e , l , p e = max ( eb * 1.d3 , 1 0.0 ) l = log10 ( e ) if ( e . le . 1.d5 ) then p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 sigma = 1 0.d0 ** p else sigma = 0.d0 endif end function B5_cx_2_adas function C6_cx_1_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(1) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 7 ), parameter :: A = [ 2.007882674d2 , - 3.546893286d2 , & 2.381542403d2 , - 8.355431742d1 , & 1.617519888d1 , - 1.638152470d0 , & 6.768953863d-2 ] real ( Float64 ) :: e , l , p e = max ( eb * 1.d3 , 1.5d3 ) l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 sigma = 1 0.d0 ** p end function C6_cx_1_adas function C6_cx_2_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=2 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(2) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 9.151879441d5 , - 2.134573133d6 , & 2.223792624d6 , - 1.362648703d6 , & 5.438401343d5 , - 1.477110500d5 , & 2.764972254d4 , - 3.522105245d3 , & 2.921934171d2 , - 1.425552507d1 , & 3.106007048d-1 ] real ( Float64 ) :: e , l , p e = max ( eb * 1.d3 , 1.5d3 ) * 2.0 ** 2 l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 + A ( 11 ) * l ** 10 sigma = 1 0.d0 ** p end function C6_cx_2_adas function C6_cx_3_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=3 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(3) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 9.208877916d5 , - 2.147294379d6 , & 2.236451628d6 , - 1.370042347d6 , & 5.466461899d5 , - 1.484338816d5 , & 2.777765778d4 , - 3.537459450d3 , & 2.933884362d2 , - 1.430994136d1 , & 3.117002878d-1 ] real ( Float64 ) :: e , l , p e = max ( eb * 1.d3 , 1.5d3 ) * 3.0 ** 2 l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 + A ( 11 ) * l ** 10 sigma = 1 0.d0 ** p end function C6_cx_3_adas function Aq_cx_n_adas ( eb , q , n ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+@note Returns 0 if ADAS cross sections are not available for given inputs !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] sigma = 0.d0 select case ( q ) case ( 5 ) if ( n . eq . 1 ) sigma = B5_cx_1_adas ( eb ) if ( n . eq . 2 ) sigma = B5_cx_2_adas ( eb ) case ( 6 ) if ( n . eq . 1 ) sigma = C6_cx_1_adas ( eb ) if ( n . eq . 2 ) sigma = C6_cx_2_adas ( eb ) if ( n . eq . 3 ) sigma = C6_cx_3_adas ( eb ) case DEFAULT sigma = 0.d0 end select end function Aq_cx_n_adas function B5_cx_1_janev ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(1) \\rightarrow B&#94;{4+} + H&#94;+  !+ !+###References !+* Page 166 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 3 1.226d0 , 1.1442d0 , & 4.8372d-8 , 3.0961d-10 , & 4.7205d0 , 6.2844d-7 , & 3.1297d0 , 0.12556d0 , & 0.30098d0 , 5.9607d-2 , & - 0.57923d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ** A ( 8 )) / & ( 1.0 + A ( 3 ) * eb ** 2 + A ( 4 ) * eb ** A ( 5 ) + & A ( 6 ) * eb ** A ( 7 )) + A ( 9 ) * exp ( - A ( 10 ) * eb ) / eb ** A ( 11 )) end function B5_cx_1_janev function C6_cx_1_janev ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(1) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Page 168 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 41 8.18d0 , 2.1585d0 , & 3.4808d-4 , 5.3333d-9 , & 4.6556d0 , 0.33755d0 , & 0.81736d0 , 0.27874d0 , & 1.8003d-6 , 7.1033d-2 , & 0.53261d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ** A ( 8 )) / & ( 1.0 + A ( 3 ) * eb ** 2 + A ( 4 ) * eb ** A ( 5 ) + & A ( 6 ) * eb ** A ( 7 )) + A ( 9 ) * exp ( - A ( 10 ) * eb ) / eb ** A ( 11 )) end function C6_cx_1_janev function Aq_cx_n_janev ( eb , q , n ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Page 166 in Ref. 5 [[atomic_tables(module)]] !+* Page 168 in Ref. 5 [[atomic_tables(module)]] !+* Page 174 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.507d5 real ( Float64 ), parameter :: B = 1.974d-5 real ( Float64 ) :: etil , nf , qf nf = real ( n ) qf = real ( q ) if (( n . eq . 1 ). and .( q . eq . 5 )) then sigma = B5_cx_1_janev ( eb ) return endif if (( n . eq . 1 ). and .( q . eq . 6 )) then sigma = C6_cx_1_janev ( eb ) return endif if ( n . le . 1 ) then sigma = 0.d0 return endif etil = eb * ( nf ** 2.0 ) / ( qf ** 0.5 ) sigma = qf * nf ** 4 * 7.04d-16 * A / ( etil ** 3.5 * ( 1.0 + B * etil ** 2 )) * & ( 1.0 - exp ( - 2.0 * etil ** 3.5 * ( 1.0 + B * etil ** 2 ) / ( 3.0 * A ))) end function Aq_cx_n_janev function Aq_cx_n ( eb , q , n ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses ADAS(Ref. 4) cross sections if available else uses Janev (Ref. 5) cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] !+* Page 166 in Ref. 5 [[atomic_tables(module)]] !+* Page 168 in Ref. 5 [[atomic_tables(module)]] !+* Page 174 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] sigma = Aq_cx_n_adas ( eb , q , n ) if ( sigma . eq . 0.d0 ) then sigma = Aq_cx_n_janev ( eb , q , n ) endif end function Aq_cx_n function Aq_cx ( eb , q , n_max ) result ( sigma ) !+ Calculates an array of total charge exchange cross sections for a Neutral Hydrogen atom !+in the n=1...n_max states colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses ADAS(Ref. 4) cross sections if available else uses Janev (Ref. 5) cross sections !+ !+###Equation !+ A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] !+* Page 174 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n_max !+ Number of initial atomic energy levels/states real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the n'th index refers to a charge exchange from the n'th state [cm&#94;2] integer :: n do n = 1 , n_max sigma ( n ) = Aq_cx_n ( eb , q , n ) enddo end function Aq_cx !Impurity impact ionization function B5_ioniz_1_janev ( eb ) result ( sigma ) !+ Calculates the total ionization cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(1) \\rightarrow B&#94;{5+} + H&#94;+ + e  !+ !+###References !+* Page 152 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: A = [ 35 1.52d0 , 23 3.63d0 , & 3.2952d3 , 5.3787d-6 , & 1.8834d-2 , - 2.2064d0 , & 7.2074d0 , - 3.78664d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ) * log ( 1 + A ( 3 ) * eb ) / eb & + A ( 4 ) * exp ( - A ( 5 ) * eb ) / (( eb ** A ( 6 )) + A ( 7 ) * ( eb ** A ( 8 )))) end function B5_ioniz_1_janev function C6_ioniz_1_janev ( eb ) result ( sigma ) !+ Calculates the total ionization cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(1) \\rightarrow C&#94;{6+} + H&#94;+ + e  !+ !+###References !+* Page 154 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: A = [ 43 8.36d0 , 32 7.10d0 , & 1.4444d5 , 3.5212d-3 , & 8.3031d-3 , - 0.63731d0 , & 1.9116d4 , - 3.1003d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ) * log ( 1 + A ( 3 ) * eb ) / eb & + A ( 4 ) * exp ( - A ( 5 ) * eb ) / (( eb ** A ( 6 )) + A ( 7 ) * ( eb ** A ( 8 )))) end function C6_ioniz_1_janev function Aq_ioniz_n_janev ( eb , q , n ) result ( sigma ) !+ Calculates the generic total ionization cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H&#94;+ + e, n \\gt 1, q \\gt 3  !+ !+###References !+* Page 160 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: M = 0.283d0 real ( Float64 ), parameter :: B = 4.04d0 real ( Float64 ), parameter :: c = 13 7.d0 real ( Float64 ), parameter :: g = 0.662d0 real ( Float64 ), parameter :: lambda = 0.76d0 real ( Float64 ) :: nf , qf , u , v , sigma_b nf = real ( n ) qf = real ( q ) v = sqrt ( eb / 2 5. ) u = nf * v sigma_b = 3.52d-16 * ( nf ** 4 ) * ( qf ** 2 ) / ( u ** 2 ) * & ( M * ( log (( u ** 2 ) / ( c ** 2 - u ** 2 )) - ( u ** 2 ) / ( c ** 2 )) + B - g / u ** 2 ) sigma_b = max ( sigma_b , 0.d0 ) sigma = exp ( - lambda * qf / u ** 2 ) * sigma_b end function Aq_ioniz_n_janev function Aq_ioniz_n ( eb , q , n ) result ( sigma ) !+ Calculates the total ionization cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Page 152 in Ref. 5 [[atomic_tables(module)]] !+* Page 154 in Ref. 5 [[atomic_tables(module)]] !+* Page 160 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] if (( q . eq . 5 ). and .( n . eq . 1 )) then sigma = B5_ioniz_1_janev ( eb ) return endif if (( q . eq . 6 ). and .( n . eq . 1 )) then sigma = C6_ioniz_1_janev ( eb ) return endif sigma = Aq_ioniz_n_janev ( eb , q , n ) end function Aq_ioniz_n function Aq_ioniz ( eb , q , n_max ) result ( sigma ) !+ Calculates an array of total ionization cross sections for a Neutral Hydrogen atom !+in the n=1...n_max states colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Page 152 in Ref. 5 [[atomic_tables(module)]] !+* Page 154 in Ref. 5 [[atomic_tables(module)]] !+* Page 160 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n_max !+ Number of initial states n to calculate real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the n'th index refers to a ionization from the n'th state [cm&#94;2] integer :: n do n = 1 , n_max sigma ( n ) = Aq_ioniz_n ( eb , q , n ) enddo end function Aq_ioniz !Impurity impact excitation function Aq_excit_1_2_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=2 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(2), q \\gt 4  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 3 8.738d0 , 3 7.033d0 , & 0.39862d0 , 7.7582d-5 , & 0.25402d0 , - 2.7418d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_2_janev function Aq_excit_1_3_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=3 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(3), q \\gt 4  !+ !+###References !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 4.3619d0 , 5 7.451d0 , & 2 1.001d0 , 2.3292d-4 , & 0.083130d0 , - 2.2364d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_3_janev function Aq_excit_1_4_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=4 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(4), q \\gt 4  !+ !+###References !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 1.3730d0 , 6 0.710d0 , & 3 1.797d0 , 2.0207d-4 , & 0.082513d0 , - 2.3055d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_4_janev function Aq_excit_1_5_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=5 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(5), q \\gt 4  !+ !+###References !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.56565d0 , 6 7.333d0 , & 5 5.290d0 , 2.1595d-4 , & 0.081624d0 , - 2.1971d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_5_janev function Aq_excit_1_janev ( eb , q , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=1 state to the m'th state [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = Aq_excit_1_2_janev ( eb , q ) case ( 3 ) sigma ( 3 ) = Aq_excit_1_3_janev ( eb , q ) case ( 4 ) sigma ( 4 ) = Aq_excit_1_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_1_5_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 5 ) * ( 5.0 / m ) ** 3.0 end select enddo end function Aq_excit_1_janev function Aq_excit_2_3_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=3 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(3), q \\gt 3  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 35 8.03d0 , 2 5.283d0 , & 1.4726d0 , 0.014398d0 , & 0.12207d0 , - 0.86210d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_3_janev function Aq_excit_2_4_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=4 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(4), q \\gt 3  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 5 0.744d0 , 1 9.416d0 , & 4.0262d0 , 0.014398d0 , & 0.31584d0 , - 1.4799d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_4_janev function Aq_excit_2_5_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=5 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(5), q \\gt 3  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 1 8.264d0 , 1 8.973d0 , & 2.9056d0 , 0.013701d0 , & 0.31711d0 , - 1.4775d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_5_janev function Aq_excit_2_6_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=6 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(6), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.4610d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_6_janev function Aq_excit_2_7_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=7 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(7), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.2475d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_7_janev function Aq_excit_2_8_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=8 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(8), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.1465d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_8_janev function Aq_excit_2_9_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=9 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(9), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.092d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_9_janev function Aq_excit_2_10_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=10 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(10), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.0605d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_10_janev function Aq_excit_2_janev ( eb , q , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4, m \\gt n  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=2 state to the m'th state [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = Aq_excit_2_3_janev ( eb , q ) case ( 4 ) sigma ( 4 ) = Aq_excit_2_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_2_5_janev ( eb , q ) case ( 6 ) sigma ( 6 ) = Aq_excit_2_6_janev ( eb , q ) case ( 7 ) sigma ( 7 ) = Aq_excit_2_7_janev ( eb , q ) case ( 8 ) sigma ( 8 ) = Aq_excit_2_8_janev ( eb , q ) case ( 9 ) sigma ( 9 ) = Aq_excit_2_9_janev ( eb , q ) case ( 10 ) sigma ( 10 ) = Aq_excit_2_10_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / m ) ** 3.0 end select enddo end function Aq_excit_2_janev function Aq_excit_3_4_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=4 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(4), q \\gt 3  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 124 7.5d0 , 1 1.319d0 , & 2.6235d0 , 0.068781d0 , & 0.521176d0 , - 1.2722d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_4_janev function Aq_excit_3_5_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=5 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(5), q \\gt 3  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 19 0.59d0 , 1 1.096d0 , & 2.9098d0 , 0.073307d0 , & 0.54177d0 , - 1.2894d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_5_janev function Aq_excit_3_6_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=6 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(6), q \\gt 3  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 6 3.494d0 , 1 1.507d0 , & 4.3417d0 , 0.077953d0 , & 0.53461d0 , - 1.2881d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_6_janev function Aq_excit_3_7_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=7 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(7), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.4670d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_7_janev function Aq_excit_3_8_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=8 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(8), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.2545d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_8_janev function Aq_excit_3_9_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=9 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(9), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.1540d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_9_janev function Aq_excit_3_10_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=10 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(10), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.1d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_10_janev function Aq_excit_3_janev ( eb , q , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4, m \\gt n  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=3 state to the m'th state [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = 0.d0 case ( 4 ) sigma ( 4 ) = Aq_excit_3_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_3_5_janev ( eb , q ) case ( 6 ) sigma ( 6 ) = Aq_excit_3_6_janev ( eb , q ) case ( 7 ) sigma ( 7 ) = Aq_excit_3_7_janev ( eb , q ) case ( 8 ) sigma ( 8 ) = Aq_excit_3_8_janev ( eb , q ) case ( 9 ) sigma ( 9 ) = Aq_excit_3_9_janev ( eb , q ) case ( 10 ) sigma ( 10 ) = Aq_excit_3_10_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / m ) ** 3.0 end select enddo end function Aq_excit_3_janev function Aq_excit_n_janev ( eb , q , n , m_max ) result ( sigma ) !+Calculates an array of the generic excitation cross sections for a neutral Hydrogen atom transitioning from !+the `n` state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n, n \\gt 3  !+ !+###References !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the `n` state to the m'th state [cm&#94;2] integer :: m real ( Float64 ) :: nf , mf , qf , etil , hi , s real ( Float64 ) :: D , A , G , L , F , H , y , zpl , zmi , C2pl , C2mi nf = real ( n ) qf = real ( q ) sigma = 0.d0 m_loop : do m = 1 , m_max mf = real ( m ) if ( n . ge . m ) then sigma ( m ) = 0.d0 cycle m_loop endif etil = eb / ( 2 5.0 * qf ) hi = 2.0 ** ( 0.322 * ( 1.0 - sqrt ( 2.0 / qf ))) s = ( mf - nf ) D = exp ( - 1.0 / ( nf * mf * etil ** 2 )) A = 8.0 / ( 3.0 * s ) * ( mf / ( s * nf )) ** 3 * ( 0.184 - 0.04 / s ** ( 2.0 / 3.0 )) * & ( 1.0 - 0.2 * s / ( nf * mf )) ** ( 1.0 + 2.0 * s ) G = 0.5 * ( etil * nf ** 2.0 / ( mf - 1.0 / mf )) ** 3.0 L = log ( 1.0 + 0.53 * etil ** 2.0 * nf * ( mf - 2.0 / mf ) / ( 1.0 + 0.4 * etil )) F = ( 1.0 - 0.3 * s * D / ( nf * mf )) ** ( 1.0 + 2.0 * s ) y = 1.0 / ( 1.0 - D * log ( 18 * s ) / ( 4.0 * s )) zpl = 2.0 / ( etil * nf ** 2 * ( sqrt ( 2.0 - nf ** 2 / mf ** 2 ) + 1.0 )) zmi = 2.0 / ( etil * nf ** 2 * ( sqrt ( 2.0 - nf ** 2 / mf ** 2 ) - 1.0 )) C2pl = zpl ** 2 * log ( 1.0 + 2.0 * zpl / 3.0 ) / ( 2.0 * y + 3.0 * zpl / 2.0 ) C2mi = zmi ** 2 * log ( 1.0 + 2.0 * zmi / 3.0 ) / ( 2.0 * y + 3.0 * zmi / 2.0 ) H = C2mi - C2pl sigma ( m ) = q * hi * 8.86e-17 * nf ** 4 / etil * ( A * D * L + F * G * H ) enddo m_loop end function Aq_excit_n_janev function Aq_excit_n ( eb , q , n , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the `n` state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n, n \\gt 3  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the `n` state to the m'th state [cm&#94;2] select case ( n ) case ( 0 ) stop case ( 1 ) sigma = Aq_excit_1_janev ( eb , q , m_max ) case ( 2 ) sigma = Aq_excit_2_janev ( eb , q , m_max ) case ( 3 ) sigma = Aq_excit_3_janev ( eb , q , m_max ) case DEFAULT sigma = Aq_excit_n_janev ( eb , q , n , m_max ) end select end function Aq_excit_n function Aq_excit_n_m ( eb , q , n , m ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the `n`\\rightarrow`m` state due to a collision an ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m), q \\gt 3, m \\gt n  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = Aq_excit_n ( eb , q , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function Aq_excit_n_m function Aq_excit ( eb , q , n_max , m_max ) result ( sigma ) !+Calculates an matrix of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=1..`n_max` state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n_max !+ Number of n states to calculate integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts refers to !+an excitation from the `n` state to the m'th state: Aq_excit[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = Aq_excit_n ( eb , q , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function Aq_excit function d_d_fusion_t ( eb ) result ( sigma ) !+Calculates total cross section at a given Deuterium energy, `eb`, !+for the Tritium branch of Deuterium-Deutrium nuclear reactions !+ !+###Equation !+ D + D \\rightarrow T(1.01 MeV) + p(3.02 MeV) (50%) !+ !+###References !+* Equations 8-9 !+* Table IV in Ref. 7 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Deuterium energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 5 ), parameter :: A = [ 5.5576d4 , 2.1054d2 , & - 3.2638d-2 , 1.4987d-6 , & 1.8181d-10 ] real ( Float64 ), dimension ( 4 ), parameter :: B = [ 0.d0 , 0.d0 , 0.d0 , 0.d0 ] real ( Float64 ), parameter :: Bg = 3 1.3970 real ( Float64 ) :: S , E E = min ( max ( eb , 0.5 ), 500 0.0 ) S = ( A ( 1 ) + E * ( A ( 2 ) + E * ( A ( 3 ) + E * ( A ( 4 ) + E * A ( 5 ))))) / & ( 1 + E * ( B ( 1 ) + E * ( B ( 2 ) + E * ( B ( 3 ) + E * B ( 4 ))))) sigma = ( 1.0d-27 ) * ( S / ( E * exp ( Bg / sqrt ( E )))) end function d_d_fusion_t function d_d_fusion_he ( eb ) result ( sigma ) !+Calculates total cross section at a given deuterium energy, `eb`, !+for the Helium-3 branch of Deuterium-Deutrium nuclear reactions !+ !+###Equation !+ D + D \\rightarrow He&#94;3(0.82 MeV) + n(2.45 MeV) (50%) !+ !+###References !+* Equations 8-9 !+* Table IV in Ref. 7 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Deuterium energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 5 ), parameter :: A = [ 5.3701d4 , 3.3027d2 , & - 1.2706d-1 , 2.9327d-5 , & - 2.5151d-9 ] real ( Float64 ), dimension ( 4 ), parameter :: B = [ 0.d0 , 0.d0 , 0.d0 , 0.d0 ] real ( Float64 ), parameter :: Bg = 3 1.3970 real ( Float64 ) :: S , E E = min ( max ( eb , 0.5 ), 490 0.0 ) S = ( A ( 1 ) + E * ( A ( 2 ) + E * ( A ( 3 ) + E * ( A ( 4 ) + E * A ( 5 ))))) / & ( 1 + E * ( B ( 1 ) + E * ( B ( 2 ) + E * ( B ( 3 ) + E * B ( 4 ))))) sigma = ( 1.0d-27 ) * ( S / ( E * exp ( Bg / sqrt ( E )))) end function d_d_fusion_he function d_t_fusion ( eb ) result ( sigma ) !+Calculates total cross section at a given deuterium energy, `eb`, !+for Deuterium-Tritium nuclear reactions in the range [0.5-550 keV] !+ !+###Equation !+ D + T \\rightarrow He&#94;4(3.5 MeV) + n(14.1 MeV) !+ !+###References !+* Equations 8-9 !+* Table IV, VI in Ref. 7 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Deuterium energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 5 ), parameter :: A1 = [ 6.927d4 , 7.454d8 , & 2.050d6 , 5.2002d4 , & 0.d0 ] real ( Float64 ), dimension ( 4 ), parameter :: B1 = [ 6.38d1 , - 9.95d-1 , & 6.981d-5 , 1.728d-4 ] real ( Float64 ), dimension ( 5 ), parameter :: A2 = [ - 1.4714d6 , 0.d0 , & 0.d0 , 0.d0 , 0.d0 ] real ( Float64 ), dimension ( 4 ), parameter :: B2 = [ - 8.4127d-3 , 4.7983d-6 , & - 1.0748d-9 , 8.5184d-14 ] real ( Float64 ), parameter :: Bg = 3 4.3827 real ( Float64 ), dimension ( 5 ) :: A real ( Float64 ), dimension ( 4 ) :: B real ( Float64 ) :: S , E E = min ( max ( eb , 0.5 ), 470 0.0 ) if ( E . le . 53 0.0 ) then A = A1 B = B1 else A = A2 B = B2 endif S = ( A ( 1 ) + E * ( A ( 2 ) + E * ( A ( 3 ) + E * ( A ( 4 ) + E * A ( 5 ))))) / & ( 1 + E * ( B ( 1 ) + E * ( B ( 2 ) + E * ( B ( 3 ) + E * B ( 4 ))))) sigma = ( 1.0d-27 ) * ( S / ( E * exp ( Bg / sqrt ( E )))) end function d_t_fusion function simpsons_rule ( f , dx ) result ( I ) !+ Performs 1D integration using Simpsons rule !+ !+ ###References !+* [Simpson's rule](http://mathworld.wolfram.com/SimpsonsRule.html) real ( Float64 ), dimension (:), intent ( in ) :: f !+ Array of equally spaced f(x) values real ( Float64 ), intent ( in ) :: dx !+ Spacing between x values real ( Float64 ) :: I integer :: s , ii s = size ( f ) I = 0.d0 if ( mod ( s , 2 ). eq . 1 ) then write ( * , '(a)' ) \"Length of array must be even\" return endif I = f ( 1 ) do ii = 2 , s - 1 if ( mod ( ii , 2 ). eq . 1 ) then I = I + 4.0 * f ( ii ) else I = I + 2.0 * f ( ii ) endif enddo I = I + f ( s ) I = ( dx / 3.0 ) * I end function simpsons_rule subroutine bt_maxwellian_eb ( fn , T , eb , am , ab , rate ) !+ Calculates Maxwellian reaction rate for a beam with atomic mass `ab` and energy `eb` !+firing into a target with atomic mass `am` and temperature `T` which has a cross section given by the function `fn` interface function fn ( a ) !+Cross section function real ( 8 ) :: fn !sigma real ( 8 ), intent ( in ) :: a !eb end function fn end interface real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] integer :: n_vr real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( 32 ) :: vr real ( Float64 ), dimension ( 32 ) :: fr integer :: n_vz real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( 62 ) :: vz real ( Float64 ), dimension ( 62 ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , v_therm , dE integer :: i , j n_vr = 32 vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo n_vz = 62 vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 sig = fn ( erel ) fr ( j ) = sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm end subroutine bt_maxwellian_eb subroutine bt_maxwellian_n ( fn , T , eb , am , ab , n , rate ) !+ Calculates Maxwellian reaction rate for a beam with atomic mass `ab`, energy `eb`, and energy level `n` !+firing into a target with atomic mass `am` and temperature `T` which has a cross section given by the function `fn` interface function fn ( a , b ) !+Cross section function real ( 8 ) :: fn !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !n end function fn end interface real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] logical :: dxc integer :: n_vr real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( 32 ) :: vr real ( Float64 ), dimension ( 32 ) :: fr integer :: n_vz real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( 62 ) :: vz real ( Float64 ), dimension ( 62 ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , v_therm , dE integer :: i , j n_vr = 32 vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo n_vz = 62 vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) dE = ( 1 3.6d-3 ) / ( n ** 2.0 ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 !for electron interactions fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( erel . ge . dE ) then sig = fn ( erel / ared , n ) else sig = 0.d0 endif fr ( j ) = sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm end subroutine bt_maxwellian_n subroutine bt_maxwellian_q_n ( fqn , q , T , eb , am , ab , n , rate ) !+ Calculates Maxwellian reaction rate for a beam with atomic mass `ab`, energy `eb`, and energy level `n` !+firing into a target with atomic mass `am`, temperature `T`, and charge `q`  which has a cross section given by the function `fqn` interface function fqn ( a , b , c ) !+Cross section function real ( 8 ) :: fqn !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !q integer , intent ( in ) :: c !n end function fqn end interface integer , intent ( in ) :: q !+Target charge real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] integer :: n_vr real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( 32 ) :: vr real ( Float64 ), dimension ( 32 ) :: fr integer :: n_vz real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( 62 ) :: vz real ( Float64 ), dimension ( 62 ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , v_therm , dE integer :: i , j n_vr = 32 vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo n_vz = 62 vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) dE = ( 1 3.6d-3 ) / ( n ** 2.0 ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( erel . ge . dE ) then sig = fqn ( erel / ared , q , n ) else sig = 0.d0 endif fr ( j ) = sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm end subroutine bt_maxwellian_q_n subroutine bt_maxwellian_n_m ( fnm , T , eb , am , ab , n , m , rate , deexcit ) !+ Calculates Maxwellian reaction rate for a `n`\\rightarrow)`m` transition due to a beam with atomic mass `ab` and energy `eb` !+firing into a target with atomic mass `am` and temperature `T` which has a cross section given by the function `fnm` interface function fnm ( a , b , c ) !+Cross section function real ( 8 ) :: fnm !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !n integer , intent ( in ) :: c !m end function fnm end interface real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state integer , intent ( in ) :: m !+Final atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] logical , intent ( in ), optional :: deexcit !+Calculate de-excitation reaction rate logical :: dxc integer :: n_vr real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( 32 ) :: vr real ( Float64 ), dimension ( 32 ) :: fr integer :: n_vz real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( 62 ) :: vz real ( Float64 ), dimension ( 62 ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , dE , factor , En , Em , v_therm integer :: i , j if ( present ( deexcit )) then dxc = deexcit else dxc = . False . endif n_vr = 32 vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo n_vz = 62 vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo En = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / n ) ** 2.0 ) Em = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / m ) ** 2.0 ) dE = Em - En T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( dxc ) then factor = ( erel + dE ) / erel erel = erel + dE else factor = 1.0 endif if ( erel . ge . dE ) then sig = fnm ( erel / ared , n , m ) else sig = 0.d0 endif fr ( j ) = factor * sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm if ( dxc ) rate = rate * ( real ( n ) / real ( m )) ** 2.0 end subroutine bt_maxwellian_n_m subroutine bt_maxwellian_q_n_m ( fqnm , q , T , eb , am , ab , n , m , rate , deexcit ) !+ Calculates Maxwellian reaction rate for a `n`\\rightarrow)`m` transition due to a beam with atomic mass `ab` and energy `eb` !+firing into a target with atomic mass `am`, temperature `T`, and charge `q` which has a cross section given by the function `fqnm` interface function fqnm ( a , b , c , d ) !+Cross section function real ( 8 ) :: fqnm !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !q integer , intent ( in ) :: c !n integer , intent ( in ) :: d !m end function fqnm end interface integer , intent ( in ) :: q !+Target charge real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state integer , intent ( in ) :: m !+Final atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] logical , intent ( in ), optional :: deexcit !+Calculate de-excitation reaction rate logical :: dxc integer :: n_vr real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( 32 ) :: vr real ( Float64 ), dimension ( 32 ) :: fr integer :: n_vz real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( 62 ) :: vz real ( Float64 ), dimension ( 62 ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , dE , factor , En , Em , v_therm integer :: i , j if ( present ( deexcit )) then dxc = deexcit else dxc = . False . endif n_vr = 32 vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo n_vz = 62 vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo En = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / n ) ** 2.0 ) Em = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / m ) ** 2.0 ) dE = Em - En T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( dxc ) then factor = ( erel + dE ) / erel erel = erel + dE else factor = 1.0 endif if ( erel . ge . dE ) then sig = fqnm ( erel / ared , q , n , m ) else sig = 0.d0 endif fr ( j ) = factor * sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm if ( dxc ) rate = rate * ( real ( n ) / real ( m )) ** 2.0 end subroutine bt_maxwellian_q_n_m subroutine write_einstein ( id , n_max , m_max ) !+ Write Einstein coefficients to HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate real ( Float64 ), dimension ( n_max , m_max ) :: ein integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: error ein (:,:) = EINSTEIN ( 1 : n_max , 1 : m_max ) call h5gcreate_f ( id , \"spontaneous\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , m_max ] call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_compressed_dataset_double_f ( gid , \"einstein\" , 2 , dim2 , ein , error ) call h5ltset_attribute_string_f ( id , \"spontaneous\" , \"description\" , & \"Atomic rates for spontaneous emission/deexcitation\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"description\" , & \"n/m resolved einstein coefficients: einstein(n,m)\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"units\" , \"1/s\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"reaction\" , & \"H(n) -> H(m) + ph, n > m\" , error ) call h5gclose_f ( gid , error ) end subroutine write_einstein subroutine write_bb_H_H ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Hydrogen interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:), allocatable :: cx , excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: i , cnt , error logical :: exis NAMELIST / H_H_cross / nenergy , emin , emax nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_H: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_H_cross ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( cx ( n_max , m_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 write ( * , '(a)' ) \"---- H-H cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = 1 , nenergy eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb cx (:,:, i ) = p_cx ( eb , n_max , m_max ) excit (:,:, i ) = p_excit ( eb , n_max , m_max ) ioniz (:, i ) = p_ioniz ( eb , n_max ) cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"H_H\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 3 , dim3 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_H\" , \"description\" , & \"Cross sections for Hydrogen-Hydrogen interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n/m resolved charge exchange cross sections: cx(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"H(+) + H(n) -> H(m) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , cx , excit , ioniz ) end subroutine write_bb_H_H subroutine write_bb_H_e ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Electron interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: i , cnt , error logical :: exis NAMELIST / H_e_cross / nenergy , emin , emax nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_E: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_e_cross ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0.d0 ioniz = 0.d0 excit = 0.d0 write ( * , '(a)' ) \"---- H-e cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = 1 , nenergy eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb excit (:,:, i ) = e_excit ( eb , n_max , m_max ) ioniz (:, i ) = e_ioniz ( eb , n_max ) cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"H_e\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_e\" , \"description\" , & \"Cross sections for Hydrogen-Electron interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum Energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum Energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"e- + H(n) -> e- + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"e- + H(n) -> e- + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , ioniz , excit ) end subroutine write_bb_H_e subroutine write_bb_H_Aq ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Impurity interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate integer :: q real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: cx , ioniz real ( Float64 ), dimension (:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 character ( len = 10 ) :: aname character ( len = 5 ) :: asym integer :: i , cnt , error logical :: exis NAMELIST / H_Aq_cross / q , nenergy , emin , emax nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 q = 6 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_Aq: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_Aq_cross ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( cx ( n_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 select case ( q ) case ( 5 ) aname = \"Boron\" asym = \"H_B5\" case ( 6 ) aname = \"Carbon\" asym = \"H_C6\" case DEFAULT aname = \"Impurity\" asym = \"H_Aq\" end select write ( * , '(a)' ) \"---- H-\" // trim ( adjustl ( aname )) // \" cross sections settings ----\" write ( * , '(T2,\"q = \", i2)' ), q write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = 1 , nenergy eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb cx (:, i ) = Aq_cx ( eb , q , n_max ) ioniz (:, i ) = Aq_ioniz ( eb , q , n_max ) excit (:,:, i ) = Aq_excit ( eb , q , n_max , m_max ) cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy ), char ( 13 ) enddo call h5gcreate_f ( id , trim ( adjustl ( asym )), gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 2 , dim2 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , trim ( adjustl ( asym )), \"description\" , & \"Cross sections for Hydrogen-\" // trim ( adjustl ( aname )) // \" interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n resolved charge exchange / electron capture cross sections: cx(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"A(q+) + H(n) -> A((q-1)+) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , ioniz , cx , excit ) end subroutine write_bb_H_Aq subroutine write_bb_D_D ( id , namelist_file ) !+ Write Deuterium-Deuterium interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer :: nbranch = 2 real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: i , cnt , error logical :: exis NAMELIST / D_D_cross / nenergy , emin , emax nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_D_D: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_D_cross ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( fusion ( nenergy , nbranch )) ebarr = 0.d0 fusion = 0.d0 write ( * , '(a)' ) \"---- D-D cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = 1 , nenergy eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb fusion ( i , 1 ) = d_d_fusion_t ( eb ) fusion ( i , 2 ) = d_d_fusion_he ( eb ) cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"D_D\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] dim2 = [ nenergy , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 2 , dim2 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_D\" , \"description\" , & \"Cross sections for Deuterium-Deuterium interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Deuterium energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Cross sections for the Tritium[1] and He3[2] branches of D-D nuclear reactions: fusion(energy, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + D -> [1] T(1.01 MeV) + p(3.02 MeV) (50%); [2] He3(0.82 MeV) + n(2.45 MeV) (50%)\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , fusion ) end subroutine write_bb_D_D subroutine write_bb_D_T ( id , namelist_file ) !+ Write Deuterium-Tritium interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer :: nbranch = 1 real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: i , cnt , error logical :: exis NAMELIST / D_T_cross / nenergy , emin , emax nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_D_T: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_T_cross ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( fusion ( nenergy , nbranch )) ebarr = 0.d0 fusion = 0.d0 write ( * , '(a)' ) \"---- D-T cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = 1 , nenergy eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb fusion ( i , 1 ) = d_t_fusion ( eb ) cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"D_T\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] dim2 = [ nenergy , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 2 , dim2 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_T\" , \"description\" , & \"Cross sections for Deuterium-Tritium interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Deuterium energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Total cross sections for D-T nuclear reactions: fusion(deuterium energy, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + T -> He4(3.5 MeV) + n(14.1 MeV)\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , fusion ) end subroutine write_bb_D_T subroutine write_bt_H_H ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Hydrogen reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit , cx integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 4 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a logical :: exis NAMELIST / H_H_rates / nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_H: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_H_rates ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( cx ( n_max , m_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) ebarr = 0.d0 tarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 a (:, 1 ) = [ H1_amu , H1_amu ] a (:, 2 ) = [ H1_amu , H2_amu ] a (:, 3 ) = [ H2_amu , H1_amu ] a (:, 4 ) = [ H2_amu , H2_amu ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo write ( * , '(a)' ) \"---- H-H reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = 1 , nenergy eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max call bt_maxwellian ( p_cx_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) cx ( n , m , ie , it , ia ) = rate if ( m . gt . n ) then call bt_maxwellian ( p_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( p_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( p_ioniz_n , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"H_H\" , gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 5 , dim5 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_H\" , \"description\" , & \"Beam-Target reaction rates for Hydrogen(beam)-Hydrogen(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n/m resolved charge exchange reaction rates: cx(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"H(+) + H(n) -> H(m) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , tarr , cx , excit , ioniz ) end subroutine write_bt_H_H subroutine write_bt_H_e ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Electron reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 2 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a logical :: exis NAMELIST / H_e_rates / nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_E: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_e_rates ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) ebarr = 0.d0 ioniz = 0.d0 excit = 0.d0 a (:, 1 ) = [ H1_amu , e_amu ] a (:, 2 ) = [ H2_amu , e_amu ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo write ( * , '(a)' ) \"---- H-e reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = 1 , nenergy eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max if ( m . gt . n ) then call bt_maxwellian ( e_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( e_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( e_ioniz_n , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"H_e\" , gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_e\" , \"description\" , & \"Beam-Target reaction rates for Hydrogen(beam)-Electron(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"e- + H(n) -> e- + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"e- + H(n) -> e- + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , tarr , excit , ioniz ) end subroutine write_bt_H_e subroutine write_bt_H_Aq ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Impurity reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate integer :: q real ( Float64 ) :: mass real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz , cx real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 2 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a character ( len = 10 ) :: aname character ( len = 5 ) :: asym logical :: exis NAMELIST / H_Aq_rates / q , mass , nenergy , emin , emax , ntemp , tmin , tmax q = 6 ; mass = C_amu nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_Aq: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_Aq_rates ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( cx ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) select case ( q ) case ( 5 ) aname = \"Boron\" asym = \"H_B5\" case ( 6 ) aname = \"Carbon\" asym = \"H_C6\" case DEFAULT aname = \"Impurity\" asym = \"H_Aq\" end select ebarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 a (:, 1 ) = [ H1_amu , mass ] a (:, 2 ) = [ H2_amu , mass ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo write ( * , '(a)' ) \"---- H-\" // trim ( adjustl ( aname )) // \" reaction rates settings ----\" write ( * , '(T2,\"q = \", i2)' ), q write ( * , '(T2,\"mass = \",f7.2, \" amu\")' ) mass write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = 1 , nenergy eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max if ( m . gt . n ) then call bt_maxwellian ( Aq_excit_n_m , q , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( Aq_excit_n_m , q , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( Aq_cx_n , q , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) cx ( n , ie , it , ia ) = rate call bt_maxwellian ( Aq_ioniz_n , q , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , trim ( adjustl ( asym )), gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 4 , dim4 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , trim ( adjustl ( asym )), \"description\" , & \"Beam-Target reaction rates for Hydrogen(beam)-\" // trim ( adjustl ( aname )) // & \"(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n-resolved charge exchange reaction rates: cx(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"A(q+) + H(n) -> A((q-1)+) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , tarr , excit , ioniz ) end subroutine write_bt_H_Aq subroutine write_bt_D_D ( id , namelist_file ) !+ Write Deuterium-Deuterium reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer :: nbranch = 2 real ( Float64 ), dimension ( 2 ) :: bt_amu = [ H2_amu , H2_amu ] real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: ie , it , error , cnt real ( Float64 ) :: rate_a , rate_b logical :: exis NAMELIST / D_D_rates / nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_D_D: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_D_rates ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( fusion ( nenergy , ntemp , nbranch )) ebarr = 0.d0 tarr = 0.d0 fusion = 0.d0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo write ( * , '(a)' ) \"---- D-D reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' cnt = 0 !$OMP PARALLEL DO private(ie, it, eb, ti, rate_a, rate_b) do ie = 1 , nenergy eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) call bt_maxwellian ( d_d_fusion_t , ti , eb , bt_amu ( 1 ), bt_amu ( 2 ), rate_a ) call bt_maxwellian ( d_d_fusion_he , ti , eb , bt_amu ( 2 ), bt_amu ( 2 ), rate_b ) fusion ( ie , it , 1 ) = rate_a fusion ( ie , it , 2 ) = rate_b cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"D_D\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim1 = [ 2 ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 1 , dim1 , bt_amu , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) dim3 = [ nenergy , ntemp , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 3 , dim3 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_D\" , \"description\" , & \"Beam-Target reaction rates for Deuterium(beam)-Deuterium(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Isotope mass of the beam and target species respectively\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"units\" , \"amu\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Beam-Target reaction rates for T/He3 branches of D-D nuclear reactions: fusion(energy, temp, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + D -> [1] T(1.01 MeV) + p(3.02 MeV) (50%); [2] He3(0.82 MeV) + n(2.45 MeV) (50%)\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , tarr , fusion ) end subroutine write_bt_D_D subroutine write_bt_D_T ( id , namelist_file ) !+ Write Deuterium-Tritium reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer :: nbranch = 1 real ( Float64 ), dimension ( 2 ) :: bt_amu = [ H2_amu , H3_amu ] real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: ie , it , error , cnt real ( Float64 ) :: rate logical :: exis NAMELIST / D_T_rates / nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_D_T: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_T_rates ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( fusion ( nenergy , ntemp , nbranch )) ebarr = 0.d0 tarr = 0.d0 fusion = 0.d0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo write ( * , '(a)' ) \"---- D-T reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' cnt = 0 !$OMP PARALLEL DO private(ie, it, eb, ti, rate) do ie = 1 , nenergy eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) call bt_maxwellian ( d_t_fusion , ti , eb , bt_amu ( 1 ), bt_amu ( 2 ), rate ) fusion ( ie , it , 1 ) = rate cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"D_T\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim1 = [ 2 ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 1 , dim1 , bt_amu , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) dim3 = [ nenergy , ntemp , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 3 , dim3 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_T\" , \"description\" , & \"Beam-Target reaction rates for Deuterium(beam)-Tritium(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Isotope mass of the beam and target species respectively\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"units\" , \"amu\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Beam-Target reaction rates for D-T nuclear reactions: fusion(energy, temperature, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + T -> He4(3.5 MeV) + n(14.1 MeV)\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , tarr , fusion ) end subroutine write_bt_D_T subroutine print_default_namelist !+ Prints out the default settings as a namelist write ( * , '(a)' ) \"!Default Atomic Table Settings\" write ( * , '(a)' ) \"&general_settings\" write ( * , '(a)' ) \"n_max = 12,    !Number of initial atomic energy levels\" write ( * , '(a)' ) \"m_max = 12,    !Number of final atomic energy levels\" write ( * , '(a)' ) \"tables_file = './atomic_tables.h5'\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Hydrogen Cross Sections\" write ( * , '(a)' ) \"&H_H_cross\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Electron Cross Sections\" write ( * , '(a)' ) \"&H_e_cross\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Impurity Cross Sections\" write ( * , '(a)' ) \"&H_Aq_cross\" write ( * , '(a)' ) \"q = 6,         !Impurity charge: Boron: 5, Carbon: 6, ...\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Deuterium-Deuterium Nuclear Cross Sections\" write ( * , '(a)' ) \"&D_D_cross\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Hydrogen Reaction Rates\" write ( * , '(a)' ) \"&H_H_rates\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum ion temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum ion temperature [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Electron Reaction Rates\" write ( * , '(a)' ) \"&H_e_rates\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum electron temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum electron temperature [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Impurity Reaction Rates\" write ( * , '(a)' ) \"&H_Aq_rates\" write ( * , '(a)' ) \"q = 6,         !Impurity charge: Boron: 5, Carbon: 6, ...\" write ( * , '(a)' ) \"mass = 12.011, !Impurity mass [amu]\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum ion temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum ion temperature [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Deuterium-Deuterium Nuclear Reaction Rates\" write ( * , '(a)' ) \"&D_D_rates\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum deuterium temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum deuterium temperature [keV]\" write ( * , '(a)' ) \"/\" end subroutine print_default_namelist end module atomic_tables program generate_tables !+ Tabulates cross sections and reaction rates and writes them to a HDF5 file use atomic_tables use H5LT use HDF5 use hdf5_extra #ifdef _OMP use omp_lib #endif character ( len = 200 ) :: namelist_file character ( len = 3 ) :: arg character ( len = 200 ) :: tables_file = '' integer :: n_max , m_max integer , dimension ( 8 ) :: time_arr , time_start , time_end integer :: hour , minu , sec integer :: argc , max_threads , nthreads integer ( HID_T ) :: fid , gid integer :: error logical :: exis NAMELIST / general_settings / n_max , m_max , tables_file argc = command_argument_count () if ( argc . eq . 0 ) then call print_default_namelist () stop endif if ( argc . ge . 1 ) then call get_command_argument ( 1 , namelist_file ) endif inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'Input file does not exist: ' , trim ( namelist_file ) stop else open ( 13 , file = namelist_file ) read ( 13 , NML = general_settings ) close ( 13 ) n_max = min ( n_max , 15 ) m_max = min ( m_max , 15 ) endif write ( * , '(a)' ) \"---- General settings ----\" write ( * , '(T2,\"n_max = \",i2)' ) n_max write ( * , '(T2,\"m_max = \",i2)' ) m_max write ( * , '(T2,\"Tables File: \",a)' ) trim ( tables_file ) write ( * , * ) '' #ifdef _OMP max_threads = OMP_get_num_procs () if ( argc . ge . 2 ) then call get_command_argument ( 2 , arg ) read ( arg , '(i3)' ) nthreads else nthreads = max_threads endif max_threads = min ( nthreads , max_threads ) write ( * , '(a)' ) \"---- OpenMP settings ----\" write ( * , '(T2,\"Number of threads: \",i2)' ) max_threads write ( * , * ) '' call OMP_set_num_threads ( max_threads ) #endif !! Check if compression is possible call check_compression_availability () call date_and_time ( values = time_start ) !! Open HDF5 Interface call h5open_f ( error ) !! Create tables file. Overwrites if already exists call h5fcreate_f ( tables_file , H5F_ACC_TRUNC_F , fid , error ) !! Create group for cross sections call h5gcreate_f ( fid , \"cross\" , gid , error ) !! Calculate cross sections call date_and_time ( values = time_arr ) write ( * , \"(A,I2,A,I2.2,A,I2.2)\" ) 'Cross Sections:   ' , time_arr ( 5 ), ':' , time_arr ( 6 ), ':' , time_arr ( 7 ) call write_bb_H_H ( gid , namelist_file , n_max , m_max ) call write_bb_H_e ( gid , namelist_file , n_max , m_max ) call write_bb_H_Aq ( gid , namelist_file , n_max , m_max ) call write_bb_D_D ( gid , namelist_file ) !! Close cross section group call h5gclose_f ( gid , error ) !! Create group for reaction rates call h5gcreate_f ( fid , \"rates\" , gid , error ) !! Calculate reaction rates call date_and_time ( values = time_arr ) write ( * , \"(A,I2,A,I2.2,A,I2.2)\" ) 'Reaction Rates:   ' , time_arr ( 5 ), ':' , time_arr ( 6 ), ':' , time_arr ( 7 ) call write_bt_H_H ( gid , namelist_file , n_max , m_max ) call write_bt_H_e ( gid , namelist_file , n_max , m_max ) call write_bt_H_Aq ( gid , namelist_file , n_max , m_max ) call write_einstein ( gid , n_max , m_max ) call write_bt_D_D ( gid , namelist_file ) !! Close reaction rates group call h5gclose_f ( gid , error ) !! Add group attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Atomic Cross Sections and Rates\" , error ) call h5ltset_attribute_string_f ( fid , \"cross\" , \"description\" , & \"Atomic Cross Sections\" , error ) call h5ltset_attribute_string_f ( fid , \"rates\" , \"description\" , & \"Atomic Reaction Rates\" , error ) !! Close file and HDF5 interface call h5fclose_f ( fid , error ) call h5close_f ( error ) write ( * , '(a)' ) \"Atomic tables written to \" // trim ( tables_file ) write ( * , * ) '' call date_and_time ( values = time_arr ) write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'END: hour, minute, second: ' , time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) call date_and_time ( values = time_end ) hour = time_end ( 5 ) - time_start ( 5 ) minu = time_end ( 6 ) - time_start ( 6 ) sec = time_end ( 7 ) - time_start ( 7 ) if ( minu . lt . 0. ) then minu = minu + 60 hour = hour - 1 endif if ( sec . lt . 0. ) then sec = sec + 60 minu = minu - 1 endif write ( * , '(A,18X,I2,\":\",I2.2,\":\",I2.2)' ) 'duration:' , hour , minu , sec end program","tags":"","loc":"sourcefile/atomic_tables.f90.html","title":"atomic_tables.f90 – FIDASIM"},{"text":"aabb_intersect Calculates intersection length of a ray and an axis aligned bounding box (AABB) Input Arguments rc : Center of AABB dr : [length, width, height] of AABB r0 : starting point of ray d0 : direction of ray Output Arguments intersect : Intersection length of ray and AABB ri : Optional, ray enterence point rf : Optional, ray exit point Example Usage IDL > aabb_intersect, [ 0 , 0 , 0 ], [ 1 , 1 , 1 ], [ - 1 , 0 , 0 ], [ 1 , 0 , 0 ], intersect, ri, rf\nIDL > print , intersect 1.0 IDL > print , ri - 0.5 0.0 0.0 IDL > print , rf 0.5 0.0 0.0 Source Code aabb_intersect.pro Source Code PRO aabb_intersect , rc , dr , r0 , d0 , intersect , r_enter , r_exit ; +#aabb_intersect ; + Calculates intersection length of a ray and an axis aligned bounding box ( AABB ) ; +*** ; +## Input Arguments ; + **rc**: Center of AABB ; + ; + **dr**: [ length , width , height ] of AABB ; + ; + **r0**: starting point of ray ; + ; + **d0**: direction of ray ; + ; +## Output Arguments ; + **intersect**: Intersection length of ray and AABB ; + ; + **ri**: Optional , ray enterence point ; + ; + **rf**: Optional , ray exit point ; + ; +## Example Usage ; + ``` idl ; + IDL > aabb_intersect , [ 0 , 0 , 0 ], [ 1 , 1 , 1 ], [ - 1 , 0 , 0 ], [ 1 , 0 , 0 ], intersect , ri , rf ; + IDL > print , intersect ; + 1.0 ; + IDL > print , ri ; + - 0.5 0.0 0.0 ; + IDL > print , rf ; + 0.5 0.0 0.0 ; + ``` v0 = d0 / sqrt ( total ( d0 * d0 )) ;; There are 6 sides to a cube / grid side_inter = dblarr ( 6 ) ;; Intersection points of ray with planes defined by grid ipnts = dblarr ( 3 , 6 ) ;; Find whether ray intersects each side for i = 0 L , 5 do begin j = fix ( floor ( i / 2 )) ind = where ([ 0 , 1 , 2 ] ne j ) if abs ( v0 [ j ]) gt 0 then begin ;; Intersection point with plane ipnts [ * , i ] = r0 + v0* ( ( ( rc [ j ] + ( ( i mod 2 ) - 0.5 ) * dr [ j ] ) - r0 [ j ]) / v0 [ j ] ) ;; Check if point on plane is within grid side if abs ( ipnts [ ind [ 0 ], i ] - rc [ ind [ 0 ]]) le 0.5 * dr [ ind [ 0 ]] and $ abs ( ipnts [ ind [ 1 ], i ] - rc [ ind [ 1 ]]) le 0.5 * dr [ ind [ 1 ]] then side_inter [ i ] = 1 endif endfor intersect = 0.0 r_enter = r0 r_exit = r0 w = where ( side_inter ne 0 , nw ) if nw ge 2 then begin ;; Find two unique intersection points nunique = 0 for i = 0 , nw - 2 do begin if total ( ipnts [ * , w [ 0 ]] eq ipnts [ * , w [ i + 1 ]]) ne 3 then begin w = [ w [ 0 ], w [ i + 1 ]] nunique = 2 break end end if nunique eq 2 then begin vi = ipnts [ * , w [ 1 ]] - ipnts [ * , w [ 0 ]] vi = vi / sqrt ( total ( vi * vi )) dot_prod = total ( v0 * vi ) if dot_prod gt 0.0 then begin r_enter = ipnts [ * , w [ 0 ]] r_exit = ipnts [ * , w [ 1 ]] endif else begin r_enter = ipnts [ * , w [ 1 ]] r_exit = ipnts [ * , w [ 0 ]] endelse ;; Calculate intersection length intersect = sqrt ( total (( r_exit - r_enter ) &#94; 2.0 )) endif endif END","tags":"","loc":"sourcefile/aabb_intersect.pro.html","title":"aabb_intersect.pro – FIDASIM"},{"text":"beam_grid Calculates settings for a grid that aligns with the neutral beam. Arguments nbi : Neutral beam geometry structure rstart : Radial start position of beam grid [cm] Keyword Arguments dV : Cell volume [cm&#94;3]: Defaults to 8.0 nx : Number of cells in length: Default determined by dV ny : Number of cells in width: Default determined by dV nz : Number of cells in height: Default determined by dV length : Length of grid along beam sightline. [cm]: Defaults to 100 cm width : Width of grid [cm]: Defaults to 50 cm height : Height of grid [cm]: Defaults to 50 cm Return Value Structure containing beam grid settings suitable for the Namelist File Example Usage IDL > grid = beam_grid(nbi, 200.0 ,nx = 100 ,ny = 50 ,nz = 50 ,length = 100 ,width = 50 ,height = 50 ) Source Code beam_grid.pro Source Code FUNCTION beam_grid , nbi , rstart , $ nx = nx , ny = ny , nz = nz , dv = dv , $ length = length , width = width , height = height ; +#beam_grid ; + Calculates settings for a grid that aligns with the neutral beam . ; +*** ; +## Arguments ; + **nbi**: [ Neutral beam geometry structure ](| url | / page / 03 _ technical / 01 _ prefida_inputs . html#neutral - beam - geometry - structure ) ; + ; + **rstart**: Radial start position of beam grid [ cm ] ; + ; +## Keyword Arguments ; + **dV**: Cell volume [ \\ ( cm&#94; 3 \\ )] : Defaults to 8.0 ; + ; + **nx**: Number of cells in length : Default determined by ` dV ` ; + ; + **ny**: Number of cells in width : Default determined by ` dV ` ; + ; + **nz**: Number of cells in height : Default determined by ` dV ` ; + ; + **length**: Length of grid along beam sightline . [ cm ] : Defaults to 100 cm ; + ; + **width**: Width of grid [ cm ] : Defaults to 50 cm ; + ; + **height**: Height of grid [ cm ] : Defaults to 50 cm ; + ; +## Return Value ; + Structure containing beam grid settings suitable for the Namelist File ; + ; +## Example Usage ; + ``` idl ; + IDL > grid = beam_grid ( nbi , 200.0 , nx = 100 , ny = 50 , nz = 50 , length = 100 , width = 50 , height = 50 ) ; + ``` beam_grid = { err : 1 } if not keyword_set ( length ) then length = 100.0 ; cm if not keyword_set ( width ) then width = 80.0 ; cm if width lt nbi . widy then begin warning , \"Grid width is smaller then the source width\" print , \"width: \" , width print , \"source width: \" , nbi . widy endif if not keyword_set ( height ) then height = 80.0 ; cm if height lt nbi . widz then begin warning , \"Grid height is smaller then the source height\" print , \"height: \" , height print , \"source height: \" , nbi . widz endif if not keyword_set ( dv ) then dv = 8.0 ; cm&#94; 3 dv3 = dv&#94; ( 1.0 / 3.0 ) if not keyword_set ( nx ) then nx = round ( length / dv3 ) if not keyword_set ( ny ) then ny = round ( width / dv3 ) if not keyword_set ( nz ) then nz = round ( height / dv3 ) xmin = 0. d0 xmax = double ( length ) ymin = - width / 2. d0 ymax = width / 2. d0 zmin = - height / 2. d0 zmax = height / 2. d0 src = nbi . src axis = nbi . axis / sqrt ( total ( nbi . axis&#94; 2 )) pos = src + 100 * axis rsrc = sqrt ( src [ 0 ] &#94; 2 + src [ 1 ] &#94; 2 ) if sqrt ( src [ 0 ] &#94; 2 + src [ 1 ] &#94; 2 ) lt rstart then begin error , \"Source radius cannot be less then rstart\" goto , GET_OUT endif dis = sqrt ( total (( src - pos ) &#94; 2.0 )) beta = double ( asin (( src [ 2 ] - pos [ 2 ]) / dis )) alpha = double ( atan (( pos [ 1 ] - src [ 1 ]),( pos [ 0 ] - src [ 0 ]))) gamma = 0. d0 a = axis [ 0 ] &#94; 2 + axis [ 1 ] &#94; 2 b = 2 * ( src [ 0 ] * axis [ 0 ] + src [ 1 ] * axis [ 1 ]) c = src [ 0 ] &#94; 2 + src [ 1 ] &#94; 2 - rstart&#94; 2 t = ( - b - sqrt ( b&#94; 2 - 4 * a * c )) / ( 2 * a ) origin = src + t * axis beam_grid = { nx : fix ( nx ), ny : fix ( ny ), nz : fix ( nz ), $ xmin : xmin , xmax : xmax , $ ymin : ymin , ymax : ymax , $ zmin : zmin , zmax : zmax , $ alpha : alpha , beta : beta , gamma : gamma , $ origin : origin } GET_OUT : return , beam_grid END","tags":"","loc":"sourcefile/beam_grid.pro.html","title":"beam_grid.pro – FIDASIM"},{"text":"check_beam Checks if neutral beam geometry structure is valid Input Arguments inputs : input structure nbi : neutral beam geometry structure Example Usage IDL > check_beam, inputs, nbi Source Code check_beam.pro Source Code PRO check_beam , inp , nbi ; +#check_beam ; + Checks if neutral beam geometry structure is valid ; +*** ; +## Input Arguments ; + **inputs**: input structure ; + ; + **nbi**: neutral beam geometry structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_beam , inputs , nbi ; + ``` err_status = 0 info , 'Checking beam geometry...' na = nbi . naperture zero_string = { dims : 0 , type : 'STRING' } zero_int = { dims : 0 , type : 'INT' } zero_double = { dims : 0 , type : 'DOUBLE' } three_double = { dims :[ 3 ], type : 'DOUBLE' } na_double = { dims :[ na ], type : 'DOUBLE' } na_int = { dims :[ na ], type : 'INT' } schema = { data_source:zero_string , $ name : zero_string , shape : zero_int , $ src : three_double , axis : three_double , $ divy : three_double , divz : three_double , $ focy : zero_double , focz : zero_double , $ widz : zero_double , widy : zero_double , $ naperture : zero_int , ashape : na_int , $ awidy : na_double , awidz : na_double , $ aoffy : na_double , aoffz : na_double , $ adist : na_double } check_struct_schema , schema , nbi , err_status , desc= \"beam geometry\" if err_status eq 1 then begin goto , GET_OUT endif if abs ( total ( nbi . axis&#94; 2.0 ) - 1.0 ) gt 1 d - 5 then begin error , 'Invalid source axis. Expected norm(axis) == 1' err_status = 1 endif if nbi . focz le 0.0 then begin error , 'focz cannot be in the range (-Inf,0.0]' err_status = 1 endif if nbi . focy le 0.0 then begin error , 'focy cannot be in the range (-Inf,0.0]' err_status = 1 endif if nbi . shape gt 2 or nbi . shape eq 0 then begin error , 'Invalid source shape. Expected 1 (rectagular) or 2 (circular)' err_status = 1 endif if nbi . widz lt 0 then begin error , 'Invalid widz. Expected widz > 0' err_status = 1 endif if nbi . widy lt 0 then begin error , 'Invalid widy. Expected widy > 0' err_status = 1 endif w = where ( nbi . ashape gt 2 or nbi . ashape eq 0 , nw ) if nw gt 0 then begin error , 'Invalid aperture shape. Expected 1 (rectangular) or 2 (circular)' err_status = 1 endif w = where ( nbi . awidy lt 0 , nw ) if nw gt 0 then begin error , 'Invalid awidy. Expected awidy >= 0.0' err_status = 1 endif w = where ( nbi . awidz lt 0 , nw ) if nw gt 0 then begin error , 'Invalid awidz. Expected awidz >= 0.0' err_status = 1 endif origin = inp . origin uvw_src = nbi . src uvw_axis = nbi . axis uvw_pos = uvw_src + nbi . adist [ 0 ] * uvw_axis xyz_src = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma , uvw_src , origin = origin ) xyz_axis = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma , uvw_axis ) xyz_pos = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma , uvw_pos , origin = origin ) xyz_center = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma ,[ 0.0 , 0.0 , 0.0 ], origin = origin ) dis = sqrt ( total (( xyz_src - xyz_pos ) &#94; 2.0 )) BETA = double ( asin (( xyz_src [ 2 ] - xyz_pos [ 2 ]) / dis )) ALPHA = double ( atan (( xyz_pos [ 1 ] - xyz_src [ 1 ]),( xyz_pos [ 0 ] - xyz_src [ 0 ]))) print , 'Beam injection start point in machine coordinates' print , f='(\"    [\",F9.3,\",\",F9.3,\",\",F9.3,\"]\")' , uvw_src print , 'First aperture position in machine coordinates' print , f='(\"    [\",F9.3,\",\",F9.3,\",\",F9.3,\"]\")' , uvw_pos print , 'Machine center in beam grid coordinates' print , f='(\"    [\",F9.3,\",\",F9.3,\",\",F9.3,\"]\")' , xyz_center print , 'Beam injection start point in beam grid coordinates' print , f='(\"    [\",F9.3,\",\",F9.3,\",\",F9.3,\"]\")' , xyz_src print , 'First aperture position in beam grid coordinates' print , f='(\"    [\",F9.3,\",\",F9.3,\",\",F9.3,\"]\")' , xyz_pos print , 'Beam grid rotation angles that would align it with the beam centerline' print , ALPHA / ! DPI * 180 , FORMAT ='(\"    alpha = \",F14.10,\"°\")' print , BETA / ! DPI * 180 , FORMAT ='(\"    beta = \",F14.10,\"°\")' ;; Calculate grid center rc and sides length dr dr = [ inp . xmax - inp . xmin , inp . ymax - inp . ymin , inp . zmax - inp . zmin ] rc = [ inp . xmin , inp . ymin , inp . zmin ] + 0.5 * dr ;; Check if beam centerline intersects beam grid aabb_intersect , rc , dr , xyz_src , xyz_axis , length , r_enter , r_exit print , 'Beam centerline - grid intersection length' print , f='(\"    length = \",F8.3)' , length if length le 10.0 then begin error , 'Beam centerline does not intersect grid' err_status = 1 endif GET_OUT : if err_status ne 0 then begin error , 'Invalid beam geometry. Exiting...' , / halt endif else begin success , 'Beam geometry is valid' endelse END","tags":"","loc":"sourcefile/check_beam.pro.html","title":"check_beam.pro – FIDASIM"},{"text":"check_distribution Checks if distribution structure is valid Input Arguments inputs : Input structure grid : Interpolation grid structure dist : Fast-ion distribution structure Example Usage IDL > check_distribution, inputs, grid, dist Source Code check_distribution.pro Source Code PRO check_distribution , inp , grid , dist ; +#check_distribution ; + Checks if distribution structure is valid ; +*** ; +## Input Arguments ; + **inputs**: Input structure ; + ; + **grid**: Interpolation grid structure ; + ; + **dist**: Fast - ion distribution structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_distribution , inputs , grid , dist ; + ``` err_status = 0 info , 'Checking fast-ion distribution' w = where ( \"type\" eq strlowcase ( TAG_names ( dist )), nw ) if nw eq 0 then begin error , '\"type\" is missing from the fast-ion distribution' err_status = 1 goto , GET_OUT endif dist_type = dist . type CASE dist_type OF 1 : BEGIN print , 'Using a Guiding Center Fast-ion Density Function' w = where ( \"nenergy\" eq strlowcase ( TAG_names ( dist )), nw ) if nw eq 0 then begin error , '\"nenergy\" is missing from the fast-ion distribution' err_status = 1 goto , GET_OUT endif w = where ( \"npitch\" eq strlowcase ( TAG_names ( dist )), nw ) if nw eq 0 then begin error , '\"npitch\" is missing from the fast-ion distribution' err_status = 1 goto , GET_OUT endif np = dist . npitch nen = dist . nenergy nr = grid . nr nz = grid . nz zero_string = { dims : 0 , type : 'STRING' } zero_int = { dims : 0 , type : 'INT' } zero_double = { dims : 0 , type : 'DOUBLE' } nrnz_double = { dims :[ nr , nz ], type : 'DOUBLE' } schema = { type : zero_int , $ nenergy : zero_int , $ npitch : zero_int , $ energy :{ dims :[ nen ], type : 'DOUBLE' }, $ pitch :{ dims :[ np ], type : 'DOUBLE' }, $ denf : nrnz_double , $ f :{ dims :[ nen , np , nr , nz ], type : 'DOUBLE' }, $ time : zero_double , $ data_source:zero_string } check_struct_schema , schema , dist , err_status , desc= \"fast-ion distribution\" if err_status eq 1 then begin goto , GET_OUT endif dist = create_struct ( dist , grid ) END 2 : BEGIN print , 'Using Guiding Center Monte Carlo fast-ion distribution' w = where ( \"nparticle\" eq strlowcase ( TAG_names ( dist )), nw ) if nw eq 0 then begin error , '\"nparticle\" is missing from the fast-ion distribution' err_status = 1 goto , GET_OUT endif npart = dist . nparticle zero_int = { dims : 0 , type : 'INT' } zero_long = { dims : 0 , type : 'LONG' } zero_string = { dims : 0 , type : 'STRING' } zero_double = { dims : 0 , type : 'DOUBLE' } npart_double = { dims :[ npart ], type : 'DOUBLE' } npart_int = { dims :[ npart ], type : 'INT' } schema = { type : zero_int , $ nparticle : zero_long , $ nclass : zero_int , $ time : zero_double , $ energy : npart_double , $ pitch : npart_double , $ r : npart_double , $ z : npart_double , $ weight : npart_double , $ class : npart_int , $ data_source:zero_string } check_struct_schema , schema , dist , err_status , desc= \"fast-ion distribution\" if err_status eq 1 then begin goto , GET_OUT endif print , 'Number of MC particles: ' , npart END 3 : BEGIN print , 'Using Full Orbit Monte Carlo fast-ion distribution' w = where ( \"nparticle\" eq strlowcase ( TAG_names ( dist )), nw ) if nw eq 0 then begin error , '\"nparticle\" is missing from the fast-ion distribution' err_status = 1 goto , GET_OUT endif npart = dist . nparticle zero_int = { dims : 0 , type : 'INT' } zero_long = { dims : 0 , type : 'LONG' } zero_string = { dims : 0 , type : 'STRING' } zero_double = { dims : 0 , type : 'DOUBLE' } npart_double = { dims :[ npart ], type : 'DOUBLE' } npart_int = { dims :[ npart ], type : 'INT' } schema = { type : zero_int , $ nparticle : zero_long , $ nclass : zero_int , $ time : zero_double , $ vr : npart_double , $ vt : npart_double , $ vz : npart_double , $ r : npart_double , $ z : npart_double , $ weight : npart_double , $ class : npart_int , $ data_source:zero_string } check_struct_schema , schema , dist , err_status , desc= \"fast-ion distribution\" if err_status eq 1 then begin goto , GET_OUT endif print , 'Number of MC particles: ' , npart END ELSE : BEGIN error , 'Invalid distribution type. Expected ' + $ '1 (Guiding Center Density Function), ' + $ '2 (Guiding Center Monte Carlo), or ' + $ '3 (Full Orbit Monte Carlo)' err_status = 1 goto , GET_OUT END ENDCASE if dist . data_source eq '' then begin error , 'Invalid data source. An empty string is not a data source.' err_status = 1 endif if abs ( dist . time - inp . time ) gt 0.02 then begin warn , 'Distribution time and input time do not match' print , 'Input time: ' , inp . time print , 'Distribution time: ' , dist . time endif GET_OUT : if err_status ne 0 then begin error , 'Invalid fast-ion distribution. Exiting...' , / halt endif else begin success , 'Fast-ion distribution is valid' endelse END","tags":"","loc":"sourcefile/check_distribution.pro.html","title":"check_distribution.pro – FIDASIM"},{"text":"check_fields Checks if electromagnetic fields structure is valid Input Arguments inputs : Input structure grid : Interpolation grid structure fields : Electromagnetic fields structure Example Usage IDL > check_fields, inputs, grid, fields Source Code check_fields.pro Source Code PRO check_fields , inp , grid , fields ; +#check_fields ; + Checks if electromagnetic fields structure is valid ; +*** ; +## Input Arguments ; + **inputs**: Input structure ; + ; + **grid**: Interpolation grid structure ; + ; + **fields**: Electromagnetic fields structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_fields , inputs , grid , fields ; + ``` err_status = 0 info , 'Checking electromagnetic fields...' nr = grid . nr nz = grid . nz zero_string = { dims : 0 , type : 'STRING' } zero_double = { dims : 0 , type : 'DOUBLE' } nrnz_double = { dims :[ nr , nz ], type : 'DOUBLE' } nrnz_int = { dims :[ nr , nz ], type : 'INT' } schema = { time : zero_double , $ br : nrnz_double , $ bt : nrnz_double , $ bz : nrnz_double , $ er : nrnz_double , $ et : nrnz_double , $ ez : nrnz_double , $ mask : nrnz_int , $ data_source:zero_string } check_struct_schema , schema , fields , err_status , desc = \"electromagnetic fields\" if err_status eq 1 then begin goto , GET_OUT endif if fields . data_source eq '' then begin error , 'Invalid data source. An empty string is not a data source.' err_status = 1 endif if abs ( fields . time - inp . time ) gt 0.02 then begin warn , 'Electromagnetic fields time and input time do not match' print , 'Input time: ' , inp . time print , 'Electromagnetic fields time: ' , fields . time endif fields = create_struct ( fields , grid ) GET_OUT : if err_status ne 0 then begin error , 'Invalid electromagnetic fields. Exiting...' , / halt endif else begin success , 'Electromagnetic fields are valid' endelse END","tags":"","loc":"sourcefile/check_fields.pro.html","title":"check_fields.pro – FIDASIM"},{"text":"check_grid Checks if interpolation grid structure is valid Input Arguments grid : Interpolation grid structure Example Usage IDL > check_grid, grid Source Code check_grid.pro Source Code PRO check_grid , grid ; +#check_grid ; + Checks if interpolation grid structure is valid ; +*** ; +## Input Arguments ; + **grid**: Interpolation grid structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_grid , grid ; + ``` err_status = 0 info , 'Checking interpolation grid...' w = where ( \"nr\" eq strlowcase ( TAG_NAMES ( grid )), nw ) if nw eq 0 then begin error , '\"nr\" is missing from the interpolation grid' err_status = 1 goto , GET_OUT endif w = where ( \"nz\" eq strlowcase ( TAG_NAMES ( grid )), nw ) if nw eq 0 then begin error , '\"nz\" is missing from the interpolation grid' err_status = 1 goto , GET_OUT endif nr = grid . nr nz = grid . nz zero_int = { dims : 0 , type : 'INT' } schema = { nr : zero_int , nz : zero_int , $ r2d: { dims :[ nr , nz ], type : 'DOUBLE' }, $ z2d: { dims :[ nr , nz ], type : 'DOUBLE' }, $ r :{ dims :[ nr ], type : 'DOUBLE' }, $ z :{ dims :[ nz ], type : 'DOUBLE' } } check_struct_schema , schema , grid , err_status , desc= \"interpolation grid\" if err_status eq 1 then begin goto , GET_OUT endif w = where (( indgen ( nr ) eq sort ( grid . r )) ne 1 , nw ) if nw ne 0 then begin error , 'r is not in ascending order' err_status = 1 endif w = where (( indgen ( nz ) eq sort ( grid . z )) ne 1 , nw ) if nw ne 0 then begin error , 'z is not in ascending order' err_status = 1 endif w = where (( grid . r eq grid . r2d [ * , 0 ]) ne 1 , nw ) if nw ne 0 then begin error , 'r2d is defined incorrectly. Expected r == r2d[*,0]' err_status = 1 endif w = where (( grid . z eq grid . z2d [ 0 , * ]) ne 1 , nw ) if nw ne 0 then begin error , 'z2d is defined incorrectly. Expected z == z2d[0,*]' err_status = 1 endif GET_OUT : if err_status ne 0 then begin error , 'Invalid interpolation grid. Exiting...' , / halt endif else begin success , 'Interpolation grid is valid' endelse END","tags":"","loc":"sourcefile/check_grid.pro.html","title":"check_grid.pro – FIDASIM"},{"text":"check_inputs Checks if input structure is valid Input Arguments inputs : input structure Example Usage IDL > check_inputs, inputs Source Code check_inputs.pro Source Code PRO check_inputs , inputs ; +#check_inputs ; + Checks if input structure is valid ; +*** ; +## Input Arguments ; + **inputs**: input structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_inputs , inputs ; + ``` info , 'Checking simulation settings...' err_status = 0 zero_string = { dims : 0 , type : 'STRING' } zero_int = { dims : 0 , type : 'INT' } zero_long = { dims : 0 , type : 'LONG' } zero_double = { dims : 0 , type : 'DOUBLE' } three_double = { dims :[ 3 ], type : 'DOUBLE' } schema = { comment : zero_string , $ shot : zero_long , time : zero_double , $ runid : zero_string , device : zero_string , $ tables_file:zero_string , result_dir:zero_string , $ nlambda : zero_int , lambdamin : zero_double , lambdamax : zero_double , $ nx : zero_int , ny : zero_int , nz : zero_int , $ alpha : zero_double , beta : zero_double , gamma : zero_double , $ origin : three_double , xmin : zero_double , xmax : zero_double , $ ymin : zero_double , ymax : zero_double , zmin : zero_double , zmax : zero_double , $ ab : zero_double , ai : zero_double , current_fractions:three_double , $ pinj : zero_double , einj : zero_double , impurity_charge:zero_int , $ n_fida:zero_long , n_nbi:zero_long , n_dcx:zero_long , $ n_npa:zero_long , n_halo:zero_long , n_birth:zero_long , $ ne_wght:zero_int , np_wght:zero_int , nphi_wght:zero_int , $ emax_wght:zero_double , nlambda_wght:zero_int , $ lambdamin_wght:zero_double , lambdamax_wght:zero_double , $ calc_npa:zero_int , calc_fida:zero_int , calc_bes:zero_int , $ calc_brems:zero_int , calc_birth:zero_int , $ calc_fida_wght:zero_int , calc_npa_wght:zero_int , $ dump_dcx:zero_int } check_struct_schema , schema , inputs , err_status , desc= \"simulation settings\" if err_status eq 1 then begin goto , GET_OUT endif ; Normalize File Paths inputs . result_dir = expand_path ( inputs . result_dir ) if inputs . alpha gt 2 * ! DPI or $ inputs . beta gt 2 * ! DPI or $ inputs . gamma gt 2 * ! DPI then begin error , 'Angles must be in radians' err_status = 1 endif if inputs . lambdamin ge inputs . lambdamax then begin error , 'Invalid wavelength range. Expected lambdamin < lamdbdamax' err_status = 1 endif if inputs . lambdamin_wght ge inputs . lambdamax_wght then begin error , 'Invalid wavelength range. Expected lambdamin_wght < lamdbdamax_wght' err_status = 1 endif if inputs . xmin ge inputs . xmax then begin error , 'Invalid x range. Expected xmin < xmax' err_status = 1 endif if inputs . ymin ge inputs . ymax then begin error , 'Invalid y range. Expected ymin < ymax' err_status = 1 endif if inputs . zmin ge inputs . zmax then begin error , 'Invalid z range. Expected zmin < zmax' err_status = 1 endif if inputs . pinj le 0. or inputs . einj le 0.0 then begin error , 'The selected source is not on' print , 'einj = ' , inputs . einj print , 'pinj = ' , inputs . pinj err_status = 1 endif if abs ( total ( inputs . current_fractions ) - 1.0 ) gt 1. d - 3 then begin error , 'current_fractions do not sum to 1.0' print , 'sum(current_fractions) = ' , total ( inputs . current_fractions ) err_status = 1 endif if inputs . impurity_charge le 1 then begin error , 'Invalid impurity charge. Expected impurity charge > 1' err_status = 1 endif ps = path_sep () input_file = inputs . result_dir + ps + inputs . runid+'_inputs.dat' equilibrium_file = inputs . result_dir + ps + inputs . runid+'_equilibrium.h5' geometry_file = inputs . result_dir + ps + inputs . runid+'_geometry.h5' distribution_file = inputs . result_dir + ps + inputs . runid+'_distribution.h5' neutrals_file = inputs . result_dir + ps + inputs . runid+'_neutrals.h5' inputs = create_struct ( inputs , 'input_file' , input_file , $ 'equilibrium_file' , equilibrium_file , $ 'geometry_file' , geometry_file , $ 'distribution_file' , distribution_file , $ 'load_neutrals' , 0 , $ 'no_flr' , 0 , $ 'verbose' , 1 , $ 'neutrals_file' , neutrals_file ) GET_OUT : if err_status ne 0 then begin error , 'Invalid simulation settings. Exiting...' , / halt endif else begin success , 'Simulation settings are valid' endelse END","tags":"","loc":"sourcefile/check_inputs.pro.html","title":"check_inputs.pro – FIDASIM"},{"text":"check_npa Checks if NPA geometry structure is valid Input Arguments inputs : input structure npa : NPA geometry structure Example Usage IDL > check_npa, inputs, npa Source Code check_npa.pro Source Code PRO check_npa , inp , npa ; +#check_npa ; + Checks if NPA geometry structure is valid ; +*** ; +## Input Arguments ; + **inputs**: input structure ; + ; + **npa**: NPA geometry structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_npa , inputs , npa ; + ``` err_status = 0 info , 'Checking NPA geometry...' w = where ( \"nchan\" eq strlowcase ( TAG_NAMES ( npa )), nw ) if nw eq 0 then begin error , '\"nchan\" is missing from the NPA geometry' err_status = 1 goto , GET_OUT endif nchan = npa . nchan zero_string = { dims : 0 , type : 'STRING' } zero_long = { dims : 0 , type : 'LONG' } schema = { data_source:zero_string , $ nchan : zero_long , $ system : zero_string , $ id :{ dims :[ nchan ], type : 'STRING' }, $ a_shape: { dims :[ nchan ], type : 'INT' }, $ d_shape: { dims :[ nchan ], type : 'INT' }, $ a_tedge: { dims :[ 3 , nchan ], type : 'DOUBLE' }, $ a_redge: { dims :[ 3 , nchan ], type : 'DOUBLE' }, $ a_cent: { dims :[ 3 , nchan ], type : 'DOUBLE' }, $ d_tedge: { dims :[ 3 , nchan ], type : 'DOUBLE' }, $ d_redge: { dims :[ 3 , nchan ], type : 'DOUBLE' }, $ d_cent: { dims :[ 3 , nchan ], type : 'DOUBLE' }, $ radius :{ dims :[ nchan ], type : 'DOUBLE' } } check_struct_schema , schema , npa , err_status , desc= \"NPA geometry\" if err_status eq 1 then begin goto , GET_OUT endif ;; Check detector / aperture shape w = where ( npa . d_shape gt 2 or npa . d_shape eq 0 , nw ) if nw ne 0 then begin error , 'Invalid detector shape. Expected 1 (rectagular) or 2 (circular)' print , 'Invalid indices: ' , w err_status = 1 endif w = where ( npa . a_shape gt 2 or npa . a_shape eq 0 , nw ) if nw ne 0 then begin error , 'Invalid aperture shape. Expected 1 (rectagular) or 2 (circular)' print , 'Invalid indices: ' , w err_status = 1 endif ;; Calculate grid center rc and sides length dr dr = [ inp . xmax - inp . xmin , inp . ymax - inp . ymin , inp . zmax - inp . zmin ] rc = [ inp . xmin , inp . ymin , inp . zmin ] + 0.5 * dr err_arr = dblarr ( nchan ) for i = 0 , nchan - 1 do begin uvw_det = npa . d_cent [ * , i ] d_e1 = npa . d_redge [ * , i ] - uvw_det d_e2 = npa . d_tedge [ * , i ] - uvw_det uvw_aper = npa . a_cent [ * , i ] a_e1 = npa . a_redge [ * , i ] - uvw_aper a_e2 = npa . a_tedge [ * , i ] - uvw_aper uvw_dir = uvw_aper - uvw_det ;; Rotate chords into beam grid coordinates xyz_aper = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma , uvw_aper , origin = inp . origin ) xyz_det = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma , uvw_det , origin = inp . origin ) xyz_dir = xyz_aper - xyz_det xyz_dir = xyz_dir / sqrt ( total ( xyz_dir * xyz_dir )) ;; Check if npa chord intersects beam grid aabb_intersect , rc , dr , xyz_det , xyz_dir , length , r_enter , r_exit if length le 0.0 then begin err_arr [ i ] = 1 endif ;; Check if NPA detector is pointing in the right direction d_enter = sqrt ( total (( r_enter - xyz_aper ) &#94; 2 )) d_exit = sqrt ( total (( r_exit - xyz_aper ) &#94; 2 )) if d_exit lt d_enter then begin err_arr [ i ] = 1 endif ;; Check that the detector and aperture point in the right direction d_e3 = crossp ( d_e1 , d_e2 ) a_e3 = crossp ( a_e1 , a_e2 ) d_dp = total ( uvw_dir * d_e3 ) a_dp = total ( uvw_dir * a_e3 ) dp = total ( d_e3 * a_e3 ) if ( a_dp le 0.0 ) or ( d_dp le 0.0 ) or ( dp le 0.0 ) then begin error , 'The detector and/or aperture plane normal vectors are pointing in the wrong direction. The NPA definition is incorrect.' err_arr [ i ] = 1 endif endfor w = where ( err_arr eq 0.0 , nw , complement = ww , ncomplement = nww ) print , f='(i3,\" out of \",i3,\" channels crossed the beam grid\")' , nw , nchan if nw eq 0 then begin error , 'No channels intersect the beam grid' err_status = 1 endif if nww gt 0 then begin warn , 'Some channels did not intersect the beam grid' print , 'Number missed: ' , nww print , 'Missed channels:' print , '    ' , npa . id [ ww ] endif GET_OUT : if err_status ne 0 then begin error , 'Invalid NPA geometry. Exiting...' , / halt endif else begin success , 'NPA geometry is valid' endelse END","tags":"","loc":"sourcefile/check_npa.pro.html","title":"check_npa.pro – FIDASIM"},{"text":"check_plasma Checks if plasma paramters structure is valid Input Arguments inputs : Input structure grid : Interpolation grid structure plasma : Plasma parameters structure Example Usage IDL > check_plasma, inputs, grid, plasma Source Code check_plasma.pro Source Code PRO check_plasma , inp , grid , plasma ; +#check_plasma ; + Checks if plasma paramters structure is valid ; +*** ; +## Input Arguments ; + **inputs**: Input structure ; + ; + **grid**: Interpolation grid structure ; + ; + **plasma**: Plasma parameters structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_plasma , inputs , grid , plasma ; + ``` err_status = 0 info , 'Checking plasma parameters...' nr = grid . nr nz = grid . nz zero_string = { dims : 0 , type : 'STRING' } zero_double = { dims : 0 , type : 'DOUBLE' } nrnz_double = { dims :[ nr , nz ], type : 'DOUBLE' } nrnz_int = { dims :[ nr , nz ], type : 'INT' } schema = { time : zero_double , $ vr : nrnz_double , $ vt : nrnz_double , $ vz : nrnz_double , $ dene : nrnz_double , $ ti : nrnz_double , $ te : nrnz_double , $ zeff : nrnz_double , $ mask : nrnz_int , $ data_source:zero_string } check_struct_schema , schema , plasma , err_status , desc = \"plasma parameters\" if err_status eq 1 then begin goto , GET_OUT endif if plasma . data_source eq '' then begin error , 'Invalid data source. An empty string is not a data source.' err_status = 1 endif ;; Electron density plasma . dene = plasma . dene > 0. ;[ 1 / cm&#94; 3 ] ;; Zeff plasma . zeff = plasma . zeff > 1.0 ;; Electron temperature plasma . te = plasma . te > 0. ;[ keV ] ;; Ion temperature plasma . ti = plasma . ti > 0. ;[ keV ] if abs ( plasma . time - inp . time ) gt 0.02 then begin warn , 'Plasma time and input time do not match' print , 'Input time: ' , inp . time print , 'Plasma time: ' , plasma . time endif plasma = create_struct ( plasma , grid ) GET_OUT : if err_status ne 0 then begin error , 'Invalid plasma parameters. Exiting...' , / halt endif else begin success , 'Plasma parameters are valid' endelse END","tags":"","loc":"sourcefile/check_plasma.pro.html","title":"check_plasma.pro – FIDASIM"},{"text":"check_spec Check if spectral geometry structure is valid Input Arguments inputs : input structure chords : spectral geometry structure Example Usage IDL > check_spec, inputs, chords Source Code check_spec.pro Source Code PRO check_spec , inp , chords ; +#check_spec ; + Check if spectral geometry structure is valid ; +*** ; +## Input Arguments ; + **inputs**: input structure ; + ; + **chords**: spectral geometry structure ; + ; +## Example Usage ; + ``` idl ; + IDL > check_spec , inputs , chords ; + ``` err_status = 0 info , 'Checking FIDA/BES inputs...' w = where ( \"nchan\" eq strlowcase ( TAG_NAMES ( chords )), nw ) if nw eq 0 then begin error , '\"nchan\" is missing from the FIDA/BES geometry' err_status = 1 goto , GET_OUT endif nchan = chords . nchan zero_string = { dims : 0 , type : 'STRING' } zero_long = { dims : 0 , type : 'LONG' } nchan_double = { dims :[ nchan ], type : 'DOUBLE' } nchan_string = { dims :[ nchan ], type : 'STRING' } schema = { data_source:zero_string , $ nchan : zero_long , $ system : zero_string , $ id : nchan_string , $ lens :{ dims :[ 3 , nchan ], type : 'DOUBLE' }, $ axis :{ dims :[ 3 , nchan ], type : 'DOUBLE' }, $ sigma_pi:nchan_double , $ spot_size:nchan_double , $ radius : nchan_double } check_struct_schema , schema , chords , err_status , desc= \"FIDA/BES geometry\" if err_status eq 1 then begin goto , GET_OUT endif err_arr = intarr ( nchan ) cross_arr = intarr ( nchan ) uvw_lens = chords . lens uvw_axis = chords . axis ;; ROTATE CHORDS INTO BEAM GRID COORDINATES xyz_lens = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma , uvw_lens , origin = inp . origin ) xyz_axis = uvw_to_xyz ( inp . alpha , inp . beta , inp . gamma , uvw_axis ) ;; Calculate grid center rc and sides length dr dr = [ inp . xmax - inp . xmin , inp . ymax - inp . ymin , inp . zmax - inp . zmin ] rc = [ inp . xmin , inp . ymin , inp . zmin ] + 0.5 * dr for i = 0 , nchan - 1 do begin chan_str = strcompress ( string ( i ), / remove_all ) if abs ( total ( uvw_axis [ * , i ] &#94; 2.0 ) - 1.0 ) gt 1 d - 5 then begin error , 'Invalid optical axis for chord \"' + chords . id [ i ] +'\". Expected norm(axis) == 1' print , total ( uvw_axis [ * , i ] &#94; 2.0 ) - 1.0 err_arr [ i ] = 1 endif ;; Check if viewing chord intersects beam grid aabb_intersect , rc , dr , xyz_lens [ * , i ], xyz_axis [ * , i ], length , r_enter , r_exit if length le 0.0 then begin warn , 'Chord \"' + chords . id [ i ] +'\" does not cross the beam grid' cross_arr [ i ] = 1 endif endfor w = where ( cross_arr eq 0.0 , nw , complement = ww , ncomplement = nww ) print , f='(i3,\" out of \",i3,\" chords crossed the beam grid\")' , nw , nchan if nw eq 0 then begin error , 'No channels intersect the beam grid' err_status = 1 endif GET_OUT : if err_status ne 0 then begin error , 'Invalid FIDA/BES geometry. Exiting...' , / halt endif else begin success , 'FIDA/BES geometry is valid' endelse END","tags":"","loc":"sourcefile/check_spec.pro.html","title":"check_spec.pro – FIDASIM"},{"text":"check_struct_schema Check structure s is formatted according to schema Input Arguments schema : structure schema s : structure to check Output Arguments err : error code Keyword Arguments desc : description of structure s Example usage IDL > s = {a : 0 , b : [ 1.d0 , 2.d0 ], c : \"example\" }\nIDL > schema = {a : {dims : 0 ,type : \"INT\" }, b : {dims : [ 2 ],type : \"DOUBLE\" }, c : {dims : 0 ,type : \"STRING\" }  }\n\nIDL > check_struct_schema, schema, s, err, desc = \"Example structure\" IDL > print , err 0 Source Code check_struct_schema.pro Source Code PRO check_struct_schema , schema , s , err_status , desc = desc ; +#check_struct_schema ; + Check structure ` s ` is formatted according to ` schema ` ; +*** ; +## Input Arguments ; + **schema**: structure schema ; + ; + **s**: structure to check ; + ; +## Output Arguments ; + **err**: error code ; + ; +## Keyword Arguments ; + **desc**: description of structure ` s ` ; + ; +## Example usage ; + ``` idl ; + IDL > s = { a : 0 , b :[ 1. d0 , 2. d0 ], c : \"example\" } ; + IDL > schema = { a :{ dims : 0 , type : \"INT\" }, b :{ dims :[ 2 ], type : \"DOUBLE\" }, c :{ dims : 0 , type : \"STRING\" } } ; + ; + IDL > check_struct_schema , schema , s , err , desc= \"Example structure\" ; + IDL > print , err ; + 0 ; + ``` if not keyword_set ( struct_name ) then desc = 'structure' err_status = 0 schema_tags = strlowcase ( TAG_NAMES ( schema )) tags = strlowcase ( TAG_NAMES ( s )) for i = 0 , n_elements ( tags ) - 1 do begin w = where ( tags [ i ] eq schema_tags , nw ) if nw eq 0 then begin info , 'Extra variable \"' + tags [ i ] +'\" found in ' + desc endif endfor for i = 0 , n_elements ( schema_tags ) - 1 do begin w = where ( schema_tags [ i ] eq tags , nw ) if nw eq 0 then begin error , '\"' + schema_tags [ i ] +'\" is missing from the ' + desc err_status = 1 endif else begin ;; Check dimensions ww = where (( size ( s .( w ), / dim ) eq schema .( i ). dims ) ne 1 , nww ) if nww ne 0 then begin error , '\"' + schema_tags [ i ] +'\" has the wrong dimensions. Expected (' + $ strjoin ( strcompress ( string ( schema .( i ). dims ), / remove_all ), ',' ) +')' print , 'size(' + schema_tags [ i ] +') = ' , size ( s .( w ), / dim ) err_status = 1 endif ;; Check type tname = size ( s .( w ), / tname ) if tname ne schema .( i ). type then begin error , '\"' + schema_tags [ i ] +'\" has the wrong type. Expected ' + schema .( i ). type print , 'type(' + schema_tags [ i ] +') = ' + tname err_status = 1 endif ;; Check for NaNs or Inf if tname ne 'STRING' and tname ne 'STRUCT' then begin ww = where ( finite ( s .( w )) eq 0 , nww ) endif else nww = 0 if nww ne 0 then begin error , 'NaN or Infinity detected in \"' + schema_tags [ i ] +'\"' err_status = 1 endif endelse endfor END","tags":"","loc":"sourcefile/check_struct_schema.pro.html","title":"check_struct_schema.pro – FIDASIM"},{"text":"colored Creates colored string Arguments str : String to be colored Keyword Arguments c : Foreground color code s : Style code Foreground Color Codes k : Black, r : Red, g : Green, y : Yellow, b : Blue, m : Magenta, c : Cyan, w : White Style Format Codes n : Normal, b : Bright, d : Dim, i : Italics, u : Underline, r : Reverse, h : Hidden, s : Strikethrough Return Value Colored string Example Usage IDL > blue_bright_hello = colored( \"Hello\" ,c = \"b\" ,s = \"b\" ) Source Code colored.pro Source Code FUNCTION colored , str , c = c , s = s ; +#colored ; + Creates colored string ; +*** ; +## Arguments ; + **str**: String to be colored ; + ; +## Keyword Arguments ; + **c**: Foreground color code ; + ; + **s**: Style code ; + ; +### Foreground Color Codes ; + **k**: Black , ; + **r**: Red , ; + **g**: Green , ; + **y**: Yellow , ; + **b**: Blue , ; + **m**: Magenta , ; + **c**: Cyan , ; + **w**: White ; +### Style Format Codes ; + **n**: Normal , ; + **b**: Bright , ; + **d**: Dim , ; + **i**: Italics , ; + **u**: Underline , ; + **r**: Reverse , ; + **h**: Hidden , ; + **s**: Strikethrough ; +## Return Value ; + Colored string ; + ; +## Example Usage ; + ``` idl ; + IDL > blue_bright_hello = colored ( \"Hello\" , c= \"b\" , s= \"b\" ) ; + ``` if not keyword_set ( c ) then c='w' ;; Foreground Color if not keyword_set ( s ) then s='n' ;; Style esc = string ( 27 b ) back = esc+ \"[0m\" style = { n : '0' , b : '1' , d : '2' , i : '3' , u : '4' , r : '7' , h : '8' , s : '9' } sTags = [ \"n\" , \"b\" , \"d\" , \"i\" , \"u\" , \"r\" , \"h\" , \"s\" ] fgColors = { k : '30' , r : '31' , g : '32' , y : '33' , $ b : '34' , m : '35' , c : '36' , w : '37' } fgTags = [ \"k\" , \"r\" , \"g\" , \"y\" , \"b\" , \"m\" , \"c\" , \"w\" ] sIndex = where ( s eq sTags ) fgIndex = where ( c eq fgTags ) if sIndex eq - 1 then sIndex = 0 if fgIndex eq - 1 then fgIndex = 7 return , esc+ \"[\" + style .( sIndex ) + \";\" + fgColors .( fgIndex ) + \"m\" + str + back END","tags":"","loc":"sourcefile/colored.pro.html","title":"colored.pro – FIDASIM"},{"text":"error Print a error message Arguments str : message Keyword Arguments halt : Halt program execution Example Usage IDL > error, \"=(\" Source Code error.pro Source Code PRO error , str , halt = halt ; +#error ; + Print a error message ; +*** ; +## Arguments ; + **str**: message ; + ; +## Keyword Arguments ; + **halt**: Halt program execution ; + ; +## Example Usage ; + ``` idl ; + IDL > error , \"=(\" ; + ``` if keyword_set ( halt ) then begin message , colored ( str , c='r' ), level=- 1 endif else begin print , colored ( 'ERROR: ' + str , c='r' ) endelse END","tags":"","loc":"sourcefile/error.pro.html","title":"error.pro – FIDASIM"},{"text":"extract_transp_plasma Extracts plasma structure from a TRANSP run Arguments filename : TRANSP output file e.g. [TRANSP_RUNID].CDF intime : Time of interest [s] grid : Interpolation grid flux : Torodial Flux mapped onto the interpolation grid Keyword Arguments doplot : Plot profiles profiles : Set this keyword to a named variable to recieve the plasma profiles as a function of rho s(ne|te|ti|imp|rot) : Smooth profiles Example Usage IDL > plasma = extract_transp_plasma( \"./142332H01.CDF\" , 1.2 , grid, flux) Source Code extract_transp_plasma.pro Source Code FUNCTION extract_transp_plasma , filename , intime , grid , flux , $ doplot = doplot , profiles = profiles , $ sne = sne , ste = ste , sti = sti , simp = simp , srot = srot ; +#extract_transp_plasma ; + Extracts ` plasma ` structure from a TRANSP run ; +*** ; +## Arguments ; + **filename**: TRANSP output file e . g . [ TRANSP_RUNID ]. CDF ; + ; + **intime**: Time of interest [ s ] ; + ; + **grid**: Interpolation grid ; + ; + **flux**: Torodial Flux mapped onto the interpolation grid ; + ; +## Keyword Arguments ; + **doplot**: Plot profiles ; + ; + **profiles**: Set this keyword to a named variable to recieve the plasma profiles as a function of rho ; + ; + ** s ( ne | te | ti | imp | rot ) **: Smooth profiles ; + ; +## Example Usage ; + ``` idl ; + IDL > plasma = extract_transp_plasma ( \"./142332H01.CDF\" , 1.2 , grid , flux ) ; + ``` var_list = [ \"X\" , \"TIME\" , \"NE\" , \"TE\" , \"TI\" , \"ZEFFI\" , \"OMEGA\" ] zz = read_ncdf ( filename , vars = var_list ) transp_ne = zz . ne_ ; cm&#94;- 3 transp_te = zz . te * 1. d - 3 ; kev transp_ti = zz . ti * 1. d - 3 ; kev transp_zeff = zz . zeffi x = zz . x t = zz . time dummy = min ( abs ( t - intime ), idx ) time = double ( t [ idx ]) x = double ( x [ * , idx ]) if total ( strmatch ( tag_names ( zz ), 'OMEGA' , / fold_case )) eq 0 then begin warn , 'OMEGA not found in TRANSP file. Assuming no plasma rotation' transp_omega = replicate ( 0. , n_elements ( x ), n_elements ( t )) endif else begin transp_omega = zz . omega ; rad / s endelse print , ' * Selecting profiles at :' , t [ idx ], ' s' ; pick the closest timeslice to TOI if keyword_set ( doplot ) then begin ! p . charsize = 2 & ! x . minor=- 1 & ! y . minor=- 1 loadct , 13 & ! p . color = 100 & ! p . multi = [ 0 , 2 , 3 ] & ! p . psym = 1 & ! p . thick = 1 device , decompose = 0 window , 0 , retain = 2 , xs = 600 , ys = 800 if keyword_set ( sne ) then begin z = smooth ( transp_ne , [ 1 , sne ]) plot , x , transp_ne [ * , idx ], title='Ne' oplot , x , z [ * , idx ], psym = 0 , color = 100 transp_ne = z end if keyword_set ( simp ) then begin z = smooth ( transp_zeff , [ 1 , simp ]) plot , x , transp_zeff [ * , idx ], title='Zeff' oplot , x , z [ * , idx ], psym = 0 , color = 100 transp_zeff = z end if keyword_set ( ste ) then begin z = smooth ( transp_te , [ 1 , ste ]) plot , x , transp_te [ * , idx ], title='Te' oplot , x , z [ * , idx ], psym = 0 , color = 100 transp_te = z end if keyword_set ( sti ) then begin z = smooth ( transp_ti , [ 1 , sti ]) plot , x , transp_ti [ * , idx ], title='Ti' oplot , x , z [ * , idx ], psym = 0 , color = 100 transp_ti = z end if keyword_set ( srot ) then begin z = smooth ( transp_omega , [ 1 , srot ]) plot , x , transp_omega [ * , idx ], title='Omega' oplot , x , z [ * , idx ], psym = 0 , color = 100 transp_omega = z end ! p . color = 220 & ! p . multi = [ 0 , 2 , 3 ] & ! p . psym = 0 & ! p . thick = 2 window , 1 , retain = 2 , xs = 600 , ys = 800 plot , x , transp_ne [ * , idx ], ytitle=' x E13 cm-3' , title='Ne  ' plot , x , transp_zeff [ * , idx ], ytitle = 'x E13 cm-3' , title='Zeff' plot , x , transp_te [ * , idx ], ytitle=' keV' , title='Te' plot , x , transp_ti [ * , idx ], xtitle='rho' , ytitle=' keV' , title='Ti' plot , x , transp_omega [ * , idx ], xtitle='rho' , ytitle='rad/s' , title='Omega' endif profiles = { rho : x , $ dene : transp_ne [ * , idx ] > 0.0 , $ te : transp_te [ * , idx ] > 0.0 , $ ti : transp_ti [ * , idx ] > 0.0 , $ zeff : transp_zeff [ * , idx ] > 1.0 , $ omega : transp_omega [ * , idx ]} ;; Interpolate onto r - z grid dene = interpol ( transp_ne [ * , idx ], x , flux ) > 0.0 te = interpol ( transp_te [ * , idx ], x , flux ) > 0.0 ti = interpol ( transp_ti [ * , idx ], x , flux ) > 0.0 zeff = interpol ( transp_zeff [ * , idx ], x , flux ) > 1.0 vt = double ( grid . r2d * interpol ( transp_omega [ * , idx ], x , flux )) vr = double ( replicate ( 0.0 , grid . nr , grid . nz )) vz = double ( replicate ( 0.0 , grid . nr , grid . nz )) max_flux = max ( abs ( x )) s = size ( flux , / dim ) mask = intarr ( s [ 0 ], s [ 1 ]) w = where ( flux le max_flux ) ; where we have profiles mask [ w ] = 1 ;; SAVE IN PROFILES STRUCTURE plasma= { data_source: file_expand_path ( filename ), time : time , mask : mask , $ dene : dene , te : te , ti : ti , vr : vr , vt : vt , vz : vz , zeff : zeff } return , plasma END","tags":"","loc":"sourcefile/extract_transp_plasma.pro.html","title":"extract_transp_plasma.pro – FIDASIM"},{"text":"get_fidasim_dir Gets FIDASIM install directory Example Usage IDL > fida_dir = get_fidasim_dir() Source Code get_fidasim_dir.pro Source Code FUNCTION get_fidasim_dir ; +#get_fidasim_dir ; + Gets FIDASIM install directory ; +*** ; + ; +## Example Usage ; + ``` idl ; + IDL > fida_dir = get_fidasim_dir () ; + ``` return , file_dirname ( file_dirname ( file_dirname ( source_file ()))) END","tags":"","loc":"sourcefile/get_fidasim_dir.pro.html","title":"get_fidasim_dir.pro – FIDASIM"},{"text":"get_version Gets FIDASIM version number from git.\nFalls back to reading VERSION file when git is not available Input Arguments fidasim_dir : FIDASIM install directory Example Usage IDL > version = get_version( getenv ( \"FIDASIM_DIR\" )) Source Code get_version.pro Source Code FUNCTION get_version , fidasim_dir ; +#get_version ; + Gets FIDASIM version number from git . ; + Falls back to reading VERSION file when git is not available ; +*** ; +## Input Arguments ; + **fidasim_dir**: FIDASIM install directory ; + ; +## Example Usage ; + ``` idl ; + IDL > version = get_version ( getenv ( \"FIDASIM_DIR\" )) ; + ``` version = '' git_dir = fidasim_dir+'/.git' if strcmp (! VERSION . OS_FAMILY , 'windows' , / fold_case ) then begin spawn , 'command -v git ' , git_command endif else begin spawn , 'command -v git ' , git_command , / sh endelse if file_test ( git_command ) and file_test ( git_dir , / dir ) then begin spawn , git_command+' --git-dir=' + git_dir+' describe --tags --always --dirty' , version , err_status endif else begin version_file = fidasim_dir+'/VERSION' version = '' if file_test ( version_file ) then begin openr , lun , version_file , / get_lun readf , lun , version free_lun , lun endif endelse return , version END","tags":"","loc":"sourcefile/get_version.pro.html","title":"get_version.pro – FIDASIM"},{"text":"info Print a informational message Arguments str : message Example Usage IDL > info, \"This is an informative message\" Source Code info.pro Source Code PRO info , str ; +#info ; + Print a informational message ; +*** ; +## Arguments ; + **str**: message ; + ; +## Example Usage ; + ``` idl ; + IDL > info , \"This is an informative message\" ; + ``` print , colored ( 'INFO: ' + str , c='b' ) END","tags":"","loc":"sourcefile/info.pro.html","title":"info.pro – FIDASIM"},{"text":"line_basis Calculates basis from a line with +x in the direction of line Arguments r0 : Starting point of line [cm] v0 : Direction of line Keyword Arguments inv_basis : Set this to a named variable that recieves the inverse basis Example Usage IDL > basis = line_basis([ 0 , 0 , 0 ],[ 0 , - 1 , 0 ])\nIDL > x = basis ## [ 1 , 1 , 0 ] ;Transforms a point in line - space ([ 1 , 1 , 0 ]) to real space\nIDL > print ,x\n[ 1 , - 1 , 0 ] Source Code line_basis.pro Source Code FUNCTION line_basis , r0 , v0 , inv_basis = inv_basis ; +#line_basis ; + Calculates basis from a line with + x in the direction of line ; +*** ; +## Arguments ; + **r0**: Starting point of line [ cm ] ; + ; + **v0**: Direction of line ; + ; +## Keyword Arguments ; + **inv_basis**: Set this to a named variable that recieves the inverse basis ; + ; +## Example Usage ; + ``` idl ; + IDL > basis = line_basis ([ 0 , 0 , 0 ],[ 0 , - 1 , 0 ]) ; + IDL > x = basis## [ 1 , 1 , 0 ] ; Transforms a point in line - space ([ 1 , 1 , 0 ]) to real space ; + IDL > print , x ; + [ 1 , - 1 , 0 ] ; + ``` rf = r0 + v0 dis = sqrt ( total ( v0&#94; 2.0 )) beta = asin (( r0 [ 2 ] - rf [ 2 ]) / dis ) alpha = atan (( rf [ 1 ] - r0 [ 1 ]),( rf [ 0 ] - r0 [ 0 ])) R = tb_zyx ( alpha , beta , 0.0 ) inv_basis = transpose ( R ) return , R END","tags":"","loc":"sourcefile/line_basis.pro.html","title":"line_basis.pro – FIDASIM"},{"text":"nubeam_geometry Calculates the FIDASIM beam geometry from the beam geometry variables in the TRANSP/NUBEAM namelist Arguments NUBEAM : Structure containing the following NUBEAM.NAME : Ion source name NUBEAM.NBSHAP : Ion source shape 1=rectangular, 2=circular NUBEAM.FOCLZ : Vertical focal length [cm] NUBEAM.FOCLR : Horizontal focal length [cm] NUBEAM.DIVZ : Vertical divergence [rad] NUBEAM.DIVR : Horizontal divergence [rad] NUBEAM.BMWIDZ : Ion source half height [cm] NUBEAM.BMWIDR : Ion source half width [cm] NUBEAM.RTCENA : Radius of tangency point [cm] NUBEAM.XLBTNA : Distance from center of beam source grid to tangency point [cm] NUBEAM.XBZETA : Torodial angle [deg] Positive angles defined to be in the counter-clockwise direction NUBEAM.XYBSCA : Elevation above/below vacuum vessel midplane of center of beam source grid [cm] NUBEAM.NLCO : 1 for Co-beam, 0 or -1 for Counter-beam NUBEAM.NBAPSHA : Vector of aperture shapes 1=rectangular, 2=circular NUBEAM.XLBAPA : Vector of distances from center of beam source grid to the aperture plane [cm] NUBEAM.XYBAPA : Vector of elevation above/below vacuum vessel midplane of beam centerline at aperture [cm] NUBEAM.RAPEDGA : Vector of aperture half-widths [cm] NUBEAM.XZPEDGA : Vector of aperture half-heights [cm] NUBEAM.XRAPOFFA : Vector of horizontal (y) offsets relative to the +x aligned beam centerline [cm] NUBEAM.XZAPOFFA : Vector of vertical (z) offsets relative to the +x aligned beam centerline [cm] Keyword Arguments angle : Angle to add to XBZETA to rotate the beams into correct coordinates [deg] verbose : Print out positions plot : Plot the beam Return Value Neutral beam structure Example Usage IDL > nbi = nubeam_geometry(nubeam) Source Code nubeam_geometry.pro Source Code FUNCTION nubeam_geometry , nubeam , angle = angle , verbose = verbose , plot = plot ; +#nubeam_geometry ; + Calculates the FIDASIM beam geometry from the beam geometry variables in the TRANSP / NUBEAM namelist ; +*** ; +## Arguments ; + ** NUBEAM **: Structure containing the following ; + ; + ** NUBEAM . NAME **: Ion source name ; + ; + ** NUBEAM . NBSHAP **: Ion source shape 1 = rectangular , 2 = circular ; + ; + ** NUBEAM . FOCLZ **: Vertical focal length [ cm ] ; + ; + ** NUBEAM . FOCLR **: Horizontal focal length [ cm ] ; + ; + ** NUBEAM . DIVZ **: Vertical divergence [ rad ] ; + ; + ** NUBEAM . DIVR **: Horizontal divergence [ rad ] ; + ; + ** NUBEAM . BMWIDZ **: Ion source half height [ cm ] ; + ; + ** NUBEAM . BMWIDR **: Ion source half width [ cm ] ; + ; + ** NUBEAM . RTCENA **: Radius of tangency point [ cm ] ; + ; + ** NUBEAM . XLBTNA **: Distance from center of beam source grid to tangency point [ cm ] ; + ; + ** NUBEAM . XBZETA **: Torodial angle [ deg ] Positive angles defined to be in the counter - clockwise direction ; + ; + ** NUBEAM . XYBSCA **: Elevation above / below vacuum vessel midplane of center of beam source grid [ cm ] ; + ; + ** NUBEAM . NLCO **: 1 for Co - beam , 0 or - 1 for Counter - beam ; + ; + ** NUBEAM . NBAPSHA **: Vector of aperture shapes 1 = rectangular , 2 = circular ; + ; + ** NUBEAM . XLBAPA **: Vector of distances from center of beam source grid to the aperture plane [ cm ] ; + ; + ** NUBEAM . XYBAPA **: Vector of elevation above / below vacuum vessel midplane of beam centerline at aperture [ cm ] ; + ; + ** NUBEAM . RAPEDGA **: Vector of aperture half - widths [ cm ] ; + ; + ** NUBEAM . XZPEDGA **: Vector of aperture half - heights [ cm ] ; + ; + ** NUBEAM . XRAPOFFA **: Vector of horizontal ( y ) offsets relative to the + x aligned beam centerline [ cm ] ; + ; + ** NUBEAM . XZAPOFFA **: Vector of vertical ( z ) offsets relative to the + x aligned beam centerline [ cm ] ; + ; +## Keyword Arguments ; + **angle**: Angle to add to XBZETA to rotate the beams into correct coordinates [ deg ] ; + ; + **verbose**: Print out positions ; + ; + **plot**: Plot the beam ; + ; +## Return Value ; + Neutral beam structure ; + ; +## Example Usage ; + ``` idl ; + IDL > nbi = nubeam_geometry ( nubeam ) ; + ``` if not keyword_set ( angle ) then angle = 0 if nubeam . nlco eq 0 then nubeam . nlco = - 1 phi_s= ( nubeam . XBZETA + angle ) * ! DPI / 180.0 zs = nubeam . XYBSCA za = nubeam . XYBAPA [ 0 ] alpha = asin (( zs - za ) / nubeam . XLBAPA [ 0 ]) pdst = nubeam . XLBTNA * cos ( alpha ) rs = sqrt ( nubeam . RTCENA &#94; 2.0 + pdst&#94; 2.0 ) dat = nubeam . XLBTNA - nubeam . XLBAPA [ 0 ] pdat = dat * cos ( alpha ) ra = sqrt ( nubeam . RTCENA &#94; 2.0 + pdat&#94; 2.0 ) beta_s = acos ( nubeam . RTCENA / rs ) beta_a = acos ( nubeam . RTCENA / ra ) phi_a = phi_s + nubeam . NLCO * ( beta_s - beta_a ) src = [ rs * cos ( phi_s ), rs * sin ( phi_s ), zs ] aper_src = [ ra * cos ( phi_a ), ra * sin ( phi_a ), za ] axis= ( aper_src - src ) axis = axis / sqrt ( total ( axis&#94; 2 )) pos = src + axis * nubeam . XLBTNA if keyword_set ( verbose ) then begin print , 'Source position: ' , src print , '1st Aperture position: ' , aper_src print , 'Tangency position: ' , pos endif if keyword_set ( plot ) then begin plot ,[ src [ 0 ], pos [ 0 ]],[ src [ 1 ], pos [ 1 ]] endif nbi = { data_source: \"TRANSP/NUBEAM namelist\" , name : nubeam . name , $ shape : nubeam . nbshap , src : src , axis : axis , $ focy : double ( nubeam . foclr ), focz : double ( nubeam . foclz ), $ divy : replicate ( double ( nubeam . divr ), 3 ), $ divz : replicate ( double ( nubeam . divz ), 3 ), $ widy : double ( nubeam . bmwidr ), widz : double ( nubeam . bmwidz ), $ naperture : fix ( n_elements ( nubeam . nbapsha )), ashape : nubeam . nbapsha , $ awidy : double ( nubeam . rapedga ), awidz : double ( nubeam . xzpedga ), $ aoffy : double ( nubeam . xrapoffa ), aoffz : double ( nubeam . xzapoffa ), $ adist : double ( nubeam . xlbapa ) } return , nbi END","tags":"","loc":"sourcefile/nubeam_geometry.pro.html","title":"nubeam_geometry.pro – FIDASIM"},{"text":"prefida Checks FIDASIM inputs and writes FIDASIM input files Input Arguments inputs : Inputs structure grid : Interpolation grid structure nbi : Neutral beam geometry structure plasma : Plasma parameters structure fields : Electromagnetic fields structure dist : Fast-ion distribution structure Keyword Arguments spec : Optional, Spectral geometry structure npa : Optional, NPA geometry structure Example Usage IDL > prefida, inputs, grid, nbi, plasma, fields, dist , spec = spec, npa = npa Source Code prefida.pro Source Code PRO prefida , inputs , grid , nbi , plasma , fields , fbm , spec = spec , npa = npa ; +#prefida ; + Checks FIDASIM inputs and writes FIDASIM input files ; +*** ; +## Input Arguments ; + **inputs**: Inputs structure ; + ; + **grid**: Interpolation grid structure ; + ; + **nbi**: Neutral beam geometry structure ; + ; + **plasma**: Plasma parameters structure ; + ; + **fields**: Electromagnetic fields structure ; + ; + **dist**: Fast - ion distribution structure ; + ; +## Keyword Arguments ; + **spec**: Optional , Spectral geometry structure ; + ; + **npa**: Optional , NPA geometry structure ; + ; +## Example Usage ; + ``` idl ; + IDL > prefida , inputs , grid , nbi , plasma , fields , dist , spec = spec , npa = npa ; + ``` COMPILE_OPT DEFINT32 ;; CHECK INPUTS check_inputs , inputs ;; MAKE DIRECTORIES IF THEY DONT EXIST if file_test ( inputs . result_dir , / directory ) eq 0 then begin file_mkdir , inputs . result_dir endif ;; CHECK INTERPOLATION GRID check_grid , grid ;; CHECK BEAM INPUTS check_beam , inputs , nbi ;; CHECK PLASMA PARAMETERS check_plasma , inputs , grid , plasma ;; CHECK ELECTROMAGNETIC FIELDS check_fields , inputs , grid , fields ;; CHECK FAST - ION DISTRIBUTION check_distribution , inputs , grid , fbm ;; CHECK FIDA / BES if keyword_set ( spec ) then begin check_spec , inputs , spec endif ;; CHECK NPA if keyword_set ( npa ) then begin check_npa , inputs , npa endif ;; WRITE FIDASIM INPUT FILES write_namelist , inputs . input_file , inputs ;; WRITE GEOMETRY FILE write_geometry , inputs . geometry_file , nbi , spec = spec , npa = npa ;; WRITE EQUILIBRIUM FILE write_equilibrium , inputs . equilibrium_file , plasma , fields ;; WRITE DISTRIBUTION FILE write_distribution , inputs . distribution_file , fbm print , '' print , '' success , 'FIDASIM pre-processing completed' print , 'To run FIDASIM use the following command' print , get_fidasim_dir () +'/fidasim ' + inputs . result_dir+'/' + inputs . runid+'_inputs.dat' print , '' print , '' END","tags":"","loc":"sourcefile/prefida.pro.html","title":"prefida.pro – FIDASIM"},{"text":"read_geqdsk Reads an EFIT GEQDSK file Arguments filename : GEQDSK file grid : Interpolation grid Keyword Arguments flux : Set this keyword to a named variable to recieve the torodial flux mapped onto the interpolation grid g : Set this keyword to a named variable to recieve the geqdsk structure Return Value Electronmagnetic fields structure Example Usage IDL > fields = read_geqdsk( \"./g133223.00200\" ,grid,flux = flux) Source Code read_geqdsk.pro Source Code ; ====================================================================== ; $ Id : calculate_bfield . pro , v 1.3 2008 / 06 / 14 18 : 51 : 54 liud Exp $ ; ====================================================================== ; WWH removed requirement for a eqdsk from Jong 's calculate_bfields ; Include sign of current so br & bz go in right direction for ; standard (r,phi,z) coordinates ; NAME: ;     CALCULATE_BFIELD ; ; PURPOSE: ;     Calculate the poloidal, toroidal, vertical and radial magnetic ;     field components ; ; CALLING SEQUENCE: ;     calculate_bfields,bp,br,bt,bz,a,g ; ; INPUT PARAMETERS: ;     a:      - structure containing A0 parameters ;     g:      - structure containing G0 parameters ; ; ; OPTIONAL INPUT PARAMETERS: ; ;     NONE ; ; KEYWORDS: ; ;     NONE ; ; OUTPUTS: ;      bp     2-D array containing the poloidal field at refit,zefit ;      br     2-D array containing the radial field at refit,zefit ;      bt     2-D array containing the toroidal field at refit,zefit ;      bz     2-D array containing the vertical field at refit,zefit ; ; COMMON BLOCKS: ; ;     NONE ; ; SIDE EFFECTS: ; ;     NONE ; ; RESTRICTIONS: ;     Prior to this using this function, you must have first read in ;     the EFIT data to fill the a and g structures. ; ; PROCEDURE: ;     The program uses a simple differentiation using a 3 point ;     Lagrangian interpolation. ; ; CODE TYPE: modeling, analysis ; ; CODE SUBJECT:  edge, transport, equilibrium ; ; EASE OF USE: can be used with existing documentation ; ; OPERATING SYSTEMS:  Unix Of All Flavors ; ; EXTERNAL CALLS:  NONE ; ; RESPONSIBLE PERSON: Ray Jong ; ; DATE OF LAST MODIFICATION:  09/24/98 ; ; MODIFICATION HISTORY: ; ;     Created by Gary D. Porter, LLNL ;     1994.02.16     Michael D. Brown ;                    Optimized for IDL ;     1998.02.17:    Gary D. Porter ;                    Modified to use new EFIT routines and a and g structures. ;                    No longer uses efitcommon. ;- PRO calculate_bfield,bp,br,bt,bz,g compile_opt defint32,strictarr,strictarrsubs if n_elements(g.time) eq 0 then return ;if a.ishot le 0 or g.time le 0 then return if g.time le 0 then return mw=g.mw & mh=g.mh bp=fltarr(mw,mh) & bt=fltarr(mw,mh) & br=fltarr(mw,mh) & bz=fltarr(mw,mh) dpsidx = fltarr(mw,mh) dpsidy = fltarr(mw,mh) ; calculate vertical derivative of psi for i = 0,mw-1 do begin dpsidy[i,*] = Deriv(g.z[0:mh-1],g.psirz[i,0:mh-1]) endfor ; calculate horizontal derivative of psi for j = 0,mh-1 do begin dpsidx[*,j] = Deriv(g.r[0:mw-1],g.psirz[0:mw-1,j]) endfor ; calculate array of Br, Bz, and Bp for j = 0,mh-1 do begin br[*,j] = dpsidy[0:mw-1,j]/g.r[0:mw-1] bz[*,j] = -dpsidx[0:mw-1,j]/g.r[0:mw-1] endfor bp = sqrt(br*br+bz*bz) ; WWH get right sign if g.cpasma lt 0. then begin br=-br & bz=-bz end ; Calculate toroidal field ; Original coding was from gfield.for by Peter Politzer, ;   translated to IDL by Gary Porter (see BFIELD.PRO). ; The code below has be optimized for IDL by Michael D. Brown, 2/16/94 dpsi = (g.ssibry-g.ssimag)/float(mw-1) ; first order Bt value. for j=0,mh-1 do bt[0:mw-1,j]=g.bcentr*g.rzero/g.r[0:mw-1] k = long((g.psirz - g.ssimag)/dpsi) iw=where(k ge 0 and k lt mw-1,n)  ; 1-d indexes where k is a valid index. if n gt 0 then begin iwr = iw mod mw  ; map matrix 1-d selected indexes to an refit row index. bt[iw] = ( g.fpol[k[iw]]+(g.fpol[k[iw]+1]-g.fpol[k[iw]])* $ (g.psirz[iw]-(k[iw]*dpsi+g.ssimag))/dpsi ) / g.r[iwr] endif return end FUNCTION read_geqdsk,filename,grid,flux=flux,g=g ;+#read_geqdsk ;+Reads an EFIT GEQDSK file ;+*** ;+##Arguments ;+    **filename**: GEQDSK file ;+ ;+    **grid**: Interpolation grid ;+ ;+##Keyword Arguments ;+    **flux**: Set this keyword to a named variable to recieve the torodial flux mapped onto the interpolation grid ;+ ;+    **g**: Set this keyword to a named variable to recieve the geqdsk structure ;+ ;+##Return Value ;+Electronmagnetic fields structure ;+ ;+##Example Usage ;+```idl ;+IDL> fields = read_geqdsk(\"./g133223.00200\",grid,flux=flux) ;+``` equil={err:1} ;; Get eqdsk g=readg(filename) time = double(g.time) fluxgrid=double(rho_rz(g,grid.r2d/100.,grid.z2d/100.,/do_linear)) calculate_bfield,bp,br,bphi,bz1,g ;; Get radial electric field on efit's grid from potential ;; epoten is on a grid of equally spaced points in psi from g . ssimag to g . ssibry dpsi= ( g . ssibry - g . ssimag ) / ( n_elements ( g . epoten ) - 1 ) psi = g . ssimag + dpsi * findgen ( n_elements ( g . epoten )) npot = n_elements ( g . epoten ) epot = replicate ( g . epoten [ npot - 1 ], n_elements ( g . r ), n_elements ( g . z )) for i = 0 l , n_elements ( g . r ) - 1 do begin for j = 0 l , n_elements ( g . z ) - 1 do begin psi1 = g . psirz [ i , j ] dum = min ( abs ( psi1 - psi ), kpsi ) if kpsi ne npot - 1 then epot [ i , j ] = spline ( psi , g . epoten ,[ psi1 ]) endfor endfor ; E = - grad ( Phi ) EFIT units should be V / m er=- ( shift ( epot , - 1 , 0 ) - shift ( epot , 1 , 0 )) / ( g . r [ 2 ] - g . r [ 0 ]) ez1=- ( shift ( epot , 0 , - 1 ) - shift ( epot , 0 , 1 )) / ( g . z [ 2 ] - g . z [ 0 ]) ;; Interpolate cylindrical fields onto ( r , w ) mesh b_r = dblarr ( grid . nr , grid . nz ) & b_t = b_r & b_z = b_r e_r = dblarr ( grid . nr , grid . nz ) & e_t = e_r & e_z = e_r for i = 0 L , grid . nr - 1 do for j = 0 L , grid . nz - 1 do begin rgrid= ( .01 * grid . r2d [ i , j ] - g . r [ 0 ]) / ( g . r [ 1 ] - g . r [ 0 ]) ; in grid units zgrid= ( .01 * grid . z2d [ i , j ] - g . z [ 0 ]) / ( g . z [ 1 ] - g . z [ 0 ]) ; WWH 3 / 31 / 07 b_r [ i , j ] = interpolate ( br ,[ rgrid ],[ zgrid ]) e_r [ i , j ] = interpolate ( er ,[ rgrid ],[ zgrid ]) b_t [ i , j ] = interpolate ( bphi ,[ rgrid ],[ zgrid ]) e_z [ i , j ] = interpolate ( ez1 ,[ rgrid ],[ zgrid ]) b_z [ i , j ] = interpolate ( bz1 ,[ rgrid ],[ zgrid ]) endfor flux = fluxgrid mask = replicate ( 1 , grid . nr , grid . nz ) equil= { time : time , data_source: file_expand_path ( filename ), mask : mask , $ br : b_r , bt : b_t , bz : b_z , er : e_r , et : e_t , ez : e_z } GET_OUT : return , equil END","tags":"","loc":"sourcefile/read_geqdsk.pro.html","title":"read_geqdsk.pro – FIDASIM"},{"text":"read_hdf5 Reads HDF5 file variables and attributes Arguments filename : HDF5 file Keyword Arguments paths : Paths to variables to be read flatten : Flatten tree structure shallow : Performs a shallow read i.e. no dataset/group attributes Return Value Structure containing variables and attributes Example Usage IDL > a = read_hdf5( \"./test_1a_geometry.h5\" )\nIDL > b = read_hdf5( \"./test_1a_geometry.h5\" ,paths = \"/spec/lens\" , / flatten, / shallow) Source Code read_hdf5.pro Source Code FUNCTION valid_name , name , bad_names = bad_names , post = post reserved = [ 'AND' , 'BEGIN' , 'BREAK' , 'CASE' , 'COMMON' , 'COMPILE_OPT' , $ 'CONTINUE' , 'DO' , 'ELSE' , 'END' , 'ENDCASE' , 'ENDELSE' , $ 'ENDFOR' , 'ENDFOREACH' , 'ENDIF' , 'ENDREP' , 'ENDSWITCH' , 'ENDWHILE' , $ 'EQ' , 'FOR' , 'FOREACH' , 'FORWARD_FUNCTION' , 'FUNCTION' , 'GE' , $ 'GOTO' , 'GT' , 'IF' , 'INHERITS' , 'LE' , 'LT' , 'MOD' , 'NE' , 'NOT' , 'OF' , $ 'ON_IOERROR' , 'OR' , 'PRO' , 'REPEAT' , 'SWITCH' , 'THEN' , 'UNTIL' , $ 'WHILE' , 'X0R' ] if not keyword_set ( bad_names ) then bad_names = '' if not keyword_set ( post ) then post = '' bad_names = [ reserved , bad_names ] if total ( strmatch ( bad_names , name , / fold_case )) ne 0 then begin valid_name = name + '_' + post endif else begin valid_name = name endelse ; added 2016 - 09 - 15 by NGB to fix invalid structure tags valid_name = idl_validname ( valid_name , / convert_all ) return , valid_name END FUNCTION create_nested_struct , path , data rpath = reverse ( strsplit ( path , '/' , / extract )) d = data for i = 0 , n_elements ( rpath ) - 1 do begin varname = valid_name ( rpath [ i ]) d = create_struct ( varname , d ) endfor return , d END FUNCTION hdf5_read_attributes , id , bad_names = bad_names ;; Get any attributes natts = h5a_get_num_attrs ( id ) atts = {} for i = 0 L , natts - 1 do begin ;; Open attribute id attribute_id = h5a_open_idx ( id , i ) ;; Get attribute name and make sure its valid attribute_name = h5a_get_name ( attribute_id ) attribute_name = valid_name ( attribute_name , $ bad_names = bad_names , $ post = strcompress ( string ( i ), / remove_all )) ;; Get the attribute data attribute_data = h5a_read ( attribute_id ) atts = create_struct ( atts , attribute_name , attribute_data ) ;; Close attribute id h5a_close , attribute_id endfor return , atts END FUNCTION hdf5_read_dataset , id , name , shallow = shallow ;; Get data dataset_id = h5d_open ( id , name ) data = h5d_read ( dataset_id ) ;; Get any attributes atts = hdf5_read_attributes ( dataset_id , bad_names= \"data\" ) ;; Close the dataset h5d_close , dataset_id if keyword_set ( shallow ) then begin return , data endif else begin return , create_struct ( atts , \"data\" , data ) endelse END FUNCTION hdf5_read_group , id , shallow = shallow FORWARD_FUNCTION hdf5_read_group nobjs = h5g_get_num_objs ( id ) d = {} for i = 0 , nobjs - 1 do begin obj_name = h5g_get_obj_name_by_idx ( id , i ) var_name = valid_name ( obj_name ) obj_info = h5g_get_objinfo ( id , obj_name ) obj_type = obj_info . type CASE obj_type OF 'GROUP': BEGIN gid = h5g_open ( id , obj_name ) var = hdf5_read_group ( gid , shallow = shallow ) h5g_close , gid if n_elements ( var ) ne 0 then begin d = create_struct ( d , var_name , var ) endif END 'DATASET': BEGIN var = hdf5_read_dataset ( id , obj_name , shallow = shallow ) if n_elements ( var ) ne 0 then begin d = create_struct ( d , var_name , var ) endif END 'TYPE': BEGIN tid = h5t_open ( id , obj_name ) var = hdf5_read_attributes ( tid ) h5t_close , tid if n_elements ( var ) ne 0 then begin d = create_struct ( d , var_name , var ) endif END ELSE : ENDCASE endfor atts = hdf5_read_attributes ( id ) if n_elements ( atts ) ne 0 then begin return , create_struct ( d , atts ) endif else begin return , d endelse END FUNCTION hdf5_read_from_list , id , var_paths , flatten = flatten , shallow = shallow d = {} used_names = [] i = 0 L while i lt n_elements ( var_paths ) do begin catch , err_status if err_status ne 0 then begin print , 'Error reading ' + var_paths [ i ] print ,! ERROR_STATE . MSG catch , / cancel i = i + 1 continue endif path = var_paths [ i ] obj_info = h5g_get_objinfo ( id , path ) obj_type = obj_info . type CASE obj_type OF 'LINK': BEGIN var_name = h5g_get_linkval ( id , path ) var_paths = [ var_paths , var_name ] END 'GROUP': BEGIN gid = h5g_open ( id , path ) var = hdf5_read_group ( gid , shallow = shallow ) h5g_close , gid if n_elements ( var ) ne 0 then begin if keyword_set ( flatten ) then begin var_names = strsplit ( path , '/' , / extract ) var_name = valid_name ( var_names [ - 1 ], $ bad_names = used_names , $ post = strcompress ( string ( i ), / remove_all )) used_names = [ used_names , var_name ] d = create_struct ( d , var_name , var ) endif else begin d = create_struct ( d , create_nested_struct ( path , var )) endelse endif END 'DATASET': BEGIN var = hdf5_read_dataset ( id , path , shallow = shallow ) if n_elements ( var ) ne 0 then begin if keyword_set ( flatten ) then begin var_names = strsplit ( path , '/' , / extract ) var_name = valid_name ( var_names [ - 1 ], $ bad_names = used_names , $ post = strcompress ( string ( i ), / remove_all )) used_names = [ used_names , var_name ] d = create_struct ( d , var_name , var ) endif else begin d = create_struct ( d , create_nested_struct ( path , var )) endelse endif END 'TYPE': BEGIN tid = h5t_open ( id , path ) var = hdf5_read_attributes ( tid ) h5t_close , tid if n_elements ( var ) ne 0 then begin if keyword_set ( flatten ) then begin var_names = strsplit ( path , '/' , / extract ) var_name = valid_name ( var_names [ - 1 ], $ bad_names = used_names , $ post = strcompress ( string ( i ), / remove_all )) used_names = [ used_names , var_name ] d = create_struct ( d , var_name , var ) endif else begin d = create_struct ( d , create_nested_struct ( path , var )) endelse endif END ELSE : ENDCASE i = i + 1 endwhile return , d END FUNCTION read_hdf5 , filename , paths = paths , flatten = flatten , shallow = shallow ; +#read_hdf5 ; + Reads HDF5 file variables and attributes ; +*** ; +## Arguments ; + **filename**: HDF5 file ; + ; +## Keyword Arguments ; + **paths**: Paths to variables to be read ; + ; + **flatten**: Flatten tree structure ; + ; + **shallow**: Performs a shallow read i . e . no dataset / group attributes ; + ; +## Return Value ; + Structure containing variables and attributes ; + ; +## Example Usage ; + ``` idl ; + IDL > a = read_hdf5 ( \"./test_1a_geometry.h5\" ) ; + IDL > b = read_hdf5 ( \"./test_1a_geometry.h5\" , paths= \"/spec/lens\" , / flatten , / shallow ) ; + ``` if file_test ( filename ) then begin ;; Open file fid = h5f_open ( filename ) if not keyword_set ( paths ) then begin ;; Read group and sub - groups d = hdf5_read_group ( fid , shallow = shallow ) endif else begin ;; Read datasets from list d = hdf5_read_from_list ( fid , paths , flatten = flatten , shallow = shallow ) endelse ;; Close file h5f_close , fid endif else begin print , 'File does not exist' return , 0 endelse return , d END","tags":"","loc":"sourcefile/read_hdf5.pro.html","title":"read_hdf5.pro – FIDASIM"},{"text":"read_json Reads a JSON file that can have YAML like comments Arguments file : JSON file Return Value Structure containg JSON values Example Usage IDL > json_struct = read_json( \"./file.json\" ) Source Code read_json.pro Source Code FUNCTION tokenize , str , regex ;;; Splits string into tokens according to regex ;;; json = str group = [] start = [] finish = [] cnt = 0 while stregex ( json , regex , / BOOLEAN ) do begin pos = stregex ( json , regex , length = len ) tmp = strmid ( json , pos , len ) group = [ group , tmp ] if cnt eq 0 then begin start = [ start , pos ] finish = [ finish , pos + len ] endif else begin start = [ start , finish [ cnt - 1 ] + pos ] finish = [ finish , finish [ cnt - 1 ] + pos + len ] endelse json = strmid ( json , pos + len , strlen ( json )) cnt+= 1 endwhile return ,{ group : group , start : start , finish : finish } END FUNCTION json_minify , str ;;; Strips out C like comments out of JSON string ;;; ;;; Based of JSON . minify https : // github . com / getify / JSON . minify ;;; regex='\"|(#=)|(=#)|(#)|' + string ( 10 b ) +'|' + string ( 13 b ) slashes='(\\*$' in_string = 0 in_multi = 0 in_single = 0 new_str='' index = 0 tokenizer = tokenize ( str , regex ) for i = 0 , n_elements ( tokenizer . group ) - 1 do begin if not ( in_multi or in_single ) then begin tmp = strmid ( str , index , tokenizer . start [ i ] - index ) if not in_string then begin tmp = strcompress ( tmp , / remove_all ) tmp = strjoin ( strsplit ( tmp , string ( 10 b ), / extract , / regex ), '' ) tmp = strjoin ( strsplit ( tmp , string ( 13 b ), / extract , / regex ), '' ) endif new_str+=tmp endif index = tokenizer . finish [ i ] val = tokenizer . group [ i ] if val eq '\"' and not ( in_multi or in_single ) then begin escaped = stregex ( strmid ( str , 0 , tokenizer . start [ i ]), slashes , / EXTRACT ) if not in_string or ( escaped eq '' or strlen ( escaped ) mod 2 eq 0 ) then in_string = not in_string index-= 1 endif else if not ( in_string or in_multi or in_single ) then begin if val eq '#=' then in_multi = 1 else if val eq '#' then in_single = 1 endif else if val eq '=#' and in_multi and not ( in_string or in_single ) then begin in_multi = 0 endif else if ( stregex ( val , string ( 10 b ), / boolean ) or stregex ( val , string ( 13 b ), / boolean )) $ and not ( in_multi or in_string ) and in_single then begin in_single = 0 endif else if not (( in_multi or in_single ) or $ ( stregex ( val , string ( 10 b ), / boolean ) or $ stregex ( val , string ( 13 b ), / boolean ) or $ stregex ( val , string ( 9 b ), / boolean ) or $ stregex ( val , string ( 32 b ), / boolean ) )) then begin new_str+=val endif endfor new_str+= strmid ( str , index , strlen ( str ) - index ) return , new_str END FUNCTION read_json , file ; +#read_json ; + Reads a JSON file that can have YAML like comments ; +*** ; +## Arguments ; + **file**: JSON file ; + ; +## Return Value ; + Structure containg JSON values ; + ; +## Example Usage ; + ``` idl ; + IDL > json_struct = read_json ( \"./file.json\" ) ; + ``` openr , lun , file , / GET_LUN json='' tmp='' while not EOF ( lun ) do begin readf , lun , tmp json+=tmp json+= string ( 10 b ) endwhile free_lun , lun stripped_json = json_minify ( json ) return , json_parse ( stripped_json , / toarray , / tostruct ) END","tags":"","loc":"sourcefile/read_json.pro.html","title":"read_json.pro – FIDASIM"},{"text":"read_mc_nubeam Reads guiding center Monte Carlo NUBEAM fast-ion distribution file Arguments infile : NUBEAM Monte Carlo distribution file Keyword Arguments ntotal : Total number of fast-ions e_range : Energy range of particles to consider p_range : Pitch range of particles to consider particle_weight : Set particle/marker weight such that sum(particle_weights) = ntotal: Defaults to ntotal /nparticles btipsign : Sign of the dot product between the current and magnetic field (Required) Return Value Distribution structure Example Usage IDL > dist = read_spiral( \"./spiral_file.TXT\" ,time = 1.0 , ntotal = 1e19) Source Code read_mc_nubeam.pro Source Code FUNCTION read_mc_nubeam , infile , ntotal = ntotal , e_range = e_range , p_range = p_range , particle_weight = particle_weight , btipsign = btipsign ; +#read_mc_nubeam ; + Reads guiding center Monte Carlo NUBEAM fast - ion distribution file ; +*** ; +## Arguments ; + **infile**: NUBEAM Monte Carlo distribution file ; + ; +## Keyword Arguments ; + **ntotal**: Total number of fast - ions ; + ; + **e_range**: Energy range of particles to consider ; + ; + **p_range**: Pitch range of particles to consider ; + ; + **particle_weight**: Set particle / marker weight such that sum ( particle_weights ) = ntotal : Defaults to ` ntotal ` / nparticles ; + ; + **btipsign**: Sign of the dot product between the current and magnetic field ( Required ) ; + ; +## Return Value ; + Distribution structure ; + ; +## Example Usage ; + ``` idl ; + IDL > dist = read_spiral ( \"./spiral_file.TXT\" , time = 1.0 , ntotal = 1 e19 ) ; + ``` if not keyword_set ( btipsign ) then begin error , 'btipsign is not set.' , / halt endif if not keyword_set ( ntotal ) and not keyword_set ( particle_weight ) then begin warn , 'Ntotal not set. Setting arbitrarily to 1e19' ntotal = 1. d19 endif zzz = FINDFILE ( infile ) if zzz eq '' then begin error , 'Nonexistent file: ' + infile , / halt endif openr , unit , infile , / get_lun line=' ' readf , unit , line ; read string readf , unit , line pos = strpos ( line , 'N=' ) if pos eq - 1 then begin error , 'Second line is missing the number of points' , / halt endif w = stregex ( line , 'N *= *([0-9]*)' , / sub , / extract ) npts = long ( w [ 1 ]) if npts lt 5 then begin error , 'Too few points ' + strtrim ( npts , 2 ), / halt endif ; Get time readf , unit , line parts = str_sep ( line , ' ' ) w = where ( parts eq 'TIME' , nw ) if nw eq 0 then begin error , 'Time not found on 3rd line' , / halt endif i = 1 while 1 do begin s = parts [ w [ 0 ] + i ] if s ne '' and s ne '=' then begin time = float ( s ) break endif i = i + 1 endwhile data = fltarr ( 4 , npts ) ready = 0 while not ready do begin readf , unit , line ; Description line pos = strpos ( line , 'R(cm)' ) if pos gt - 1 then ready = 1 endwhile for i = 0 L , npts - 1 do begin readf , unit , line ; read string line = strcompress ( line ) parts = str_sep ( line , ' ' ) & np = n_elements ( parts ) if parts ( 0 ) eq '' then parts = shift ( parts , - 1 ) ; accommodate blank before 1 st while parts ( np - 1 ) eq '' do np = np - 1 if np ne 4 then begin error , 'Wrong number of entries on line: ' + line endif else begin data [ * , i ] = parts [ 0 :np - 1 ] endelse print , format='(f7.2,\"%\",A,$)' , 100.0 * ( i + 1 ) / float ( npts ), string ( 13 b ) endfor free_lun , unit r = double ( reform ( data [ 0 , 0 :npts - 1 ])) w = double ( reform ( data [ 1 , 0 :npts - 1 ])) pitch = double ( reform ( data [ 2 , 0 :npts - 1 ])) * btipsign energy = reform ( data [ 3 , 0 :npts - 1 ]) * 1. d - 3 ; keV orbit_class = replicate ( 1 , npts ) if not keyword_set ( particle_weight ) then begin particle_weight = ntotal / float ( npts ) endif weight = replicate ( particle_weight , npts ) if not keyword_set ( e_range ) then begin e_range = [ min ( energy ), max ( energy )] endif if not keyword_set ( p_range ) then begin p_range = [ min ( pitch ), max ( pitch )] endif ww = where ( energy ge e_range [ 0 ] and energy le e_range [ 1 ], nw ) if nw eq 0 then begin error , 'No particles fall in requested energy range' , / halt endif wwp = where ( pitch [ ww ] ge p_range [ 0 ] and pitch [ ww ] le p_range [ 1 ], nwp ) if nwp eq 0 then begin error , 'No particles fall in the requested pitch range' , / halt endif ww = ww [ wwp ] nw = n_elements ( ww ) print , 'Time: ' , time print , 'Number of markers: ' , npts print , 'Number of markers in phase space: ' , nw print , 'Total Number of Fast-ions in phase space: ' , particle_weight * nw fbm_struct = { type : 2 , time : double ( time ), data_source: file_expand_path ( infile ), $ nparticle : long ( nw ), nclass : 1 , r : r [ ww ], z : w [ ww ], $ energy : energy [ ww ], pitch : pitch [ ww ], class : orbit_class [ ww ], $ weight : weight [ ww ]} return , fbm_struct END","tags":"","loc":"sourcefile/read_mc_nubeam.pro.html","title":"read_mc_nubeam.pro – FIDASIM"},{"text":"read_ncdf Reads a flat NetCDF file Arguments file : NetCDF file Keyword Arguments vars : List of variables to read Return Value Structure containing NetCDF variables Example Usage IDL > a = read_ncdf( \"./123324H01_fi_1.cdf\" ) Source Code read_ncdf.pro Source Code FUNCTION read_ncdf , file , vars = vars ; +#read_ncdf ; + Reads a flat NetCDF file ; +*** ; +## Arguments ; + **file**: NetCDF file ; + ; +## Keyword Arguments ; + **vars**: List of variables to read ; + ; +## Return Value ; + Structure containing NetCDF variables ; + ; +## Example Usage ; + ``` idl ; + IDL > a = read_ncdf ( \"./123324H01_fi_1.cdf\" ) ; + ``` ;; List of reserved names reserved = [ 'AND' , 'BEGIN' , 'BREAK' , 'CASE' , 'COMMON' , 'COMPILE_OPT' , $ 'CONTINUE' , 'DO' , 'ELSE' , 'END' , 'ENDCASE' , 'ENDELSE' , $ 'ENDFOR' , 'ENDFOREACH' , 'ENDIF' , 'ENDREP' , 'ENDSWITCH' , 'ENDWHILE' , $ 'EQ' , 'FOR' , 'FOREACH' , 'FORWARD_FUNCTION' , 'FUNCTION' , 'GE' , $ 'GOTO' , 'GT' , 'IF' , 'INHERITS' , 'LE' , 'LT' , 'MOD' , 'NE' , 'NOT' , 'OF' , $ 'ON_IOERROR' , 'OR' , 'PRO' , 'REPEAT' , 'SWITCH' , 'THEN' , 'UNTIL' , $ 'WHILE' , 'X0R' ] d= { err : 1 } if file_test ( file ) then begin d . err = 0 ncid = ncdf_open ( file , / nowrite ) info = ncdf_inquire ( ncid ) if keyword_set ( vars ) then nvars = n_elements ( vars ) else nvars = info . nvars for i = 0 , nvars - 1 do begin if keyword_set ( vars ) then begin name = vars [ i ] CATCH , err_status if err_status ne 0 then begin CATCH , / CANCEL continue endif ncdf_varget , ncid , name , tmp endif else begin var_info = ncdf_varinq ( ncid , i ) name = var_info . name ncdf_varget , ncid , i , tmp endelse if total ( strmatch ( reserved , name , / FOLD_CASE )) gt 0 then name+='_' d = create_struct ( d , name , tmp ) endfor ncdf_close , ncid endif else message , 'FILE DOES NOT EXIST: ' + file return , d END","tags":"","loc":"sourcefile/read_ncdf.pro.html","title":"read_ncdf.pro – FIDASIM"},{"text":"read_nubeam Reads NUBEAM fast-ion distribution function Arguments filename : NUBEAM guiding center fast-ion distribution function file e.g. 159245H01_fi_1.cdf grid : Interpolation grid Keyword Arguments btipsign : Sign of the dot product of the magnetic field and plasma current e_range : Energy range to consider p_range : Pitch range to consider Return Value Distribution structure Example Usage IDL > dist = read_nubeam( \"./159245H02_fi_1.cdf\" ,grid,btipsign =- 1 ) Source Code read_nubeam.pro Source Code FUNCTION grid_fbm , r2d , z2d , fbm , fdens , rout , zout compile_opt idl2 , logical_predicate s = size ( fbm , / dim ) nenergy = s [ 0 ] npitch = s [ 1 ] nr = n_elements ( rout ) nz = n_elements ( zout ) nr2d = n_elements ( r2d ) dim = [ nr , nz ] delta = abs ([ rout [ 1 ] - rout [ 0 ], zout [ 1 ] - zout [ 0 ]]) start = [ min ( rout ), min ( zout )] triangulate , r2d , z2d , tr index = lindgen ( n_elements ( tr )) / 3 * 3 r2dt = r2d [ tr [ * ]] z2dt = z2d [ tr [ * ]] linTr = lindgen ( size ( tr , / dim )) tr_num = round ( griddata ( r2dt , z2dt , float ( index ), triangles = linTr , / linear , $ start = start , delta = delta , dimension = dim )) wts = ptrarr ( 3 ) for i = 0 , 2 do begin w = griddata ( r2dt , z2dt ,( lindgen ( n_elements ( r2dt )) mod 3 ) eq i , triangles = linTr , / linear , $ start = start , delta = delta , dimension = dim ) wts [ i ] = ptr_new ( w , / no_copy ) endfor denf = dblarr ( nr , nz ) for i = 0 , 2 do begin denf = denf + fdens [ tr [ tr_num + i ]] * ( * wts [ i ]) endfor denf = denf > 0 fbm_grid = dblarr ( nenergy , npitch , nr , nz ) for i = 0 , nenergy - 1 do begin for j = 0 , npitch - 1 do begin for k = 0 , 2 do begin fbm_grid [ i , j , * , * ] = fbm_grid [ i , j , * , * ] + fbm [ i , j , tr [ tr_num + k ]] * ( * wts [ k ]) endfor endfor endfor fbm_grid = fbm_grid > 0 return , { denf : denf , fbm : fbm_grid } END FUNCTION read_nubeam , filename , grid , btipsign = btipsign , e_range = e_range , p_range = p_range ; +#read_nubeam ; + Reads NUBEAM fast - ion distribution function ; +*** ; +## Arguments ; + **filename**: NUBEAM guiding center fast - ion distribution function file e . g . 159245 H01_fi_1 . cdf ; + ; + **grid**: Interpolation grid ; + ; +## Keyword Arguments ; + **btipsign**: Sign of the dot product of the magnetic field and plasma current ; + ; + **e_range**: Energy range to consider ; + ; + **p_range**: Pitch range to consider ; + ; +## Return Value ; + Distribution structure ; + ; +## Example Usage ; + ``` idl ; + IDL > dist = read_nubeam ( \"./159245H02_fi_1.cdf\" , grid , btipsign=- 1 ) ; + ``` if not keyword_set ( btipsign ) then btipsign = - 1 cdftest = findfile ( filename ) if cdftest [ 0 ] eq '' then begin err = 1 goto , GET_OUT endif vars = read_ncdf ( filename , vars = [ \"TIME\" , \"R2D\" , \"Z2D\" , \"E_D_NBI\" , \"A_D_NBI\" , $ \"F_D_NBI\" , \"RSURF\" , \"ZSURF\" , \"BMVOL\" ]) ngrid = n_elements ( vars . r2d ) ;; ------------- Convert eV-> keV time = vars . time r2d = vars . r2d z2d = vars . z2d rsurf = vars . rsurf zsurf = vars . zsurf pitch = vars . a_d_nbi energy = vars . e_d_nbi * 1.0 d - 3 ;; fidasim needs energy in kev fbm = vars . f_d_nbi * 1.0 d3 ;; now , this needs to be corrected ;; as we now calculate with fast - ions / omega / keV / cm&#94; 3 ;; ------------ Convert d_omega --> pitch ;; Fast - ion distribution is given as a function of cm&#94; 3 , energy ;; and d_omega / 4 Pi . omega is the solild angle in 3 D velocity space . In ;; order to transform this to a function depending on pitch instead ;; of d_omega / 4 PI , one has to multiply by 0.5 ! fbm*= 0.5 ;; make sure that fbm is >= 0 : fbm >= 0. ;; loading finished ;; TRANSP defines the pitch along the current direction . In ;; contrast , FIDASIM uses pitch along the B - field ! Therefore , ;; reverse the pitch coordinate in fbm if B and J are anti - parallel ! if btipsign lt 0 then begin npitch = n_elements ( pitch ) index = npitch- ( indgen ( npitch ) + 1 ) fbm [ * , * , * ] = fbm [ * , index , * ] endif if not keyword_set ( e_range ) then begin e_range = [ min ( energy ), max ( energy )] endif if not keyword_set ( p_range ) then begin p_range = [ min ( pitch ), max ( pitch )] endif ;; ----------- select energy range ------- index = where ( energy ge e_range [ 0 ] and energy le e_range [ 1 ], nenergy ) energy = energy [ index ] fbm = fbm [ index , * , * ] dE = energy [ 1 ] - energy [ 0 ] emin= ( float ( energy [ 0 ]) - float ( 0.5 * dE )) > 0. emax = float ( energy [ nenergy - 1 ]) + float ( 0.5 * dE ) print , 'Energy min/max:' , emin , emax ;; --------- select Pitch range -------- index = where ( pitch ge p_range [ 0 ] and pitch le p_range [ 1 ], npitch ) pitch = pitch [ index ] fbm = fbm [ * , index , * ] dP = abs ( pitch [ 1 ] - pitch [ 0 ]) pmin= ( float ( pitch [ 0 ]) - float ( 0.5 * dP )) > ( - 1 ) pmax= ( float ( pitch [ npitch - 1 ]) + float ( 0.5 * dP )) < 1 print , 'Pitch  min/max:' , pmin , pmax ;; ------map fdens on FIDASIM grid and sort out ;; ------points outside the separatrix nr = grid . nr nz = grid . nz rgrid = grid . r zgrid = grid . z dr = abs ( rgrid [ 1 ] - rgrid [ 0 ]) dz = abs ( zgrid [ 1 ] - zgrid [ 0 ]) ;; FBM & DENF fdens = total ( reform ( total ( fbm , 1 )), 1 ) * dE * dP ntot = total ( fdens * vars . bmvol ) print , 'Ntotal in phase space: ' , ntot fstr = grid_fbm ( r2d , z2d , fbm , fdens , rgrid , zgrid ) denf = fstr . denf fbm_grid = fstr . fbm ;; enforce correct normalization ntot_denf = ( 2 * ! dpi * dr * dz ) * total ( rgrid * total ( denf , 2 )) denf = denf* ( ntot / ntot_denf ) ntot_fbm = ( 2 * ! dpi * dr * dz * dE * dP ) * total ( rgrid * total ( total ( total ( fbm_grid , 1 ), 1 ), 2 )) fbm_grid = fbm_grid* ( ntot / ntot_fbm ) ;; sort out positions more than 2 cm outside the separatrix rmaxis = mean ( rsurf [ * , 0 ]) zmaxis = mean ( zsurf [ * , 0 ]) rsep = rsurf [ * ,( size ( rsurf ))[ 2 ] - 1 ] zsep = zsurf [ * ,( size ( rsurf ))[ 2 ] - 1 ] x_bdry = rsep - rmaxis y_bdry = zsep - zmaxis r_bdry = sqrt ( x_bdry&#94; 2 + y_bdry&#94; 2 ) theta = atan ( y_bdry , x_bdry ) ;; -- sort and remove identical values -- index = uniq ( theta , sort ( theta )) theta = theta [ index ] r = r_bdry [ index ] ;; --- make theta periodic n = n_elements ( r ) r_bdry = fltarr ( n + 2 ) theta_bdry = fltarr ( n + 2 ) theta_bdry [ 1 :n ] = theta r_bdry [ 1 :n ] = r r_bdry [ 0 ] = r [ n - 1 ] theta_bdry [ 0 ] = theta [ n - 1 ] - 2. * ! pi r_bdry [ n + 1 ] = r [ 0 ] theta_bdry [ n + 1 ] = theta [ 0 ] + 2. * ! pi ;; -- express ( r_pts , z_pts ) in ( r , theta ) coordinates -- x_pts = grid . r2d - rmaxis y_pts = grid . z2d - zmaxis r_pts = sqrt ( x_pts&#94; 2 + y_pts&#94; 2 ) theta_pts = atan ( y_pts , x_pts ) ;; -- interpolate to get the radial position of the boundary ;; evaluated at theta = theta_pts -- index = sort ( theta_pts ) mapped = interpol ( r_bdry , theta_bdry , theta_pts [ index ]) r_boundary = theta_pts * 0. d r_boundary [ index ] = mapped index = where ( r_pts gt r_boundary + 2. , nind ) if nind gt 0 then begin indices = array_indices ( r_pts , index ) for i = 0 ,( size ( indices ))[ 2 ] - 1 do begin fbm_grid [ * , * , indices [ 0 , i ], indices [ 1 , i ]] = 0. endfor endif fbm_struct= { type : 1 , time : time , nenergy : fix ( nenergy ), energy : energy , npitch : fix ( npitch ), $ pitch : pitch , f : fbm_grid , denf : denf , data_source: file_expand_path ( filename )} return , fbm_struct GET_OUT : END","tags":"","loc":"sourcefile/read_nubeam.pro.html","title":"read_nubeam.pro – FIDASIM"},{"text":"This file contains the procedure to read SPIRAL fast-ion distribution file read_spiral Reads SPIRAL guiding center fast-ion distribution file Arguments file : SPIRAL output file Keyword Arguments time : Time [s] ntotal : Total number of fast-ions e_range : Energy range of particles to consider p_range : Pitch range of particles to consider particle_weight : Set particle/marker weight such that sum(particle_weights) = ntotal: Defaults to ntotal /nparticles btipsign : Sign of the dot product between the current and magnetic field (Required) Return Value Distribution structure Example Usage IDL > dist = read_mc_nubeam( \"./mc_159243H06_9\" ,ntotal = 1e19) Source Code read_spiral.pro Source Code FUNCTION read_spiral_header , file openr , lun , file , / get_lun npart = 0 gc = 0 err = 0 nheader = 0 line = '' header = '' readf , lun , line while strmid ( line , 0 , 1 ) eq ';' do begin nheader = nheader + 1 header = header + line + string ( 10 B ) if stregex ( line , \"number\" , / fold_case ) ne - 1 then begin npart = long ( stregex ( line , \"[0-9]+\" , / extract )) endif if stregex ( line , \"guiding center\" , / fold_case ) ne - 1 then begin gc = 1 endif if stregex ( line , \"R_[m]\" , / fold_case ) ne - 1 then begin if n_elements ( strsplit ( line )) ne 6 then begin err = 1 endif endif line = '' readf , lun , line endwhile free_lun , lun if gc eq 0 then begin error , 'Not a guiding center distribution' , / halt endif if npart eq 0 then begin error , 'Number of particles le 0' , / halt endif return , { nheader : nheader , npart : npart , header : header } END FUNCTION finite_struct , s n = N_TAGS ( s ) for i = 0 , n - 1 do begin if finite ( s .( i )) ne 1 then return , 0 endfor return , 1 END ; + This file contains the procedure to read SPIRAL fast - ion distribution file FUNCTION read_spiral , file , time = time , ntotal = ntotal , e_range = e_range , p_range = p_range , $ particle_weight = particle_weight , btipsign = btipsign ; +#read_spiral ; + Reads SPIRAL guiding center fast - ion distribution file ; +*** ; +## Arguments ; + **file**: SPIRAL output file ; + ; +## Keyword Arguments ; + **time**: Time [ s ] ; + ; + **ntotal**: Total number of fast - ions ; + ; + **e_range**: Energy range of particles to consider ; + ; + **p_range**: Pitch range of particles to consider ; + ; + **particle_weight**: Set particle / marker weight such that sum ( particle_weights ) = ntotal : Defaults to ` ntotal ` / nparticles ; + ; + **btipsign**: Sign of the dot product between the current and magnetic field ( Required ) ; + ; +## Return Value ; + Distribution structure ; + ; +## Example Usage ; + ``` idl ; + IDL > dist = read_mc_nubeam ( \"./mc_159243H06_9\" , ntotal = 1 e19 ) ; + ``` if not keyword_set ( btipsign ) then begin error , 'btipsign is not set.' , / halt endif if not file_test ( file ) then begin error , 'Nonexistent file: ' + file , / halt endif if not keyword_set ( ntotal ) and not keyword_set ( particle_weight ) then begin print , 'WARNING: ntotal is not set. Setting arbitrarily to 1e19' ntotal = 1. d19 endif if not keyword_set ( time ) then begin print , 'WARNING: Time is not set for SPIRAL distribution. Setting to 0.0 [s]' time = 0. d0 endif header = read_spiral_header ( file ) npart = header . npart nhead = header . nheader openr , unit , file , / get_lun ; Read header head = strarr ( nhead ) readf , unit , head ; Read in data r = dblarr ( npart ) z = dblarr ( npart ) phi = dblarr ( npart ) energy = dblarr ( npart ) pitch = dblarr ( npart ) cnt = 0 L for i = 0 , npart - 1 do begin s = { r : double ( 0 ), phi : double ( 0 ), z : double ( 0 ), energy : double ( 0 ), pitch : double ( 0 )} readf , unit , s if not finite_struct ( s ) then begin continue endif else begin r [ cnt ] = s . r * 100 phi [ cnt ] = s . phi z [ cnt ] = s . z * 100 energy [ cnt ] = s . energy pitch [ cnt ] = s . pitch * btipsign ; SPIRAL pitch is defined relative to current cnt = cnt + 1 endelse endfor free_lun , unit npart = cnt r = r [ 0 :npart - 1 ] z = z [ 0 :npart - 1 ] phi = phi [ 0 :npart - 1 ] energy = energy [ 0 :npart - 1 ] pitch = pitch [ 0 :npart - 1 ] orbit_class = replicate ( 1 , npart ) if not keyword_set ( particle_weight ) then begin weight = replicate ( Ntotal / float ( npart ), npart ) endif else begin weight = replicate ( particle_weight , npart ) endelse if not keyword_set ( e_range ) then begin e_range = [ min ( energy ), max ( energy )] endif if not keyword_set ( p_range ) then begin p_range = [ min ( pitch ), max ( pitch )] endif ww = where ( energy ge e_range [ 0 ] and energy le e_range [ 1 ], nw ) if nw eq 0 then begin error , 'No particles fall in requested energy range' , / halt endif wwp = where ( pitch [ ww ] ge p_range [ 0 ] and pitch [ ww ] le p_range [ 1 ], nwp ) if nwp eq 0 then begin error , 'No particles fall in the requested pitch range' , / halt endif ww = ww [ wwp ] nw = n_elements ( ww ) print , 'Number of markers: ' , npart print , 'Number of markers in phase space: ' , nw dist_struct = { type : 2 , time : time , data_source: file_expand_path ( file ), $ nparticle : long ( nw ), nclass : 1 , r : r [ ww ], z : z [ ww ], phi : phi [ ww ], $ energy : energy [ ww ], pitch : pitch [ ww ], class : orbit_class [ ww ], $ weight : weight [ ww ]} return , dist_struct END","tags":"","loc":"sourcefile/read_spiral.pro.html","title":"read_spiral.pro – FIDASIM"},{"text":"rz_grid Creates interpolation grid Arguments rmin : Minimum radius [cm] rmax : Maximum radius [cm] nr : Number of radii zmin : Minimum Z value [cm] zmax : Maximum Z value [cm] nz : Number of z values Return Value Interpolation grid structure Example Usage IDL > grid = rz_grid( 0 , 200.0 , 200 , - 100 , 100 , 200 ) Source Code rz_grid.pro Source Code FUNCTION rz_grid , rmin , rmax , nr , zmin , zmax , nz ; +#rz_grid ; + Creates interpolation grid ; +*** ; +## Arguments ; + **rmin**: Minimum radius [ cm ] ; + ; + **rmax**: Maximum radius [ cm ] ; + ; + **nr**: Number of radii ; + ; + **zmin**: Minimum Z value [ cm ] ; + ; + **zmax**: Maximum Z value [ cm ] ; + ; + **nz**: Number of z values ; + ; +## Return Value ; + Interpolation grid structure ; + ; +## Example Usage ; + ``` idl ; + IDL > grid = rz_grid ( 0 , 200.0 , 200 , - 100 , 100 , 200 ) ; + ``` dr = ( rmax - rmin ) / ( nr - 1 ) dz = ( zmax - zmin ) / ( nz - 1 ) r = rmin + dr * dindgen ( nr ) z = zmin + dz * dindgen ( nz ) r2d = r # replicate ( 1 , nz ) z2d = replicate ( 1 , nr ) # z grid = { r2d:r2d , z2d:z2d , r : r , z : z , nr : nr , nz : nz } return , grid END","tags":"","loc":"sourcefile/rz_grid.pro.html","title":"rz_grid.pro – FIDASIM"},{"text":"save_to_hdf5 Converts an IDL save file to a HDF5 file Arguments savefile : IDL save file Keyword Arguments filename : HDF5 file name defaults to IDL save file name Example Usage IDL > sav_to_hdf5, './dne159245.00500' Source Code sav_to_hdf5.pro Source Code PRO sav_to_hdf5 , savefile , filename = filename ; +#save_to_hdf5 ; + Converts an IDL save file to a HDF5 file ; +*** ; +## Arguments ; + **savefile**: IDL save file ; + ; +## Keyword Arguments ; + **filename**: HDF5 file name defaults to IDL save file name ; + ; +## Example Usage ; + ``` idl ; + IDL > sav_to_hdf5 , './dne159245.00500' ; + ``` if not keyword_set ( filename ) then begin p = strsplit ( savefile , '.' , / extract ) if strlowcase ( p [ - 1 ]) eq 'sav' then c = 2 else c = 1 filename = strjoin ( p [ 0 : n_elements ( p ) - c ], '.' ) +'.h5' endif restore , savefile sObj = OBJ_NEW ( 'IDL_Savefile' , savefile ) vars = strlowcase ( sObj-> Names ()) write_hdf5 , vars , filename = filename END","tags":"","loc":"sourcefile/sav_to_hdf5.pro.html","title":"sav_to_hdf5.pro – FIDASIM"},{"text":"Returns the source file of the routine name If name is not given then it returns the source file of caller routine Source Code source_file.pro Source Code FUNCTION source_file , name ; + Returns the source file of the routine ` name ` ; + If name is not given then it returns the source file of caller routine if N_PARAMS () eq 0 then begin s = scope_traceback ( / structure ) nlevels = n_elements ( s ) sfile = s [ nlevels - 2 ]. filename return , file_expand_path ( sfile ) endif else begin help , / source_files , output = csf ; all compiled source files nc = n_elements ( csf ) for i = 2 , nc - 1 do begin has_name = stregex ( csf [ i ], name , / fold_case ) ne - 1 if has_name then begin sfile = stregex ( csf [ i ], \"(/[&#94;/ ]*)+/?$\" , / extract , / fold_case ) return , file_expand_path ( sfile ) endif endfor endelse return , '' END","tags":"","loc":"sourcefile/source_file.pro.html","title":"source_file.pro – FIDASIM"},{"text":"success, str Print a success message Arguments str : message Example Usage IDL > success, \"Yay!!!\" Source Code success.pro Source Code PRO success , str ; +## ` success , str ` ; + Print a success message ; +### Arguments ; + **str**: message ; + ; +### Example Usage ; + ``` idl ; + IDL > success , \"Yay!!!\" ; + ``` print , colored ( 'SUCCESS: ' + str , c='g' ) END","tags":"","loc":"sourcefile/success.pro.html","title":"success.pro – FIDASIM"},{"text":"tb_zyx Calculates Tait-Bryan z-y'-x\" active rotation matrix given rotation angles alpha , beta , gamma in radians Arguments alpha : rotation angle about z [radians] beta : rotation angle about y' [radians] gamma : rotation angle about x\" [radians] Return Value Rotation Matrix prefida Example Usage IDL > rot_mat = tb_zyx(!DPI / 2 , 0.0 , !DPI / 3 ) Source Code tb_zyx.pro Source Code FUNCTION tb_zyx , a , b , g ; +#tb_zyx ; + Calculates Tait - Bryan z - y'-x\" active rotation matrix given rotation angles `alpha`,`beta`,`gamma` in radians ;+##Arguments ;+     **alpha**: rotation angle about z [radians] ;+ ;+     **beta**: rotation angle about y' [ radians ] ; + ; + **gamma**: rotation angle about x \" [ radians ] ; + ; +## Return Value ; + Rotation Matrix [ prefida ](| url | / sourcefile / prefida . pro . html ) ; + ; +## Example Usage ; + ``` idl ; + IDL > rot_mat = tb_zyx (! DPI / 2 , 0.0 , ! DPI / 3 ) ; + ``` sa = sin ( a ) & ca = cos ( a ) sb = sin ( b ) & cb = cos ( b ) sg = sin ( g ) & cg = cos ( g ) R = dblarr ( 3 , 3 ) R [ 0 , 0 ] = ca * cb & R [ 1 , 0 ] = ca * sb * sg - cg * sa & R [ 2 , 0 ] = sa * sg + ca * cg * sb R [ 0 , 1 ] = cb * sa & R [ 1 , 1 ] = ca * cg + sa * sb * sg & R [ 2 , 1 ] = cg * sa * sb - ca * sg R [ 0 , 2 ] = - sb & R [ 1 , 2 ] = cb * sg & R [ 2 , 2 ] = cb * cg return , R END","tags":"","loc":"sourcefile/tb_zyx.pro.html","title":"tb_zyx.pro – FIDASIM"},{"text":"tile_array(arr, ncol, nrow) Creates a tiled matrix out of an array or matrix Arguments arr : Array or Matrix of size (nx,ny) to be tiled ncol : Number of columns in the tile nrow : Number of rows in the tile Return Value Tiled array of size (ncol nx,nrow ny) Example Usage IDL > arr = indgen ( 2 , 2 )\nIDL > print , arr 0 1 2 3 IDL > tiled_arr = tile_array(arr, 2 , 2 )\nIDL > print , tiled_arr 0 1 0 1 2 3 2 3 0 1 0 1 2 3 2 3 Source Code tile_array.pro Source Code FUNCTION tile_array , arr , ncol , nrow ; +## ` tile_array ( arr , ncol , nrow ) ` ; + Creates a tiled matrix out of an array or matrix ; +### Arguments ; + **arr**: Array or Matrix of size ( nx , ny ) to be tiled ; + ; + **ncol**: Number of columns in the tile ; + ; + **nrow**: Number of rows in the tile ; + ; +### Return Value ; + Tiled array of size ( ncol * nx , nrow * ny ) ; + ; +### Example Usage ; + ``` idl ; + IDL > arr = indgen ( 2 , 2 ) ; + IDL > print , arr ; + 0 1 ; + 2 3 ; + IDL > tiled_arr = tile_array ( arr , 2 , 2 ) ; + IDL > print , tiled_arr ; + 0 1 0 1 ; + 2 3 2 3 ; + 0 1 0 1 ; + 2 3 2 3 ; + ``` s = size ( arr , / dim ) if n_elements ( s ) eq 1 then s = [ s , 1 ] new_arr = make_array ( s [ 0 ] * ncol , s [ 1 ] * nrow , type = size ( arr , / type )) new_arr [ 0 , 0 ] = arr if nrow gt 1 then begin for i = 1 , nrow - 1 do begin new_arr [ 0 , i * s [ 1 ]] = arr endfor endif if ncol gt 1 then begin rarr = new_arr [ 0 :s [ 0 ] - 1 , * ] for j = 1 , ncol - 1 do begin new_arr [( j * s [ 0 ]), 0 ] = rarr endfor endif return , new_arr END","tags":"","loc":"sourcefile/tile_array.pro.html","title":"tile_array.pro – FIDASIM"},{"text":"uvw_to_xyz(alpha, beta, gamma, uvw, origin=[0,0,0]) Express non-rotated coordinate uvw in rotated xyz coordinates Arguments alpha : Rotation angle about z [radians] beta : Rotation angle about y' [radians] gamma : Rotation angle about x\" [radians] xyz : Point in rotated coordinate system Keyword Arguments origin : Origin of rotated coordinate system in non-rotated (uvw) coordinates. Example Usage IDL > xyz = uvw_to_xyz(!DPI / 2 , 0.0 ,!DPI / 3 ,uvw) Source Code uvw_to_xyz.pro Source Code FUNCTION uvw_to_xyz , alpha , beta , gamma , uvw , origin = origin ; +## ` uvw_to_xyz ( alpha , beta , gamma , uvw , origin = [ 0 , 0 , 0 ]) ` ; + Express non - rotated coordinate ` uvw ` in rotated ` xyz ` coordinates ; +### Arguments ; + **alpha**: Rotation angle about z [ radians ] ; + ; + **beta**: Rotation angle about y ' [ radians ] ; + ; + **gamma**: Rotation angle about x \" [ radians ] ; + ; + **xyz**: Point in rotated coordinate system ; + ; +### Keyword Arguments ; + **origin**: Origin of rotated coordinate system in non - rotated ( uvw ) coordinates . ; + ; +### Example Usage ; + ``` idl ; + IDL > xyz = uvw_to_xyz (! DPI / 2 , 0.0 ,! DPI / 3 , uvw ) ; + ``` if not keyword_set ( origin ) then origin = [ 0.0 , 0.0 , 0.0 ] s = size ( uvw , / dim ) if n_elements ( s ) ne 2 then s = [ s , 1 ] uvw_shifted = transpose ( uvw - tile_array ( origin , 1 , s [ 1 ])) R = transpose ( tb_zyx ( alpha , beta , gamma )) xyz = R ##uvw_shifted return , transpose ( xyz ) END","tags":"","loc":"sourcefile/uvw_to_xyz.pro.html","title":"uvw_to_xyz.pro – FIDASIM"},{"text":"vars_to_struct Creates a structure containing the variables in the callers scope Keyword Arguments vars : List of variables to store in the output structure. Defaults to all variables in the callers scope. level : Relative scope. Defaults to the callers scope (-1) Return Value Structure containing variables from the callers scope Example Usage IDL > a = 1 IDL > b = \"hello\" IDL > s = vars_to_struct() ; structure containing `a` & `b` Source Code vars_to_struct.pro Source Code FUNCTION vars_to_struct , vars = vars , level = level ; +#vars_to_struct ; + Creates a structure containing the variables in the callers scope ; + ; +## Keyword Arguments ; + **vars**: List of variables to store in the output structure . Defaults to all variables in the callers scope . ; + ; + **level**: Relative scope . Defaults to the callers scope ( - 1 ) ; + ; +## Return Value ; + Structure containing variables from the callers scope ; + ; +## Example Usage ; + ``` idl ; + IDL > a = 1 ; + IDL > b = \"hello\" ; + IDL > s = vars_to_struct () ; structure containing ` a ` & ` b ` ; + ``` if not keyword_set ( level ) then level=- 1 if not keyword_set ( vars ) then vars = scope_varname ( level = level ) nvars = n_elements ( vars ) for i = 0 , nvars - 1 do begin catch , err_status if err_status ne 0 then begin catch , / cancel continue endif var = scope_varfetch ( vars [ i ], level = level ) if n_elements ( var ) ne 0 then begin if i eq 0 then begin s = create_struct ( vars [ i ], var ) endif else begin s = create_struct ( s , vars [ i ], var ) endelse endif endfor if nvars eq 1 and size ( s .( 0 ), / tname ) eq 'STRUCT' then begin s = s .( 0 ) endif return , s END","tags":"","loc":"sourcefile/vars_to_struct.pro.html","title":"vars_to_struct.pro – FIDASIM"},{"text":"warn, str Print a warning message Arguments str : message Example Usage IDL > warn, \"This may be a problem\" Source Code warn.pro Source Code PRO warn , str ; +## ` warn , str ` ; + Print a warning message ; +### Arguments ; + **str**: message ; + ; +### Example Usage ; + ``` idl ; + IDL > warn , \"This may be a problem\" ; + ``` print , colored ( 'WARNING: ' + str , c='y' ) END","tags":"","loc":"sourcefile/warn.pro.html","title":"warn.pro – FIDASIM"},{"text":"write_distribution, filename, dist Write fast-ion distribution to a HDF5 file Input Arguments filename : Name of the distribution file dist : Fast-ion distribution structure Example Usage IDL > write_distribution, filename, distri Source Code write_distribution.pro Source Code PRO write_distribution , filename , distri ; +## ` write_distribution , filename , dist ` ; + Write fast - ion distribution to a HDF5 file ; + ; +### Input Arguments ; + **filename**: Name of the distribution file ; + ; + **dist**: Fast - ion distribution structure ; + ; +### Example Usage ; + ``` idl ; + IDL > write_distribution , filename , distri ; + ``` info , 'Writing fast-ion distribution file...' root_atts = { attribute , obj : '/' , $ name : 'description' , $ data : 'Fast-ion distribution for FIDASIM' } cs_desc = { attribute , obj : '/' , $ name : 'coordinate_system' , $ data : 'Cylindrical' } ds_desc = { attribute , obj : '/data_source' , $ name : 'description' , $ data : 'Source of the fast-ion distribution' } type_desc = { attribute , obj : '/type' , $ name : 'description' , $ data : 'Distribution type: ' + $ '1=\"Guiding Center Density Function\", ' + $ '2=\"Guiding Center Monte Carlo\", ' + $ '3=\"Full Orbit Monte Carlo\"' } time_desc = { attribute , obj : '/time' , $ name : 'description' , $ data : 'Distribution time' } time_unit = { attribute , obj : '/time' , $ name : 'units' , $ data : 's' } type = distri . type if type eq 1 then begin nen_desc = { attribute , obj : '/nenergy' , $ name : 'description' , $ data : 'Number of energy values' } np_desc = { attribute , obj : '/npitch' , $ name : 'description' , $ data : 'Number of pitch values' } energy_desc = { attribute , obj : '/energy' , $ name : 'description' , $ data : 'Energy' } energy_unit = { attribute , obj : '/energy' , $ name : 'units' , $ data : 'keV' } pitch_desc = { attribute , obj : '/pitch' , $ name : 'description' , $ data : 'Pitch: p = v_parallel/v  w.r.t. the magnetic field' } f_desc = { attribute , obj : '/f' , $ name : 'description' , $ data : 'Fast-ion density function: F(E,p,R,Z)' } f_unit = { attribute , obj : '/f' , $ name : 'units' , $ data : 'fast-ions/(dE*dP*cm&#94;3)' } denf_desc = { attribute , obj : '/denf' , $ name : 'description' , $ data : 'Fast-ion density: Denf(r,z)' } denf_unit = { attribute , obj : '/denf' , $ name : 'units' , $ data : 'cm&#94;-3' } nr_desc = { attribute , obj : '/nr' , $ name : 'description' , $ data : 'Number of R values' } nz_desc = { attribute , obj : '/nz' , $ name : 'description' , $ data : 'Number of Z values' } r_desc = { attribute , obj : '/r' , $ name : 'description' , $ data : 'Radius' } r_unit = { attribute , obj : '/r' , $ name : 'units' , $ data : 'cm' } z_desc = { attribute , obj : '/z' , $ name : 'description' , $ data : 'Z' } z_unit = { attribute , obj : '/z' , $ name : 'units' , $ data : 'cm' } r2d_desc = { attribute , obj : '/r2d' , $ name : 'description' , $ data : 'Radius grid: R(r,z)' } r2d_unit = { attribute , obj : '/r2d' , $ name : 'units' , $ data : 'cm' } z2d_desc = { attribute , obj : '/z2d' , $ name : 'description' , $ data : 'Z grid: Z(r,z)' } z2d_unit = { attribute , obj : '/z2d' , $ name : 'units' , $ data : 'cm' } atts = [ root_atts , cs_desc , ds_desc , $ type_desc , time_desc , time_unit , $ nen_desc , np_desc , $ energy_desc , energy_unit , $ pitch_desc , $ f_desc , f_unit , $ denf_desc , denf_unit , $ nr_desc , nz_desc , $ r_desc , r_unit , $ z_desc , z_unit , $ r2d_desc , r2d_unit , $ z2d_desc , z2d_unit ] endif else begin np_desc = { attribute , obj : '/nparticle' , $ name : 'description' , $ data : 'Number of MC particles' } nc_desc = { attribute , obj : '/nclass' , $ name : 'description' , $ data : 'Number of orbit classes' } r_desc = { attribute , obj : '/r' , $ name : 'description' , $ data : 'R position of a MC particle' } r_unit = { attribute , obj : '/r' , $ name : 'units' , $ data : 'cm' } z_desc = { attribute , obj : '/z' , $ name : 'description' , $ data : 'Z position of a MC particle' } z_unit = { attribute , obj : '/z' , $ name : 'units' , $ data : 'cm' } w_desc = { attribute , obj : '/weight' , $ name : 'description' , $ data : 'Weight of a MC particle: sum(weight) = # of fast-ions ' } w_unit = { attribute , obj : '/weight' , $ name : 'units' , $ data : 'fast-ions/particle' } c_desc = { attribute , obj : '/class' , $ name : 'description' , $ data : 'Orbit class of a MC particle: class in Set(1:nclass)' } if type eq 2 then begin energy_desc = { attribute , obj : '/energy' , $ name : 'description' , $ data : 'Energy of a MC particle' } energy_unit = { attribute , obj : '/energy' , $ name : 'units' , $ data : 'keV' } pitch_desc = { attribute , obj : '/pitch' , $ name : 'description' , $ data : 'Pitch of a MC particle: p = v_parallel/v  w.r.t. the magnetic field' } type_atts = [ energy_desc , energy_unit , pitch_desc ] endif else begin vr_desc = { attribute , obj : '/vr' , $ name : 'description' , $ data : 'Radial velocity of a MC particle' } vr_unit = { attribute , obj : '/vr' , $ name : 'units' , $ data : 'cm/s' } vt_desc = { attribute , obj : '/vt' , $ name : 'description' , $ data : 'Torodial velocity of a MC particle' } vt_unit = { attribute , obj : '/vt' , $ name : 'units' , $ data : 'cm/s' } vz_desc = { attribute , obj : '/vz' , $ name : 'description' , $ data : 'Z velocity of a MC particle' } vz_unit = { attribute , obj : '/vz' , $ name : 'units' , $ data : 'cm/s' } type_atts = [ vr_desc , vr_unit , vt_desc , vt_unit , vz_desc , vz_unit ] endelse atts = [ root_atts , cs_desc , ds_desc , $ type_desc , time_desc , time_unit , $ np_desc , nc_desc , $ r_desc , r_unit , $ z_desc , z_unit , $ w_desc , w_unit , $ c_desc , type_atts ] endelse write_hdf5 , distri , filename = filename , atts = atts , / clobber , compress = 4 if file_test ( filename ) then begin success , 'Distribution file created: ' + filename endif else begin error , 'Distribution file creation failed.' endelse END","tags":"","loc":"sourcefile/write_distribution.pro.html","title":"write_distribution.pro – FIDASIM"},{"text":"write_equilibrium, filename, plasma, fields Write MHD equilibrium values to a HDF5 file Input Arguments filename : Name of the equilibrium file plasma : Plasma structure fields : Electromagnetic fields structure Example Usage IDL > write_equilibrium, filename, plasma, fields Source Code write_equilibrium.pro Source Code PRO write_equilibrium , filename , plasma , fields ; +## ` write_equilibrium , filename , plasma , fields ` ; + Write MHD equilibrium values to a HDF5 file ; + ; +### Input Arguments ; + **filename**: Name of the equilibrium file ; + ; + **plasma**: Plasma structure ; + ; + **fields**: Electromagnetic fields structure ; + ; +### Example Usage ; + ``` idl ; + IDL > write_equilibrium , filename , plasma , fields ; + ``` info , 'Writing equilibrium file...' root_atts = { attribute , obj : '/' , $ name : 'description' , $ data : 'Plasma Parameters and Electromagnetic Fields for FIDASIM' } ;; Plasma Attributes plasma_desc = { attribute , obj : '/plasma' , $ name : 'description' , $ data : 'Plasma Parameters' } plasma_cs = { attribute , obj : '/plasma' , $ name : 'coordinate_system' , $ data : 'Cylindrical' } plasma_ds_desc = { attribute , obj : '/plasma/data_source' , $ name : 'description' , $ data : 'Source of the plasma parameters' } plasma_time_desc = { attribute , obj : '/plasma/time' , $ name : 'description' , $ data : 'Time' } plasma_time_unit = { attribute , obj : '/plasma/time' , $ name : 'units' , $ data : 's' } plasma_dene_desc = { attribute , obj : '/plasma/dene' , $ name : 'description' , $ data : 'Electron Number Density: Dene(r,z)' } plasma_dene_unit = { attribute , obj : '/plasma/dene' , $ name : 'units' , $ data : 'cm&#94;-3' } plasma_te_desc = { attribute , obj : '/plasma/te' , $ name : 'description' , $ data : 'Electron Temperature: Te(r,z)' } plasma_te_unit = { attribute , obj : '/plasma/te' , $ name : 'units' , $ data : 'keV' } plasma_ti_desc = { attribute , obj : '/plasma/ti' , $ name : 'description' , $ data : 'Ion Temperature: Ti(r,z)' } plasma_ti_unit = { attribute , obj : '/plasma/ti' , $ name : 'units' , $ data : 'keV' } plasma_zeff_desc = { attribute , obj : '/plasma/zeff' , $ name : 'description' , $ data : 'Effective Nuclear Charge: Zeff(r,z)' } plasma_vr_desc = { attribute , obj : '/plasma/vr' , $ name : 'description' , $ data : 'Bulk plasma flow in the r-direction: Vr(r,z)' } plasma_vr_unit = { attribute , obj : '/plasma/vr' , $ name : 'units' , $ data : 'cm/s' } plasma_vt_desc = { attribute , obj : '/plasma/vt' , $ name : 'description' , $ data : 'Bulk plasma flow in the theta/torodial-direction: Vt(r,z)' } plasma_vt_unit = { attribute , obj : '/plasma/vt' , $ name : 'units' , $ data : 'cm/s' } plasma_vz_desc = { attribute , obj : '/plasma/vz' , $ name : 'description' , $ data : 'Bulk plasma flow in the z-direction: Vz(r,z)' } plasma_vz_unit = { attribute , obj : '/plasma/vz' , $ name : 'units' , $ data : 'cm/s' } plasma_nr_desc = { attribute , obj : '/plasma/nr' , $ name : 'description' , $ data : 'Number of R values' } plasma_nz_desc = { attribute , obj : '/plasma/nz' , $ name : 'description' , $ data : 'Number of Z values' } plasma_r_desc = { attribute , obj : '/plasma/r' , $ name : 'description' , $ data : 'Radius' } plasma_r_unit = { attribute , obj : '/plasma/r' , $ name : 'units' , $ data : 'cm' } plasma_z_desc = { attribute , obj : '/plasma/z' , $ name : 'description' , $ data : 'Z' } plasma_z_unit = { attribute , obj : '/plasma/z' , $ name : 'units' , $ data : 'cm' } plasma_r2d_desc = { attribute , obj : '/plasma/r2d' , $ name : 'description' , $ data : 'Radius grid: R(r,z)' } plasma_r2d_unit = { attribute , obj : '/plasma/r2d' , $ name : 'units' , $ data : 'cm' } plasma_z2d_desc = { attribute , obj : '/plasma/z2d' , $ name : 'description' , $ data : 'Z grid: Z(r,z)' } plasma_z2d_unit = { attribute , obj : '/plasma/z2d' , $ name : 'units' , $ data : 'cm' } plasma_mask_desc = { attribute , obj : '/plasma/mask' , $ name : 'description' , $ data : 'Boolean mask that indicates where' + $ ' the plasma parameters are well defined' } plasma_atts = [ plasma_desc , plasma_cs , plasma_ds_desc , $ plasma_time_desc , plasma_time_unit , $ plasma_mask_desc , $ plasma_dene_desc , plasma_dene_unit , $ plasma_te_desc , plasma_te_unit , $ plasma_ti_desc , plasma_ti_unit , $ plasma_zeff_desc , $ plasma_vr_desc , plasma_vr_unit , $ plasma_vt_desc , plasma_vt_unit , $ plasma_vz_desc , plasma_vz_unit , $ plasma_nr_desc , plasma_nz_desc , $ plasma_r_desc , plasma_r_unit , $ plasma_z_desc , plasma_z_unit , $ plasma_r2d_desc , plasma_r2d_unit , $ plasma_z2d_desc , plasma_z2d_unit ] ;; Electromagnetic fields attributes fields_desc = { attribute , obj : '/fields' , $ name : 'description' , $ data : 'Electromagnetic Fields' } fields_cs = { attribute , obj : '/fields' , $ name : 'coordinate_system' , $ data : 'Cylindrical' } fields_ds_desc = { attribute , obj : '/fields/data_source' , $ name : 'description' , $ data : 'Source of the EM equilibrium' } fields_mask_desc = { attribute , obj : '/fields/mask' , $ name : 'description' , $ data : 'Boolean mask that indicates where' + $ ' the fields are well defined' } fields_time_desc = { attribute , obj : '/fields/time' , $ name : 'description' , $ data : 'Time' } fields_time_unit = { attribute , obj : '/fields/time' , $ name : 'units' , $ data : 's' } fields_br_desc = { attribute , obj : '/fields/br' , $ name : 'description' , $ data : 'Magnetic field in the r-direction: Br(r,z)' } fields_br_unit = { attribute , obj : '/fields/br' , $ name : 'units' , $ data : 'T' } fields_bt_desc = { attribute , obj : '/fields/bt' , $ name : 'description' , $ data : 'Magnetic field in the theta/torodial-direction: Bt(r,z)' } fields_bt_unit = { attribute , obj : '/fields/bt' , $ name : 'units' , $ data : 'T' } fields_bz_desc = { attribute , obj : '/fields/bz' , $ name : 'description' , $ data : 'Magnetic field in the z-direction: Bz(r,z)' } fields_bz_unit = { attribute , obj : '/fields/bz' , $ name : 'units' , $ data : 'T' } fields_er_desc = { attribute , obj : '/fields/er' , $ name : 'description' , $ data : 'Electric field in the r-direction: Er(r,z)' } fields_er_unit = { attribute , obj : '/fields/er' , $ name : 'units' , $ data : 'V/m' } fields_et_desc = { attribute , obj : '/fields/et' , $ name : 'description' , $ data : 'Electric field in the theta/torodial-direction: Et(r,z)' } fields_et_unit = { attribute , obj : '/fields/et' , $ name : 'units' , $ data : 'V/m' } fields_ez_desc = { attribute , obj : '/fields/ez' , $ name : 'description' , $ data : 'Electric field in the z-direction: Ez(r,z)' } fields_ez_unit = { attribute , obj : '/fields/ez' , $ name : 'units' , $ data : 'V/m' } fields_nr_desc = { attribute , obj : '/fields/nr' , $ name : 'description' , $ data : 'Number of R values' } fields_nz_desc = { attribute , obj : '/fields/nz' , $ name : 'description' , $ data : 'Number of Z values' } fields_r_desc = { attribute , obj : '/fields/r' , $ name : 'description' , $ data : 'Radius' } fields_r_unit = { attribute , obj : '/fields/r' , $ name : 'units' , $ data : 'cm' } fields_z_desc = { attribute , obj : '/fields/z' , $ name : 'description' , $ data : 'Z' } fields_z_unit = { attribute , obj : '/fields/z' , $ name : 'units' , $ data : 'cm' } fields_r2d_desc = { attribute , obj : '/fields/r2d' , $ name : 'description' , $ data : 'Radius grid: R(r,z)' } fields_r2d_unit = { attribute , obj : '/fields/r2d' , $ name : 'units' , $ data : 'cm' } fields_z2d_desc = { attribute , obj : '/fields/z2d' , $ name : 'description' , $ data : 'Z grid: Z(r,z)' } fields_z2d_unit = { attribute , obj : '/fields/z2d' , $ name : 'units' , $ data : 'cm' } fields_atts = [ fields_desc , fields_cs , fields_ds_desc , $ fields_mask_desc , $ fields_time_desc , fields_time_unit , $ fields_br_desc , fields_br_unit , $ fields_bt_desc , fields_bt_unit , $ fields_bz_desc , fields_bz_unit , $ fields_er_desc , fields_er_unit , $ fields_et_desc , fields_et_unit , $ fields_ez_desc , fields_ez_unit , $ fields_nr_desc , fields_nz_desc , $ fields_r_desc , fields_r_unit , $ fields_z_desc , fields_z_unit , $ fields_r2d_desc , fields_r2d_unit , $ fields_z2d_desc , fields_z2d_unit ] atts = [ root_atts , plasma_atts , fields_atts ] write_hdf5 ,[ \"plasma\" , \"fields\" ], filename = filename , atts = atts , / clobber if file_test ( filename ) then begin success , 'Equilibrium file created: ' + filename endif else begin error , 'Equilibrium file creation failed.' endelse END","tags":"","loc":"sourcefile/write_equilibrium.pro.html","title":"write_equilibrium.pro – FIDASIM"},{"text":"write_geometry Write geometry values to a HDF5 file Input Arguments filename : Name of the geometry file nbi : NBI geometry structure Keyword Arguments spec : Optional, Spectral geometry structure npa : Optional, NPA geometry structure Example Usage IDL > write_geometry, filename, nbi, spec = spec, npa = npa Source Code write_geometry.pro Source Code PRO write_geometry , filename , nbi , spec = spec , npa = npa ; +#write_geometry ; + Write geometry values to a HDF5 file ; +*** ; +## Input Arguments ; + **filename**: Name of the geometry file ; + ; + **nbi**: NBI geometry structure ; + ; +## Keyword Arguments ; + **spec**: Optional , Spectral geometry structure ; + ; + **npa**: Optional , NPA geometry structure ; + ; +## Example Usage ; + ``` idl ; + IDL > write_geometry , filename , nbi , spec = spec , npa = npa ; + ``` info , 'Writing geometry file...' ;; Create attributes root_atts = { attribute , obj : '/' , $ name : 'description' , $ data : 'Geometric quantities for FIDASIM' } ;; NBI attributes nbi_desc = { attribute , obj : '/nbi' , $ name : 'description' , $ data : 'Neutral Beam Geometry' } nbi_cs = { attribute , obj : '/nbi' , $ name : 'coordinate_system' , $ data : 'Right-handed cartesian' } nbi_ds_desc = { attribute , obj : '/nbi/data_source' , $ name : 'description' , $ data : 'Source of the NBI geometry' } nbi_name_desc = { attribute , obj : '/nbi/name' , $ name : 'description' , $ data : 'Beam name' } nbi_src_desc = { attribute , obj : '/nbi/src' , $ name : 'description' , $ data : 'Position of the center of the beam source grid' } nbi_src_unit = { attribute , obj : '/nbi/src' , $ name : 'units' , $ data : 'cm' } nbi_axis_desc = { attribute , obj : '/nbi/axis' , $ name : 'description' , $ data : 'Axis of the beam centerline: Centerline(t) = src + axis*t ' } nbi_axis_unit = { attribute , obj : '/nbi/axis' , $ name : 'units' , $ data : 'cm' } nbi_focy_desc = { attribute , obj : '/nbi/focy' , $ name : 'description' , $ data : 'Horizonal focal length of the beam' } nbi_focy_unit = { attribute , obj : '/nbi/focy' , $ name : 'units' , $ data : 'cm' } nbi_focz_desc = { attribute , obj : '/nbi/focz' , $ name : 'description' , $ data : 'Vertical focal length of the beam' } nbi_focz_unit = { attribute , obj : '/nbi/focz' , $ name : 'units' , $ data : 'cm' } nbi_divy_desc = { attribute , obj : '/nbi/divy' , $ name : 'description' , $ data : 'Horizonal divergences of the beam. One for each energy component' } nbi_divy_unit = { attribute , obj : '/nbi/divy' , $ name : 'units' , $ data : 'radians' } nbi_divz_desc = { attribute , obj : '/nbi/divz' , $ name : 'description' , $ data : 'Vertical divergences of the beam. One for each energy component' } nbi_divz_unit = { attribute , obj : '/nbi/divz' , $ name : 'units' , $ data : 'radians' } nbi_widy_desc = { attribute , obj : '/nbi/widy' , $ name : 'description' , $ data : 'Half width of the beam source grid' } nbi_widy_unit = { attribute , obj : '/nbi/widy' , $ name : 'units' , $ data : 'cm' } nbi_widz_desc = { attribute , obj : '/nbi/widz' , $ name : 'description' , $ data : 'Half height of the beam source grid' } nbi_widz_unit = { attribute , obj : '/nbi/widz' , $ name : 'units' , $ data : 'cm' } nbi_shape_desc = { attribute , obj : '/nbi/shape' , $ name : 'description' , $ data : 'Shape of the beam source grid: 1=\"rectangular\", 2=\"circular\"' } nbi_naperture_desc = { attribute , obj : '/nbi/naperture' , $ name : 'description' , $ data : 'Number of apertures' } nbi_ashape_desc = { attribute , obj : '/nbi/ashape' , $ name : 'description' , $ data : 'Shape of the aperture(s): 1=\"rectangular\", 2=\"circular\"' } nbi_awidy_desc = { attribute , obj : '/nbi/awidy' , $ name : 'description' , $ data : 'Half width of the aperture(s)' } nbi_awidy_unit = { attribute , obj : '/nbi/awidy' , $ name : 'units' , $ data : 'cm' } nbi_awidz_desc = { attribute , obj : '/nbi/awidz' , $ name : 'description' , $ data : 'Half height of the aperture(s)' } nbi_awidz_unit = { attribute , obj : '/nbi/awidz' , $ name : 'units' , $ data : 'cm' } nbi_aoffy_desc = { attribute , obj : '/nbi/aoffy' , $ name : 'description' , $ data : 'Horizontal (y) offset of the aperture(s) relative to the +x aligned beam centerline' } nbi_aoffy_unit = { attribute , obj : '/nbi/aoffy' , $ name : 'units' , $ data : 'cm' } nbi_aoffz_desc = { attribute , obj : '/nbi/aoffz' , $ name : 'description' , $ data : 'Vertical (z) offset of the aperture(s) relative to the +x aligned beam centerline' } nbi_aoffz_unit = { attribute , obj : '/nbi/aoffz' , $ name : 'units' , $ data : 'cm' } nbi_adist_desc = { attribute , obj : '/nbi/adist' , $ name : 'description' , $ data : 'Distance from the center of the beam source grid to the aperture(s) plane' } nbi_adist_unit = { attribute , obj : '/nbi/adist' , $ name : 'units' , $ data : 'cm' } nbi_atts = [ nbi_desc , nbi_cs , nbi_ds_desc , nbi_name_desc , $ nbi_shape_desc , nbi_src_desc , nbi_src_unit , $ nbi_axis_desc , nbi_axis_unit , $ nbi_focy_desc , nbi_focy_unit , $ nbi_focz_desc , nbi_focz_unit , $ nbi_divy_desc , nbi_divy_unit , $ nbi_divz_desc , nbi_divz_unit , $ nbi_widy_desc , nbi_widy_unit , $ nbi_widz_desc , nbi_widz_unit , $ nbi_naperture_desc , nbi_ashape_desc , $ nbi_awidy_desc , nbi_awidy_unit , $ nbi_awidz_desc , nbi_awidz_unit , $ nbi_aoffy_desc , nbi_aoffy_unit , $ nbi_aoffz_desc , nbi_aoffz_unit , $ nbi_adist_desc , nbi_adist_unit ] ;; Spectroscopic attributes spec_desc = { attribute , obj : '/spec' , $ name : 'description' , $ data : 'FIDA/BES Chord Geometry' } spec_cs = { attribute , obj : '/spec' , $ name : 'coordinate_system' , $ data : 'Right-handed cartesian' } spec_ds_desc = { attribute , obj : '/spec/data_source' , $ name : 'description' , $ data : 'Source of the chord geometry' } spec_nchan_desc = { attribute , obj : '/spec/nchan' , $ name : 'description' , $ data : 'Number of channels' } spec_system_desc = { attribute , obj : '/spec/system' , $ name : 'description' , $ data : 'Names of the different spectrocopic systems' } spec_id_desc = { attribute , obj : '/spec/id' , $ name : 'description' , $ data : 'Line of sight ID' } spec_lens_desc = { attribute , obj : '/spec/lens' , $ name : 'description' , $ data : 'Positions of the lenses' } spec_lens_unit = { attribute , obj : '/spec/lens' , $ name : 'units' , $ data : 'cm' } spec_axis_desc = { attribute , obj : '/spec/axis' , $ name : 'description' , $ data : 'Optical axis of the lines of sight: LOS(t) = lens + axis*t ' } spec_axis_unit = { attribute , obj : '/spec/axis' , $ name : 'units' , $ data : 'cm' } spec_radius_desc = { attribute , obj : '/spec/radius' , $ name : 'description' , $ data : 'Line of sight radius at midplane or tangency point' } spec_radius_unit = { attribute , obj : '/spec/radius' , $ name : 'units' , $ data : 'cm' } spec_sigma_desc = { attribute , obj : '/spec/sigma_pi' , $ name : 'description' , $ data : 'Ratio of the intensities of the sigma and pi stark lines. Measured quantity' } spec_spot_desc = { attribute , obj : '/spec/spot_size' , $ name : 'description' , $ data : 'Radius of spot size' } spec_spot_unit = { attribute , obj : '/spec/spot_size' , $ name : 'units' , $ data : 'cm' } spec_atts = [ spec_desc , spec_cs , spec_ds_desc , $ spec_nchan_desc , spec_system_desc , $ spec_id_desc , $ spec_lens_desc , spec_lens_unit , $ spec_axis_desc , spec_axis_unit , $ spec_radius_desc , spec_radius_unit , $ spec_sigma_desc , $ spec_spot_desc , spec_spot_unit ] ;; NPA attributes npa_desc = { attribute , obj : '/npa' , $ name : 'description' , $ data : 'NPA Geometry' } npa_cs = { attribute , obj : '/npa' , $ name : 'coordinate_system' , $ data : 'Right-handed cartesian' } npa_ds_desc = { attribute , obj : '/npa/data_source' , $ name : 'description' , $ data : 'Source of the NPA geometry' } npa_nchan_desc = { attribute , obj : '/npa/nchan' , $ name : 'description' , $ data : 'Number of channels' } npa_system_desc = { attribute , obj : '/npa/system' , $ name : 'description' , $ data : 'Names of the different NPA systems' } npa_id_desc = { attribute , obj : '/npa/id' , $ name : 'description' , $ data : 'Line of sight ID' } npa_dshape_desc = { attribute , obj : '/npa/d_shape' , $ name : 'description' , $ data : 'Shape of the detector: 1=\"rectangular\", 2=\"circular\"' } npa_dcent_desc = { attribute , obj : '/npa/d_cent' , $ name : 'description' , $ data : 'Center of the detector' } npa_dcent_unit = { attribute , obj : '/npa/d_cent' , $ name : 'units' , $ data : 'cm' } npa_dtedge_desc = { attribute , obj : '/npa/d_tedge' , $ name : 'description' , $ data : 'Center of the detectors top edge' } npa_dtedge_unit = { attribute , obj : '/npa/d_tedge' , $ name : 'units' , $ data : 'cm' } npa_dredge_desc = { attribute , obj : '/npa/d_redge' , $ name : 'description' , $ data : 'Center of the detectors right edge' } npa_dredge_unit = { attribute , obj : '/npa/d_redge' , $ name : 'units' , $ data : 'cm' } npa_ashape_desc = { attribute , obj : '/npa/a_shape' , $ name : 'description' , $ data : 'Shape of the aperture: 1=\"rectangular\", 2=\"circular\"' } npa_acent_desc = { attribute , obj : '/npa/a_cent' , $ name : 'description' , $ data : 'Center of the aperture' } npa_acent_unit = { attribute , obj : '/npa/a_cent' , $ name : 'units' , $ data : 'cm' } npa_atedge_desc = { attribute , obj : '/npa/a_tedge' , $ name : 'description' , $ data : 'Center of the apertures top edge' } npa_atedge_unit = { attribute , obj : '/npa/a_tedge' , $ name : 'units' , $ data : 'cm' } npa_aredge_desc = { attribute , obj : '/npa/a_redge' , $ name : 'description' , $ data : 'Center of the apertures right edge' } npa_aredge_unit = { attribute , obj : '/npa/a_redge' , $ name : 'units' , $ data : 'cm' } npa_radius_desc = { attribute , obj : '/npa/radius' , $ name : 'description' , $ data : 'Line of sight radius at midplane or tangency point' } npa_radius_unit = { attribute , obj : '/npa/radius' , $ name : 'units' , $ data : 'cm' } npa_atts = [ npa_desc , npa_cs , npa_ds_desc , $ npa_nchan_desc , npa_system_desc , $ npa_id_desc , $ npa_dshape_desc , npa_ashape_desc , $ npa_dcent_desc , npa_dcent_unit , $ npa_acent_desc , npa_acent_unit , $ npa_dtedge_desc , npa_dtedge_unit , $ npa_atedge_desc , npa_atedge_unit , $ npa_dredge_desc , npa_dredge_unit , $ npa_aredge_desc , npa_aredge_unit , $ npa_radius_desc , npa_radius_unit ] atts = [ root_atts , nbi_atts ] geom = { nbi : nbi } if keyword_set ( spec ) then begin geom = create_struct ( geom , \"spec\" , spec ) atts = [ atts , spec_atts ] endif if keyword_set ( npa ) then begin geom = create_struct ( geom , \"npa\" , npa ) atts = [ atts , npa_atts ] endif write_hdf5 , geom , filename = filename , atts = atts , / clobber if file_test ( filename ) then begin success , 'Geometry file created: ' + filename endif else begin error , 'Geometry file creation failed.' endelse END","tags":"","loc":"sourcefile/write_geometry.pro.html","title":"write_geometry.pro – FIDASIM"},{"text":"write_hdf5 Writes HDF5 files from variables in the local scope or a structure Arguments vars : List of variables or a structure Keyword Arguments atts : Attributes to write filename : Filename of output HDF5 file clobber : Overwrite exisiting HDF5 file compress : Compression level(0-9). Defaults to 9 Example Usage IDL > a = [ 1 , 2 , 3 ]\nIDL > write_hdf5, \"a\" ,atts = {attribute,obj : \"/a\" ,name : \"description\" ,data : \"example variable\" }\nIDL > s = {a : 1 ,b : {a : 2 }}\nIDL > write_hdf5,s, / clobber Source Code write_hdf5.pro Source Code FUNCTION vars_to_struct , vars = vars , level = level ;; struct_from_list ;; creates structure from list of variables in specified scope ;; if vars not set then use all valid variables in specified scope if not keyword_set ( level ) then level=- 1 if not keyword_set ( vars ) then vars = scope_varname ( level = level ) nvars = n_elements ( vars ) for i = 0 , nvars - 1 do begin catch , err_status if err_status ne 0 then begin catch , / cancel continue endif var = scope_varfetch ( vars [ i ], level = level ) if n_elements ( var ) ne 0 then begin if i eq 0 then begin s = create_struct ( vars [ i ], var ) endif else begin s = create_struct ( s , vars [ i ], var ) endelse endif endfor if nvars eq 1 and size ( s .( 0 ), / tname ) eq 'STRUCT' then begin s = s .( 0 ) endif return , s END PRO hdf5_write_struct , id , struct , compress = compress ntags = n_tags ( struct ) if ntags eq 0 then goto , GET_OUT if not keyword_set ( compress ) then compress = 9 tags = strlowcase ( TAG_NAMES ( struct )) for i = 0 , ntags - 1 do begin var = struct .( i ) varInfo = size ( var , / structure ) typeName = varInfo . type_name if typeName eq 'STRUCT' then begin gid = h5g_create ( id , tags [ i ]) hdf5_write_struct , gid , var , compress = compress h5g_close , gid endif else begin data = var ndim = size ( data , / n_dim ) dims = size ( data , / dim ) datatype_id = h5t_idl_create ( data ) if ndim eq 0 L then begin dataspace_id = h5s_create_scalar () dataset_id = h5d_create ( id , tags [ i ], datatype_id , dataspace_id ) endif else begin dataspace_id = h5s_create_simple ( dims ) dataset_id = h5d_create ( id , tags [ i ], datatype_id , dataspace_id , $ chunk_dimensions = dims , gzip = compress , / shuffle ) endelse h5d_write , dataset_id , data h5d_close , dataset_id h5s_close , dataspace_id h5t_close , datatype_id endelse endfor GET_OUT : END FUNCTION valid_attribute , att tags = [ \"obj\" , \"name\" , \"data\" ] att_tags = strlowcase ( TAG_NAMES ( att )) is_valid = 1 for i = 0 , n_elements ( tags ) - 1 do begin w = where ( tags [ i ] eq att_tags , nw ) if nw eq 0 then begin print , 'ERROR: Structure tag \"' + tags [ i ] +'\" missing from attribute definition' is_valid = 0 endif endfor if is_valid eq 0 then begin help , att goto , GET_OUT endif value_info = size ( att . data , / structure ) if value_info . type_name eq 'STRUCT' then begin print , 'ERROR: attribute value cannot be a structure' is_valid = 0 endif GET_OUT : return , is_valid END PRO hdf5_write_att_data , id , name , data data_info = size ( data , / structure ) type_name = data_info . type_name if type_name eq 'STRING' then begin value = strjoin ( data , \", \" , / single ) endif else begin value = data endelse dims = size ( value , / dim ) ndims = size ( value , / n_dim ) datatype_id = h5t_idl_create ( value ) if ndims eq 0 L then begin dataspace_id = h5s_create_scalar () endif else begin dataspace_id = h5s_create_simple ( dims ) endelse att_id = h5a_create ( id , name , datatype_id , dataspace_id ) h5a_write , att_id , value h5a_close , att_id END PRO hdf5_write_attributes , id , atts natts = n_elements ( atts ) for i = 0 , natts - 1 do begin if not valid_attribute ( atts [ i ]) then continue object_info = h5g_get_objinfo ( id , atts [ i ]. obj ) CASE object_info . type OF 'LINK': print , 'ERROR: Can not handle an attribute of a reference' 'GROUP': BEGIN gid = h5g_open ( id , atts [ i ]. obj ) hdf5_write_att_data , gid , atts [ i ]. name , atts [ i ]. data h5g_close , gid END 'DATASET': BEGIN did = h5d_open ( id , atts [ i ]. obj ) hdf5_write_att_data , did , atts [ i ]. name , atts [ i ]. data h5d_close , did END 'TYPE': BEGIN tid = h5t_open ( id , atts [ i ]. obj ) hdf5_write_att_data , tid , atts [ i ]. name , atts [ i ]. data h5t_close , tid END ELSE : print , 'ERROR: Unknown object' ENDCASE endfor END PRO write_hdf5 , vars , atts = atts , filename = filename , clobber = clobber , compress = compress ; +#write_hdf5 ; + Writes HDF5 files from variables in the local scope or a structure ; +*** ; +## Arguments ; + **vars**: List of variables or a structure ; + ; +## Keyword Arguments ; + **atts**: Attributes to write ; + ; + **filename**: Filename of output HDF5 file ; + ; + **clobber**: Overwrite exisiting HDF5 file ; + ; + **compress**: Compression level ( 0 - 9 ). Defaults to 9 ; + ; +## Example Usage ; + ``` idl ; + IDL > a = [ 1 , 2 , 3 ] ; + IDL > write_hdf5 , \"a\" , atts= { attribute , obj : \"/a\" , name : \"description\" , data : \"example variable\" } ; + IDL > s = { a : 1 , b :{ a : 2 }} ; + IDL > write_hdf5 , s , / clobber ; + ``` if not keyword_set ( filename ) then filename = 'idlsave.h5' if file_test ( filename ) and not keyword_set ( clobber ) then begin print , \"File already exists. Use clobber keyword to overwrite\" goto , GET_OUT endif if not keyword_set ( compress ) then compress = 9 nvars = n_elements ( vars ) if nvars eq 0 then goto , GET_OUT type = size ( vars , / tname ) if type ne 'STRUCT' and type ne 'STRING' then begin print , \"Invalid argument type. Expected STRING or STRUCT\" print , type goto , GET_OUT endif if nvars ne 1 and type eq 'STRUCT' then begin print , \"Invalid argument type. Arrays of structs not permitted\" goto , GET_OUT endif if nvars eq 1 and type eq 'STRUCT' then begin var_struct = vars endif else begin var_struct = vars_to_struct ( vars = vars , level=- 2 ) end file_id = h5f_create ( filename ) hdf5_write_struct , file_id , var_struct , compress = compress if keyword_set ( atts ) then begin hdf5_write_attributes , file_id , atts endif h5f_close , file_id GET_OUT : END","tags":"","loc":"sourcefile/write_hdf5.pro.html","title":"write_hdf5.pro – FIDASIM"},{"text":"write_namelist, filename, inputs Writes namelist file Input Arguments filename : Name of the namelist file inputs : Input structure Example Usage IDL > write_namelist, filename, inputs Source Code write_namelist.pro Source Code PRO write_namelist , filename , inputs ; +## ` write_namelist , filename , inputs ` ; + Writes namelist file ; + ; +### Input Arguments ; + **filename**: Name of the namelist file ; + ; + **inputs**: Input structure ; + ; +### Example Usage ; + ``` idl ; + IDL > write_namelist , filename , inputs ; + ``` info , 'Writing namelist file...' fidasim_version = get_version ( get_fidasim_dir ()) openw , 55 , filename printf , 55 , '!! Created: ' , systime () printf , 55 , '!! FIDASIM version: ' + fidasim_version printf , 55 , '!! Comment: ' + inputs . comment printf , 55 , '&fidasim_inputs' printf , 55 , '' printf , 55 , '!! Shot Info' printf , 55 , f='(\"shot = \", i6 ,\"    !! Shot Number\")' , inputs . shot printf , 55 , f='(\"time = \", 1f8.5 ,\"    !! Time [s]\")' , inputs . time printf , 55 , \"runid = '\" + inputs . runid + \"'    !! runID\" printf , 55 , \"result_dir = '\" + inputs . result_dir+ \"'    !! Result Directory\" printf , 55 , '' printf , 55 , '!! Input Files' printf , 55 , \"tables_file = '\" + inputs . tables_file+ \"'    !! Atomic Tables File\" printf , 55 , \"equilibrium_file = '\" + inputs . equilibrium_file + \"'    !! File containing plasma parameters and fields\" printf , 55 , \"geometry_file = '\" + inputs . geometry_file + \"'    !! File containing NBI and diagnostic geometry\" printf , 55 , \"distribution_file = '\" + inputs . distribution_file + \"'    !! File containing fast-ion distribution\" printf , 55 , '' printf , 55 , '!! Simulation Switches' printf , 55 , f='(\"calc_bes = \",i2 , \"    !! Calculate Beam Emission and Halo Spectra\")' , inputs . calc_bes printf , 55 , f='(\"calc_brems = \",i2 , \"    !! Calculate Bremsstrahlung\")' , inputs . calc_brems printf , 55 , f='(\"calc_fida = \",i2 , \"    !! Calculate FIDA Spectra\")' , inputs . calc_fida printf , 55 , f='(\"calc_npa = \",i2 , \"   !! Calculate NPA\")' , inputs . calc_npa printf , 55 , f='(\"calc_birth = \",i2 , \"    !! Calculate Birth Profile\")' , inputs . calc_birth printf , 55 , f='(\"calc_fida_wght = \",i2 , \"    !! Calculate FIDA weights\")' , inputs . calc_fida_wght printf , 55 , f='(\"calc_npa_wght = \",i2 , \"    !! Calculate NPA weights\")' , inputs . calc_npa_wght printf , 55 , f='(\"dump_dcx = \",i2,\"    !! Dump DCX neutrals and spectra\")' , inputs . dump_dcx printf , 55 , '' printf , 55 , '!! Debugging Switches' printf , 55 , f='(\"no_flr = \",i2,\"    !! Turn off Finite Larmor Radius effects\")' , inputs . no_flr printf , 55 , f='(\"load_neutrals = \",i2,\"    !! Load neutrals from neutrals file\")' , inputs . load_neutrals printf , 55 , \"neutrals_file = '\" + inputs . neutrals_file + \"'    !! File containing the neutral density\" printf , 55 , f='(\"verbose = \",i2,\"    !! Verbose\")' , inputs . verbose printf , 55 , '' printf , 55 , '!! Monte Carlo Settings' printf , 55 , f='(\"n_fida = \",i9,\"    !! Number of FIDA mc particles\")' , inputs . n_fida printf , 55 , f='(\"n_npa = \",i9,\"    !! Number of NPA mc particles\")' , inputs . n_npa printf , 55 , f='(\"n_nbi = \",i9,\"    !! Number of NBI mc particles\")' , inputs . n_nbi printf , 55 , f='(\"n_halo = \",i9,\"    !! Number of HALO mc particles\")' , inputs . n_halo printf , 55 , f='(\"n_dcx = \",i9,\"     !! Number of DCX mc particles\")' , inputs . n_dcx printf , 55 , f='(\"n_birth = \",i9,\"    !! Number of BIRTH mc particles\")' , inputs . n_birth printf , 55 , '' printf , 55 , '!! Neutral Beam Settings' printf , 55 , f='(\"ab = \",1f9.5,\"     !! Beam Species mass [amu]\")' , inputs . ab printf , 55 , f='(\"pinj = \",1f9.3,\"     !! Beam Power [MW]\")' , inputs . pinj printf , 55 , f='(\"einj = \",1f9.3,\"     !! Beam Energy [keV]\")' , inputs . einj printf , 55 , f='(\"current_fractions(1) = \",1f9.5,\" !! Current Fractions (Full component)\")' , inputs . current_fractions [ 0 ] printf , 55 , f='(\"current_fractions(2) = \",1f9.5,\" !! Current Fractions (Half component)\")' , inputs . current_fractions [ 1 ] printf , 55 , f='(\"current_fractions(3) = \",1f9.5,\" !! Current Fractions (Third component)\")' , inputs . current_fractions [ 2 ] printf , 55 , '' printf , 55 , '!! Plasma Settings' printf , 55 , f='(\"ai = \",1f9.5,\"     !! Ion Species mass [amu]\")' , inputs . ai printf , 55 , f='(\"impurity_charge = \",i3,\"     !! Impurity Charge\")' , inputs . impurity_charge printf , 55 , '' printf , 55 , '!! Beam Grid Settings' printf , 55 , f='(\"nx = \",i4,\"    !! Number of cells in X direction (Into Plasma)\")' , inputs . nx printf , 55 , f='(\"ny = \",i4,\"    !! Number of cells in Y direction\")' , inputs . ny printf , 55 , f='(\"nz = \",i4,\"    !! Number of cells in Z direction\")' , inputs . nz printf , 55 , f='(\"xmin = \",1f9.3,\"     !! Minimum X value [cm]\")' , inputs . xmin printf , 55 , f='(\"xmax = \",1f9.3,\"     !! Maximum X value [cm]\")' , inputs . xmax printf , 55 , f='(\"ymin = \",1f9.3,\"     !! Minimum Y value [cm]\")' , inputs . ymin printf , 55 , f='(\"ymax = \",1f9.3,\"     !! Maximum Y value [cm]\")' , inputs . ymax printf , 55 , f='(\"zmin = \",1f9.3,\"     !! Minimum Z value [cm]\")' , inputs . zmin printf , 55 , f='(\"zmax = \",1f9.3,\"     !! Maximum Z value [cm]\")' , inputs . zmax printf , 55 , '!! Tait-Bryan Angles for z-y`-x`` rotation' printf , 55 , f='(\"alpha = \",1f9.5,\"     !! Rotation about z-axis [rad]\")' , inputs . alpha printf , 55 , f='(\"beta  = \",1f9.5,\"     !! Rotation about y`-axis [rad]\")' , inputs . beta printf , 55 , f='(\"gamma = \",1f9.5,\"     !! Rotation about x``-axis [rad]\")' , inputs . gamma printf , 55 , '!! Beam Grid origin in machine coordinates (cartesian)' printf , 55 , f='(\"origin(1) = \",1f9.3,\"     !! U value [cm]\")' , inputs . origin [ 0 ] printf , 55 , f='(\"origin(2) = \",1f9.3,\"     !! V value [cm]\")' , inputs . origin [ 1 ] printf , 55 , f='(\"origin(3) = \",1f9.3,\"     !! W value [cm]\")' , inputs . origin [ 2 ] printf , 55 , '' printf , 55 , '!! Wavelength Grid Settings' printf , 55 , f='(\"nlambda = \",1i5,\"    !! Number of Wavelengths\")' , inputs . nlambda printf , 55 , f='(\"lambdamin = \",1f9.3,\"    !! Minimum Wavelength [nm]\")' , inputs . lambdamin printf , 55 , f='(\"lambdamax = \",1f9.3,\"    !! Maximum Wavelength [nm]\")' , inputs . lambdamax printf , 55 , '' printf , 55 , '!! Weight Function Settings' printf , 55 , f='(\"ne_wght = \",i9,\"    !! Number of Energies for Weights\")' , inputs . ne_wght printf , 55 , f='(\"np_wght = \",i9,\"    !! Number of Pitches for Weights\")' , inputs . np_wght printf , 55 , f='(\"nphi_wght = \",i9,\"    !! Number of Gyro-angles for Weights\")' , inputs . nphi_wght printf , 55 , f='(\"emax_wght = \",1f9.2,\"    !! Maximum Energy for Weights [keV]\")' , inputs . emax_wght printf , 55 , f='(\"nlambda_wght = \",1i5,\"    !! Number of Wavelengths for Weights \")' , $ inputs . nlambda_wght printf , 55 , f='(\"lambdamin_wght = \",1f9.3,\"    !! Minimum Wavelength for Weights [nm]\")' , $ inputs . lambdamin_wght printf , 55 , f='(\"lambdamax_wght = \",1f9.3,\"    !! Maximum Wavelength for Weights [nm]\")' , $ inputs . lambdamax_wght printf , 55 , '' printf , 55 , '/' printf , 55 , '' close , 55 success , 'Namelist file created: ' + filename END","tags":"","loc":"sourcefile/write_namelist.pro.html","title":"write_namelist.pro – FIDASIM"},{"text":"write_ncdf Writes variables in the local scope to a NetCDF file Arguments vars : Variables to write to file Keyword Arguments filename : Filename of NetCDF file merge_struct : Merge structures before writing clobber : Overwrite existing NetCDF file Example Usage IDL > a = 2 IDL > write_ncdf, \"a\" Source Code write_ncdf.pro Source Code PRO write_ncdf , vars , filename = filename , merge_struct = merge_struct , clobber = clobber ; +#write_ncdf ; + Writes variables in the local scope to a NetCDF file ; +*** ; +## Arguments ; + **vars**: Variables to write to file ; + ; +## Keyword Arguments ; + **filename**: Filename of NetCDF file ; + ; + **merge_struct**: Merge structures before writing ; + ; + **clobber**: Overwrite existing NetCDF file ; + ; +## Example Usage ; + ``` idl ; + IDL > a = 2 ; + IDL > write_ncdf , \"a\" ; + ``` if not keyword_set ( filename ) then filename = 'idlsave.cdf' if file_test ( filename ) and not keyword_set ( clobber ) then begin print , 'File already exists. Use clobber keyword to overwrite' goto , GET_OUT endif if size ( vars , / tname ) ne 'STRING' then begin print , 'Invalid argument type. Expected STRING' goto , GET_OUT endif nVars = n_elements ( vars ) ncid = ncdf_create ( filename , / clobber ) varids = [] v = {} while n_elements ( vars ) ne 0 do begin ;; check to see if variable is set in local scope void = execute ( \"isSet = n_elements(\" + vars [ 0 ] + \")\" ) ;; if not set pull variable from above scope if isSet eq 0 then begin var = scope_varfetch ( vars [ 0 ], level=- 1 ) endif else begin void = execute ( \"var=\" + vars [ 0 ]) endelse varInfo = size ( var , / structure ) typeName = varInfo . type_name CASE typeName OF 'STRUCT': begin tagNames = strlowcase ( tag_names ( var )) if keyword_set ( merge_struct ) then begin varNames = tagNames endif else begin varNames = vars [ 0 ] +'_' + tagNames endelse for i = 0 , n_elements ( tagNames ) - 1 do begin void = execute ( varNames [ i ] + \"= var.\" + tagNames [ i ]) endfor if n_elements ( vars ) gt 1 then vars = vars [ 1 :- 1 ] else vars = [] vars = [ varNames , vars ] goto , SKIP end 'STRING': begin str_id = ncdf_dimdef ( ncid , vars [ 0 ] +'_dim' , n_elements ( var )) strmax_id = ncdf_dimdef ( ncid , vars [ 0 ] +'_strlen_dim' , max ( strlen ( var ))) dimids = [ strmax_id , str_id ] void = execute ( \"varids = [varids,ncdf_vardef(ncid,'\" + vars [ 0 ] + \"',dimids,/byte)]\" ) var = byte ( var ) end ELSE : begin if varInfo . n_dimensions gt 0 then begin dimids = [] for i = 0 , varInfo . n_dimensions - 1 do begin tmp = ncdf_dimdef ( ncid , vars [ 0 ] +'_dim' + strcompress ( string ( i + 1 ), / remove_all ), varInfo . dimensions [ i ]) dimids = [ dimids , tmp ] endfor endif else begin dimids = ncdf_dimdef ( ncid , vars [ 0 ] +'_dim' , 1 ) endelse if typeName eq \"INT\" then typeName = \"LONG\" void = execute ( \"varids = [varids,ncdf_vardef(ncid,'\" + vars [ 0 ] + \"',dimids,/\" + typeName + \")]\" ) end ENDCASE v = create_struct ( v , vars [ 0 ], var ) if n_elements ( vars ) gt 1 then vars = vars [ 1 :- 1 ] else vars = [] SKIP : endwhile ncdf_control , ncid , / ENDEF for i = 1 , N_TAGS ( v ) - 1 do begin ncdf_varput , ncid , varids [ i - 1 ], v .( i ) endfor ncdf_close , ncid GET_OUT : END","tags":"","loc":"sourcefile/write_ncdf.pro.html","title":"write_ncdf.pro – FIDASIM"},{"text":"xyz_to_uvw(alpha, beta, gamma, xyz, origin=[0,0,0]) Express rotated coordinate xyz in non-rotated uvw coordinates Arguments alpha : Rotation angle about z [radians] beta : Rotation angle about y' [radians] gamma : Rotation angle about x\" [radians] xyz : Point in rotated coordinate system Keyword Arguments origin : Origin of rotated coordinate system in non-rotated (uvw) coordinates. Example Usage IDL > uvw = xyz_to_uvw(!DPI / 2 , 0.0 ,!DPI / 3 ,xyz) Source Code xyz_to_uvw.pro Source Code FUNCTION xyz_to_uvw , alpha , beta , gamma , xyz , origin = origin ; +## ` xyz_to_uvw ( alpha , beta , gamma , xyz , origin = [ 0 , 0 , 0 ]) ` ; + Express rotated coordinate ` xyz ` in non - rotated ` uvw ` coordinates ; +### Arguments ; + **alpha**: Rotation angle about z [ radians ] ; + ; + **beta**: Rotation angle about y ' [ radians ] ; + ; + **gamma**: Rotation angle about x \" [ radians ] ; + ; + **xyz**: Point in rotated coordinate system ; + ; +### Keyword Arguments ; + **origin**: Origin of rotated coordinate system in non - rotated ( uvw ) coordinates . ; + ; +### Example Usage ; + ``` idl ; + IDL > uvw = xyz_to_uvw (! DPI / 2 , 0.0 ,! DPI / 3 , xyz ) ; + ``` if not keyword_set ( origin ) then origin = [ 0.0 , 0.0 , 0.0 ] s = size ( xyz , / dim ) if n_elements ( s ) ne 2 then s = [ s , 1 ] xyz = transpose ( xyz ) ; Column Vector R = tb_zyx ( alpha , beta , gamma ) uvw = R ##xyz return , tranpose ( uvw ) + tile_array ( origin , 1 , s [ 1 ]) END","tags":"","loc":"sourcefile/xyz_to_uvw.pro.html","title":"xyz_to_uvw.pro – FIDASIM"},{"text":"Source Code __init__.py Source Code from fidasim.preprocessing import prefida","tags":"","loc":"sourcefile/__init__.py.html","title":"__init__.py – FIDASIM"},{"text":"PREFIDA Source This file contains the source code for PREFIDA aabb_intersect Calculates intersection length of a ray and an axis aligned bounding box (AABB) Input Arguments rc : Center of AABB dr : [length, width, height] of AABB r0 : starting point of ray d0 : direction of ray Output Arguments intersect : Intersection length of ray and AABB ri : Optional, ray enterence point rf : Optional, ray exit point Example Usage >>> intersect , r_enter , r_exit = aabb_intersect ([ 0 , 0 , 0 ], [ 1 , 1 , 1 ], [ - 1 , 0 , 0 ], [ 1 , 0 , 0 ]) >>> print ( intersect ) 1.0 >>> print ( r_enter ) - 0.5 0.0 0.0 >>> print ( r_exit ) 0.5 0.0 0.0 tb_zyx Calculates Tait-Bryan z-y'-x\" active rotation matrix given rotation angles alpha , beta , gamma in radians Arguments alpha : rotation angle about z [radians] beta : rotation angle about y' [radians] gamma : rotation angle about x\" [radians] Return Value Rotation Matrix prefida Example Usage >>> rot_mat = tb_zyx(!DPI/2, 0.0, !DPI/3) uvw_to_xyz Express non-rotated coordinate uvw in rotated xyz coordinates Arguments alpha : Rotation angle about z [radians] beta : Rotation angle about y' [radians] gamma : Rotation angle about x\" [radians] uvw : Point in rotated coordinate system, (3, n) Keyword Arguments origin : Origin of rotated coordinate system in non-rotated (uvw) coordinates, (3) Output Arguments xyz : 'uvw' in 'xyz' coordinates Example Usage >>> xyz = uvw_to_xyz ( np . pi / 2. , 0.0 , np . pi / 3. , uvw , origin = [ . 1 , . 2 , 0. ]) check_dict_schema Check dict dec is formatted according to schema Input Arguments schema : dict schema dic : dict to check Output Arguments err : error code Keyword Arguments desc : description of dict dic Example usage >>> dic = { 'a' : 0 , 'b' :[ 1. d0 , 2. d0 ], 'c' : \"example\" } >>> schema = { 'a' :{ 'dims' : 0 , 'type' :[ int ]}, 'b' :{ 'dims' :[ 2 ], 'type' :[ float , np . float64 ]}, 'c' :{ 'dims' : 0 , 'type' :[ str ]} } >>> err = check_dict_schema ( schema , dic , desc = \"Example dict\" ) >>> print ( err ) False check_inputs Checks if input dictionary is valid Input Arguments inputs : input dictionary Output Arguments inputs : Updated inputs dictionary Example Usage >>> inputs = check_inputs(inputs) check_grid Checks if interpolation grid structure is valid Input Arguments grid : Interpolation grid structure Example Usage >>> check_grid ( grid ) check_beam Checks if neutral beam geometry dictionary is valid. Converts lists to numpy ndarrays Input Arguments inputs : input dictionary nbi : neutral beam geometry dictionary Output Arguments nbi : Updated nbi dictionary Example Usage >>> nbi = check_beam ( inputs , nbi ) check_plasma Checks if plasma paramters dictionary is valid Input Arguments inputs : Input dictionary grid : Interpolation grid dictionary plasma : Plasma parameters dictionary Output Arguments plasma : Updated plasma dictionary Example Usage >>> plasma = check_plasma ( inputs , grid , plasma ) check_fields Checks if electromagnetic fields dictionary is valid Input Arguments inputs : Input dictionary grid : Interpolation grid dictionary fields : Electromagnetic fields dictionary Output Arguments fields : Updated fields dictionary Example Usage >>> fields = check_fields ( inputs , grid , fields ) check_distribution Checks if distribution dictionary is valid Input Arguments inputs : Input dictionary grid : Interpolation grid dictionary dist : Fast-ion distribution dictionary Output Arguments dist : Updated dist dictionary Example Usage >>> dist = check_distribution ( inputs , grid , dist ) check_spec Check if spectral geometry dictionary is valid Input Arguments inputs : input dictionary chords : spectral geometry dictionary Example Usage >>> check_spec ( inputs , chords ) check_npa Checks if NPA geometry dictionary is valid Input Arguments inputs : input dictionary npa : NPA geometry dictionary Example Usage >>> check_npa ( inputs , npa ) write_namelist Writes namelist file Input Arguments filename : Name of the namelist file inputs : Input dictionary Example Usage >>> write_namelist ( filename , inputs ) write_geometry Write geometry values to a HDF5 file Input Arguments filename : Name of the geometry file nbi : NBI geometry structure Keyword Arguments spec : Optional, Spectral geometry structure npa : Optional, NPA geometry structure Example Usage >>> write_geometry ( filename , nbi , spec = spec , npa = npa ) write_equilibrium Write MHD equilibrium values to a HDF5 file Input Arguments filename : Name of the equilibrium file plasma : Plasma dictionary fields : Electromagnetic fields dictionary Example Usage >>> write_equilibrium ( filename , plasma , fields ) write_distribution Write fast-ion distribution to a HDF5 file Input Arguments filename : Name of the distribution file dist : Fast-ion distribution distionary Example Usage >>> write_distribution(filename, distri) prefida Checks FIDASIM inputs and writes FIDASIM input files Input Arguments inputs : Inputs structure grid : Interpolation grid structure nbi : Neutral beam geometry structure plasma : Plasma parameters structure fields : Electromagnetic fields structure fbm : Fast-ion distribution structure Keyword Arguments spec : Optional, Spectral geometry structure npa : Optional, NPA geometry structure Example Usage >>> prefida ( inputs , grid , nbi , plasma , fields , fbm , spec = spec , npa = npa ) Source Code preprocessing.py Source Code #!/usr/bin/env python # -*- coding: utf-8 -*- #+#PREFIDA Source #+ This file contains the source code for PREFIDA #+*** from __future__ import print_function import os import numpy as np import copy import datetime import h5py from fidasim.utils import * def aabb_intersect ( rc , dr , r0 , d0 ): \"\"\" #+#aabb_intersect #+Calculates intersection length of a ray and an axis aligned bounding box (AABB) #+*** #+##Input Arguments #+     **rc**: Center of AABB #+ #+     **dr**: [length, width, height] of AABB #+ #+     **r0**: starting point of ray #+ #+     **d0**: direction of ray #+ #+##Output Arguments #+     **intersect**: Intersection length of ray and AABB #+ #+     **ri**: Optional, ray enterence point #+ #+     **rf**: Optional, ray exit point #+ #+##Example Usage #+```python #+>>> intersect, r_enter, r_exit = aabb_intersect([0,0,0], [1,1,1], [-1,0,0], [1,0,0]) #+>>> print(intersect) #+    1.0 #+>>> print(r_enter) #+    -0.5  0.0  0.0 #+>>> print(r_exit) #+     0.5  0.0  0.0 #+``` \"\"\" v0 = d0 / np . sqrt ( np . sum ( d0 ** 2. )) # There are 6 sides to a cube/grid side_inter = np . zeros ( 6 ) # Intersection points of ray with planes defined by grid ipnts = np . zeros (( 3 , 6 )) # Find whether ray intersects each side for i in range ( 6 ): j = int ( np . floor ( i / 2 )) ind = np . arange ( 3 , dtype = int ) ind = ind [ ind != j ] if np . abs ( v0 [ j ]) > 0. : # just v0[j] != 0 right? # Intersection point with plane ipnts [:, i ] = r0 + v0 * ((( rc [ j ] + ( np . mod ( i , 2 ) - 0.5 ) * dr [ j ]) - r0 [ j ]) / v0 [ j ]) # Check if point on plane is within grid side if ( np . abs ( ipnts [ ind [ 0 ], i ] - rc [ ind [ 0 ]]) <= 0.5 * dr [ ind [ 0 ]]) and \\ ( np . abs ( ipnts [ ind [ 1 ], i ] - rc [ ind [ 1 ]]) <= 0.5 * dr [ ind [ 1 ]]): side_inter [ i ] = 1 intersect = 0.0 r_enter = copy . deepcopy ( r0 ) r_exit = copy . deepcopy ( r0 ) ind = np . arange ( side_inter . size ) ind = ind [ side_inter != 0 ] nw = side_inter [ ind ] . size if nw >= 2 : #Find two unique intersection points nunique = 0 for i in range ( nw - 1 ): if np . sum ( ipnts [:, ind [ 0 ]] == ipnts [:, ind [ i + 1 ]]) != 3 : ind = [ ind [ 0 ], ind [ i + 1 ]] nunique = 2 break if nunique == 2 : vi = ipnts [:, ind [ 1 ]] - ipnts [:, ind [ 0 ]] vi = vi / np . sqrt ( np . sum ( vi ** 2. )) dot_prod = np . sum ( v0 * vi ) if dot_prod > 0.0 : r_enter = ipnts [:, ind [ 0 ]] r_exit = ipnts [:, ind [ 1 ]] else : r_enter = ipnts [:, ind [ 1 ]] r_exit = ipnts [:, ind [ 0 ]] # Calculate intersection length intersect = np . sqrt ( np . sum (( r_exit - r_enter ) ** 2. )) return intersect , r_enter , r_exit def tb_zyx ( alpha , beta , gamma ): \"\"\" #+#tb_zyx #+Calculates Tait-Bryan z-y'-x\" active rotation matrix given rotation angles `alpha`,`beta`,`gamma` in radians #+*** #+##Arguments #+     **alpha**: rotation angle about z [radians] #+ #+     **beta**: rotation angle about y' [radians] #+ #+     **gamma**: rotation angle about x\" [radians] #+ #+##Return Value #+     Rotation Matrix [prefida](|url|/sourcefile/prefida.pro.html) #+ #+##Example Usage #+```dist #+ >>> rot_mat = tb_zyx(!DPI/2, 0.0, !DPI/3) #+``` \"\"\" sa = np . sin ( alpha ) ca = np . cos ( alpha ) sb = np . sin ( beta ) cb = np . cos ( beta ) sg = np . sin ( gamma ) cg = np . cos ( gamma ) r = np . zeros (( 3 , 3 )) r [ 0 , 0 ] = ca * cb r [ 0 , 1 ] = ca * sb * sg - cg * sa r [ 0 , 2 ] = sa * sg + ca * cg * sb r [ 1 , 0 ] = cb * sa r [ 1 , 1 ] = ca * cg + sa * sb * sg r [ 1 , 2 ] = cg * sa * sb - ca * sg r [ 2 , 0 ] = - sb r [ 2 , 1 ] = cb * sg r [ 2 , 2 ] = cb * cg return r def uvw_to_xyz ( alpha , beta , gamma , uvw , origin = None ): \"\"\" #+#uvw_to_xyz #+ Express non-rotated coordinate `uvw` in rotated `xyz` coordinates #+*** #+##Arguments #+     **alpha**: Rotation angle about z [radians] #+ #+     **beta**: Rotation angle about y' [radians] #+ #+     **gamma**: Rotation angle about x\" [radians] #+ #+     **uvw**: Point in rotated coordinate system, (3, n) #+ #+##Keyword Arguments #+     **origin**: Origin of rotated coordinate system in non-rotated (uvw) coordinates, (3) #+ #+##Output Arguments #+     **xyz**: 'uvw' in 'xyz' coordinates #+ #+##Example Usage #+```python #+>>> xyz = uvw_to_xyz(np.pi/2., 0.0, np.pi/3., uvw, origin=[.1, .2, 0.]) #+``` \"\"\" if origin is None : origin = [ 0. , 0. , 0. ] # Make np arrays uvw = np . array ( uvw , dtype = float ) origin = np . array ( origin , dtype = float ) # Do checks as this code does not allow multiple points to be entered (yet) if uvw . ndim == 2 : s = uvw . shape if s [ 0 ] != 3 : raise ValueError ( 'uvw must be (3, n), but it has shape {}' . format ( uvw . shape )) n = s [ 1 ] elif uvw . ndim == 1 : if uvw . size != 3 : raise ValueError ( 'uvw must have length 3, but it has length {}' . format ( uvw . size )) n = 1 else : raise ValueError ( 'uvw must be (3) or (3, n)' ) if origin . ndim != 1 : raise ValueError ( 'origin must be 1D, but it has shape {}' . format ( origin . shape )) if origin . size != 3 : raise ValueError ( 'origin must have length 3, but it has length {}' . format ( origin . size )) # Shift origin uvw_shifted = uvw - np . squeeze ( np . tile ( origin , ( n , 1 )) . T ) # Get rotation matrix r = tb_zyx ( alpha , beta , gamma ) # Apply rotation matrix xyz = np . dot ( r . T , uvw_shifted ) return xyz def check_dict_schema ( schema , dic , desc = None ): \"\"\" #+#check_dict_schema #+ Check dict `dec` is formatted according to `schema` #+*** #+##Input Arguments #+     **schema**: dict schema #+ #+     **dic**: dict to check #+ #+##Output Arguments #+     **err**: error code #+ #+##Keyword Arguments #+     **desc**: description of dict `dic` #+ #+##Example usage #+```python #+>>> dic = {'a':0, 'b':[1.d0,2.d0], 'c':\"example\"} #+>>> schema = {'a':{'dims':0,'type':[int]}, 'b':{'dims':[2],'type':[float, np.float64]}, 'c':{'dims':0,'type':[str]}  } #+ #+>>> err = check_dict_schema(schema, dic, desc=\"Example dict\") #+>>> print(err) #+    False #+``` \"\"\" if desc is None : desc = 'dict' err = False schema_keys = list ( schema . keys ()) dic_keys = list ( dic . keys ()) # Note extra variables for key in dic_keys : if key not in schema_keys : info ( 'Extra variable \"{}\" found in \"{}\"' . format ( key , desc )) for key in schema_keys : # Note missing data if key not in dic_keys : error ( '\"{}\" is missing from \"{}\"' . format ( key , desc )) err = True else : # Check type if ( schema [ key ][ 'dims' ] == 0 ): if not isinstance ( dic [ key ], tuple ( schema [ key ][ 'type' ])): error ( '\"{}\" has the wrong type of {}. Expected {}' . format ( key , type ( dic [ key ]), schema [ key ][ 'type' ])) err = True elif dic [ key ] . dtype . type not in schema [ key ][ 'type' ]: error ( '\"{}\" has the wrong type of {}. Expected {}' . format ( key , dic [ key ] . dtype . type , schema [ key ][ 'type' ])) err = True # Check for NaNs or Inf if ( not isinstance ( dic [ key ], ( str , dict , float , int ))) and ( str not in schema [ key ][ 'type' ]): if ( dic [ key ][ np . isnan ( dic [ key ])] . size > 0 ) or ( dic [ key ][ np . isinf ( dic [ key ])] . size > 0 ): error ( 'NaN or Infinity detected in \"{}\"' . format ( key )) err = True # Check shape if not np . array_equal ( dic [ key ] . shape , schema [ key ][ 'dims' ]): error ( '\"{}\" has the wrong shape of {}. Expected ({})' . format ( key , dic [ key ] . shape , schema [ key ][ 'dims' ])) print ( 'ndim({}) = {}' . format ( key , dic [ key ] . ndim )) err = True # Check shape if isinstance ( dic [ key ], ( str , int , float )): if ( schema [ key ][ 'dims' ] != 0 ) and ( schema [ key ][ 'dims' ] != [ 0 ]): error ( '\"{}\" has the wrong shape. Expected ({})' . format ( key , schema [ key ][ 'dims' ])) err = True return err def check_inputs ( inputs ): \"\"\" #+#check_inputs #+Checks if input dictionary is valid #+*** #+##Input Arguments #+     **inputs**: input dictionary #+ #+##Output Arguments #+     **inputs**: Updated inputs dictionary #+ #+##Example Usage #+```dist #+>>> inputs = check_inputs(inputs) #+``` \"\"\" info ( 'Checking simulation settings...' ) err = False zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_int = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_long = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_double = { 'dims' : 0 , 'type' : [ float , np . float64 ]} three_double = { 'dims' : [ 3 ], 'type' : [ float , np . float64 ]} schema = { 'comment' : zero_string , 'shot' : zero_long , 'time' : zero_double , 'runid' : zero_string , 'device' : zero_string , 'tables_file' : zero_string , 'result_dir' : zero_string , 'nlambda' : zero_int , 'lambdamin' : zero_double , 'lambdamax' : zero_double , 'nx' : zero_int , 'ny' : zero_int , 'nz' : zero_int , 'alpha' : zero_double , 'beta' : zero_double , 'gamma' : zero_double , 'origin' : three_double , 'xmin' : zero_double , 'xmax' : zero_double , 'ymin' : zero_double , 'ymax' : zero_double , 'zmin' : zero_double , 'zmax' : zero_double , 'ab' : zero_double , 'ai' : zero_double , 'current_fractions' : three_double , 'pinj' : zero_double , 'einj' : zero_double , 'impurity_charge' : zero_int , 'n_fida' : zero_long , 'n_nbi' : zero_long , 'n_dcx' : zero_long , 'n_npa' : zero_long , 'n_halo' : zero_long , 'n_birth' : zero_long , 'ne_wght' : zero_int , 'np_wght' : zero_int , 'nphi_wght' : zero_int , 'emax_wght' : zero_double , 'nlambda_wght' : zero_int , 'lambdamin_wght' : zero_double , 'lambdamax_wght' : zero_double , 'calc_npa' : zero_int , 'calc_fida' : zero_int , 'calc_bes' : zero_int , 'calc_brems' : zero_int , 'calc_birth' : zero_int , 'calc_fida_wght' : zero_int , 'calc_npa_wght' : zero_int , 'dump_dcx' : zero_int } err = check_dict_schema ( schema , inputs , desc = \"simulation settings\" ) if err : error ( 'Invalid simulation settings. Exiting...' , halt = True ) # Normalize File Paths inputs [ 'result_dir' ] = os . path . abspath ( inputs [ 'result_dir' ]) if ( inputs [ 'alpha' ] > 2. * np . pi ) or ( inputs [ 'beta' ] > 2. * np . pi ) or ( inputs [ 'gamma' ] > 2. * np . pi ): error ( 'Angles must be in radians' ) err = True if inputs [ 'lambdamin' ] >= inputs [ 'lambdamax' ]: error ( 'Invalid wavelength range. Expected lambdamin < lamdbdamax' ) err = True if inputs [ 'lambdamin_wght' ] >= inputs [ 'lambdamax_wght' ]: error ( 'Invalid wavelength range. Expected lambdamin_wght < lamdbdamax_wght' ) err = True if inputs [ 'xmin' ] >= inputs [ 'xmax' ]: error ( 'Invalid x range. Expected xmin < xmax' ) err = True if inputs [ 'ymin' ] >= inputs [ 'ymax' ]: error ( 'Invalid y range. Expected ymin < ymax' ) err = True if inputs [ 'zmin' ] >= inputs [ 'zmax' ]: error ( 'Invalid z range. Expected zmin < zmax' ) err = True if ( inputs [ 'pinj' ] <= 0. ) or ( inputs [ 'einj' ] <= 0.0 ): error ( 'The selected source is not on' ) print ( 'einj = {}' . format ( inputs [ 'einj' ])) print ( 'pinj = {}' . format ( inputs [ 'pinj' ])) err = True if np . abs ( np . sum ( inputs [ 'current_fractions' ]) - 1.0 ) > 1e-3 : error ( 'current_fractions do not sum to 1.0' ) print ( 'sum(current_fractions) = {}' . format ( np . sum ( inputs [ 'current_fractions' ]))) err = True if inputs [ 'impurity_charge' ] <= 1 : error ( 'Invalid impurity charge. Expected impurity charge > 1' ) err = True ps = os . path . sep input_file = inputs [ 'result_dir' ] + ps + inputs [ 'runid' ] + '_inputs.dat' equilibrium_file = inputs [ 'result_dir' ] + ps + inputs [ 'runid' ] + '_equilibrium.h5' geometry_file = inputs [ 'result_dir' ] + ps + inputs [ 'runid' ] + '_geometry.h5' distribution_file = inputs [ 'result_dir' ] + ps + inputs [ 'runid' ] + '_distribution.h5' neutrals_file = inputs [ 'result_dir' ] + ps + inputs [ 'runid' ] + '_neutrals.h5' inputs [ 'input_file' ] = input_file inputs [ 'equilibrium_file' ] = equilibrium_file inputs [ 'geometry_file' ] = geometry_file inputs [ 'distribution_file' ] = distribution_file inputs [ 'load_neutrals' ] = 0 inputs [ 'no_flr' ] = 0 inputs [ 'verbose' ] = 1 inputs [ 'neutrals_file' ] = neutrals_file if err : error ( 'Invalid simulation settings. Exiting...' , halt = True ) else : success ( 'Simulation settings are valid' ) return inputs def check_grid ( grid ): \"\"\" #+#check_grid #+Checks if interpolation grid structure is valid #+*** #+##Input Arguments #+     **grid**: Interpolation grid structure #+ #+##Example Usage #+```python #+>>> check_grid(grid) #+``` \"\"\" err = False info ( 'Checking interpolation grid...' ) if 'nr' not in grid : error ( '\"nr\" is missing from the interpolation grid' ) error ( 'Invalid interpolation grid. Exiting...' , halt = True ) if 'nz' not in grid : error ( '\"nz\" is missing from the interpolation grid' ) error ( 'Invalid interpolation grid. Exiting...' , halt = True ) nr = grid [ 'nr' ] nz = grid [ 'nz' ] zero_int = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} nrnz_doub = { 'dims' : [ nr , nz ], 'type' : [ float , np . float64 ]} schema = { 'nr' : zero_int , 'nz' : zero_int , 'r2d' : nrnz_doub , 'z2d' : nrnz_doub , 'r' : { 'dims' : [ nr ], 'type' : [ float , np . float64 ]}, 'z' : { 'dims' : [ nz ], 'type' : [ float , np . float64 ]}} err = check_dict_schema ( schema , grid , desc = \"interpolation grid\" ) if err : error ( 'Invalid interpolation grid. Exiting...' , halt = True ) if not np . array_equal ( grid [ 'r' ], np . sort ( grid [ 'r' ])): error ( 'r is not in ascending order' ) err = True if not np . array_equal ( grid [ 'z' ], np . sort ( grid [ 'z' ])): error ( 'z is not in ascending order' ) err = True if not np . array_equal ( grid [ 'r' ], grid [ 'r2d' ][:, 0 ]): error ( 'r2d is defined incorrectly. Expected r == r2d[:, 0]' ) err = True if not np . array_equal ( grid [ 'z' ], grid [ 'z2d' ][ 0 , :]): error ( 'z2d is defined incorrectly. Expected z == z2d[0, :]' ) err = True if err : error ( 'Invalid interpolation grid. Exiting...' , halt = True ) else : success ( 'Interpolation grid is valid' ) def check_beam ( inputs , nbi ): \"\"\" #+#check_beam #+Checks if neutral beam geometry dictionary is valid. Converts lists to numpy ndarrays #+*** #+##Input Arguments #+     **inputs**: input dictionary #+ #+     **nbi**: neutral beam geometry dictionary #+ #+##Output Arguments #+     **nbi**: Updated nbi dictionary #+ #+##Example Usage #+```python #+>>> nbi = check_beam(inputs, nbi) #+``` \"\"\" err = False info ( 'Checking beam geometry...' ) na = nbi [ 'naperture' ] zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_int = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_double = { 'dims' : 0 , 'type' : [ float , np . float64 ]} three_double = { 'dims' : [ 3 ], 'type' : [ float , np . float64 ]} na_double = { 'dims' : [ na ], 'type' : [ float , np . float64 ]} na_int = { 'dims' : [ na ], 'type' : [ int , np . int32 , np . int64 ]} schema = { 'data_source' : zero_string , 'name' : zero_string , 'shape' : zero_int , 'src' : three_double , 'axis' : three_double , 'divy' : three_double , 'divz' : three_double , 'focy' : zero_double , 'focz' : zero_double , 'widz' : zero_double , 'widy' : zero_double } # Add to schema if aperatures are present if nbi [ 'naperture' ] > 0 : schema [ 'naperture' ] = zero_int schema [ 'ashape' ] = na_int schema [ 'awidy' ] = na_double schema [ 'awidz' ] = na_double schema [ 'aoffy' ] = na_double schema [ 'aoffz' ] = na_double schema [ 'adist' ] = na_double # Convert to np arrays for indexing nbi [ 'ashape' ] = np . array ( nbi [ 'ashape' ], dtype = int , ndmin = 1 ) nbi [ 'awidy' ] = np . array ( nbi [ 'awidy' ], dtype = float , ndmin = 1 ) nbi [ 'awidz' ] = np . array ( nbi [ 'awidz' ], dtype = float , ndmin = 1 ) nbi [ 'aoffy' ] = np . array ( nbi [ 'aoffy' ], dtype = float , ndmin = 1 ) nbi [ 'aoffz' ] = np . array ( nbi [ 'aoffz' ], dtype = float , ndmin = 1 ) nbi [ 'adist' ] = np . array ( nbi [ 'adist' ], dtype = float , ndmin = 1 ) err = check_dict_schema ( schema , nbi , desc = \"beam geometry\" ) if err : error ( 'Invalid beam geometry. Exiting...' , halt = True ) if np . abs ( np . sum ( nbi [ 'axis' ] ** 2. ) - 1. ) > 1e-5 : error ( 'Invalid source axis. Expected norm(axis) == 1' ) err = True if nbi [ 'focz' ] <= 0.0 : error ( 'focz cannot be in the range (-Inf,0.0]' ) err = True if nbi [ 'focy' ] <= 0.0 : error ( 'focy cannot be in the range (-Inf,0.0]' ) err = True if nbi [ 'shape' ] not in [ 1 , 2 ]: error ( 'Invalid source shape. Expected 1 (rectagular) or 2 (circular)' ) err = True if nbi [ 'widz' ] < 0. : error ( 'Invalid widz. Expected widz > 0' ) err = True if nbi [ 'widy' ] < 0 : error ( 'Invalid widy. Expected widy > 0' ) err = True if nbi [ 'ashape' ] not in [ 1 , 2 ]: error ( 'Invalid aperture shape. Expected 1 (rectangular) or 2 (circular)' ) err = True w = nbi [ 'awidy' ] < 0 nw = len ( nbi [ 'awidy' ][ w ]) if nw > 0 : error ( 'Invalid awidy. Expected awidy >= 0.0' ) err = True w = nbi [ 'awidz' ] < 0 nw = len ( nbi [ 'awidz' ][ w ]) if nw > 0 : error ( 'Invalid awidz. Expected awidz >= 0.0' ) err = True # Machine coordinates origin = inputs [ 'origin' ] uvw_src = nbi [ 'src' ] uvw_axis = nbi [ 'axis' ] uvw_pos = uvw_src + nbi [ 'adist' ][ 0 ] * uvw_axis uvw_arbitrary = uvw_src + 100. * uvw_axis # Convert to beam coordinates xyz_src = uvw_to_xyz ( inputs [ 'alpha' ], inputs [ 'beta' ], inputs [ 'gamma' ], uvw_src , origin = origin ) xyz_axis = uvw_to_xyz ( inputs [ 'alpha' ], inputs [ 'beta' ], inputs [ 'gamma' ], uvw_axis ) xyz_pos = uvw_to_xyz ( inputs [ 'alpha' ], inputs [ 'beta' ], inputs [ 'gamma' ], uvw_pos , origin = origin ) xyz_center = uvw_to_xyz ( inputs [ 'alpha' ], inputs [ 'beta' ], inputs [ 'gamma' ], [ 0. , 0. , 0. ], origin = origin ) xyz_arbitrary = uvw_to_xyz ( inputs [ 'alpha' ], inputs [ 'beta' ], inputs [ 'gamma' ], uvw_arbitrary , origin = origin ) dis = np . sqrt ( np . sum (( xyz_src - xyz_arbitrary ) ** 2. )) # now dis can never be zero alpha = np . arctan2 (( xyz_pos [ 1 ] - xyz_src [ 1 ]), ( xyz_pos [ 0 ] - xyz_src [ 0 ])) beta = np . arcsin (( xyz_src [ 2 ] - xyz_pos [ 2 ]) / dis ) print ( 'Beam injection start point in machine coordinates' ) print ( uvw_src ) print ( 'First aperture position in machine coordinates' ) print ( uvw_pos ) print ( 'Machine center in beam grid coordinates' ) print ( xyz_center ) print ( 'Beam injection start point in beam grid coordinates' ) print ( xyz_src ) print ( 'First aperture position in beam grid coordinates' ) print ( xyz_pos ) print ( 'Beam grid rotation angles that would align it with the beam centerline' ) print ( 'alpha = {} deg.' . format ( alpha / np . pi * 180. )) print ( 'beta = {} deg.' . format ( beta / np . pi * 180. )) # Calculate grid center rc and sides length dr dr = np . array ([ inputs [ 'xmax' ] - inputs [ 'xmin' ], inputs [ 'ymax' ] - inputs [ 'ymin' ], inputs [ 'zmax' ] - inputs [ 'zmin' ]], dtype = np . float64 ) rc = np . array ([ inputs [ 'xmin' ], inputs [ 'ymin' ], inputs [ 'zmin' ]], dtype = np . float64 ) + 0.5 * dr # Check if beam centerline intersects beam grid length , r_enter , r_exit = aabb_intersect ( rc , dr , xyz_src , xyz_axis ) print ( 'Beam centerline - grid intersection length' ) print ( length ) if length <= 10.0 : error ( 'Beam centerline does not intersect grid' ) err = True if err : error ( 'Invalid beam geometry. Exiting...' , halt = True ) else : success ( 'Beam geometry is valid' ) return nbi def check_plasma ( inputs , grid , plasma ): \"\"\" #+#check_plasma #+Checks if plasma paramters dictionary is valid #+*** #+##Input Arguments #+     **inputs**: Input dictionary #+ #+     **grid**: Interpolation grid dictionary #+ #+     **plasma**: Plasma parameters dictionary #+ #+##Output Arguments #+     **plasma**: Updated plasma dictionary #+ #+##Example Usage #+```python #+>>> plasma = check_plasma(inputs, grid, plasma) #+``` \"\"\" err = False info ( 'Checking plasma parameters...' ) nr = grid [ 'nr' ] nz = grid [ 'nz' ] zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_double = { 'dims' : 0 , 'type' : [ float , np . float64 ]} nrnz_double = { 'dims' : [ nr , nz ], 'type' : [ float , np . float64 ]} nrnz_int = { 'dims' : [ nr , nz ], 'type' : [ int , np . int32 , np . int64 ]} schema = { 'time' : zero_double , 'vr' : nrnz_double , 'vt' : nrnz_double , 'vz' : nrnz_double , 'dene' : nrnz_double , 'ti' : nrnz_double , 'te' : nrnz_double , 'zeff' : nrnz_double , 'mask' : nrnz_int , 'data_source' : zero_string } err = check_dict_schema ( schema , plasma , desc = \"plasma parameters\" ) if err : error ( 'Invalid plasma parameters. Exiting...' , halt = True ) if plasma [ 'data_source' ] == '' : error ( 'Invalid data source. An empty string is not a data source.' ) err = True # Electron density w = ( plasma [ 'dene' ] < 0. ) plasma [ 'dene' ][ w ] = 0. # Zeff w = ( plasma [ 'zeff' ] < 1. ) plasma [ 'zeff' ][ w ] = 1. # Electron temperature w = ( plasma [ 'te' ] < 0. ) plasma [ 'te' ][ w ] = 0. # Ion temperature w = ( plasma [ 'ti' ] < 0. ) plasma [ 'ti' ][ w ] = 0. if ( np . abs ( plasma [ 'time' ] - inputs [ 'time' ]) > 0.02 ): warn ( 'Plasma time and input time do not match' ) print ( 'Input time: ' , inputs [ 'time' ]) print ( 'Plasma time: ' , plasma [ 'time' ]) # Add grid elements to plasma dict for key in grid : plasma [ key ] = grid [ key ] if err : error ( 'Invalid plasma parameters. Exiting...' , halt = True ) else : success ( 'Plasma parameters are valid' ) return plasma def check_fields ( inputs , grid , fields ): \"\"\" #+#check_fields #+Checks if electromagnetic fields dictionary is valid #+*** #+##Input Arguments #+     **inputs**: Input dictionary #+ #+     **grid**: Interpolation grid dictionary #+ #+     **fields**: Electromagnetic fields dictionary #+ #+##Output Arguments #+     **fields**: Updated fields dictionary #+ #+##Example Usage #+```python #+>>> fields = check_fields(inputs, grid, fields) #+``` \"\"\" err = False info ( 'Checking electromagnetic fields...' ) nr = grid [ 'nr' ] nz = grid [ 'nz' ] zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_double = { 'dims' : 0 , 'type' : [ float , np . float64 ]} nrnz_double = { 'dims' : [ nr , nz ], 'type' : [ float , np . float64 ]} nrnz_int = { 'dims' : [ nr , nz ], 'type' : [ int , np . int32 , np . int64 ]} schema = { 'time' : zero_double , 'br' : nrnz_double , 'bt' : nrnz_double , 'bz' : nrnz_double , 'er' : nrnz_double , 'et' : nrnz_double , 'ez' : nrnz_double , 'mask' : nrnz_int , 'data_source' : zero_string } err = check_dict_schema ( schema , fields , desc = \"electromagnetic fields\" ) if err : error ( 'Invalid electromagnetic fields. Exiting...' , halt = True ) if fields [ 'data_source' ] == '' : error ( 'Invalid data source. An empty string is not a data source.' ) err = True if np . abs ( fields [ 'time' ] - inputs [ 'time' ]) > 0.02 : warn ( 'Electromagnetic fields time and input time do not match' ) print ( 'Input time: {}' . format ( inputs [ 'time' ])) print ( 'Electromagnetic fields time: {}' . format ( fields [ 'time' ])) # Add grid elements to fields dict for key in grid : fields [ key ] = grid [ key ] if err : error ( 'Invalid electromagnetic fields. Exiting...' , halt = True ) else : success ( 'Electromagnetic fields are valid' ) return fields def check_distribution ( inputs , grid , dist ): \"\"\" #+#check_distribution #+Checks if distribution dictionary is valid #+*** #+##Input Arguments #+     **inputs**: Input dictionary #+ #+     **grid**: Interpolation grid dictionary #+ #+     **dist**: Fast-ion distribution dictionary #+ #+##Output Arguments #+     **dist**: Updated dist dictionary #+ #+##Example Usage #+```python #+>>> dist = check_distribution(inputs, grid, dist) #+``` \"\"\" err = False info ( 'Checking fast-ion distribution...' ) dist_keys = list ( dist . keys ()) if 'type' not in dist_keys : error ( '\"type\" is missing from the fast-ion distribution' ) error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) dist_type = dist [ 'type' ] if dist_type == 1 : print ( 'Using a Guiding Center Fast-ion Density Function' ) if 'nenergy' not in dist_keys : error ( '\"nenergy\" is missing from the fast-ion distribution' ) error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) if 'npitch' not in dist_keys : error ( '\"npitch\" is missing from the fast-ion distribution' ) error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) npitch = dist [ 'npitch' ] nen = dist [ 'nenergy' ] nr = grid [ 'nr' ] nz = grid [ 'nz' ] zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_int = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_double = { 'dims' : 0 , 'type' : [ float , np . float64 ]} nrnz_double = { 'dims' : [ nr , nz ], 'type' : [ float , np . float64 ]} schema = { 'type' : zero_int , 'nenergy' : zero_int , 'npitch' : zero_int , 'energy' : { 'dims' : [ nen ], 'type' : [ float , np . float64 ]}, 'pitch' : { 'dims' : [ npitch ], 'type' : [ float , np . float64 ]}, 'denf' : nrnz_double , 'f' : { 'dims' : [ nen , npitch , nr , nz ], 'type' : [ float , np . float64 ]}, 'time' : zero_double , 'data_source' : zero_string } err = check_dict_schema ( schema , dist , desc = \"fast-ion distribution\" ) if err : error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) dist [ 'grid' ] = grid elif dist_type == 2 : print ( 'Using Guiding Center Monte Carlo fast-ion distribution' ) if 'nparticle' not in dist_keys : error ( '\"nparticle\" is missing from the fast-ion distribution' ) error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) npart = dist [ 'nparticle' ] zero_int = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_long = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_double = { 'dims' : 0 , 'type' :[ float , np . float64 ]} npart_double = { 'dims' : [ npart ], 'type' : [ float , np . float64 ]} npart_int = { 'dims' : [ npart ], 'type' : [ int , np . int32 , np . int64 ]} schema = { 'type' : zero_int , 'nparticle' : zero_long , 'nclass' : zero_int , 'time' : zero_double , 'energy' : npart_double , 'pitch' : npart_double , 'r' : npart_double , 'z' : npart_double , 'weight' : npart_double , 'class' : npart_int , 'data_source' : zero_string } err = check_dict_schema ( schema , dist , desc = \"fast-ion distribution\" ) if err : error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) print ( 'Number of MC particles: {}' . format ( npart )) elif dist_type == 3 : print ( 'Using Full Orbit Monte Carlo fast-ion distribution' ) if 'nparticle' not in dist_keys : error ( '\"nparticle\" is missing from the fast-ion distribution' ) error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) npart = dist [ 'nparticle' ] zero_int = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_long = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_double = { 'dims' : 0 , 'type' : [ float , np . float64 ]} npart_double = { 'dims' : [ npart ], 'type' : [ float , np . float64 ]} npart_int = { 'dims' : [ npart ], 'type' : [ int , np . int32 , np . int64 ]} schema = { 'type' : zero_int , 'nparticle' : zero_long , 'nclass' : zero_int , 'time' : zero_double , 'vr' : npart_double , 'vt' : npart_double , 'vz' : npart_double , 'r' : npart_double , 'z' : npart_double , 'weight' : npart_double , 'class' : npart_int , 'data_source' : zero_string } err = check_dict_schema ( schema , dist , desc = \"fast-ion distribution\" ) if err : error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) print ( 'Number of MC particles: {}' . format ( npart )) else : error ( 'Invalid distribution type. Expected ' + '1 (Guiding Center Density Function), ' + '2 (Guiding Center Monte Carlo), or ' + '3 (Full Orbit Monte Carlo)' ) error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) if dist [ 'data_source' ] == '' : error ( 'Invalid data source. An empty string is not a data source.' ) err = True if np . abs ( dist [ 'time' ] - inputs [ 'time' ]) > 0.02 : warn ( 'Distribution time and input time do not match' ) print ( 'Input time: {}' . format ( inputs [ 'time' ])) print ( 'Distribution time: {}' . format ( dist [ 'time' ])) if err : error ( 'Invalid fast-ion distribution. Exiting...' , halt = True ) else : success ( 'Fast-ion distribution is valid' ) return dist def check_spec ( inputs , chords ): \"\"\" #+#check_spec #+Check if spectral geometry dictionary is valid #+*** #+##Input Arguments #+     **inputs**: input dictionary #+ #+     **chords**: spectral geometry dictionary #+ #+##Example Usage #+```python #+>>> check_spec(inputs, chords) #+``` \"\"\" err = False info ( 'Checking FIDA/BES inputs...' ) chords_keys = list ( chords . keys ()) if 'nchan' not in chords_keys : error ( '\"nchan\" is missing from the FIDA/BES geometry' ) err = True error ( 'Invalid FIDA/BES geometry. Exiting...' , halt = True ) nchan = chords [ 'nchan' ] zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_long = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} nchan_double = { 'dims' : [ nchan ], 'type' : [ float , np . float64 ]} nchan_string = { 'dims' : [ nchan ], 'type' : [ str , np . str_ , np . bytes_ ]} three_nchan_float = { 'dims' : [ 3 , nchan ], 'type' : [ float , np . float64 ]} schema = { 'data_source' : zero_string , 'nchan' : zero_long , 'system' : zero_string , 'id' : nchan_string , 'lens' : three_nchan_float , 'axis' : three_nchan_float , 'sigma_pi' : nchan_double , 'spot_size' : nchan_double , 'radius' : nchan_double } err = check_dict_schema ( schema , chords , desc = \"FIDA/BES geometry\" ) if err : error ( 'Invalid FIDA/BES geometry. Exiting...' , halt = True ) cross_arr = np . zeros ( nchan , dtype = int ) uvw_lens = chords [ 'lens' ] uvw_axis = chords [ 'axis' ] # ROTATE CHORDS INTO BEAM GRID COORDINATES xyz_lens = uvw_to_xyz ( inputs [ 'alpha' ], inputs [ 'beta' ], inputs [ 'gamma' ], uvw_lens , origin = inputs [ 'origin' ]) xyz_axis = uvw_to_xyz ( inputs [ 'alpha' ], inputs [ 'beta' ], inputs [ 'gamma' ], uvw_axis ) # Calculate grid center rc and sides length dr dr = np . array ([ inputs [ 'xmax' ] - inputs [ 'xmin' ], inputs [ 'ymax' ] - inputs [ 'ymin' ], inputs [ 'zmax' ] - inputs [ 'zmin' ]], dtype = float ) rc = np . array ([ inputs [ 'xmin' ], inputs [ 'ymin' ], inputs [ 'zmin' ]], dtype = float ) + 0.5 * dr for i in range ( nchan ): if np . abs ( np . sum ( uvw_axis [:, i ] ** 2. ) - 1. ) > 1e-5 : error ( 'Invalid optical axis for chord \"' + chords [ 'id' ][ i ] + '\". Expected norm(axis) == 1' ) print ( np . sum ( uvw_axis [:, i ] ** 2. ) - 1. ) # Check if viewing chord intersects beam grid length , r_enter , r_exit = aabb_intersect ( rc , dr , xyz_lens [:, i ], xyz_axis [:, i ]) if length <= 0.0 : cross_arr [ i ] = 1 wbad = ( cross_arr == 1 ) nbad = cross_arr [ wbad ] . size if nbad > 0 : warn ( 'The following {} chords do not cross the beam grid:' . format ( nbad )) warn ( 'Chord ID: {}' . format ( chords [ 'id' ][ wbad ])) wgood = ( cross_arr == 0 ) ngood = cross_arr [ wgood ] . size print ( '{} out of {} chords crossed the beam grid' . format ( ngood , nchan )) if ngood == 0 : error ( 'No channels intersect the beam grid' ) err = True if err : error ( 'Invalid FIDA/BES geometry. Exiting...' , halt = True ) else : success ( 'FIDA/BES geometry is valid' ) def check_npa ( inp , npa ): \"\"\" #+#check_npa #+Checks if NPA geometry dictionary is valid #+*** #+##Input Arguments #+     **inputs**: input dictionary #+ #+     **npa**: NPA geometry dictionary #+ #+##Example Usage #+```python #+>>> check_npa(inputs, npa) #+``` \"\"\" err = False info ( 'Checking NPA geometry...' ) npa_keys = npa . keys () if 'nchan' not in npa_keys : error ( '\"nchan\" is missing from the NPA geometry' ) err = True error ( 'Invalid NPA geometry. Exiting...' , halt = True ) nchan = npa [ 'nchan' ] zero_string = { 'dims' : 0 , 'type' : [ str ]} zero_long = { 'dims' : 0 , 'type' : [ int , np . int32 , np . int64 ]} three_float = { 'dims' : [ 3 , nchan ], 'type' : [ float , np . float64 ]} nchan_int = { 'dims' : [ nchan ], 'type' : [ int , np . int32 , np . int64 ]} schema = { 'data_source' : zero_string , 'nchan' : zero_long , 'system' : zero_string , 'id' : { 'dims' : [ nchan ], 'type' : [ str ]}, 'a_shape' : nchan_int , 'd_shape' : nchan_int , 'a_tedge' : three_float , 'a_redge' : three_float , 'a_cent' : three_float , 'd_tedge' : three_float , 'd_redge' : three_float , 'd_cent' : three_float , 'radius' : three_float } err = check_dict_schema ( schema , npa , desc = \"NPA geometry\" ) if err : error ( 'Invalid NPA geometry. Exiting...' , halt = True ) # Check detector/aperture shape w = ( npa [ 'd_shape' ] > 2 ) or ( npa [ 'd_shape' ] == 0 ) nw = len ( npa [ 'd_shape' ][ w ]) if nw != 0 : error ( 'Invalid detector shape. Expected 1 (rectagular) or 2 (circular)' ) print ( 'Invalid indices: {}' . format ( np . arange ( len ( npa [ 'd_shape' ]))[ w ])) err = True w = ( npa [ 'a_shape' ] > 2 ) or ( npa [ 'a_shape' ] == 0 ) nw = len ( npa [ 'a_shape' ]) if nw != 0 : error ( 'Invalid aperture shape. Expected 1 (rectagular) or 2 (circular)' ) print ( 'Invalid indices: {}' . format ( np . arange ( len ( npa [ 'a_shape' ]))[ w ])) err = True # Calculate grid center rc and sides length dr dr = [ inp [ 'xmax' ] - inp [ 'xmin' ], inp [ 'ymax' ] - inp [ 'ymin' ], inp [ 'zmax' ] - inp [ 'zmin' ]] rc = [ inp [ 'xmin' ], inp [ 'ymin' ], inp [ 'zmin' ]] + 0.5 * dr err_arr = np . zeros ( nchan , dtype = int ) for i in range ( nchan ): uvw_det = npa [ 'd_cent' ][:, i ] d_e1 = npa [ 'd_redge' ][:, i ] - uvw_det d_e2 = npa [ 'd_tedge' ][:, i ] - uvw_det uvw_aper = npa [ 'a_cent' ][:, i ] a_e1 = npa [ 'a_redge' ][:, i ] - uvw_aper a_e2 = npa [ 'a_tedge' ][:, i ] - uvw_aper uvw_dir = uvw_aper - uvw_det #Rotate chords into beam grid coordinates xyz_aper = uvw_to_xyz ( inp [ 'alpha' ], inp [ 'beta' ], inp [ 'gamma' ], uvw_aper , origin = inp [ 'origin' ]) xyz_det = uvw_to_xyz ( inp [ 'alpha' ], inp [ 'beta' ], inp [ 'gamma' ], uvw_det , origin = inp [ 'origin' ]) xyz_dir = xyz_aper - xyz_det xyz_dir = xyz_dir / np . sqrt ( np . sum ( xyz_dir * xyz_dir )) # Check if npa chord intersects beam grid length , r_enter , r_exit = aabb_intersect ( rc , dr , xyz_det , xyz_dir ) if length <= 0. : err_arr [ i ] = 1 # Check if NPA detector is pointing in the right direction d_enter = np . sqrt ( np . sum (( r_enter - xyz_aper ) ** 2 )) d_exit = np . sqrt ( np . sum (( r_exit - xyz_aper ) ** 2 )) if d_exit < d_enter : err_arr [ i ] = 1 # Check that the detector and aperture point in the same direction d_e3 = np . cross ( d_e1 , d_e2 ) a_e3 = np . cross ( a_e1 , a_e2 ) a_dp = np . sum ( uvw_dir * a_e3 ) d_dp = np . sum ( uvw_dir * d_e3 ) dp = np . sum ( d_e3 * a_e3 ) if ( dp <= 0. ) or ( a_dp <= 0. ) or ( d_dp <= 0. ): error ( 'The detector and/or aperture plane normal vectors are pointing in the wrong direction. The NPA definition is incorrect.' ) err_arr [ i ] = 1 w = ( err_arr == 0 ) nw = err_arr [ w ] . size ww = ( err_arr != 0 ) nww = err_arr [ ww ] . size print ( '{} out of {} channels crossed the beam grid' . format ( nw , nchan )) if nw == 0 : error ( 'No channels intersect the beam grid' ) err = True if nww > 0 : warn ( 'Some channels did not intersect the beam grid' ) print ( 'Number missed: {}' . format ( nww )) print ( 'Missed channels:' ) print ( '    {}' . format ( npa [ 'id' ][ ww ])) if err : error ( 'Invalid NPA geometry. Exiting...' , halt = True ) else : success ( 'NPA geometry is valid' ) def write_namelist ( filename , inputs ): \"\"\" #+#write_namelist #+Writes namelist file #+*** #+##Input Arguments #+     **filename**: Name of the namelist file #+ #+     **inputs**: Input dictionary #+ #+##Example Usage #+```python #+>>> write_namelist(filename, inputs) #+``` \"\"\" info ( \"Writing namelist file...\" ) fidasim_version = get_version ( get_fidasim_dir ()) with open ( filename , \"w\" ) as f : f . write ( \"!! Created: {} \\n \" . format ( datetime . datetime . now ())) f . write ( \"!! FIDASIM version: {} \\n \" . format ( fidasim_version )) f . write ( \"!! Comment: {} \\n \" . format ( inputs [ 'comment' ])) f . write ( \"&fidasim_inputs \\n\\n \" ) f . write ( \"!! Shot Info \\n \" ) f . write ( \"shot = {:d}    !! Shot Number \\n \" . format ( inputs [ 'shot' ])) f . write ( \"time = {:f}    !! Time [s] \\n \" . format ( inputs [ 'time' ])) f . write ( \"runid = '{}'   !! runID \\n \" . format ( inputs [ 'runid' ])) f . write ( \"result_dir = '{}'    !! Result Directory \\n\\n \" . format ( inputs [ 'result_dir' ])) f . write ( \"!! Input Files \\n \" ) f . write ( \"tables_file = '{}'   !! Atomic Tables File \\n \" . format ( inputs [ 'tables_file' ])) f . write ( \"equilibrium_file = '\" + inputs [ 'equilibrium_file' ] + \"'    !! File containing plasma parameters and fields \\n \" ) f . write ( \"geometry_file = '\" + inputs [ 'geometry_file' ] + \"'    !! File containing NBI and diagnostic geometry \\n \" ) f . write ( \"distribution_file = '\" + inputs [ 'distribution_file' ] + \"'    !! File containing fast-ion distribution \\n\\n \" ) f . write ( \"!! Simulation Switches \\n \" ) f . write ( \"calc_bes = {:d}    !! Calculate Beam Emission and Halo Spectra \\n \" . format ( inputs [ 'calc_bes' ])) f . write ( \"calc_brems = {:d}    !! Calculate Bremsstrahlung \\n \" . format ( inputs [ 'calc_brems' ])) f . write ( \"calc_fida = {:d}    !! Calculate FIDA Spectra \\n \" . format ( inputs [ 'calc_fida' ])) f . write ( \"calc_npa = {:d}   !! Calculate NPA \\n \" . format ( inputs [ 'calc_npa' ])) f . write ( \"calc_birth = {:d}    !! Calculate Birth Profile \\n \" . format ( inputs [ 'calc_birth' ])) f . write ( \"calc_fida_wght = {:d}    !! Calculate FIDA weights \\n \" . format ( inputs [ 'calc_fida_wght' ])) f . write ( \"calc_npa_wght = {:d}    !! Calculate NPA weights \\n \" . format ( inputs [ 'calc_npa_wght' ])) f . write ( \"dump_dcx = {:d}    !! Dump DCX neutrals and spectra \\n\\n \" . format ( inputs [ 'dump_dcx' ])) f . write ( \"!! Debugging Switches \\n \" ) f . write ( \"no_flr = {:d}    !! Turn off Finite Larmor Radius effects \\n \" . format ( inputs [ 'no_flr' ])) f . write ( \"load_neutrals = {:d}    !! Load neutrals from neutrals file \\n \" . format ( inputs [ 'load_neutrals' ])) f . write ( \"neutrals_file = '\" + inputs [ 'neutrals_file' ] + \"'    !! File containing the neutral density \\n \" ) f . write ( \"verbose = {:d}    !! Verbose \\n\\n \" . format ( inputs [ 'verbose' ])) f . write ( \"!! Monte Carlo Settings \\n \" ) f . write ( \"n_fida = {:d}    !! Number of FIDA mc particles \\n \" . format ( inputs [ 'n_fida' ])) f . write ( \"n_npa = {:d}    !! Number of NPA mc particles \\n \" . format ( inputs [ 'n_npa' ])) f . write ( \"n_nbi = {:d}    !! Number of NBI mc particles \\n \" . format ( inputs [ 'n_nbi' ])) f . write ( \"n_halo = {:d}    !! Number of HALO mc particles \\n \" . format ( inputs [ 'n_halo' ])) f . write ( \"n_dcx = {:d}     !! Number of DCX mc particles \\n \" . format ( inputs [ 'n_dcx' ])) f . write ( \"n_birth = {:d}    !! Number of BIRTH mc particles \\n\\n \" . format ( inputs [ 'n_birth' ])) f . write ( \"!! Neutral Beam Settings \\n \" ) f . write ( \"ab = {:f}     !! Beam Species mass [amu] \\n \" . format ( inputs [ 'ab' ])) f . write ( \"pinj = {:f}     !! Beam Power [MW] \\n \" . format ( inputs [ 'pinj' ])) f . write ( \"einj = {:f}     !! Beam Energy [keV] \\n \" . format ( inputs [ 'einj' ])) f . write ( \"current_fractions(1) = {:f} !! Current Fractions (Full component) \\n \" . format ( inputs [ 'current_fractions' ][ 0 ])) f . write ( \"current_fractions(2) = {:f} !! Current Fractions (Half component) \\n \" . format ( inputs [ 'current_fractions' ][ 1 ])) f . write ( \"current_fractions(3) = {:f} !! Current Fractions (Third component) \\n\\n \" . format ( inputs [ 'current_fractions' ][ 2 ])) f . write ( \"!! Plasma Settings \\n \" ) f . write ( \"ai = {:f}     !! Ion Species mass [amu] \\n \" . format ( inputs [ 'ai' ])) f . write ( \"impurity_charge = {:d}     !! Impurity Charge \\n\\n \" . format ( inputs [ 'impurity_charge' ])) f . write ( \"!! Beam Grid Settings \\n \" ) f . write ( \"nx = {:d}    !! Number of cells in X direction (Into Plasma) \\n \" . format ( inputs [ 'nx' ])) f . write ( \"ny = {:d}    !! Number of cells in Y direction \\n \" . format ( inputs [ 'ny' ])) f . write ( \"nz = {:d}    !! Number of cells in Z direction \\n \" . format ( inputs [ 'nz' ])) f . write ( \"xmin = {:f}     !! Minimum X value [cm] \\n \" . format ( inputs [ 'xmin' ])) f . write ( \"xmax = {:f}     !! Maximum X value [cm] \\n \" . format ( inputs [ 'xmax' ])) f . write ( \"ymin = {:f}     !! Minimum Y value [cm] \\n \" . format ( inputs [ 'ymin' ])) f . write ( \"ymax = {:f}     !! Maximum Y value [cm] \\n \" . format ( inputs [ 'ymax' ])) f . write ( \"zmin = {:f}     !! Minimum Z value [cm] \\n \" . format ( inputs [ 'zmin' ])) f . write ( \"zmax = {:f}     !! Maximum Z value [cm] \\n\\n \" . format ( inputs [ 'zmax' ])) f . write ( \"!! Tait-Bryan Angles for z-y`-x`` rotation \\n \" ) f . write ( \"alpha = {:f}     !! Rotation about z-axis [rad] \\n \" . format ( inputs [ 'alpha' ])) f . write ( \"beta  = {:f}     !! Rotation about y`-axis [rad] \\n \" . format ( inputs [ 'beta' ])) f . write ( \"gamma = {:f}     !! Rotation about x``-axis [rad] \\n\\n \" . format ( inputs [ 'gamma' ])) f . write ( \"!! Beam Grid origin in machine coordinates (cartesian) \\n \" ) f . write ( \"origin(1) = {:f}     !! U value [cm] \\n \" . format ( inputs [ 'origin' ][ 0 ])) f . write ( \"origin(2) = {:f}     !! V value [cm] \\n \" . format ( inputs [ 'origin' ][ 1 ])) f . write ( \"origin(3) = {:f}     !! W value [cm] \\n\\n \" . format ( inputs [ 'origin' ][ 2 ])) f . write ( \"!! Wavelength Grid Settings \\n \" ) f . write ( \"nlambda = {:d}    !! Number of Wavelengths \\n \" . format ( inputs [ 'nlambda' ])) f . write ( \"lambdamin = {:f}    !! Minimum Wavelength [nm] \\n \" . format ( inputs [ 'lambdamin' ])) f . write ( \"lambdamax = {:f}    !! Maximum Wavelength [nm] \\n\\n \" . format ( inputs [ 'lambdamax' ])) f . write ( \"!! Weight Function Settings \\n \" ) f . write ( \"ne_wght = {:d}    !! Number of Energies for Weights \\n \" . format ( inputs [ 'ne_wght' ])) f . write ( \"np_wght = {:d}    !! Number of Pitches for Weights \\n \" . format ( inputs [ 'np_wght' ])) f . write ( \"nphi_wght = {:d}    !! Number of Gyro-angles for Weights \\n \" . format ( inputs [ 'nphi_wght' ])) f . write ( \"emax_wght = {:f}    !! Maximum Energy for Weights [keV] \\n \" . format ( inputs [ 'emax_wght' ])) f . write ( \"nlambda_wght = {:d}    !! Number of Wavelengths for Weights \\n \" . format ( inputs [ 'nlambda_wght' ])) f . write ( \"lambdamin_wght = {:f}    !! Minimum Wavelength for Weights [nm] \\n \" . format ( inputs [ 'lambdamin_wght' ])) f . write ( \"lambdamax_wght = {:f}    !! Maximum Wavelength for Weights [nm] \\n\\n \" . format ( inputs [ 'lambdamax_wght' ])) f . write ( \"/ \\n\\n \" ) success ( \"Namelist file created: {} \\n \" . format ( filename )) def write_geometry ( filename , nbi , spec = None , npa = None ): \"\"\" #+#write_geometry #+Write geometry values to a HDF5 file #+*** #+##Input Arguments #+     **filename**: Name of the geometry file #+ #+     **nbi**: NBI geometry structure #+ #+##Keyword Arguments #+     **spec**: Optional, Spectral geometry structure #+ #+     **npa**: Optional, NPA geometry structure #+ #+##Example Usage #+```python #+>>> write_geometry(filename, nbi, spec=spec, npa=npa) #+``` \"\"\" info ( 'Writing geometry file...' ) # Create and open h5 file with h5py . File ( filename , 'w' ) as hf : # File attributes hf . attrs [ 'description' ] = 'Geometric quantities for FIDASIM' # Create nbi group g_nbi = hf . create_group ( 'nbi' ) # nbi att g_nbi . attrs [ 'description' ] = 'Neutral Beam Geometry' g_nbi . attrs [ 'coordinate_system' ] = 'Right-handed cartesian' nbi_description = { 'data_source' : 'Source of the NBI geometry' , 'name' : 'Beam name' , 'src' : 'Position of the center of the beam source grid' , 'axis' : 'Axis of the beam centerline: Centerline(t) = src + axis*t ' , 'focy' : 'Horizonal focal length of the beam' , 'focz' : 'Vertical focal length of the beam' , 'divy' : 'Horizonal divergences of the beam. One for each energy component' , 'divz' : 'Vertical divergences of the beam. One for each energy component' , 'widy' : 'Half width of the beam source grid' , 'widz' : 'Half height of the beam source grid' , 'shape' : 'Shape of the beam source grid: 1=\"rectangular\", 2=\"circular\"' , 'naperture' : 'Number of apertures' , 'ashape' : 'Shape of the aperture(s): 1=\"rectangular\", 2=\"circular\"' , 'awidy' : 'Half width of the aperture(s)' , 'awidz' : 'Half height of the aperture(s)' , 'aoffy' : 'Horizontal (y) offset of the aperture(s) relative to the +x aligned beam centerline' , 'aoffz' : 'Vertical (z) offset of the aperture(s) relative to the +x aligned beam centerline' , 'adist' : 'Distance from the center of the beam source grid to the aperture(s) plane' } nbi_units = { 'src' : 'cm' , 'axis' : 'cm' , 'focy' : 'cm' , 'focz' : 'cm' , 'divy' : 'radians' , 'divz' : 'radians' , 'widy' : 'cm' , 'widz' : 'cm' , 'awidy' : 'cm' , 'awidz' : 'cm' , 'aoffy' : 'cm' , 'aoffz' : 'cm' , 'adist' : 'cm' } write_data ( g_nbi , nbi , nbi_description , nbi_units , name = 'nbi' ) if spec is not None : # Create spec group g_spec = hf . create_group ( 'spec' ) # Spectroscopic attributes g_spec . attrs [ 'description' ] = 'FIDA/BES Chord Geometry' g_spec . attrs [ 'coordinate_system' ] = 'Right-handed cartesian' # Define description attributes spec_description = { 'data_source' : 'Source of the chord geometry' , 'nchan' : 'Number of channels' , 'system' : 'Names of the different spectrocopic systems' , 'id' : 'Line of sight ID' , 'lens' : 'Positions of the lenses' , 'axis' : 'Optical axis of the lines of sight: LOS(t) = lens + axis*t ' , 'radius' : 'Line of sight radius at midplane or tangency point' , 'sigma_pi' : 'Ratio of the intensities of the sigma and pi stark lines. Measured quantity' , 'spot_size' : 'Radius of spot size' } spec_units = { 'lens' : 'cm' , 'axis' : 'cm' , 'radius' : 'cm' , 'spot_size' : 'cm' } write_data ( g_spec , spec , spec_description , spec_units , name = 'spec' ) if npa is not None : # Create npa group g_npa = hf . create_group ( 'npa' ) # Group attributes g_npa . attrs [ 'description' ] = 'NPA Geometry' g_npa . attrs [ 'coordinate_system' ] = 'Right-handed cartesian' # Dataset attributes npa_description = { 'data_source' : 'Source of the NPA geometry' , 'nchan' : 'Number of channels' , 'system' : 'Names of the different NPA systems' , 'id' : 'Line of sight ID' , 'd_shape' : 'Shape of the detector: 1=\"rectangular\", 2=\"circular\"' , 'd_cent' : 'Center of the detector' , 'd_tedge' : 'Center of the detectors top edge' , 'd_redge' : 'Center of the detectors right edge' , 'a_shape' : 'Shape of the aperture: 1=\"rectangular\", 2=\"circular\"' , 'a_cent' : 'Center of the aperture' , 'a_tedge' : 'Center of the apertures top edge' , 'a_redge' : 'Center of the apertures right edge' , 'radius' : 'Line of sight radius at midplane or tangency point' } npa_units = { 'd_cent' : 'cm' , 'd_tedge' : 'cm' , 'd_redge' : 'cm' , 'a_cent' : 'cm' , 'a_tedge' : 'cm' , 'radius' : 'cm' , 'a_redge' : 'cm' } write_data ( g_npa , npa , npa_description , npa_units , name = 'npa' ) if os . path . isfile ( filename ): success ( 'Geometry file created: ' + filename ) else : error ( 'Geometry file creation failed.' ) def write_equilibrium ( filename , plasma , fields ): \"\"\" #+#write_equilibrium #+Write MHD equilibrium values to a HDF5 file #+*** #+##Input Arguments #+     **filename**: Name of the equilibrium file #+ #+     **plasma**: Plasma dictionary #+ #+     **fields**: Electromagnetic fields dictionary #+ #+##Example Usage #+```python #+>>> write_equilibrium(filename, plasma, fields) #+``` \"\"\" info ( 'Writing equilibrium file...' ) with h5py . File ( filename , 'w' ) as hf : # File attribute hf . attrs [ 'description' ] = 'Plasma Parameters and Electromagnetic Fields for FIDASIM' # Create plasma group g_plasma = hf . create_group ( 'plasma' ) # Plasma Attributes g_plasma . attrs [ 'description' ] = 'Plasma Parameters' g_plasma . attrs [ 'coordinate_system' ] = 'Cylindrical' # Dataset attributes plasma_description = { 'data_source' : 'Source of the plasma parameters' , 'time' : 'Time' , 'dene' : 'Electron Number Density: Dene(r,z)' , 'te' : 'Electron Temperature: Te(r,z)' , 'ti' : 'Ion Temperature: Ti(r,z)' , 'zeff' : 'Effective Nuclear Charge: Zeff(r,z)' , 'vr' : 'Bulk plasma flow in the r-direction: Vr(r,z)' , 'vt' : 'Bulk plasma flow in the theta/torodial-direction: Vt(r,z)' , 'vz' : 'Bulk plasma flow in the z-direction: Vz(r,z)' , 'nr' : 'Number of R values' , 'nz' : 'Number of Z values' , 'r' : 'Radius' , 'z' : 'Z' , 'r2d' : 'Radius grid: R(r,z)' , 'z2d' : 'Z grid: Z(r,z)' , 'mask' : 'Boolean mask that indicates where the plasma parameters are well defined' } plasma_units = { 'time' : 's' , 'dene' : 'cm&#94;-3' , 'te' : 'keV' , 'ti' : 'keV' , 'vr' : 'cm/s' , 'vt' : 'cm/s' , 'vz' : 'cm/s' , 'r' : 'cm' , 'z' : 'cm' , 'r2d' : 'cm' , 'z2d' : 'cm' } write_data ( g_plasma , plasma , plasma_description , plasma_units , name = 'plasma' ) # Create fields group g_fields = hf . create_group ( 'fields' ) # Electromagnetic fields attributes g_fields . attrs [ 'description' ] = 'Electromagnetic Fields' g_fields . attrs [ 'coordinate_system' ] = 'Cylindrical' fields_description = { 'data_source' : 'Source of the EM equilibrium' , 'mask' : 'Boolean mask that indicates where the fields are well defined' , 'time' : 'Time' , 'br' : 'Magnetic field in the r-direction: Br(r,z)' , 'bt' : 'Magnetic field in the theta/torodial-direction: Bt(r,z)' , 'bz' : 'Magnetic field in the z-direction: Bz(r,z)' , 'er' : 'Electric field in the r-direction: Er(r,z)' , 'et' : 'Electric field in the theta/torodial-direction: Et(r,z)' , 'ez' : 'Electric field in the z-direction: Ez(r,z)' , 'nr' : 'Number of R values' , 'nz' : 'Number of Z values' , 'r' : 'Radius' , 'z' : 'Z' , 'r2d' : 'Radius grid: R(r,z)' , 'z2d' : 'Z grid: Z(r,z)' } fields_units = { 'time' : 's' , 'br' : 'T' , 'bt' : 'T' , 'bz' : 'T' , 'er' : 'V/m' , 'et' : 'V/m' , 'ez' : 'V/m' , 'nr' : 'V/m' , 'nz' : 'V/m' , 'r' : 'cm' , 'z' : 'cm' , 'r2d' : 'cm' , 'z2d' : 'cm' } write_data ( g_fields , fields , fields_description , fields_units , name = 'fields' ) if os . path . isfile ( filename ): success ( 'Equilibrium file created: ' + filename ) else : error ( 'Equilibrium file creation failed.' ) def write_distribution ( filename , distri ): \"\"\" #+#write_distribution #+Write fast-ion distribution to a HDF5 file #+*** #+##Input Arguments #+     **filename**: Name of the distribution file #+ #+     **dist**: Fast-ion distribution distionary #+ #+##Example Usage #+```dist #+>>> write_distribution(filename, distri) #+``` \"\"\" info ( 'Writing fast-ion distribution file...' ) description = { 'data_source' : 'Source of the fast-ion distribution' , 'type' : 'Distribution type: 1=\"Guiding Center Density Function\", 2=\"Guiding Center ' \\ 'Monte Carlo\", 3=\"Full Orbit Monte Carlo\"' , 'time' : 'Distribution time' } units = { 'time' : 's' } if distri [ 'type' ] == 1 : description [ 'nenergy' ] = 'Number of energy values' description [ 'npitch' ] = 'Number of pitch values' description [ 'energy' ] = 'Energy' description [ 'pitch' ] = 'Pitch: p = v_parallel/v  w.r.t. the magnetic field' description [ 'f' ] = 'Fast-ion density function: F(E,p,R,Z)' description [ 'denf' ] = 'Fast-ion density: Denf(r,z)' description [ 'nr' ] = 'Number of R values' description [ 'nz' ] = 'Number of Z values' description [ 'r' ] = 'Radius' description [ 'z' ] = 'Z' description [ 'r2d' ] = 'Radius grid: R(r,z)' description [ 'z2d' ] = 'Z grid: Z(r,z)' units [ 'energy' ] = 'keV' units [ 'f' ] = 'fast-ions/(dE*dP*cm&#94;3)' units [ 'denf' ] = 'cm&#94;-3' units [ 'r' ] = 'cm' units [ 'z' ] = 'cm' units [ 'r2d' ] = 'cm' units [ 'z2d' ] = 'cm' else : description [ 'nparticle' ] = 'Number of MC particles' description [ 'nclass' ] = 'Number of orbit classes' description [ 'r' ] = 'R position of a MC particle' description [ 'z' ] = 'Z position of a MC particle' description [ 'weight' ] = 'Weight of a MC particle: sum(weight) = # of fast-ions ' description [ 'class' ] = 'Orbit class of a MC particle: class in Set(1:nclass)' units [ 'r' ] = 'cm' units [ 'z' ] = 'cm' units [ 'weight' ] = 'fast-ions/particle' if distri [ 'type' ] == 2 : description [ 'energy' ] = 'Energy of a MC particle' description [ 'pitch' ] = 'Pitch of a MC particle: p = v_parallel/v  w.r.t. the magnetic field' else : description [ 'vr' ] = 'Radial velocity of a MC particle' description [ 'vt' ] = 'Torodial velocity of a MC particle' description [ 'vz' ] = 'Z velocity of a MC particle' units [ 'vr' ] = 'cm/s' units [ 'vt' ] = 'cm/s' units [ 'vz' ] = 'cm/s' with h5py . File ( filename , 'w' ) as hf : # File attr hf . attrs [ 'description' ] = 'Fast-ion distribution for FIDASIM' hf . attrs [ 'coordinate_system' ] = 'Cylindrical' write_data ( hf , distri , description , units , name = 'distribution' ) if os . path . isfile ( filename ): success ( 'Distribution file created: ' + filename ) else : error ( 'Distribution file creation failed.' ) def prefida ( inputs , grid , nbi , plasma , fields , fbm , spec = None , npa = None ): \"\"\" #+#prefida #+Checks FIDASIM inputs and writes FIDASIM input files #+*** #+##Input Arguments #+     **inputs**: Inputs structure #+ #+     **grid**: Interpolation grid structure #+ #+     **nbi**: Neutral beam geometry structure #+ #+     **plasma**: Plasma parameters structure #+ #+     **fields**: Electromagnetic fields structure #+ #+     **fbm**: Fast-ion distribution structure #+ #+##Keyword Arguments #+     **spec**: Optional, Spectral geometry structure #+ #+     **npa**: Optional, NPA geometry structure #+ #+##Example Usage #+```python #+>>> prefida(inputs, grid, nbi, plasma, fields, fbm, spec=spec, npa=npa) #+``` \"\"\" # CHECK INPUTS inputs = check_inputs ( inputs ) # MAKE DIRECTORIES IF THEY DONT EXIST if not os . path . isdir ( inputs [ 'result_dir' ]): os . makedirs ( inputs [ 'result_dir' ]) # CHECK INTERPOLATION GRID check_grid ( grid ) # CHECK BEAM INPUTS nbi = check_beam ( inputs , nbi ) # CHECK PLASMA PARAMETERS plasma = check_plasma ( inputs , grid , plasma ) # CHECK ELECTROMAGNETIC FIELDS fields = check_fields ( inputs , grid , fields ) # CHECK FAST-ION DISTRIBUTION fbm = check_distribution ( inputs , grid , fbm ) # CHECK FIDA/BES if spec is not None : check_spec ( inputs , spec ) # CHECK NPA if npa is not None : check_npa ( inputs , npa ) # WRITE FIDASIM INPUT FILES write_namelist ( inputs [ 'input_file' ], inputs ) # WRITE GEOMETRY FILE write_geometry ( inputs [ 'geometry_file' ], nbi , spec = spec , npa = npa ) # WRITE EQUILIBRIUM FILE write_equilibrium ( inputs [ 'equilibrium_file' ], plasma , fields ) # WRITE DISTRIBUTION FILE write_distribution ( inputs [ 'distribution_file' ], fbm ) print ( '' ) print ( '' ) success ( 'FIDASIM pre-processing completed' ) print ( 'To run FIDASIM use the following command' ) print ( get_fidasim_dir () + os . sep + 'fidasim ' + inputs [ 'result_dir' ] + os . sep + inputs [ 'runid' ] + '_inputs.dat' ) print ( '' ) print ( '' )","tags":"","loc":"sourcefile/preprocessing.py.html","title":"preprocessing.py – FIDASIM"},{"text":"FIDASIM Utilities This file contains useful FIDASIM utilities get_fidasim_dir Gets FIDASIM install directory Output Arguments directory : FIDASIM install directory. Example Usage >>> fida_dir = get_fidasim_dir () get_version Gets FIDASIM version number from git.\nFalls back to reading VERSION file when git is not available Input Arguments fidasim_dir : FIDASIM install directory Output Arguments version : FIDAIM version number. Example Usage >>> version = get_version ( get_fidasim_dir ()) rz_grid Creates interpolation grid Arguments rmin : Minimum radius [cm] rmax : Maximum radius [cm] nr : Number of radii zmin : Minimum Z value [cm] zmax : Maximum Z value [cm] nz : Number of z values Return Value Interpolation grid dictionary Example Usage >>> grid = rz_grid ( 0 , 200.0 , 200 , - 100 , 100 , 200 ) colored Return text string formatting for color in terminal Input Arguments text : String to be colored color : Desired color of string. Red, green, yellow, blue, magenta, cyan, or white. Output Arguments text : Text formated to have \"color\" in terminal. Example Usage >>> text = colored ( \"Text to be red\" , 'red' ) >>> print ( text ) info Print a informational message Arguments str : message Example Usage >>> info ( \"This is an informative message\" ) warn Print a warning message Arguments string : message Example Usage >>> warn ( \"This may be a problem\" ) error Print a error message Arguments string : message Keyword Arguments halt : Halt program execution Example Usage >>> error ( \"Error message\" ) success Print a success message Arguments string : message Example Usage >>> success ( \"Yay!!!\" ) beam_grid Calculates settings for a grid that aligns with the neutral beam. Arguments nbi : Neutral beam geometry structure rstart : Radial start position of beam grid [cm] Keyword Arguments dV : Cell volume [cm&#94;3]: Defaults to 8.0 nx : Number of cells in length: Default determined by dV ny : Number of cells in width: Default determined by dV nz : Number of cells in height: Default determined by dV length : Length of grid along beam sightline. [cm]: Defaults to 100 cm width : Width of grid [cm]: Defaults to 100 cm height : Height of grid [cm]: Defaults 80 cm Return Value Structure containing beam grid settings suitable for the Namelist File Example Usage >>> grid = beam_grid ( nbi , 200.0 , nx = 100 , ny = 50 , nz = 50 , length = 100 , width = 50 , height = 50 ) write_data Write h5 datasets with attributes 'description' and 'units' Arguments h5_obj : An h5 file or group object from h5py dic : Dict of data to save as h5 datasets desc : Dict with same keys as dic describing each item in dic units : Dict with same keys as dic providing units of data in dic, doesn't have to be all keys of dic. Keyword Arguments name : Name/description of dic for clarity in raising errors Example Usage >>> write_data ( h5_obj , dic , desc , units ) Source Code utils.py Source Code #!/usr/bin/env python # -*- coding: utf-8 -*- #+#FIDASIM Utilities #+This file contains useful FIDASIM utilities #+*** from __future__ import print_function import os from os.path import dirname import subprocess import platform import numpy as np import h5py def get_fidasim_dir (): \"\"\" #+#get_fidasim_dir #+ Gets FIDASIM install directory #+*** #+##Output Arguments #+     **directory**: FIDASIM install directory. #+##Example Usage #+```python #+>>> fida_dir = get_fidasim_dir() #+``` \"\"\" directory = dirname ( dirname ( dirname ( dirname ( os . path . abspath ( __file__ ))))) return directory def get_version ( fidasim_dir ): \"\"\" #+#get_version #+ Gets FIDASIM version number from git. #+ Falls back to reading VERSION file when git is not available #+*** #+##Input Arguments #+    **fidasim_dir**: FIDASIM install directory #+ #+##Output Arguments #+     **version**: FIDAIM version number. #+ #+##Example Usage #+```python #+>>> version = get_version(get_fidasim_dir()) #+``` \"\"\" version = '' alt = False if platform . system () == 'Windows' : alt = True else : # Location of .git folder git_dir = r '{}{}.git' . format ( fidasim_dir , os . path . sep ) # git is installed if git_file is a file proc = subprocess . Popen ( 'command -v git' , stdout = subprocess . PIPE , stderr = subprocess . PIPE , shell = True ) git_file = proc . communicate ()[ 0 ] . decode ( 'utf-8' ) git_file = git_file . replace ( ' \\n ' , '' ) # Check that .git folder is present and git is installed if os . path . isfile ( git_file ) and os . path . isdir ( git_dir ): try : version = subprocess . check_output ([ 'git' , '--git-dir={}' . format ( git_dir ), 'describe' , '--tags' , '--always' , '--dirty' ]) version = version . replace ( ' \\n ' , '' ) except : alt = True else : alt = True # If above didn't work, read version file if alt : # Git 'version' filepath ver_file = '{}{}VERSION' . format ( fidasim_dir , os . path . sep ) if os . path . isfile ( ver_file ): with open ( ver_file ) as f : version = f . read () return version def rz_grid ( rmin , rmax , nr , zmin , zmax , nz ): \"\"\" #+#rz_grid #+Creates interpolation grid #+*** #+##Arguments #+    **rmin**: Minimum radius [cm] #+ #+    **rmax**: Maximum radius [cm] #+ #+    **nr**: Number of radii #+ #+    **zmin**: Minimum Z value [cm] #+ #+    **zmax**: Maximum Z value [cm] #+ #+    **nz**: Number of z values #+ #+##Return Value #+Interpolation grid dictionary #+ #+##Example Usage #+```python #+>>> grid = rz_grid(0,200.0,200,-100,100,200) #+``` \"\"\" dr = ( rmax - rmin ) / ( nr - 1 ) dz = ( zmax - zmin ) / ( nz - 1 ) r = rmin + dr * np . arange ( nr , dtype = np . float64 ) z = zmin + dz * np . arange ( nz , dtype = np . float64 ) r2d = np . tile ( r , ( nz , 1 )) . T z2d = np . tile ( z , ( nr , 1 )) grid = { 'r2d' : r2d , 'z2d' : z2d , 'r' : r , 'z' : z , 'nr' : nr , 'nz' : nz } return grid def colored ( text , color ): #, on_color=None, attrs=None): \"\"\" #+#colored #+ Return text string formatting for color in terminal #+*** #+##Input Arguments #+     **text**: String to be colored #+ #+     **color**: Desired color of string. Red, green, yellow, blue, magenta, cyan, or white. #+ #+##Output Arguments #+     **text**: Text formated to have \"color\" in terminal. #+##Example Usage #+```python #+>>> text = colored(\"Text to be red\", 'red') #+>>> print(text) #+``` \"\"\" # Copyright (c) 2008-2011 Volvox Development Team # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. # # Author: Konstantin Lepa <konstantin.lepa@gmail.com> COLORS = dict ( list ( zip ([ 'grey' , 'red' , 'green' , 'yellow' , 'blue' , 'magenta' , 'cyan' , 'white' ,], list ( range ( 30 , 38 ))))) RESET = ' \\033 [0m' if os . getenv ( 'ANSI_COLORS_DISABLED' ) is None : fmt_str = ' \\033 [ %d m %s ' text = fmt_str % ( COLORS [ color ], text ) text += RESET return text def info ( string ): \"\"\" #+#info #+Print a informational message #+*** #+##Arguments #+     **str**: message #+ #+##Example Usage #+```python #+>>> info(\"This is an informative message\") #+``` \"\"\" print ( colored ( 'INFO: ' + string , 'cyan' )) def warn ( string ): \"\"\" #+#warn #+Print a warning message #+*** #+##Arguments #+     **string**: message #+ #+##Example Usage #+```python #+>>> warn(\"This may be a problem\") #+``` \"\"\" print ( colored ( 'WARNING: ' + string , 'magenta' )) def error ( string , halt = False ): \"\"\" #+#error #+Print a error message #+*** #+##Arguments #+     **string**: message #+ #+##Keyword Arguments #+     **halt**: Halt program execution #+ #+##Example Usage #+```python #+>>> error(\"Error message\") #+``` \"\"\" print ( colored ( 'ERROR: {}' . format ( string ), 'red' )) if halt : raise Exception () def success ( string ): \"\"\" #+#success #+Print a success message #+*** #+##Arguments #+     **string**: message #+ #+##Example Usage #+```python #+>>> success(\"Yay!!!\") #+``` \"\"\" print ( colored ( 'SUCCESS: ' + string , 'green' )) def beam_grid ( nbi , rstart , nx = None , ny = None , nz = None , dv = 8.0 , length = 100.0 , width = 80.0 , height = 80.0 ): \"\"\" #+#beam_grid #+ Calculates settings for a grid that aligns with the neutral beam. #+*** #+##Arguments #+    **nbi**: [Neutral beam geometry structure](|url|/page/03_technical/01_prefida_inputs.html#neutral-beam-geometry-structure) #+ #+    **rstart**: Radial start position of beam grid [cm] #+ #+##Keyword Arguments #+    **dV**: Cell volume [cm&#94;3]: Defaults to 8.0 #+ #+    **nx**: Number of cells in length: Default determined by `dV` #+ #+    **ny**: Number of cells in width: Default determined by `dV` #+ #+    **nz**: Number of cells in height: Default determined by `dV` #+ #+    **length**: Length of grid along beam sightline. [cm]: Defaults to 100 cm #+ #+    **width**: Width of grid [cm]: Defaults to 100 cm #+ #+    **height**: Height of grid [cm]: Defaults 80 cm #+ #+##Return Value #+    Structure containing beam grid settings suitable for the Namelist File #+ #+##Example Usage #+```python #+>>> grid = beam_grid(nbi,200.0,nx=100,ny=50,nz=50,length=100,width=50,height=50) #+``` \"\"\" if width < nbi [ 'widy' ]: warn ( \"Grid width is smaller then the source width\" ) print ( \"width: {}\" . format ( width )) print ( \"source width: {}\" . format ( nbi [ 'widy' ])) if height < nbi [ 'widz' ]: warn ( \"Grid height is smaller then the source height\" ) print ( \"height: {}\" . format ( height )) print ( \"source height: {}\" . format ( nbi [ 'widz' ])) dv3 = dv ** ( 1. / 3. ) if nx is None : nx = round ( length / dv3 ) if ny is None : ny = round ( width / dv3 ) if nz is None : nz = round ( height / dv3 ) xmin = 0. xmax = length ymin = - width / 2. ymax = width / 2. zmin = - height / 2. zmax = height / 2. src = nbi [ 'src' ] axis = nbi [ 'axis' ] / np . sqrt ( np . sum ( nbi [ 'axis' ] ** 2 )) pos = src + 100. * axis if np . sqrt ( src [ 0 ] ** 2 + src [ 1 ] ** 2 ) < rstart : error ( \"Source radius cannot be less then rstart\" , halt = True ) dis = np . sqrt ( np . sum (( src - pos ) ** 2.0 )) beta = np . arcsin (( src [ 2 ] - pos [ 2 ]) / dis ) alpha = np . arctan2 (( pos [ 1 ] - src [ 1 ]), ( pos [ 0 ] - src [ 0 ])) gamma = 0. a = axis [ 0 ] ** 2 + axis [ 1 ] ** 2 b = 2. * ( src [ 0 ] * axis [ 0 ] + src [ 1 ] * axis [ 1 ]) c = src [ 0 ] ** 2 + src [ 1 ] ** 2 - rstart ** 2 t = ( - b - np . sqrt ( b ** 2 - 4. * a * c )) / ( 2. * a ) origin = src + t * axis beam_grid = { 'nx' : nx , 'ny' : ny , 'nz' : nz , 'xmin' : xmin , 'xmax' : xmax , 'ymin' : ymin , 'ymax' : ymax , 'zmin' : zmin , 'zmax' : zmax , 'alpha' : alpha , 'beta' : beta , 'gamma' : gamma , 'origin' : origin } return beam_grid def write_data ( h5_obj , dic , desc , units , name = '' ): \"\"\" #+#write_data #+ Write h5 datasets with attributes 'description' and 'units' #+*** #+##Arguments #+     **h5_obj**: An h5 file or group object from h5py #+ #+     **dic**: Dict of data to save as h5 datasets #+ #+     **desc**: Dict with same keys as dic describing each item in dic #+ #+     **units**: Dict with same keys as dic providing units of data in dic, doesn't have to be all keys of dic. #+ #+##Keyword Arguments #+     **name**: Name/description of dic for clarity in raising errors #+ #+##Example Usage #+```python #+>>> write_data(h5_obj, dic, desc, units) #+``` \"\"\" for key in dic : # Transpose data to match expected by Fortran and historically provided by IDL if isinstance ( dic [ key ], np . ndarray ): if dic [ key ] . ndim == 2 : dic [ key ] = dic [ key ] . T elif dic [ key ] . ndim != 1 : raise ValueError ( 'Dict {}, key {}, has shape {}, need fix.' . format ( name , key , dic [ key ] . shape )) # Make strings of fixed length as required by Fortran. # See http://docs.h5py.org/en/latest/strings.html#fixed-length-ascii if isinstance ( dic [ key ], str ): dic [ key ] = np . string_ ( dic [ key ]) # Create dataset ds = h5_obj . create_dataset ( key , data = dic [ key ]) # Add descrption attribute ds . attrs [ 'description' ] = desc [ key ] # Add units attribute (if present) if key in units : ds . attrs [ 'units' ] = units [ key ]","tags":"","loc":"sourcefile/utils.py.html","title":"utils.py – FIDASIM"},{"text":"type, public :: InterpolCoeffs1D Linear Interpolation Coefficients and indices Variables i b1 b2 Source Code InterpolCoeffs1D Components Type Visibility Attributes Name Initial integer, public :: i = 0 Index of position right before xout real(kind=Float64), public :: b1 = 0.d0 Coefficient for y(i) term real(kind=Float64), public :: b2 = 0.d0 Coefficient for y(i+1) term Source Code type InterpolCoeffs1D !+ Linear Interpolation Coefficients and indices integer :: i = 0 !+ Index of position right before `xout` real ( Float64 ) :: b1 = 0.d0 !+ Coefficient for y(i) term real ( Float64 ) :: b2 = 0.d0 !+ Coefficient for y(i+1) term end type InterpolCoeffs1D","tags":"","loc":"type/interpolcoeffs1d.html","title":"InterpolCoeffs1D – FIDASIM "},{"text":"type, public :: InterpolCoeffs2D 2D Linear Interpolation Coefficients and indices Inherited By type~~interpolcoeffs2d~~InheritedByGraph type~interpolcoeffs2d InterpolCoeffs2D type~localprofiles LocalProfiles type~interpolcoeffs2d->type~localprofiles c type~localemfields LocalEMFields type~interpolcoeffs2d->type~localemfields c Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables i j b11 b12 b21 b22 Source Code InterpolCoeffs2D Components Type Visibility Attributes Name Initial integer, public :: i = 0 Index of abscissa before xout integer, public :: j = 0 Index of ordinate before yout real(kind=Float64), public :: b11 = 0.d0 Coefficient for z(i,j) term real(kind=Float64), public :: b12 = 0.d0 Coefficient for z(i,j+1) term real(kind=Float64), public :: b21 = 0.d0 Coefficient for z(i+1,j) term real(kind=Float64), public :: b22 = 0.d0 Coefficient for z(i+1,j+1) term Source Code type InterpolCoeffs2D !+ 2D Linear Interpolation Coefficients and indices integer :: i = 0 !+ Index of abscissa before `xout` integer :: j = 0 !+ Index of ordinate before `yout` real ( Float64 ) :: b11 = 0.d0 !+ Coefficient for z(i,j) term real ( Float64 ) :: b12 = 0.d0 !+ Coefficient for z(i,j+1) term real ( Float64 ) :: b21 = 0.d0 !+ Coefficient for z(i+1,j) term real ( Float64 ) :: b22 = 0.d0 !+ Coefficient for z(i+1,j+1) term end type InterpolCoeffs2D","tags":"","loc":"type/interpolcoeffs2d.html","title":"InterpolCoeffs2D – FIDASIM "},{"text":"type, public :: BeamGrid Defines a 3D grid for neutral beam calculations Variables nx ny nz xmin xmax ymin ymax zmin zmax alpha beta gamma drmin dv volume ntrack ngrid origin center dr lwh basis inv_basis xc yc zc Source Code BeamGrid Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nx Number of cells in the x direction integer(kind=Int32), public :: ny Number of cells in the y direction integer(kind=Int32), public :: nz Number of cells in the z direction real(kind=Float64), public :: xmin Minimum x value real(kind=Float64), public :: xmax Maximum x value real(kind=Float64), public :: ymin Minimum y value real(kind=Float64), public :: ymax Maximum y value real(kind=Float64), public :: zmin Minimum z value real(kind=Float64), public :: zmax Maximum z value real(kind=Float64), public :: alpha Tait-Bryan angle for a rotation about z [radians] real(kind=Float64), public :: beta Tait-Bryan angle for a rotation about y' [radians] real(kind=Float64), public :: gamma Tait-Bryan angle for a rotation about x\" [radians] real(kind=Float64), public :: drmin Minimum cell spacing: min(dx,dy,dz) real(kind=Float64), public :: dv Cell volume [cm&#94;3] real(kind=Float64), public :: volume Grid volume [cm&#94;3] integer(kind=Int32), public :: ntrack Maximum number of cell for particle tracking integer(kind=Int32), public :: ngrid Number of cells real(kind=Float64), public, dimension(3) :: origin Origin of beam grid in machine coordinates real(kind=Float64), public, dimension(3) :: center Center of beam grid in beam coordinates real(kind=Float64), public, dimension(3) :: dr Cell spacings [dx, dy, dz] real(kind=Float64), public, dimension(3) :: lwh Grid [length(x), width(y), height(z)] real(kind=Float64), public, dimension(3,3) :: basis Beam grid basis for converting from beam coordinates(xyz)\nto machine coordinates(uvw): (\\uvw = B*xyz + origin) real(kind=Float64), public, dimension(3,3) :: inv_basis Inverse basis for reverse transformation: (\\xyz = B&#94;{-1}*(uvw - origin)) real(kind=Float64), public, dimension(:), allocatable :: xc x positions of cell centers real(kind=Float64), public, dimension(:), allocatable :: yc y positions of cell centers real(kind=Float64), public, dimension(:), allocatable :: zc z positions of cell centers Source Code type BeamGrid !+ Defines a 3D grid for neutral beam calculations integer ( Int32 ) :: nx !+ Number of cells in the x direction integer ( Int32 ) :: ny !+ Number of cells in the y direction integer ( Int32 ) :: nz !+ Number of cells in the z direction real ( Float64 ) :: xmin !+ Minimum x value real ( Float64 ) :: xmax !+ Maximum x value real ( Float64 ) :: ymin !+ Minimum y value real ( Float64 ) :: ymax !+ Maximum y value real ( Float64 ) :: zmin !+ Minimum z value real ( Float64 ) :: zmax !+ Maximum z value real ( Float64 ) :: alpha !+ Tait-Bryan angle for a rotation about z [radians] real ( Float64 ) :: beta !+ Tait-Bryan angle for a rotation about y' [radians] real ( Float64 ) :: gamma !+ Tait-Bryan angle for a rotation about x\" [radians] real ( Float64 ) :: drmin !+ Minimum cell spacing: `min(dx,dy,dz)` real ( Float64 ) :: dv !+ Cell volume [cm&#94;3] real ( Float64 ) :: volume !+ Grid volume [cm&#94;3] integer ( Int32 ) :: ntrack !+ Maximum number of cell for particle tracking integer ( Int32 ) :: ngrid !+ Number of cells real ( Float64 ), dimension ( 3 ) :: origin !+ Origin of beam grid in machine coordinates real ( Float64 ), dimension ( 3 ) :: center !+ Center of beam grid in beam coordinates real ( Float64 ), dimension ( 3 ) :: dr !+ Cell spacings [dx, dy, dz] real ( Float64 ), dimension ( 3 ) :: lwh !+ Grid [length(x), width(y), height(z)] real ( Float64 ), dimension ( 3 , 3 ) :: basis !+Beam grid basis for converting from beam coordinates(xyz) !+to machine coordinates(uvw): (\\uvw = B*xyz + origin real ( Float64 ), dimension ( 3 , 3 ) :: inv_basis !+Inverse basis for reverse transformation: (\\xyz = B&#94;{-1}*(uvw - origin) real ( Float64 ), dimension (:), allocatable :: xc !+ x positions of cell centers real ( Float64 ), dimension (:), allocatable :: yc !+ y positions of cell centers real ( Float64 ), dimension (:), allocatable :: zc !+ z positions of cell centers end type BeamGrid","tags":"","loc":"type/beamgrid.html","title":"BeamGrid – FIDASIM "},{"text":"type, public :: InterpolationGrid Defines a 2D R-Z grid for interpolating plasma parameters and fields Variables nr nz dr dz da r z r2d z2d Source Code InterpolationGrid Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nr Number of Radii integer(kind=Int32), public :: nz Number of Z values real(kind=Float64), public :: dr Radial spacing [cm] real(kind=Float64), public :: dz Vertical spacing [cm] real(kind=Float64), public :: da Grid element area [cm&#94;2] real(kind=Float64), public, dimension(:), allocatable :: r Radii values [cm] real(kind=Float64), public, dimension(:), allocatable :: z Z values [cm] real(kind=Float64), public, dimension(:,:), allocatable :: r2d 2D R grid [cm] real(kind=Float64), public, dimension(:,:), allocatable :: z2d 2D Z grid [cm] Source Code type InterpolationGrid !+ Defines a 2D R-Z grid for interpolating plasma parameters and fields integer ( Int32 ) :: nr !+ Number of Radii integer ( Int32 ) :: nz !+ Number of Z values real ( Float64 ) :: dr !+ Radial spacing [cm] real ( Float64 ) :: dz !+ Vertical spacing [cm] real ( Float64 ) :: da !+ Grid element area [cm&#94;2] real ( Float64 ), dimension (:), allocatable :: r !+ Radii values [cm] real ( Float64 ), dimension (:), allocatable :: z !+ Z values [cm] real ( Float64 ), dimension (:,:), allocatable :: r2d !+ 2D R grid [cm] real ( Float64 ), dimension (:,:), allocatable :: z2d !+ 2D Z grid [cm] end type InterpolationGrid","tags":"","loc":"type/interpolationgrid.html","title":"InterpolationGrid – FIDASIM "},{"text":"type, public :: Profiles Torodial symmetric plasma parameters at a given R-Z Inherited By type~~profiles~~InheritedByGraph type~profiles Profiles type~equilibrium Equilibrium type~profiles->type~equilibrium plasma type~localprofiles LocalProfiles type~profiles->type~localprofiles Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables dene denp denimp denf te ti zeff vr vt vz Source Code Profiles Components Type Visibility Attributes Name Initial real(kind=Float64), public :: dene = 0.d0 Electron density [cm&#94;{-3}] real(kind=Float64), public :: denp = 0.d0 Ion density [cm&#94;{-3}] real(kind=Float64), public :: denimp = 0.d0 Impurity density [cm&#94;{-3}] real(kind=Float64), public :: denf = 0.d0 Fast-ion density [cm&#94;{-3}] real(kind=Float64), public :: te = 0.d0 Electron temperature [kev] real(kind=Float64), public :: ti = 0.d0 Ion temperature [kev] real(kind=Float64), public :: zeff = 0.d0 Effective Nuclear Charge real(kind=Float64), public :: vr = 0.d0 Plasma rotation in radial direction real(kind=Float64), public :: vt = 0.d0 Plasma rotation in torodial/phi direction real(kind=Float64), public :: vz = 0.d0 Plasma rotation in z direction Source Code type Profiles !+ Torodial symmetric plasma parameters at a given R-Z real ( Float64 ) :: dene = 0.d0 !+ Electron density [cm&#94;{-3}] real ( Float64 ) :: denp = 0.d0 !+ Ion density [cm&#94;{-3}] real ( Float64 ) :: denimp = 0.d0 !+ Impurity density [cm&#94;{-3}] real ( Float64 ) :: denf = 0.d0 !+ Fast-ion density [cm&#94;{-3}] real ( Float64 ) :: te = 0.d0 !+ Electron temperature [kev] real ( Float64 ) :: ti = 0.d0 !+ Ion temperature [kev] real ( Float64 ) :: zeff = 0.d0 !+ Effective Nuclear Charge real ( Float64 ) :: vr = 0.d0 !+ Plasma rotation in radial direction real ( Float64 ) :: vt = 0.d0 !+ Plasma rotation in torodial/phi direction real ( Float64 ) :: vz = 0.d0 !+ Plasma rotation in z direction end type Profiles","tags":"","loc":"type/profiles.html","title":"Profiles – FIDASIM "},{"text":"type, public, extends( Profiles ) :: LocalProfiles type~~localprofiles~~InheritsGraph type~localprofiles LocalProfiles type~interpolcoeffs2d InterpolCoeffs2D type~interpolcoeffs2d->type~localprofiles c type~profiles Profiles type~profiles->type~localprofiles Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Plasma parameters at given position Variables dene denp denimp denf te ti zeff vr vt vz in_plasma machine_coords pos uvw vrot c Source Code LocalProfiles Components Type Visibility Attributes Name Initial real(kind=Float64), public :: dene = 0.d0 Electron density [cm&#94;{-3}] real(kind=Float64), public :: denp = 0.d0 Ion density [cm&#94;{-3}] real(kind=Float64), public :: denimp = 0.d0 Impurity density [cm&#94;{-3}] real(kind=Float64), public :: denf = 0.d0 Fast-ion density [cm&#94;{-3}] real(kind=Float64), public :: te = 0.d0 Electron temperature [kev] real(kind=Float64), public :: ti = 0.d0 Ion temperature [kev] real(kind=Float64), public :: zeff = 0.d0 Effective Nuclear Charge real(kind=Float64), public :: vr = 0.d0 Plasma rotation in radial direction real(kind=Float64), public :: vt = 0.d0 Plasma rotation in torodial/phi direction real(kind=Float64), public :: vz = 0.d0 Plasma rotation in z direction logical, public :: in_plasma = .False. Indicates whether plasma parameters are valid/known logical, public :: machine_coords = .False. Indicates whether vectors are in machine coordinates real(kind=Float64), public, dimension(3) :: pos = 0.d0 Position in beam grid coordinates real(kind=Float64), public, dimension(3) :: uvw = 0.d0 Position in machine coordinates real(kind=Float64), public, dimension(3) :: vrot = 0.d0 Plasma rotation in beam grid coordinates type( InterpolCoeffs2D ), public :: c Linear Interpolation Coefficients and indicies for interpolation at pos Source Code type , extends ( Profiles ) :: LocalProfiles !+ Plasma parameters at given position logical :: in_plasma = . False . !+ Indicates whether plasma parameters are valid/known logical :: machine_coords = . False . !+ Indicates whether vectors are in machine coordinates real ( Float64 ), dimension ( 3 ) :: pos = 0.d0 !+ Position in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: uvw = 0.d0 !+ Position in machine coordinates real ( Float64 ), dimension ( 3 ) :: vrot = 0.d0 !+ Plasma rotation in beam grid coordinates type ( InterpolCoeffs2D ) :: c !+ Linear Interpolation Coefficients and indicies for interpolation at `pos` end type LocalProfiles","tags":"","loc":"type/localprofiles.html","title":"LocalProfiles – FIDASIM "},{"text":"type, public :: EMFields Torodial symmetric electro-magnetic fields at given R-Z Inherited By type~~emfields~~InheritedByGraph type~emfields EMFields type~equilibrium Equilibrium type~emfields->type~equilibrium fields type~localemfields LocalEMFields type~emfields->type~localemfields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables br bt bz er et ez dbr_dr dbr_dz dbt_dr dbt_dz dbz_dr dbz_dz Source Code EMFields Components Type Visibility Attributes Name Initial real(kind=Float64), public :: br = 0.d0 Radial magnetic field [T] real(kind=Float64), public :: bt = 0.d0 Torodial magnetic field [T] real(kind=Float64), public :: bz = 0.d0 Vertical magnetic field [T] real(kind=Float64), public :: er = 0.d0 Radial electric field [V/m] real(kind=Float64), public :: et = 0.d0 Torodial electric field [V/m] real(kind=Float64), public :: ez = 0.d0 Vertical electric field [V/m] real(kind=Float64), public :: dbr_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbr_dz = 0.d0 Vertical derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbt_dr = 0.d0 Radial derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbt_dz = 0.d0 Vertical derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbz_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbz_dz = 0.d0 Vertical derivative of the vertical magnetic field [T/m] Source Code type EMFields !+ Torodial symmetric electro-magnetic fields at given R-Z real ( Float64 ) :: br = 0.d0 !+ Radial magnetic field [T] real ( Float64 ) :: bt = 0.d0 !+ Torodial magnetic field [T] real ( Float64 ) :: bz = 0.d0 !+ Vertical magnetic field [T] real ( Float64 ) :: er = 0.d0 !+ Radial electric field [V/m] real ( Float64 ) :: et = 0.d0 !+ Torodial electric field [V/m] real ( Float64 ) :: ez = 0.d0 !+ Vertical electric field [V/m] real ( Float64 ) :: dbr_dr = 0.d0 !+ Radial derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbr_dz = 0.d0 !+ Vertical derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbt_dr = 0.d0 !+ Radial derivative of the torodial magnetic field [T/m] real ( Float64 ) :: dbt_dz = 0.d0 !+ Vertical derivative of the torodial magnetic field [T/m] real ( Float64 ) :: dbz_dr = 0.d0 !+ Radial derivative of the radial magnetic field [T/m] real ( Float64 ) :: dbz_dz = 0.d0 !+ Vertical derivative of the vertical magnetic field [T/m] end type EMFields","tags":"","loc":"type/emfields.html","title":"EMFields – FIDASIM "},{"text":"type, public, extends( EMFields ) :: LocalEMFields type~~localemfields~~InheritsGraph type~localemfields LocalEMFields type~interpolcoeffs2d InterpolCoeffs2D type~interpolcoeffs2d->type~localemfields c type~emfields EMFields type~emfields->type~localemfields Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Electro-magnetic fields at given position Variables br bt bz er et ez dbr_dr dbr_dz dbt_dr dbt_dz dbz_dr dbz_dz in_plasma machine_coords b_abs e_abs pos uvw b_norm a_norm c_norm e_norm c Source Code LocalEMFields Components Type Visibility Attributes Name Initial real(kind=Float64), public :: br = 0.d0 Radial magnetic field [T] real(kind=Float64), public :: bt = 0.d0 Torodial magnetic field [T] real(kind=Float64), public :: bz = 0.d0 Vertical magnetic field [T] real(kind=Float64), public :: er = 0.d0 Radial electric field [V/m] real(kind=Float64), public :: et = 0.d0 Torodial electric field [V/m] real(kind=Float64), public :: ez = 0.d0 Vertical electric field [V/m] real(kind=Float64), public :: dbr_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbr_dz = 0.d0 Vertical derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbt_dr = 0.d0 Radial derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbt_dz = 0.d0 Vertical derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbz_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbz_dz = 0.d0 Vertical derivative of the vertical magnetic field [T/m] logical, public :: in_plasma = .False. Indicates whether fields are valid/known logical, public :: machine_coords = .False. Indicates whether vectors are in machine coordinates real(kind=Float64), public :: b_abs = 0.d0 Magnitude of magnetic field real(kind=Float64), public :: e_abs = 0.d0 Magnitude of electrin field real(kind=Float64), public, dimension(3) :: pos = 0.d0 Position in beam grid coordinates real(kind=Float64), public, dimension(3) :: uvw = 0.d0 Position in machine coordinates real(kind=Float64), public, dimension(3) :: b_norm = 0.d0 Direction of magnetic field in beam grid coordinates real(kind=Float64), public, dimension(3) :: a_norm = 0.d0 Vector perpendicular to b_norm and c_norm real(kind=Float64), public, dimension(3) :: c_norm = 0.d0 Vector perpendicular to b_norm and a_norm real(kind=Float64), public, dimension(3) :: e_norm = 0.d0 Direction of electric field in beam grid coordinates type( InterpolCoeffs2D ), public :: c Linear Interpolation Coefficients and indicies for interpolation at pos Source Code type , extends ( EMFields ) :: LocalEMFields !+ Electro-magnetic fields at given position logical :: in_plasma = . False . !+ Indicates whether fields are valid/known logical :: machine_coords = . False . !+ Indicates whether vectors are in machine coordinates real ( Float64 ) :: b_abs = 0.d0 !+ Magnitude of magnetic field real ( Float64 ) :: e_abs = 0.d0 !+ Magnitude of electrin field real ( Float64 ), dimension ( 3 ) :: pos = 0.d0 !+ Position in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: uvw = 0.d0 !+ Position in machine coordinates real ( Float64 ), dimension ( 3 ) :: b_norm = 0.d0 !+ Direction of magnetic field in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: a_norm = 0.d0 !+ Vector perpendicular to `b_norm` and `c_norm` real ( Float64 ), dimension ( 3 ) :: c_norm = 0.d0 !+ Vector perpendicular to `b_norm` and `a_norm` real ( Float64 ), dimension ( 3 ) :: e_norm = 0.d0 !+ Direction of electric field in beam grid coordinates type ( InterpolCoeffs2D ) :: c !+ Linear Interpolation Coefficients and indicies for interpolation at `pos` end type LocalEMFields","tags":"","loc":"type/localemfields.html","title":"LocalEMFields – FIDASIM "},{"text":"type, public :: Equilibrium type~~equilibrium~~InheritsGraph type~equilibrium Equilibrium type~emfields EMFields type~emfields->type~equilibrium fields type~profiles Profiles type~profiles->type~equilibrium plasma Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). MHD Equilbrium Variables fields plasma mask Source Code Equilibrium Components Type Visibility Attributes Name Initial type( EMFields ), public, dimension(:,:), allocatable :: fields Electro-magnetic fields at points defined in inter_grid type( Profiles ), public, dimension(:,:), allocatable :: plasma Plasma parameters at points defined in inter_grid real(kind=Float64), public, dimension(:,:), allocatable :: mask Indicates whether fields and plasma are well-defined at points defined in inter_grid Source Code type Equilibrium !+MHD Equilbrium type ( EMFields ), dimension (:,:), allocatable :: fields !+ Electro-magnetic fields at points defined in [[libfida:inter_grid]] type ( Profiles ), dimension (:,:), allocatable :: plasma !+ Plasma parameters at points defined in [[libfida:inter_grid]] real ( Float64 ), dimension (:,:), allocatable :: mask !+ Indicates whether fields and plasma are well-defined at points defined in [[libfida:inter_grid]] end type Equilibrium","tags":"","loc":"type/equilibrium.html","title":"Equilibrium – FIDASIM "},{"text":"type, public :: FastIonDistribution Defines a Guiding Center Fast-ion Distribution Function: F(E,p,R,Z) Variables nenergy npitch nr nz dE dp dr dz emin emax e_range pmin pmax p_range n_tot energy pitch r z denf f Source Code FastIonDistribution Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nenergy Number of energies integer(kind=Int32), public :: npitch Number of pitches integer(kind=Int32), public :: nr Number of radii integer(kind=Int32), public :: nz Number of z values real(kind=Float64), public :: dE Energy spacing [keV] real(kind=Float64), public :: dp Pitch spacing real(kind=Float64), public :: dr Radial spacing [cm] real(kind=Float64), public :: dz Z spacing [cm] real(kind=Float64), public :: emin Minimum energy [keV] real(kind=Float64), public :: emax Maximum energy [keV] real(kind=Float64), public :: e_range Energy interval length [keV] real(kind=Float64), public :: pmin Minimum pitch real(kind=Float64), public :: pmax Maximum pitch real(kind=Float64), public :: p_range Pitch interval length real(kind=Float64), public :: n_tot = 0.d0 Total Number of fast-ions real(kind=Float64), public, dimension(:), allocatable :: energy Energy values [keV] real(kind=Float64), public, dimension(:), allocatable :: pitch Pitch w.r.t. the magnetic field real(kind=Float64), public, dimension(:), allocatable :: r Radius [cm] real(kind=Float64), public, dimension(:), allocatable :: z Z [cm] real(kind=Float64), public, dimension(:,:), allocatable :: denf Fast-ion density defined on the inter_grid : denf(R,Z) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: f Fast-ion distribution function defined on the inter_grid : F(E,p,R,Z) Source Code type FastIonDistribution !+ Defines a Guiding Center Fast-ion Distribution Function: F(E,p,R,Z) integer ( Int32 ) :: nenergy !+ Number of energies integer ( Int32 ) :: npitch !+ Number of pitches integer ( Int32 ) :: nr !+ Number of radii integer ( Int32 ) :: nz !+ Number of z values real ( Float64 ) :: dE !+ Energy spacing [keV] real ( Float64 ) :: dp !+ Pitch spacing real ( Float64 ) :: dr !+ Radial spacing [cm] real ( Float64 ) :: dz !+ Z spacing [cm] real ( Float64 ) :: emin !+ Minimum energy [keV] real ( Float64 ) :: emax !+ Maximum energy [keV] real ( Float64 ) :: e_range !+ Energy interval length [keV] real ( Float64 ) :: pmin !+ Minimum pitch real ( Float64 ) :: pmax !+ Maximum pitch real ( Float64 ) :: p_range !+ Pitch interval length real ( Float64 ) :: n_tot = 0.d0 !+ Total Number of fast-ions real ( Float64 ), dimension (:), allocatable :: energy !+ Energy values [keV] real ( Float64 ), dimension (:), allocatable :: pitch !+ Pitch w.r.t. the magnetic field real ( Float64 ), dimension (:), allocatable :: r !+ Radius [cm] real ( Float64 ), dimension (:), allocatable :: z !+ Z [cm] real ( Float64 ), dimension (:,:), allocatable :: denf !+ Fast-ion density defined on the [[libfida:inter_grid]]: denf(R,Z) real ( Float64 ), dimension (:,:,:,:), allocatable :: f !+ Fast-ion distribution function defined on the [[libfida:inter_grid]]: F(E,p,R,Z) end type FastIonDistribution","tags":"","loc":"type/fastiondistribution.html","title":"FastIonDistribution – FIDASIM "},{"text":"type, public :: FastIon Defines a fast-ion Inherited By type~~fastion~~InheritedByGraph type~fastion FastIon type~fastionparticles FastIonParticles type~fastion->type~fastionparticles fast_ion Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables cross_grid r z phi_enter delta_phi energy pitch vabs vr vt vz weight class Source Code FastIon Components Type Visibility Attributes Name Initial logical, public :: cross_grid = .False. Indicates whether the fast-ion crosses the beam_grid real(kind=Float64), public :: r = 0.d0 Radial position of fast-ion [cm] real(kind=Float64), public :: z = 0.d0 Vertical position of fast-ion [cm] real(kind=Float64), public :: phi_enter = 0.d0 Torodial/phi position where fast-ion enters the beam_grid [radians] real(kind=Float64), public :: delta_phi = 2*pi Angle subtended by the beam_grid at (r,z) real(kind=Float64), public :: energy = 0.d0 Energy [keV] real(kind=Float64), public :: pitch = 0.d0 Pitch w.r.t. the magnetic field real(kind=Float64), public :: vabs = 0.d0 Speed [cm/s] real(kind=Float64), public :: vr = 0.d0 Radial velocity [cm/s] real(kind=Float64), public :: vt = 0.d0 Torodial velocity [cm/s] real(kind=Float64), public :: vz = 0.d0 Z velocity [cm/s] real(kind=Float64), public :: weight = 0.d0 Particle weight: How many fast-ions does particle represent. integer(kind=Int32), public :: class = 0 Orbit class id Source Code type FastIon !+ Defines a fast-ion logical :: cross_grid = . False . !+ Indicates whether the fast-ion crosses the [[libfida:beam_grid]] real ( Float64 ) :: r = 0.d0 !+ Radial position of fast-ion [cm] real ( Float64 ) :: z = 0.d0 !+ Vertical position of fast-ion [cm] real ( Float64 ) :: phi_enter = 0.d0 !+ Torodial/phi position where fast-ion enters the [[libfida:beam_grid]] [radians] real ( Float64 ) :: delta_phi = 2 * pi !+ Angle subtended by the [[libfida:beam_grid]] at (r,z) real ( Float64 ) :: energy = 0.d0 !+ Energy [keV] real ( Float64 ) :: pitch = 0.d0 !+ Pitch w.r.t. the magnetic field real ( Float64 ) :: vabs = 0.d0 !+ Speed [cm/s] real ( Float64 ) :: vr = 0.d0 !+ Radial velocity [cm/s] real ( Float64 ) :: vt = 0.d0 !+ Torodial velocity [cm/s] real ( Float64 ) :: vz = 0.d0 !+ Z velocity [cm/s] real ( Float64 ) :: weight = 0.d0 !+ Particle weight: How many fast-ions does particle represent. integer ( Int32 ) :: class = 0 !+ Orbit class id end type FastIon","tags":"","loc":"type/fastion.html","title":"FastIon – FIDASIM "},{"text":"type, public :: FastIonParticles type~~fastionparticles~~InheritsGraph type~fastionparticles FastIonParticles type~fastion FastIon type~fastion->type~fastionparticles fast_ion Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Collection of fast-ion particles Variables nparticle nclass fast_ion Source Code FastIonParticles Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nparticle = 0 Number of particles integer(kind=Int32), public :: nclass = 1 Number of orbit classes type( FastIon ), public, dimension(:), allocatable :: fast_ion Fast-ion particles Source Code type FastIonParticles !+ Collection of fast-ion particles integer ( Int32 ) :: nparticle = 0 !+ Number of particles integer ( Int32 ) :: nclass = 1 !+ Number of orbit classes type ( FastIon ), dimension (:), allocatable :: fast_ion !+ Fast-ion particles end type FastIonParticles","tags":"","loc":"type/fastionparticles.html","title":"FastIonParticles – FIDASIM "},{"text":"type, public :: NeutralBeam Defines a neutral beam with +x defined to be into the plasma Variables name shape widy widz focy focz einj pinj vinj alpha beta divy divz current_fractions src axis naperture ashape awidy awidz aoffy aoffz adist basis inv_basis Source Code NeutralBeam Components Type Visibility Attributes Name Initial character(len=25), public :: name = '' Beam name integer, public :: shape Beam source shape 1=\"rectangular\", 2=\"circular\" real(kind=Float64), public :: widy Half width of source in y direction real(kind=Float64), public :: widz Half height of source in z direction real(kind=Float64), public :: focy Focal length in y direction real(kind=Float64), public :: focz Focal length in z direction real(kind=Float64), public :: einj NBI voltage  [kV] real(kind=Float64), public :: pinj NBI power    [MW] real(kind=Float64), public :: vinj NBI velocity [cm/s] real(kind=Float64), public :: alpha Z rotation not same as beam_grid alpha real(kind=Float64), public :: beta Tilt rotation not same as beam_grid beta real(kind=Float64), public, dimension(3) :: divy Energy dependent divergence in y direction real(kind=Float64), public, dimension(3) :: divz Energy dependent divergence in z direction real(kind=Float64), public, dimension(3) :: current_fractions Fractions of full, half, and third energy neutrals real(kind=Float64), public, dimension(3) :: src Position of source in beam grid coordinates [cm] real(kind=Float64), public, dimension(3) :: axis Beam centerline integer, public :: naperture Number of beam apertures integer, public, dimension(:), allocatable :: ashape Aperture shape 1=\"rectangular\", 2=\"circular\" real(kind=Float64), public, dimension(:), allocatable :: awidy Half width of the aperture(s) in y direction real(kind=Float64), public, dimension(:), allocatable :: awidz Half height of the aperture(s) in z direction real(kind=Float64), public, dimension(:), allocatable :: aoffy Horizontal (y) offset of the aperture(s) relative to the beam centerline [cm] real(kind=Float64), public, dimension(:), allocatable :: aoffz Vertical (z) offset of the aperture(s) relative to the beam centerline [cm] real(kind=Float64), public, dimension(:), allocatable :: adist Distance from the center of the beam source grid to the aperture(s) plane [cm] real(kind=Float64), public, dimension(3,3) :: basis Beam basis for converting from centerline coordinates to beam grid coordinates real(kind=Float64), public, dimension(3,3) :: inv_basis Inverse basis for reverse transfomation Source Code type NeutralBeam !+ Defines a neutral beam with +x defined to be into the plasma character ( 25 ) :: name = '' !+ Beam name integer :: shape !+ Beam source shape 1=\"rectangular\", 2=\"circular\" real ( Float64 ) :: widy !+ Half width of source in y direction real ( Float64 ) :: widz !+ Half height of source in z direction real ( Float64 ) :: focy !+ Focal length in y direction real ( Float64 ) :: focz !+ Focal length in z direction real ( Float64 ) :: einj !+ NBI voltage  [kV] real ( Float64 ) :: pinj !+ NBI power    [MW] real ( Float64 ) :: vinj !+ NBI velocity [cm/s] real ( Float64 ) :: alpha !+ Z rotation not same as [[libfida:beam_grid]] alpha real ( Float64 ) :: beta !+ Tilt rotation not same as [[libfida:beam_grid]] beta real ( Float64 ), dimension ( 3 ) :: divy !+ Energy dependent divergence in y direction real ( Float64 ), dimension ( 3 ) :: divz !+ Energy dependent divergence in z direction real ( Float64 ), dimension ( 3 ) :: current_fractions !+ Fractions of full, half, and third energy neutrals real ( Float64 ), dimension ( 3 ) :: src !+ Position of source in beam grid coordinates [cm] real ( Float64 ), dimension ( 3 ) :: axis !+ Beam centerline integer :: naperture !+ Number of beam apertures integer , dimension (:), allocatable :: ashape !+ Aperture shape 1=\"rectangular\", 2=\"circular\" real ( Float64 ), dimension (:), allocatable :: awidy !+ Half width of the aperture(s) in y direction real ( Float64 ), dimension (:), allocatable :: awidz !+ Half height of the aperture(s) in z direction real ( Float64 ), dimension (:), allocatable :: aoffy !+ Horizontal (y) offset of the aperture(s) relative to the beam centerline [cm] real ( Float64 ), dimension (:), allocatable :: aoffz !+ Vertical (z) offset of the aperture(s) relative to the beam centerline [cm] real ( Float64 ), dimension (:), allocatable :: adist !+ Distance from the center of the beam source grid to the aperture(s) plane [cm] real ( Float64 ), dimension ( 3 , 3 ) :: basis !+ Beam basis for converting from centerline coordinates to beam grid coordinates real ( Float64 ), dimension ( 3 , 3 ) :: inv_basis !+ Inverse basis for reverse transfomation end type NeutralBeam","tags":"","loc":"type/neutralbeam.html","title":"NeutralBeam – FIDASIM "},{"text":"type, public :: AtomicCrossSection Defines a n/m-resolved atomic cross section table Inherited By type~~atomiccrosssection~~InheritedByGraph type~atomiccrosssection AtomicCrossSection type~atomictables AtomicTables type~atomiccrosssection->type~atomictables H_H_cx Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables nenergy logemin logemax n_max m_max dlogE minlog_cross log_cross Source Code AtomicCrossSection Components Type Visibility Attributes Name Initial integer, public :: nenergy = 1 Number of beam energies real(kind=Float64), public :: logemin = 0.d0 Log-10 minimum energy real(kind=Float64), public :: logemax = 0.d0 Log-10 maximum energy integer, public :: n_max = nlevs Number of initial atomic energy levels integer, public :: m_max = nlevs Number of final atomic energy levels real(kind=Float64), public :: dlogE = 0.d0 Log-10 energy spacing real(kind=Float64), public :: minlog_cross Log-10 minimum cross section real(kind=Float64), public, dimension(:,:,:), allocatable :: log_cross Log-10 cross sections Source Code type AtomicCrossSection !+ Defines a n/m-resolved atomic cross section table integer :: nenergy = 1 !+ Number of beam energies real ( Float64 ) :: logemin = 0.d0 !+ Log-10 minimum energy real ( Float64 ) :: logemax = 0.d0 !+ Log-10 maximum energy integer :: n_max = nlevs !+ Number of initial atomic energy levels integer :: m_max = nlevs !+ Number of final atomic energy levels real ( Float64 ) :: dlogE = 0.d0 !+ Log-10 energy spacing real ( Float64 ) :: minlog_cross !+ Log-10 minimum cross section real ( Float64 ), dimension (:,:,:), allocatable :: log_cross !+ Log-10 cross sections end type AtomicCrossSection","tags":"","loc":"type/atomiccrosssection.html","title":"AtomicCrossSection – FIDASIM "},{"text":"type, public :: AtomicRates Defines an atomic table for populating and de-populating reaction rates Inherited By type~~atomicrates~~InheritedByGraph type~atomicrates AtomicRates type~atomictables AtomicTables type~atomicrates->type~atomictables H_H, H_e, H_Aq Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables nenergy logemin logemax ntemp logtmin logtmax n_max m_max dlogE dlogT minlog_pop minlog_depop ab log_pop log_depop Source Code AtomicRates Components Type Visibility Attributes Name Initial integer, public :: nenergy = 1 Number of beam energies real(kind=Float64), public :: logemin = 0.d0 Log-10 minimum energy real(kind=Float64), public :: logemax = 0.d0 Log-10 maximum energy integer, public :: ntemp = 1 Number of target temperatures real(kind=Float64), public :: logtmin = 0.d0 Log-10 minimum temperature real(kind=Float64), public :: logtmax = 0.d0 Log-10 maximum temperature integer, public :: n_max = nlevs Number of initial atomic energy levels integer, public :: m_max = nlevs Number of final atomic energy levels real(kind=Float64), public :: dlogE = 0.d0 Log-10 energy spacing real(kind=Float64), public :: dlogT = 0.d0 Log-10 temperature spacing real(kind=Float64), public :: minlog_pop = 0.d0 Log-10 minimum reaction rates for populating transistions real(kind=Float64), public :: minlog_depop = 0.d0 Log-10 minimum reaction rates for de-populating transistions real(kind=Float64), public, dimension(2) :: ab = 0.d0 Atomic mass of beam and thermal ions respectively [amu] real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: log_pop Log-10 reaction rates for populating transistions real(kind=Float64), public, dimension(:,:,:,:), allocatable :: log_depop Log-10 reaction rates for de-populating transistions Source Code type AtomicRates !+ Defines an atomic table for populating and de-populating reaction rates integer :: nenergy = 1 !+ Number of beam energies real ( Float64 ) :: logemin = 0.d0 !+ Log-10 minimum energy real ( Float64 ) :: logemax = 0.d0 !+ Log-10 maximum energy integer :: ntemp = 1 !+ Number of target temperatures real ( Float64 ) :: logtmin = 0.d0 !+ Log-10 minimum temperature real ( Float64 ) :: logtmax = 0.d0 !+ Log-10 maximum temperature integer :: n_max = nlevs !+ Number of initial atomic energy levels integer :: m_max = nlevs !+ Number of final atomic energy levels real ( Float64 ) :: dlogE = 0.d0 !+ Log-10 energy spacing real ( Float64 ) :: dlogT = 0.d0 !+ Log-10 temperature spacing real ( Float64 ) :: minlog_pop = 0.d0 !+ Log-10 minimum reaction rates for populating transistions real ( Float64 ) :: minlog_depop = 0.d0 !+ Log-10 minimum reaction rates for de-populating transistions real ( Float64 ), dimension ( 2 ) :: ab = 0.d0 !+ Atomic mass of beam and thermal ions respectively [amu] real ( Float64 ), dimension (:,:,:,:,:), allocatable :: log_pop !+ Log-10 reaction rates for populating transistions real ( Float64 ), dimension (:,:,:,:), allocatable :: log_depop !+ Log-10 reaction rates for de-populating transistions end type AtomicRates","tags":"","loc":"type/atomicrates.html","title":"AtomicRates – FIDASIM "},{"text":"type, public :: NuclearRates Nuclear reaction rates Inherited By type~~nuclearrates~~InheritedByGraph type~nuclearrates NuclearRates type~atomictables AtomicTables type~nuclearrates->type~atomictables D_D Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables nbranch nenergy logemin logemax ntemp logtmin logtmax dlogE dlogT minlog_rate bt_amu log_rate Source Code NuclearRates Components Type Visibility Attributes Name Initial integer, public :: nbranch = 1 Number of reaction branches integer, public :: nenergy = 1 Number of beam energies real(kind=Float64), public :: logemin = 0.d0 Log-10 minimum energy real(kind=Float64), public :: logemax = 0.d0 Log-10 maximum energy integer, public :: ntemp = 1 Number of target temperatures real(kind=Float64), public :: logtmin = 0.d0 Log-10 minimum temperature real(kind=Float64), public :: logtmax = 0.d0 Log-10 maximum temperature real(kind=Float64), public :: dlogE = 0.d0 Log-10 energy spacing real(kind=Float64), public :: dlogT = 0.d0 Log-10 temperature spacing real(kind=Float64), public :: minlog_rate = 0.d0 Log-10 minimum reaction rate real(kind=Float64), public, dimension(2) :: bt_amu = 0.d0 Isotope mass of beam and thermal ions respectively [amu] real(kind=Float64), public, dimension(:,:,:), allocatable :: log_rate Log-10 reaction rates: log_rate(energy, temperature, branch) Source Code type NuclearRates !+ Nuclear reaction rates integer :: nbranch = 1 !+ Number of reaction branches integer :: nenergy = 1 !+ Number of beam energies real ( Float64 ) :: logemin = 0.d0 !+ Log-10 minimum energy real ( Float64 ) :: logemax = 0.d0 !+ Log-10 maximum energy integer :: ntemp = 1 !+ Number of target temperatures real ( Float64 ) :: logtmin = 0.d0 !+ Log-10 minimum temperature real ( Float64 ) :: logtmax = 0.d0 !+ Log-10 maximum temperature real ( Float64 ) :: dlogE = 0.d0 !+ Log-10 energy spacing real ( Float64 ) :: dlogT = 0.d0 !+ Log-10 temperature spacing real ( Float64 ) :: minlog_rate = 0.d0 !+ Log-10 minimum reaction rate real ( Float64 ), dimension ( 2 ) :: bt_amu = 0.d0 !+ Isotope mass of beam and thermal ions respectively [amu] real ( Float64 ), dimension (:,:,:), allocatable :: log_rate !+ Log-10 reaction rates: log_rate(energy, temperature, branch) end type NuclearRates","tags":"","loc":"type/nuclearrates.html","title":"NuclearRates – FIDASIM "},{"text":"type, public :: AtomicTables type~~atomictables~~InheritsGraph type~atomictables AtomicTables type~nuclearrates NuclearRates type~nuclearrates->type~atomictables D_D type~atomiccrosssection AtomicCrossSection type~atomiccrosssection->type~atomictables H_H_cx type~atomicrates AtomicRates type~atomicrates->type~atomictables H_H, H_e, H_Aq Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Atomic tables for various types of interactions Variables H_H_cx H_H H_e H_Aq einstein D_D Source Code AtomicTables Components Type Visibility Attributes Name Initial type( AtomicCrossSection ), public :: H_H_cx Hydrogen-Hydrogen charge exchange n/m-resolved cross sections type( AtomicRates ), public :: H_H Hydrogen-Hydrogen reaction rates type( AtomicRates ), public :: H_e Hydrogen-Electron reaction rates type( AtomicRates ), public :: H_Aq Hydrogen-Impurity reaction rates real(kind=Float64), public, dimension(nlevs,nlevs) :: einstein Einstein coefficients for spontaneous emission type( NuclearRates ), public :: D_D Deuterium-Deuterium reaction rates Source Code type AtomicTables !+ Atomic tables for various types of interactions type ( AtomicCrossSection ) :: H_H_cx !+ Hydrogen-Hydrogen charge exchange n/m-resolved cross sections type ( AtomicRates ) :: H_H !+ Hydrogen-Hydrogen reaction rates type ( AtomicRates ) :: H_e !+ Hydrogen-Electron reaction rates type ( AtomicRates ) :: H_Aq !+ Hydrogen-Impurity reaction rates real ( Float64 ), dimension ( nlevs , nlevs ) :: einstein !+ Einstein coefficients for spontaneous emission type ( NuclearRates ) :: D_D !+ Deuterium-Deuterium reaction rates end type AtomicTables","tags":"","loc":"type/atomictables.html","title":"AtomicTables – FIDASIM "},{"text":"type, public :: LineOfSight Defines a line of sight Inherited By type~~lineofsight~~InheritedByGraph type~lineofsight LineOfSight type~spectralchords SpectralChords type~lineofsight->type~spectralchords los Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables sigma_pi spot_size lens axis Source Code LineOfSight Components Type Visibility Attributes Name Initial real(kind=Float64), public :: sigma_pi = 1.d0 Ratio of sigma to pi line intensity real(kind=Float64), public :: spot_size = 0.d0 Radius of spot size [cm] real(kind=Float64), public, dimension(3) :: lens = 0.d0 Lens location in beam grid coordinates real(kind=Float64), public, dimension(3) :: axis = 0.d0 Optical axis in beam grid coordinates Source Code type LineOfSight !+ Defines a line of sight real ( Float64 ) :: sigma_pi = 1.d0 !+ Ratio of sigma to pi line intensity real ( Float64 ) :: spot_size = 0.d0 !+ Radius of spot size [cm] real ( Float64 ), dimension ( 3 ) :: lens = 0.d0 !+ Lens location in beam grid coordinates real ( Float64 ), dimension ( 3 ) :: axis = 0.d0 !+ Optical axis in beam grid coordinates end type LineOfSight","tags":"","loc":"type/lineofsight.html","title":"LineOfSight – FIDASIM "},{"text":"type, public :: LOSElement Defines a element of a line of sight and cell intersection Inherited By type~~loselement~~InheritedByGraph type~loselement LOSElement type~losinters LOSInters type~loselement->type~losinters los_elem type~spectralchords SpectralChords type~losinters->type~spectralchords inter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables id length Source Code LOSElement Components Type Visibility Attributes Name Initial integer, public :: id Line of sight index real(kind=Float64), public :: length Length of crossing Source Code type LOSElement !+ Defines a element of a line of sight and cell intersection integer :: id !+ Line of sight index real ( Float64 ) :: length !+ Length of crossing end type LOSElement","tags":"","loc":"type/loselement.html","title":"LOSElement – FIDASIM "},{"text":"type, public :: LOSInters type~~losinters~~InheritsGraph type~losinters LOSInters type~loselement LOSElement type~loselement->type~losinters los_elem Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Defines the channels that intersect a cell Inherited By type~~losinters~~InheritedByGraph type~losinters LOSInters type~spectralchords SpectralChords type~losinters->type~spectralchords inter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables nchan los_elem Source Code LOSInters Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 Number of channels that intersect type( LOSElement ), public, dimension(:), allocatable :: los_elem Array of crossing Source Code type LOSInters !+ Defines the channels that intersect a cell integer :: nchan = 0 !+ Number of channels that intersect type ( LOSElement ), dimension (:), allocatable :: los_elem !+ Array of crossing end type LOSInters","tags":"","loc":"type/losinters.html","title":"LOSInters – FIDASIM "},{"text":"type, public :: SpectralChords type~~spectralchords~~InheritsGraph type~spectralchords SpectralChords type~losinters LOSInters type~losinters->type~spectralchords inter type~lineofsight LineOfSight type~lineofsight->type~spectralchords los type~loselement LOSElement type~loselement->type~losinters los_elem Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Defines an spectral diagnostic system Variables nchan los radius inter Source Code SpectralChords Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 Number of channels type( LineOfSight ), public, dimension(:), allocatable :: los Line of sight array real(kind=Float64), public, dimension(:), allocatable :: radius Radius of each line of sight type( LOSInters ), public, dimension(:,:,:), allocatable :: inter Array of LOS intersections with beam_grid Source Code type SpectralChords !+ Defines an spectral diagnostic system integer :: nchan = 0 !+ Number of channels type ( LineOfSight ), dimension (:), allocatable :: los !+ Line of sight array real ( Float64 ), dimension (:), allocatable :: radius !+ Radius of each line of sight type ( LOSInters ), dimension (:,:,:), allocatable :: inter !+ Array of LOS intersections with [[libfida:beam_grid]] end type SpectralChords","tags":"","loc":"type/spectralchords.html","title":"SpectralChords – FIDASIM "},{"text":"type, public :: BoundedPlane Defines a plane with a circular or rectangular boundary Inherited By type~~boundedplane~~InheritedByGraph type~boundedplane BoundedPlane type~npadetector NPADetector type~boundedplane->type~npadetector detector, aperture type~npachords NPAChords type~npadetector->type~npachords det Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables shape hh hw origin basis inv_basis Source Code BoundedPlane Components Type Visibility Attributes Name Initial integer, public :: shape = 0 Boundary shape 1=\"Rectangular\", 2=\"circular\" real(kind=Float64), public :: hh = 0.d0 Half height of boundary [cm] real(kind=Float64), public :: hw = 0.d0 Half width of boundary [cm] real(kind=Float64), public, dimension(3) :: origin = 0.d0 Origin of plane in machine coordinates real(kind=Float64), public, dimension(3,3) :: basis = 0.d0 Basis vectors basis(:,1) = u_1 is plane normal real(kind=Float64), public, dimension(3,3) :: inv_basis = 0.d0 Inverse basis Source Code type BoundedPlane !+ Defines a plane with a circular or rectangular boundary integer :: shape = 0 !+ Boundary shape 1=\"Rectangular\", 2=\"circular\" real ( Float64 ) :: hh = 0.d0 !+ Half height of boundary [cm] real ( Float64 ) :: hw = 0.d0 !+ Half width of boundary [cm] real ( Float64 ), dimension ( 3 ) :: origin = 0.d0 !+ Origin of plane in machine coordinates real ( Float64 ), dimension ( 3 , 3 ) :: basis = 0.d0 !+ Basis vectors basis(:,1) = u_1 is plane normal real ( Float64 ), dimension ( 3 , 3 ) :: inv_basis = 0.d0 !+ Inverse basis end type BoundedPlane","tags":"","loc":"type/boundedplane.html","title":"BoundedPlane – FIDASIM "},{"text":"type, public :: NPADetector type~~npadetector~~InheritsGraph type~npadetector NPADetector type~boundedplane BoundedPlane type~boundedplane->type~npadetector detector, aperture Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Defines a NPA detector Inherited By type~~npadetector~~InheritedByGraph type~npadetector NPADetector type~npachords NPAChords type~npadetector->type~npachords det Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables detector aperture Source Code NPADetector Components Type Visibility Attributes Name Initial type( BoundedPlane ), public :: detector Detecting plane of NPA detector type( BoundedPlane ), public :: aperture Aperture plane of NPA detector Source Code type NPADetector !+ Defines a NPA detector type ( BoundedPlane ) :: detector !+ Detecting plane of NPA detector type ( BoundedPlane ) :: aperture !+ Aperture plane of NPA detector end type NPADetector","tags":"","loc":"type/npadetector.html","title":"NPADetector – FIDASIM "},{"text":"type, public :: NPAProbability Type to contain the probability of hitting a NPA detector Inherited By type~~npaprobability~~InheritedByGraph type~npaprobability NPAProbability type~npachords NPAChords type~npaprobability->type~npachords phit Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables p pitch eff_rd dir Source Code NPAProbability Components Type Visibility Attributes Name Initial real(kind=Float64), public :: p = 0.d0 Hit probability real(kind=Float64), public :: pitch = -2.d0 Pitch real(kind=Float64), public, dimension(3) :: eff_rd = 0.d0 Effective position of detector real(kind=Float64), public, dimension(3) :: dir = 0.d0 Trajectory direction Source Code type NPAProbability !+ Type to contain the probability of hitting a NPA detector real ( Float64 ) :: p = 0.d0 !+ Hit probability real ( Float64 ) :: pitch = - 2.d0 !+ Pitch real ( Float64 ), dimension ( 3 ) :: eff_rd = 0.d0 !+ Effective position of detector real ( Float64 ), dimension ( 3 ) :: dir = 0.d0 !+ Trajectory direction end type NPAProbability","tags":"","loc":"type/npaprobability.html","title":"NPAProbability – FIDASIM "},{"text":"type, public :: NPAChords type~~npachords~~InheritsGraph type~npachords NPAChords type~npadetector NPADetector type~npadetector->type~npachords det type~npaprobability NPAProbability type~npaprobability->type~npachords phit type~boundedplane BoundedPlane type~boundedplane->type~npadetector detector, aperture Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Defines a NPA system Variables nchan det radius hit phit Source Code NPAChords Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 Number of channels type( NPADetector ), public, dimension(:), allocatable :: det NPA detector array real(kind=Float64), public, dimension(:), allocatable :: radius Radius [cm] logical, public, dimension(:,:,:), allocatable :: hit Indicates whether a particle can hit any NPA detector from a grid cell: hit(x,y,z) type( NPAProbability ), public, dimension(:,:,:,:), allocatable :: phit Probability of hitting a detector from a grid cell: phit(x,y,z,chan) Source Code type NPAChords !+ Defines a NPA system integer :: nchan = 0 !+ Number of channels type ( NPADetector ), dimension (:), allocatable :: det !+ NPA detector array real ( Float64 ), dimension (:), allocatable :: radius !+ Radius [cm] logical , dimension (:,:,:), allocatable :: hit !+ Indicates whether a particle can hit any NPA detector from a grid cell: hit(x,y,z) type ( NPAProbability ), dimension (:,:,:,:), allocatable :: phit !+ Probability of hitting a detector from a grid cell: phit(x,y,z,chan) end type NPAChords","tags":"","loc":"type/npachords.html","title":"NPAChords – FIDASIM "},{"text":"type, public :: NPAParticle Defines a NPA particle Inherited By type~~npaparticle~~InheritedByGraph type~npaparticle NPAParticle type~nparesults NPAResults type~npaparticle->type~nparesults part Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables detector xi yi zi xf yf zf weight energy pitch Source Code NPAParticle Components Type Visibility Attributes Name Initial integer, public :: detector = 0 Detector NPA particle hit real(kind=Float64), public :: xi = 0.d0 Initial x position real(kind=Float64), public :: yi = 0.d0 Initial y position real(kind=Float64), public :: zi = 0.d0 Initial z position real(kind=Float64), public :: xf = 0.d0 Final x position real(kind=Float64), public :: yf = 0.d0 Final y position real(kind=Float64), public :: zf = 0.d0 Final z position real(kind=Float64), public :: weight = 0.d0 NPA particle weight real(kind=Float64), public :: energy = 0.d0 Birth Energy [keV] real(kind=Float64), public :: pitch = 0.d0 Birth Pitch Source Code type NPAParticle !+ Defines a NPA particle integer :: detector = 0 !+ Detector NPA particle hit real ( Float64 ) :: xi = 0.d0 !+ Initial x position real ( Float64 ) :: yi = 0.d0 !+ Initial y position real ( Float64 ) :: zi = 0.d0 !+ Initial z position real ( Float64 ) :: xf = 0.d0 !+ Final x position real ( Float64 ) :: yf = 0.d0 !+ Final y position real ( Float64 ) :: zf = 0.d0 !+ Final z position real ( Float64 ) :: weight = 0.d0 !+ NPA particle weight real ( Float64 ) :: energy = 0.d0 !+ Birth Energy [keV] real ( Float64 ) :: pitch = 0.d0 !+ Birth Pitch end type NPAParticle","tags":"","loc":"type/npaparticle.html","title":"NPAParticle – FIDASIM "},{"text":"type, public :: NPAResults type~~nparesults~~InheritsGraph type~nparesults NPAResults type~npaparticle NPAParticle type~npaparticle->type~nparesults part Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). MC NPA result structure Variables nchan npart nmax nenergy part energy flux Source Code NPAResults Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nchan = 0 Number of NPA channels integer(kind=Int32), public :: npart = 0 Number of particles that hit a detector integer(kind=Int32), public :: nmax = 1000000 Maximum allowed number of particles grows if necessary integer(kind=Int32), public :: nenergy = 100 Number of energy values type( NPAParticle ), public, dimension(:), allocatable :: part Array of NPA particles real(kind=Float64), public, dimension(:), allocatable :: energy Energy array [keV] real(kind=Float64), public, dimension(:,:,:), allocatable :: flux Neutral particle flux: flux(energy,chan, orbit_type) [neutrals/(s*dE)] Source Code type NPAResults !+ MC NPA result structure integer ( Int32 ) :: nchan = 0 !+ Number of NPA channels integer ( Int32 ) :: npart = 0 !+ Number of particles that hit a detector integer ( Int32 ) :: nmax = 1000000 !+ Maximum allowed number of particles grows if necessary integer ( Int32 ) :: nenergy = 100 !+ Number of energy values type ( NPAParticle ), dimension (:), allocatable :: part !+ Array of NPA particles real ( Float64 ), dimension (:), allocatable :: energy !+ Energy array [keV] real ( Float64 ), dimension (:,:,:), allocatable :: flux !+ Neutral particle flux: flux(energy,chan, orbit_type) [neutrals/(s*dE)] end type NPAResults","tags":"","loc":"type/nparesults.html","title":"NPAResults – FIDASIM "},{"text":"type, public :: BirthProfile Birth profile structure Variables cnt neut_type ri vi ind dens Source Code BirthProfile Components Type Visibility Attributes Name Initial integer, public :: cnt = 1 Particle counter integer, public, dimension(:), allocatable :: neut_type Particle birth type (1=Full, 2=Half, 3=Third) real(kind=Float64), public, dimension(:,:), allocatable :: ri Particle birth position [cm] real(kind=Float64), public, dimension(:,:), allocatable :: vi Particle birth velocity [cm/s] integer, public, dimension(:,:), allocatable :: ind Particle beam_grid indices real(kind=Float64), public, dimension(:,:,:,:), allocatable :: dens Birth density: dens(neutral_type,x,y,z) [fast-ions/(s*cm&#94;3)] Source Code type BirthProfile !+ Birth profile structure integer :: cnt = 1 !+ Particle counter integer , dimension (:), allocatable :: neut_type !+ Particle birth type (1=Full, 2=Half, 3=Third) real ( Float64 ), dimension (:,:), allocatable :: ri !+ Particle birth position [cm] real ( Float64 ), dimension (:,:), allocatable :: vi !+ Particle birth velocity [cm/s] integer , dimension (:,:), allocatable :: ind !+ Particle [[libfida:beam_grid]] indices real ( Float64 ), dimension (:,:,:,:), allocatable :: dens !+ Birth density: dens(neutral_type,x,y,z) [fast-ions/(s*cm&#94;3)] end type BirthProfile","tags":"","loc":"type/birthprofile.html","title":"BirthProfile – FIDASIM "},{"text":"type, public :: Spectra Spectra storage structure Variables brems bes fida Source Code Spectra Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:), allocatable :: brems Bremsstruhlung: brems(lambda,chan) real(kind=Float64), public, dimension(:,:,:), allocatable :: bes Beam emission: bes(lambda,chan,neutral_type) real(kind=Float64), public, dimension(:,:,:), allocatable :: fida FIDA emission: fida(lambda,chan,orbit_type) Source Code type Spectra !+ Spectra storage structure real ( Float64 ), dimension (:,:), allocatable :: brems !+ Bremsstruhlung: brems(lambda,chan) real ( Float64 ), dimension (:,:,:), allocatable :: bes !+ Beam emission: bes(lambda,chan,neutral_type) real ( Float64 ), dimension (:,:,:), allocatable :: fida !+ FIDA emission: fida(lambda,chan,orbit_type) end type Spectra","tags":"","loc":"type/spectra.html","title":"Spectra – FIDASIM "},{"text":"type, public :: NeutronRate Neutron storage structure Variables rate weight Source Code NeutronRate Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:), allocatable :: rate Neutron rate: rate(orbit_type) [neutrons/sec] real(kind=Float64), public, dimension(:,:,:,:), allocatable :: weight Neutron rate weight: weight(E,p,R,Z) Source Code type NeutronRate !+ Neutron storage structure real ( Float64 ), dimension (:), allocatable :: rate !+ Neutron rate: rate(orbit_type) [neutrons/sec] real ( Float64 ), dimension (:,:,:,:), allocatable :: weight !+ Neutron rate weight: weight(E,p,R,Z) end type NeutronRate","tags":"","loc":"type/neutronrate.html","title":"NeutronRate – FIDASIM "},{"text":"type, public :: NeutralDensity Neutral density structure Variables dens Source Code NeutralDensity Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: dens Neutral density: dens(lev,neutral_type,x,y,z) Source Code type NeutralDensity !+ Neutral density structure real ( Float64 ), dimension (:,:,:,:,:), allocatable :: dens !+ Neutral density: dens(lev,neutral_type,x,y,z) end type NeutralDensity","tags":"","loc":"type/neutraldensity.html","title":"NeutralDensity – FIDASIM "},{"text":"type, public :: FIDAWeights FIDA weights structure Variables mean_f weight Source Code FIDAWeights Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:,:), allocatable :: mean_f Estimate of mean fast-ion distribution function \"seen\" by LOS: mean_f(E,p,chan) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: weight FIDA weight function: weight(lambda,E,p,chan) Source Code type FIDAWeights !+ FIDA weights structure real ( Float64 ), dimension (:,:,:), allocatable :: mean_f !+ Estimate of mean fast-ion distribution function \"seen\" by LOS: mean_f(E,p,chan) real ( Float64 ), dimension (:,:,:,:), allocatable :: weight !+ FIDA weight function: weight(lambda,E,p,chan) end type FIDAWeights","tags":"","loc":"type/fidaweights.html","title":"FIDAWeights – FIDASIM "},{"text":"type, public :: NPAWeights NPA weights structure Variables attenuation cx emissivity weight flux Source Code NPAWeights Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: attenuation Attenuation fraction: attenuation(E,x,y,z,chan) real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: cx Charge Exchange reaction rates: cx(E,x,y,z,chan) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: emissivity Emissivity: emissivity(x,y,z,chan) [neutrals/(s*dV)] real(kind=Float64), public, dimension(:,:,:), allocatable :: weight NPA weight function: weight(E,p,chan) [neutrals/(s fast-ion dE*dP)] real(kind=Float64), public, dimension(:,:), allocatable :: flux Neutral particle flux: flux(E,chan) [neutrals/(s*dE)] Source Code type NPAWeights !+ NPA weights structure real ( Float64 ), dimension (:,:,:,:,:), allocatable :: attenuation !+ Attenuation fraction: attenuation(E,x,y,z,chan) real ( Float64 ), dimension (:,:,:,:,:), allocatable :: cx !+ Charge Exchange reaction rates: cx(E,x,y,z,chan) real ( Float64 ), dimension (:,:,:,:), allocatable :: emissivity !+ Emissivity: emissivity(x,y,z,chan) [neutrals/(s*dV)] real ( Float64 ), dimension (:,:,:), allocatable :: weight !+ NPA weight function: weight(E,p,chan) [neutrals/(s*fast-ion*dE*dP)] real ( Float64 ), dimension (:,:), allocatable :: flux !+ Neutral particle flux: flux(E,chan) [neutrals/(s*dE)] end type NPAWeights","tags":"","loc":"type/npaweights.html","title":"NPAWeights – FIDASIM "},{"text":"type, public :: SimulationInputs Simulation settings structure Variables shot_number time runid result_dir tables_file geometry_file equilibrium_file distribution_file neutrals_file n_fida n_npa n_nbi n_dcx n_halo n_birth calc_spec calc_brems calc_bes calc_fida load_neutrals calc_npa calc_fida_wght calc_npa_wght calc_birth calc_neutron no_flr dump_dcx verbose ab impurity_charge ai dist_type nlambda dlambda lambdamin lambdamax ne_wght np_wght nphi_wght nlambda_wght emax_wght lambdamin_wght lambdamax_wght Source Code SimulationInputs Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: shot_number Shot Number real(kind=Float64), public :: time Shot time [s] character(len=charlim), public :: runid = '' FIDASIM run ID character(len=charlim), public :: result_dir = '' Result directory character(len=charlim), public :: tables_file = '' Atomic tables file character(len=charlim), public :: geometry_file = '' FIDASIM input file containing geometric quantities character(len=charlim), public :: equilibrium_file = '' FIDASIM input file containing the plasma parameters and fields character(len=charlim), public :: distribution_file = '' FIDASIM input file containing the fast-ion distribution character(len=charlim), public :: neutrals_file = '' FIDASIM output/input file containing beam neutral density.\n Used when load_neutrals is set. integer(kind=Int64), public :: n_fida Number of FIDA mc markers integer(kind=Int64), public :: n_npa Number of NPA mc markers integer(kind=Int64), public :: n_nbi Number of neutral beam mc markers integer(kind=Int64), public :: n_dcx Number of direct charge exchange (DCX) mc markers integer(kind=Int64), public :: n_halo Number of halo mc markers integer(kind=Int64), public :: n_birth Number of birth particles per n_nbi integer(kind=Int32), public :: calc_spec Calculate spectra: 0 = off, 1=on integer(kind=Int32), public :: calc_brems Calculate bremmstruhlung: 0 = off, 1=on integer(kind=Int32), public :: calc_bes Calculate BES: 0 = off, 1=on integer(kind=Int32), public :: calc_fida Calculate FIDA: 0 = off, 1=on integer(kind=Int32), public :: load_neutrals Load neutrals from file: 0 = off, 1=on integer(kind=Int32), public :: calc_npa Calculate NPA: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: calc_fida_wght Calculate FIDA weight: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: calc_npa_wght Calculate NPA weights: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: calc_birth Calculate birth profile: 0 = off, 1=on integer(kind=Int32), public :: calc_neutron Calculate neutron flux: 0 = off, 1=on integer(kind=Int32), public :: no_flr Turns off Finite Larmor Radius effects: 0=off, 1=on integer(kind=Int32), public :: dump_dcx Output DCX density and spectra: 0 = off, 1=on integer(kind=Int32), public :: verbose real(kind=Float64), public :: ab Atomic mass of beam neutrals integer(kind=Int32), public :: impurity_charge Impurity proton number real(kind=Float64), public :: ai Atomic mass of thermal ions integer(kind=Int32), public :: dist_type Type of fast-ion distribution integer(kind=Int32), public :: nlambda Number of wavelength to calculate real(kind=Float64), public :: dlambda Wavelength spacing [nm] real(kind=Float64), public :: lambdamin Minimum wavelength [nm] real(kind=Float64), public :: lambdamax Maximum wavelength [nm] integer(kind=Int32), public :: ne_wght Number of energies in weight functions integer(kind=Int32), public :: np_wght Number of pitches in weight functions integer(kind=Int32), public :: nphi_wght Number of gyro-angles to average over in weight functions integer(kind=Int32), public :: nlambda_wght Number of wavelength to calculate in weight functions real(kind=Float64), public :: emax_wght Maximum energy in weight functions [keV] real(kind=Float64), public :: lambdamin_wght Minimum wavelength in weight functions [nm] real(kind=Float64), public :: lambdamax_wght Maximum wavelength in weight functions [nm] Source Code type SimulationInputs !+ Simulation settings structure integer ( Int32 ) :: shot_number !+ Shot Number real ( Float64 ) :: time !+ Shot time [s] character ( charlim ) :: runid = '' !+ FIDASIM run ID character ( charlim ) :: result_dir = '' !+ Result directory character ( charlim ) :: tables_file = '' !+ Atomic tables file character ( charlim ) :: geometry_file = '' !+ FIDASIM input file containing geometric quantities character ( charlim ) :: equilibrium_file = '' !+ FIDASIM input file containing the plasma parameters and fields character ( charlim ) :: distribution_file = '' !+ FIDASIM input file containing the fast-ion distribution character ( charlim ) :: neutrals_file = '' !+ FIDASIM output/input file containing beam neutral density. !+ Used when [[SimulationInputs:load_neutrals]] is set. !! Monte Carlo settings integer ( Int64 ) :: n_fida !+ Number of FIDA mc markers integer ( Int64 ) :: n_npa !+ Number of NPA mc markers integer ( Int64 ) :: n_nbi !+ Number of neutral beam mc markers integer ( Int64 ) :: n_dcx !+ Number of direct charge exchange (DCX) mc markers integer ( Int64 ) :: n_halo !+ Number of halo mc markers integer ( Int64 ) :: n_birth !+ Number of birth particles per [[SimulationInputs:n_nbi]] !! Simulation switches integer ( Int32 ) :: calc_spec !+ Calculate spectra: 0 = off, 1=on integer ( Int32 ) :: calc_brems !+ Calculate bremmstruhlung: 0 = off, 1=on integer ( Int32 ) :: calc_bes !+ Calculate BES: 0 = off, 1=on integer ( Int32 ) :: calc_fida !+ Calculate FIDA: 0 = off, 1=on integer ( Int32 ) :: load_neutrals !+ Load neutrals from file: 0 = off, 1=on integer ( Int32 ) :: calc_npa !+ Calculate NPA: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: calc_fida_wght !+ Calculate FIDA weight: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: calc_npa_wght !+ Calculate NPA weights: 0 = off, 1=on, 2=on++ integer ( Int32 ) :: calc_birth !+ Calculate birth profile: 0 = off, 1=on integer ( Int32 ) :: calc_neutron !+ Calculate neutron flux: 0 = off, 1=on integer ( Int32 ) :: no_flr !+ Turns off Finite Larmor Radius effects: 0=off, 1=on integer ( Int32 ) :: dump_dcx !+ Output DCX density and spectra: 0 = off, 1=on integer ( Int32 ) :: verbose !+ Verbosity: <0 = off++, 0 = off, 1=on, 2=on++ !! Neutral Beam Settings real ( Float64 ) :: ab !+ Atomic mass of beam neutrals !! Plasma parameters integer ( Int32 ) :: impurity_charge !+ Impurity proton number real ( Float64 ) :: ai !+ Atomic mass of thermal ions !! Distribution settings integer ( Int32 ) :: dist_type !+ Type of fast-ion distribution !! Spectrum parameters integer ( Int32 ) :: nlambda !+ Number of wavelength to calculate real ( Float64 ) :: dlambda !+ Wavelength spacing [nm] real ( Float64 ) :: lambdamin !+ Minimum wavelength [nm] real ( Float64 ) :: lambdamax !+ Maximum wavelength [nm] !! Weight function settings integer ( Int32 ) :: ne_wght !+ Number of energies in weight functions integer ( Int32 ) :: np_wght !+ Number of pitches in weight functions integer ( Int32 ) :: nphi_wght !+ Number of gyro-angles to average over in weight functions integer ( Int32 ) :: nlambda_wght !+ Number of wavelength to calculate in weight functions real ( Float64 ) :: emax_wght !+ Maximum energy in weight functions [keV] real ( Float64 ) :: lambdamin_wght !+ Minimum wavelength in weight functions [nm] real ( Float64 ) :: lambdamax_wght !+ Maximum wavelength in weight functions [nm] end type SimulationInputs","tags":"","loc":"type/simulationinputs.html","title":"SimulationInputs – FIDASIM "},{"text":"type, public :: ParticleTrack Stores properties seen when traveling through a 3D grid Variables time flux ind pos Source Code ParticleTrack Components Type Visibility Attributes Name Initial real(kind=Float64), public :: time = 0.d0 Time/distance/... in cell real(kind=Float64), public :: flux = 0.d0 Flux/density/... in cell integer(kind=Int32), public, dimension(3) :: ind = 0 Indices of cell real(kind=Float64), public, dimension(3) :: pos = 0.d0 Midpoint of track in cell [cm] Source Code type ParticleTrack !+ Stores properties seen when traveling through a 3D grid real ( Float64 ) :: time = 0.d0 !+ Time/distance/... in cell real ( Float64 ) :: flux = 0.d0 !+ Flux/density/... in cell integer ( Int32 ), dimension ( 3 ) :: ind = 0 !+ Indices of cell real ( Float64 ), dimension ( 3 ) :: pos = 0.d0 !+ Midpoint of track in cell [cm] end type ParticleTrack","tags":"","loc":"type/particletrack.html","title":"ParticleTrack – FIDASIM "},{"text":"type, public :: GyroSurface Surface containing the fast-ion velocity vectors for all values of the\n gyro-angle. It takes the form of a hyperboloid \n (x(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(cos(\\gamma + \\pi/2) - \\omega_i t sin(\\gamma + \\pi/2)) \n (y(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(sin(\\gamma + \\pi/2) + \\omega_i t cos(\\gamma + \\pi/2)) \n (z(\\gamma,t) = \\alpha \\omega_i \\rm{pitch} t\n where \\gamma is the gyro-angle, \\omega_i is the ion\n gyro-frequency and \\alpha = V/\\omega_i  Variables v omega axes center A basis Source Code GyroSurface Components Type Visibility Attributes Name Initial real(kind=Float64), public :: v = 0.d0 Particle speed real(kind=Float64), public :: omega = 0.d0 Ion gyro-frequency real(kind=Float64), public, dimension(3) :: axes Semi-axes of the hyperboloid, i.e. a, b, c coefficients real(kind=Float64), public, dimension(3) :: center = 0.d0 Center of the gyrosurface real(kind=Float64), public, dimension(3,3) :: A = 0.d0 Coefficients of quartic surface i.e. basis*diagm(1/a&#94;2,1/b&#94;2,1/c&#94;2)*basis' real(kind=Float64), public, dimension(3,3) :: basis = 0.d0 Basis of coordinate system of gyrosurface Source Code type GyroSurface !+ Surface containing the fast-ion velocity vectors for all values of the !+ gyro-angle. It takes the form of a hyperboloid !+ (x(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(cos(\\gamma + \\pi/2) - \\omega_i t sin(\\gamma + \\pi/2))  !+ (y(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(sin(\\gamma + \\pi/2) + \\omega_i t cos(\\gamma + \\pi/2))  !+ (z(\\gamma,t) = \\alpha \\omega_i \\rm{pitch} t !+ where \\gamma is the gyro-angle, \\omega_i is the ion !+ gyro-frequency and \\alpha = V/\\omega_i  real ( Float64 ) :: v = 0.d0 !+ Particle speed real ( Float64 ) :: omega = 0.d0 !+ Ion gyro-frequency real ( Float64 ), dimension ( 3 ) :: axes !+ Semi-axes of the hyperboloid, i.e. a, b, c coefficients real ( Float64 ), dimension ( 3 ) :: center = 0.d0 !+ Center of the gyrosurface real ( Float64 ), dimension ( 3 , 3 ) :: A = 0.d0 !+ Coefficients of quartic surface i.e. `basis*diagm(1/a&#94;2,1/b&#94;2,1/c&#94;2)*basis'` real ( Float64 ), dimension ( 3 , 3 ) :: basis = 0.d0 !+ Basis of coordinate system of gyrosurface end type GyroSurface","tags":"","loc":"type/gyrosurface.html","title":"GyroSurface – FIDASIM "},{"text":"type, public :: rng_type Random Number Generator Derived Type Variables state Source Code rng_type Components Type Visibility Attributes Name Initial integer(kind=Int32), public, dimension(ns) :: state Source Code type :: rng_type !+ Random Number Generator Derived Type integer ( Int32 ), dimension ( ns ) :: state end type rng_type","tags":"","loc":"type/rng_type.html","title":"rng_type – FIDASIM "},{"text":"type, public :: SparseArray Variables nnz nd dims inds vals Source Code SparseArray Components Type Visibility Attributes Name Initial integer, public :: nnz = 0 Number of non-zero elements integer, public :: nd = 0 Number of dimensions integer, public, dimension(:), allocatable :: dims Dimensions of array integer, public, dimension(:), allocatable :: inds Linear index of non-zero elements real(kind=Float64), public, dimension(:), allocatable :: vals Array values Source Code type SparseArray integer :: nnz = 0 !+ Number of non-zero elements integer :: nd = 0 !+ Number of dimensions integer , dimension (:), allocatable :: dims !+ Dimensions of array integer , dimension (:), allocatable :: inds !+ Linear index of non-zero elements real ( Float64 ), dimension (:), allocatable :: vals !+ Array values end type SparseArray","tags":"","loc":"type/sparsearray.html","title":"SparseArray – FIDASIM "},{"text":"public function comabs(ar, ai) Calculates absolute value of a complex number a Arguments Type Intent Optional Attributes Name real(kind=double) :: ar Real part of a real(kind=double) :: ai Imaginary part of a Return Value real(kind=double) Absolute value of a Calls proc~~comabs~~CallsGraph proc~comabs comabs proc~rswap RSWAP proc~comabs->proc~rswap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code comabs Source Code function comabs ( ar , ai ) !+ Calculates absolute value of a complex number `a` real ( double ) :: ar !+ Real part of `a` real ( double ) :: ai !+ Imaginary part of `a` real ( double ) :: comabs !+ Absolute value of `a` if ( ar == ZERO . and . ai == ZERO ) then Comabs = ZERO return endif ar = DABS ( ar ) ai = DABS ( ai ) if ( ai > ar ) then !Switch  ai and ar call RSWAP ( ai , ar ) endif if ( ai == ZERO ) then Comabs = ar else Comabs = ar * DSQRT ( ONE + ai / ar * ai / ar ) endif end function comabs","tags":"","loc":"proc/comabs.html","title":"comabs – FIDASIM"},{"text":"public function outerprod(a, b) Calculates outer product Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: a real(kind=double), intent(in), dimension(:) :: b Return Value real(kind=double),\n  dimension(size(a),size(b)) Called By proc~~outerprod~~CalledByGraph proc~outerprod outerprod proc~ludcmp ludcmp proc~ludcmp->proc~outerprod proc~matinv matinv proc~matinv->proc~ludcmp proc~colrad colrad proc~colrad->proc~matinv proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate var panprocouterprodCalledByGraph = svgPanZoom('#procouterprodCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code outerprod Source Code function outerprod ( a , b ) !+ Calculates outer product real ( double ), dimension (:), intent ( IN ) :: a , b real ( double ), dimension ( size ( a ), size ( b )) :: outerprod outerprod = spread ( a , dim = 2 , ncopies = size ( b )) * & spread ( b , dim = 1 , ncopies = size ( a )) end function outerprod","tags":"","loc":"proc/outerprod.html","title":"outerprod – FIDASIM"},{"text":"public subroutine RSWAP(a, b) Swaps values a and b Arguments Type Intent Optional Attributes Name real(kind=double) :: a real(kind=double) :: b Called By proc~~rswap~~CalledByGraph proc~rswap RSWAP proc~comabs comabs proc~comabs->proc~rswap proc~elmhes elmhes proc~elmhes->proc~rswap proc~balback balback proc~balback->proc~rswap proc~balance balance proc~balance->proc~rswap proc~eigen eigen proc~eigen->proc~elmhes proc~eigen->proc~balback proc~eigen->proc~balance proc~colrad colrad proc~colrad->proc~eigen proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate var panprocrswapCalledByGraph = svgPanZoom('#procrswapCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code RSWAP Source Code subroutine RSWAP ( a , b ) !+ Swaps values `a` and `b` real ( double ) :: a , b , t t = a ; a = b ; b = t end subroutine RSWAP","tags":"","loc":"proc/rswap.html","title":"RSWAP – FIDASIM"},{"text":"public subroutine balance(n, mat, scal, low, high) Balances the matrix so that the rows with zero entries\noff the diagonal are isolated and the remaining columns and rows\nare resized to have one norm close to 1. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of mat real(kind=double) :: mat (0:n,0:n) n x n scaled matrix real(kind=double) :: scal (0:n) Contains isolated eigenvalue in the positions 0- low and high - n -1\n its other components contain the scaling factors for transforming mat integer, intent(out) :: low integer, intent(out) :: high Calls proc~~balance~~CallsGraph proc~balance balance proc~rswap RSWAP proc~balance->proc~rswap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~balance~~CalledByGraph proc~balance balance proc~eigen eigen proc~eigen->proc~balance proc~colrad colrad proc~colrad->proc~eigen proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code balance Source Code subroutine balance ( n , mat , scal , low , high ) !+Balances the matrix so that the rows with zero entries !+off the diagonal are isolated and the remaining columns and rows !+are resized to have one norm close to 1. integer , intent ( in ) :: n !+ Dimension of `mat` real ( double ) :: mat ( 0 : n , 0 : n ) !+ `n`x`n` scaled matrix real ( double ) :: scal ( 0 : n ) !+ Contains isolated eigenvalue in the positions 0-`low` and `high`-`n`-1 !+ its other components contain the scaling factors for transforming `mat` integer , intent ( out ) :: high integer , intent ( out ) :: low integer , parameter :: basis = 2 real ( double ) :: b2 , r , c , f , g , s integer :: m , k , i , j , iter scal = 0.d0 b2 = basis * basis m = 0 k = n - 1 iter = 1 do while ( iter == 1 ) iter = 0 do j = k , 0 , - 1 r = ZERO do i = 0 , k if ( i . ne . j ) r = r + DABS ( mat ( j , i )) enddo if ( r == ZERO ) then scal ( k ) = j if ( j . ne . k ) then do i = 0 , k call RSWAP ( mat ( i , j ), mat ( i , k )) enddo do i = m , n - 1 call RSWAP ( mat ( j , i ), mat ( k , i )) enddo endif k = k - 1 iter = 1 endif enddo !j loop enddo !while iter=1 iter = 1 do while ( iter == 1 ) iter = 0 do j = m , k c = ZERO do i = m , k if ( i . ne . j ) c = c + DABS ( mat ( i , j )) enddo if ( c == ZERO ) then scal ( m ) = j if ( j . ne . m ) then do i = 0 , k call RSWAP ( mat ( i , j ), mat ( i , m )) enddo do i = m , n - 1 call RSWAP ( mat ( j , i ), mat ( m , i )) enddo endif m = m + 1 iter = 1 endif enddo !j loop enddo !while iter=1 low = m high = k do i = m , k scal ( i ) = ONE enddo iter = 1 do while ( iter == 1 ) iter = 0 do i = m , k c = ZERO ; r = ZERO do j = m , k if ( j . ne . i ) then c = c + DABS ( mat ( j , i )) r = r + DABS ( mat ( i , j )) endif enddo g = r / basis f = ONE s = c + r do while ( c < g ) f = f * basis c = c * b2 enddo g = r * basis do while ( c >= g ) f = f / basis c = c / b2 enddo if (( c + r ) / f < 0.95 * s ) then g = ONE / f scal ( i ) = scal ( i ) * f iter = 1 do j = m , n - 1 mat ( i , j ) = mat ( i , j ) * g enddo do j = 0 , k mat ( j , i ) = mat ( j , i ) * f enddo endif enddo !i loop enddo !while iter=1 return end subroutine balance","tags":"","loc":"proc/balance.html","title":"balance – FIDASIM"},{"text":"public subroutine balback(n, low, high, scal, eivec) Reverses the balancing of balance for the eigenvectors Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of matrix integer, intent(in) :: low First nonzero row integer, intent(in) :: high Last nonzero row real(kind=double), intent(in) :: scal (0:n) Scaling data from balance real(kind=double), intent(inout) :: eivec (0:n,0:n) Calls proc~~balback~~CallsGraph proc~balback balback proc~rswap RSWAP proc~balback->proc~rswap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~balback~~CalledByGraph proc~balback balback proc~eigen eigen proc~eigen->proc~balback proc~colrad colrad proc~colrad->proc~eigen proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code balback Source Code subroutine balback ( n , low , high , scal , eivec ) !+  Reverses the balancing of balance for the eigenvectors integer , intent ( in ) :: n !+ Dimension of matrix integer , intent ( in ) :: low !+ First nonzero row integer , intent ( in ) :: high !+ Last nonzero row real ( double ), intent ( in ) :: scal ( 0 : n ) !+ Scaling data from balance real ( double ), intent ( inout ) :: eivec ( 0 : n , 0 : n ) !+ Input: n x n matrix of eigenvectors, as computed in qr2 !+ Output: Non-normalized eigenvectors of the original matrix real ( double ) :: s integer :: i , j , k do i = low , high s = scal ( i ) do j = 0 , n - 1 eivec ( i , j ) = eivec ( i , j ) * s enddo enddo do i = low - 1 , 0 , - 1 k = Int ( scal ( i )) if ( k . ne . i ) then do j = 0 , n - 1 call RSWAP ( eivec ( i , j ), eivec ( k , j )) enddo endif enddo do i = high + 1 , n - 1 k = Int ( scal ( i )) if ( k . ne . i ) then do j = 0 , n - 1 call RSWAP ( eivec ( i , j ), eivec ( k , j )) enddo endif enddo return end subroutine balback","tags":"","loc":"proc/balback.html","title":"balback – FIDASIM"},{"text":"public subroutine elmhes(n, low, high, mat, perm) Transforms the matrix mat to upper Hessenberg form. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of mat integer, intent(in) :: low First nonzero row integer, intent(in) :: high Last nonzero row real(kind=double), intent(inout) :: mat (0:n,0:n) is stored in the lower triangle integer, intent(out) :: perm (0:n) Permutation vector for elmtrans Calls proc~~elmhes~~CallsGraph proc~elmhes elmhes proc~rswap RSWAP proc~elmhes->proc~rswap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~elmhes~~CalledByGraph proc~elmhes elmhes proc~eigen eigen proc~eigen->proc~elmhes proc~colrad colrad proc~colrad->proc~eigen proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code elmhes Source Code subroutine elmhes ( n , low , high , mat , perm ) !+Transforms the matrix `mat` to upper Hessenberg form. integer , intent ( in ) :: n !+Dimension of `mat` integer , intent ( in ) :: low !+First nonzero row integer , intent ( in ) :: high !+Last nonzero row real ( double ), intent ( inout ) :: mat ( 0 : n , 0 : n ) !+Input: `n`x`n` matrix !+Output: Upper Hessenberg matrix; additional information on the tranformation !+is stored in the lower triangle integer , intent ( out ) :: perm ( 0 : n ) !+Permutation vector for elmtrans integer :: i , j , m real ( double ) :: x , y do m = low + 1 , high - 1 i = m x = ZERO do j = m , high if ( DABS ( mat ( j , m - 1 )) > DABS ( x )) then x = mat ( j , m - 1 ) i = j endif enddo perm ( m ) = i if ( i . ne . m ) then do j = m - 1 , n - 1 call RSWAP ( mat ( i , j ), mat ( m , j )) enddo do j = 0 , high call RSWAP ( mat ( j , i ), mat ( j , m )) enddo endif if ( x . ne . ZERO ) then do i = m + 1 , high y = mat ( i , m - 1 ) if ( y . ne . ZERO ) then y = y / x mat ( i , m - 1 ) = y do j = m , n - 1 mat ( i , j ) = mat ( i , j ) - y * mat ( m , j ) enddo do j = 0 , high mat ( j , m ) = mat ( j , m ) + y * mat ( j , i ) enddo endif enddo !i loop endif !x <> ZERO enddo !m loop end subroutine elmhes","tags":"","loc":"proc/elmhes.html","title":"elmhes – FIDASIM"},{"text":"public subroutine elmtrans(n, low, high, mat, perm, h) Elmtrans copies the Hessenberg matrix stored in mat to h Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of mat integer, intent(in) :: low First nonzero row integer, intent(in) :: high Last nonzero row real(kind=double), intent(in) :: mat (0:n,0:n) n x n input matrix integer, intent(in) :: perm (0:n) Permutation data from elmhes real(kind=double), intent(out) :: h (0:n,0:n) Hessenberg matrix Called By proc~~elmtrans~~CalledByGraph proc~elmtrans elmtrans proc~eigen eigen proc~eigen->proc~elmtrans proc~colrad colrad proc~colrad->proc~eigen proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code elmtrans Source Code Subroutine elmtrans ( n , low , high , mat , perm , h ) !+  Elmtrans copies the Hessenberg matrix stored in `mat` to `h` integer , intent ( in ) :: n !+ Dimension of mat integer , intent ( in ) :: low !+ First nonzero row integer , intent ( in ) :: high !+ Last nonzero row real ( double ), intent ( in ) :: mat ( 0 : n , 0 : n ) !+ `n`x`n` input matrix integer , intent ( in ) :: perm ( 0 : n ) !+ Permutation data from elmhes real ( double ), intent ( out ) :: h ( 0 : n , 0 : n ) !+ Hessenberg matrix integer :: i , j , k do i = 0 , n - 1 do k = 0 , n - 1 h ( i , k ) = ZERO enddo h ( i , i ) = ONE enddo do i = high - 1 , low + 1 , - 1 j = perm ( i ) do k = i + 1 , high h ( k , i ) = mat ( k , i - 1 ) enddo if ( i . ne . j ) then do k = i , high h ( i , k ) = h ( j , k ) h ( j , k ) = ZERO enddo h ( j , i ) = ONE endif enddo end subroutine elmtrans","tags":"","loc":"proc/elmtrans.html","title":"elmtrans – FIDASIM"},{"text":"public subroutine Comdiv(ar, ai, br, bi, cr, ci, rc) Performs complex division c = a / b Arguments Type Intent Optional Attributes Name real(kind=double) :: ar Real part of numerator real(kind=double) :: ai Imaginary part of numerator real(kind=double) :: br Real part of denominator real(kind=double) :: bi Imaginary part of denominator real(kind=double) :: cr Real part of quotient real(kind=double) :: ci Imaginary part of quotient integer :: rc return code Called By proc~~comdiv~~CalledByGraph proc~comdiv Comdiv proc~hqrvec hqrvec proc~hqrvec->proc~comdiv proc~hqr2 hqr2 proc~hqr2->proc~hqrvec proc~eigen eigen proc~eigen->proc~hqr2 proc~colrad colrad proc~colrad->proc~eigen proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate var panproccomdivCalledByGraph = svgPanZoom('#proccomdivCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Comdiv Source Code subroutine Comdiv ( ar , ai , br , bi , cr , ci , rc ) !+ Performs complex division `c` = `a` / `b` real ( double ) :: ar !+ Real part of numerator real ( double ) :: ai !+ Imaginary part of numerator real ( double ) :: br !+ Real part of denominator real ( double ) :: bi !+ Imaginary part of denominator real ( double ) :: cr !+ Real part of quotient real ( double ) :: ci !+ Imaginary part of quotient integer :: rc !+ return code real ( double ) :: tmp if ( br == ZERO . AND . bi == ZERO ) then rc = 1 return endif if ( dabs ( br ) > dabs ( bi )) then tmp = bi / br br = tmp * bi + br cr = ( ar + tmp * ai ) / br ci = ( ai - tmp * ar ) / br else tmp = br / bi bi = tmp * br + bi cr = ( tmp * ar + ai ) / bi ci = ( tmp * ai - ar ) / bi endif rc = 0 end subroutine Comdiv !Comdiv","tags":"","loc":"proc/comdiv.html","title":"Comdiv – FIDASIM"},{"text":"public subroutine hqrvec(n, low, high, h, wr, wi, eivec, rc) Computes the eigenvectors for the eigenvalues found in hqr2 Input parameters n     :   int n;  ( n > 0 )\n         :   Dimension of  mat and eivec, number of eigenvalues. low   :   int low; high  :   int high; see  balance h     :   n x n upper Hessenberg matrix wr    :   vector of size n;\n         :   Real parts of the n eigenvalues. wi    :   vector of size n; Imaginary parts of the n eigenvalues. Output parameter: eivec :  n x n matrix, whose columns are the eigenvectors\n w   x |  | h[i][en]   |   | -r |\n       |  |            | = |    |\n y   z |  | h[i+1][en] |   | -s |\n w+i q     x | | h[i][na] + i h[i][en]  |   | -ra+i sa |\n             | |                        | = |          |\n   y    z+i q| | h[i+1][na]+i h[i+1][en]|   | -r+i s   | Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double) :: h (0:n,0:n) real(kind=double), intent(in) :: wr (0:n) real(kind=double), intent(in) :: wi (0:n) real(kind=double), intent(out) :: eivec (0:n,0:n) integer :: rc Calls proc~~hqrvec~~CallsGraph proc~hqrvec hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~hqrvec~~CalledByGraph proc~hqrvec hqrvec proc~hqr2 hqr2 proc~hqr2->proc~hqrvec proc~eigen eigen proc~eigen->proc~hqr2 proc~colrad colrad proc~colrad->proc~eigen proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate var panprochqrvecCalledByGraph = svgPanZoom('#prochqrvecCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code hqrvec Source Code subroutine hqrvec ( n , & !Dimension of matrix ....... low , & !first nonzero row ......... high , & !last nonzero row .......... h , & !upper Hessenberg matrix ... wr , & !Real parts of evalues ..... wi , & !Imaginary parts of evalues eivec , & !Eigenvectors .............. rc ) !return code ............... !+Computes the eigenvectors for the eigenvalues found in hqr2 !+ !+###Input parameters !+   n     :   int n;  ( n > 0 ) !+         :   Dimension of  mat and eivec, number of eigenvalues. !+ !+   low   :   int low; !+ !+   high  :   int high; see  balance !+ !+   h     :   n x n upper Hessenberg matrix !+ !+   wr    :   vector of size n; !+         :   Real parts of the n eigenvalues. !+ !+   wi    :   vector of size n; Imaginary parts of the n eigenvalues. !+ !+###Output parameter: !+   eivec :  n x n matrix, whose columns are the eigenvectors integer , intent ( in ) :: n integer , intent ( in ) :: high , low real ( double ), intent ( in ) :: wr ( 0 : n ), wi ( 0 : n ) real ( double ), intent ( out ) :: eivec ( 0 : n , 0 : n ) real ( double ) :: h ( 0 : n , 0 : n ) integer :: rc integer :: i , j , m , k , na , l integer :: code , en real ( double ) :: p , q , r , s , t , w , x , y , z , ra , sa , vr , vi , norm , temp r = ZERO ; s = ZERO ; z = ZERO ; norm = ZERO do i = 0 , n - 1 !find norm of h do j = i , n - 1 norm = norm + DABS ( h ( i , j )) enddo enddo if ( norm == ZERO ) then rc = 1 !zero matrix return endif do en = n - 1 , 0 , - 1 !transform back p = wr ( en ) q = wi ( en ) na = en - 1 if ( q == ZERO ) then m = en h ( en , en ) = ONE do i = na , 0 , - 1 w = h ( i , i ) - p r = h ( i , en ) do j = m , na r = r + h ( i , j ) * h ( j , en ) enddo if ( wi ( i ) < ZERO ) then z = w s = r else m = i if ( wi ( i ) == ZERO ) then if ( w . ne . ZERO ) then temp = w else temp = XMACH_EPS * norm endif h ( i , en ) = - r / temp else !Solve the linear system: !| w   x |  | h[i][en]   |   | -r | !|       |  |            | = |    | !| y   z |  | h[i+1][en] |   | -s | x = h ( i , i + 1 ) y = h ( i + 1 , i ) q = ( wr ( i ) - p ) ** 2 + wi ( i ) ** 2 h ( i , en ) = ( x * s - z * r ) / q t = h ( i , en ) if ( DABS ( x ) > DABS ( z )) then temp = ( - r - w * t ) / x else temp = ( - s - y * t ) / z endif h ( i + 1 , en ) = temp endif endif !wi[i] < 0 enddo !i loop else if ( q < ZERO ) then m = na if ( DABS ( h ( en , na )) > DABS ( h ( na , en ))) then h ( na , na ) = - ( h ( en , en ) - p ) / h ( en , na ) h ( na , en ) = - q / h ( en , na ) else call Comdiv ( - h ( na , en ), 0.d0 , h ( na , na ) - p , q , h ( na , na ), h ( na , en ), code ) endif h ( en , na ) = ONE h ( en , en ) = ZERO do i = na - 1 , 0 , - 1 w = h ( i , i ) - p ra = h ( i , en ) sa = ZERO do j = m , na ra = ra + h ( i , j ) * h ( j , na ) sa = sa + h ( i , j ) * h ( j , en ) enddo if ( wi ( i ) < ZERO ) then z = w r = ra s = sa else m = i if ( wi ( i ) == ZERO ) then call Comdiv ( - ra , - sa , w , q , h ( i , na ), h ( i , en ), code ) else !  solve complex linear system: !| w+i*q     x | | h[i][na] + i*h[i][en]  |   | -ra+i*sa | !|             | |                        | = |          | !|   y    z+i*q| | h[i+1][na]+i*h[i+1][en]|   | -r+i*s   | x = h ( i , i + 1 ) y = h ( i + 1 , i ) vr = ( wr ( i ) - p ) ** 2 + wi ( i ) ** 2 - q * q vi = TWO * q * ( wr ( i ) - p ) if ( vr == ZERO . AND . vi == ZERO ) then vr = XMACH_EPS * norm * ( DABS ( w ) + DABS ( q ) & + DABS ( x ) + DABS ( y ) + DABS ( z )) endif call Comdiv ( x * r - z * ra + q * sa , x * s - z * sa - q * ra & , vr , vi , h ( i , na ), h ( i , en ), code ) if ( DABS ( x ) > DABS ( z ) + DABS ( q )) then h ( i + 1 , na ) = ( - ra - w * h ( i , na ) + q * h ( i , en )) / x h ( i + 1 , en ) = ( - sa - w * h ( i , en ) - q * h ( i , na )) / x else call Comdiv ( - r - y * h ( i , na ), - s - y * h ( i , en ) & , z , q , h ( i + 1 , na ), h ( i + 1 , en ), code ) endif endif !wi[i] = 0 endif !wi[i] < 0 enddo !i loop endif !else if q < 0 enddo !en loop do i = 0 , n - 1 !Eigenvectors for the evalues for if ( i < low . or . i > high ) then !rows < low  and rows  > high do k = i + 1 , n - 1 eivec ( i , k ) = h ( i , k ) enddo endif enddo j = n - 1 do while ( j >= low ) if ( j <= high ) then m = j else j = high endif if ( wi ( j ) < ZERO ) then l = j - 1 do i = low , high y = ZERO ; z = ZERO do k = low , m y = y + eivec ( i , k ) * h ( k , l ) z = z + eivec ( i , k ) * h ( k , j ) enddo eivec ( i , l ) = y eivec ( i , j ) = z enddo else if ( wi ( j ) == ZERO ) then do i = low , high z = ZERO do k = low , m z = z + eivec ( i , k ) * h ( k , j ) enddo eivec ( i , j ) = z enddo endif endif j = j - 1 enddo !j loop rc = 0 end subroutine hqrvec","tags":"","loc":"proc/hqrvec.html","title":"hqrvec – FIDASIM"},{"text":"public subroutine hqr2(n, low, high, h, wr, wi, eivec, cnt, rc) Computes the eigenvalues and (if vec = True) the eigenvectors\nof an  n * n upper Hessenberg matrix. Input parameters n     :  integer;  ( n > 0 )\n            Dimension of  h and eivec,\n            length of the real parts vector  wr and of the\n            imaginary parts vector  wi of the eigenvalues. low   :  integer; high  :  integer;  see balance h     :  n x n matrix;\n            upper Hessenberg matrix as output of Elmhes\n            (destroyed in the process). Output parameters eivec :  n x n matrix;  (only if vec = 1)\n            Matrix, which for vec = 1 contains the\n            eigenvectors as follows:\n            For real eigebvalues the corresponding column\n            contains the corresponding eigenvactor, while for\n            complex eigenvalues the corresponding column contains\n            the real part of the eigenvactor with its imaginary\n            part is stored in the subsequent column of eivec.\n            The eigenvactor for the complex conjugate eigenvactor\n            is given by the complex conjugate eigenvactor. wr    :  vector of size n;\n            Real part of the n eigenvalues. wi    :  vector of size n;\n            Imaginary parts of the eigenvalues cnt   :  Integer vector of size n;\n            vector of iterations used for each eigenvalue.\n            For a complex conjugate eigenvalue pair the second\n            entry is negative. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double), intent(out) :: h (0:n,0:n) real(kind=double), intent(out) :: wr (0:n) real(kind=double), intent(out) :: wi (0:n) real(kind=double), intent(out) :: eivec (0:n,0:n) integer, intent(out) :: cnt (0:n) integer, intent(out) :: rc Calls proc~~hqr2~~CallsGraph proc~hqr2 hqr2 proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~comdiv Comdiv proc~hqrvec->proc~comdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~hqr2~~CalledByGraph proc~hqr2 hqr2 proc~eigen eigen proc~eigen->proc~hqr2 proc~colrad colrad proc~colrad->proc~eigen proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code hqr2 Source Code subroutine hqr2 ( n , & !Dimension of matrix ......... low , & !first nonzero row ........... high , & !last nonzero row ............ h , & !Hessenberg matrix ........... wr , & !Real parts of eigenvalues ... wi , & !Imaginary parts of evalues .. eivec ,& !Matrix of eigenvectors ...... cnt , & !Iteration counter ........... rc ) !return code ................. !+Computes the eigenvalues and (if vec = True) the eigenvectors !+of an  n * n upper Hessenberg matrix. !+ !+###Input parameters !+   n     :  integer;  ( n > 0 ) !+            Dimension of  h and eivec, !+            length of the real parts vector  wr and of the !+            imaginary parts vector  wi of the eigenvalues. !+ !+   low   :  integer; !+ !+   high  :  integer;  see balance !+ !+   h     :  n x n matrix; !+            upper Hessenberg matrix as output of Elmhes !+            (destroyed in the process). !+###Output parameters !+   eivec :  n x n matrix;  (only if vec = 1) !+            Matrix, which for vec = 1 contains the !+            eigenvectors as follows: !+            For real eigebvalues the corresponding column !+            contains the corresponding eigenvactor, while for !+            complex eigenvalues the corresponding column contains !+            the real part of the eigenvactor with its imaginary !+            part is stored in the subsequent column of eivec. !+            The eigenvactor for the complex conjugate eigenvactor !+            is given by the complex conjugate eigenvactor. !+ !+   wr    :  vector of size n; !+            Real part of the n eigenvalues. !+ !+   wi    :  vector of size n; !+            Imaginary parts of the eigenvalues !+ !+   cnt   :  Integer vector of size n; !+            vector of iterations used for each eigenvalue. !+            For a complex conjugate eigenvalue pair the second !+            entry is negative. integer , intent ( in ) :: n integer , intent ( in ) :: high , low real ( double ) , intent ( out ) :: h ( 0 : n , 0 : n ) real ( double ), intent ( out ) :: wr ( 0 : n ), wi ( 0 : n ) real ( double ), intent ( out ) :: eivec ( 0 : n , 0 : n ) integer , intent ( out ) :: rc integer , intent ( out ) :: cnt ( 0 : n ) integer :: en integer :: i , j , na , iter , l , ll , m , k real ( double ) :: p , q , r , s , t , w , x , y , z p = ZERO ; q = ZERO ; r = ZERO do i = 0 , n - 1 if ( i < low . or . i > high ) then wr ( i ) = h ( i , i ) wi ( i ) = ZERO cnt ( i ) = 0 endif enddo en = high t = ZERO do while ( en >= low ) iter = 0 na = en - 1 do while ( 1 < 2 ) ll = 999 do l = en , low + 1 , - 1 !search for small !subdiagonal element if ( DABS ( h ( l , l - 1 )) <= XMACH_EPS * ( DABS ( h ( l - 1 , l - 1 )) + DABS ( h ( l , l )))) then ll = l ; !save current index goto 10 !exit l loop endif enddo 10 if ( ll . ne . 999 ) then l = ll else l = 0 !restore l endif x = h ( en , en ) if ( l == en ) then !found one evalue wr ( en ) = x + t h ( en , en ) = x + t wi ( en ) = ZERO cnt ( en ) = iter en = en - 1 goto 15 !exit from loop while(True) endif y = h ( na , na ) w = h ( en , na ) * h ( na , en ) if ( l == na ) then !found two evalues p = ( y - x ) * 0.5d0 q = p * p + w z = DSQRT ( DABS ( q )) x = x + t h ( en , en ) = x + t h ( na , na ) = y + t cnt ( en ) = - iter cnt ( na ) = iter if ( q >= ZERO ) then !real eigenvalues if ( p < ZERO ) then z = p - z else z = p + z endif wr ( na ) = x + z wr ( en ) = x - w / z s = w - w / z wi ( na ) = ZERO wi ( en ) = ZERO x = h ( en , na ) r = DSQRT ( x * x + z * z ) p = x / r q = z / r do j = na , n - 1 z = h ( na , j ) h ( na , j ) = q * z + p * h ( en , j ) h ( en , j ) = q * h ( en , j ) - p * z enddo do i = 0 , en z = h ( i , na ) h ( i , na ) = q * z + p * h ( i , en ) h ( i , en ) = q * h ( i , en ) - p * z enddo do i = low , high z = eivec ( i , na ) eivec ( i , na ) = q * z + p * eivec ( i , en ) eivec ( i , en ) = q * eivec ( i , en ) - p * z enddo else !pair of complex wr ( na ) = x + p wr ( en ) = x + p wi ( na ) = z wi ( en ) = - z endif !if q>=ZERO en = en - 2 goto 15 !exit while(1<2) endif !if l = na if ( iter >= MAXIT ) then cnt ( en ) = MAXIT + 1 rc = en write ( * , * ) ' stop at iter >= MAXIT.' return endif if ( iter . ne . 0. and . MOD ( iter , 10 ) == 0 ) then t = t + x do i = low , en h ( i , i ) = h ( i , i ) - x enddo s = DABS ( h ( en , na )) + DABS ( h ( na , en - 2 )) x = 0.75d0 * s ; y = x w = - 0.4375d0 * s * s endif iter = iter + 1 do m = en - 2 , l , - 1 z = h ( m , m ) r = x - z s = y - z p = ( r * s - w ) / h ( m + 1 , m ) + h ( m , m + 1 ) q = h ( m + 1 , m + 1 ) - z - r - s r = h ( m + 2 , m + 1 ) s = DABS ( p ) + DABS ( q ) + DABS ( r ) p = p / s q = q / s r = r / s if ( m == l ) goto 12 if ( DABS ( h ( m , m - 1 )) * ( DABS ( q ) + DABS ( r )) <= XMACH_EPS * DABS ( p ) & * ( DABS ( h ( m - 1 , m - 1 )) + DABS ( z ) + DABS ( h ( m + 1 , m + 1 )))) then goto 12 !exit m loop endif enddo 12 do i = m + 2 , en h ( i , i - 2 ) = ZERO enddo do i = m + 3 , en h ( i , i - 3 ) = ZERO enddo do k = m , na if ( k . ne . m ) then !double QR step, for rows l to en and columns m to en p = h ( k , k - 1 ) q = h ( k + 1 , k - 1 ) if ( k . ne . na ) then r = h ( k + 2 , k - 1 ) else r = ZERO endif x = DABS ( p ) + DABS ( q ) + DABS ( r ) if ( x == ZERO ) goto 30 !next k p = p / x q = q / x r = r / x endif s = DSQRT ( p * p + q * q + r * r ) if ( p < ZERO ) s = - s if ( k . ne . m ) then h ( k , k - 1 ) = - s * x else if ( l . ne . m ) then h ( k , k - 1 ) = - h ( k , k - 1 ) endif p = p + s x = p / s y = q / s z = r / s q = q / p r = r / p do j = k , n - 1 !modify rows p = h ( k , j ) + q * h ( k + 1 , j ) if ( k . ne . na ) then p = p + r * h ( k + 2 , j ) h ( k + 2 , j ) = h ( k + 2 , j ) - p * z endif h ( k + 1 , j ) = h ( k + 1 , j ) - p * y h ( k , j ) = h ( k , j ) - p * x enddo if ( k + 3 < en ) then j = k + 3 else j = en endif do i = 0 , j !modify columns p = x * h ( i , k ) + y * h ( i , k + 1 ) if ( k . ne . na ) then p = p + z * h ( i , k + 2 ) h ( i , k + 2 ) = h ( i , k + 2 ) - p * r endif h ( i , k + 1 ) = h ( i , k + 1 ) - p * q h ( i , k ) = h ( i , k ) - p enddo do i = low , high p = x * eivec ( i , k ) + y * eivec ( i , k + 1 ) if ( k . ne . na ) then p = p + z * eivec ( i , k + 2 ) eivec ( i , k + 2 ) = eivec ( i , k + 2 ) - p * r endif eivec ( i , k + 1 ) = eivec ( i , k + 1 ) - p * q eivec ( i , k ) = eivec ( i , k ) - p enddo 30 continue enddo !k loop enddo !while(1<2) 15 continue enddo !while en >= low                         All evalues found !transform evectors back call hqrvec ( n , low , high , h , wr , wi , eivec , rc ) end subroutine hqr2","tags":"","loc":"proc/hqr2.html","title":"hqr2 – FIDASIM"},{"text":"public subroutine eigen(n, matrix, eigvec, eigval) The subroutine eigen  determines all eigenvalues and (if desired)\nall eigenvectors of a real square  n * n  matrix via the QR method\nin the version of Martin, Parlett, Peters, Reinsch and Wilkinson. Literature Peters, Wilkinson: Eigenvectors of real and complex\n   matrices by LR and QR triangularisations,\n   Num. Math. 16, p.184-204, (1970); [PETE70]; contribution\n   II/15, p. 372 - 395 in [WILK71]. Martin, Wilkinson: Similarity reductions of a general\n   matrix to Hessenberg form, Num. Math. 12, p. 349-368,(1968)\n   [MART 68]; contribution II,13, p. 339 - 358 in [WILK71]. Parlett, Reinsch: Balancing a matrix for calculations of\n   eigenvalues and eigenvectors, Num. Math. 13, p. 293-304,\n   (1969); [PARL69]; contribution II/11, p.315 - 326 in\n   [WILK71]. Input parameters n     :  integer; ( n > 0 )\n            size of matrix, number of eigenvalues mat   :  n x n matrix;\n            input matrix Output parameters eivec :  n x n matrix;     (only if vec = 1)\n            matrix, if  vec = 1  that holds the eigenvectors\n            thus :\n            If the jth eigenvalue of the matrix is real then the\n            jth column is the corresponding real eigenvector;\n            if the jth eigenvalue is complex then the jth column\n            of eivec contains the real part of the eigenvector\n            while its imaginary part is in column j+1.\n            (the j+1st eigenvector is the complex conjugate\n            vector.) valre :  vector of size n;\n            Real parts of the eigenvalues. valim :  vector of size n;\n            Imaginary parts of the eigenvalues cnt   :  Integer vector of size n;\n            vector containing the number of iterations for each\n            eigenvalue. (for a complex conjugate pair the second\n            entry is negative). Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=double), intent(in), dimension(n,n) :: matrix real(kind=double), intent(out), dimension(n,n) :: eigvec real(kind=double), intent(out), dimension(n) :: eigval Calls proc~~eigen~~CallsGraph proc~eigen eigen proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balance balance proc~eigen->proc~balance proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~rswap RSWAP proc~balance->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~elmhes->proc~rswap proc~comdiv Comdiv proc~hqrvec->proc~comdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~eigen~~CalledByGraph proc~eigen eigen proc~colrad colrad proc~colrad->proc~eigen proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code eigen Source Code subroutine eigen ( n , matrix , eigvec , eigval ) !+The subroutine eigen  determines all eigenvalues and (if desired) !+all eigenvectors of a real square  n * n  matrix via the QR method !+in the version of Martin, Parlett, Peters, Reinsch and Wilkinson. !+ !+###Literature !+1. Peters, Wilkinson: Eigenvectors of real and complex !+   matrices by LR and QR triangularisations, !+   Num. Math. 16, p.184-204, (1970); [PETE70]; contribution !+   II/15, p. 372 - 395 in [WILK71]. !+2. Martin, Wilkinson: Similarity reductions of a general !+   matrix to Hessenberg form, Num. Math. 12, p. 349-368,(1968) !+   [MART 68]; contribution II,13, p. 339 - 358 in [WILK71]. !+3. Parlett, Reinsch: Balancing a matrix for calculations of !+   eigenvalues and eigenvectors, Num. Math. 13, p. 293-304, !+   (1969); [PARL69]; contribution II/11, p.315 - 326 in !+   [WILK71]. !+ !+###Input parameters !+   n     :  integer; ( n > 0 ) !+            size of matrix, number of eigenvalues !+ !+   mat   :  n x n matrix; !+            input matrix !+ !+###Output parameters !+   eivec :  n x n matrix;     (only if vec = 1) !+            matrix, if  vec = 1  that holds the eigenvectors !+            thus : !+            If the jth eigenvalue of the matrix is real then the !+            jth column is the corresponding real eigenvector; !+            if the jth eigenvalue is complex then the jth column !+            of eivec contains the real part of the eigenvector !+            while its imaginary part is in column j+1. !+            (the j+1st eigenvector is the complex conjugate !+            vector.) !+ !+   valre :  vector of size n; !+            Real parts of the eigenvalues. !+ !+   valim :  vector of size n; !+            Imaginary parts of the eigenvalues !+ !+   cnt   :  Integer vector of size n; !+            vector containing the number of iterations for each !+            eigenvalue. (for a complex conjugate pair the second !+            entry is negative). integer , intent ( in ) :: n ! nlevels real ( double ) , intent ( in ), dimension ( n , n ) :: matrix real ( double ) , intent ( out ), dimension ( n , n ) :: eigvec real ( double ) , intent ( out ), dimension ( n ) :: eigval real ( double ) :: mat ( 0 : n , 0 : n ) real ( double ) :: eivec ( 0 : n , 0 : n ) real ( double ) :: valre ( 0 : n ) !real parts of eigenvalues real ( double ) :: valim ( 0 : n ) !imaginary parts of eigenvalues integer :: rc !return code integer :: cnt ( 0 : n ) !Iteration counter integer :: high , low real ( double ) :: d ( 0 : n ), scale ( 0 : n ) integer :: perm ( 0 : n ) cnt = 0 ; d = 0.d0 mat ( 0 : n - 1 , 0 : n - 1 ) = matrix ( 1 : n , 1 : n ) !balance mat for nearly call balance ( n , mat , scale , low , high ) !equal row and column !reduce mat to upper call elmhes ( n , low , high , mat , perm ) !reduce mat to upper !Hessenberg form call elmtrans ( n , low , high , mat , perm , eivec ) !QR algorithm for eigenvalues and eigenvectors call hqr2 ( n , low , high , mat , valre , valim , eivec , cnt , rc ) !reverse balancing to determine eigenvectors call balback ( n , low , high , scale , eivec ) if ( rc . ne . 0 ) then print * , 'matrix = ' print * , matrix stop 'problem in eigen!' endif eigval ( 1 : n ) = valre ( 0 : n - 1 ) eigvec ( 1 : n , 1 : n ) = eivec ( 0 : n - 1 , 0 : n - 1 ) end subroutine eigen","tags":"","loc":"proc/eigen.html","title":"eigen – FIDASIM"},{"text":"public subroutine swap(a, b) Swap arrays a and b Arguments Type Intent Optional Attributes Name real(kind=double), intent(inout), dimension(:) :: a real(kind=double), intent(inout), dimension(:) :: b Called By proc~~swap~~CalledByGraph proc~swap swap proc~ludcmp ludcmp proc~ludcmp->proc~swap proc~matinv matinv proc~matinv->proc~ludcmp proc~colrad colrad proc~colrad->proc~matinv proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate var panprocswapCalledByGraph = svgPanZoom('#procswapCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code swap Source Code subroutine swap ( a , b ) !+Swap arrays `a` and `b` real ( double ), dimension (:), intent ( INOUT ) :: a , b real ( double ), dimension ( size ( a )) :: dum dum = a a = b b = dum end subroutine swap","tags":"","loc":"proc/swap.html","title":"swap – FIDASIM"},{"text":"public subroutine ludcmp(a, indx, d) Calculates LU decomposition Arguments Type Intent Optional Attributes Name real(kind=double), intent(inout), dimension(:,:) :: a integer, intent(out), dimension(:) :: indx real(kind=double), intent(out) :: d Calls proc~~ludcmp~~CallsGraph proc~ludcmp ludcmp proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~ludcmp~~CalledByGraph proc~ludcmp ludcmp proc~matinv matinv proc~matinv->proc~ludcmp proc~colrad colrad proc~colrad->proc~matinv proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ludcmp Source Code subroutine ludcmp ( a , indx , d ) !+Calculates LU decomposition real ( double ), dimension (:,:), intent ( INOUT ) :: a integer , dimension (:), intent ( OUT ) :: indx real ( double ), intent ( OUT ) :: d real ( double ), dimension ( size ( a , 1 )) :: vv integer , dimension ( 1 ) :: imaxloc integer :: j , n , imax n = size ( indx ) d = 1.0 vv = maxval ( abs ( a ), dim = 2 ) if ( any ( vv . eq . 0. )) stop 'singular matrix in ludcmp' vv = 1.d0 / vv do j = 1 , n imaxloc = maxloc ( vv ( j : n ) * abs ( a ( j : n , j ))) imax = ( j - 1 ) + imaxloc ( 1 ) if ( j /= imax ) then call swap ( a ( imax ,:), a ( j ,:)) d =- d vv ( imax ) = vv ( j ) endif indx ( j ) = imax if ( a ( j , j ) == 0.0 ) a ( j , j ) = 1.0d-20 a ( j + 1 : n , j ) = a ( j + 1 : n , j ) / a ( j , j ) a ( j + 1 : n , j + 1 : n ) = a ( j + 1 : n , j + 1 : n ) - outerprod ( a ( j + 1 : n , j ), a ( j , j + 1 : n )) enddo end subroutine ludcmp","tags":"","loc":"proc/ludcmp.html","title":"ludcmp – FIDASIM"},{"text":"public subroutine lubksb(a, indx, b) Does LU back substitution Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:,:) :: a integer, intent(in), dimension(:) :: indx real(kind=double), intent(inout), dimension(:) :: b Called By proc~~lubksb~~CalledByGraph proc~lubksb lubksb proc~matinv matinv proc~matinv->proc~lubksb proc~colrad colrad proc~colrad->proc~matinv proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lubksb Source Code subroutine lubksb ( a , indx , b ) !+ Does LU back substitution real ( double ), dimension (:,:), intent ( IN ) :: a integer , dimension (:), intent ( IN ) :: indx real ( double ), dimension (:), intent ( INOUT ) :: b integer :: i , n , ii , ll real ( double ) :: summ n = size ( indx ) ii = 0 do i = 1 , n ll = indx ( i ) summ = b ( ll ) b ( ll ) = b ( i ) if ( ii /= 0 ) then summ = summ - dot_product ( a ( i , ii : i - 1 ), b ( ii : i - 1 )) else if ( summ /= 0.0 ) then ii = i endif b ( i ) = summ enddo do i = n , 1 , - 1 b ( i ) = ( b ( i ) - dot_product ( a ( i , i + 1 : n ), b ( i + 1 : n ))) / a ( i , i ) enddo end subroutine lubksb","tags":"","loc":"proc/lubksb.html","title":"lubksb – FIDASIM"},{"text":"public subroutine matinv(a, b) Matrix inversion with LU-decomposition Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:,:) :: a real(kind=double), intent(out), dimension(:,:) :: b Calls proc~~matinv~~CallsGraph proc~matinv matinv proc~lubksb lubksb proc~matinv->proc~lubksb proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~matinv~~CalledByGraph proc~matinv matinv proc~colrad colrad proc~colrad->proc~matinv proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code matinv Source Code subroutine matinv ( a , b ) !+ Matrix inversion with LU-decomposition !==================================================== real ( double ), dimension (:,:), intent ( IN ) :: a real ( double ), dimension (:,:), intent ( OUT ) :: b real ( double ), dimension ( size ( a , dim = 1 ), size ( a , dim = 2 )) :: ah , y integer :: i , N integer , dimension ( size ( a , dim = 1 )) :: indx real ( double ) :: d N = size ( a , dim = 1 ) if ( N /= size ( a , dim = 2 )) stop 'SUB matinv: ludcmp matrix must be square!' ah = a y = 0. do i = 1 , N y ( i , i ) = 1.d0 enddo call ludcmp ( ah , indx , d ) do i = 1 , N call lubksb ( ah , indx , y (:, i )) enddo b = y end subroutine matinv","tags":"","loc":"proc/matinv.html","title":"matinv – FIDASIM"},{"text":"public function pp_add(p1, p2) result(p3) Defines how to add two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) Called By proc~~pp_add~~CalledByGraph proc~pp_add pp_add interface~operator(+) operator(+) interface~operator(+)->proc~pp_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pp_add Source Code function pp_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[Profiles]] types type ( Profiles ), intent ( in ) :: p1 , p2 type ( Profiles ) :: p3 p3 % dene = p1 % dene + p2 % dene p3 % ti = p1 % ti + p2 % ti p3 % te = p1 % te + p2 % te p3 % denp = p1 % denp + p2 % denp p3 % denf = p1 % denf + p2 % denf p3 % denimp = p1 % denimp + p2 % denimp p3 % zeff = p1 % zeff + p2 % zeff p3 % vr = p1 % vr + p2 % vr p3 % vt = p1 % vt + p2 % vt p3 % vz = p1 % vz + p2 % vz end function pp_add","tags":"","loc":"proc/pp_add.html","title":"pp_add – FIDASIM"},{"text":"public function pp_subtract(p1, p2) result(p3) Defines how to subtract two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) Called By proc~~pp_subtract~~CalledByGraph proc~pp_subtract pp_subtract interface~operator(-) operator(-) interface~operator(-)->proc~pp_subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pp_subtract Source Code function pp_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[Profiles]] types type ( Profiles ), intent ( in ) :: p1 , p2 type ( Profiles ) :: p3 p3 % dene = p1 % dene - p2 % dene p3 % ti = p1 % ti - p2 % ti p3 % te = p1 % te - p2 % te p3 % denp = p1 % denp - p2 % denp p3 % denf = p1 % denf - p2 % denf p3 % denimp = p1 % denimp - p2 % denimp p3 % zeff = p1 % zeff - p2 % zeff p3 % vr = p1 % vr - p2 % vr p3 % vt = p1 % vt - p2 % vt p3 % vz = p1 % vz - p2 % vz end function pp_subtract","tags":"","loc":"proc/pp_subtract.html","title":"pp_subtract – FIDASIM"},{"text":"public function lplp_add(p1, p2) result(p3) Defines how to add two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) Called By proc~~lplp_add~~CalledByGraph proc~lplp_add lplp_add interface~operator(+) operator(+) interface~operator(+)->proc~lplp_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lplp_add Source Code function lplp_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[LocalProfiles]] types type ( LocalProfiles ), intent ( in ) :: p1 , p2 type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos + p2 % pos p3 % uvw = p1 % uvw + p2 % uvw p3 % dene = p1 % dene + p2 % dene p3 % ti = p1 % ti + p2 % ti p3 % te = p1 % te + p2 % te p3 % denp = p1 % denp + p2 % denp p3 % denf = p1 % denf + p2 % denf p3 % denimp = p1 % denimp + p2 % denimp p3 % zeff = p1 % zeff + p2 % zeff p3 % vr = p1 % vr + p2 % vr p3 % vt = p1 % vt + p2 % vt p3 % vz = p1 % vz + p2 % vz p3 % vrot = p1 % vrot + p2 % vrot end function lplp_add","tags":"","loc":"proc/lplp_add.html","title":"lplp_add – FIDASIM"},{"text":"public function lplp_subtract(p1, p2) result(p3) Defines how to subtract two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) Called By proc~~lplp_subtract~~CalledByGraph proc~lplp_subtract lplp_subtract interface~operator(-) operator(-) interface~operator(-)->proc~lplp_subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lplp_subtract Source Code function lplp_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[LocalProfiles]] types type ( LocalProfiles ), intent ( in ) :: p1 , p2 type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos - p2 % pos p3 % uvw = p1 % uvw - p2 % uvw p3 % dene = p1 % dene - p2 % dene p3 % ti = p1 % ti - p2 % ti p3 % te = p1 % te - p2 % te p3 % denp = p1 % denp - p2 % denp p3 % denf = p1 % denf - p2 % denf p3 % denimp = p1 % denimp - p2 % denimp p3 % zeff = p1 % zeff - p2 % zeff p3 % vr = p1 % vr - p2 % vr p3 % vt = p1 % vt - p2 % vt p3 % vz = p1 % vz - p2 % vz p3 % vrot = p1 % vrot - p2 % vrot end function lplp_subtract","tags":"","loc":"proc/lplp_subtract.html","title":"lplp_subtract – FIDASIM"},{"text":"public function ps_multiply(p1, real_scalar) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) Called By proc~~ps_multiply~~CalledByGraph proc~ps_multiply ps_multiply interface~operator(*) operator(*) interface~operator(*)->proc~ps_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ps_multiply Source Code function ps_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[Profiles]] types by a scalar type ( Profiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 % dene = p1 % dene * real_scalar p3 % ti = p1 % ti * real_scalar p3 % te = p1 % te * real_scalar p3 % denp = p1 % denp * real_scalar p3 % denf = p1 % denf * real_scalar p3 % denimp = p1 % denimp * real_scalar p3 % zeff = p1 % zeff * real_scalar p3 % vr = p1 % vr * real_scalar p3 % vt = p1 % vt * real_scalar p3 % vz = p1 % vz * real_scalar end function ps_multiply","tags":"","loc":"proc/ps_multiply.html","title":"ps_multiply – FIDASIM"},{"text":"public function sp_multiply(real_scalar, p1) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( Profiles ), intent(in) :: p1 Return Value type( Profiles ) Called By proc~~sp_multiply~~CalledByGraph proc~sp_multiply sp_multiply interface~operator(*) operator(*) interface~operator(*)->proc~sp_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sp_multiply Source Code function sp_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[Profiles]] types by a scalar type ( Profiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 = p1 * real_scalar end function sp_multiply","tags":"","loc":"proc/sp_multiply.html","title":"sp_multiply – FIDASIM"},{"text":"public function ps_divide(p1, real_scalar) result(p3) Defines how to divide Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) Called By proc~~ps_divide~~CalledByGraph proc~ps_divide ps_divide interface~operator(SLASH) operator(/) interface~operator(SLASH)->proc~ps_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ps_divide Source Code function ps_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[Profiles]] types by a scalar type ( Profiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( Profiles ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function ps_divide","tags":"","loc":"proc/ps_divide.html","title":"ps_divide – FIDASIM"},{"text":"public function lps_multiply(p1, real_scalar) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) Called By proc~~lps_multiply~~CalledByGraph proc~lps_multiply lps_multiply interface~operator(*) operator(*) interface~operator(*)->proc~lps_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lps_multiply Source Code function lps_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[LocalProfiles]] types by a scalar type ( LocalProfiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 % pos = p1 % pos * real_scalar p3 % uvw = p1 % uvw * real_scalar p3 % dene = p1 % dene * real_scalar p3 % ti = p1 % ti * real_scalar p3 % te = p1 % te * real_scalar p3 % denp = p1 % denp * real_scalar p3 % denf = p1 % denf * real_scalar p3 % denimp = p1 % denimp * real_scalar p3 % zeff = p1 % zeff * real_scalar p3 % vr = p1 % vr * real_scalar p3 % vt = p1 % vt * real_scalar p3 % vz = p1 % vz * real_scalar p3 % vrot = p1 % vrot * real_scalar end function lps_multiply","tags":"","loc":"proc/lps_multiply.html","title":"lps_multiply – FIDASIM"},{"text":"public function slp_multiply(real_scalar, p1) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalProfiles ), intent(in) :: p1 Return Value type( LocalProfiles ) Called By proc~~slp_multiply~~CalledByGraph proc~slp_multiply slp_multiply interface~operator(*) operator(*) interface~operator(*)->proc~slp_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code slp_multiply Source Code function slp_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[LocalProfiles]] types by a scalar type ( LocalProfiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 = p1 * real_scalar end function slp_multiply","tags":"","loc":"proc/slp_multiply.html","title":"slp_multiply – FIDASIM"},{"text":"public function lps_divide(p1, real_scalar) result(p3) Defines how to divide LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) Called By proc~~lps_divide~~CalledByGraph proc~lps_divide lps_divide interface~operator(SLASH) operator(/) interface~operator(SLASH)->proc~lps_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lps_divide Source Code function lps_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[LocalProfiles]] types by a scalar type ( LocalProfiles ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalProfiles ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function lps_divide","tags":"","loc":"proc/lps_divide.html","title":"lps_divide – FIDASIM"},{"text":"public function ff_add(p1, p2) result(p3) Defines how to add two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) Called By proc~~ff_add~~CalledByGraph proc~ff_add ff_add interface~operator(+) operator(+) interface~operator(+)->proc~ff_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ff_add Source Code function ff_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[EMFields]] types type ( EMFields ), intent ( in ) :: p1 , p2 type ( EMFields ) :: p3 p3 % br = p1 % br + p2 % br p3 % bt = p1 % bt + p2 % bt p3 % bz = p1 % bz + p2 % bz p3 % er = p1 % er + p2 % er p3 % et = p1 % et + p2 % et p3 % ez = p1 % ez + p2 % ez p3 % dbr_dr = p1 % dbr_dr + p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz + p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr + p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz + p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr + p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz + p2 % dbz_dz end function ff_add","tags":"","loc":"proc/ff_add.html","title":"ff_add – FIDASIM"},{"text":"public function ff_subtract(p1, p2) result(p3) Defines how to subtract two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) Called By proc~~ff_subtract~~CalledByGraph proc~ff_subtract ff_subtract interface~operator(-) operator(-) interface~operator(-)->proc~ff_subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ff_subtract Source Code function ff_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[EMFields]] types type ( EMFields ), intent ( in ) :: p1 , p2 type ( EMFields ) :: p3 p3 % br = p1 % br - p2 % br p3 % bt = p1 % bt - p2 % bt p3 % bz = p1 % bz - p2 % bz p3 % er = p1 % er - p2 % er p3 % et = p1 % et - p2 % et p3 % ez = p1 % ez - p2 % ez p3 % dbr_dr = p1 % dbr_dr - p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz - p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr - p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz - p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr - p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz - p2 % dbz_dz end function ff_subtract","tags":"","loc":"proc/ff_subtract.html","title":"ff_subtract – FIDASIM"},{"text":"public function fs_multiply(p1, real_scalar) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) Called By proc~~fs_multiply~~CalledByGraph proc~fs_multiply fs_multiply interface~operator(*) operator(*) interface~operator(*)->proc~fs_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code fs_multiply Source Code function fs_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[EMFields]] types by a scalar type ( EMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 % br = p1 % br * real_scalar p3 % bt = p1 % bt * real_scalar p3 % bz = p1 % bz * real_scalar p3 % er = p1 % er * real_scalar p3 % et = p1 % et * real_scalar p3 % ez = p1 % ez * real_scalar p3 % dbr_dr = p1 % dbr_dr * real_scalar p3 % dbr_dz = p1 % dbr_dz * real_scalar p3 % dbt_dr = p1 % dbt_dr * real_scalar p3 % dbt_dz = p1 % dbt_dz * real_scalar p3 % dbz_dr = p1 % dbz_dr * real_scalar p3 % dbz_dz = p1 % dbz_dz * real_scalar end function fs_multiply","tags":"","loc":"proc/fs_multiply.html","title":"fs_multiply – FIDASIM"},{"text":"public function sf_multiply(real_scalar, p1) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( EMFields ), intent(in) :: p1 Return Value type( EMFields ) Called By proc~~sf_multiply~~CalledByGraph proc~sf_multiply sf_multiply interface~operator(*) operator(*) interface~operator(*)->proc~sf_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sf_multiply Source Code function sf_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[EMFields]] types by a scalar type ( EMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 = p1 * real_scalar end function sf_multiply","tags":"","loc":"proc/sf_multiply.html","title":"sf_multiply – FIDASIM"},{"text":"public function fs_divide(p1, real_scalar) result(p3) Defines how to divide EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) Called By proc~~fs_divide~~CalledByGraph proc~fs_divide fs_divide interface~operator(SLASH) operator(/) interface~operator(SLASH)->proc~fs_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code fs_divide Source Code function fs_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[EMFields]] types by a scalar type ( EMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( EMFields ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function fs_divide","tags":"","loc":"proc/fs_divide.html","title":"fs_divide – FIDASIM"},{"text":"public function lflf_add(p1, p2) result(p3) Defines how to add two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) Calls proc~~lflf_add~~CallsGraph proc~lflf_add lflf_add proc~calc_perp_vectors calc_perp_vectors proc~lflf_add->proc~calc_perp_vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~lflf_add~~CalledByGraph proc~lflf_add lflf_add interface~operator(+) operator(+) interface~operator(+)->proc~lflf_add Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lflf_add Source Code function lflf_add ( p1 , p2 ) result ( p3 ) !+ Defines how to add two [[LocalEMFields]] types type ( LocalEMFields ), intent ( in ) :: p1 , p2 type ( LocalEMFields ) :: p3 real ( Float64 ), dimension ( 3 ) :: bfield , efield p3 % pos = p1 % pos + p2 % pos p3 % uvw = p1 % uvw + p2 % uvw p3 % br = p1 % br + p2 % br p3 % bt = p1 % bt + p2 % bt p3 % bz = p1 % bz + p2 % bz p3 % er = p1 % er + p2 % er p3 % et = p1 % et + p2 % et p3 % ez = p1 % ez + p2 % ez bfield = p1 % b_abs * p1 % b_norm + p2 % b_abs * p2 % b_norm p3 % b_abs = norm2 ( bfield ) if ( p3 % b_abs . gt . 0.d0 ) then p3 % b_norm = bfield / p3 % b_abs call calc_perp_vectors ( p3 % b_norm , p3 % a_norm , p3 % c_norm ) endif efield = p1 % e_abs * p1 % e_norm + p2 % e_abs * p2 % e_norm p3 % e_abs = norm2 ( efield ) if ( p3 % e_abs . gt . 0.d0 ) p3 % e_norm = efield / p3 % e_abs p3 % dbr_dr = p1 % dbr_dr + p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz + p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr + p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz + p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr + p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz + p2 % dbz_dz end function lflf_add","tags":"","loc":"proc/lflf_add.html","title":"lflf_add – FIDASIM"},{"text":"public function lflf_subtract(p1, p2) result(p3) Defines how to subtract two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) Calls proc~~lflf_subtract~~CallsGraph proc~lflf_subtract lflf_subtract proc~calc_perp_vectors calc_perp_vectors proc~lflf_subtract->proc~calc_perp_vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~lflf_subtract~~CalledByGraph proc~lflf_subtract lflf_subtract interface~operator(-) operator(-) interface~operator(-)->proc~lflf_subtract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lflf_subtract Source Code function lflf_subtract ( p1 , p2 ) result ( p3 ) !+ Defines how to subtract two [[LocalEMFields]] types type ( LocalEMFields ), intent ( in ) :: p1 , p2 type ( LocalEMFields ) :: p3 real ( Float64 ), dimension ( 3 ) :: bfield , efield p3 % pos = p1 % pos - p2 % pos p3 % uvw = p1 % uvw - p2 % uvw p3 % br = p1 % br - p2 % br p3 % bt = p1 % bt - p2 % bt p3 % bz = p1 % bz - p2 % bz p3 % er = p1 % er - p2 % er p3 % et = p1 % et - p2 % et p3 % ez = p1 % ez - p2 % ez bfield = p1 % b_abs * p1 % b_norm - p2 % b_abs * p2 % b_norm p3 % b_abs = norm2 ( bfield ) if ( p3 % b_abs . gt . 0.d0 ) then p3 % b_norm = bfield / p3 % b_abs call calc_perp_vectors ( p3 % b_norm , p3 % a_norm , p3 % c_norm ) endif efield = p1 % e_abs * p1 % e_norm - p2 % e_abs * p2 % e_norm p3 % e_abs = norm2 ( efield ) if ( p3 % e_abs . gt . 0.d0 ) p3 % e_norm = efield / p3 % e_abs p3 % dbr_dr = p1 % dbr_dr - p2 % dbr_dr p3 % dbr_dz = p1 % dbr_dz - p2 % dbr_dz p3 % dbt_dr = p1 % dbt_dr - p2 % dbt_dr p3 % dbt_dz = p1 % dbt_dz - p2 % dbt_dz p3 % dbz_dr = p1 % dbz_dr - p2 % dbz_dr p3 % dbz_dz = p1 % dbz_dz - p2 % dbz_dz end function lflf_subtract","tags":"","loc":"proc/lflf_subtract.html","title":"lflf_subtract – FIDASIM"},{"text":"public function lfs_multiply(p1, real_scalar) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields ) Called By proc~~lfs_multiply~~CalledByGraph proc~lfs_multiply lfs_multiply interface~operator(*) operator(*) interface~operator(*)->proc~lfs_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lfs_multiply Source Code function lfs_multiply ( p1 , real_scalar ) result ( p3 ) !+ Defines how to multiply [[LocalEMFields]] types by a scalar type ( LocalEMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 % pos = p1 % pos * real_scalar p3 % uvw = p1 % uvw * real_scalar p3 % br = p1 % br * real_scalar p3 % bt = p1 % bt * real_scalar p3 % bz = p1 % bz * real_scalar p3 % er = p1 % er * real_scalar p3 % et = p1 % et * real_scalar p3 % ez = p1 % ez * real_scalar p3 % b_abs = p1 % b_abs * real_scalar p3 % e_abs = p1 % e_abs * real_scalar p3 % a_norm = p1 % a_norm p3 % b_norm = p1 % b_norm p3 % c_norm = p1 % c_norm p3 % e_norm = p1 % e_norm p3 % dbr_dr = p1 % dbr_dr * real_scalar p3 % dbr_dz = p1 % dbr_dz * real_scalar p3 % dbt_dr = p1 % dbt_dr * real_scalar p3 % dbt_dz = p1 % dbt_dz * real_scalar p3 % dbz_dr = p1 % dbz_dr * real_scalar p3 % dbz_dz = p1 % dbz_dz * real_scalar end function lfs_multiply","tags":"","loc":"proc/lfs_multiply.html","title":"lfs_multiply – FIDASIM"},{"text":"public function slf_multiply(real_scalar, p1) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalEMFields ), intent(in) :: p1 Return Value type( LocalEMFields ) Called By proc~~slf_multiply~~CalledByGraph proc~slf_multiply slf_multiply interface~operator(*) operator(*) interface~operator(*)->proc~slf_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code slf_multiply Source Code function slf_multiply ( real_scalar , p1 ) result ( p3 ) !+ Defines how to multiply [[LocalEMFields]] types by a scalar type ( LocalEMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 = p1 * real_scalar end function slf_multiply","tags":"","loc":"proc/slf_multiply.html","title":"slf_multiply – FIDASIM"},{"text":"public function lfs_divide(p1, real_scalar) result(p3) Defines how to divide LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields ) Called By proc~~lfs_divide~~CalledByGraph proc~lfs_divide lfs_divide interface~operator(SLASH) operator(/) interface~operator(SLASH)->proc~lfs_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lfs_divide Source Code function lfs_divide ( p1 , real_scalar ) result ( p3 ) !+ Defines how to divide [[LocalEMFields]] types by a scalar type ( LocalEMFields ), intent ( in ) :: p1 real ( Float64 ), intent ( in ) :: real_scalar type ( LocalEMFields ) :: p3 p3 = p1 * ( 1.d0 / real_scalar ) end function lfs_divide","tags":"","loc":"proc/lfs_divide.html","title":"lfs_divide – FIDASIM"},{"text":"public function approx_eq(x, y, tol) result(a) Inexact equality comparison: x ~= y true if abs(x-y) <= tol else false Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: x First value in comparison real(kind=Float64), intent(in) :: y Second value in comparison real(kind=Float64), intent(in) :: tol Equality tolerance Return Value logical Called By proc~~approx_eq~~CalledByGraph proc~approx_eq approx_eq proc~npa_gyro_range npa_gyro_range proc~npa_gyro_range->proc~approx_eq proc~circle_grid_intersect circle_grid_intersect proc~circle_grid_intersect->proc~approx_eq proc~in_grid in_grid proc~circle_grid_intersect->proc~in_grid proc~approx_ge approx_ge proc~approx_ge->proc~approx_eq proc~approx_le approx_le proc~approx_le->proc~approx_eq proc~npa_f npa_f proc~npa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~npa_f program~fidasim->proc~npa_mc proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~read_mc read_mc proc~read_mc->proc~circle_grid_intersect proc~read_distribution->proc~read_mc proc~in_grid->proc~approx_ge proc~in_grid->proc~approx_le var panprocapprox_eqCalledByGraph = svgPanZoom('#procapprox_eqCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code approx_eq Source Code function approx_eq ( x , y , tol ) result ( a ) !+ Inexact equality comparison: `x ~= y` true if `abs(x-y) <= tol` else false real ( Float64 ), intent ( in ) :: x !+First value in comparison real ( Float64 ), intent ( in ) :: y !+Second value in comparison real ( Float64 ), intent ( in ) :: tol !+Equality tolerance logical :: a a = abs ( x - y ). le . tol end function approx_eq","tags":"","loc":"proc/approx_eq.html","title":"approx_eq – FIDASIM"},{"text":"public function approx_ge(x, y, tol) result(a) Inexact greater than or equal to comparison: x >~= y Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: x First value in comparison real(kind=Float64), intent(in) :: y Second value in comparison real(kind=Float64), intent(in) :: tol Equality tolerance Return Value logical Calls proc~~approx_ge~~CallsGraph proc~approx_ge approx_ge proc~approx_eq approx_eq proc~approx_ge->proc~approx_eq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~approx_ge~~CalledByGraph proc~approx_ge approx_ge proc~in_grid in_grid proc~in_grid->proc~approx_ge proc~circle_grid_intersect circle_grid_intersect proc~circle_grid_intersect->proc~in_grid proc~read_mc read_mc proc~read_mc->proc~circle_grid_intersect proc~read_distribution read_distribution proc~read_distribution->proc~read_mc program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code approx_ge Source Code function approx_ge ( x , y , tol ) result ( a ) !+ Inexact greater than or equal to comparison: `x >~= y` real ( Float64 ), intent ( in ) :: x !+First value in comparison real ( Float64 ), intent ( in ) :: y !+Second value in comparison real ( Float64 ), intent ( in ) :: tol !+Equality tolerance logical :: a a = ( x . gt . y ). or .( approx_eq ( x , y , tol )) end function approx_ge","tags":"","loc":"proc/approx_ge.html","title":"approx_ge – FIDASIM"},{"text":"public function approx_le(x, y, tol) result(a) Inexact less then or equal to comparison: x <~= y Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: x First value in comparison real(kind=Float64), intent(in) :: y Second value in comparison real(kind=Float64), intent(in) :: tol Equality tolerance Return Value logical Calls proc~~approx_le~~CallsGraph proc~approx_le approx_le proc~approx_eq approx_eq proc~approx_le->proc~approx_eq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~approx_le~~CalledByGraph proc~approx_le approx_le proc~in_grid in_grid proc~in_grid->proc~approx_le proc~circle_grid_intersect circle_grid_intersect proc~circle_grid_intersect->proc~in_grid proc~read_mc read_mc proc~read_mc->proc~circle_grid_intersect proc~read_distribution read_distribution proc~read_distribution->proc~read_mc program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code approx_le Source Code function approx_le ( x , y , tol ) result ( a ) !+ Inexact less then or equal to comparison: `x <~= y` real ( Float64 ), intent ( in ) :: x !+First value in comparison real ( Float64 ), intent ( in ) :: y !+Second value in comparison real ( Float64 ), intent ( in ) :: tol !+Equality tolerance logical :: a a = ( x . lt . y ). or .( approx_eq ( x , y , tol )) end function approx_le","tags":"","loc":"proc/approx_le.html","title":"approx_le – FIDASIM"},{"text":"public function cross_product(u, v) result(s) Calculates the cross product of two vectors: u x v Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: u real(kind=Float64), intent(in), dimension(3) :: v Return Value real(kind=Float64),\n  dimension(3) Called By proc~~cross_product~~CalledByGraph proc~cross_product cross_product proc~gyro_step gyro_step proc~gyro_step->proc~cross_product proc~plane_basis plane_basis proc~plane_basis->proc~cross_product proc~gyro_radius gyro_radius proc~gyro_radius->proc~gyro_step proc~gyro_correction gyro_correction proc~gyro_correction->proc~gyro_step proc~npa_weights npa_weights proc~npa_weights->proc~gyro_step proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~gyro_correction proc~fida_f fida_f proc~fida_f->proc~gyro_correction proc~neutron_mc neutron_mc proc~neutron_mc->proc~gyro_correction proc~fida_mc fida_mc proc~fida_mc->proc~gyro_correction proc~neutron_f neutron_f proc~neutron_f->proc~gyro_correction program~fidasim fidasim program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~fida_mc program~fidasim->proc~neutron_f proc~read_npa read_npa program~fidasim->proc~read_npa proc~read_npa->proc~plane_basis Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code cross_product Source Code function cross_product ( u , v ) result ( s ) !+ Calculates the cross product of two vectors: `u`x`v` real ( Float64 ), dimension ( 3 ), intent ( in ) :: u real ( Float64 ), dimension ( 3 ), intent ( in ) :: v real ( Float64 ), dimension ( 3 ) :: s s ( 1 ) = u ( 2 ) * v ( 3 ) - u ( 3 ) * v ( 2 ) s ( 2 ) = u ( 3 ) * v ( 1 ) - u ( 1 ) * v ( 3 ) s ( 3 ) = u ( 1 ) * v ( 2 ) - u ( 2 ) * v ( 1 ) end function cross_product","tags":"","loc":"proc/cross_product.html","title":"cross_product – FIDASIM"},{"text":"public function in_boundary(bplane, p) result(in_b) Indicator function for determining if a point on a plane is within the plane boundary Arguments Type Intent Optional Attributes Name type( BoundedPlane ), intent(in) :: bplane Plane with boundary real(kind=Float64), intent(in), dimension(3) :: p Point on plane Return Value logical Called By proc~~in_boundary~~CalledByGraph proc~in_boundary in_boundary proc~gyro_range gyro_range proc~gyro_range->proc~in_boundary proc~hit_npa_detector hit_npa_detector proc~hit_npa_detector->proc~in_boundary proc~npa_gyro_range npa_gyro_range proc~npa_gyro_range->proc~gyro_range proc~npa_f npa_f proc~npa_f->proc~hit_npa_detector proc~npa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~hit_npa_detector proc~npa_mc->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~npa_f program~fidasim->proc~npa_mc proc~read_npa read_npa program~fidasim->proc~read_npa proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~read_npa->proc~hit_npa_detector proc~npa_weights->proc~hit_npa_detector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code in_boundary Source Code function in_boundary ( bplane , p ) result ( in_b ) !+ Indicator function for determining if a point on a plane is within the plane boundary type ( BoundedPlane ), intent ( in ) :: bplane !+ Plane with boundary real ( Float64 ), dimension ( 3 ), intent ( in ) :: p !+ Point on plane logical :: in_b real ( Float64 ), dimension ( 3 ) :: pp real ( Float64 ) :: hh , hw hh = bplane % hh hw = bplane % hw pp = matmul ( bplane % inv_basis , p - bplane % origin ) in_b = . False . SELECT CASE ( bplane % shape ) CASE ( 1 ) !Rectangular boundary if (( abs ( pp ( 1 )). le . hw ). and . & ( abs ( pp ( 2 )). le . hh )) then in_b = . True . endif CASE ( 2 ) !Circular/Ellipsoidal boundary if ((( hh * pp ( 1 )) ** 2 + ( hw * pp ( 2 )) ** 2 ). le .(( hh * hw ) ** 2 )) then in_b = . True . endif CASE DEFAULT if ( inputs % verbose . ge . 0 ) then write ( * , '(\"IN_BOUNDARY: Unknown boundary shape: \",i2)' ), bplane % shape endif stop END SELECT end function in_boundary","tags":"","loc":"proc/in_boundary.html","title":"in_boundary – FIDASIM"},{"text":"public function in_gyro_surface(gs, p) result(in_gs) Indicator function for determining if a point is inside the gyro_surface Arguments Type Intent Optional Attributes Name type( GyroSurface ), intent(in) :: gs Gyro-surface real(kind=Float64), intent(in), dimension(3) :: p Point Return Value logical Called By proc~~in_gyro_surface~~CalledByGraph proc~in_gyro_surface in_gyro_surface proc~gyro_range gyro_range proc~gyro_range->proc~in_gyro_surface proc~npa_gyro_range npa_gyro_range proc~npa_gyro_range->proc~gyro_range proc~npa_f npa_f proc~npa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~npa_f program~fidasim->proc~npa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code in_gyro_surface Source Code function in_gyro_surface ( gs , p ) result ( in_gs ) !+ Indicator function for determining if a point is inside the gyro_surface type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-surface real ( Float64 ), dimension ( 3 ), intent ( in ) :: p !+ Point logical :: in_gs real ( Float64 ), dimension ( 3 ) :: pp pp = p - gs % center in_gs = dot_product ( pp , matmul ( gs % A , pp )). le . 1.d0 end function in_gyro_surface","tags":"","loc":"proc/in_gyro_surface.html","title":"in_gyro_surface – FIDASIM"},{"text":"public function in_grid(xyz) result(ing) Determines if a position pos is in the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: xyz Position in beam grid coordinates [cm] Return Value logical Indicates whether the position is in the beam grid Calls proc~~in_grid~~CallsGraph proc~in_grid in_grid proc~approx_ge approx_ge proc~in_grid->proc~approx_ge proc~approx_le approx_le proc~in_grid->proc~approx_le proc~approx_eq approx_eq proc~approx_ge->proc~approx_eq proc~approx_le->proc~approx_eq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~in_grid~~CalledByGraph proc~in_grid in_grid proc~circle_grid_intersect circle_grid_intersect proc~circle_grid_intersect->proc~in_grid proc~read_mc read_mc proc~read_mc->proc~circle_grid_intersect proc~read_distribution read_distribution proc~read_distribution->proc~read_mc program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/in_grid.html","title":"in_grid – FIDASIM"},{"text":"public function gyro_radius(fields, energy, pitch) result(gyro_rad) Calculates mean gyro-radius Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: fields Electromagnetic fields at guiding center real(kind=Float64), intent(in) :: energy Energy of particle real(kind=Float64), intent(in) :: pitch Particle pitch w.r.t the magnetic field Return Value real(kind=Float64) Mean gyro-radius Calls proc~~gyro_radius~~CallsGraph proc~gyro_radius gyro_radius proc~gyro_step gyro_step proc~gyro_radius->proc~gyro_step proc~pitch_to_vec pitch_to_vec proc~gyro_radius->proc~pitch_to_vec proc~cross_product cross_product proc~gyro_step->proc~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code gyro_radius Source Code function gyro_radius ( fields , energy , pitch ) result ( gyro_rad ) !+ Calculates mean gyro-radius type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields at guiding center real ( Float64 ), intent ( in ) :: energy !+ Energy of particle real ( Float64 ), intent ( in ) :: pitch !+ Particle pitch w.r.t the magnetic field real ( Float64 ) :: gyro_rad !+ Mean gyro-radius real ( Float64 ), dimension ( 3 ) :: vi_norm , r_step real ( Float64 ) :: vabs , phi integer :: i , n vabs = sqrt ( energy / ( v2_to_E_per_amu * inputs % ab )) gyro_rad = 0.d0 n = 6 do i = 1 , n phi = i * 2 * pi / n call pitch_to_vec ( pitch , phi , fields , vi_norm ) call gyro_step ( vabs * vi_norm , fields , r_step ) gyro_rad = gyro_rad + norm2 ( r_step ) / n enddo end function gyro_radius","tags":"","loc":"proc/gyro_radius.html","title":"gyro_radius – FIDASIM"},{"text":"public subroutine print_banner() Prints FIDASIM banner Arguments None Called By proc~~print_banner~~CalledByGraph proc~print_banner print_banner program~fidasim fidasim program~fidasim->proc~print_banner Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code print_banner Source Code subroutine print_banner () !+ Prints FIDASIM banner write ( * , '(a)' ) \"   ____ ____ ___   ___    ____ ____ __  ___\" write ( * , '(a)' ) \"  / __//  _// _ \\ / _ |  / __//  _//  |/  /\" write ( * , '(a)' ) \" / _/ _/ / / // // __ | _\\ \\ _/ / / /|_/ / \" write ( * , '(a)' ) \"/_/  /___//____//_/ |_|/___//___//_/  /_/  \" write ( * , '(a)' ) \"                                           \" if ( version . ne . \"\" ) then write ( * , '(a,a)' ) \"Version: \" , trim ( version ) endif write ( * , '(a)' ) \"\" write ( * , '(a)' ) \"FIDASIM is released as open source code under the MIT Licence.\" write ( * , '(a)' ) \"For more information visit http://d3denergetic.github.io/FIDASIM/\" write ( * , '(a)' ) \"\" #ifdef _DEBUG write ( * , '(a)' ) \"########################### ATTENTION ###########################\" write ( * , '(a)' ) \"# Running in debug mode. All optimizations have been turned off #\" write ( * , '(a)' ) \"#################################################################\" write ( * , '(a)' ) \"\" #endif #ifdef _PROF write ( * , '(a)' ) \"########################### ATTENTION ###########################\" write ( * , '(a)' ) \"#                   Running in profiling mode                   #\" write ( * , '(a)' ) \"#################################################################\" write ( * , '(a)' ) \"\" #endif #ifdef _OMP #else write ( * , '(a)' ) \"########################### ATTENTION ###########################\" write ( * , '(a)' ) \"#              OpenMP threading has been disabled               #\" write ( * , '(a)' ) \"#################################################################\" write ( * , '(a)' ) \"\" #endif end subroutine print_banner","tags":"","loc":"proc/print_banner.html","title":"print_banner – FIDASIM"},{"text":"public subroutine fast_ion_assign(p1, p2) Defines how to assign FastIon types to eachother Arguments Type Intent Optional Attributes Name type( FastIon ), intent(out) :: p1 type( FastIon ), intent(in) :: p2 Called By proc~~fast_ion_assign~~CalledByGraph proc~fast_ion_assign fast_ion_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~fast_ion_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code fast_ion_assign Source Code subroutine fast_ion_assign ( p1 , p2 ) !+ Defines how to assign [[FastIon]] types to eachother type ( FastIon ), intent ( in ) :: p2 type ( FastIon ), intent ( out ) :: p1 p1 % cross_grid = p2 % cross_grid p1 % r = p2 % r p1 % z = p2 % z p1 % phi_enter = p2 % phi_enter p1 % delta_phi = p2 % delta_phi p1 % energy = p2 % energy p1 % pitch = p2 % pitch p1 % vabs = p2 % vabs p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % weight = p2 % weight p1 % class = p2 % class end subroutine fast_ion_assign","tags":"","loc":"proc/fast_ion_assign.html","title":"fast_ion_assign – FIDASIM"},{"text":"public subroutine npa_part_assign(p1, p2) Defines how to assign NPAParticle types to eachother Arguments Type Intent Optional Attributes Name type( NPAParticle ), intent(out) :: p1 type( NPAParticle ), intent(in) :: p2 Called By proc~~npa_part_assign~~CalledByGraph proc~npa_part_assign npa_part_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~npa_part_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code npa_part_assign Source Code subroutine npa_part_assign ( p1 , p2 ) !+ Defines how to assign [[NPAParticle]] types to eachother type ( NPAParticle ), intent ( in ) :: p2 type ( NPAParticle ), intent ( out ) :: p1 p1 % xi = p2 % xi p1 % yi = p2 % yi p1 % zi = p2 % zi p1 % xf = p2 % xf p1 % yf = p2 % yf p1 % zf = p2 % zf p1 % weight = p2 % weight p1 % energy = p2 % energy p1 % pitch = p2 % pitch p1 % detector = p2 % detector end subroutine npa_part_assign","tags":"","loc":"proc/npa_part_assign.html","title":"npa_part_assign – FIDASIM"},{"text":"public subroutine pp_assign(p1, p2) Defines how to assign Profiles types to eachother Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 Called By proc~~pp_assign~~CalledByGraph proc~pp_assign pp_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~pp_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pp_assign Source Code subroutine pp_assign ( p1 , p2 ) !+ Defines how to assign [[Profiles]] types to eachother type ( Profiles ), intent ( in ) :: p2 type ( Profiles ), intent ( inout ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz end subroutine pp_assign","tags":"","loc":"proc/pp_assign.html","title":"pp_assign – FIDASIM"},{"text":"public subroutine lpp_assign(p1, p2) Defines how to assign a Profiles type to a LocalProfiles type Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 Called By proc~~lpp_assign~~CalledByGraph proc~lpp_assign lpp_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~lpp_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lpp_assign Source Code subroutine lpp_assign ( p1 , p2 ) !+ Defines how to assign a [[Profiles]] type to a [[LocalProfiles]] type type ( Profiles ), intent ( in ) :: p2 type ( LocalProfiles ), intent ( inout ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz end subroutine lpp_assign","tags":"","loc":"proc/lpp_assign.html","title":"lpp_assign – FIDASIM"},{"text":"public subroutine plp_assign(p1, p2) Defines how to assign a LocalProfiles type to a Profiles type Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 Called By proc~~plp_assign~~CalledByGraph proc~plp_assign plp_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~plp_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code plp_assign Source Code subroutine plp_assign ( p1 , p2 ) !+ Defines how to assign a [[LocalProfiles]] type to a [[Profiles]] type type ( LocalProfiles ), intent ( in ) :: p2 type ( Profiles ), intent ( inout ) :: p1 p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz end subroutine plp_assign","tags":"","loc":"proc/plp_assign.html","title":"plp_assign – FIDASIM"},{"text":"public subroutine lplp_assign(p1, p2) Defines how to assign LocalProfiles types to eachother Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 Called By proc~~lplp_assign~~CalledByGraph proc~lplp_assign lplp_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~lplp_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lplp_assign Source Code subroutine lplp_assign ( p1 , p2 ) !+ Defines how to assign [[LocalProfiles]] types to eachother type ( LocalProfiles ), intent ( in ) :: p2 type ( LocalProfiles ), intent ( inout ) :: p1 p1 % pos = p2 % pos p1 % uvw = p2 % uvw p1 % dene = p2 % dene p1 % ti = p2 % ti p1 % te = p2 % te p1 % denp = p2 % denp p1 % denf = p2 % denf p1 % denimp = p2 % denimp p1 % zeff = p2 % zeff p1 % vr = p2 % vr p1 % vt = p2 % vt p1 % vz = p2 % vz p1 % vrot = p2 % vrot end subroutine lplp_assign","tags":"","loc":"proc/lplp_assign.html","title":"lplp_assign – FIDASIM"},{"text":"public subroutine ff_assign(p1, p2) Defines how to assign EMFields types to eachother Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 Called By proc~~ff_assign~~CalledByGraph proc~ff_assign ff_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~ff_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ff_assign Source Code subroutine ff_assign ( p1 , p2 ) !+ Defines how to assign [[EMFields]] types to eachother type ( EMFields ), intent ( in ) :: p2 type ( EMFields ), intent ( inout ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine ff_assign","tags":"","loc":"proc/ff_assign.html","title":"ff_assign – FIDASIM"},{"text":"public subroutine lff_assign(p1, p2) Defines how to assign a EMFields type to a LocalEMFields type Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 Called By proc~~lff_assign~~CalledByGraph proc~lff_assign lff_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~lff_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lff_assign Source Code subroutine lff_assign ( p1 , p2 ) !+ Defines how to assign a [[EMFields]] type to a [[LocalEMFields]] type type ( EMFields ), intent ( in ) :: p2 type ( LocalEMFields ), intent ( inout ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine lff_assign","tags":"","loc":"proc/lff_assign.html","title":"lff_assign – FIDASIM"},{"text":"public subroutine flf_assign(p1, p2) Defines how to assign a LocalEMFields type to a EMFields type Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 Called By proc~~flf_assign~~CalledByGraph proc~flf_assign flf_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~flf_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code flf_assign Source Code subroutine flf_assign ( p1 , p2 ) !+ Defines how to assign a [[LocalEMFields]] type to a [[EMFields]] type type ( LocalEMFields ), intent ( in ) :: p2 type ( EMFields ), intent ( inout ) :: p1 p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine flf_assign","tags":"","loc":"proc/flf_assign.html","title":"flf_assign – FIDASIM"},{"text":"public subroutine lflf_assign(p1, p2) Defines how to assign LocalEMFields types to eachother Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 Called By proc~~lflf_assign~~CalledByGraph proc~lflf_assign lflf_assign interface~assignment(=) assignment(=) interface~assignment(=)->proc~lflf_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lflf_assign Source Code subroutine lflf_assign ( p1 , p2 ) !+ Defines how to assign [[LocalEMFields]] types to eachother type ( LocalEMFields ), intent ( in ) :: p2 type ( LocalEMFields ), intent ( inout ) :: p1 p1 % pos = p2 % pos p1 % uvw = p2 % uvw p1 % br = p2 % br p1 % bt = p2 % bt p1 % bz = p2 % bz p1 % er = p2 % er p1 % et = p2 % et p1 % ez = p2 % ez p1 % b_abs = p2 % b_abs p1 % e_abs = p2 % e_abs p1 % a_norm = p2 % a_norm p1 % b_norm = p2 % b_norm p1 % c_norm = p2 % c_norm p1 % e_norm = p2 % e_norm p1 % dbr_dr = p2 % dbr_dr p1 % dbr_dz = p2 % dbr_dz p1 % dbt_dr = p2 % dbt_dr p1 % dbt_dz = p2 % dbt_dz p1 % dbz_dr = p2 % dbz_dr p1 % dbz_dz = p2 % dbz_dz end subroutine lflf_assign","tags":"","loc":"proc/lflf_assign.html","title":"lflf_assign – FIDASIM"},{"text":"public subroutine read_inputs() Reads input namelist file and stores the results into inputs , nbi , and beam_grid 20 for suffixes and seperators e.g. /, _npa.h5, ... Arguments None Called By proc~~read_inputs~~CalledByGraph proc~read_inputs read_inputs program~fidasim fidasim program~fidasim->proc~read_inputs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code read_inputs Source Code subroutine read_inputs !+ Reads input namelist file and stores the results into [[libfida:inputs]], !+ [[libfida:nbi]], and [[libfida:beam_grid]] character ( charlim ) :: runid , result_dir , tables_file character ( charlim ) :: distribution_file , equilibrium_file character ( charlim ) :: geometry_file , neutrals_file integer :: pathlen , calc_neutron integer :: calc_brems , calc_bes , calc_fida , calc_npa integer :: calc_birth , calc_fida_wght , calc_npa_wght integer :: load_neutrals , verbose , dump_dcx , no_flr integer ( Int64 ) :: n_fida , n_npa , n_nbi , n_halo , n_dcx , n_birth integer ( Int32 ) :: shot , nlambda , ne_wght , np_wght , nphi_wght , nlambda_wght real ( Float64 ) :: time , lambdamin , lambdamax , emax_wght real ( Float64 ) :: lambdamin_wght , lambdamax_wght real ( Float64 ) :: ai , ab , pinj , einj , current_fractions ( 3 ) integer ( Int32 ) :: impurity_charge integer ( Int32 ) :: nx , ny , nz real ( Float64 ) :: xmin , xmax , ymin , ymax , zmin , zmax real ( Float64 ) :: alpha , beta , gamma , origin ( 3 ) logical :: exis , error NAMELIST / fidasim_inputs / result_dir , tables_file , distribution_file , & geometry_file , equilibrium_file , neutrals_file , shot , time , runid , & calc_brems , calc_bes , calc_fida , calc_npa , calc_birth , no_flr , & calc_fida_wght , calc_npa_wght , load_neutrals , dump_dcx , verbose , & calc_neutron , n_fida , n_npa , n_nbi , n_halo , n_dcx , n_birth , & ab , pinj , einj , current_fractions , ai , impurity_charge , & nx , ny , nz , xmin , xmax , ymin , ymax , zmin , zmax , & origin , alpha , beta , gamma , & ne_wght , np_wght , nphi_wght , & nlambda , lambdamin , lambdamax , emax_wght , & nlambda_wght , lambdamin_wght , lambdamax_wght inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'READ_INPUTS: Input file does not exist: ' , trim ( namelist_file ) stop endif !!Set Defaults TODO: remove at next major release no_flr = 0 calc_neutron = 0 open ( 13 , file = namelist_file ) read ( 13 , NML = fidasim_inputs ) close ( 13 ) !!General Information inputs % shot_number = shot inputs % time = time inputs % runid = runid inputs % result_dir = result_dir !!Input Files inputs % tables_file = tables_file inputs % geometry_file = geometry_file inputs % equilibrium_file = equilibrium_file inputs % distribution_file = distribution_file inputs % neutrals_file = neutrals_file !!Simulation Switches if (( calc_brems + calc_bes + calc_fida ). gt . 0 ) then inputs % calc_spec = 1 else inputs % calc_spec = 0 endif inputs % calc_brems = calc_brems inputs % calc_bes = calc_bes inputs % calc_fida = calc_fida inputs % calc_npa = calc_npa inputs % calc_birth = calc_birth inputs % calc_fida_wght = calc_fida_wght inputs % calc_npa_wght = calc_npa_wght inputs % calc_neutron = calc_neutron inputs % load_neutrals = load_neutrals inputs % dump_dcx = dump_dcx inputs % verbose = verbose inputs % no_flr = no_flr !!Monte Carlo Settings inputs % n_fida = max ( 10 , n_fida ) inputs % n_npa = max ( 10 , n_npa ) inputs % n_nbi = max ( 10 , n_nbi ) inputs % n_halo = max ( 10 , n_halo ) inputs % n_dcx = max ( 10 , n_dcx ) inputs % n_birth = max ( 1 , nint ( n_birth / real ( n_nbi ))) !!Plasma Settings inputs % ai = ai inputs % impurity_charge = impurity_charge !!Neutral Beam Settings inputs % ab = ab nbi % current_fractions = current_fractions nbi % einj = einj nbi % pinj = pinj !!Weight Function Settings inputs % ne_wght = ne_wght inputs % np_wght = np_wght inputs % nphi_wght = nphi_wght inputs % emax_wght = emax_wght inputs % nlambda_wght = nlambda_wght inputs % lambdamin_wght = lambdamin_wght inputs % lambdamax_wght = lambdamax_wght !!Wavelength Grid Settings inputs % nlambda = nlambda inputs % lambdamin = lambdamin inputs % lambdamax = lambdamax inputs % dlambda = ( inputs % lambdamax - inputs % lambdamin ) / inputs % nlambda !!Beam Grid Settings beam_grid % nx = nx beam_grid % ny = ny beam_grid % nz = nz beam_grid % xmin = xmin beam_grid % xmax = xmax beam_grid % ymin = ymin beam_grid % ymax = ymax beam_grid % zmin = zmin beam_grid % zmax = zmax beam_grid % alpha = alpha beam_grid % beta = beta beam_grid % gamma = gamma beam_grid % origin = origin if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Shot settings ----\" write ( * , '(T2,\"Shot: \",i8)' ) inputs % shot_number write ( * , '(T2,\"Time: \",i4,\" [ms]\")' ) int ( inputs % time * 1.d3 ) write ( * , '(T2,\"Runid: \",a)' ) trim ( adjustl ( inputs % runid )) write ( * , * ) '' write ( * , '(a)' ) \"---- Input files ----\" endif error = . False . inquire ( file = inputs % tables_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Tables file: \",a)' ) trim ( inputs % tables_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Tables file does not exist: ' , & trim ( inputs % tables_file ) endif error = . True . endif inquire ( file = inputs % geometry_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Geometry file: \",a)' ) trim ( inputs % geometry_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Geometry file does not exist: ' , & trim ( inputs % geometry_file ) endif error = . True . endif inquire ( file = inputs % equilibrium_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Equilibrium file: \",a)' ) trim ( inputs % equilibrium_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Equilibrium file does not exist: ' , & trim ( inputs % equilibrium_file ) endif error = . True . endif inquire ( file = inputs % distribution_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Distribution file: \",a)' ) trim ( inputs % distribution_file ) endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_INPUTS: Distribution file does not exist: ' , & trim ( inputs % distribution_file ) endif error = . True . endif pathlen = len_trim ( inputs % result_dir ) + len_trim ( inputs % runid ) + 20 !+20 for suffixes and seperators e.g. /, _npa.h5, ... if ( pathlen . gt . charlim ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,i3,a,i3)' ) 'READ_INPUTS: Result directory path + runID use too many characters: ' , & pathlen - 20 , '>' , charlim - 20 endif error = . True . endif if ( inputs % verbose . ge . 1 ) then write ( * , * ) '' endif if ( error ) then stop endif end subroutine read_inputs","tags":"","loc":"proc/read_inputs.html","title":"read_inputs – FIDASIM"},{"text":"public subroutine make_beam_grid() Makes [[libfida:beam_grid] from user defined inputs Arguments None Calls proc~~make_beam_grid~~CallsGraph proc~make_beam_grid make_beam_grid proc~tb_zyx tb_zyx proc~make_beam_grid->proc~tb_zyx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~make_beam_grid~~CalledByGraph proc~make_beam_grid make_beam_grid program~fidasim fidasim program~fidasim->proc~make_beam_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code make_beam_grid Source Code subroutine make_beam_grid !+ Makes [[libfida:beam_grid] from user defined inputs integer ( Int32 ) :: i real ( Float64 ) :: dx , dy , dz allocate ( beam_grid % xc ( beam_grid % nx ), & beam_grid % yc ( beam_grid % ny ), & beam_grid % zc ( beam_grid % nz )) dx = ( beam_grid % xmax - beam_grid % xmin ) / beam_grid % nx dy = ( beam_grid % ymax - beam_grid % ymin ) / beam_grid % ny dz = ( beam_grid % zmax - beam_grid % zmin ) / beam_grid % nz do i = 1 , beam_grid % nx beam_grid % xc ( i ) = beam_grid % xmin + ( i - 0.5 ) * dx enddo do i = 1 , beam_grid % ny beam_grid % yc ( i ) = beam_grid % ymin + ( i - 0.5 ) * dy enddo do i = 1 , beam_grid % nz beam_grid % zc ( i ) = beam_grid % zmin + ( i - 0.5 ) * dz enddo beam_grid % dr ( 1 ) = abs ( beam_grid % xc ( 2 ) - beam_grid % xc ( 1 )) beam_grid % dr ( 2 ) = abs ( beam_grid % yc ( 2 ) - beam_grid % yc ( 1 )) beam_grid % dr ( 3 ) = abs ( beam_grid % zc ( 2 ) - beam_grid % zc ( 1 )) beam_grid % lwh ( 1 ) = abs ( beam_grid % xc ( beam_grid % nx ) - beam_grid % xc ( 1 )) + beam_grid % dr ( 1 ) beam_grid % lwh ( 2 ) = abs ( beam_grid % yc ( beam_grid % ny ) - beam_grid % yc ( 1 )) + beam_grid % dr ( 2 ) beam_grid % lwh ( 3 ) = abs ( beam_grid % zc ( beam_grid % nz ) - beam_grid % zc ( 1 )) + beam_grid % dr ( 3 ) beam_grid % volume = beam_grid % lwh ( 1 ) * beam_grid % lwh ( 2 ) * beam_grid % lwh ( 3 ) beam_grid % center ( 1 ) = ( minval ( beam_grid % xc ) - 0.5 * beam_grid % dr ( 1 )) + 0.5 * beam_grid % lwh ( 1 ) beam_grid % center ( 2 ) = ( minval ( beam_grid % yc ) - 0.5 * beam_grid % dr ( 2 )) + 0.5 * beam_grid % lwh ( 2 ) beam_grid % center ( 3 ) = ( minval ( beam_grid % zc ) - 0.5 * beam_grid % dr ( 3 )) + 0.5 * beam_grid % lwh ( 3 ) beam_grid % drmin = minval ( beam_grid % dr ) beam_grid % dv = beam_grid % dr ( 1 ) * beam_grid % dr ( 2 ) * beam_grid % dr ( 3 ) beam_grid % ntrack = beam_grid % nx + beam_grid % ny + beam_grid % nz beam_grid % ngrid = beam_grid % nx * beam_grid % ny * beam_grid % nz call tb_zyx ( beam_grid % alpha , beam_grid % beta , beam_grid % gamma , & beam_grid % basis , beam_grid % inv_basis ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Beam grid settings ----\" write ( * , '(T2,\"Nx: \", i3)' ) beam_grid % nx write ( * , '(T2,\"Ny: \", i3)' ) beam_grid % ny write ( * , '(T2,\"Nz: \", i3)' ) beam_grid % nz write ( * , '(T2,\"dV: \", f5.2,\" [cm&#94;3]\")' ) beam_grid % dv write ( * , '(T2,\"alpha: \",f5.2,\" [rad]\")' ) beam_grid % alpha write ( * , '(T2,\"beta:  \",f5.2,\" [rad]\")' ) beam_grid % beta write ( * , '(T2,\"gamma: \",f5.2,\" [rad]\")' ) beam_grid % gamma write ( * , '(T2,\"origin: [\",f7.2,\",\",f7.2,\",\",f7.2,\"] [cm]\")' ) beam_grid % origin write ( * , * ) '' endif end subroutine make_beam_grid","tags":"","loc":"proc/make_beam_grid.html","title":"make_beam_grid – FIDASIM"},{"text":"public subroutine read_beam() Reads neutral beam geometry and stores the quantities in nbi Arguments None Calls proc~~read_beam~~CallsGraph proc~read_beam read_beam proc~tb_zyx tb_zyx proc~read_beam->proc~tb_zyx proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_beam->proc~h5ltread_dataset_int_scalar_f h5close_f h5close_f proc~read_beam->h5close_f h5gopen_f h5gopen_f proc~read_beam->h5gopen_f h5ltpath_valid_f h5ltpath_valid_f proc~read_beam->h5ltpath_valid_f h5open_f h5open_f proc~read_beam->h5open_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_beam->h5ltread_dataset_double_f h5gclose_f h5gclose_f proc~read_beam->h5gclose_f proc~uvw_to_xyz uvw_to_xyz proc~read_beam->proc~uvw_to_xyz proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_beam->proc~h5ltread_dataset_double_scalar_f h5fclose_f h5fclose_f proc~read_beam->h5fclose_f h5fopen_f h5fopen_f proc~read_beam->h5fopen_f h5ltread_dataset_string_f h5ltread_dataset_string_f proc~read_beam->h5ltread_dataset_string_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_beam->h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~read_beam~~CalledByGraph proc~read_beam read_beam program~fidasim fidasim program~fidasim->proc~read_beam Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code read_beam Source Code subroutine read_beam !+ Reads neutral beam geometry and stores the quantities in [[libfida:nbi]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 1 ) :: dims real ( Float64 ), dimension ( 3 ) :: uvw_src , uvw_axis , pos real ( Float64 ) :: dis logical :: path_valid integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDONLY_F , fid , error ) !!Open NBI group call h5gopen_f ( fid , \"/nbi\" , gid , error ) !!Read in beam definitions call h5ltread_dataset_string_f ( gid , \"/nbi/name\" , nbi % name , error ) dims ( 1 ) = 3 call h5ltread_dataset_double_f ( gid , \"/nbi/src\" , uvw_src , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/axis\" , uvw_axis , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/divy\" , nbi % divy , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/divz\" , nbi % divz , dims , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/nbi/shape\" , nbi % shape , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/focy\" , nbi % focy , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/focz\" , nbi % focz , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/widy\" , nbi % widy , error ) call h5ltread_dataset_double_scalar_f ( gid , \"/nbi/widz\" , nbi % widz , error ) !!Read in aperture definitions !! Check for naperture for compatibility with old runs call h5ltpath_valid_f ( gid , \"/nbi/naperture\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltread_dataset_int_scalar_f ( gid , \"/nbi/naperture\" , nbi % naperture , error ) else nbi % naperture = 0 endif if ( nbi % naperture . gt . 0 ) then allocate ( nbi % ashape ( nbi % naperture ), nbi % adist ( nbi % naperture ), & nbi % awidy ( nbi % naperture ), nbi % awidz ( nbi % naperture ), & nbi % aoffy ( nbi % naperture ), nbi % aoffz ( nbi % naperture ) ) dims ( 1 ) = nbi % naperture call h5ltread_dataset_int_f ( gid , \"/nbi/ashape\" , nbi % ashape , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/awidy\" , nbi % awidy , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/awidz\" , nbi % awidz , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/aoffy\" , nbi % aoffy , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/aoffz\" , nbi % aoffz , dims , error ) call h5ltread_dataset_double_f ( gid , \"/nbi/adist\" , nbi % adist , dims , error ) endif !!Close NBI group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) !!Convert to beam grid coordinates call uvw_to_xyz ( uvw_src , nbi % src ) nbi % axis = matmul ( beam_grid % inv_basis , uvw_axis ) nbi % vinj = sqrt ( 2.d0 * nbi % einj * 1.d3 * e0 / ( inputs % ab * mass_u )) * 1.d2 !! [cm/s] pos = nbi % src + 20 0.0 * nbi % axis dis = sqrt ( sum (( pos - nbi % src ) ** 2 )) nbi % beta = asin (( nbi % src ( 3 ) - pos ( 3 )) / dis ) nbi % alpha = atan2 ( pos ( 2 ) - nbi % src ( 2 ), pos ( 1 ) - nbi % src ( 1 )) call tb_zyx ( nbi % alpha , nbi % beta , 0.d0 , nbi % basis , nbi % inv_basis ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Neutral beam settings ----' write ( * , '(T2,\"Beam: \",a)' ) nbi % name write ( * , '(T2,\"Power:   \",f5.2,\" [MW]\")' ) nbi % pinj write ( * , '(T2,\"Voltage: \",f6.2,\" [keV]\")' ) nbi % einj write ( * , * ) '' endif end subroutine read_beam","tags":"","loc":"proc/read_beam.html","title":"read_beam – FIDASIM"},{"text":"public subroutine read_chords() Reads the spectral geometry and stores the quantities in spec_chords Arguments None Calls proc~~read_chords~~CallsGraph proc~read_chords read_chords proc~track track proc~read_chords->proc~track proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_chords->proc~h5ltread_dataset_int_scalar_f proc~randu randu proc~read_chords->proc~randu h5gclose_f h5gclose_f proc~read_chords->h5gclose_f h5fclose_f h5fclose_f proc~read_chords->h5fclose_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_chords->h5ltread_dataset_double_f h5ltpath_valid_f h5ltpath_valid_f proc~read_chords->h5ltpath_valid_f h5ltread_dataset_string_f h5ltread_dataset_string_f proc~read_chords->h5ltread_dataset_string_f h5close_f h5close_f proc~read_chords->h5close_f proc~uvw_to_xyz uvw_to_xyz proc~read_chords->proc~uvw_to_xyz h5gopen_f h5gopen_f proc~read_chords->h5gopen_f h5fopen_f h5fopen_f proc~read_chords->h5fopen_f proc~grid_intersect grid_intersect proc~read_chords->proc~grid_intersect h5open_f h5open_f proc~read_chords->h5open_f proc~line_basis line_basis proc~read_chords->proc~line_basis proc~get_indices get_indices proc~track->proc~get_indices proc~in_plasma in_plasma proc~track->proc~in_plasma h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~tb_zyx tb_zyx proc~line_basis->proc~tb_zyx proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff var panprocread_chordsCallsGraph = svgPanZoom('#procread_chordsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~read_chords~~CalledByGraph proc~read_chords read_chords program~fidasim fidasim program~fidasim->proc~read_chords Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code read_chords Source Code subroutine read_chords !+ Reads the spectral geometry and stores the quantities in [[libfida:spec_chords]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 2 ) :: dims logical :: path_valid real ( Float64 ), dimension (:,:), allocatable :: lenses real ( Float64 ), dimension (:,:), allocatable :: axes real ( Float64 ), dimension (:,:,:), allocatable :: dlength real ( Float64 ), dimension (:), allocatable :: spot_size , sigma_pi type ( LOSElement ), dimension (:), allocatable :: los_elem real ( Float64 ) :: r0 ( 3 ), v0 ( 3 ), r_enter ( 3 ), r_exit ( 3 ) real ( Float64 ) :: xyz_lens ( 3 ), xyz_axis ( 3 ), length real ( Float64 ), dimension ( 3 , 3 ) :: basis real ( Float64 ), dimension ( 2 ) :: randomu real ( Float64 ) :: theta , sqrt_rho type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks character ( len = 20 ) :: system = '' integer :: i , j , ic , nc , ncell , ind ( 3 ), ii , jj , kk integer :: error if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- FIDA/BES settings ----' endif !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDONLY_F , fid , error ) !!Check if SPEC group exists call h5ltpath_valid_f ( fid , \"/spec\" , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'FIDA/BES geometry is not in the geometry file' write ( * , '(a)' ) 'Continuing without spectral diagnostics' endif inputs % calc_spec = 0 inputs % calc_fida = 0 inputs % calc_bes = 0 inputs % calc_brems = 0 inputs % calc_fida_wght = 0 call h5fclose_f ( fid , error ) call h5close_f ( error ) return endif !!Open SPEC group call h5gopen_f ( fid , \"/spec\" , gid , error ) call h5ltread_dataset_string_f ( gid , \"/spec/system\" , system , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/spec/nchan\" , spec_chords % nchan , error ) allocate ( lenses ( 3 , spec_chords % nchan )) allocate ( axes ( 3 , spec_chords % nchan )) allocate ( spot_size ( spec_chords % nchan )) allocate ( sigma_pi ( spec_chords % nchan )) allocate ( spec_chords % los ( spec_chords % nchan )) allocate ( spec_chords % radius ( spec_chords % nchan )) allocate ( dlength ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz ) ) dims = [ 3 , spec_chords % nchan ] call h5ltread_dataset_double_f ( gid , \"/spec/lens\" , lenses , dims , error ) call h5ltread_dataset_double_f ( gid , \"/spec/axis\" , axes , dims , error ) call h5ltread_dataset_double_f ( gid , \"/spec/spot_size\" , spot_size , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/spec/sigma_pi\" , sigma_pi , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/spec/radius\" , spec_chords % radius , dims ( 2 : 2 ), error ) !!Close SPEC group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) chan_loop : do i = 1 , spec_chords % nchan call uvw_to_xyz ( lenses (:, i ), xyz_lens ) xyz_axis = matmul ( beam_grid % inv_basis , axes (:, i )) spec_chords % los ( i )% lens = xyz_lens spec_chords % los ( i )% axis = xyz_axis spec_chords % los ( i )% sigma_pi = sigma_pi ( i ) spec_chords % los ( i )% spot_size = spot_size ( i ) r0 = xyz_lens v0 = xyz_axis v0 = v0 / norm2 ( v0 ) call line_basis ( r0 , v0 , basis ) call grid_intersect ( r0 , v0 , length , r_enter , r_exit ) if ( length . le . 0.d0 ) then if ( inputs % verbose . ge . 0 ) then WRITE ( * , '(\"Channel \",i5,\" missed the beam grid\")' ), i endif cycle chan_loop endif if ( spot_size ( i ). le . 0.d0 ) then nc = 1 else nc = 100 endif dlength = 0.d0 !$OMP PARALLEL DO schedule(guided) private(ic,randomu,sqrt_rho,theta,r0, & !$OMP& length, r_enter, r_exit, j, tracks, ncell, ind) do ic = 1 , nc ! Uniformally sample within spot size call randu ( randomu ) sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) r0 ( 1 ) = 0.d0 r0 ( 2 ) = spot_size ( i ) * sqrt_rho * cos ( theta ) r0 ( 3 ) = spot_size ( i ) * sqrt_rho * sin ( theta ) r0 = matmul ( basis , r0 ) + xyz_lens call grid_intersect ( r0 , v0 , length , r_enter , r_exit ) call track ( r_enter , v0 , tracks , ncell ) track_loop : do j = 1 , ncell ind = tracks ( j )% ind !inds can repeat so add rather than assign !$OMP CRITICAL(read_chords_1) dlength ( ind ( 1 ), ind ( 2 ), ind ( 3 )) = & dlength ( ind ( 1 ), ind ( 2 ), ind ( 3 )) + tracks ( j )% time / real ( nc ) !time == distance !$OMP END CRITICAL(read_chords_1) enddo track_loop enddo !$OMP END PARALLEL DO do kk = 1 , beam_grid % nz do jj = 1 , beam_grid % ny xloop : do ii = 1 , beam_grid % nx if ( dlength ( ii , jj , kk ). ne . 0.d0 ) then nc = spec_chords % inter ( ii , jj , kk )% nchan + 1 if ( nc . eq . 1 ) then allocate ( spec_chords % inter ( ii , jj , kk )% los_elem ( nc )) spec_chords % inter ( ii , jj , kk )% los_elem ( nc ) = LOSElement ( i , dlength ( ii , jj , kk )) else allocate ( los_elem ( nc )) los_elem ( 1 :( nc - 1 )) = spec_chords % inter ( ii , jj , kk )% los_elem los_elem ( nc ) = LOSElement ( i , dlength ( ii , jj , kk )) deallocate ( spec_chords % inter ( ii , jj , kk )% los_elem ) call move_alloc ( los_elem , spec_chords % inter ( ii , jj , kk )% los_elem ) endif spec_chords % inter ( ii , jj , kk )% nchan = nc endif enddo xloop enddo enddo enddo chan_loop if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"FIDA/BES System: \",a)' ) trim ( adjustl ( system )) write ( * , '(T2,\"Number of channels: \",i5)' ) spec_chords % nchan write ( * , * ) '' endif deallocate ( lenses , axes , spot_size , sigma_pi ) end subroutine read_chords","tags":"","loc":"proc/read_chords.html","title":"read_chords – FIDASIM"},{"text":"public subroutine read_npa() Reads the NPA geometry and stores the quantities in npa_chords Arguments None Calls proc~~read_npa~~CallsGraph proc~read_npa read_npa proc~plane_basis plane_basis proc~read_npa->proc~plane_basis proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_npa->proc~h5ltread_dataset_int_scalar_f h5gclose_f h5gclose_f proc~read_npa->h5gclose_f h5fclose_f h5fclose_f proc~read_npa->h5fclose_f proc~get_fields get_fields proc~read_npa->proc~get_fields h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_npa->h5ltread_dataset_double_f h5ltpath_valid_f h5ltpath_valid_f proc~read_npa->h5ltpath_valid_f h5ltread_dataset_string_f h5ltread_dataset_string_f proc~read_npa->h5ltread_dataset_string_f h5close_f h5close_f proc~read_npa->h5close_f proc~uvw_to_xyz uvw_to_xyz proc~read_npa->proc~uvw_to_xyz proc~hit_npa_detector hit_npa_detector proc~read_npa->proc~hit_npa_detector h5gopen_f h5gopen_f proc~read_npa->h5gopen_f h5fopen_f h5fopen_f proc~read_npa->h5fopen_f proc~grid_intersect grid_intersect proc~read_npa->proc~grid_intersect h5open_f h5open_f proc~read_npa->h5open_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_npa->h5ltread_dataset_int_f proc~cross_product cross_product proc~plane_basis->proc~cross_product proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~get_position get_position proc~get_fields->proc~get_position proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector->proc~line_plane_intersect proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff var panprocread_npaCallsGraph = svgPanZoom('#procread_npaCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~read_npa~~CalledByGraph proc~read_npa read_npa program~fidasim fidasim program~fidasim->proc~read_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code read_npa Source Code subroutine read_npa !+ Reads the NPA geometry and stores the quantities in [[libfida:npa_chords]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 2 ) :: dims logical :: path_valid real ( Float64 ), dimension (:,:), allocatable :: a_tedge , a_redge , a_cent real ( Float64 ), dimension (:,:), allocatable :: d_tedge , d_redge , d_cent integer , dimension (:), allocatable :: a_shape , d_shape character ( len = 20 ) :: system = '' real ( Float64 ), parameter :: inv_4pi = ( 4.d0 * pi ) ** ( - 1 ) real ( Float64 ), dimension ( 3 ) :: xyz_a_tedge , xyz_a_redge , xyz_a_cent real ( Float64 ), dimension ( 3 ) :: xyz_d_tedge , xyz_d_redge , xyz_d_cent real ( Float64 ), dimension ( 3 ) :: eff_rd , rd , rd_d , r0 , r0_d , v0 real ( Float64 ), dimension ( 3 , 3 ) :: basis , inv_basis real ( Float64 ), dimension ( 50 ) :: xd , yd type ( LocalEMFields ) :: fields real ( Float64 ) :: length , total_prob , hh , hw , dprob , dx , dy , r , pitch integer :: ichan , i , j , k , ix , iy , d_index , nd , cnt integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % geometry_file , H5F_ACC_RDWR_F , fid , error ) !!Check if NPA group exists call h5ltpath_valid_f ( fid , \"/npa\" , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'NPA geometry is not in the geometry file' write ( * , '(a)' ) 'Continuing without NPA diagnostics' endif inputs % calc_npa = 0 inputs % calc_npa_wght = 0 call h5fclose_f ( fid , error ) call h5close_f ( error ) return endif !!Open NPA group call h5gopen_f ( fid , \"/npa\" , gid , error ) call h5ltread_dataset_string_f ( gid , \"/npa/system\" , system , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/npa/nchan\" , npa_chords % nchan , error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- NPA settings ----\" write ( * , '(T2,\"NPA System: \", a)' ) trim ( adjustl ( system )) write ( * , '(T2,\"Number of channels: \",i3)' ) npa_chords % nchan endif allocate ( a_tedge ( 3 , npa_chords % nchan )) allocate ( a_redge ( 3 , npa_chords % nchan )) allocate ( a_cent ( 3 , npa_chords % nchan )) allocate ( a_shape ( npa_chords % nchan )) allocate ( d_tedge ( 3 , npa_chords % nchan )) allocate ( d_redge ( 3 , npa_chords % nchan )) allocate ( d_cent ( 3 , npa_chords % nchan )) allocate ( d_shape ( npa_chords % nchan )) allocate ( npa_chords % radius ( npa_chords % nchan )) allocate ( npa_chords % det ( npa_chords % nchan )) allocate ( npa_chords % phit ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan ) ) allocate ( npa_chords % hit ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz ) ) npa_chords % hit = . False . dims = [ 3 , spec_chords % nchan ] call h5ltread_dataset_double_f ( gid , \"/npa/radius\" , npa_chords % radius , dims ( 2 : 2 ), error ) call h5ltread_dataset_int_f ( gid , \"/npa/a_shape\" , a_shape , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_tedge\" , a_tedge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_redge\" , a_redge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/a_cent\" , a_cent , dims , error ) call h5ltread_dataset_int_f ( gid , \"/npa/d_shape\" , d_shape , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_tedge\" , d_tedge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_redge\" , d_redge , dims , error ) call h5ltread_dataset_double_f ( gid , \"/npa/d_cent\" , d_cent , dims , error ) !!Close NPA group call h5gclose_f ( gid , error ) !!Close file id call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) ! Define detector/aperture shape npa_chords % det % detector % shape = d_shape npa_chords % det % aperture % shape = a_shape chan_loop : do ichan = 1 , npa_chords % nchan ! Convert to beam grid coordinates call uvw_to_xyz ( a_cent (:, ichan ), xyz_a_cent ) call uvw_to_xyz ( a_redge (:, ichan ), xyz_a_redge ) call uvw_to_xyz ( a_tedge (:, ichan ), xyz_a_tedge ) call uvw_to_xyz ( d_cent (:, ichan ), xyz_d_cent ) call uvw_to_xyz ( d_redge (:, ichan ), xyz_d_redge ) call uvw_to_xyz ( d_tedge (:, ichan ), xyz_d_tedge ) ! Define detector/aperture hh/hw npa_chords % det ( ichan )% detector % hw = norm2 ( xyz_d_redge - xyz_d_cent ) npa_chords % det ( ichan )% aperture % hw = norm2 ( xyz_a_redge - xyz_a_cent ) npa_chords % det ( ichan )% detector % hh = norm2 ( xyz_d_tedge - xyz_d_cent ) npa_chords % det ( ichan )% aperture % hh = norm2 ( xyz_a_tedge - xyz_a_cent ) ! Define detector/aperture origin npa_chords % det ( ichan )% detector % origin = xyz_d_cent npa_chords % det ( ichan )% aperture % origin = xyz_a_cent ! Define detector/aperture basis call plane_basis ( xyz_d_cent , xyz_d_redge , xyz_d_tedge , & npa_chords % det ( ichan )% detector % basis , & npa_chords % det ( ichan )% detector % inv_basis ) call plane_basis ( xyz_a_cent , xyz_a_redge , xyz_a_tedge , & npa_chords % det ( ichan )% aperture % basis , & npa_chords % det ( ichan )% aperture % inv_basis ) v0 = xyz_a_cent - xyz_d_cent v0 = v0 / norm2 ( v0 ) call grid_intersect ( xyz_d_cent , v0 , length , r0 , r0_d ) if ( length . le . 0.0 ) then if ( inputs % verbose . ge . 0 ) then WRITE ( * , '(\"Channel \",i3,\" centerline missed the beam grid\")' ), ichan endif endif if ( inputs % calc_npa_wght . ge . 1 ) then hw = npa_chords % det ( ichan )% detector % hw hh = npa_chords % det ( ichan )% detector % hh nd = size ( xd ) do i = 1 , nd xd ( i ) = - hw + 2 * hw * ( i - 0.5 ) / real ( nd ) yd ( i ) = - hh + 2 * hh * ( i - 0.5 ) / real ( nd ) enddo dx = abs ( xd ( 2 ) - xd ( 1 )) dy = abs ( yd ( 2 ) - yd ( 1 )) basis = npa_chords % det ( ichan )% detector % basis inv_basis = npa_chords % det ( ichan )% detector % inv_basis cnt = 0 ! For each grid point find the probability of hitting the detector given an isotropic source !$OMP PARALLEL DO schedule(guided) collapse(3) private(i,j,k,ix,iy,total_prob,eff_rd,r0,r0_d, & !$OMP& rd_d,rd,d_index,v0,dprob,r,fields) do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx cnt = cnt + 1 total_prob = 0.d0 eff_rd = eff_rd * 0.d0 r0 = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] r0_d = matmul ( inv_basis , r0 - xyz_d_cent ) do ix = 1 , nd do iy = 1 , nd rd_d = [ xd ( ix ), yd ( iy ), 0.d0 ] rd = matmul ( basis , rd_d ) + xyz_d_cent v0 = rd - r0 d_index = 0 call hit_npa_detector ( r0 , v0 , d_index , det = ichan ) if ( d_index . ne . 0 ) then r = norm2 ( rd_d - r0_d ) ** 2 dprob = ( dx * dy ) * inv_4pi * r0_d ( 3 ) / ( r * sqrt ( r )) eff_rd = eff_rd + dprob * rd total_prob = total_prob + dprob endif enddo !yd loop enddo !xd loop if ( total_prob . gt . 0.0 ) then eff_rd = eff_rd / total_prob call get_fields ( fields , pos = r0 ) v0 = ( eff_rd - r0 ) / norm2 ( eff_rd - r0 ) npa_chords % phit ( i , j , k , ichan )% pitch = dot_product ( fields % b_norm , v0 ) npa_chords % phit ( i , j , k , ichan )% p = total_prob npa_chords % phit ( i , j , k , ichan )% dir = v0 npa_chords % phit ( i , j , k , ichan )% eff_rd = eff_rd npa_chords % hit ( i , j , k ) = . True . endif if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(T4,\"Channel: \",i5,\" \",f7.2,\"% completed\",a,$)' ) & ichan , cnt / real ( beam_grid % ngrid ) * 100 , char ( 13 ) endif enddo !x loop enddo !y loop enddo !z loop !$OMP END PARALLEL DO total_prob = sum ( npa_chords % phit (:,:,:, ichan )% p ) if ( total_prob . le . 0.d0 ) then if ( inputs % verbose . ge . 0 ) then WRITE ( * , '(\"Channel \",i3,\" missed the beam grid\")' ), ichan endif cycle chan_loop endif endif enddo chan_loop if ( inputs % verbose . ge . 1 ) write ( * , '(50X,a)' ) \"\" deallocate ( a_shape , a_cent , a_redge , a_tedge ) deallocate ( d_shape , d_cent , d_redge , d_tedge ) end subroutine read_npa","tags":"","loc":"proc/read_npa.html","title":"read_npa – FIDASIM"},{"text":"public subroutine read_equilibrium() Reads in the interpolation grid, plasma parameters, and fields\n and stores the quantities in inter_grid and equil Arguments None Calls proc~~read_equilibrium~~CallsGraph proc~read_equilibrium read_equilibrium proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_equilibrium->proc~h5ltread_dataset_int_scalar_f h5close_f h5close_f proc~read_equilibrium->h5close_f h5gopen_f h5gopen_f proc~read_equilibrium->h5gopen_f h5open_f h5open_f proc~read_equilibrium->h5open_f h5gclose_f h5gclose_f proc~read_equilibrium->h5gclose_f h5fclose_f h5fclose_f proc~read_equilibrium->h5fclose_f interface~deriv deriv proc~read_equilibrium->interface~deriv h5fopen_f h5fopen_f proc~read_equilibrium->h5fopen_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_equilibrium->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_equilibrium->h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~read_equilibrium~~CalledByGraph proc~read_equilibrium read_equilibrium program~fidasim fidasim program~fidasim->proc~read_equilibrium Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code read_equilibrium Source Code subroutine read_equilibrium !+ Reads in the interpolation grid, plasma parameters, and fields !+ and stores the quantities in [[libfida:inter_grid]] and [[libfida:equil]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 2 ) :: dims integer :: impc integer :: error integer , dimension (:,:), allocatable :: p_mask , f_mask integer :: iz , ir !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % equilibrium_file , H5F_ACC_RDONLY_F , fid , error ) !!Open PLASMA group call h5gopen_f ( fid , \"/plasma\" , gid , error ) !!Read in interpolation grid call h5ltread_dataset_int_scalar_f ( gid , \"/plasma/nr\" , inter_grid % nr , error ) call h5ltread_dataset_int_scalar_f ( gid , \"/plasma/nz\" , inter_grid % nz , error ) allocate ( inter_grid % r ( inter_grid % nr ), inter_grid % z ( inter_grid % nz )) allocate ( inter_grid % r2d ( inter_grid % nr , inter_grid % nz )) allocate ( inter_grid % z2d ( inter_grid % nr , inter_grid % nz )) allocate ( p_mask ( inter_grid % nr , inter_grid % nz )) allocate ( f_mask ( inter_grid % nr , inter_grid % nz )) dims = [ inter_grid % nr , inter_grid % nz ] call h5ltread_dataset_double_f ( gid , \"/plasma/r\" , inter_grid % r , dims ( 1 : 1 ), error ) call h5ltread_dataset_double_f ( gid , \"/plasma/z\" , inter_grid % z , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( gid , \"/plasma/r2d\" , inter_grid % r2d , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/z2d\" , inter_grid % z2d , dims , error ) inter_grid % dr = abs ( inter_grid % r ( 2 ) - inter_grid % r ( 1 )) inter_grid % dz = abs ( inter_grid % z ( 2 ) - inter_grid % z ( 1 )) inter_grid % da = inter_grid % dr * inter_grid % dz if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Interpolation grid settings ----' write ( * , '(T2,\"Nr: \",i3)' ) inter_grid % nr write ( * , '(T2,\"Nz: \",i3)' ) inter_grid % nz write ( * , '(T2,\"dA: \", f5.2,\" [cm&#94;2]\")' ) inter_grid % da write ( * , * ) '' endif !!Read in plasma parameters allocate ( equil % plasma ( inter_grid % nr , inter_grid % nz )) call h5ltread_dataset_double_f ( gid , \"/plasma/dene\" , equil % plasma % dene , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/te\" , equil % plasma % te , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/ti\" , equil % plasma % ti , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/zeff\" , equil % plasma % zeff , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vr\" , equil % plasma % vr , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vt\" , equil % plasma % vt , dims , error ) call h5ltread_dataset_double_f ( gid , \"/plasma/vz\" , equil % plasma % vz , dims , error ) call h5ltread_dataset_int_f ( gid , \"/plasma/mask\" , p_mask , dims , error ) impc = inputs % impurity_charge where ( equil % plasma % zeff . lt . 1.0 ) equil % plasma % zeff = 1 endwhere where ( equil % plasma % zeff . gt . impc ) equil % plasma % zeff = impc endwhere where ( equil % plasma % dene . lt . 0.0 ) equil % plasma % dene = 0.0 endwhere where ( equil % plasma % te . lt . 0.0 ) equil % plasma % te = 0.0 endwhere where ( equil % plasma % ti . lt . 0.0 ) equil % plasma % ti = 0.0 endwhere equil % plasma % denimp = (( equil % plasma % zeff - 1.d0 ) / ( impc * ( impc - 1.d0 ))) * equil % plasma % dene equil % plasma % denp = equil % plasma % dene - impc * equil % plasma % denimp !!Close PLASMA group call h5gclose_f ( gid , error ) !!Open FIELDS group call h5gopen_f ( fid , \"/fields\" , gid , error ) allocate ( equil % fields ( inter_grid % nr , inter_grid % nz )) !!Read in electromagnetic fields call h5ltread_dataset_double_f ( gid , \"/fields/br\" , equil % fields % br , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/bt\" , equil % fields % bt , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/bz\" , equil % fields % bz , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/er\" , equil % fields % er , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/et\" , equil % fields % et , dims , error ) call h5ltread_dataset_double_f ( gid , \"/fields/ez\" , equil % fields % ez , dims , error ) call h5ltread_dataset_int_f ( gid , \"/fields/mask\" , f_mask , dims , error ) !!Calculate B field derivatives call deriv ( inter_grid % r , inter_grid % z , equil % fields % br , equil % fields % dbr_dr , equil % fields % dbr_dz ) call deriv ( inter_grid % r , inter_grid % z , equil % fields % bt , equil % fields % dbt_dr , equil % fields % dbt_dz ) call deriv ( inter_grid % r , inter_grid % z , equil % fields % bz , equil % fields % dbz_dr , equil % fields % dbz_dz ) !!Close FIELDS group call h5gclose_f ( gid , error ) !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) allocate ( equil % mask ( inter_grid % nr , inter_grid % nz )) equil % mask = 0.d0 where (( p_mask . eq . 1 ). and .( f_mask . eq . 1 )) equil % mask = 1.d0 end subroutine read_equilibrium","tags":"","loc":"proc/read_equilibrium.html","title":"read_equilibrium – FIDASIM"},{"text":"public subroutine read_f(fid, error) Reads in the fast-ion distribution function and stores the quantities in fbm Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: fid HDF5 file ID integer, intent(out) :: error Error code Calls proc~~read_f~~CallsGraph proc~read_f read_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_f->proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_f->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~read_f~~CalledByGraph proc~read_f read_f proc~read_distribution read_distribution proc~read_distribution->proc~read_f program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code read_f Source Code subroutine read_f ( fid , error ) !+ Reads in the fast-ion distribution function and stores the quantities in [[libfida:fbm]] integer ( HID_T ), intent ( inout ) :: fid !+ HDF5 file ID integer , intent ( out ) :: error !+ Error code integer ( HSIZE_T ), dimension ( 4 ) :: dims real ( Float64 ) :: dummy ( 1 ) integer :: ir if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Fast-ion distribution settings ----' endif call h5ltread_dataset_int_scalar_f ( fid , \"/nenergy\" , fbm % nenergy , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/npitch\" , fbm % npitch , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/nr\" , fbm % nr , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/nz\" , fbm % nz , error ) if (( fbm % nr . ne . inter_grid % nr ). or .( fbm % nz . ne . inter_grid % nz )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"READ_F: Distribution file has incompatable grid dimensions\" endif stop endif allocate ( fbm % energy ( fbm % nenergy ), fbm % pitch ( fbm % npitch ), fbm % r ( fbm % nr ), fbm % z ( fbm % nz )) allocate ( fbm % denf ( fbm % nr , fbm % nz )) allocate ( fbm % f ( fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz )) dims = [ fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz ] call h5ltread_dataset_double_f ( fid , \"/energy\" , fbm % energy , dims ( 1 : 1 ), error ) call h5ltread_dataset_double_f ( fid , \"/pitch\" , fbm % pitch , dims ( 2 : 2 ), error ) call h5ltread_dataset_double_f ( fid , \"/r\" , fbm % r , dims ( 3 : 3 ), error ) call h5ltread_dataset_double_f ( fid , \"/z\" , fbm % z , dims ( 4 : 4 ), error ) call h5ltread_dataset_double_f ( fid , \"/denf\" , fbm % denf , dims ( 3 : 4 ), error ) call h5ltread_dataset_double_f ( fid , \"/f\" , fbm % f , dims , error ) equil % plasma % denf = fbm % denf fbm % dE = abs ( fbm % energy ( 2 ) - fbm % energy ( 1 )) fbm % dp = abs ( fbm % pitch ( 2 ) - fbm % pitch ( 1 )) fbm % dr = abs ( fbm % r ( 2 ) - fbm % r ( 1 )) fbm % dz = abs ( fbm % z ( 2 ) - fbm % z ( 1 )) dummy = minval ( fbm % energy ) fbm % emin = dummy ( 1 ) dummy = maxval ( fbm % energy ) fbm % emax = dummy ( 1 ) fbm % e_range = fbm % emax - fbm % emin dummy = minval ( fbm % pitch ) fbm % pmin = dummy ( 1 ) dummy = maxval ( fbm % pitch ) fbm % pmax = dummy ( 1 ) fbm % p_range = fbm % pmax - fbm % pmin do ir = 1 , fbm % nr fbm % n_tot = fbm % n_tot + 2 * pi * fbm % dr * fbm % dz * sum ( fbm % denf ( ir ,:)) * fbm % r ( ir ) enddo if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Distribution type: \",a)' ) \"Fast-ion Density Function F(energy,pitch,R,Z)\" write ( * , '(T2,\"Nenergy = \",i3)' ), fbm % nenergy write ( * , '(T2,\"Npitch  = \",i3)' ), fbm % npitch write ( * , '(T2,\"Energy range = [\",f5.2,\",\",f6.2,\"]\")' ), fbm % emin , fbm % emax write ( * , '(T2,\"Pitch  range = [\",f5.2,\",\",f5.2,\"]\")' ), fbm % pmin , fbm % pmax write ( * , '(T2,\"Ntotal = \",ES10.3)' ) fbm % n_tot write ( * , * ) '' endif end subroutine read_f","tags":"","loc":"proc/read_f.html","title":"read_f – FIDASIM"},{"text":"public subroutine read_mc(fid, error) Reads in a MC particle fast-ion distribution and puts them in particles Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: fid HDF5 file ID integer, intent(out) :: error Error code Calls proc~~read_mc~~CallsGraph proc~read_mc read_mc proc~in_plasma in_plasma proc~read_mc->proc~in_plasma proc~uvw_to_xyz uvw_to_xyz proc~read_mc->proc~uvw_to_xyz h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_mc->h5ltread_dataset_double_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_mc->proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_mc->h5ltread_dataset_int_f proc~circle_grid_intersect circle_grid_intersect proc~read_mc->proc~circle_grid_intersect proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~in_grid in_grid proc~circle_grid_intersect->proc~in_grid proc~grid_intersect grid_intersect proc~circle_grid_intersect->proc~grid_intersect proc~approx_eq approx_eq proc~circle_grid_intersect->proc~approx_eq proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~approx_ge approx_ge proc~in_grid->proc~approx_ge proc~approx_le approx_le proc~in_grid->proc~approx_le proc~approx_ge->proc~approx_eq proc~approx_le->proc~approx_eq var panprocread_mcCallsGraph = svgPanZoom('#procread_mcCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~read_mc~~CalledByGraph proc~read_mc read_mc proc~read_distribution read_distribution proc~read_distribution->proc~read_mc program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code read_mc Source Code subroutine read_mc ( fid , error ) !+ Reads in a MC particle fast-ion distribution and puts them in [[libfida:particles]] integer ( HID_T ), intent ( inout ) :: fid !+ HDF5 file ID integer , intent ( out ) :: error !+ Error code integer ( HSIZE_T ), dimension ( 1 ) :: dims integer ( Int32 ) :: i , j , ii , ir , iz real ( Float64 ) :: phi , phi_enter , phi_exit , delta_phi real ( Float64 ), dimension ( 3 ) :: uvw , ri , vi , e1_xyz , e2_xyz , C_xyz , dum integer ( Int32 ), dimension ( 1 ) :: minpos real ( Float64 ), dimension (:), allocatable :: weight type ( LocalEMFields ) :: fields integer :: cnt , num logical :: inp character ( len = 32 ) :: dist_type_name = '' if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- Fast-ion distribution settings ----' endif call h5ltread_dataset_int_scalar_f ( fid , \"/nparticle\" , particles % nparticle , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/nclass\" , particles % nclass , error ) !!ALLOCATE SPACE allocate ( particles % fast_ion ( particles % nparticle )) allocate ( weight ( particles % nparticle )) dims ( 1 ) = particles % nparticle call h5ltread_dataset_double_f ( fid , \"/r\" , particles % fast_ion % r , dims , error ) call h5ltread_dataset_double_f ( fid , \"/z\" , particles % fast_ion % z , dims , error ) call h5ltread_dataset_int_f ( fid , \"/class\" , particles % fast_ion % class , dims , error ) if ( any ( particles % fast_ion % class . gt . particles % nclass )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_MC: Orbit class ID greater then the number of classes' endif stop endif if ( inputs % dist_type . eq . 2 ) then dist_type_name = \"Guiding Center Monte Carlo\" call h5ltread_dataset_double_f ( fid , \"/energy\" , particles % fast_ion % energy , dims , error ) call h5ltread_dataset_double_f ( fid , \"/pitch\" , particles % fast_ion % pitch , dims , error ) particles % fast_ion % vabs = sqrt ( particles % fast_ion % energy / ( v2_to_E_per_amu * inputs % ab )) else dist_type_name = \"Full Orbit Monte Carlo\" call h5ltread_dataset_double_f ( fid , \"/vr\" , particles % fast_ion % vr , dims , error ) call h5ltread_dataset_double_f ( fid , \"/vt\" , particles % fast_ion % vt , dims , error ) call h5ltread_dataset_double_f ( fid , \"/vz\" , particles % fast_ion % vz , dims , error ) particles % fast_ion % vabs = sqrt ( particles % fast_ion % vr ** 2 + & particles % fast_ion % vt ** 2 + & particles % fast_ion % vz ** 2 ) particles % fast_ion % energy = v2_to_E_per_amu * inputs % ab * particles % fast_ion % vabs ** 2 endif call h5ltread_dataset_double_f ( fid , \"/weight\" , weight , dims , error ) cnt = 0 e1_xyz = matmul ( beam_grid % inv_basis ,[ 1.0 , 0.0 , 0.0 ]) e2_xyz = matmul ( beam_grid % inv_basis ,[ 0.0 , 1.0 , 0.0 ]) !$OMP PARALLEL DO schedule(guided) private(i,ii,j,ir,iz,minpos,fields,uvw,phi,ri,vi, & !$OMP& delta_phi,phi_enter,phi_exit,C_xyz) particle_loop : do i = 1 , particles % nparticle if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt / real ( particles % nparticle ) * 100 , char ( 13 ) endif uvw = [ particles % fast_ion ( i )% r , 0.d0 , particles % fast_ion ( i )% z ] call in_plasma ( uvw , inp , machine_coords = . True .) if (. not . inp ) cycle particle_loop phi_enter = 0.0 phi_exit = 0.0 dum = [ 0.d0 , 0.d0 , particles % fast_ion ( i )% z ] call uvw_to_xyz ( dum , C_xyz ) call circle_grid_intersect ( C_xyz , e1_xyz , e2_xyz , particles % fast_ion ( i )% r , phi_enter , phi_exit ) delta_phi = phi_exit - phi_enter if ( delta_phi . gt . 0 ) then particles % fast_ion ( i )% cross_grid = . True . else particles % fast_ion ( i )% cross_grid = . False . delta_phi = 2 * pi endif particles % fast_ion ( i )% phi_enter = phi_enter particles % fast_ion ( i )% delta_phi = delta_phi particles % fast_ion ( i )% weight = weight ( i ) * ( delta_phi / ( 2 * pi )) / beam_grid % dv minpos = minloc ( abs ( inter_grid % r - particles % fast_ion ( i )% r )) ir = minpos ( 1 ) minpos = minloc ( abs ( inter_grid % z - particles % fast_ion ( i )% z )) iz = minpos ( 1 ) !$OMP CRITICAL(mc_denf) equil % plasma ( ir , iz )% denf = equil % plasma ( ir , iz )% denf + weight ( i ) / & ( 2 * pi * particles % fast_ion ( i )% r * inter_grid % da ) !$OMP END CRITICAL(mc_denf) cnt = cnt + 1 enddo particle_loop !$OMP END PARALLEL DO num = count ( particles % fast_ion % cross_grid ) if ( num . le . 0 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_MC: No mc particles in beam grid' endif stop endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Distribution type: \",a)' ) dist_type_name write ( * , '(T2,\"Number of mc particles: \",i9)' ) particles % nparticle write ( * , '(T2,\"Number of orbit classes: \",i6)' ) particles % nclass write ( * , * ) '' endif end subroutine read_mc","tags":"","loc":"proc/read_mc.html","title":"read_mc – FIDASIM"},{"text":"public subroutine read_distribution() Reads in the fast-ion distribution Arguments None Calls proc~~read_distribution~~CallsGraph proc~read_distribution read_distribution proc~read_f read_f proc~read_distribution->proc~read_f h5fclose_f h5fclose_f proc~read_distribution->h5fclose_f h5close_f h5close_f proc~read_distribution->h5close_f proc~read_mc read_mc proc~read_distribution->proc~read_mc h5fopen_f h5fopen_f proc~read_distribution->h5fopen_f h5open_f h5open_f proc~read_distribution->h5open_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_distribution->proc~h5ltread_dataset_int_scalar_f proc~read_f->proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_f->h5ltread_dataset_double_f proc~read_mc->proc~h5ltread_dataset_int_scalar_f proc~read_mc->h5ltread_dataset_double_f proc~in_plasma in_plasma proc~read_mc->proc~in_plasma proc~uvw_to_xyz uvw_to_xyz proc~read_mc->proc~uvw_to_xyz h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_mc->h5ltread_dataset_int_f proc~circle_grid_intersect circle_grid_intersect proc~read_mc->proc~circle_grid_intersect proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~in_grid in_grid proc~circle_grid_intersect->proc~in_grid proc~grid_intersect grid_intersect proc~circle_grid_intersect->proc~grid_intersect proc~approx_eq approx_eq proc~circle_grid_intersect->proc~approx_eq proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~approx_ge approx_ge proc~in_grid->proc~approx_ge proc~approx_le approx_le proc~in_grid->proc~approx_le proc~approx_ge->proc~approx_eq proc~approx_le->proc~approx_eq var panprocread_distributionCallsGraph = svgPanZoom('#procread_distributionCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~read_distribution~~CalledByGraph proc~read_distribution read_distribution program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code read_distribution Source Code subroutine read_distribution !+ Reads in the fast-ion distribution integer ( HID_T ) :: fid integer :: error !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % distribution_file , H5F_ACC_RDONLY_F , fid , error ) !!Get distribution type call h5ltread_dataset_int_scalar_f ( fid , \"/type\" , inputs % dist_type , error ) if ( inputs % dist_type . eq . 1 ) then call read_f ( fid , error ) else !2 or 3 call read_mc ( fid , error ) endif !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) end subroutine read_distribution","tags":"","loc":"proc/read_distribution.html","title":"read_distribution – FIDASIM"},{"text":"public subroutine read_atomic_cross(fid, grp, cross) Reads in a cross section table from file\n and puts it into a AtomicCrossSection type Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid HDF5 file ID character(len=*), intent(in) :: grp HDF5 group to read from type( AtomicCrossSection ), intent(inout) :: cross Atomic cross section Calls proc~~read_atomic_cross~~CallsGraph proc~read_atomic_cross read_atomic_cross h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_atomic_cross->h5ltread_dataset_double_f h5ltpath_valid_f h5ltpath_valid_f proc~read_atomic_cross->h5ltpath_valid_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_atomic_cross->proc~h5ltread_dataset_double_scalar_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_atomic_cross->proc~h5ltread_dataset_int_scalar_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~read_atomic_cross~~CalledByGraph proc~read_atomic_cross read_atomic_cross proc~read_tables read_tables proc~read_tables->proc~read_atomic_cross program~fidasim fidasim program~fidasim->proc~read_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code read_atomic_cross Source Code subroutine read_atomic_cross ( fid , grp , cross ) !+ Reads in a cross section table from file !+ and puts it into a [[AtomicCrossSection]] type integer ( HID_T ), intent ( in ) :: fid !+ HDF5 file ID character ( len =* ), intent ( in ) :: grp !+ HDF5 group to read from type ( AtomicCrossSection ), intent ( inout ) :: cross !+ Atomic cross section integer ( HSIZE_T ), dimension ( 3 ) :: dim3 real ( Float64 ) :: emin , emax , rmin integer :: i , n_max , m_max , error real ( Float64 ), dimension (:,:,:), allocatable :: dummy3 logical :: path_valid call h5ltpath_valid_f ( fid , grp , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_ATOMIC_CROSS: Unknown atomic interaction: ' , trim ( grp ) endif stop endif call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , cross % nenergy , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/m_max\" , m_max , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , cross % dlogE , error ) cross % logemin = log10 ( emin ) cross % logemax = log10 ( emax ) allocate ( dummy3 ( n_max , m_max , cross % nenergy )) allocate ( cross % log_cross ( cross % m_max , cross % n_max , cross % nenergy )) dim3 = [ n_max , m_max , tables % H_H_cx % nenergy ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy3 , dim3 , error ) rmin = minval ( dummy3 , dummy3 . gt . 0.d0 ) where ( dummy3 . le . 0.0 ) dummy3 = 0.9 * rmin end where cross % minlog_cross = log10 ( rmin ) do i = 1 , cross % nenergy cross % log_cross (:,:, i ) = log10 ( transpose ( dummy3 ( 1 : nlevs , 1 : nlevs , i ))) enddo deallocate ( dummy3 ) end subroutine read_atomic_cross","tags":"","loc":"proc/read_atomic_cross.html","title":"read_atomic_cross – FIDASIM"},{"text":"public subroutine read_atomic_rates(fid, grp, b_amu, t_amu, rates) Reads in a atomic reaction rates table from file\n and puts it into a AtomicRates type Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid HDF5 file ID character(len=*), intent(in) :: grp HDF5 group to read from real(kind=Float64), intent(in), dimension(2) :: b_amu Atomic masses of \"beam\" species (beam ion and thermal ion) real(kind=Float64), intent(in) :: t_amu Atomic mass of \"target\" species (thermal ion) type( AtomicRates ), intent(inout) :: rates Atomic reaction rates Calls proc~~read_atomic_rates~~CallsGraph proc~read_atomic_rates read_atomic_rates h5ltget_dataset_ndims_f h5ltget_dataset_ndims_f proc~read_atomic_rates->h5ltget_dataset_ndims_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_atomic_rates->h5ltread_dataset_double_f h5ltpath_valid_f h5ltpath_valid_f proc~read_atomic_rates->h5ltpath_valid_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_atomic_rates->proc~h5ltread_dataset_double_scalar_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_atomic_rates->proc~h5ltread_dataset_int_scalar_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~read_atomic_rates~~CalledByGraph proc~read_atomic_rates read_atomic_rates proc~read_tables read_tables proc~read_tables->proc~read_atomic_rates program~fidasim fidasim program~fidasim->proc~read_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code read_atomic_rates Source Code subroutine read_atomic_rates ( fid , grp , b_amu , t_amu , rates ) !+ Reads in a atomic reaction rates table from file !+ and puts it into a [[AtomicRates]] type integer ( HID_T ), intent ( in ) :: fid !+ HDF5 file ID character ( len =* ), intent ( in ) :: grp !+ HDF5 group to read from real ( Float64 ), dimension ( 2 ), intent ( in ) :: b_amu !+ Atomic masses of \"beam\" species (beam ion and thermal ion) real ( Float64 ), intent ( in ) :: t_amu !+ Atomic mass of \"target\" species (thermal ion) type ( AtomicRates ), intent ( inout ) :: rates !+ Atomic reaction rates integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 logical :: path_valid integer :: i , j , n , n_max , m_max , error integer :: n_bt_amu , tt_ind , bt_ind , drank real ( Float64 ) :: emin , emax , tmin , tmax , rmin real ( Float64 ) :: bt_min , tt_min , tt_dum , bt_dum real ( Float64 ), dimension ( 2 ) :: bt_amu , tt_amu real ( Float64 ), dimension (:,:), allocatable :: dummy2 real ( Float64 ), dimension (:,:,:,:), allocatable :: dummy4 real ( Float64 ), dimension (:,:,:,:,:), allocatable :: dummy5 call h5ltpath_valid_f ( fid , grp , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_ATOMIC_RATES: Unknown atomic interaction: ' , trim ( grp ) endif stop endif call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_bt_amu\" , n_bt_amu , error ) allocate ( dummy2 ( 2 , n_bt_amu )) dim2 = [ 2 , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/bt_amu\" , dummy2 , dim2 , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/m_max\" , m_max , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , rates % nenergy , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , rates % dlogE , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/ntemp\" , rates % ntemp , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmin\" , tmin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmax\" , tmax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogT\" , rates % dlogT , error ) rates % logemin = log10 ( emin ) rates % logemax = log10 ( emax ) rates % logtmin = log10 ( tmin ) rates % logtmax = log10 ( tmax ) bt_ind = 1 tt_ind = 1 bt_amu = [ b_amu ( 1 ), t_amu ] tt_amu = [ b_amu ( 2 ), t_amu ] bt_min = norm2 ( bt_amu - dummy2 (:, 1 )) tt_min = norm2 ( tt_amu - dummy2 (:, 1 )) do i = 2 , n_bt_amu bt_dum = norm2 ( bt_amu - dummy2 (:, i )) tt_dum = norm2 ( tt_amu - dummy2 (:, i )) if ( bt_dum . lt . bt_min ) then bt_min = bt_dum bt_ind = i endif if ( tt_dum . lt . tt_min ) then tt_min = tt_dum tt_ind = i endif enddo rates % ab ( 1 ) = dummy2 ( 1 , bt_ind ) rates % ab ( 2 ) = dummy2 ( 1 , tt_ind ) deallocate ( dummy2 ) allocate ( rates % log_pop (& rates % m_max , & rates % n_max , & rates % nenergy , & rates % ntemp , 2 )) allocate ( rates % log_depop (& rates % n_max , & rates % nenergy , & rates % ntemp , 2 )) rates % log_pop = 0.d0 rates % log_depop = 0.d0 !!Read CX call h5ltpath_valid_f ( fid , grp // \"/cx\" , . True ., path_valid , error ) if ( path_valid ) then call h5ltget_dataset_ndims_f ( fid , grp // \"/cx\" , drank , error ) if ( drank . eq . 4 ) then allocate ( dummy4 ( n_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim4 = [ n_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy4 , dim4 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = dummy4 ( n , i , j , bt_ind ) rates % log_depop ( n , i , j , 2 ) = dummy4 ( n , i , j , tt_ind ) enddo enddo enddo deallocate ( dummy4 ) endif if ( drank . eq . 5 ) then allocate ( dummy5 ( n_max , m_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim5 = [ n_max , m_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/cx\" , dummy5 , dim5 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = sum ( dummy5 ( n ,:, i , j , bt_ind )) rates % log_depop ( n , i , j , 2 ) = sum ( dummy5 ( n ,:, i , j , tt_ind )) enddo enddo enddo deallocate ( dummy5 ) endif endif !!Read ionization call h5ltpath_valid_f ( fid , grp // \"/ionization\" , . True ., path_valid , error ) if ( path_valid ) then allocate ( dummy4 ( n_max , & rates % nenergy , & rates % ntemp , n_bt_amu )) dim4 = [ n_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/ionization\" , dummy4 , dim4 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = rates % log_depop ( n , i , j , 1 ) + & dummy4 ( n , i , j , bt_ind ) rates % log_depop ( n , i , j , 2 ) = rates % log_depop ( n , i , j , 2 ) + & dummy4 ( n , i , j , tt_ind ) enddo enddo enddo deallocate ( dummy4 ) endif !!Read excitation call h5ltpath_valid_f ( fid , grp // \"/excitation\" , . True ., path_valid , error ) if ( path_valid ) then allocate ( dummy5 ( n_max , m_max ,& rates % nenergy , & rates % ntemp , n_bt_amu )) dim5 = [ n_max , m_max , rates % nenergy , rates % ntemp , n_bt_amu ] call h5ltread_dataset_double_f ( fid , grp // \"/excitation\" , dummy5 , dim5 , error ) do j = 1 , rates % ntemp do i = 1 , rates % nenergy rates % log_pop (:,:, i , j , 1 ) = transpose ( dummy5 ( 1 : nlevs , 1 : nlevs , i , j , bt_ind )) rates % log_pop (:,:, i , j , 2 ) = transpose ( dummy5 ( 1 : nlevs , 1 : nlevs , i , j , tt_ind )) do n = 1 , rates % n_max rates % log_depop ( n , i , j , 1 ) = rates % log_depop ( n , i , j , 1 ) + & sum ( dummy5 ( n ,:, i , j , bt_ind )) rates % log_depop ( n , i , j , 2 ) = rates % log_depop ( n , i , j , 2 ) + & sum ( dummy5 ( n ,:, i , j , tt_ind )) enddo enddo enddo deallocate ( dummy5 ) endif rmin = minval ( rates % log_depop , rates % log_depop . gt . 0.d0 ) where ( rates % log_depop . le . 0.d0 ) rates % log_depop = 0.9 * rmin end where rates % minlog_depop = log10 ( rmin ) rates % log_depop = log10 ( rates % log_depop ) rmin = minval ( rates % log_pop , rates % log_pop . gt . 0.d0 ) where ( rates % log_pop . le . 0.d0 ) rates % log_pop = 0.9 * rmin end where rates % minlog_pop = log10 ( rmin ) rates % log_pop = log10 ( rates % log_pop ) end subroutine read_atomic_rates","tags":"","loc":"proc/read_atomic_rates.html","title":"read_atomic_rates – FIDASIM"},{"text":"public subroutine read_nuclear_rates(fid, grp, rates) Reads in a nuclear reaction rates table from file\n and puts it into a NuclearRates type Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid HDF5 file ID character(len=*), intent(in) :: grp HDF5 group to read from type( NuclearRates ), intent(inout) :: rates Atomic reaction rates Calls proc~~read_nuclear_rates~~CallsGraph proc~read_nuclear_rates read_nuclear_rates h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_nuclear_rates->h5ltread_dataset_double_f h5ltpath_valid_f h5ltpath_valid_f proc~read_nuclear_rates->h5ltpath_valid_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_nuclear_rates->proc~h5ltread_dataset_double_scalar_f proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_nuclear_rates->proc~h5ltread_dataset_int_scalar_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~read_nuclear_rates~~CalledByGraph proc~read_nuclear_rates read_nuclear_rates proc~read_tables read_tables proc~read_tables->proc~read_nuclear_rates program~fidasim fidasim program~fidasim->proc~read_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code read_nuclear_rates Source Code subroutine read_nuclear_rates ( fid , grp , rates ) !+ Reads in a nuclear reaction rates table from file !+ and puts it into a [[NuclearRates]] type integer ( HID_T ), intent ( in ) :: fid !+ HDF5 file ID character ( len =* ), intent ( in ) :: grp !+ HDF5 group to read from type ( NuclearRates ), intent ( inout ) :: rates !+ Atomic reaction rates integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 logical :: path_valid integer :: i , j , error real ( Float64 ) :: emin , emax , tmin , tmax , rmin call h5ltpath_valid_f ( fid , grp , . True ., path_valid , error ) if (. not . path_valid ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_NUCLEAR_RATES: Unknown nuclear interaction: ' , trim ( grp ) write ( * , '(a)' ) 'Continuing without neutron calculation' endif inputs % calc_neutron = 0 return endif call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nbranch\" , rates % nbranch , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/nenergy\" , rates % nenergy , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emin\" , emin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/emax\" , emax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogE\" , rates % dlogE , error ) call h5ltread_dataset_int_scalar_f ( fid , grp // \"/ntemp\" , rates % ntemp , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmin\" , tmin , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/tmax\" , tmax , error ) call h5ltread_dataset_double_scalar_f ( fid , grp // \"/dlogT\" , rates % dlogT , error ) rates % logemin = log10 ( emin ) rates % logemax = log10 ( emax ) rates % logtmin = log10 ( tmin ) rates % logtmax = log10 ( tmax ) allocate ( rates % log_rate ( rates % nenergy , & rates % ntemp , & rates % nbranch )) dim1 = [ 2 ] call h5ltread_dataset_double_f ( fid , grp // \"/bt_amu\" , rates % bt_amu , dim1 , error ) if ( abs ( inputs % ab - rates % bt_amu ( 1 )). gt . 0.2 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,f6.3,a,f6.3,a)' ) 'READ_NUCLEAR_RATES: Unexpected beam species mass. Expected ' ,& rates % bt_amu ( 1 ), ' amu got ' , inputs % ab , ' amu' endif endif if ( abs ( inputs % ai - rates % bt_amu ( 2 )). gt . 0.2 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a,f6.3,a,f6.3,a)' ) 'READ_NUCLEAR_RATES: Unexpected thermal species mass. Expected ' ,& rates % bt_amu ( 2 ), ' amu got ' , inputs % ai , ' amu' endif endif dim3 = [ rates % nenergy , rates % ntemp , rates % nbranch ] call h5ltread_dataset_double_f ( fid , grp // \"/fusion\" , rates % log_rate , dim3 , error ) rmin = minval ( rates % log_rate , rates % log_rate . gt . 0.d0 ) where ( rates % log_rate . le . 0.d0 ) rates % log_rate = 0.9 * rmin end where rates % minlog_rate = log10 ( rmin ) rates % log_rate = log10 ( rates % log_rate ) end subroutine read_nuclear_rates","tags":"","loc":"proc/read_nuclear_rates.html","title":"read_nuclear_rates – FIDASIM"},{"text":"public subroutine read_tables() Reads in atomic tables from file and stores them in tables Arguments None Calls proc~~read_tables~~CallsGraph proc~read_tables read_tables proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_tables->proc~h5ltread_dataset_int_scalar_f h5close_f h5close_f proc~read_tables->h5close_f h5fclose_f h5fclose_f proc~read_tables->h5fclose_f proc~read_atomic_cross read_atomic_cross proc~read_tables->proc~read_atomic_cross h5open_f h5open_f proc~read_tables->h5open_f proc~read_nuclear_rates read_nuclear_rates proc~read_tables->proc~read_nuclear_rates h5fopen_f h5fopen_f proc~read_tables->h5fopen_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_tables->h5ltread_dataset_double_f proc~read_atomic_rates read_atomic_rates proc~read_tables->proc~read_atomic_rates h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~read_atomic_cross->proc~h5ltread_dataset_int_scalar_f proc~read_atomic_cross->h5ltread_dataset_double_f h5ltpath_valid_f h5ltpath_valid_f proc~read_atomic_cross->h5ltpath_valid_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_atomic_cross->proc~h5ltread_dataset_double_scalar_f proc~read_nuclear_rates->proc~h5ltread_dataset_int_scalar_f proc~read_nuclear_rates->h5ltread_dataset_double_f proc~read_nuclear_rates->h5ltpath_valid_f proc~read_nuclear_rates->proc~h5ltread_dataset_double_scalar_f proc~read_atomic_rates->proc~h5ltread_dataset_int_scalar_f proc~read_atomic_rates->h5ltread_dataset_double_f proc~read_atomic_rates->h5ltpath_valid_f proc~read_atomic_rates->proc~h5ltread_dataset_double_scalar_f h5ltget_dataset_ndims_f h5ltget_dataset_ndims_f proc~read_atomic_rates->h5ltget_dataset_ndims_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~read_tables~~CalledByGraph proc~read_tables read_tables program~fidasim fidasim program~fidasim->proc~read_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code read_tables Source Code subroutine read_tables !+ Reads in atomic tables from file and stores them in [[libfida:tables]] integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: error integer :: n_max , m_max character ( len = 4 ) :: impname real ( Float64 ) :: imp_amu real ( Float64 ), dimension ( 2 ) :: b_amu real ( Float64 ), dimension (:,:), allocatable :: dummy2 if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- Atomic tables settings ----\" endif !!Initialize HDF5 interface call h5open_f ( error ) !!Open HDF5 file call h5fopen_f ( inputs % tables_file , H5F_ACC_RDONLY_F , fid , error ) !!Read Hydrogen-Hydrogen CX Cross Sections call read_atomic_cross ( fid , \"/cross/H_H\" , tables % H_H_cx ) !!Read Hydrogen-Hydrogen Rates b_amu = [ inputs % ab , inputs % ai ] call read_atomic_rates ( fid , \"/rates/H_H\" , b_amu , inputs % ai , tables % H_H ) inputs % ab = tables % H_H % ab ( 1 ) inputs % ai = tables % H_H % ab ( 2 ) !!Read Hydrogen-Electron Rates call read_atomic_rates ( fid , \"/rates/H_e\" , b_amu , e_amu , tables % H_e ) !!Read Hydrogen-Impurity rates impname = '' select case ( inputs % impurity_charge ) case ( 5 ) impname = \"B5\" imp_amu = B5_amu case ( 6 ) impname = \"C6\" imp_amu = C6_amu case DEFAULT impname = \"Aq\" imp_amu = 2.d0 * inputs % impurity_charge end select call read_atomic_rates ( fid , \"/rates/H_\" // trim ( adjustl ( impname )), b_amu , imp_amu , tables % H_Aq ) !!Read Einstein coefficients call h5ltread_dataset_int_scalar_f ( fid , \"/rates/spontaneous/n_max\" , n_max , error ) call h5ltread_dataset_int_scalar_f ( fid , \"/rates/spontaneous/m_max\" , m_max , error ) allocate ( dummy2 ( n_max , m_max )) dim2 = [ n_max , m_max ] call h5ltread_dataset_double_f ( fid , \"/rates/spontaneous/einstein\" , dummy2 , dim2 , error ) tables % einstein (:,:) = transpose ( dummy2 ( 1 : nlevs , 1 : nlevs )) deallocate ( dummy2 ) !!Read nuclear Deuterium-Deuterium rates call read_nuclear_rates ( fid , \"/rates/D_D\" , tables % D_D ) !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Maximum n/m: \",i2)' ) nlevs write ( * , '(T2,\"Beam/Fast-ion mass: \",f6.3,\" [amu]\")' ) inputs % ab write ( * , '(T2,\"Thermal/Bulk-ion mass: \",f6.3,\" [amu]\")' ) inputs % ai write ( * , '(T2,\"Impurity mass: \",f6.3,\" [amu]\")' ) imp_amu write ( * , * ) '' endif end subroutine read_tables","tags":"","loc":"proc/read_tables.html","title":"read_tables – FIDASIM"},{"text":"public subroutine write_beam_grid(id, error) Write beam_grid to an HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file ID integer, intent(out) :: error Error code Calls proc~~write_beam_grid~~CallsGraph proc~write_beam_grid write_beam_grid h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_beam_grid->h5ltset_attribute_string_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_beam_grid->h5ltmake_dataset_int_f proc~xyz_to_uvw xyz_to_uvw proc~write_beam_grid->proc~xyz_to_uvw interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_beam_gridCallsGraph = svgPanZoom('#procwrite_beam_gridCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_beam_grid~~CalledByGraph proc~write_beam_grid write_beam_grid proc~write_birth_profile write_birth_profile proc~write_birth_profile->proc~write_beam_grid proc~write_neutrals write_neutrals proc~write_neutrals->proc~write_beam_grid proc~write_npa_weights write_npa_weights proc~write_npa_weights->proc~write_beam_grid proc~write_dcx write_dcx proc~write_dcx->proc~write_beam_grid program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_weights->proc~write_npa_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_beam_grid Source Code subroutine write_beam_grid ( id , error ) !+ Write [[libfida:beam_grid]] to an HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file ID integer , intent ( out ) :: error !+ Error code integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 3 ) :: dims real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: u_grid , v_grid , w_grid real ( Float64 ) :: xyz ( 3 ), uvw ( 3 ) integer :: i , j , k !Create uvw grids do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx xyz = [ beam_grid % xc ( i ), & beam_grid % yc ( j ), & beam_grid % zc ( k )] call xyz_to_uvw ( xyz , uvw ) u_grid ( i , j , k ) = uvw ( 1 ) v_grid ( i , j , k ) = uvw ( 2 ) w_grid ( i , j , k ) = uvw ( 3 ) enddo enddo enddo !Create grid group call h5gcreate_f ( id , \"grid\" , gid , error ) !Write variables dims ( 1 ) = 1 call h5ltmake_dataset_int_f ( gid , \"nx\" , 0 , dims ( 1 : 1 ), [ beam_grid % nx ], error ) call h5ltmake_dataset_int_f ( gid , \"ny\" , 0 , dims ( 1 : 1 ), [ beam_grid % ny ], error ) call h5ltmake_dataset_int_f ( gid , \"nz\" , 0 , dims ( 1 : 1 ), [ beam_grid % nz ], error ) dims = [ beam_grid % nx , beam_grid % ny , beam_grid % nz ] call h5ltmake_compressed_dataset_double_f ( gid , \"x\" , 1 , dims ( 1 : 1 ), beam_grid % xc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"y\" , 1 , dims ( 2 : 2 ), beam_grid % yc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"z\" , 1 , dims ( 3 : 3 ), beam_grid % zc , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"x_grid\" , 3 , dims , u_grid , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"y_grid\" , 3 , dims , v_grid , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"z_grid\" , 3 , dims , w_grid , error ) !Write attributes call h5ltset_attribute_string_f ( gid , \"nx\" , \"description\" , & \"Number of cells in the X direction\" , error ) call h5ltset_attribute_string_f ( gid , \"ny\" , \"description\" , & \"Number of cells in the Y direction\" , error ) call h5ltset_attribute_string_f ( gid , \"nz\" , \"description\" , & \"Number of cells in the Z direction\" , error ) call h5ltset_attribute_string_f ( gid , \"x\" , \"description\" , & \"X value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"x\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"y\" , \"description\" , & \"Y value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"y\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"z\" , \"description\" , & \"Z value of cell center in beam grid coordinates\" , error ) call h5ltset_attribute_string_f ( gid , \"z\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"x_grid\" , \"description\" , & \"X value of cell center in machine coordinates: x_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"x_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"y_grid\" , \"description\" , & \"Y value of cell center in machine coordinates: y_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"y_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"z_grid\" , \"description\" , & \"Z value of cell center in machine coordinates: z_grid(x,y,z)\" , error ) call h5ltset_attribute_string_f ( gid , \"z_grid\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( id , \"grid\" , \"coordinate_system\" , & \"Right-handed cartesian\" , error ) !Close grid group call h5gclose_f ( gid , error ) end subroutine write_beam_grid","tags":"","loc":"proc/write_beam_grid.html","title":"write_beam_grid – FIDASIM"},{"text":"public subroutine write_birth_profile() Writes birth to a HDF5 file Arguments None Calls proc~~write_birth_profile~~CallsGraph proc~write_birth_profile write_birth_profile interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f h5close_f h5close_f proc~write_birth_profile->h5close_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_birth_profile->h5ltset_attribute_string_f h5open_f h5open_f proc~write_birth_profile->h5open_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~xyz_to_uvw xyz_to_uvw proc~write_birth_profile->proc~xyz_to_uvw interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_birth_profile->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_birth_profile->h5ltmake_dataset_int_f h5fcreate_f h5fcreate_f proc~write_birth_profile->h5fcreate_f proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 proc~write_beam_grid->h5ltset_attribute_string_f proc~write_beam_grid->proc~xyz_to_uvw proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->h5ltmake_dataset_int_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_int_f_1->h5ltmake_dataset_int_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_1->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_deflate_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_1->h5screate_simple_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f var panprocwrite_birth_profileCallsGraph = svgPanZoom('#procwrite_birth_profileCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_birth_profile~~CalledByGraph proc~write_birth_profile write_birth_profile program~fidasim fidasim program~fidasim->proc~write_birth_profile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_birth_profile Source Code subroutine write_birth_profile !+ Writes [[libfida:birth]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error , i , npart character ( charlim ) :: filename real ( Float64 ), dimension (:,:), allocatable :: ri real ( Float64 ), dimension (:,:), allocatable :: vi real ( Float64 ), dimension ( 3 ) :: xyz , uvw , v_uvw npart = birth % cnt - 1 allocate ( ri ( 3 , npart )) allocate ( vi ( 3 , npart )) do i = 1 , npart ! Convert position to rzphi xyz = birth % ri (:, i ) call xyz_to_uvw ( xyz , uvw ) ri ( 1 , i ) = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) ri ( 2 , i ) = uvw ( 3 ) ri ( 3 , i ) = atan2 ( uvw ( 2 ), uvw ( 1 )) ! Convert velocity to rzphi v_uvw = matmul ( beam_grid % basis , birth % vi (:, i )) vi ( 1 , i ) = v_uvw ( 1 ) * cos ( ri ( 3 , i )) + v_uvw ( 2 ) * sin ( ri ( 3 , i )) vi ( 2 , i ) = v_uvw ( 3 ) vi ( 3 , i ) = - v_uvw ( 1 ) * sin ( ri ( 3 , i )) + v_uvw ( 2 ) * cos ( ri ( 3 , i )) enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_birth.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables call write_beam_grid ( fid , error ) d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/n_birth\" , 0 , d , [ npart ], error ) dim4 = shape ( birth % dens ) call h5ltmake_compressed_dataset_double_f ( fid , \"/dens\" , 4 , dim4 , birth % dens , error ) dim2 = [ 3 , npart ] call h5ltmake_compressed_dataset_double_f ( fid , \"/ri\" , 2 , dim2 , ri , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vi\" , 2 , dim2 , vi , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/ind\" , 2 , dim2 , birth % ind , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/type\" , 1 , dim2 ( 2 : 2 ), birth % neut_type , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/n_birth\" , \"description\" , & \"Number of birth mc particles deposited\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"description\" , & \"Birth density: dens(beam_component,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"units\" , & \"fast-ions/(s*cm&#94;3)\" , error ) call h5ltset_attribute_string_f ( fid , \"/ri\" , \"description\" , & \"Fast-ion birth position in R-Z-Phi: ri([r,z,phi],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/ri\" , \"units\" , \"cm, radians\" , error ) call h5ltset_attribute_string_f ( fid , \"/vi\" , \"description\" , & \"Fast-ion birth velocity in R-Z-Phi: vi([r,z,phi],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/vi\" , \"units\" , \"cm/s\" , error ) call h5ltset_attribute_string_f ( fid , \"/ind\" , \"description\" , & \"Fast-ion birth beam grid indices: ind([i,j,k],particle)\" , error ) call h5ltset_attribute_string_f ( fid , \"/type\" , \"description\" , & \"Fast-ion birth type (1=Full, 2=Half, 3=Third)\" , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"coordinate_system\" , & \"Cylindrical (R,Z,Phi)\" , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Birth density and particles calculated by FIDASIM\" , error ) !!Close file call h5fclose_f ( fid , error ) !!Close HDF5 interface call h5close_f ( error ) deallocate ( ri , vi ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'birth profile written to: ' , trim ( filename ) endif end subroutine write_birth_profile","tags":"","loc":"proc/write_birth_profile.html","title":"write_birth_profile – FIDASIM"},{"text":"public subroutine write_dcx() Writes the direct charge exchange (DCX) neutrals and spectra to a HDF5 file Arguments None Calls proc~~write_dcx~~CallsGraph proc~write_dcx write_dcx h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_dcx->h5ltset_attribute_string_f h5open_f h5open_f proc~write_dcx->h5open_f proc~write_beam_grid write_beam_grid proc~write_dcx->proc~write_beam_grid h5close_f h5close_f proc~write_dcx->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_dcx->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_dcx->h5ltmake_dataset_int_f h5fcreate_f h5fcreate_f proc~write_dcx->h5fcreate_f proc~write_beam_grid->h5ltset_attribute_string_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->h5ltmake_dataset_int_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f proc~xyz_to_uvw xyz_to_uvw proc~write_beam_grid->proc~xyz_to_uvw h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_dcxCallsGraph = svgPanZoom('#procwrite_dcxCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_dcx~~CalledByGraph proc~write_dcx write_dcx program~fidasim fidasim program~fidasim->proc~write_dcx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_dcx Source Code subroutine write_dcx !+ Writes the direct charge exchange (DCX) neutrals and spectra to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dims integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error character ( charlim ) :: filename character ( 15 ) :: spec_str integer :: i real ( Float64 ), dimension (:), allocatable :: lambda_arr real ( Float64 ), dimension (:,:), allocatable :: dcx_spec filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_dcx.h5\" spec_str = \"\" if ( inputs % calc_spec . ge . 1 ) then spec_str = \" spectra and\" allocate ( lambda_arr ( inputs % nlambda )) do i = 1 , inputs % nlambda lambda_arr ( i ) = ( i - 0.5 ) * inputs % dlambda + inputs % lambdamin ! [nm] enddo allocate ( dcx_spec ( inputs % nlambda , spec_chords % nchan )) !! convert [Ph/(s*wavel_bin*cm&#94;2*all_directions)] to [Ph/(s*nm*sr*m&#94;2)]! dcx_spec = spec % bes (:,:, halo_type ) / ( inputs % dlambda ) / ( 4.d0 * pi ) * 1.d4 endif !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables call write_beam_grid ( fid , error ) d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nlevel\" , 0 , d , [ nlevs ], error ) dims = [ nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz ] call h5ltmake_compressed_dataset_double_f ( fid , \"/dens\" , 4 , dims , & neut % dens (:, halo_type ,:,:,:), error ) if ( inputs % calc_spec . ge . 1 ) then call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ spec_chords % nchan ], error ) call h5ltmake_dataset_int_f ( fid , \"/nlambda\" , 0 , d , [ inputs % nlambda ], error ) dims ( 1 ) = inputs % nlambda dims ( 2 ) = spec_chords % nchan call h5ltmake_compressed_dataset_double_f ( fid , \"/spec\" , 2 , dims ( 1 : 2 ), & dcx_spec , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/lambda\" , 1 , dims ( 1 : 1 ), & lambda_arr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dims ( 2 : 2 ), & spec_chords % radius , error ) endif !Add attributes call h5ltset_attribute_string_f ( fid , \"/nlevel\" , \"description\" , & \"Number of atomic energy levels\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"description\" , & \"Direct Charge Exchange (DCX) neutral density: dcx(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/dens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) if ( inputs % calc_spec . ge . 1 ) then call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nlambda\" , \"description\" , & \"Number of wavelengths\" , error ) call h5ltset_attribute_string_f ( fid , \"/spec\" , \"description\" , & \"Direct Charge Exchange (DCX) beam emission: spec(lambda, chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/spec\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"description\" , & \"Wavelength array\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"units\" , \"nm\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Direct Charge Exchange (DCX)\" // trim ( spec_str ) // \" neutral density calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % calc_spec . ge . 1 ) then deallocate ( dcx_spec , lambda_arr ) endif if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'dcx written to: ' , trim ( filename ) endif end subroutine write_dcx","tags":"","loc":"proc/write_dcx.html","title":"write_dcx – FIDASIM"},{"text":"public subroutine write_neutrals() Writes neut to a HDF5 file Arguments None Calls proc~~write_neutrals~~CallsGraph proc~write_neutrals write_neutrals h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_neutrals->h5ltset_attribute_string_f h5open_f h5open_f proc~write_neutrals->h5open_f proc~write_beam_grid write_beam_grid proc~write_neutrals->proc~write_beam_grid h5close_f h5close_f proc~write_neutrals->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_neutrals->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_neutrals->h5ltmake_dataset_int_f h5fcreate_f h5fcreate_f proc~write_neutrals->h5fcreate_f proc~write_beam_grid->h5ltset_attribute_string_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->h5ltmake_dataset_int_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f proc~xyz_to_uvw xyz_to_uvw proc~write_beam_grid->proc~xyz_to_uvw h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_neutralsCallsGraph = svgPanZoom('#procwrite_neutralsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_neutrals~~CalledByGraph proc~write_neutrals write_neutrals program~fidasim fidasim program~fidasim->proc~write_neutrals Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_neutrals Source Code subroutine write_neutrals !+ Writes [[libfida:neut]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dims integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error character ( charlim ) :: filename filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_neutrals.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables call write_beam_grid ( fid , error ) dims = [ nlevs , beam_grid % nx , beam_grid % ny , beam_grid % nz ] d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nlevel\" , 0 , d , [ nlevs ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/fdens\" , 4 , dims , & neut % dens (:, nbif_type ,:,:,:), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/hdens\" , 4 , dims , & neut % dens (:, nbih_type ,:,:,:), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/tdens\" , 4 , dims , & neut % dens (:, nbit_type ,:,:,:), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/halodens\" , 4 , dims , & neut % dens (:, halo_type ,:,:,:), error ) !Write attributes call h5ltset_attribute_string_f ( fid , \"/nlevel\" , \"description\" , & \"Number of atomic energy levels\" , error ) call h5ltset_attribute_string_f ( fid , \"/fdens\" , \"description\" , & \"Neutral density for the full energy component of the beam: fdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/fdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/hdens\" , \"description\" , & \"Neutral density for the half energy component of the beam: hdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/hdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/tdens\" , \"description\" , & \"Neutral density for the third energy component of the beam: tdens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/tdens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/halodens\" , \"description\" , & \"Neutral density of the beam halo(including dcx): halodens(level,x,y,z)\" , error ) call h5ltset_attribute_string_f ( fid , \"/halodens\" , \"units\" , \"neutrals*cm&#94;-3\" , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Beam neutral density calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'neutral density written to: ' , trim ( filename ) endif end subroutine write_neutrals","tags":"","loc":"proc/write_neutrals.html","title":"write_neutrals – FIDASIM"},{"text":"public subroutine write_npa() Writes npa to a HDF5 file Arguments None Calls proc~~write_npa~~CallsGraph proc~write_npa write_npa interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f proc~write_npa->interface~h5ltmake_compressed_dataset_int_f h5close_f h5close_f proc~write_npa->h5close_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_npa->h5ltset_attribute_string_f h5open_f h5open_f proc~write_npa->h5open_f h5gclose_f h5gclose_f proc~write_npa->h5gclose_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_npa->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_npa->h5fclose_f h5gcreate_f h5gcreate_f proc~write_npa->h5gcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_npa->h5ltmake_dataset_int_f h5fcreate_f h5fcreate_f proc~write_npa->h5fcreate_f proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_int_f_1->h5ltmake_dataset_int_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_1->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_deflate_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_1->h5screate_simple_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f var panprocwrite_npaCallsGraph = svgPanZoom('#procwrite_npaCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_npa~~CalledByGraph proc~write_npa write_npa program~fidasim fidasim program~fidasim->proc~write_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_npa Source Code subroutine write_npa !+ Writes [[libfida:npa]] to a HDF5 file integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error integer , dimension (:), allocatable :: dcount real ( Float64 ), dimension (:,:), allocatable :: ri , rf integer :: i , n character ( charlim ) :: filename = '' allocate ( dcount ( npa_chords % nchan )) do i = 1 , npa_chords % nchan dcount ( i ) = count ( npa % part % detector . eq . i ) enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_npa.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write Flux d ( 1 ) = 1 dim2 = [ npa % nenergy , npa % nchan ] dim3 = [ npa % nenergy , npa % nchan , particles % nclass ] if ( particles % nclass . gt . 1 ) then call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , d , [ particles % nclass ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/flux\" , 3 , dim3 , npa % flux , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"description\" , & \"Neutral flux: flux(energy,chan,class)\" , error ) else call h5ltmake_compressed_dataset_double_f ( fid , \"/flux\" , 2 , dim3 ( 1 : 2 ), npa % flux (:,:, 1 ), error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"description\" , & \"Neutral flux: flux(energy,chan)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/flux\" , \"units\" , \"neutrals/(s*dE)\" , error ) call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , d , [ npa % nenergy ], error ) call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ npa % nchan ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim2 ( 1 : 1 ),& npa % energy , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dim2 ( 2 : 2 ),& npa_chords % radius , error ) call h5ltmake_compressed_dataset_int_f ( fid , \"/count\" , 1 , dim2 ( 2 : 2 ), dcount , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"NPA flux calculated by FIDASIM\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" ,& \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" ,& \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Detector line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/count\" , \"description\" , & \"Number of particles that hit the detector: count(chan)\" , error ) deallocate ( dcount ) if (( npa % npart . ne . 0 ). and .( inputs % calc_npa . ge . 2 )) then n = npa % npart allocate ( ri ( 3 , n ), rf ( 3 , n )) ri ( 1 ,:) = npa % part ( 1 : n )% xi ri ( 2 ,:) = npa % part ( 1 : n )% yi ri ( 3 ,:) = npa % part ( 1 : n )% zi rf ( 1 ,:) = npa % part ( 1 : n )% xf rf ( 2 ,:) = npa % part ( 1 : n )% yf rf ( 3 ,:) = npa % part ( 1 : n )% zf !Create Group call h5gcreate_f ( fid , \"/particles\" , gid , error ) call h5ltmake_dataset_int_f ( gid , \"nparticle\" , 0 , d , [ npa % npart ], error ) d ( 1 ) = npa % npart dim2 = [ 3 , n ] call h5ltmake_compressed_dataset_double_f ( gid , \"ri\" , 2 , dim2 , ri , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"rf\" , 2 , dim2 , rf , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"pitch\" , 1 , d , & npa % part ( 1 : n )% pitch , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , d ,& npa % part ( 1 : n )% energy , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"weight\" , 1 , d ,& npa % part ( 1 : n )% weight , error ) call h5ltmake_compressed_dataset_int_f ( gid , \"detector\" , 1 , d ,& npa % part ( 1 : n )% detector , error ) !Add attributes call h5ltset_attribute_string_f ( gid , \"nparticle\" , \"description\" , & \"Number of particles that hit a detector\" , error ) call h5ltset_attribute_string_f ( gid , \"ri\" , \"description\" , & \"Neutral particle's birth position in machine coordinates: ri([x,y,z],particle)\" , error ) call h5ltset_attribute_string_f ( gid , \"ri\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"rf\" , \"description\" , & \"Neutral particle's hit position in machine coordinates: rf([x,y,z],particle)\" , error ) call h5ltset_attribute_string_f ( gid , \"rf\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( gid , \"pitch\" , \"description\" , & \"Pitch value of the neutral particle: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy value of the neutral particle\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"weight\" , \"description\" , & \"Neutral particle's contribution to the flux\" , error ) call h5ltset_attribute_string_f ( gid , \"weight\" , \"units\" , \"neutrals/s\" , error ) call h5ltset_attribute_string_f ( gid , \"detector\" , \"description\" , & \"Detector that the neutral particle hit\" , error ) call h5ltset_attribute_string_f ( fid , \"/particles\" , \"coordinate_system\" , & \"Right-handed cartesian\" , error ) call h5ltset_attribute_string_f ( fid , \"/particles\" , \"description\" , & \"Monte Carlo particles\" , error ) !Close group call h5gclose_f ( gid , error ) deallocate ( ri , rf ) endif !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'NPA data written to: ' , trim ( filename ) endif end subroutine write_npa","tags":"","loc":"proc/write_npa.html","title":"write_npa – FIDASIM"},{"text":"public subroutine write_spectra() Writes Spectra to a HDF5 file Arguments None Calls proc~~write_spectra~~CallsGraph proc~write_spectra write_spectra h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_spectra->h5ltset_attribute_string_f h5open_f h5open_f proc~write_spectra->h5open_f h5close_f h5close_f proc~write_spectra->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_spectra->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_spectra->h5ltmake_dataset_int_f h5fcreate_f h5fcreate_f proc~write_spectra->h5fcreate_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_spectraCallsGraph = svgPanZoom('#procwrite_spectraCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_spectra~~CalledByGraph proc~write_spectra write_spectra program~fidasim fidasim program~fidasim->proc~write_spectra Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_spectra Source Code subroutine write_spectra !+ Writes [[libfida:spectra]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 3 ) :: dims integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error character ( charlim ) :: filename integer :: i real ( Float64 ), dimension (:), allocatable :: lambda_arr allocate ( lambda_arr ( inputs % nlambda )) do i = 1 , inputs % nlambda lambda_arr ( i ) = ( i - 0.5 ) * inputs % dlambda + inputs % lambdamin enddo !! convert [Ph/(s*wavel_bin*cm&#94;2*all_directions)] to [Ph/(s*nm*sr*m&#94;2)]! spec % brems = spec % brems / ( inputs % dlambda ) / ( 4.d0 * pi ) * 1.d4 spec % bes = spec % bes / ( inputs % dlambda ) / ( 4.d0 * pi ) * 1.d4 spec % fida = spec % fida / ( inputs % dlambda ) / ( 4.d0 * pi ) * 1.d4 !! write to file filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_spectra.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables d ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ spec_chords % nchan ], error ) call h5ltmake_dataset_int_f ( fid , \"/nlambda\" , 0 , d , [ inputs % nlambda ], error ) dims ( 1 ) = inputs % nlambda dims ( 2 ) = spec_chords % nchan dims ( 3 ) = particles % nclass call h5ltmake_compressed_dataset_double_f ( fid , \"/lambda\" , 1 , dims ( 1 : 1 ), & lambda_arr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dims ( 2 : 2 ), & spec_chords % radius , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nlambda\" , \"description\" , & \"Number of wavelengths\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"description\" , & \"Wavelength array\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"units\" , \"nm\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) if ( inputs % calc_brems . ge . 1 ) then !Write variables call h5ltmake_compressed_dataset_double_f ( fid , \"/brems\" , 2 , & dims ( 1 : 2 ), spec % brems , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/brems\" , \"description\" , & \"Visible Bremsstrahlung: brems(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/brems\" , \"units\" ,& \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_bes . ge . 1 ) then !Write variables call h5ltmake_compressed_dataset_double_f ( fid , \"/full\" , 2 , dims ( 1 : 2 ), & spec % bes (:,:, nbif_type ), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/half\" , 2 , dims ( 1 : 2 ), & spec % bes (:,:, nbih_type ), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/third\" , 2 , dims ( 1 : 2 ),& spec % bes (:,:, nbit_type ), error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/halo\" , 2 , dims ( 1 : 2 ), & spec % bes (:,:, halo_type ), error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/full\" , \"description\" , & \"Full energy component of the beam emmision: full(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/full\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/half\" , \"description\" , & \"Half energy component of the beam emmision: half(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/half\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/third\" , \"description\" , & \"Third energy component of the beam emmision: third(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/third\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/halo\" , \"description\" , & \"Halo component of the beam emmision (includes dcx): halo(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/halo\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif if ( inputs % calc_fida . ge . 1 ) then !Write variables if ( particles % nclass . le . 1 ) then call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 2 , & dims ( 1 : 2 ), spec % fida (:,:, 1 ), error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Fast-ion D-alpha (FIDA) emmision: fida(lambda,chan)\" , error ) else call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , d , [ particles % nclass ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 3 , & dims , spec % fida , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Fast-ion D-alpha (FIDA) emmision: fida(lambda,chan,class)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/fida\" , \"units\" , \"Ph/(s*nm*sr*m&#94;2)\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" ,& \"Spectra calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'Spectra written to: ' , trim ( filename ) endif end subroutine write_spectra","tags":"","loc":"proc/write_spectra.html","title":"write_spectra – FIDASIM"},{"text":"public subroutine write_neutrons() Writes neutron to a HDF5 file Arguments None Calls proc~~write_neutrons~~CallsGraph proc~write_neutrons write_neutrons h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_neutrons->h5ltset_attribute_string_f h5fcreate_f h5fcreate_f proc~write_neutrons->h5fcreate_f h5open_f h5open_f proc~write_neutrons->h5open_f h5close_f h5close_f proc~write_neutrons->h5close_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_neutrons->h5ltmake_dataset_double_f h5fclose_f h5fclose_f proc~write_neutrons->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_neutrons->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_neutronsCallsGraph = svgPanZoom('#procwrite_neutronsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_neutrons~~CalledByGraph proc~write_neutrons write_neutrons proc~neutron_f neutron_f proc~neutron_f->proc~write_neutrons proc~neutron_mc neutron_mc proc~neutron_mc->proc~write_neutrons program~fidasim fidasim program~fidasim->proc~neutron_f program~fidasim->proc~neutron_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_neutrons Source Code subroutine write_neutrons !+ Writes [[libfida:neutron]] to a HDF5 file integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer :: error character ( charlim ) :: filename !! write to file filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_neutrons.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables if ( particles % nclass . gt . 1 ) then dim1 ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nclass\" , 0 , dim1 , [ particles % nclass ], error ) dim1 ( 1 ) = particles % nclass call h5ltmake_compressed_dataset_double_f ( fid , \"/rate\" , 1 , dim1 , neutron % rate , error ) call h5ltset_attribute_string_f ( fid , \"/rate\" , \"description\" , & \"Neutron rate: rate(orbit_class)\" , error ) else dim1 ( 1 ) = 1 call h5ltmake_dataset_double_f ( fid , \"/rate\" , 0 , dim1 , neutron % rate , error ) call h5ltset_attribute_string_f ( fid , \"/rate\" , \"description\" , & \"Neutron rate\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/rate\" , \"units\" , \"neutrons/s\" , error ) if ( inputs % dist_type . eq . 1 ) then dim1 ( 1 ) = 1 call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , dim1 ,[ fbm % nenergy ], error ) call h5ltmake_dataset_int_f ( fid , \"/npitch\" , 0 , dim1 ,[ fbm % npitch ], error ) call h5ltmake_dataset_int_f ( fid , \"/nr\" , 0 , dim1 ,[ fbm % nr ], error ) call h5ltmake_dataset_int_f ( fid , \"/nz\" , 0 , dim1 ,[ fbm % nz ], error ) dim4 = shape ( neutron % weight ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 4 , dim4 , neutron % weight , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim4 ( 1 : 1 ), fbm % energy , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , dim4 ( 2 : 2 ), fbm % pitch , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/r\" , 1 , dim4 ( 3 : 3 ), fbm % r , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/z\" , 1 , dim4 ( 4 : 4 ), fbm % z , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/npitch\" , \"description\" , & \"Number of pitch values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nr\" , \"description\" , & \"Number of R values\" , error ) call h5ltset_attribute_string_f ( fid , \"/nz\" , \"description\" , & \"Number of Z values\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"Neutron Weight Function: weight(E,p,R,Z), rate = sum(f*weight)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , \"neutrons*cm&#94;3*dE*dp/fast-ion*s\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Pitch array: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( fid , \"/r\" , \"description\" , & \"Radius array\" , error ) call h5ltset_attribute_string_f ( fid , \"/r\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/z\" , \"description\" , & \"Z array\" , error ) call h5ltset_attribute_string_f ( fid , \"/z\" , \"units\" , \"cm\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" ,& \"Neutron rate calculated by FIDASIM\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'Neutrons written to: ' , trim ( filename ) endif end subroutine write_neutrons","tags":"","loc":"proc/write_neutrons.html","title":"write_neutrons – FIDASIM"},{"text":"public subroutine write_fida_weights() Writes fweight to a HDF5 file Arguments None Calls proc~~write_fida_weights~~CallsGraph proc~write_fida_weights write_fida_weights h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_fida_weights->h5ltset_attribute_string_f h5open_f h5open_f proc~write_fida_weights->h5open_f h5close_f h5close_f proc~write_fida_weights->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_fida_weights->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_fida_weights->h5ltmake_dataset_int_f h5fcreate_f h5fcreate_f proc~write_fida_weights->h5fcreate_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_fida_weightsCallsGraph = svgPanZoom('#procwrite_fida_weightsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_fida_weights~~CalledByGraph proc~write_fida_weights write_fida_weights proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~write_fida_weights program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_weights_los Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_fida_weights Source Code subroutine write_fida_weights !+ Writes [[libfida:fweight]] to a HDF5 file !! HDF5 variables integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer :: error character ( charlim ) :: filename integer :: i , ie , ip , ic , iwav real ( Float64 ), dimension (:), allocatable :: lambda_arr real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr real ( Float64 ), dimension (:,:), allocatable :: jacobian , e_grid , p_grid real ( Float64 ), dimension (:,:), allocatable :: vpa_grid , vpe_grid , fida real ( Float64 ) :: dlambda , wtot , dE , dP dlambda = ( inputs % lambdamax_wght - inputs % lambdamin_wght ) / inputs % nlambda_wght allocate ( lambda_arr ( inputs % nlambda_wght )) do i = 1 , inputs % nlambda_wght lambda_arr ( i ) = ( i - 0.5 ) * dlambda + inputs % lambdamin_wght enddo !! define arrays !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) !! define 2d grids !! define energy grid allocate ( e_grid ( inputs % ne_wght , inputs % np_wght )) do i = 1 , inputs % ne_wght e_grid ( i ,:) = ebarr ( i ) enddo !! define pitch grid allocate ( p_grid ( inputs % ne_wght , inputs % np_wght )) do i = 1 , inputs % np_wght p_grid (:, i ) = ptcharr ( i ) enddo !! define velocity space grid allocate ( vpe_grid ( inputs % ne_wght , inputs % np_wght )) !! V perpendicular allocate ( vpa_grid ( inputs % ne_wght , inputs % np_wght )) !! V parallel vpa_grid = 100 * sqrt (((( 2.0d3 ) * e0 ) / ( mass_u * inputs % ab )) * e_grid ) * p_grid ! [cm/s] vpe_grid = 100 * sqrt (((( 2.0d3 ) * e0 ) / ( mass_u * inputs % ab )) * e_grid * ( 1.0 - p_grid ** 2 )) ![cm/s] !! define jacobian to convert between E-p to velocity allocate ( jacobian ( inputs % ne_wght , inputs % np_wght )) jacobian = (( inputs % ab * mass_u ) / ( e0 * 1.0d3 )) * vpe_grid / sqrt ( vpa_grid ** 2 + vpe_grid ** 2 ) !! normalize mean_f do ic = 1 , spec_chords % nchan do ip = 1 , inputs % np_wght do ie = 1 , inputs % ne_wght wtot = sum ( fweight % weight (:, ie , ip , ic )) if (( wtot . gt . 0.d0 )) then fweight % mean_f ( ie , ip , ic ) = fweight % mean_f ( ie , ip , ic ) / wtot endif enddo enddo enddo !! Calculate FIDA estimate allocate ( fida ( inputs % nlambda_wght , spec_chords % nchan )) do iwav = 1 , size ( fida , 1 ) fida ( iwav ,:) = ( dE * dP * 1 d4 ) * sum ( sum ( fweight % mean_f (:,:,:) * fweight % weight ( iwav ,:,:,:), 1 ), 1 ) enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_fida_weights.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) dim1 ( 1 ) = 1 dim2 = [ inputs % nlambda_wght , spec_chords % nchan ] dim4 = [ inputs % nlambda_wght , inputs % ne_wght , inputs % np_wght , spec_chords % nchan ] call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , dim1 ,[ inputs % ne_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/npitch\" , 0 , dim1 ,[ inputs % np_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , dim1 ,[ spec_chords % nchan ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 4 , dim4 , fweight % weight , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/fida\" , 2 , dim2 , fida , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/mean_f\" , 3 , dim4 ( 2 : 4 ), fweight % mean_f , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/lambda\" , 1 , dim4 ( 1 : 1 ), lambda_arr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , dim4 ( 2 : 2 ), ebarr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , dim4 ( 3 : 3 ), ptcharr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , dim4 ( 4 : 4 ), spec_chords % radius , error ) dim2 = [ inputs % ne_wght , inputs % np_wght ] call h5ltmake_compressed_dataset_double_f ( fid , \"/jacobian\" , 2 , dim2 , jacobian , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vpe_grid\" , 2 , dim2 , vpe_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/vpa_grid\" , 2 , dim2 , vpa_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/e_grid\" , 2 , dim2 , e_grid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/p_grid\" , 2 , dim2 , p_grid , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) if ( inputs % calc_fida_wght . eq . 1 ) then call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Line of Sight averaged FIDA E-p space sensitivity/weights \" // & \"and spectra calculated by FIDASIM\" , error ) else call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"Full FIDA E-p space sensitivity/weights and spectra calculated \" // & \"by FIDASIM via Monte Carlo method\" , error ) endif call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"E-p space sensivity/weight of FIDA diagnostic: weight(lambda,energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , & \"(Ph*cm)/(s*nm*sr*fast-ion*dE*dP)\" , error ) call h5ltset_attribute_string_f ( fid , \"/fida\" , \"units\" , & \"Ph/(s*nm*sr*m&#94;2)\" , error ) call h5ltset_attribute_string_f ( fid , \"/fida\" , \"description\" , & \"Estimate of Fast-ion D-alpha (FIDA) emmision calculated by 1e4*weight*mean_f*dEdP: fida(lambda,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/mean_f\" , \"description\" , & \"Estimated mean fast-ion distribution function seen by los: mean_f(energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/mean_f\" , \"units\" , & \"fast-ion/(dE*dP*cm&#94;3)\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"description\" , & \"Wavelength array\" , error ) call h5ltset_attribute_string_f ( fid , \"/lambda\" , \"units\" , \"nm\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/npitch\" , \"description\" , & \"Number of pitch value\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Pitch array: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/jacobian\" , \"description\" , & \"Jacobian used to convert from E-p space to velocity space\" , error ) call h5ltset_attribute_string_f ( fid , \"/jacobian\" , \"units\" , & \"(dE*dP)/(dvpa*dvpe)\" , error ) call h5ltset_attribute_string_f ( fid , \"/e_grid\" , \"description\" , & \"2D energy grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/e_grid\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/p_grid\" , \"description\" , & \"2D pitch grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpe_grid\" , \"description\" , & \"2D perpendicular velocity grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpe_grid\" , \"units\" , \"cm/s\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpa_grid\" , \"description\" , & \"2D parallel velocity grid\" , error ) call h5ltset_attribute_string_f ( fid , \"/vpa_grid\" , \"units\" , \"cm/s\" , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'FIDA weights written to: ' , trim ( filename ) endif end subroutine write_fida_weights","tags":"","loc":"proc/write_fida_weights.html","title":"write_fida_weights – FIDASIM"},{"text":"public subroutine write_npa_weights() Writes nweight to a HDF5 file Arguments None Calls proc~~write_npa_weights~~CallsGraph proc~write_npa_weights write_npa_weights h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_npa_weights->h5ltset_attribute_string_f h5open_f h5open_f proc~write_npa_weights->h5open_f proc~write_beam_grid write_beam_grid proc~write_npa_weights->proc~write_beam_grid h5close_f h5close_f proc~write_npa_weights->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_npa_weights->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_npa_weights->h5ltmake_dataset_int_f h5fcreate_f h5fcreate_f proc~write_npa_weights->h5fcreate_f proc~write_beam_grid->h5ltset_attribute_string_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->h5ltmake_dataset_int_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f proc~xyz_to_uvw xyz_to_uvw proc~write_beam_grid->proc~xyz_to_uvw h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_npa_weightsCallsGraph = svgPanZoom('#procwrite_npa_weightsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_npa_weights~~CalledByGraph proc~write_npa_weights write_npa_weights proc~npa_weights npa_weights proc~npa_weights->proc~write_npa_weights program~fidasim fidasim program~fidasim->proc~npa_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_npa_weights Source Code subroutine write_npa_weights !+ Writes [[libfida:nweight]] to a HDF5 file character ( charlim ) :: filename integer :: i real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr !! HDF5 variables integer ( HID_T ) :: fid integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 1 ) :: d integer :: error !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo filename = trim ( adjustl ( inputs % result_dir )) // \"/\" // trim ( adjustl ( inputs % runid )) // \"_npa_weights.h5\" !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , fid , error ) !Write variables d ( 1 ) = 1 dim2 = [ inputs % ne_wght , npa_chords % nchan ] dim3 = [ inputs % ne_wght , inputs % np_wght , npa_chords % nchan ] dim5 = [ inputs % ne_wght , beam_grid % nx , beam_grid % ny , beam_grid % nz , npa_chords % nchan ] call h5ltmake_dataset_int_f ( fid , \"/nchan\" , 0 , d , [ npa_chords % nchan ], error ) call h5ltmake_dataset_int_f ( fid , \"/nenergy\" , 0 , d , [ inputs % ne_wght ], error ) call h5ltmake_dataset_int_f ( fid , \"/npitch\" , 0 , d , [ inputs % np_wght ], error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/radius\" , 1 , & dim2 ( 2 : 2 ), npa_chords % radius , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/energy\" , 1 , & dim2 ( 1 : 1 ), ebarr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/pitch\" , 1 , & dim3 ( 2 : 2 ), ptcharr , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/flux\" , 2 , & dim2 , nweight % flux , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/weight\" , 3 , & dim3 , nweight % weight , error ) !Add attributes call h5ltset_attribute_string_f ( fid , \"/\" , \"version\" , version , error ) call h5ltset_attribute_string_f ( fid , \"/\" , \"description\" , & \"NPA E-p space sensitivity/weights and Flux calculated by FIDASIM\" , error ) call h5ltset_attribute_string_f ( fid , \"/nchan\" , \"description\" , & \"Number of channels\" , error ) call h5ltset_attribute_string_f ( fid , \"/nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( fid , \"/npitch\" , \"description\" , & \"Number of pitch value\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"description\" , & \"Energy array\" , error ) call h5ltset_attribute_string_f ( fid , \"/energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( fid , \"/pitch\" , \"description\" , & \"Pitch array: p = v_parallel/v  w.r.t. the magnetic field\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"description\" , & \"Line of sight radius at midplane or tangency point\" , error ) call h5ltset_attribute_string_f ( fid , \"/radius\" , \"units\" , \"cm\" , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"description\" , & \"Neutral flux: flux(energy,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/flux\" , \"units\" , & \"neutrals/(s*dE)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"description\" , & \"E-p space sensivity/weight of NPA diagnostics: weight(energy,pitch,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/weight\" , \"units\" , & \"neutrals/(s*fast-ion*dE*dP)\" , error ) if ( inputs % calc_npa_wght . ge . 2 ) then !Write diagnostic variables call write_beam_grid ( fid , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/emissivity\" , 4 , & dim5 ( 2 : 5 ), nweight % emissivity , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/attenuation\" , 5 , & dim5 , nweight % attenuation , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/cx\" , 5 , & dim5 , nweight % cx , error ) call h5ltmake_compressed_dataset_double_f ( fid , \"/phit\" , 4 , & dim5 ( 2 : 5 ), npa_chords % phit % p , error ) call h5ltset_attribute_string_f ( fid , \"/emissivity\" , \"description\" , & \"Neutral emissivity: emissivity(x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/emissivity\" , \"units\" , & \"neutrals/(s*dV)\" , error ) call h5ltset_attribute_string_f ( fid , \"/cx\" , \"description\" , & \"Charge-exchange rate: cx(energy,x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/cx\" , \"units\" , \"s&#94;(-1)\" , error ) call h5ltset_attribute_string_f ( fid , \"/attenuation\" , \"description\" , & \"Attenuation factor i.e. survival probability: attenuation(energy,x,y,z,chan)\" , error ) call h5ltset_attribute_string_f ( fid , \"/phit\" , \"description\" , & \"Probability of hitting the detector given an isotropic source: phit(x,y,z,chan)\" , error ) endif !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,a,a)' ) 'NPA weights written to: ' , trim ( filename ) endif end subroutine write_npa_weights","tags":"","loc":"proc/write_npa_weights.html","title":"write_npa_weights – FIDASIM"},{"text":"public subroutine read_neutrals() Reads neutral density from file and puts it in neut Arguments None Calls proc~~read_neutrals~~CallsGraph proc~read_neutrals read_neutrals proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_neutrals->proc~h5ltread_dataset_int_scalar_f h5close_f h5close_f proc~read_neutrals->h5close_f h5gopen_f h5gopen_f proc~read_neutrals->h5gopen_f h5open_f h5open_f proc~read_neutrals->h5open_f h5gclose_f h5gclose_f proc~read_neutrals->h5gclose_f h5fclose_f h5fclose_f proc~read_neutrals->h5fclose_f h5fopen_f h5fopen_f proc~read_neutrals->h5fopen_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_neutrals->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~read_neutrals~~CalledByGraph proc~read_neutrals read_neutrals program~fidasim fidasim program~fidasim->proc~read_neutrals Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code read_neutrals Source Code subroutine read_neutrals !+ Reads neutral density from file and puts it in [[libfida:neut]] integer ( HID_T ) :: fid , gid integer ( HSIZE_T ), dimension ( 4 ) :: dims integer :: error , nx , ny , nz logical :: exis if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) '---- loading neutrals ----' endif inquire ( file = inputs % neutrals_file , exist = exis ) if ( exis ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Neutrals file: \",a)' ) trim ( inputs % neutrals_file ) write ( * , * ) '' endif else if ( inputs % verbose . ge . 0 ) then write ( * , '(a,a)' ) 'READ_NEUTRALS: Neutrals file does not exist: ' , inputs % neutrals_file endif stop endif !Open HDF5 interface call h5open_f ( error ) !Create file overwriting any existing file call h5fopen_f ( inputs % neutrals_file , H5F_ACC_RDONLY_F , fid , error ) call h5gopen_f ( fid , \"/grid\" , gid , error ) call h5ltread_dataset_int_scalar_f ( gid , \"nx\" , nx , error ) call h5ltread_dataset_int_scalar_f ( gid , \"ny\" , ny , error ) call h5ltread_dataset_int_scalar_f ( gid , \"nz\" , nz , error ) call h5gclose_f ( gid , error ) if (( nx . ne . beam_grid % nx ). or . & ( ny . ne . beam_grid % ny ). or . & ( nz . ne . beam_grid % nz )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'READ_NEUTRALS: Neutrals file has incompatable grid dimensions' endif stop endif dims = [ nlevs , nx , ny , nz ] call h5ltread_dataset_double_f ( fid , \"/fdens\" , & neut % dens (:, nbif_type ,:,:,:), dims , error ) call h5ltread_dataset_double_f ( fid , \"/hdens\" , & neut % dens (:, nbih_type ,:,:,:), dims , error ) call h5ltread_dataset_double_f ( fid , \"/tdens\" , & neut % dens (:, nbit_type ,:,:,:), dims , error ) call h5ltread_dataset_double_f ( fid , \"/halodens\" , & neut % dens (:, halo_type ,:,:,:), dims , error ) !Close file call h5fclose_f ( fid , error ) !Close HDF5 interface call h5close_f ( error ) end subroutine read_neutrals","tags":"","loc":"proc/read_neutrals.html","title":"read_neutrals – FIDASIM"},{"text":"public subroutine tb_zyx(alpha, beta, gamma, basis, inv_basis) Creates active rotation matrix for z-y'-x\" rotation given Tait-Bryan angles Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: alpha Angle of rotation about z real(kind=Float64), intent(in) :: beta Angle of rotation about y' real(kind=Float64), intent(in) :: gamma Angle of rotation about x\" real(kind=Float64), intent(out), dimension(3,3) :: basis Rotation matrix/basis for transforming from rotated to non-rotated coordinates real(kind=Float64), intent(out), optional dimension(3,3) :: inv_basis Inverse basis for reverse transformation Called By proc~~tb_zyx~~CalledByGraph proc~tb_zyx tb_zyx proc~read_beam read_beam proc~read_beam->proc~tb_zyx proc~make_beam_grid make_beam_grid proc~make_beam_grid->proc~tb_zyx proc~line_basis line_basis proc~line_basis->proc~tb_zyx program~fidasim fidasim program~fidasim->proc~read_beam program~fidasim->proc~make_beam_grid proc~read_chords read_chords program~fidasim->proc~read_chords proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~read_chords->proc~line_basis proc~bremsstrahlung->proc~line_basis Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code tb_zyx Source Code subroutine tb_zyx ( alpha , beta , gamma , basis , inv_basis ) !+ Creates active rotation matrix for z-y'-x\" rotation given Tait-Bryan angles real ( Float64 ), intent ( in ) :: alpha !+ Angle of rotation about z real ( Float64 ), intent ( in ) :: beta !+ Angle of rotation about y' real ( Float64 ), intent ( in ) :: gamma !+ Angle of rotation about x\" real ( Float64 ), dimension ( 3 , 3 ), intent ( out ) :: basis !+ Rotation matrix/basis for transforming from rotated to non-rotated coordinates real ( Float64 ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis !+ Inverse basis for reverse transformation real ( Float64 ) :: sa , sb , sg , ca , cb , cg sa = sin ( alpha ) ; sb = sin ( beta ) ; sg = sin ( gamma ) ca = cos ( alpha ) ; cb = cos ( beta ) ; cg = cos ( gamma ) basis ( 1 , 1 ) = ca * cb ; basis ( 1 , 2 ) = ca * sb * sg - cg * sa ; basis ( 1 , 3 ) = sa * sg + ca * cg * sb basis ( 2 , 1 ) = cb * sa ; basis ( 2 , 2 ) = ca * cg + sa * sb * sg ; basis ( 2 , 3 ) = cg * sa * sb - ca * sg basis ( 3 , 1 ) = - sb ; basis ( 3 , 2 ) = cb * sg ; basis ( 3 , 3 ) = cb * cg if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine tb_zyx","tags":"","loc":"proc/tb_zyx.html","title":"tb_zyx – FIDASIM"},{"text":"public subroutine line_basis(r0, v0, basis, inv_basis) Calculates basis from a line with +x in the direction of line Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Starting point of line [cm] real(kind=Float64), intent(in), dimension(3) :: v0 Direction of line real(kind=Float64), intent(out), dimension(3,3) :: basis Basis for transforming from line coordinates to cartesian real(kind=Float64), intent(out), optional dimension(3,3) :: inv_basis Inverse basis for the reverse transformation cartesian to line Calls proc~~line_basis~~CallsGraph proc~line_basis line_basis proc~tb_zyx tb_zyx proc~line_basis->proc~tb_zyx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~line_basis~~CalledByGraph proc~line_basis line_basis proc~read_chords read_chords proc~read_chords->proc~line_basis proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~line_basis program~fidasim fidasim program~fidasim->proc~read_chords program~fidasim->proc~bremsstrahlung Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code line_basis Source Code subroutine line_basis ( r0 , v0 , basis , inv_basis ) !+ Calculates basis from a line with +x in the direction of line real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Starting point of line [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Direction of line real ( Float64 ), dimension ( 3 , 3 ), intent ( out ) :: basis !+ Basis for transforming from line coordinates to cartesian real ( Float64 ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis !+ Inverse basis for the reverse transformation cartesian to line real ( Float64 ), dimension ( 3 ) :: rf real ( Float64 ) :: alpha , beta , dis rf = r0 + v0 dis = sqrt ( sum (( rf - r0 ) ** 2 )) beta = asin (( r0 ( 3 ) - rf ( 3 )) / dis ) alpha = atan2 ( rf ( 2 ) - r0 ( 2 ), rf ( 1 ) - r0 ( 1 )) call tb_zyx ( alpha , beta , 0.d0 , basis ) if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine line_basis","tags":"","loc":"proc/line_basis.html","title":"line_basis – FIDASIM"},{"text":"public subroutine plane_basis(center, redge, tedge, basis, inv_basis) Calculates basis from 3 points on a plane with +z being the plane normal Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: center Plane origin real(kind=Float64), intent(in), dimension(3) :: redge Right edge of plane real(kind=Float64), intent(in), dimension(3) :: tedge Top edge of plane real(kind=Float64), intent(out), dimension(3,3) :: basis Basis for transforming from plane to cartesian coordinates real(kind=Float64), intent(out), optional dimension(3,3) :: inv_basis Inverse basis for the reverse transformation cartesian to plane Calls proc~~plane_basis~~CallsGraph proc~plane_basis plane_basis proc~cross_product cross_product proc~plane_basis->proc~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~plane_basis~~CalledByGraph proc~plane_basis plane_basis proc~read_npa read_npa proc~read_npa->proc~plane_basis program~fidasim fidasim program~fidasim->proc~read_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code plane_basis Source Code subroutine plane_basis ( center , redge , tedge , basis , inv_basis ) !+ Calculates basis from 3 points on a plane with +z being the plane normal real ( Float64 ), dimension ( 3 ), intent ( in ) :: center !+ Plane origin real ( Float64 ), dimension ( 3 ), intent ( in ) :: redge !+ Right edge of plane real ( Float64 ), dimension ( 3 ), intent ( in ) :: tedge !+ Top edge of plane real ( Float64 ), dimension ( 3 , 3 ), intent ( out ) :: basis !+ Basis for transforming from plane to cartesian coordinates real ( Float64 ), dimension ( 3 , 3 ), intent ( out ), optional :: inv_basis !+ Inverse basis for the reverse transformation cartesian to plane real ( Float64 ), dimension ( 3 ) :: u1 , u2 , u3 u1 = ( redge - center ) u1 = u1 / norm2 ( u1 ) u2 = ( tedge - center ) u2 = u2 / norm2 ( u2 ) u3 = cross_product ( u1 , u2 ) u3 = u3 / norm2 ( u3 ) basis (:, 1 ) = u1 basis (:, 2 ) = u2 basis (:, 3 ) = u3 if ( present ( inv_basis )) inv_basis = transpose ( basis ) end subroutine plane_basis","tags":"","loc":"proc/plane_basis.html","title":"plane_basis – FIDASIM"},{"text":"public subroutine line_plane_intersect(l0, l, p0, n, p, t) Calculates the intersection of a line and a plane Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: l0 Point on line real(kind=Float64), intent(in), dimension(3) :: l Ray of line real(kind=Float64), intent(in), dimension(3) :: p0 Point on plane real(kind=Float64), intent(in), dimension(3) :: n Normal vector of plane real(kind=Float64), intent(out), dimension(3) :: p Line-plane intersect point real(kind=Float64), intent(out) :: t \"time\" to intersect Called By proc~~line_plane_intersect~~CalledByGraph proc~line_plane_intersect line_plane_intersect proc~gyro_range gyro_range proc~gyro_range->proc~line_plane_intersect proc~hit_npa_detector hit_npa_detector proc~hit_npa_detector->proc~line_plane_intersect proc~npa_gyro_range npa_gyro_range proc~npa_gyro_range->proc~gyro_range proc~npa_f npa_f proc~npa_f->proc~hit_npa_detector proc~npa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~hit_npa_detector proc~npa_mc->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~npa_f program~fidasim->proc~npa_mc proc~read_npa read_npa program~fidasim->proc~read_npa proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~read_npa->proc~hit_npa_detector proc~npa_weights->proc~hit_npa_detector Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code line_plane_intersect Source Code subroutine line_plane_intersect ( l0 , l , p0 , n , p , t ) !+ Calculates the intersection of a line and a plane real ( Float64 ), dimension ( 3 ), intent ( in ) :: l0 !+ Point on line real ( Float64 ), dimension ( 3 ), intent ( in ) :: l !+ Ray of line real ( Float64 ), dimension ( 3 ), intent ( in ) :: p0 !+ Point on plane real ( Float64 ), dimension ( 3 ), intent ( in ) :: n !+ Normal vector of plane real ( Float64 ), dimension ( 3 ), intent ( out ) :: p !+ Line-plane intersect point real ( Float64 ), intent ( out ) :: t !+ \"time\" to intersect real ( Float64 ) :: ldotn ldotn = dot_product ( l , n ) if ( ldotn . eq . 0.0 ) then t = 0.0 else t = dot_product ( p0 - l0 , n ) / ldotn endif p = l0 + t * l end subroutine line_plane_intersect","tags":"","loc":"proc/line_plane_intersect.html","title":"line_plane_intersect – FIDASIM"},{"text":"public subroutine boundary_edge(bplane, bedge, nb) Returns 3 x nb array containing points along the BoundedPlane's boundary edge Arguments Type Intent Optional Attributes Name type( BoundedPlane ), intent(in) :: bplane Bounded plane real(kind=Float64), intent(out), dimension(:,:) :: bedge Boundary edge points of bounded plane integer, intent(out) :: nb Number of points in boundary edge Called By proc~~boundary_edge~~CalledByGraph proc~boundary_edge boundary_edge proc~gyro_range gyro_range proc~gyro_range->proc~boundary_edge proc~npa_gyro_range npa_gyro_range proc~npa_gyro_range->proc~gyro_range proc~npa_f npa_f proc~npa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~npa_f program~fidasim->proc~npa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code boundary_edge Source Code subroutine boundary_edge ( bplane , bedge , nb ) !+ Returns 3 x `nb` array containing points along the BoundedPlane's boundary edge type ( BoundedPlane ), intent ( in ) :: bplane !+ Bounded plane real ( Float64 ), dimension (:,:), intent ( out ) :: bedge !+ Boundary edge points of bounded plane integer , intent ( out ) :: nb !+ Number of points in boundary edge integer :: i real ( Float64 ) :: th , dth , x , y real ( Float64 ), dimension ( 4 ) :: xx , yy select case ( bplane % shape ) case ( 1 ) !Rectangular boundary nb = 4 if ( nb . gt . size ( bedge , 2 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(\"BOUNDARY_EDGE: Incompatible boundary edge array : \",i2,\" > \",i2)' ) nb , size ( bedge , 2 ) endif stop endif xx = [ - bplane % hw , - bplane % hw , bplane % hw , bplane % hw ] yy = [ - bplane % hh , bplane % hh , bplane % hh , - bplane % hh ] do i = 1 , nb bedge (:, i ) = matmul ( bplane % basis ,[ xx ( i ), yy ( i ), 0.d0 ]) + bplane % origin enddo case ( 2 ) nb = 50 if ( nb . gt . size ( bedge , 2 )) then if ( inputs % verbose . ge . 0 ) then write ( * , '(\"BOUNDARY_EDGE: Incompatible boundary edge array : \",i2,\" > \",i2)' ) nb , size ( bedge , 2 ) endif stop endif dth = 2 * pi / nb do i = 1 , nb th = i * dth x = bplane % hw * cos ( th ) y = bplane % hh * sin ( th ) bedge (:, i ) = matmul ( bplane % basis ,[ x , y , 0.d0 ]) + bplane % origin enddo case default if ( inputs % verbose . ge . 0 ) then write ( * , '(\"BOUNDARY_EDGE: Unknown boundary shape: \",i2)' ), bplane % shape endif stop end select end subroutine boundary_edge","tags":"","loc":"proc/boundary_edge.html","title":"boundary_edge – FIDASIM"},{"text":"public subroutine gyro_surface(fields, energy, pitch, gs) Calculates the surface of all possible trajectories Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: fields Electromagnetic fields at guiding center real(kind=Float64), intent(in) :: energy Energy of particle real(kind=Float64), intent(in) :: pitch Particle pitch w.r.t the magnetic field type( GyroSurface ), intent(out) :: gs Gyro-surface Called By proc~~gyro_surface~~CalledByGraph proc~gyro_surface gyro_surface proc~npa_f npa_f proc~npa_f->proc~gyro_surface proc~npa_mc npa_mc proc~npa_mc->proc~gyro_surface program~fidasim fidasim program~fidasim->proc~npa_f program~fidasim->proc~npa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code gyro_surface Source Code subroutine gyro_surface ( fields , energy , pitch , gs ) !+ Calculates the surface of all possible trajectories type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields at guiding center real ( Float64 ), intent ( in ) :: energy !+ Energy of particle real ( Float64 ), intent ( in ) :: pitch !+ Particle pitch w.r.t the magnetic field type ( GyroSurface ), intent ( out ) :: gs !+ Gyro-surface integer :: i real ( Float64 ) :: alpha , vabs , omega real ( Float64 ), dimension ( 3 , 3 ) :: s vabs = sqrt ( energy / ( v2_to_E_per_amu * inputs % ab )) omega = ( fields % b_abs * e0 ) / ( inputs % ab * mass_u ) alpha = vabs / omega gs % omega = omega gs % v = vabs gs % axes ( 1 ) = alpha * sqrt ( 1 - pitch ** 2 ) gs % axes ( 2 ) = alpha * sqrt ( 1 - pitch ** 2 ) gs % axes ( 3 ) = pitch * alpha s = 0.d0 s ( 1 , 1 ) = gs % axes ( 1 ) ** ( - 2 ) s ( 2 , 2 ) = gs % axes ( 2 ) ** ( - 2 ) s ( 3 , 3 ) = - gs % axes ( 3 ) ** ( - 2 ) gs % center = fields % pos gs % basis (:, 1 ) = fields % a_norm gs % basis (:, 2 ) = fields % c_norm gs % basis (:, 3 ) = fields % b_norm gs % A = matmul ( gs % basis , matmul ( s , transpose ( gs % basis ))) end subroutine gyro_surface","tags":"","loc":"proc/gyro_surface.html","title":"gyro_surface – FIDASIM"},{"text":"public subroutine line_gyro_surface_intersect(r0, v0, gs, t) Calculates the times of intersection of a line and a gyro-surface Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Point on line real(kind=Float64), intent(in), dimension(3) :: v0 Direction of line type( GyroSurface ), intent(in) :: gs Gyro-surface real(kind=Float64), intent(out), dimension(2) :: t \"time\" to intersect Called By proc~~line_gyro_surface_intersect~~CalledByGraph proc~line_gyro_surface_intersect line_gyro_surface_intersect proc~gyro_range gyro_range proc~gyro_range->proc~line_gyro_surface_intersect proc~npa_gyro_range npa_gyro_range proc~npa_gyro_range->proc~gyro_range proc~npa_f npa_f proc~npa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~npa_f program~fidasim->proc~npa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code line_gyro_surface_intersect Source Code subroutine line_gyro_surface_intersect ( r0 , v0 , gs , t ) !+ Calculates the times of intersection of a line and a gyro-surface real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Point on line real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Direction of line type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-surface real ( Float64 ), dimension ( 2 ), intent ( out ) :: t !+ \"time\" to intersect real ( Float64 ), dimension ( 3 ) :: rr real ( Float64 ) :: a , b , c , d , tp , tm rr = r0 - gs % center a = dot_product ( v0 , matmul ( gs % A , v0 )) b = dot_product ( rr , matmul ( gs % A , v0 )) + dot_product ( v0 , matmul ( gs % A , rr )) c = dot_product ( rr , matmul ( gs % A , rr )) - 1.0 d = b ** 2 - 4 * a * c if ( d . lt . 0.0 ) then t = 0.0 return endif t ( 1 ) = ( - b - sqrt ( d )) / ( 2 * a ) t ( 2 ) = ( - b + sqrt ( d )) / ( 2 * a ) end subroutine line_gyro_surface_intersect","tags":"","loc":"proc/line_gyro_surface_intersect.html","title":"line_gyro_surface_intersect – FIDASIM"},{"text":"public subroutine gyro_surface_coordinates(gs, p, u) Calculates the parametric coordinates, u , of point p on the gyro_surface Arguments Type Intent Optional Attributes Name type( GyroSurface ), intent(in) :: gs Gyro_surface real(kind=Float64), intent(in), dimension(3) :: p Point on gyro_surface real(kind=Float64), intent(out), dimension(2) :: u Parametric coordinates (gyro-angle, t) Called By proc~~gyro_surface_coordinates~~CalledByGraph proc~gyro_surface_coordinates gyro_surface_coordinates proc~gyro_range gyro_range proc~gyro_range->proc~gyro_surface_coordinates proc~npa_gyro_range npa_gyro_range proc~npa_gyro_range->proc~gyro_range proc~npa_f npa_f proc~npa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~npa_f program~fidasim->proc~npa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code gyro_surface_coordinates Source Code subroutine gyro_surface_coordinates ( gs , p , u ) !+ Calculates the parametric coordinates, `u`, of point `p` on the gyro_surface type ( GyroSurface ), intent ( in ) :: gs !+ Gyro_surface real ( Float64 ), dimension ( 3 ), intent ( in ) :: p !+ Point on gyro_surface real ( Float64 ), dimension ( 2 ), intent ( out ) :: u !+ Parametric coordinates (gyro-angle, t) real ( Float64 ), dimension ( 3 ) :: pp real ( Float64 ) :: t , a , b , c , d , thm , thp , dp , dm , th integer :: i pp = matmul ( transpose ( gs % basis ), p - gs % center ) t = pp ( 3 ) / gs % axes ( 3 ) a = gs % axes ( 1 ) + gs % axes ( 2 ) * t b = gs % axes ( 2 ) - gs % axes ( 1 ) * t d = pp ( 1 ) + pp ( 2 ) c = max ( min ( d / sqrt ( a ** 2 + b ** 2 ), 1.d0 ), - 1.d0 ) thm = - acos ( c ) + atan2 ( b , a ) thp = acos ( c ) + atan2 ( b , a ) dm = norm2 ([ gs % axes ( 1 ) * ( cos ( thm ) - t * sin ( thm )), & gs % axes ( 2 ) * ( sin ( thm ) + t * cos ( thm )), & gs % axes ( 3 ) * t ] - pp ) dp = norm2 ([ gs % axes ( 1 ) * ( cos ( thp ) - t * sin ( thp )), & gs % axes ( 2 ) * ( sin ( thp ) + t * cos ( thp )), & gs % axes ( 3 ) * t ] - pp ) th = thm - pi / 2 if ( dp . le . dm ) th = thp - pi / 2 if ( th . lt . 0.0 ) th = th + 2 * pi u = [ th , t / gs % omega ] end subroutine gyro_surface_coordinates","tags":"","loc":"proc/gyro_surface_coordinates.html","title":"gyro_surface_coordinates – FIDASIM"},{"text":"public subroutine gyro_trajectory(gs, theta, ri, vi) Calculate particle trajectory for a given gyro-angle and gyro-surface Arguments Type Intent Optional Attributes Name type( GyroSurface ), intent(in) :: gs Gyro-Surface real(kind=Float64), intent(in) :: theta Gyro-angle real(kind=Float64), dimension(3) :: ri Particle position real(kind=Float64), dimension(3) :: vi Particle Velocity Called By proc~~gyro_trajectory~~CalledByGraph proc~gyro_trajectory gyro_trajectory proc~npa_f npa_f proc~npa_f->proc~gyro_trajectory proc~npa_mc npa_mc proc~npa_mc->proc~gyro_trajectory program~fidasim fidasim program~fidasim->proc~npa_f program~fidasim->proc~npa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code gyro_trajectory Source Code subroutine gyro_trajectory ( gs , theta , ri , vi ) !+ Calculate particle trajectory for a given gyro-angle and gyro-surface type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-Surface real ( Float64 ), intent ( in ) :: theta !+ Gyro-angle real ( Float64 ), dimension ( 3 ) :: ri !+ Particle position real ( Float64 ), dimension ( 3 ) :: vi !+ Particle Velocity real ( Float64 ) :: a , b , c , th a = gs % axes ( 1 ) b = gs % axes ( 2 ) c = gs % axes ( 3 ) th = theta + pi / 2 ri = matmul ( gs % basis , [ a * cos ( th ), b * sin ( th ), 0.d0 ]) + gs % center vi = gs % omega * matmul ( gs % basis , [ - a * sin ( th ), b * cos ( th ), c ]) end subroutine gyro_trajectory","tags":"","loc":"proc/gyro_trajectory.html","title":"gyro_trajectory – FIDASIM"},{"text":"public subroutine gyro_range(b, gs, gyrange, nrange) Calculates the range(s) of gyro-angles that would land within a bounded plane Arguments Type Intent Optional Attributes Name type( BoundedPlane ), intent(in) :: b Bounded Plane type( GyroSurface ), intent(in) :: gs Gyro-surface real(kind=Float64), intent(out), dimension(2,4) :: gyrange (theta, dtheta) values integer, intent(out) :: nrange Number of ranges. 1 <= nrange <= 4 Calls proc~~gyro_range~~CallsGraph proc~gyro_range gyro_range proc~boundary_edge boundary_edge proc~gyro_range->proc~boundary_edge proc~line_gyro_surface_intersect line_gyro_surface_intersect proc~gyro_range->proc~line_gyro_surface_intersect proc~gyro_surface_coordinates gyro_surface_coordinates proc~gyro_range->proc~gyro_surface_coordinates proc~in_gyro_surface in_gyro_surface proc~gyro_range->proc~in_gyro_surface proc~line_plane_intersect line_plane_intersect proc~gyro_range->proc~line_plane_intersect proc~in_boundary in_boundary proc~gyro_range->proc~in_boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~gyro_range~~CalledByGraph proc~gyro_range gyro_range proc~npa_gyro_range npa_gyro_range proc~npa_gyro_range->proc~gyro_range proc~npa_f npa_f proc~npa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~npa_f program~fidasim->proc~npa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code gyro_range Source Code subroutine gyro_range ( b , gs , gyrange , nrange ) !+ Calculates the range(s) of gyro-angles that would land within a bounded plane type ( BoundedPlane ), intent ( in ) :: b !+ Bounded Plane type ( GyroSurface ), intent ( in ) :: gs !+ Gyro-surface real ( Float64 ), dimension ( 2 , 4 ), intent ( out ) :: gyrange !+ (theta, dtheta) values integer , intent ( out ) :: nrange !+ Number of ranges. `1 <= nrange <= 4` integer :: nb , i , j , ninter logical :: in_gs , bin_gs logical , dimension ( 8 ) :: cross = . False . real ( Float64 ) :: t_p , th1 , th2 , dth real ( Float64 ), dimension ( 2 ) :: u_cur , t_i real ( Float64 ), dimension ( 3 ) :: rc , p_pre , p_cur , v0 , ri real ( Float64 ), dimension ( 2 , 8 ) :: u real ( Float64 ), dimension ( 3 , 50 ) :: bedge nrange = 0 call line_plane_intersect ( gs % center , gs % basis (:, 3 ), b % origin , b % basis (:, 3 ), rc , t_p ) if ( t_p . eq . 0.0 ) return call boundary_edge ( b , bedge , nb ) p_pre = bedge (:, 1 ) in_gs = in_gyro_surface ( gs , p_pre ) bin_gs = . False . ninter = 0 u = 0.d0 boundary_loop : do i = 1 , nb p_cur = bedge (:, modulo ( i , nb ) + 1 ) v0 = p_cur - p_pre call line_gyro_surface_intersect ( p_pre , v0 , gs , t_i ) do j = 1 , 2 if (( t_i ( j ). gt . 0.0 ). and .( t_i ( j ). lt . 1.0 )) then ri = p_pre + t_i ( j ) * v0 call gyro_surface_coordinates ( gs , ri , u_cur ) if ( u_cur ( 2 ). gt . 0.0 ) then in_gs = . not . in_gs ninter = ninter + 1 cross ( ninter ) = in_gs u (:, ninter ) = u_cur endif endif enddo p_pre = p_cur enddo boundary_loop gyrange = 0.d0 if (( ninter . eq . 0 ). and .(. not . bin_gs )) then if ( in_boundary ( b , rc )) then nrange = 1 gyrange (:, 1 ) = [ 0.d0 , 2 * pi ] endif return endif do i = 1 , ninter if ( cross ( i )) then th1 = u ( 1 , i ) j = modulo ( i , ninter ) + 1 th2 = u ( 1 , j ) dth = th2 - th1 nrange = nrange + 1 if ( dth . gt . 0.0 ) then gyrange (:, nrange ) = [ th1 , dth ] else gyrange (:, nrange ) = [ th2 , - dth ] endif endif enddo end subroutine gyro_range","tags":"","loc":"proc/gyro_range.html","title":"gyro_range – FIDASIM"},{"text":"public subroutine npa_gyro_range(ichan, gs, gyrange, nrange) Calculates range of gyro-angles that would hit the NPA detector Arguments Type Intent Optional Attributes Name integer, intent(in) :: ichan Index of NPA detector type( GyroSurface ), intent(in) :: gs real(kind=Float64), intent(out), dimension(2,4) :: gyrange integer, intent(out) :: nrange Calls proc~~npa_gyro_range~~CallsGraph proc~npa_gyro_range npa_gyro_range proc~gyro_range gyro_range proc~npa_gyro_range->proc~gyro_range proc~approx_eq approx_eq proc~npa_gyro_range->proc~approx_eq proc~boundary_edge boundary_edge proc~gyro_range->proc~boundary_edge proc~line_gyro_surface_intersect line_gyro_surface_intersect proc~gyro_range->proc~line_gyro_surface_intersect proc~gyro_surface_coordinates gyro_surface_coordinates proc~gyro_range->proc~gyro_surface_coordinates proc~in_gyro_surface in_gyro_surface proc~gyro_range->proc~in_gyro_surface proc~line_plane_intersect line_plane_intersect proc~gyro_range->proc~line_plane_intersect proc~in_boundary in_boundary proc~gyro_range->proc~in_boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~npa_gyro_range~~CalledByGraph proc~npa_gyro_range npa_gyro_range proc~npa_f npa_f proc~npa_f->proc~npa_gyro_range proc~npa_mc npa_mc proc~npa_mc->proc~npa_gyro_range program~fidasim fidasim program~fidasim->proc~npa_f program~fidasim->proc~npa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code npa_gyro_range Source Code subroutine npa_gyro_range ( ichan , gs , gyrange , nrange ) !+ Calculates range of gyro-angles that would hit the NPA detector integer , intent ( in ) :: ichan !+ Index of NPA detector type ( GyroSurface ), intent ( in ) :: gs real ( Float64 ), dimension ( 2 , 4 ), intent ( out ) :: gyrange integer , intent ( out ) :: nrange type ( LocalEMFields ) :: fields integer :: i , j , a_nrange , d_nrange real ( Float64 ) :: a0 , a , b , c , d real ( Float64 ), dimension ( 2 , 4 ) :: a_gyrange , d_gyrange nrange = 0 gyrange = 0.d0 call gyro_range ( npa_chords % det ( ichan )% aperture , gs , a_gyrange , a_nrange ) if ( a_nrange . eq . 0 ) return call gyro_range ( npa_chords % det ( ichan )% detector , gs , d_gyrange , d_nrange ) if ( d_nrange . eq . 0 ) return if (( a_nrange . eq . 1 ). and . approx_eq ( a_gyrange ( 2 , 1 ), 2 * pi , 1 d - 6 )) then gyrange = d_gyrange nrange = d_nrange return endif if (( d_nrange . eq . 1 ). and . approx_eq ( d_gyrange ( 2 , 1 ), 2 * pi , 1 d - 6 )) then gyrange = a_gyrange nrange = a_nrange return endif do i = 1 , a_nrange do j = 1 , d_nrange a0 = 0.d0 if ( d_gyrange ( 1 , j ). gt . a_gyrange ( 1 , i )) then a0 = a_gyrange ( 1 , i ) a = 0.d0 b = modulo ( a_gyrange ( 1 , i ) + a_gyrange ( 2 , i ) - a0 , 2 * pi ) c = modulo ( d_gyrange ( 1 , j ) - a0 , 2 * pi ) d = modulo ( d_gyrange ( 1 , j ) + d_gyrange ( 2 , j ) - a0 , 2 * pi ) else a0 = d_gyrange ( 1 , j ) a = 0.d0 b = modulo ( d_gyrange ( 1 , j ) + d_gyrange ( 2 , j ) - a0 , 2 * pi ) c = modulo ( a_gyrange ( 1 , i ) - a0 , 2 * pi ) d = modulo ( a_gyrange ( 1 , i ) + a_gyrange ( 2 , i ) - a0 , 2 * pi ) endif if (( c . lt . b ). or .( d . lt . c )) then if ( c . lt . d ) then nrange = nrange + 1 gyrange (:, nrange ) = [ a0 + c , min ( d - c , b - c )] else nrange = nrange + 1 gyrange (:, nrange ) = [ a0 , d ] nrange = nrange + 1 gyrange (:, nrange ) = [ a0 + c , b - c ] endif endif enddo enddo end subroutine npa_gyro_range","tags":"","loc":"proc/npa_gyro_range.html","title":"npa_gyro_range – FIDASIM"},{"text":"public subroutine hit_npa_detector(r0, v0, d_index, rd, det) Routine to check if a particle will hit a NPA detector Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Starting point of particle real(kind=Float64), intent(in), dimension(3) :: v0 Particle velocity integer, intent(out) :: d_index Index of NPA detector. Zero if particle doesn't hit real(kind=Float64), intent(out), optional dimension(3) :: rd Point where particle hit detector integer, intent(in), optional :: det Index of NPA detector to check Calls proc~~hit_npa_detector~~CallsGraph proc~hit_npa_detector hit_npa_detector proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector->proc~line_plane_intersect proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~hit_npa_detector~~CalledByGraph proc~hit_npa_detector hit_npa_detector proc~npa_mc npa_mc proc~npa_mc->proc~hit_npa_detector proc~read_npa read_npa proc~read_npa->proc~hit_npa_detector proc~npa_weights npa_weights proc~npa_weights->proc~hit_npa_detector proc~npa_f npa_f proc~npa_f->proc~hit_npa_detector program~fidasim fidasim program~fidasim->proc~npa_mc program~fidasim->proc~read_npa program~fidasim->proc~npa_weights program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code hit_npa_detector Source Code subroutine hit_npa_detector ( r0 , v0 , d_index , rd , det ) !+ Routine to check if a particle will hit a NPA detector real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Starting point of particle real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Particle velocity integer , intent ( out ) :: d_index !+ Index of NPA detector. Zero if particle doesn't hit real ( Float64 ), dimension ( 3 ), intent ( out ), optional :: rd !+ Point where particle hit detector integer , intent ( in ), optional :: det !+ Index of NPA detector to check real ( Float64 ), dimension ( 3 ) :: d , a real ( Float64 ) :: t_a , t_d integer :: i , s , ndet if ( present ( det )) then s = det ndet = det else s = 1 ndet = npa_chords % nchan endif d_index = 0 detector_loop : do i = s , ndet !! Find where trajectory crosses detector plane call line_plane_intersect ( r0 , v0 , npa_chords % det ( i )% detector % origin , & npa_chords % det ( i )% detector % basis (:, 3 ), d , t_d ) !! Find where trajectory crosses aperture plane call line_plane_intersect ( r0 , v0 , npa_chords % det ( i )% aperture % origin , & npa_chords % det ( i )% aperture % basis (:, 3 ), a , t_a ) !! If both points are in plane boundaries and the !! particle is heading toward the detector then its a hit if ( in_boundary ( npa_chords % det ( i )% aperture , a ) . and . & in_boundary ( npa_chords % det ( i )% detector , d ) . and . & ( t_d . gt . 0.0 ) ) then d_index = i exit detector_loop endif enddo detector_loop if ( present ( rd )) rd = d end subroutine hit_npa_detector","tags":"","loc":"proc/hit_npa_detector.html","title":"hit_npa_detector – FIDASIM"},{"text":"public subroutine xyz_to_uvw(xyz, uvw) Convert beam coordinate xyz to machine coordinate uvw Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: xyz real(kind=Float64), intent(out), dimension(3) :: uvw Called By proc~~xyz_to_uvw~~CalledByGraph proc~xyz_to_uvw xyz_to_uvw proc~get_ep_denf get_ep_denf proc~get_ep_denf->proc~xyz_to_uvw proc~in_plasma in_plasma proc~in_plasma->proc~xyz_to_uvw proc~write_birth_profile write_birth_profile proc~write_birth_profile->proc~xyz_to_uvw proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~store_npa store_npa proc~store_npa->proc~xyz_to_uvw proc~get_fields get_fields proc~store_npa->proc~get_fields proc~write_beam_grid->proc~xyz_to_uvw proc~get_distribution get_distribution proc~get_distribution->proc~xyz_to_uvw proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~get_plasma get_plasma proc~fida_weights_mc->proc~get_plasma proc~track track proc~fida_weights_mc->proc~track proc~fida_weights_mc->proc~get_fields proc~get_beam_cx_prob get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~npa_weights npa_weights proc~npa_weights->proc~get_ep_denf proc~npa_weights->proc~get_fields proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~write_npa_weights write_npa_weights proc~npa_weights->proc~write_npa_weights proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~track proc~fida_weights_los->proc~get_fields proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_los proc~ndmc ndmc program~fidasim->proc~ndmc proc~fida_f fida_f program~fidasim->proc~fida_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~dcx dcx program~fidasim->proc~dcx proc~halo halo program~fidasim->proc~halo proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~read_chords read_chords program~fidasim->proc~read_chords proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~read_npa read_npa program~fidasim->proc~read_npa proc~write_neutrals write_neutrals program~fidasim->proc~write_neutrals proc~write_dcx write_dcx program~fidasim->proc~write_dcx proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~get_plasma->proc~in_plasma proc~track->proc~in_plasma proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~get_fields->proc~in_plasma proc~ndmc->proc~mc_nbi proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~store_bes_photons store_bes_photons proc~ndmc->proc~store_bes_photons proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~fida_f->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_f->proc~store_fida_photons proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~neutron_mc->proc~get_plasma proc~neutron_mc->proc~get_fields proc~npa_f->proc~store_npa proc~npa_f->proc~get_plasma proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~npa_f->proc~mc_fastion proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~halo->proc~store_bes_photons proc~mc_halo->proc~get_plasma proc~attenuate->proc~get_plasma proc~bremsstrahlung->proc~get_plasma proc~neutron_f->proc~get_plasma proc~neutron_f->proc~get_fields proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~store_fida_photons proc~get_beam_cx_prob->proc~mc_halo proc~npa_mc->proc~store_npa proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~read_chords->proc~track proc~read_distribution->proc~read_mc proc~store_fida_photons->proc~get_fields proc~read_npa->proc~get_fields proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~mc_fastion->proc~get_distribution proc~mc_fastion->proc~get_fields proc~write_neutrals->proc~write_beam_grid proc~write_npa_weights->proc~write_beam_grid proc~write_dcx->proc~write_beam_grid var panprocxyz_to_uvwCalledByGraph = svgPanZoom('#procxyz_to_uvwCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code xyz_to_uvw Source Code subroutine xyz_to_uvw ( xyz , uvw ) !+ Convert beam coordinate `xyz` to machine coordinate `uvw` real ( Float64 ), dimension ( 3 ), intent ( in ) :: xyz real ( Float64 ), dimension ( 3 ), intent ( out ) :: uvw real ( Float64 ), dimension ( 3 ) :: origin real ( Float64 ), dimension ( 3 , 3 ) :: basis origin = beam_grid % origin basis = beam_grid % basis uvw = matmul ( basis , xyz ) uvw = uvw + origin end subroutine xyz_to_uvw","tags":"","loc":"proc/xyz_to_uvw.html","title":"xyz_to_uvw – FIDASIM"},{"text":"public subroutine uvw_to_xyz(uvw, xyz) Convert machine coordinate uvw to beam coordinate xyz Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: uvw real(kind=Float64), intent(out), dimension(3) :: xyz Called By proc~~uvw_to_xyz~~CalledByGraph proc~uvw_to_xyz uvw_to_xyz proc~fida_mc fida_mc proc~fida_mc->proc~uvw_to_xyz proc~read_npa read_npa proc~read_npa->proc~uvw_to_xyz proc~read_chords read_chords proc~read_chords->proc~uvw_to_xyz proc~npa_mc npa_mc proc~npa_mc->proc~uvw_to_xyz proc~read_mc read_mc proc~read_mc->proc~uvw_to_xyz proc~neutron_f neutron_f proc~neutron_f->proc~uvw_to_xyz proc~read_beam read_beam proc~read_beam->proc~uvw_to_xyz proc~neutron_mc neutron_mc proc~neutron_mc->proc~uvw_to_xyz program~fidasim fidasim program~fidasim->proc~fida_mc program~fidasim->proc~read_npa program~fidasim->proc~read_chords program~fidasim->proc~npa_mc program~fidasim->proc~neutron_f program~fidasim->proc~read_beam program~fidasim->proc~neutron_mc proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~read_distribution->proc~read_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code uvw_to_xyz Source Code subroutine uvw_to_xyz ( uvw , xyz ) !+ Convert machine coordinate `uvw` to beam coordinate `xyz` real ( Float64 ), dimension ( 3 ), intent ( in ) :: uvw real ( Float64 ), dimension ( 3 ), intent ( out ) :: xyz real ( Float64 ), dimension ( 3 ) :: origin , uvw_p real ( Float64 ), dimension ( 3 , 3 ) :: basis origin = beam_grid % origin basis = beam_grid % inv_basis uvw_p = uvw - origin xyz = matmul ( basis , uvw_p ) end subroutine uvw_to_xyz","tags":"","loc":"proc/uvw_to_xyz.html","title":"uvw_to_xyz – FIDASIM"},{"text":"public subroutine grid_intersect(r0, v0, length, r_enter, r_exit, center_in, lwh_in) Calculates a particles intersection length with the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Initial position of particle [cm] real(kind=Float64), intent(in), dimension(3) :: v0 Velocity of particle [cm/s] real(kind=Float64), intent(out) :: length Intersection length [cm] real(kind=Float64), intent(out), dimension(3) :: r_enter Point where particle enters beam_grid real(kind=Float64), intent(out), dimension(3) :: r_exit Point where particle exits beam_grid real(kind=Float64), intent(in), optional dimension(3) :: center_in Alternative grid center real(kind=Float64), intent(in), optional dimension(3) :: lwh_in Alternative grid [length,width,height] Called By proc~~grid_intersect~~CalledByGraph proc~grid_intersect grid_intersect proc~mc_nbi mc_nbi proc~mc_nbi->proc~grid_intersect proc~read_chords read_chords proc~read_chords->proc~grid_intersect proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~grid_intersect proc~circle_grid_intersect circle_grid_intersect proc~circle_grid_intersect->proc~grid_intersect proc~read_npa read_npa proc~read_npa->proc~grid_intersect proc~ndmc ndmc proc~ndmc->proc~mc_nbi program~fidasim fidasim program~fidasim->proc~read_chords program~fidasim->proc~fida_weights_los program~fidasim->proc~read_npa program~fidasim->proc~ndmc proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~read_mc read_mc proc~read_mc->proc~circle_grid_intersect proc~read_distribution->proc~read_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code grid_intersect Source Code subroutine grid_intersect ( r0 , v0 , length , r_enter , r_exit , center_in , lwh_in ) !+ Calculates a particles intersection length with the [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Initial position of particle [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: v0 !+ Velocity of particle [cm/s] real ( Float64 ), intent ( out ) :: length !+ Intersection length [cm] real ( Float64 ), dimension ( 3 ), intent ( out ) :: r_enter !+ Point where particle enters [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( out ) :: r_exit !+ Point where particle exits [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: center_in !+ Alternative grid center real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: lwh_in !+ Alternative grid [length,width,height] real ( Float64 ), dimension ( 3 , 6 ) :: ipnts real ( Float64 ), dimension ( 3 ) :: vi real ( Float64 ), dimension ( 3 ) :: center real ( Float64 ), dimension ( 3 ) :: lwh integer , dimension ( 6 ) :: side_inter integer , dimension ( 2 ) :: ind integer :: i , j , nunique , ind1 , ind2 if ( present ( center_in )) then center = center_in else center = beam_grid % center endif if ( present ( lwh_in )) then lwh = lwh_in else lwh = beam_grid % lwh endif side_inter = 0 ipnts = 0.d0 do i = 1 , 6 j = int ( ceiling ( i / 2.0 )) if ( j . eq . 1 ) ind = [ 2 , 3 ] if ( j . eq . 2 ) ind = [ 1 , 3 ] if ( j . eq . 3 ) ind = [ 1 , 2 ] if ( abs ( v0 ( j )). gt . 0.d0 ) then ipnts (:, i ) = r0 + v0 * ( ( ( center ( j ) + & ( mod ( i , 2 ) - 0.5 ) * lwh ( j )) - r0 ( j )) / v0 ( j ) ) if (( abs ( ipnts ( ind ( 1 ), i ) - center ( ind ( 1 ))). le .( 0.5 * lwh ( ind ( 1 )))). and . & ( abs ( ipnts ( ind ( 2 ), i ) - center ( ind ( 2 ))). le .( 0.5 * lwh ( ind ( 2 ))))) then side_inter ( i ) = 1 endif endif enddo length = 0.d0 r_enter = r0 r_exit = r0 ind1 = 0 ind2 = 0 if ( sum ( side_inter ). ge . 2 ) then ! Find first intersection side i = 1 do while ( i . le . 6 ) if ( side_inter ( i ). eq . 1 ) exit i = i + 1 enddo ind1 = i !Find number of unique points nunique = 0 do i = ind1 + 1 , 6 if ( side_inter ( i ). ne . 1 ) cycle if ( sqrt ( sum ( ( ipnts (:, i ) - ipnts (:, ind1 ) ) ** 2 ) ). gt . 0.001 ) then ind2 = i nunique = 2 exit endif enddo if ( nunique . eq . 2 ) then vi = ipnts (:, ind2 ) - ipnts (:, ind1 ) if ( dot_product ( v0 , vi ). gt . 0.0 ) then r_enter = ipnts (:, ind1 ) r_exit = ipnts (:, ind2 ) else r_enter = ipnts (:, ind2 ) r_exit = ipnts (:, ind1 ) endif length = sqrt ( sum (( r_exit - r_enter ) ** 2 )) endif endif end subroutine grid_intersect","tags":"","loc":"proc/grid_intersect.html","title":"grid_intersect – FIDASIM"},{"text":"public subroutine circle_grid_intersect(r0, e1, e2, radius, phi_enter, phi_exit) Calculates the intersection arclength of a circle with the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Position of center enter of the circle in beam grid coordinates [cm] real(kind=Float64), intent(in), dimension(3) :: e1 Unit vector pointing towards (R, 0) (r,phi) position of the circle in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: e2 Unit vector pointing towards (R, pi/2) (r,phi) position of the circle in beam grid coordinates real(kind=Float64), intent(in) :: radius Radius of circle [cm] real(kind=Float64), intent(out) :: phi_enter Phi value where the circle entered the beam_grid [rad] real(kind=Float64), intent(out) :: phi_exit Phi value where the circle exits the beam_grid [rad] Calls proc~~circle_grid_intersect~~CallsGraph proc~circle_grid_intersect circle_grid_intersect proc~in_grid in_grid proc~circle_grid_intersect->proc~in_grid proc~grid_intersect grid_intersect proc~circle_grid_intersect->proc~grid_intersect proc~approx_eq approx_eq proc~circle_grid_intersect->proc~approx_eq proc~approx_ge approx_ge proc~in_grid->proc~approx_ge proc~approx_le approx_le proc~in_grid->proc~approx_le proc~approx_ge->proc~approx_eq proc~approx_le->proc~approx_eq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~circle_grid_intersect~~CalledByGraph proc~circle_grid_intersect circle_grid_intersect proc~read_mc read_mc proc~read_mc->proc~circle_grid_intersect proc~read_distribution read_distribution proc~read_distribution->proc~read_mc program~fidasim fidasim program~fidasim->proc~read_distribution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code circle_grid_intersect Source Code subroutine circle_grid_intersect ( r0 , e1 , e2 , radius , phi_enter , phi_exit ) !+ Calculates the intersection arclength of a circle with the [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: r0 !+ Position of center enter of the circle in beam grid coordinates [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: e1 !+ Unit vector pointing towards (R, 0) (r,phi) position of the circle in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: e2 !+ Unit vector pointing towards (R, pi/2) (r,phi) position of the circle in beam grid coordinates real ( Float64 ), intent ( in ) :: radius !+ Radius of circle [cm] real ( Float64 ), intent ( out ) :: phi_enter !+ Phi value where the circle entered the [[libfida:beam_grid]] [rad] real ( Float64 ), intent ( out ) :: phi_exit !+ Phi value where the circle exits the [[libfida:beam_grid]] [rad] real ( Float64 ), dimension ( 3 ) :: i1_p , i1_n , i2_p , i2_n real ( Float64 ), dimension ( 4 ) :: d real ( Float64 ), dimension ( 6 ) :: p , gams real ( Float64 ), dimension ( 4 , 6 ) :: phi logical , dimension ( 4 , 6 ) :: inter integer , dimension ( 6 ) :: n integer :: i real ( Float64 ) :: alpha , beta , delta , sinx1 , cosx1 , sinx2 , cosx2 , tmp real ( Float64 ) :: tol = 1.0d-10 logical :: r0_ing p = [ beam_grid % xmin , beam_grid % xmax , & beam_grid % ymin , beam_grid % ymax , & beam_grid % zmin , beam_grid % zmax ] n = [ 1 , 1 , 2 , 2 , 3 , 3 ] inter = . False . phi = 0.d0 r0_ing = in_grid ( r0 ) do i = 1 , 6 alpha = e2 ( n ( i )) beta = e1 ( n ( i )) if (( alpha . eq . 0.0 ). and .( beta . eq . 0.0 )) cycle gams ( i ) = ( p ( i ) - r0 ( n ( i ))) / radius delta = alpha ** 4 + ( alpha ** 2 ) * ( beta ** 2 - gams ( i ) ** 2 ) if ( delta . ge . 0.0 ) then cosx1 = ( gams ( i ) * beta + sqrt ( delta )) / ( alpha ** 2 + beta ** 2 ) if (( cosx1 ** 2 ). le . 1.0 ) then sinx1 = sqrt ( 1 - cosx1 ** 2 ) i1_p = r0 + radius * cosx1 * e1 + radius * sinx1 * e2 i1_n = r0 + radius * cosx1 * e1 - radius * sinx1 * e2 if ( approx_eq ( i1_p ( n ( i )), p ( i ), tol ). and . in_grid ( i1_p )) then inter ( 1 , i ) = . True . phi ( 1 , i ) = atan2 ( sinx1 , cosx1 ) endif if ( approx_eq ( i1_n ( n ( i )), p ( i ), tol ). and . in_grid ( i1_n )) then inter ( 2 , i ) = . True . phi ( 2 , i ) = atan2 ( - sinx1 , cosx1 ) endif endif if ( delta . gt . 0.0 ) then cosx2 = ( gams ( i ) * beta - sqrt ( delta )) / ( alpha ** 2 + beta ** 2 ) if (( cosx2 ** 2 ). le . 1.0 ) then sinx2 = sqrt ( 1 - cosx2 ** 2 ) i2_p = r0 + radius * cosx2 * e1 + radius * sinx2 * e2 i2_n = r0 + radius * cosx2 * e1 - radius * sinx2 * e2 if ( approx_eq ( i2_p ( n ( i )), p ( i ), tol ). and . in_grid ( i2_p )) then inter ( 3 , i ) = . True . phi ( 3 , i ) = atan2 ( sinx2 , cosx2 ) endif if ( approx_eq ( i2_n ( n ( i )), p ( i ), tol ). and . in_grid ( i2_n )) then inter ( 4 , i ) = . True . phi ( 4 , i ) = atan2 ( - sinx2 , cosx2 ) endif endif endif endif enddo phi_enter = 0.d0 phi_exit = 0.d0 if ( count ( inter ). gt . 2 ) return if ( any ( inter )) then phi_enter = minval ( phi , inter ) phi_exit = maxval ( phi , inter ) if ( r0_ing . and . any ( count ( inter , 1 ). ge . 2 )) then if (( phi_exit - phi_enter ) . lt . pi ) then tmp = phi_enter phi_enter = phi_exit phi_exit = tmp + 2 * pi endif else if (( phi_exit - phi_enter ) . gt . pi ) then tmp = phi_enter phi_enter = phi_exit phi_exit = tmp + 2 * pi endif endif if ( approx_eq ( phi_exit - phi_enter , pi , tol ). and . r0_ing ) then phi_enter = 0.0 phi_exit = 2 * pi endif else if ( r0_ing ) then call grid_intersect ( r0 , e1 , tmp , i1_n , i1_p ) call grid_intersect ( r0 , e2 , tmp , i2_n , i2_p ) d ( 1 ) = norm2 ( r0 - i1_n ) / radius d ( 2 ) = norm2 ( r0 - i1_p ) / radius d ( 3 ) = norm2 ( r0 - i2_n ) / radius d ( 4 ) = norm2 ( r0 - i2_p ) / radius if ( all ( d . ge . 1.0 )) then phi_enter = 0.d0 phi_exit = 2.d0 * pi endif endif endif end subroutine circle_grid_intersect","tags":"","loc":"proc/circle_grid_intersect.html","title":"circle_grid_intersect – FIDASIM"},{"text":"public subroutine get_indices(pos, ind) Find closests beam_grid indices ind to position pos Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position [cm] integer(kind=Int32), intent(out), dimension(3) :: ind Closest indices to position Called By proc~~get_indices~~CalledByGraph proc~get_indices get_indices proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_indices proc~track track proc~track->proc~get_indices proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~get_indices proc~npa_mc npa_mc proc~npa_mc->proc~get_indices proc~npa_f npa_f proc~npa_f->proc~get_indices proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~get_indices proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~store_fw_photons proc~fida_weights_mc->proc~track program~fidasim fidasim program~fidasim->proc~npa_mc program~fidasim->proc~npa_f program~fidasim->proc~fida_weights_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~read_chords read_chords program~fidasim->proc~read_chords proc~halo halo program~fidasim->proc~halo proc~dcx dcx program~fidasim->proc~dcx proc~ndmc ndmc program~fidasim->proc~ndmc proc~fida_f->proc~track proc~fida_f->proc~store_fida_photons proc~fida_mc->proc~track proc~fida_mc->proc~store_fida_photons proc~fida_weights_los->proc~track proc~read_chords->proc~track proc~halo->proc~track proc~halo->proc~store_bes_photons proc~dcx->proc~track proc~dcx->proc~store_bes_photons proc~ndmc->proc~track proc~ndmc->proc~store_bes_photons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_indices Source Code subroutine get_indices ( pos , ind ) !+ Find closests [[libfida:beam_grid]] indices `ind` to position `pos` real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position [cm] integer ( Int32 ), dimension ( 3 ), intent ( out ) :: ind !+ Closest indices to position real ( Float64 ), dimension ( 3 ) :: mini integer ( Int32 ), dimension ( 3 ) :: maxind integer :: i maxind ( 1 ) = beam_grid % nx maxind ( 2 ) = beam_grid % ny maxind ( 3 ) = beam_grid % nz mini ( 1 ) = minval ( beam_grid % xc ) - 0.5 * beam_grid % dr ( 1 ) mini ( 2 ) = minval ( beam_grid % yc ) - 0.5 * beam_grid % dr ( 2 ) mini ( 3 ) = minval ( beam_grid % zc ) - 0.5 * beam_grid % dr ( 3 ) do i = 1 , 3 ind ( i ) = floor (( pos ( i ) - mini ( i )) / beam_grid % dr ( i )) + 1 if ( ind ( i ). gt . maxind ( i )) ind ( i ) = maxind ( i ) if ( ind ( i ). lt . 1 ) ind ( i ) = 1 enddo end subroutine get_indices","tags":"","loc":"proc/get_indices.html","title":"get_indices – FIDASIM"},{"text":"public subroutine get_position(ind, pos) Get position pos given beam_grid indices ind Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind beam_grid indices real(kind=Float64), intent(out), dimension(3) :: pos Position [cm] Called By proc~~get_position~~CalledByGraph proc~get_position get_position proc~get_ep_denf get_ep_denf proc~get_ep_denf->proc~get_position proc~get_plasma get_plasma proc~get_plasma->proc~get_position proc~get_fields get_fields proc~get_fields->proc~get_position proc~get_distribution get_distribution proc~get_distribution->proc~get_position proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~get_fields proc~get_beam_cx_prob get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~npa_weights npa_weights proc~npa_weights->proc~get_ep_denf proc~npa_weights->proc~get_fields proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~get_fields proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_los proc~fida_f fida_f program~fidasim->proc~fida_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~ndmc ndmc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~dcx dcx program~fidasim->proc~dcx proc~halo halo program~fidasim->proc~halo proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~read_npa read_npa program~fidasim->proc~read_npa proc~fida_f->proc~get_plasma proc~fida_f->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_f->proc~store_fida_photons proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~neutron_mc->proc~get_plasma proc~neutron_mc->proc~get_fields proc~ndmc->proc~get_plasma proc~store_bes_photons store_bes_photons proc~ndmc->proc~store_bes_photons proc~npa_f->proc~get_plasma proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~store_npa store_npa proc~npa_f->proc~store_npa proc~npa_f->proc~mc_fastion proc~dcx->proc~get_plasma proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~halo->proc~get_plasma proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~halo->proc~store_bes_photons proc~mc_halo->proc~get_plasma proc~attenuate->proc~get_plasma proc~bremsstrahlung->proc~get_plasma proc~neutron_f->proc~get_plasma proc~neutron_f->proc~get_fields proc~fida_mc->proc~get_plasma proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~store_fida_photons proc~get_beam_cx_prob->proc~mc_halo proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~store_npa proc~store_fida_photons->proc~get_fields proc~read_npa->proc~get_fields proc~store_npa->proc~get_fields proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~mc_fastion->proc~get_fields proc~mc_fastion->proc~get_distribution var panprocget_positionCalledByGraph = svgPanZoom('#procget_positionCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_position Source Code subroutine get_position ( ind , pos ) !+ Get position `pos` given [[libfida:beam_grid]] indices `ind` integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices real ( Float64 ), dimension ( 3 ), intent ( out ) :: pos !+ Position [cm] pos ( 1 ) = beam_grid % xc ( ind ( 1 )) pos ( 2 ) = beam_grid % yc ( ind ( 2 )) pos ( 3 ) = beam_grid % zc ( ind ( 3 )) end subroutine get_position","tags":"","loc":"proc/get_position.html","title":"get_position – FIDASIM"},{"text":"public subroutine track(rin, vin, tracks, ncell, los_intersect) Computes the path of a neutral through the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: rin Initial position of particle real(kind=Float64), intent(in), dimension(3) :: vin Initial velocity of particle type( ParticleTrack ), intent(inout), dimension(:) :: tracks Array of ParticleTrack type integer(kind=Int32), intent(out) :: ncell Number of cells that a particle crosses logical, intent(out), optional :: los_intersect Indicator whether particle intersects a LOS in spec_chords Calls proc~~track~~CallsGraph proc~track track proc~get_indices get_indices proc~track->proc~get_indices proc~in_plasma in_plasma proc~track->proc~in_plasma proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~track~~CalledByGraph proc~track track proc~fida_f fida_f proc~fida_f->proc~track proc~fida_mc fida_mc proc~fida_mc->proc~track proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~track proc~read_chords read_chords proc~read_chords->proc~track proc~halo halo proc~halo->proc~track proc~dcx dcx proc~dcx->proc~track proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~track proc~ndmc ndmc proc~ndmc->proc~track program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~read_chords program~fidasim->proc~halo program~fidasim->proc~dcx program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code track Source Code subroutine track ( rin , vin , tracks , ncell , los_intersect ) !+ Computes the path of a neutral through the [[libfida:beam_grid]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: rin !+ Initial position of particle real ( Float64 ), dimension ( 3 ), intent ( in ) :: vin !+ Initial velocity of particle type ( ParticleTrack ), dimension (:), intent ( inout ) :: tracks !+ Array of [[ParticleTrack]] type integer ( Int32 ), intent ( out ) :: ncell !+ Number of cells that a particle crosses logical , intent ( out ), optional :: los_intersect !+ Indicator whether particle intersects a LOS in [[libfida:spec_chords]] integer :: cc , i , ii , mind integer , dimension ( 3 ) :: ind logical :: in_plasma1 , in_plasma2 , in_plasma_tmp , los_inter real ( Float64 ) :: dT , dt1 , inv_50 real ( Float64 ), dimension ( 3 ) :: dt_arr , dr real ( Float64 ), dimension ( 3 ) :: vn , inv_vn real ( Float64 ), dimension ( 3 ) :: ri , ri_tmp , ri_cell integer , dimension ( 3 ) :: sgn integer , dimension ( 3 ) :: gdims integer , dimension ( 1 ) :: minpos vn = vin ; ri = rin ; sgn = 0 ; ncell = 0 if ( dot_product ( vin , vin ). eq . 0.0 ) then return endif gdims ( 1 ) = beam_grid % nx gdims ( 2 ) = beam_grid % ny gdims ( 3 ) = beam_grid % nz !! define actual cell call get_indices ( ri , ind ) ri_cell = [ beam_grid % xc ( ind ( 1 )), & beam_grid % yc ( ind ( 2 )), & beam_grid % zc ( ind ( 3 ))] do i = 1 , 3 if ( vn ( i ). gt . 0.0 ) sgn ( i ) = 1 if ( vn ( i ). lt . 0.0 ) sgn ( i ) =- 1 if ( vn ( i ). eq . 0.0 ) vn ( i ) = 1.0d-3 enddo dr = beam_grid % dr * sgn inv_vn = 1 / vn inv_50 = 1.0 / 5 0.0 cc = 1 los_inter = . False . tracks % time = 0.d0 tracks % flux = 0.d0 call in_plasma ( ri , in_plasma1 ) track_loop : do i = 1 , beam_grid % ntrack if ( cc . gt . beam_grid % ntrack ) exit track_loop if (( spec_chords % inter ( ind ( 1 ), ind ( 2 ), ind ( 3 ))% nchan . ne . 0 ) & . and .(. not . los_inter )) then los_inter = . True . endif dt_arr = abs (( ( ri_cell + 0.5 * dr ) - ri ) * inv_vn ) minpos = minloc ( dt_arr ) mind = minpos ( 1 ) dT = dt_arr ( mind ) ri_tmp = ri + dT * vn call in_plasma ( ri_tmp , in_plasma2 ) if ( in_plasma1 . neqv . in_plasma2 ) then dt1 = 0.0 track_fine : do ii = 1 , 50 dt1 = dt1 + dT * inv_50 ri_tmp = ri + vn * dt1 call in_plasma ( ri_tmp , in_plasma_tmp ) if ( in_plasma2 . eqv . in_plasma_tmp ) exit track_fine enddo track_fine tracks ( cc )% pos = ri + 0.5 * dt1 * vn tracks ( cc + 1 )% pos = ri + 0.5 * ( dt1 + dT ) * vn tracks ( cc )% time = dt1 tracks ( cc + 1 )% time = dT - dt1 tracks ( cc )% ind = ind tracks ( cc + 1 )% ind = ind cc = cc + 2 else tracks ( cc )% pos = ri + 0.5 * dT * vn tracks ( cc )% time = dT tracks ( cc )% ind = ind cc = cc + 1 endif in_plasma1 = in_plasma2 ri = ri + dT * vn ind ( mind ) = ind ( mind ) + sgn ( mind ) ri_cell ( mind ) = ri_cell ( mind ) + dr ( mind ) if ( ind ( mind ). gt . gdims ( mind )) exit track_loop if ( ind ( mind ). lt . 1 ) exit track_loop enddo track_loop ncell = cc - 1 if ( present ( los_intersect )) then los_intersect = los_inter endif end subroutine track","tags":"","loc":"proc/track.html","title":"track – FIDASIM"},{"text":"public subroutine interpol1D_coeff(xmin, dx, nx, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa value real(kind=Float64), intent(in) :: dx Absissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code Called By proc~~interpol1d_coeff~~CalledByGraph proc~interpol1d_coeff interpol1D_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr proc~interpol1d_coeff_arr->proc~interpol1d_coeff interface~interpol_coeff interpol_coeff interface~interpol_coeff->proc~interpol1d_coeff interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~in_plasma in_plasma proc~in_plasma->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff proc~get_neutron_rate get_neutron_rate proc~get_neutron_rate->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~neut_rates neut_rates proc~neut_rates->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff interface~interpol interpol interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol2d_arr interface~interpol->proc~interpol1d_arr proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~get_plasma get_plasma proc~fida_weights_mc->proc~get_plasma proc~track track proc~fida_weights_mc->proc~track proc~get_fields get_fields proc~fida_weights_mc->proc~get_fields proc~get_beam_cx_prob get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~colrad colrad proc~fida_weights_mc->proc~colrad proc~npa_weights npa_weights proc~npa_weights->proc~get_ep_denf proc~npa_weights->proc~get_fields proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~neut_rates proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~track proc~fida_weights_los->proc~get_fields proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~fida_weights_los->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_los proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~ndmc ndmc program~fidasim->proc~ndmc proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~dcx dcx program~fidasim->proc~dcx proc~halo halo program~fidasim->proc~halo proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~read_chords read_chords program~fidasim->proc~read_chords proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~read_npa read_npa program~fidasim->proc~read_npa proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~mc_fastion->proc~get_fields proc~fida_f->proc~mc_fastion proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~fida_f->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_f->proc~store_fida_photons proc~fida_f->proc~colrad proc~npa_f->proc~mc_fastion proc~npa_f->proc~get_plasma proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~store_npa store_npa proc~npa_f->proc~store_npa proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~get_plasma->proc~in_plasma proc~track->proc~in_plasma proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~get_fields->proc~in_plasma proc~ndmc->proc~mc_nbi proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~store_bes_photons store_bes_photons proc~ndmc->proc~store_bes_photons proc~ndmc->proc~colrad proc~neutron_mc->proc~get_neutron_rate proc~neutron_mc->proc~get_plasma proc~neutron_mc->proc~get_fields proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~dcx->proc~colrad proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~halo->proc~store_bes_photons proc~halo->proc~colrad proc~mc_halo->proc~get_plasma proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~bremsstrahlung->proc~get_plasma proc~neutron_f->proc~get_neutron_rate proc~neutron_f->proc~get_plasma proc~neutron_f->proc~get_fields proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~store_fida_photons proc~fida_mc->proc~colrad proc~get_beam_cx_prob->proc~neut_rates proc~get_beam_cx_prob->proc~mc_halo proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~store_npa proc~read_chords->proc~track proc~read_distribution->proc~read_mc proc~store_fida_photons->proc~get_fields proc~read_npa->proc~get_fields proc~store_npa->proc~get_fields proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~colrad->proc~get_rate_matrix var panprocinterpol1d_coeffCalledByGraph = svgPanZoom('#procinterpol1d_coeffCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code interpol1D_coeff Source Code subroutine interpol1D_coeff ( xmin , dx , nx , xout , c , err ) !+ Linear interpolation coefficients and index for a 1D grid y(x) real ( Float64 ), intent ( in ) :: xmin !+ Minimum abscissa value real ( Float64 ), intent ( in ) :: dx !+ Absissa spacing integer , intent ( in ) :: nx !+ Number of abscissa real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate type ( InterpolCoeffs1D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: x1 , xp , b1 , b2 integer :: i , err_status err_status = 1 xp = max ( xout , xmin ) i = floor (( xp - xmin ) / dx ) + 1 if (( i . gt . 0 ). and .( i . le .( nx - 1 ))) then x1 = xmin + ( i - 1 ) * dx b2 = ( xp - x1 ) / dx b1 = ( 1.0 - b2 ) c % i = i c % b1 = b1 c % b2 = b2 err_status = 0 endif if ( present ( err )) err = err_status end subroutine interpol1D_coeff","tags":"","loc":"proc/interpol1d_coeff.html","title":"interpol1D_coeff – FIDASIM"},{"text":"public subroutine interpol1D_coeff_arr(x, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code Calls proc~~interpol1d_coeff_arr~~CallsGraph proc~interpol1d_coeff_arr interpol1D_coeff_arr proc~interpol1d_coeff interpol1D_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~interpol1d_coeff_arr~~CalledByGraph proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff interpol_coeff interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~in_plasma in_plasma proc~in_plasma->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff proc~get_neutron_rate get_neutron_rate proc~get_neutron_rate->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~neut_rates neut_rates proc~neut_rates->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff interface~interpol interpol interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol2d_arr interface~interpol->proc~interpol1d_arr proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~get_plasma get_plasma proc~fida_weights_mc->proc~get_plasma proc~track track proc~fida_weights_mc->proc~track proc~get_fields get_fields proc~fida_weights_mc->proc~get_fields proc~get_beam_cx_prob get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~colrad colrad proc~fida_weights_mc->proc~colrad proc~npa_weights npa_weights proc~npa_weights->proc~get_ep_denf proc~npa_weights->proc~get_fields proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~neut_rates proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~track proc~fida_weights_los->proc~get_fields proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~fida_weights_los->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_los proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~ndmc ndmc program~fidasim->proc~ndmc proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~dcx dcx program~fidasim->proc~dcx proc~halo halo program~fidasim->proc~halo proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~read_chords read_chords program~fidasim->proc~read_chords proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~read_npa read_npa program~fidasim->proc~read_npa proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~mc_fastion->proc~get_fields proc~fida_f->proc~mc_fastion proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~fida_f->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_f->proc~store_fida_photons proc~fida_f->proc~colrad proc~npa_f->proc~mc_fastion proc~npa_f->proc~get_plasma proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~store_npa store_npa proc~npa_f->proc~store_npa proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~get_plasma->proc~in_plasma proc~track->proc~in_plasma proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~get_fields->proc~in_plasma proc~ndmc->proc~mc_nbi proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~store_bes_photons store_bes_photons proc~ndmc->proc~store_bes_photons proc~ndmc->proc~colrad proc~neutron_mc->proc~get_neutron_rate proc~neutron_mc->proc~get_plasma proc~neutron_mc->proc~get_fields proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~dcx->proc~colrad proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~halo->proc~store_bes_photons proc~halo->proc~colrad proc~mc_halo->proc~get_plasma proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~bremsstrahlung->proc~get_plasma proc~neutron_f->proc~get_neutron_rate proc~neutron_f->proc~get_plasma proc~neutron_f->proc~get_fields proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~store_fida_photons proc~fida_mc->proc~colrad proc~get_beam_cx_prob->proc~neut_rates proc~get_beam_cx_prob->proc~mc_halo proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~store_npa proc~read_chords->proc~track proc~read_distribution->proc~read_mc proc~store_fida_photons->proc~get_fields proc~read_npa->proc~get_fields proc~store_npa->proc~get_fields proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~colrad->proc~get_rate_matrix var panprocinterpol1d_coeff_arrCalledByGraph = svgPanZoom('#procinterpol1d_coeff_arrCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code interpol1D_coeff_arr Source Code subroutine interpol1D_coeff_arr ( x , xout , c , err ) !+ Linear interpolation coefficients and index for a 1D grid y(x) real ( Float64 ), dimension (:), intent ( in ) :: x !+ Abscissa values real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate type ( InterpolCoeffs1D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: xmin , dx integer :: sx , err_status err_status = 1 sx = size ( x ) xmin = x ( 1 ) dx = abs ( x ( 2 ) - x ( 1 )) call interpol1D_coeff ( xmin , dx , sx , xout , c , err_status ) if ( present ( err )) err = err_status end subroutine interpol1D_coeff_arr","tags":"","loc":"proc/interpol1d_coeff_arr.html","title":"interpol1D_coeff_arr – FIDASIM"},{"text":"public subroutine interpol2D_coeff(xmin, dx, nx, ymin, dy, ny, xout, yout, c, err) Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa real(kind=Float64), intent(in) :: dx Abscissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: ymin Minimum ordinate real(kind=Float64), intent(in) :: dy Ordinate spacing integer, intent(in) :: ny Number of ordinates points real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code Called By proc~~interpol2d_coeff~~CalledByGraph proc~interpol2d_coeff interpol2D_coeff proc~interpol2d_coeff_arr interpol2D_coeff_arr proc~interpol2d_coeff_arr->proc~interpol2d_coeff interface~interpol_coeff interpol_coeff interface~interpol_coeff->proc~interpol2d_coeff interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~in_plasma in_plasma proc~in_plasma->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff proc~get_neutron_rate get_neutron_rate proc~get_neutron_rate->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~neut_rates neut_rates proc~neut_rates->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff interface~interpol interpol interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol2d_arr interface~interpol->proc~interpol1d_arr proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~get_plasma get_plasma proc~fida_weights_mc->proc~get_plasma proc~track track proc~fida_weights_mc->proc~track proc~get_fields get_fields proc~fida_weights_mc->proc~get_fields proc~get_beam_cx_prob get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~colrad colrad proc~fida_weights_mc->proc~colrad proc~npa_weights npa_weights proc~npa_weights->proc~get_ep_denf proc~npa_weights->proc~get_fields proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~neut_rates proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~track proc~fida_weights_los->proc~get_fields proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~fida_weights_los->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_los proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~ndmc ndmc program~fidasim->proc~ndmc proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~dcx dcx program~fidasim->proc~dcx proc~halo halo program~fidasim->proc~halo proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~read_chords read_chords program~fidasim->proc~read_chords proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~read_npa read_npa program~fidasim->proc~read_npa proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~mc_fastion->proc~get_fields proc~fida_f->proc~mc_fastion proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~fida_f->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_f->proc~store_fida_photons proc~fida_f->proc~colrad proc~npa_f->proc~mc_fastion proc~npa_f->proc~get_plasma proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~store_npa store_npa proc~npa_f->proc~store_npa proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~get_plasma->proc~in_plasma proc~track->proc~in_plasma proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~get_fields->proc~in_plasma proc~ndmc->proc~mc_nbi proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~store_bes_photons store_bes_photons proc~ndmc->proc~store_bes_photons proc~ndmc->proc~colrad proc~neutron_mc->proc~get_neutron_rate proc~neutron_mc->proc~get_plasma proc~neutron_mc->proc~get_fields proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~dcx->proc~colrad proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~halo->proc~store_bes_photons proc~halo->proc~colrad proc~mc_halo->proc~get_plasma proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~bremsstrahlung->proc~get_plasma proc~neutron_f->proc~get_neutron_rate proc~neutron_f->proc~get_plasma proc~neutron_f->proc~get_fields proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~store_fida_photons proc~fida_mc->proc~colrad proc~get_beam_cx_prob->proc~neut_rates proc~get_beam_cx_prob->proc~mc_halo proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~store_npa proc~read_chords->proc~track proc~read_distribution->proc~read_mc proc~store_fida_photons->proc~get_fields proc~read_npa->proc~get_fields proc~store_npa->proc~get_fields proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~colrad->proc~get_rate_matrix var panprocinterpol2d_coeffCalledByGraph = svgPanZoom('#procinterpol2d_coeffCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code interpol2D_coeff Source Code subroutine interpol2D_coeff ( xmin , dx , nx , ymin , dy , ny , xout , yout , c , err ) !+ Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) real ( Float64 ), intent ( in ) :: xmin !+ Minimum abscissa real ( Float64 ), intent ( in ) :: dx !+ Abscissa spacing integer , intent ( in ) :: nx !+ Number of abscissa real ( Float64 ), intent ( in ) :: ymin !+ Minimum ordinate real ( Float64 ), intent ( in ) :: dy !+ Ordinate spacing integer , intent ( in ) :: ny !+ Number of ordinates points real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ Ordinate value to interpolate type ( InterpolCoeffs2D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: x1 , x2 , y1 , y2 , xp , yp integer :: i , j , err_status err_status = 1 xp = max ( xout , xmin ) yp = max ( yout , ymin ) i = floor (( xp - xmin ) / dx ) + 1 j = floor (( yp - ymin ) / dy ) + 1 if ((( i . gt . 0 ). and .( i . le .( nx - 1 ))). and .(( j . gt . 0 ). and .( j . le .( ny - 1 )))) then x1 = xmin + ( i - 1 ) * dx x2 = x1 + dx y1 = ymin + ( j - 1 ) * dy y2 = y1 + dy c % b11 = (( x2 - xp ) * ( y2 - yp )) / ( dx * dy ) c % b21 = (( xp - x1 ) * ( y2 - yp )) / ( dx * dy ) c % b12 = (( x2 - xp ) * ( yp - y1 )) / ( dx * dy ) c % b22 = (( xp - x1 ) * ( yp - y1 )) / ( dx * dy ) c % i = i c % j = j err_status = 0 endif if ( present ( err )) err = err_status end subroutine interpol2D_coeff","tags":"","loc":"proc/interpol2d_coeff.html","title":"interpol2D_coeff – FIDASIM"},{"text":"public subroutine interpol2D_coeff_arr(x, y, xout, yout, c, err) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in), dimension(:) :: y Ordinate values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code Calls proc~~interpol2d_coeff_arr~~CallsGraph proc~interpol2d_coeff_arr interpol2D_coeff_arr proc~interpol2d_coeff interpol2D_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~interpol2d_coeff_arr~~CalledByGraph proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff interpol_coeff interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~in_plasma in_plasma proc~in_plasma->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff proc~get_neutron_rate get_neutron_rate proc~get_neutron_rate->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~neut_rates neut_rates proc~neut_rates->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff interface~interpol interpol interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol2d_arr interface~interpol->proc~interpol1d_arr proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~get_plasma get_plasma proc~fida_weights_mc->proc~get_plasma proc~track track proc~fida_weights_mc->proc~track proc~get_fields get_fields proc~fida_weights_mc->proc~get_fields proc~get_beam_cx_prob get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~colrad colrad proc~fida_weights_mc->proc~colrad proc~npa_weights npa_weights proc~npa_weights->proc~get_ep_denf proc~npa_weights->proc~get_fields proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~neut_rates proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~track proc~fida_weights_los->proc~get_fields proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~fida_weights_los->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_los proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~ndmc ndmc program~fidasim->proc~ndmc proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~dcx dcx program~fidasim->proc~dcx proc~halo halo program~fidasim->proc~halo proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~read_chords read_chords program~fidasim->proc~read_chords proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~read_npa read_npa program~fidasim->proc~read_npa proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~mc_fastion->proc~get_fields proc~fida_f->proc~mc_fastion proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~fida_f->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_f->proc~store_fida_photons proc~fida_f->proc~colrad proc~npa_f->proc~mc_fastion proc~npa_f->proc~get_plasma proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~store_npa store_npa proc~npa_f->proc~store_npa proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~get_plasma->proc~in_plasma proc~track->proc~in_plasma proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~get_fields->proc~in_plasma proc~ndmc->proc~mc_nbi proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~store_bes_photons store_bes_photons proc~ndmc->proc~store_bes_photons proc~ndmc->proc~colrad proc~neutron_mc->proc~get_neutron_rate proc~neutron_mc->proc~get_plasma proc~neutron_mc->proc~get_fields proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~dcx->proc~colrad proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~halo->proc~store_bes_photons proc~halo->proc~colrad proc~mc_halo->proc~get_plasma proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~bremsstrahlung->proc~get_plasma proc~neutron_f->proc~get_neutron_rate proc~neutron_f->proc~get_plasma proc~neutron_f->proc~get_fields proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~store_fida_photons proc~fida_mc->proc~colrad proc~get_beam_cx_prob->proc~neut_rates proc~get_beam_cx_prob->proc~mc_halo proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~store_npa proc~read_chords->proc~track proc~read_distribution->proc~read_mc proc~store_fida_photons->proc~get_fields proc~read_npa->proc~get_fields proc~store_npa->proc~get_fields proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~colrad->proc~get_rate_matrix var panprocinterpol2d_coeff_arrCalledByGraph = svgPanZoom('#procinterpol2d_coeff_arrCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code interpol2D_coeff_arr Source Code subroutine interpol2D_coeff_arr ( x , y , xout , yout , c , err ) !!Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) real ( Float64 ), dimension (:), intent ( in ) :: x !+ Abscissa values real ( Float64 ), dimension (:), intent ( in ) :: y !+ Ordinate values real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ Ordinate value to interpolate type ( InterpolCoeffs2D ), intent ( out ) :: c !+ Interpolation Coefficients integer , intent ( out ), optional :: err !+ Error code real ( Float64 ) :: xmin , ymin , dx , dy integer :: sx , sy , err_status err_status = 1 sx = size ( x ) sy = size ( y ) xmin = x ( 1 ) ymin = y ( 1 ) dx = abs ( x ( 2 ) - x ( 1 )) dy = abs ( y ( 2 ) - y ( 1 )) call interpol2D_coeff ( xmin , dx , sx , ymin , dy , sy , xout , yout , c , err_status ) if ( present ( err )) err = err_status end subroutine interpol2D_coeff_arr","tags":"","loc":"proc/interpol2d_coeff_arr.html","title":"interpol2D_coeff_arr – FIDASIM"},{"text":"public subroutine interpol1D_arr(x, y, xout, yout, err, coeffs) Performs linear interpolation on a uniform 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of y real(kind=Float64), intent(in), dimension(:) :: y Values at abscissa values x : y(x) real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(out) :: yout Interpolant: y(xout) integer, intent(out), optional :: err Error code type( InterpolCoeffs1D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients Calls proc~~interpol1d_arr~~CallsGraph proc~interpol1d_arr interpol1D_arr interface~interpol_coeff interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~interpol1d_arr~~CalledByGraph proc~interpol1d_arr interpol1D_arr interface~interpol interpol interface~interpol->proc~interpol1d_arr proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~npa_weights npa_weights proc~npa_weights->proc~get_ep_denf proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_ep_denf program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_los proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~fida_f->proc~mc_fastion proc~npa_f->proc~mc_fastion Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code interpol1D_arr Source Code subroutine interpol1D_arr ( x , y , xout , yout , err , coeffs ) !+ Performs linear interpolation on a uniform 1D grid y(x) real ( Float64 ), dimension (:), intent ( in ) :: x !+ The abscissa values of `y` real ( Float64 ), dimension (:), intent ( in ) :: y !+ Values at abscissa values `x`: y(x) real ( Float64 ), intent ( in ) :: xout !+ Abscissa value to interpolate real ( Float64 ), intent ( out ) :: yout !+ Interpolant: y(xout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs1D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients type ( InterpolCoeffs1D ) :: c integer :: i , err_status err_status = 1 if ( present ( coeffs )) then c = coeffs err_status = 0 else call interpol_coeff ( x , xout , c , err_status ) endif if ( err_status . eq . 0 ) then i = c % i yout = c % b1 * y ( i ) + c % b2 * y ( i + 1 ) else yout = 0.d0 endif if ( present ( err )) err = err_status end subroutine interpol1D_arr","tags":"","loc":"proc/interpol1d_arr.html","title":"interpol1D_arr – FIDASIM"},{"text":"public subroutine interpol2D_arr(x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:) :: z Values at the abscissa/ordinates: z(x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out) :: zout Interpolant: z(xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients Calls proc~~interpol2d_arr~~CallsGraph proc~interpol2d_arr interpol2D_arr interface~interpol_coeff interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~interpol2d_arr~~CalledByGraph proc~interpol2d_arr interpol2D_arr interface~interpol interpol interface~interpol->proc~interpol2d_arr proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~npa_weights npa_weights proc~npa_weights->proc~get_ep_denf proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_ep_denf program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_los proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~fida_f->proc~mc_fastion proc~npa_f->proc~mc_fastion Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code interpol2D_arr Source Code subroutine interpol2D_arr ( x , y , z , xout , yout , zout , err , coeffs ) !+ Performs bilinear interpolation on a 2D grid z(x,y) real ( Float64 ), dimension (:), intent ( in ) :: x !+ The abscissa values of `z` real ( Float64 ), dimension (:), intent ( in ) :: y !+ The ordinate values of `z` real ( Float64 ), dimension (:,:), intent ( in ) :: z !+ Values at the abscissa/ordinates: z(x,y) real ( Float64 ), intent ( in ) :: xout !+ The abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ The ordinate value to interpolate real ( Float64 ), intent ( out ) :: zout !+ Interpolant: z(xout,yout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs2D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients type ( InterpolCoeffs2D ) :: c integer :: i , j , err_status err_status = 1 if ( present ( coeffs )) then c = coeffs err_status = 0 else call interpol_coeff ( x , y , xout , yout , c , err_status ) endif if ( err_status . eq . 0 ) then i = c % i j = c % j zout = c % b11 * z ( i , j ) + c % b12 * z ( i , j + 1 ) + c % b21 * z ( i + 1 , j ) + c % b22 * z ( i + 1 , j + 1 ) else zout = 0.d0 endif if ( present ( err )) err = err_status end subroutine interpol2D_arr","tags":"","loc":"proc/interpol2d_arr.html","title":"interpol2D_arr – FIDASIM"},{"text":"public subroutine interpol2D_2D_arr(x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid of 2D arrays z(:,:,x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:,:,:) :: z Values at the abscissa/ordinates: z(:,:,x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out), dimension(:,:) :: zout Interpolant: z(:,:,xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients Calls proc~~interpol2d_2d_arr~~CallsGraph proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol_coeff interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~interpol2d_2d_arr~~CalledByGraph proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol interpol interface~interpol->proc~interpol2d_2d_arr proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~npa_weights npa_weights proc~npa_weights->proc~get_ep_denf proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_ep_denf program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_los proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~fida_f->proc~mc_fastion proc~npa_f->proc~mc_fastion var panprocinterpol2d_2d_arrCalledByGraph = svgPanZoom('#procinterpol2d_2d_arrCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code interpol2D_2D_arr Source Code subroutine interpol2D_2D_arr ( x , y , z , xout , yout , zout , err , coeffs ) !+ Performs bilinear interpolation on a 2D grid of 2D arrays z(:,:,x,y) real ( Float64 ), dimension (:), intent ( in ) :: x !+ The abscissa values of `z` real ( Float64 ), dimension (:), intent ( in ) :: y !+ The ordinate values of `z` real ( Float64 ), dimension (:,:,:,:), intent ( in ) :: z !+ Values at the abscissa/ordinates: z(:,:,x,y) real ( Float64 ), intent ( in ) :: xout !+ The abscissa value to interpolate real ( Float64 ), intent ( in ) :: yout !+ The ordinate value to interpolate real ( Float64 ), dimension (:,:), intent ( out ) :: zout !+ Interpolant: z(:,:,xout,yout) integer , intent ( out ), optional :: err !+ Error code type ( InterpolCoeffs2D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients type ( InterpolCoeffs2D ) :: c integer :: i , j , err_status err_status = 1 if ( present ( coeffs )) then c = coeffs err_status = 0 else call interpol_coeff ( x , y , xout , yout , c , err_status ) endif if ( err_status . eq . 0 ) then i = c % i j = c % j zout = c % b11 * z (:,:, i , j ) + c % b12 * z (:,:, i , j + 1 ) + c % b21 * z (:,:, i + 1 , j ) + c % b22 * z (:,:, i + 1 , j + 1 ) else zout = 0.0 endif if ( present ( err )) err = err_status end subroutine interpol2D_2D_arr","tags":"","loc":"proc/interpol2d_2d_arr.html","title":"interpol2D_2D_arr – FIDASIM"},{"text":"public subroutine in_plasma(xyz, inp, machine_coords, coeffs, uvw_out) Indicator subroutine to determine if a position is in a region where\n the plasma parameter and fields are valid/known Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: xyz Position in beam coordinates logical, intent(out) :: inp Indicates whether plasma parameters and fields are valid/known logical, intent(in), optional :: machine_coords Indicates that xyz is in machine coordinates type( InterpolCoeffs2D ), intent(out), optional :: coeffs Linear Interpolation coefficients used in calculation real(kind=Float64), intent(out), optional dimension(3) :: uvw_out Position in machine coordinates Calls proc~~in_plasma~~CallsGraph proc~in_plasma in_plasma proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~in_plasma~~CalledByGraph proc~in_plasma in_plasma proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~get_plasma get_plasma proc~get_plasma->proc~in_plasma proc~track track proc~track->proc~in_plasma proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~get_fields get_fields proc~get_fields->proc~in_plasma proc~ndmc ndmc proc~ndmc->proc~mc_nbi proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~store_bes_photons store_bes_photons proc~ndmc->proc~store_bes_photons program~fidasim fidasim program~fidasim->proc~ndmc proc~fida_f fida_f program~fidasim->proc~fida_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~dcx dcx program~fidasim->proc~dcx proc~halo halo program~fidasim->proc~halo proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~read_chords read_chords program~fidasim->proc~read_chords proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~read_npa read_npa program~fidasim->proc~read_npa proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~get_beam_cx_prob get_beam_cx_prob proc~fida_f->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_f->proc~store_fida_photons proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~neutron_mc->proc~get_plasma proc~neutron_mc->proc~get_fields proc~npa_f->proc~get_plasma proc~attenuate attenuate proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~store_npa store_npa proc~npa_f->proc~store_npa proc~npa_f->proc~mc_fastion proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~track proc~fida_weights_los->proc~get_fields proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~halo->proc~store_bes_photons proc~mc_halo->proc~get_plasma proc~attenuate->proc~get_plasma proc~bremsstrahlung->proc~get_plasma proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~track proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~get_beam_cx_prob proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~neutron_f->proc~get_plasma proc~neutron_f->proc~get_fields proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~store_fida_photons proc~get_beam_cx_prob->proc~mc_halo proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~store_npa proc~npa_weights->proc~get_fields proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~read_chords->proc~track proc~read_distribution->proc~read_mc proc~store_fida_photons->proc~get_fields proc~read_npa->proc~get_fields proc~store_npa->proc~get_fields proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~mc_fastion->proc~get_fields var panprocin_plasmaCalledByGraph = svgPanZoom('#procin_plasmaCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code in_plasma Source Code subroutine in_plasma ( xyz , inp , machine_coords , coeffs , uvw_out ) !+ Indicator subroutine to determine if a position is in a region where !+ the plasma parameter and fields are valid/known real ( Float64 ), dimension ( 3 ), intent ( in ) :: xyz !+ Position in beam coordinates logical , intent ( out ) :: inp !+ Indicates whether plasma parameters and fields are valid/known logical , intent ( in ), optional :: machine_coords !+ Indicates that xyz is in machine coordinates type ( InterpolCoeffs2D ), intent ( out ), optional :: coeffs !+ Linear Interpolation coefficients used in calculation real ( Float64 ), dimension ( 3 ), intent ( out ), optional :: uvw_out !+ Position in machine coordinates real ( Float64 ), dimension ( 3 ) :: uvw type ( InterpolCoeffs2D ) :: c real ( Float64 ) :: R , W , mask logical :: mc integer :: i , j , err err = 1 mc = . False . if ( present ( machine_coords )) mc = machine_coords if ( mc ) then uvw = xyz else !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) endif R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) W = uvw ( 3 ) !! Interpolate mask value call interpol_coeff ( inter_grid % r , inter_grid % z , R , W , c , err ) inp = . False . if ( err . eq . 0 ) then i = c % i j = c % j mask = c % b11 * equil % mask ( i , j ) + c % b12 * equil % mask ( i , j + 1 ) + & c % b21 * equil % mask ( i + 1 , j ) + c % b22 * equil % mask ( i + 1 , j + 1 ) if (( mask . ge . 0.5 ). and .( err . eq . 0 )) then inp = . True . endif endif if ( present ( coeffs )) coeffs = c if ( present ( uvw_out )) uvw_out = uvw end subroutine in_plasma","tags":"","loc":"proc/in_plasma.html","title":"in_plasma – FIDASIM"},{"text":"public subroutine get_plasma(plasma, pos, ind) Gets plasma parameters at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(out) :: plasma Plasma parameters at pos / ind real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices Calls proc~~get_plasma~~CallsGraph proc~get_plasma get_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~get_plasma~~CalledByGraph proc~get_plasma get_plasma proc~fida_f fida_f proc~fida_f->proc~get_plasma proc~get_beam_cx_prob get_beam_cx_prob proc~fida_f->proc~get_beam_cx_prob proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_plasma proc~ndmc ndmc proc~ndmc->proc~get_plasma proc~npa_f npa_f proc~npa_f->proc~get_plasma proc~attenuate attenuate proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_plasma proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~dcx dcx proc~dcx->proc~get_plasma proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~halo halo proc~halo->proc~get_plasma proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~mc_halo->proc~get_plasma proc~attenuate->proc~get_plasma proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~get_plasma proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~get_beam_cx_prob proc~neutron_f neutron_f proc~neutron_f->proc~get_plasma proc~fida_mc fida_mc proc~fida_mc->proc~get_plasma proc~fida_mc->proc~get_beam_cx_prob program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~ndmc program~fidasim->proc~npa_f program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~bremsstrahlung program~fidasim->proc~fida_weights_mc program~fidasim->proc~neutron_f program~fidasim->proc~fida_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~get_beam_cx_prob->proc~mc_halo proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_plasma Source Code subroutine get_plasma ( plasma , pos , ind ) !+ Gets plasma parameters at position `pos` or [[libfida:beam_grid]] indices `ind` type ( LocalProfiles ), intent ( out ) :: plasma !+ Plasma parameters at `pos`/`ind` real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices logical :: inp type ( InterpolCoeffs2D ) :: coeffs real ( Float64 ), dimension ( 3 ) :: xyz , uvw , vrot_uvw real ( Float64 ) :: phi , s , c integer :: i , j plasma % in_plasma = . False . if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos call in_plasma ( xyz , inp ,. False ., coeffs , uvw ) if ( inp ) then phi = atan2 ( uvw ( 2 ), uvw ( 1 )) i = coeffs % i j = coeffs % j plasma = coeffs % b11 * equil % plasma ( i , j ) + coeffs % b12 * equil % plasma ( i , j + 1 ) + & coeffs % b21 * equil % plasma ( i + 1 , j ) + coeffs % b22 * equil % plasma ( i + 1 , j + 1 ) s = sin ( phi ) ; c = cos ( phi ) vrot_uvw ( 1 ) = plasma % vr * c - plasma % vt * s vrot_uvw ( 2 ) = plasma % vr * s + plasma % vt * c vrot_uvw ( 3 ) = plasma % vz plasma % vrot = matmul ( beam_grid % inv_basis , vrot_uvw ) plasma % pos = xyz plasma % uvw = uvw plasma % in_plasma = . True . plasma % c = coeffs endif end subroutine get_plasma","tags":"","loc":"proc/get_plasma.html","title":"get_plasma – FIDASIM"},{"text":"public subroutine calc_perp_vectors(b, a, c) Calculates normalized vectors that are perpendicular to b\n such that a x c = b_norm Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: b real(kind=Float64), intent(out), dimension(3) :: a real(kind=Float64), intent(out), dimension(3) :: c Called By proc~~calc_perp_vectors~~CalledByGraph proc~calc_perp_vectors calc_perp_vectors proc~lflf_subtract lflf_subtract proc~lflf_subtract->proc~calc_perp_vectors proc~lflf_add lflf_add proc~lflf_add->proc~calc_perp_vectors proc~get_fields get_fields proc~get_fields->proc~calc_perp_vectors interface~operator(-) operator(-) interface~operator(-)->proc~lflf_subtract interface~operator(+) operator(+) interface~operator(+)->proc~lflf_add proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_fields proc~fida_mc fida_mc proc~fida_mc->proc~get_fields proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~npa_mc npa_mc proc~npa_mc->proc~get_fields proc~store_npa store_npa proc~npa_mc->proc~store_npa proc~store_fida_photons->proc~get_fields proc~neutron_f neutron_f proc~neutron_f->proc~get_fields proc~read_npa read_npa proc~read_npa->proc~get_fields proc~store_npa->proc~get_fields proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~store_fw_photons proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~get_fields proc~npa_weights npa_weights proc~npa_weights->proc~get_fields proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_fields proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_fields program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~npa_mc program~fidasim->proc~neutron_f program~fidasim->proc~read_npa program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_weights program~fidasim->proc~neutron_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~dcx dcx program~fidasim->proc~dcx proc~ndmc ndmc program~fidasim->proc~ndmc proc~halo halo program~fidasim->proc~halo proc~fida_f->proc~store_fida_photons proc~fida_f->proc~mc_fastion proc~npa_f->proc~store_npa proc~npa_f->proc~mc_fastion proc~dcx->proc~store_bes_photons proc~ndmc->proc~store_bes_photons proc~halo->proc~store_bes_photons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code calc_perp_vectors Source Code subroutine calc_perp_vectors ( b , a , c ) !+ Calculates normalized vectors that are perpendicular to b !+ such that `a` x `c` = `b_norm` real ( Float64 ), dimension ( 3 ), intent ( in ) :: b real ( Float64 ), dimension ( 3 ), intent ( out ) :: a real ( Float64 ), dimension ( 3 ), intent ( out ) :: c real ( Float64 ), dimension ( 3 ) :: bnorm bnorm = b / norm2 ( b ) if ( abs ( bnorm ( 3 )). eq . 1 ) then a = [ 1.d0 , 0.d0 , 0.d0 ] c = [ 0.d0 , 1.d0 , 0.d0 ] else if ( bnorm ( 3 ). eq . 0. ) then a = [ 0.d0 , 0.d0 , 1.d0 ] c = [ bnorm ( 2 ), - bnorm ( 1 ), 0.d0 ] / sqrt ( bnorm ( 1 ) ** 2 + bnorm ( 2 ) ** 2 ) else a = [ bnorm ( 2 ), - bnorm ( 1 ), 0.d0 ] / sqrt ( bnorm ( 1 ) ** 2 + bnorm ( 2 ) ** 2 ) c =- [ a ( 2 ) , - a ( 1 ) , ( a ( 1 ) * bnorm ( 2 ) - a ( 2 ) * bnorm ( 1 )) / bnorm ( 3 ) ] c = c / norm2 ( c ) if ( bnorm ( 3 ). lt . 0.0 ) then c =- c endif endif endif end subroutine calc_perp_vectors","tags":"","loc":"proc/calc_perp_vectors.html","title":"calc_perp_vectors – FIDASIM"},{"text":"public subroutine get_fields(fields, pos, ind, machine_coords) Gets electro-magnetic fields at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(out) :: fields Electro-magnetic fields at pos / ind real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices logical, intent(in), optional :: machine_coords Indicates that pos is machine coordinates Calls proc~~get_fields~~CallsGraph proc~get_fields get_fields proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~get_position get_position proc~get_fields->proc~get_position proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~get_fields~~CalledByGraph proc~get_fields get_fields proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_fields proc~fida_mc fida_mc proc~fida_mc->proc~get_fields proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~npa_mc npa_mc proc~npa_mc->proc~get_fields proc~store_npa store_npa proc~npa_mc->proc~store_npa proc~store_fida_photons->proc~get_fields proc~neutron_f neutron_f proc~neutron_f->proc~get_fields proc~read_npa read_npa proc~read_npa->proc~get_fields proc~store_npa->proc~get_fields proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~get_fields proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_fields proc~fida_weights_mc->proc~store_fw_photons proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~get_fields proc~npa_weights npa_weights proc~npa_weights->proc~get_fields proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_fields proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_fields program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_mc program~fidasim->proc~npa_mc program~fidasim->proc~neutron_f program~fidasim->proc~read_npa program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_weights program~fidasim->proc~neutron_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~dcx dcx program~fidasim->proc~dcx proc~ndmc ndmc program~fidasim->proc~ndmc proc~halo halo program~fidasim->proc~halo proc~fida_f->proc~store_fida_photons proc~fida_f->proc~mc_fastion proc~npa_f->proc~store_npa proc~npa_f->proc~mc_fastion proc~dcx->proc~store_bes_photons proc~ndmc->proc~store_bes_photons proc~halo->proc~store_bes_photons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_fields Source Code subroutine get_fields ( fields , pos , ind , machine_coords ) !+ Gets electro-magnetic fields at position `pos` or [[libfida:beam_grid]] indices `ind` type ( LocalEMFields ), intent ( out ) :: fields !+ Electro-magnetic fields at `pos`/`ind` real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices logical , intent ( in ), optional :: machine_coords !+ Indicates that pos is machine coordinates logical :: inp , mc real ( Float64 ), dimension ( 3 ) :: xyz , uvw real ( Float64 ), dimension ( 3 ) :: uvw_bfield , uvw_efield real ( Float64 ), dimension ( 3 ) :: xyz_bfield , xyz_efield real ( Float64 ) :: phi , s , c type ( InterpolCoeffs2D ) :: coeffs integer :: i , j fields % in_plasma = . False . if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos mc = . False . if ( present ( machine_coords )) mc = machine_coords call in_plasma ( xyz , inp , mc , coeffs , uvw ) if ( inp ) then phi = atan2 ( uvw ( 2 ), uvw ( 1 )) i = coeffs % i j = coeffs % j fields = coeffs % b11 * equil % fields ( i , j ) + coeffs % b12 * equil % fields ( i , j + 1 ) + & coeffs % b21 * equil % fields ( i + 1 , j ) + coeffs % b22 * equil % fields ( i + 1 , j + 1 ) phi = atan2 ( uvw ( 2 ), uvw ( 1 )) s = sin ( phi ) ; c = cos ( phi ) !Convert cylindrical coordinates to uvw uvw_bfield ( 1 ) = c * fields % br - s * fields % bt uvw_bfield ( 2 ) = s * fields % br + c * fields % bt uvw_bfield ( 3 ) = fields % bz uvw_efield ( 1 ) = c * fields % er - s * fields % et uvw_efield ( 2 ) = s * fields % er + c * fields % et uvw_efield ( 3 ) = fields % ez if ( mc ) then xyz_bfield = uvw_bfield xyz_efield = uvw_efield else !Represent fields in beam grid coordinates xyz_bfield = matmul ( beam_grid % inv_basis , uvw_bfield ) xyz_efield = matmul ( beam_grid % inv_basis , uvw_efield ) endif !Calculate field directions and magnitudes fields % b_abs = norm2 ( xyz_bfield ) fields % e_abs = norm2 ( xyz_efield ) if ( fields % b_abs . gt . 0.d0 ) fields % b_norm = xyz_bfield / fields % b_abs if ( fields % e_abs . gt . 0.d0 ) fields % e_norm = xyz_efield / fields % e_abs call calc_perp_vectors ( fields % b_norm , fields % a_norm , fields % c_norm ) fields % pos = xyz fields % uvw = uvw fields % in_plasma = . True . fields % machine_coords = mc fields % c = coeffs endif end subroutine get_fields","tags":"","loc":"proc/get_fields.html","title":"get_fields – FIDASIM"},{"text":"public subroutine get_distribution(fbeam, denf, pos, ind, coeffs) Gets Guiding Center distribution at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:,:) :: fbeam Guiding Center Fast-ion distribution at pos / ind : F(E,p) real(kind=Float64), intent(out) :: denf Guiding Center Fast-ion density at pos / ind [fast-ions/cm&#94;3] real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients Calls proc~~get_distribution~~CallsGraph proc~get_distribution get_distribution proc~xyz_to_uvw xyz_to_uvw proc~get_distribution->proc~xyz_to_uvw interface~interpol interpol proc~get_distribution->interface~interpol proc~get_position get_position proc~get_distribution->proc~get_position proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr interface~interpol_coeff interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff var panprocget_distributionCallsGraph = svgPanZoom('#procget_distributionCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~get_distribution~~CalledByGraph proc~get_distribution get_distribution proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~fida_f fida_f proc~fida_f->proc~mc_fastion proc~npa_f npa_f proc~npa_f->proc~mc_fastion program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_distribution Source Code subroutine get_distribution ( fbeam , denf , pos , ind , coeffs ) !+ Gets Guiding Center distribution at position `pos` or [[libfida:beam_grid]] indices `ind` real ( Float64 ), dimension (:,:), intent ( out ) :: fbeam !+ Guiding Center Fast-ion distribution at `pos`/`ind`: F(E,p) real ( Float64 ), intent ( out ) :: denf !+ Guiding Center Fast-ion density at `pos`/`ind` [fast-ions/cm&#94;3] real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices type ( InterpolCoeffs2D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients real ( Float64 ), dimension ( 3 ) :: xyz , uvw real ( Float64 ) :: R , Z integer :: err if ( present ( coeffs )) then call interpol ( fbm % r , fbm % z , fbm % f , R , Z , fbeam , err , coeffs ) call interpol ( fbm % r , fbm % z , fbm % denf , R , Z , denf , err , coeffs ) else if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) Z = uvw ( 3 ) call interpol ( fbm % r , fbm % z , fbm % f , R , Z , fbeam , err ) call interpol ( fbm % r , fbm % z , fbm % denf , R , Z , denf , err ) endif end subroutine get_distribution","tags":"","loc":"proc/get_distribution.html","title":"get_distribution – FIDASIM"},{"text":"public subroutine get_ep_denf(energy, pitch, denf, pos, ind, coeffs) Get guiding center fast-ion density at given energy and pitch\n at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: energy Energy [keV] real(kind=Float64), intent(in) :: pitch Pitch real(kind=Float64), intent(out) :: denf Fast-ion density [fast-ions/(cm&#94;3 dE dp)] real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients Calls proc~~get_ep_denf~~CallsGraph proc~get_ep_denf get_ep_denf proc~xyz_to_uvw xyz_to_uvw proc~get_ep_denf->proc~xyz_to_uvw interface~interpol interpol proc~get_ep_denf->interface~interpol proc~get_position get_position proc~get_ep_denf->proc~get_position proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr interface~interpol_coeff interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff var panprocget_ep_denfCallsGraph = svgPanZoom('#procget_ep_denfCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~get_ep_denf~~CalledByGraph proc~get_ep_denf get_ep_denf proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~npa_weights npa_weights proc~npa_weights->proc~get_ep_denf proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_ep_denf program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_los Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_ep_denf Source Code subroutine get_ep_denf ( energy , pitch , denf , pos , ind , coeffs ) !+ Get guiding center fast-ion density at given energy and pitch !+ at position `pos` or [[libfida:beam_grid]] indices `ind` real ( Float64 ), intent ( in ) :: energy !+ Energy [keV] real ( Float64 ), intent ( in ) :: pitch !+ Pitch real ( Float64 ), intent ( out ) :: denf !+ Fast-ion density [fast-ions/(cm&#94;3*dE*dp)] real ( Float64 ), dimension ( 3 ), intent ( in ), optional :: pos !+ Position in beam grid coordinates integer ( Int32 ), dimension ( 3 ), intent ( in ), optional :: ind !+ [[libfida:beam_grid]] indices type ( InterpolCoeffs2D ), intent ( in ), optional :: coeffs !+ Precomputed Linear Interpolation Coefficients real ( Float64 ), dimension ( 3 ) :: xyz , uvw real ( Float64 ), dimension ( fbm % nenergy , fbm % npitch ) :: fbeam integer ( Int32 ), dimension ( 2 ) :: epi integer ( Int32 ), dimension ( 1 ) :: dummy real ( Float64 ) :: R , Z real ( Float64 ) :: dE , dp integer :: err dummy = minloc ( abs ( fbm % energy - energy )) epi ( 1 ) = dummy ( 1 ) dummy = minloc ( abs ( fbm % pitch - pitch )) epi ( 2 ) = dummy ( 1 ) dE = abs ( fbm % energy ( epi ( 1 )) - energy ) dp = abs ( fbm % pitch ( epi ( 2 )) - pitch ) if (( dE . le . fbm % dE ). and .( dp . le . fbm % dp )) then if ( present ( coeffs )) then call interpol ( inter_grid % r , inter_grid % z , fbm % f , R , Z , fbeam , err , coeffs ) else if ( present ( ind )) call get_position ( ind , xyz ) if ( present ( pos )) xyz = pos !! Convert to machine coordinates call xyz_to_uvw ( xyz , uvw ) R = sqrt ( uvw ( 1 ) * uvw ( 1 ) + uvw ( 2 ) * uvw ( 2 )) Z = uvw ( 3 ) call interpol ( inter_grid % r , inter_grid % z , fbm % f , R , Z , fbeam , err ) endif denf = fbeam ( epi ( 1 ), epi ( 2 )) else denf = 0.0 endif end subroutine get_ep_denf","tags":"","loc":"proc/get_ep_denf.html","title":"get_ep_denf – FIDASIM"},{"text":"public subroutine store_neutrals(ind, neut_type, dens, store_iter) Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind beam_grid indices integer, intent(in) :: neut_type Neutral type real(kind=Float64), intent(in), dimension(:) :: dens Neutral density [neutrals/cm&#94;3] logical, intent(in), optional :: store_iter Store DCX/Halo iteration density in halo_iter_dens Called By proc~~store_neutrals~~CalledByGraph proc~store_neutrals store_neutrals proc~dcx dcx proc~dcx->proc~store_neutrals proc~ndmc ndmc proc~ndmc->proc~store_neutrals proc~halo halo proc~halo->proc~store_neutrals program~fidasim fidasim program~fidasim->proc~dcx program~fidasim->proc~ndmc program~fidasim->proc~halo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code store_neutrals Source Code subroutine store_neutrals ( ind , neut_type , dens , store_iter ) !Store neutrals in [[libfida:neut]] at indices `ind` integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices integer , intent ( in ) :: neut_type !+ Neutral type real ( Float64 ), dimension (:), intent ( in ) :: dens !+ Neutral density [neutrals/cm&#94;3] logical , intent ( in ), optional :: store_iter !+ Store DCX/Halo iteration density in [[libfida:halo_iter_dens]] logical :: iter if ( present ( store_iter )) then iter = store_iter else iter = . False . endif !$OMP CRITICAL(store_neutrals_1) if ( iter ) halo_iter_dens ( neut_type ) = halo_iter_dens ( neut_type ) + sum ( dens ) neut % dens (:, neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) = & neut % dens (:, neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) + dens ![neutrals/cm&#94;3] !$OMP END CRITICAL(store_neutrals_1) end subroutine store_neutrals","tags":"","loc":"proc/store_neutrals.html","title":"store_neutrals – FIDASIM"},{"text":"public subroutine store_births(ind, neut_type, dflux) Store birth particles/density in birth Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind beam_grid indices integer(kind=Int32), intent(in) :: neut_type Neutral type real(kind=Float64), intent(in) :: dflux Deposited flux Called By proc~~store_births~~CalledByGraph proc~store_births store_births proc~ndmc ndmc proc~ndmc->proc~store_births program~fidasim fidasim program~fidasim->proc~ndmc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code store_births Source Code subroutine store_births ( ind , neut_type , dflux ) !+ Store birth particles/density in [[libfida:birth]] integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices integer ( Int32 ), intent ( in ) :: neut_type !+ Neutral type real ( Float64 ), intent ( in ) :: dflux !+ Deposited flux !$OMP CRITICAL(store_births_1) birth % dens ( neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) = & birth % dens ( neut_type , ind ( 1 ), ind ( 2 ), ind ( 3 )) + dflux !$OMP END CRITICAL(store_births_1) end subroutine store_births","tags":"","loc":"proc/store_births.html","title":"store_births – FIDASIM"},{"text":"public subroutine store_npa(det, ri, rf, vn, flux, orbit_class) Store NPA particles in npa Arguments Type Intent Optional Attributes Name integer, intent(in) :: det Detector/Channel Number real(kind=Float64), intent(in), dimension(3) :: ri Birth position in beam coordinates [cm] real(kind=Float64), intent(in), dimension(3) :: rf Detector position in beam coordinates [cm] real(kind=Float64), intent(in), dimension(3) :: vn Particle velocity [cm/s] real(kind=Float64), intent(in) :: flux Neutral flux [neutrals/s] integer, intent(in), optional :: orbit_class Orbit class ID Calls proc~~store_npa~~CallsGraph proc~store_npa store_npa proc~xyz_to_uvw xyz_to_uvw proc~store_npa->proc~xyz_to_uvw proc~get_fields get_fields proc~store_npa->proc~get_fields proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~get_position get_position proc~get_fields->proc~get_position proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff var panprocstore_npaCallsGraph = svgPanZoom('#procstore_npaCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~store_npa~~CalledByGraph proc~store_npa store_npa proc~npa_f npa_f proc~npa_f->proc~store_npa proc~npa_mc npa_mc proc~npa_mc->proc~store_npa program~fidasim fidasim program~fidasim->proc~npa_f program~fidasim->proc~npa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code store_npa Source Code subroutine store_npa ( det , ri , rf , vn , flux , orbit_class ) !+ Store NPA particles in [[libfida:npa]] integer , intent ( in ) :: det !+ Detector/Channel Number real ( Float64 ), dimension ( 3 ), intent ( in ) :: ri !+ Birth position in beam coordinates [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: rf !+ Detector position in beam coordinates [cm] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vn !+ Particle velocity [cm/s] real ( Float64 ), intent ( in ) :: flux !+ Neutral flux [neutrals/s] integer , intent ( in ), optional :: orbit_class !+ Orbit class ID integer :: iclass type ( LocalEMFields ) :: fields real ( Float64 ), dimension ( 3 ) :: uvw_ri , uvw_rf , vn_norm real ( Float64 ) :: energy , pitch , dE integer ( Int32 ), dimension ( 1 ) :: ienergy type ( NPAParticle ), dimension (:), allocatable :: parts if ( present ( orbit_class )) then iclass = orbit_class else iclass = 1 endif ! Convert to machine coordinates call xyz_to_uvw ( ri , uvw_ri ) call xyz_to_uvw ( rf , uvw_rf ) ! Calculate energy energy = inputs % ab * v2_to_E_per_amu * dot_product ( vn , vn ) dE = npa % energy ( 2 ) - npa % energy ( 1 ) ! Calculate pitch if distribution actually uses pitch if ( inputs % dist_type . le . 2 ) then call get_fields ( fields , pos = ri ) vn_norm = vn / norm2 ( vn ) pitch = dot_product ( fields % b_norm , vn_norm ) else pitch = 0.d0 endif !$OMP CRITICAL(store_npa_1) npa % npart = npa % npart + 1 if ( npa % npart . gt . npa % nmax ) then npa % nmax = int ( npa % nmax * 2 ) allocate ( parts ( npa % nmax )) parts ( 1 :( npa % npart - 1 )) = npa % part deallocate ( npa % part ) call move_alloc ( parts , npa % part ) endif npa % part ( npa % npart )% detector = det npa % part ( npa % npart )% xi = uvw_ri ( 1 ) npa % part ( npa % npart )% yi = uvw_ri ( 2 ) npa % part ( npa % npart )% zi = uvw_ri ( 3 ) npa % part ( npa % npart )% xf = uvw_rf ( 1 ) npa % part ( npa % npart )% yf = uvw_rf ( 2 ) npa % part ( npa % npart )% zf = uvw_rf ( 3 ) npa % part ( npa % npart )% energy = energy npa % part ( npa % npart )% pitch = pitch npa % part ( npa % npart )% weight = flux ienergy = minloc ( abs ( npa % energy - energy )) npa % flux ( ienergy ( 1 ), det , iclass ) = & npa % flux ( ienergy ( 1 ), det , iclass ) + flux / dE !$OMP END CRITICAL(store_npa_1) end subroutine store_npa","tags":"","loc":"proc/store_npa.html","title":"store_npa – FIDASIM"},{"text":"public subroutine neut_rates(denn, vi, vn, rates) Get neutralization/cx rates Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(nlevs) :: denn Neutral density [cm&#94;-3] real(kind=Float64), intent(in), dimension(3) :: vi Ion velocity [cm/s] real(kind=Float64), intent(in), dimension(3) :: vn Neutral velocity [cm/s] real(kind=Float64), intent(out), dimension(nlevs) :: rates Reaction rates [1/s] Calls proc~~neut_rates~~CallsGraph proc~neut_rates neut_rates interface~interpol_coeff interpol_coeff proc~neut_rates->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~neut_rates~~CalledByGraph proc~neut_rates neut_rates proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~neut_rates proc~get_beam_cx_prob get_beam_cx_prob proc~get_beam_cx_prob->proc~neut_rates program~fidasim fidasim program~fidasim->proc~fida_weights_los proc~fida_f fida_f program~fidasim->proc~fida_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~dcx dcx program~fidasim->proc~dcx proc~halo halo program~fidasim->proc~halo proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_f->proc~get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~dcx->proc~get_beam_cx_prob proc~halo->proc~get_beam_cx_prob proc~npa_mc->proc~get_beam_cx_prob proc~npa_weights->proc~get_beam_cx_prob proc~npa_f->proc~get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code neut_rates Source Code subroutine neut_rates ( denn , vi , vn , rates ) !+ Get neutralization/cx rates real ( Float64 ), dimension ( nlevs ), intent ( in ) :: denn !+ Neutral density [cm&#94;-3] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Ion velocity [cm/s] real ( Float64 ), dimension ( 3 ), intent ( in ) :: vn !+ Neutral velocity [cm/s] real ( Float64 ), dimension ( nlevs ), intent ( out ) :: rates !+ Reaction rates [1/s] real ( Float64 ), dimension ( nlevs , nlevs ) :: neut !!rate coeff real ( Float64 ) :: eb !! relative Energy type ( InterpolCoeffs1D ) :: c real ( Float64 ) :: dlogE , logEmin , logeb real ( Float64 ) :: vrel !! relative velocity integer :: ebi , neb , err !Eeff vrel = norm2 ( vi - vn ) eb = v2_to_E_per_amu * vrel ** 2 ! [kev/amu] logeb = log10 ( eb ) logEmin = tables % H_H_cx % logemin dlogE = tables % H_H_cx % dlogE neb = tables % H_H_cx % nenergy call interpol_coeff ( logEmin , dlogE , neb , logeb , c , err ) ebi = c % i if ( err . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"NEUT_RATES: Eb out of range of H_H_cx table. Using nearest energy value.\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb endif if ( ebi . lt . 1 ) then ebi = 1 c % b1 = 1.0 ; c % b2 = 0.0 else ebi = neb c % b1 = 0.0 ; c % b2 = 1.0 endif endif neut (:,:) = ( c % b1 * tables % H_H_cx % log_cross (:,:, ebi ) + & c % b2 * tables % H_H_cx % log_cross (:,:, ebi + 1 )) where ( neut . lt . tables % H_H_cx % minlog_cross ) neut = 0.d0 elsewhere neut = 1 0.d0 ** neut end where rates = matmul ( neut , denn ) * vrel end subroutine neut_rates","tags":"","loc":"proc/neut_rates.html","title":"neut_rates – FIDASIM"},{"text":"public subroutine get_neutron_rate(plasma, eb, rate) Gets neutron rate for a beam with energy eb interacting with a target plasma Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma Plasma Paramters real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(out) :: rate Neutron reaction rate [1/s] Calls proc~~get_neutron_rate~~CallsGraph proc~get_neutron_rate get_neutron_rate interface~interpol_coeff interpol_coeff proc~get_neutron_rate->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~get_neutron_rate~~CalledByGraph proc~get_neutron_rate get_neutron_rate proc~neutron_f neutron_f proc~neutron_f->proc~get_neutron_rate proc~neutron_mc neutron_mc proc~neutron_mc->proc~get_neutron_rate program~fidasim fidasim program~fidasim->proc~neutron_f program~fidasim->proc~neutron_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_neutron_rate Source Code subroutine get_neutron_rate ( plasma , eb , rate ) !+ Gets neutron rate for a beam with energy `eb` interacting with a target plasma type ( LocalProfiles ), intent ( in ) :: plasma !+ Plasma Paramters real ( Float64 ), intent ( in ) :: eb !+ Beam energy [keV] real ( Float64 ), intent ( out ) :: rate !+ Neutron reaction rate [1/s] integer :: err_status , neb , nt , ebi , tii real ( Float64 ) :: dlogE , dlogT , logEmin , logTmin real ( Float64 ) :: logeb , logti , lograte , denp type ( InterpolCoeffs2D ) :: c real ( Float64 ) :: b11 , b12 , b21 , b22 logeb = log10 ( eb ) logti = log10 ( plasma % ti ) denp = plasma % denp !!D_D err_status = 1 logEmin = tables % D_D % logemin logTmin = tables % D_D % logtmin dlogE = tables % D_D % dlogE dlogT = tables % D_D % dlogT neb = tables % D_D % nenergy nt = tables % D_D % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , c , err_status ) ebi = c % i tii = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_NEUTRON_RATE: Eb or Ti out of range of D_D table. Setting D_D rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",ES10.3,\" [keV]\")' ) plasma % ti endif denp = 0.d0 endif lograte = ( b11 * tables % D_D % log_rate ( ebi , tii , 2 ) + & b12 * tables % D_D % log_rate ( ebi , tii + 1 , 2 ) + & b21 * tables % D_D % log_rate ( ebi + 1 , tii , 2 ) + & b22 * tables % D_D % log_rate ( ebi + 1 , tii + 1 , 2 )) if ( lograte . lt . tables % D_D % minlog_rate ) then rate = 0.d0 else rate = denp * 1 0.d0 ** lograte endif end subroutine get_neutron_rate","tags":"","loc":"proc/get_neutron_rate.html","title":"get_neutron_rate – FIDASIM"},{"text":"public subroutine get_beam_cx_prob(ind, pos, v_ion, types, prob) Get probability of a thermal ion charge exchanging with types neutrals Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind beam_grid indices real(kind=Float64), intent(in), dimension(3) :: pos Interaction position in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: v_ion Ion velocity [cm/s] integer(kind=Int32), intent(in), dimension(:) :: types Neutral types real(kind=Float64), intent(out), dimension(nlevs) :: prob Charge exchange rate/probability [1/s] Calls proc~~get_beam_cx_prob~~CallsGraph proc~get_beam_cx_prob get_beam_cx_prob proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~mc_halo mc_halo proc~get_beam_cx_prob->proc~mc_halo interface~interpol_coeff interpol_coeff proc~neut_rates->interface~interpol_coeff proc~randu randu proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~get_plasma get_plasma proc~mc_halo->proc~get_plasma proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~get_position get_position proc~get_plasma->proc~get_position proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~rng_normal->proc~rng_uniform proc~in_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw var panprocget_beam_cx_probCallsGraph = svgPanZoom('#procget_beam_cx_probCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~get_beam_cx_prob~~CalledByGraph proc~get_beam_cx_prob get_beam_cx_prob proc~fida_f fida_f proc~fida_f->proc~get_beam_cx_prob proc~fida_mc fida_mc proc~fida_mc->proc~get_beam_cx_prob proc~dcx dcx proc~dcx->proc~get_beam_cx_prob proc~halo halo proc~halo->proc~get_beam_cx_prob proc~npa_mc npa_mc proc~npa_mc->proc~get_beam_cx_prob proc~npa_weights npa_weights proc~npa_weights->proc~get_beam_cx_prob proc~npa_f npa_f proc~npa_f->proc~get_beam_cx_prob proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_beam_cx_prob program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~npa_mc program~fidasim->proc~npa_weights program~fidasim->proc~npa_f program~fidasim->proc~fida_weights_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_beam_cx_prob Source Code subroutine get_beam_cx_prob ( ind , pos , v_ion , types , prob ) !+ Get probability of a thermal ion charge exchanging with `types` neutrals integer ( Int32 ), dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Interaction position in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: v_ion !+ Ion velocity [cm/s] integer ( Int32 ), dimension (:), intent ( in ) :: types !+ Neutral types real ( Float64 ), dimension ( nlevs ), intent ( out ) :: prob !+ Charge exchange rate/probability [1/s] integer :: ntypes , i , ii real ( Float64 ), dimension ( nlevs ) :: rates , denn real ( Float64 ), dimension ( 3 ) :: vhalo , vnbi , vn vnbi = pos - nbi % src vnbi = vnbi / norm2 ( vnbi ) * nbi % vinj ntypes = size ( types ) prob = 0 do i = 1 , ntypes if (( types ( i ). le . 3 ). and .( types ( i ). ne . 0 )) then ! CX with full type'th energy NBI neutrals denn = neut % dens (:, types ( i ), ind ( 1 ), ind ( 2 ), ind ( 3 )) vn = vnbi / sqrt ( real ( types ( i ))) call neut_rates ( denn , v_ion , vn , rates ) prob = prob + rates else denn = neut % dens (:, types ( i ), ind ( 1 ), ind ( 2 ), ind ( 3 )) do ii = 1 , int ( n_halo_neutrate ) call mc_halo ( ind , vhalo ) call neut_rates ( denn , v_ion , vhalo , rates ) prob = prob + rates / n_halo_neutrate enddo endif enddo end subroutine get_beam_cx_prob","tags":"","loc":"proc/get_beam_cx_prob.html","title":"get_beam_cx_prob – FIDASIM"},{"text":"public subroutine get_rate_matrix(plasma, i_type, eb, rmat) Gets rate matrix for use in colrad Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma Plasma parameters integer, intent(in) :: i_type Ion type real(kind=Float64), intent(in) :: eb Ion energy [keV] real(kind=Float64), intent(out), dimension(nlevs,nlevs) :: rmat Rate matrix Calls proc~~get_rate_matrix~~CallsGraph proc~get_rate_matrix get_rate_matrix interface~interpol_coeff interpol_coeff proc~get_rate_matrix->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~get_rate_matrix~~CalledByGraph proc~get_rate_matrix get_rate_matrix proc~colrad colrad proc~colrad->proc~get_rate_matrix proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_rate_matrix Source Code subroutine get_rate_matrix ( plasma , i_type , eb , rmat ) !+ Gets rate matrix for use in [[libfida:colrad]] type ( LocalProfiles ), intent ( in ) :: plasma !+ Plasma parameters integer , intent ( in ) :: i_type !+ Ion type real ( Float64 ), intent ( in ) :: eb !+ Ion energy [keV] real ( Float64 ), dimension ( nlevs , nlevs ), intent ( out ) :: rmat !+ Rate matrix real ( Float64 ) :: logEmin , dlogE , logeb real ( Float64 ) :: logTmin , dlogT , logti , logte integer :: neb , nt type ( InterpolCoeffs2D ) :: c real ( Float64 ) :: b11 , b12 , b21 , b22 , dene , denp , denimp real ( Float64 ), dimension ( nlevs , nlevs ) :: H_H_pop , H_e_pop , H_Aq_pop real ( Float64 ), dimension ( nlevs ) :: H_H_depop , H_e_depop , H_Aq_depop integer :: ebi , tii , tei , n , err_status H_H_pop = 0.d0 H_e_pop = 0.d0 H_Aq_pop = 0.d0 H_H_depop = 0.d0 H_e_depop = 0.d0 H_Aq_depop = 0.d0 denp = plasma % denp dene = plasma % dene denimp = plasma % denimp logeb = log10 ( eb ) logti = log10 ( plasma % ti ) logte = log10 ( plasma % te ) !!H_H err_status = 1 logEmin = tables % H_H % logemin logTmin = tables % H_H % logtmin dlogE = tables % H_H % dlogE dlogT = tables % H_H % dlogT neb = tables % H_H % nenergy nt = tables % H_H % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , c , err_status ) ebi = c % i tii = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Ti out of range of H_H table. Setting H_H rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",ES10.3,\" [keV]\")' ) plasma % ti endif denp = 0.d0 endif H_H_pop = ( b11 * tables % H_H % log_pop (:,:, ebi , tii , i_type ) + & b12 * tables % H_H % log_pop (:,:, ebi , tii + 1 , i_type ) + & b21 * tables % H_H % log_pop (:,:, ebi + 1 , tii , i_type ) + & b22 * tables % H_H % log_pop (:,:, ebi + 1 , tii + 1 , i_type )) where ( H_H_pop . lt . tables % H_H % minlog_pop ) H_H_pop = 0.d0 elsewhere H_H_pop = denp * 1 0.d0 ** H_H_pop end where H_H_depop = ( b11 * tables % H_H % log_depop (:, ebi , tii , i_type ) + & b12 * tables % H_H % log_depop (:, ebi , tii + 1 , i_type ) + & b21 * tables % H_H % log_depop (:, ebi + 1 , tii , i_type ) + & b22 * tables % H_H % log_depop (:, ebi + 1 , tii + 1 , i_type )) where ( H_H_depop . lt . tables % H_H % minlog_depop ) H_H_depop = 0.d0 elsewhere H_H_depop = denp * 1 0.d0 ** H_H_depop end where !!H_e err_status = 1 logEmin = tables % H_e % logemin logTmin = tables % H_e % logtmin dlogE = tables % H_e % dlogE dlogT = tables % H_e % dlogT neb = tables % H_e % nenergy nt = tables % H_e % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logte , c , err_status ) ebi = c % i tei = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Te out of range of H_e table. Setting H_e rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"te = \",ES10.3,\" [keV]\")' ) plasma % te endif dene = 0.d0 endif H_e_pop = ( b11 * tables % H_e % log_pop (:,:, ebi , tei , i_type ) + & b12 * tables % H_e % log_pop (:,:, ebi , tei + 1 , i_type ) + & b21 * tables % H_e % log_pop (:,:, ebi + 1 , tei , i_type ) + & b22 * tables % H_e % log_pop (:,:, ebi + 1 , tei + 1 , i_type )) where ( H_e_pop . lt . tables % H_e % minlog_pop ) H_e_pop = 0.d0 elsewhere H_e_pop = dene * 1 0.d0 ** H_e_pop end where H_e_depop = ( b11 * tables % H_e % log_depop (:, ebi , tei , i_type ) + & b12 * tables % H_e % log_depop (:, ebi , tei + 1 , i_type ) + & b21 * tables % H_e % log_depop (:, ebi + 1 , tei , i_type ) + & b22 * tables % H_e % log_depop (:, ebi + 1 , tei + 1 , i_type )) where ( H_e_depop . lt . tables % H_e % minlog_depop ) H_e_depop = 0.d0 elsewhere H_e_depop = dene * 1 0.d0 ** H_e_depop end where !!H_Aq err_status = 1 logEmin = tables % H_Aq % logemin logTmin = tables % H_Aq % logtmin dlogE = tables % H_Aq % dlogE dlogT = tables % H_Aq % dlogT neb = tables % H_Aq % nenergy nt = tables % H_Aq % ntemp call interpol_coeff ( logEmin , dlogE , neb , logTmin , dlogT , nt , & logeb , logti , c , err_status ) ebi = c % i tii = c % j b11 = c % b11 b12 = c % b12 b21 = c % b21 b22 = c % b22 if ( err_status . eq . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"GET_RATE_MATRIX: Eb or Ti out of range of H_Aq table. Setting H_Aq rates to zero\" write ( * , '(\"eb = \",ES10.3,\" [keV]\")' ) eb write ( * , '(\"ti = \",ES10.3,\" [keV]\")' ) plasma % ti endif denimp = 0.d0 endif H_Aq_pop = ( b11 * tables % H_Aq % log_pop (:,:, ebi , tii , i_type ) + & b12 * tables % H_Aq % log_pop (:,:, ebi , tii + 1 , i_type ) + & b21 * tables % H_Aq % log_pop (:,:, ebi + 1 , tii , i_type ) + & b22 * tables % H_Aq % log_pop (:,:, ebi + 1 , tii + 1 , i_type )) where ( H_Aq_pop . lt . tables % H_Aq % minlog_pop ) H_Aq_pop = 0.d0 elsewhere H_Aq_pop = denimp * 1 0.d0 ** H_Aq_pop end where H_Aq_depop = ( b11 * tables % H_Aq % log_depop (:, ebi , tii , i_type ) + & b12 * tables % H_Aq % log_depop (:, ebi , tii + 1 , i_type ) + & b21 * tables % H_Aq % log_depop (:, ebi + 1 , tii , i_type ) + & b22 * tables % H_Aq % log_depop (:, ebi + 1 , tii + 1 , i_type )) where ( H_Aq_depop . lt . tables % H_Aq % minlog_depop ) H_Aq_depop = 0.d0 elsewhere H_Aq_depop = denimp * 1 0.d0 ** H_Aq_depop end where rmat = tables % einstein + H_H_pop + H_e_pop + H_Aq_pop do n = 1 , nlevs rmat ( n , n ) = - sum ( tables % einstein (:, n )) - H_H_depop ( n ) - H_e_depop ( n ) - H_Aq_depop ( n ) enddo end subroutine get_rate_matrix","tags":"","loc":"proc/get_rate_matrix.html","title":"get_rate_matrix – FIDASIM"},{"text":"public subroutine colrad(plasma, i_type, vn, dt, states, dens, photons) Evolve density of states in time dt via collisional radiative model Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma Plasma parameters integer, intent(in) :: i_type Ion/Neutral type (beam,thermal) real(kind=Float64), intent(in), dimension(:) :: vn Neutral velocitiy [cm/s] real(kind=Float64), intent(in) :: dt Time interval [s] real(kind=Float64), intent(inout), dimension(:) :: states Density of states real(kind=Float64), intent(out), dimension(nlevs) :: dens Density of neutrals real(kind=Float64), intent(out) :: photons Emitted photons(3->2) Calls proc~~colrad~~CallsGraph proc~colrad colrad proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~lubksb lubksb proc~matinv->proc~lubksb proc~ludcmp ludcmp proc~matinv->proc~ludcmp interface~interpol_coeff interpol_coeff proc~get_rate_matrix->interface~interpol_coeff proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balance balance proc~eigen->proc~balance proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~rswap RSWAP proc~balance->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~elmhes->proc~rswap proc~comdiv Comdiv proc~hqrvec->proc~comdiv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~colrad~~CalledByGraph proc~colrad colrad proc~fida_f fida_f proc~fida_f->proc~colrad proc~fida_mc fida_mc proc~fida_mc->proc~colrad proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~colrad proc~dcx dcx proc~dcx->proc~colrad proc~halo halo proc~halo->proc~colrad proc~attenuate attenuate proc~attenuate->proc~colrad proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~colrad proc~ndmc ndmc proc~ndmc->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~npa_f npa_f program~fidasim->proc~npa_f proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_f->proc~attenuate proc~npa_weights->proc~attenuate proc~npa_mc->proc~attenuate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code colrad Source Code subroutine colrad ( plasma , i_type , vn , dt , states , dens , photons ) !+ Evolve density of states in time `dt` via collisional radiative model type ( LocalProfiles ), intent ( in ) :: plasma !+ Plasma parameters integer , intent ( in ) :: i_type !+ Ion/Neutral type (beam,thermal) real ( Float64 ), dimension (:), intent ( in ) :: vn !+ Neutral velocitiy [cm/s] real ( Float64 ), intent ( in ) :: dt !+ Time interval [s] real ( Float64 ), dimension (:), intent ( inout ) :: states !+ Density of states real ( Float64 ), dimension ( nlevs ), intent ( out ) :: dens !+ Density of neutrals real ( Float64 ), intent ( out ) :: photons !+ Emitted photons(3->2) real ( Float64 ), dimension ( nlevs , nlevs ) :: matrix !! Matrix real ( Float64 ) :: b_amu real ( Float64 ) :: vnet_square !! net velocity of neutrals squared real ( Float64 ) :: eb !! Energy of the fast neutral real ( Float64 ), dimension ( nlevs , nlevs ) :: eigvec , eigvec_inv real ( Float64 ), dimension ( nlevs ) :: eigval , coef real ( Float64 ), dimension ( nlevs ) :: exp_eigval_dt real ( Float64 ) :: iflux !!Initial total flux integer :: n photons = 0.d0 dens = 0.d0 iflux = sum ( states ) if ( iflux . lt . colrad_threshold . and . inputs % calc_npa . eq . 0 ) then return endif if (. not . plasma % in_plasma ) then dens = states * dt return endif if ( i_type . eq . beam_ion ) then b_amu = inputs % ab else b_amu = inputs % ai endif vnet_square = dot_product ( vn - plasma % vrot , vn - plasma % vrot ) ![cm/s] eb = v2_to_E_per_amu * b_amu * vnet_square ![kev] call get_rate_matrix ( plasma , i_type , eb , matrix ) call eigen ( nlevs , matrix , eigvec , eigval ) call matinv ( eigvec , eigvec_inv ) coef = matmul ( eigvec_inv , states ) !coeffs determined from states at t=0 exp_eigval_dt = exp ( eigval * dt ) ! to improve speed (used twice) do n = 1 , nlevs if ( eigval ( n ). eq . 0.0 ) eigval ( n ) = eigval ( n ) + 1 !protect against dividing by zero enddo states = matmul ( eigvec , coef * exp_eigval_dt ) ![neutrals/cm&#94;3/s]! dens = matmul ( eigvec , coef * ( exp_eigval_dt - 1.d0 ) / eigval ) if (( minval ( states ). lt . 0 ). or .( minval ( dens ). lt . 0 )) then do n = 1 , nlevs if ( states ( n ). lt . 0 ) states ( n ) = 0.d0 if ( dens ( n ). lt . 0 ) dens ( n ) = 0.d0 enddo endif photons = dens ( 3 ) * tables % einstein ( 2 , 3 ) !! - [Ph/(s*cm&#94;3)] - !! end subroutine colrad","tags":"","loc":"proc/colrad.html","title":"colrad – FIDASIM"},{"text":"public subroutine attenuate(ri, rf, vi, states, dstep_in) Attenuate states along a trajectory Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: ri Initial position in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: rf Final position in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: vi Initial velocity of neutral real(kind=Float64), intent(inout), dimension(nlevs) :: states Density of states real(kind=Float64), intent(in), optional :: dstep_in Step length [cm] Calls proc~~attenuate~~CallsGraph proc~attenuate attenuate proc~get_plasma get_plasma proc~attenuate->proc~get_plasma proc~colrad colrad proc~attenuate->proc~colrad proc~get_position get_position proc~get_plasma->proc~get_position proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~lubksb lubksb proc~matinv->proc~lubksb proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~get_rate_matrix->interface~interpol_coeff proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balance balance proc~eigen->proc~balance proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~elmhes->proc~rswap proc~comdiv Comdiv proc~hqrvec->proc~comdiv var panprocattenuateCallsGraph = svgPanZoom('#procattenuateCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~attenuate~~CalledByGraph proc~attenuate attenuate proc~npa_f npa_f proc~npa_f->proc~attenuate proc~npa_weights npa_weights proc~npa_weights->proc~attenuate proc~npa_mc npa_mc proc~npa_mc->proc~attenuate program~fidasim fidasim program~fidasim->proc~npa_f program~fidasim->proc~npa_weights program~fidasim->proc~npa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code attenuate Source Code subroutine attenuate ( ri , rf , vi , states , dstep_in ) !+ Attenuate `states` along a trajectory real ( Float64 ), dimension ( 3 ), intent ( in ) :: ri !+ Initial position in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: rf !+ Final position in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Initial velocity of neutral real ( Float64 ), dimension ( nlevs ), intent ( inout ) :: states !+ Density of states real ( Float64 ), intent ( in ), optional :: dstep_in !+ Step length [cm] type ( LocalProfiles ) :: plasma real ( Float64 ) :: photons , vabs , dt , dstep , dis , max_dis real ( Float64 ), dimension ( 3 ) :: r0 real ( Float64 ), dimension ( nlevs ) :: dens if ( present ( dstep_in )) then dstep = dstep_in else dstep = sqrt ( inter_grid % da ) !cm endif max_dis = norm2 ( rf - ri ) vabs = norm2 ( vi ) dt = dstep / vabs call get_plasma ( plasma , pos = ri ) r0 = ri dis = 0.d0 do while ( dis . le . max_dis ) call colrad ( plasma , beam_ion , vi , dt , states , dens , photons ) r0 = r0 + vi * dt dis = dis + dstep call get_plasma ( plasma , pos = r0 ) enddo end subroutine attenuate","tags":"","loc":"proc/attenuate.html","title":"attenuate – FIDASIM"},{"text":"public subroutine spectrum(vecp, vi, fields, sigma_pi, photons, dlength, lambda, intensity) Calculates doppler shift and stark splitting Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: vecp Vector directing towards optical head real(kind=Float64), intent(in), dimension(3) :: vi Particle velocity type( LocalEMFields ), intent(in) :: fields Electro-magnetic fields real(kind=Float64), intent(in) :: sigma_pi Sigma-pi ratio real(kind=Float64), intent(in) :: photons Photon density from colrad real(kind=Float64), intent(in) :: dlength LOS intersection length with beam_grid cell particle is in real(kind=Float64), intent(out), dimension(n_stark) :: lambda Wavelengths [nm] real(kind=Float64), intent(out), dimension(n_stark) :: intensity Spectra intensities [Ph/(s cm&#94;2 starkline)] Called By proc~~spectrum~~CalledByGraph proc~spectrum spectrum proc~store_bes_photons store_bes_photons proc~store_bes_photons->proc~spectrum proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~store_fw_photons_at_chan->proc~spectrum proc~store_fida_photons store_fida_photons proc~store_fida_photons->proc~spectrum proc~dcx dcx proc~dcx->proc~store_bes_photons proc~ndmc ndmc proc~ndmc->proc~store_bes_photons proc~halo halo proc~halo->proc~store_bes_photons program~fidasim fidasim program~fidasim->proc~dcx program~fidasim->proc~ndmc program~fidasim->proc~halo proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_f fida_f program~fidasim->proc~fida_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~store_fw_photons_at_chan proc~fida_weights_los->proc~store_fw_photons_at_chan proc~fida_weights_mc->proc~store_fw_photons proc~fida_f->proc~store_fida_photons proc~fida_mc->proc~store_fida_photons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code spectrum Source Code subroutine spectrum ( vecp , vi , fields , sigma_pi , photons , dlength , lambda , intensity ) !+ Calculates doppler shift and stark splitting real ( Float64 ), dimension ( 3 ), intent ( in ) :: vecp !+ Vector directing towards optical head real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Particle velocity type ( LocalEMFields ), intent ( in ) :: fields !+ Electro-magnetic fields real ( Float64 ), intent ( in ) :: sigma_pi !+ Sigma-pi ratio real ( Float64 ), intent ( in ) :: photons !+ Photon density from [[libfida:colrad]] real ( Float64 ), intent ( in ) :: dlength !+ LOS intersection length with [[libfida:beam_grid]] cell particle is in real ( Float64 ), dimension ( n_stark ), intent ( out ) :: lambda !+ Wavelengths [nm] real ( Float64 ), dimension ( n_stark ), intent ( out ) :: intensity !+ Spectra intensities [Ph/(s cm&#94;2 starkline)] real ( Float64 ), dimension ( 3 ) :: vp , vn real ( Float64 ), dimension ( 3 ) :: bfield , efield real ( Float64 ) :: E , cos_los_Efield , lambda_shifted integer , parameter , dimension ( n_stark ) :: stark_sign = + 1 * stark_sigma - 1 * stark_pi !! vector directing towards the optical head vp = vecp / norm2 ( vecp ) ! Calculate Doppler shift vn = vi * 0.01d0 ! [m/s] lambda_shifted = lambda0 * ( 1.d0 + dot_product ( vn , vp ) / c0 ) !! Calculate Stark Splitting ! Calculate E-field bfield = fields % b_norm * fields % b_abs efield = fields % e_norm * fields % e_abs efield ( 1 ) = efield ( 1 ) + vn ( 2 ) * bfield ( 3 ) - vn ( 3 ) * bfield ( 2 ) efield ( 2 ) = efield ( 2 ) - ( vn ( 1 ) * bfield ( 3 ) - vn ( 3 ) * bfield ( 1 )) efield ( 3 ) = efield ( 3 ) + vn ( 1 ) * bfield ( 2 ) - vn ( 2 ) * bfield ( 1 ) E = norm2 ( efield ) !Stark Splitting lambda = lambda_shifted + E * stark_wavel ![nm] !Intensities of stark components if ( E . eq . 0.d0 ) then cos_los_Efield = 0.d0 else cos_los_Efield = dot_product ( vp , efield ) / E endif intensity = stark_intens * ( 1.d0 + stark_sign * cos_los_Efield ** 2 ) !! E.g. mirrors may change the pi to sigma intensity ratio where ( stark_sigma . eq . 1 ) intensity = intensity * sigma_pi endwhere !! normalize and multiply with photon density from colrad intensity = intensity / sum ( intensity ) * photons * dlength endsubroutine spectrum","tags":"","loc":"proc/spectrum.html","title":"spectrum – FIDASIM"},{"text":"public subroutine store_bes_photons(pos, vi, photons, neut_type) Store BES photons in Spectra Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position of neutral in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: vi Velocitiy of neutral [cm/s] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] integer, intent(in) :: neut_type Neutral type (full,half,third,halo) Calls proc~~store_bes_photons~~CallsGraph proc~store_bes_photons store_bes_photons proc~get_indices get_indices proc~store_bes_photons->proc~get_indices proc~get_fields get_fields proc~store_bes_photons->proc~get_fields proc~spectrum spectrum proc~store_bes_photons->proc~spectrum proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~get_position get_position proc~get_fields->proc~get_position proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff var panprocstore_bes_photonsCallsGraph = svgPanZoom('#procstore_bes_photonsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~store_bes_photons~~CalledByGraph proc~store_bes_photons store_bes_photons proc~dcx dcx proc~dcx->proc~store_bes_photons proc~ndmc ndmc proc~ndmc->proc~store_bes_photons proc~halo halo proc~halo->proc~store_bes_photons program~fidasim fidasim program~fidasim->proc~dcx program~fidasim->proc~ndmc program~fidasim->proc~halo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code store_bes_photons Source Code subroutine store_bes_photons ( pos , vi , photons , neut_type ) !+ Store BES photons in [[libfida:spectra]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position of neutral in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocitiy of neutral [cm/s] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] integer , intent ( in ) :: neut_type !+ Neutral type (full,half,third,halo) real ( Float64 ), dimension ( n_stark ) :: lambda , intensity real ( Float64 ) :: dlength , sigma_pi type ( LocalEMFields ) :: fields integer ( Int32 ), dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: vp type ( LOSInters ) :: inter integer :: ichan , i , j , bin , nchan call get_indices ( pos , ind ) inter = spec_chords % inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) nchan = inter % nchan if ( nchan . eq . 0 ) return call get_fields ( fields , pos = pos ) loop_over_channels : do j = 1 , nchan ichan = inter % los_elem ( j )% id dlength = inter % los_elem ( j )% length sigma_pi = spec_chords % los ( ichan )% sigma_pi vp = pos - spec_chords % los ( ichan )% lens call spectrum ( vp , vi , fields , sigma_pi , photons , & dlength , lambda , intensity ) loop_over_stark : do i = 1 , n_stark bin = floor (( lambda ( i ) - inputs % lambdamin ) / inputs % dlambda ) + 1 if ( bin . lt . 1 ) cycle loop_over_stark if ( bin . gt . inputs % nlambda ) cycle loop_over_stark !$OMP CRITICAL(bes_spectrum) spec % bes ( bin , ichan , neut_type ) = & spec % bes ( bin , ichan , neut_type ) + intensity ( i ) !$OMP END CRITICAL(bes_spectrum) enddo loop_over_stark enddo loop_over_channels end subroutine store_bes_photons","tags":"","loc":"proc/store_bes_photons.html","title":"store_bes_photons – FIDASIM"},{"text":"public subroutine store_fida_photons(pos, vi, photons, orbit_class) Store fida photons in Spectra Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position of neutral in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: vi Velocitiy of neutral [cm/s] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] integer, intent(in), optional :: orbit_class Orbit class ID Calls proc~~store_fida_photons~~CallsGraph proc~store_fida_photons store_fida_photons proc~get_indices get_indices proc~store_fida_photons->proc~get_indices proc~get_fields get_fields proc~store_fida_photons->proc~get_fields proc~spectrum spectrum proc~store_fida_photons->proc~spectrum proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~get_position get_position proc~get_fields->proc~get_position proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff var panprocstore_fida_photonsCallsGraph = svgPanZoom('#procstore_fida_photonsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~store_fida_photons~~CalledByGraph proc~store_fida_photons store_fida_photons proc~fida_f fida_f proc~fida_f->proc~store_fida_photons proc~fida_mc fida_mc proc~fida_mc->proc~store_fida_photons program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~fida_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code store_fida_photons Source Code subroutine store_fida_photons ( pos , vi , photons , orbit_class ) !+ Store fida photons in [[libfida:spectra]] real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position of neutral in beam grid coordinates real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocitiy of neutral [cm/s] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] integer , intent ( in ), optional :: orbit_class !+ Orbit class ID real ( Float64 ), dimension ( n_stark ) :: lambda , intensity real ( Float64 ) :: dlength , sigma_pi type ( LocalEMFields ) :: fields integer ( Int32 ), dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: vp type ( LOSInters ) :: inter integer :: ichan , i , j , bin , iclass , nchan if ( present ( orbit_class )) then iclass = orbit_class else iclass = 1 endif call get_indices ( pos , ind ) inter = spec_chords % inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) nchan = inter % nchan if ( nchan . eq . 0 ) return call get_fields ( fields , pos = pos ) loop_over_channels : do j = 1 , nchan ichan = inter % los_elem ( j )% id dlength = inter % los_elem ( j )% length sigma_pi = spec_chords % los ( ichan )% sigma_pi vp = pos - spec_chords % los ( ichan )% lens call spectrum ( vp , vi , fields , sigma_pi , photons , & dlength , lambda , intensity ) loop_over_stark : do i = 1 , n_stark bin = floor (( lambda ( i ) - inputs % lambdamin ) / inputs % dlambda ) + 1 if ( bin . lt . 1 ) cycle loop_over_stark if ( bin . gt . inputs % nlambda ) cycle loop_over_stark !$OMP CRITICAL(fida_spectrum) spec % fida ( bin , ichan , iclass ) = & spec % fida ( bin , ichan , iclass ) + intensity ( i ) !$OMP END CRITICAL(fida_spectrum) enddo loop_over_stark enddo loop_over_channels end subroutine store_fida_photons","tags":"","loc":"proc/store_fida_photons.html","title":"store_fida_photons – FIDASIM"},{"text":"public subroutine store_neutrons(rate, orbit_class) Store neutron rate in neutron Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: rate Neutron rate [neutrons/sec] integer, intent(in), optional :: orbit_class Orbit class ID Called By proc~~store_neutrons~~CalledByGraph proc~store_neutrons store_neutrons proc~neutron_f neutron_f proc~neutron_f->proc~store_neutrons proc~neutron_mc neutron_mc proc~neutron_mc->proc~store_neutrons program~fidasim fidasim program~fidasim->proc~neutron_f program~fidasim->proc~neutron_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code store_neutrons Source Code subroutine store_neutrons ( rate , orbit_class ) !+ Store neutron rate in [[libfida:neutron]] real ( Float64 ), intent ( in ) :: rate !+ Neutron rate [neutrons/sec] integer , intent ( in ), optional :: orbit_class !+ Orbit class ID integer :: iclass if ( present ( orbit_class )) then iclass = orbit_class else iclass = 1 endif !$OMP CRITICAL(neutron_rate) neutron % rate ( iclass ) = neutron % rate ( iclass ) + rate !$OMP END CRITICAL(neutron_rate) end subroutine store_neutrons","tags":"","loc":"proc/store_neutrons.html","title":"store_neutrons – FIDASIM"},{"text":"public subroutine store_fw_photons_at_chan(ichan, eind, pind, vp, vi, fields, dlength, sigma_pi, denf, photons) Store FIDA weight photons in fweight for a specific channel Arguments Type Intent Optional Attributes Name integer, intent(in) :: ichan Channel index integer, intent(in) :: eind Energy index integer, intent(in) :: pind Pitch index real(kind=Float64), intent(in), dimension(3) :: vp Vector pointing toward optical head real(kind=Float64), intent(in), dimension(3) :: vi Velocity of neutral [cm/s] type( LocalEMFields ), intent(in) :: fields Electro-magnetic fields real(kind=Float64), intent(in) :: dlength LOS intersection length with beam_grid cell particle is in real(kind=Float64), intent(in) :: sigma_pi Sigma-pi ratio for channel real(kind=Float64), intent(in) :: denf Fast-ion density [cm&#94;-3] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] Calls proc~~store_fw_photons_at_chan~~CallsGraph proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~spectrum spectrum proc~store_fw_photons_at_chan->proc~spectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~store_fw_photons_at_chan~~CalledByGraph proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~store_fw_photons store_fw_photons proc~store_fw_photons->proc~store_fw_photons_at_chan proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~store_fw_photons_at_chan proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~store_fw_photons program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_weights_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code store_fw_photons_at_chan Source Code subroutine store_fw_photons_at_chan ( ichan , eind , pind , vp , vi , fields , dlength , sigma_pi , denf , photons ) !+ Store FIDA weight photons in [[libfida:fweight]] for a specific channel integer , intent ( in ) :: ichan !+ Channel index integer , intent ( in ) :: eind !+ Energy index integer , intent ( in ) :: pind !+ Pitch index real ( Float64 ), dimension ( 3 ), intent ( in ) :: vp !+ Vector pointing toward optical head real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocity of neutral [cm/s] type ( LocalEMFields ), intent ( in ) :: fields !+ Electro-magnetic fields real ( Float64 ), intent ( in ) :: dlength !+ LOS intersection length with [[libfida:beam_grid]] cell particle is in real ( Float64 ), intent ( in ) :: sigma_pi !+ Sigma-pi ratio for channel real ( Float64 ), intent ( in ) :: denf !+ Fast-ion density [cm&#94;-3] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] real ( Float64 ), dimension ( n_stark ) :: lambda , intensity real ( Float64 ) :: dlambda , intens_fac integer :: i , bin dlambda = ( inputs % lambdamax_wght - inputs % lambdamin_wght ) / inputs % nlambda_wght intens_fac = ( 1.d0 ) / ( 4.d0 * pi * dlambda ) call spectrum ( vp , vi , fields , sigma_pi , photons , & dlength , lambda , intensity ) !$OMP CRITICAL(fida_wght) loop_over_stark : do i = 1 , n_stark bin = floor (( lambda ( i ) - inputs % lambdamin_wght ) / dlambda ) + 1 if ( bin . lt . 1 ) cycle loop_over_stark if ( bin . gt . inputs % nlambda_wght ) cycle loop_over_stark !fida(bin,ichan)= fida(bin,ichan) + & !  (denf*intens_fac*1.d4)*intensity(i) !ph/(s*nm*sr*m&#94;2) fweight % weight ( bin , eind , pind , ichan ) = & fweight % weight ( bin , eind , pind , ichan ) + intensity ( i ) * intens_fac !(ph*cm)/(s*nm*sr*fast-ion*dE*dp) enddo loop_over_stark if ( denf . gt . 0.d0 ) then fweight % mean_f ( eind , pind , ichan ) = fweight % mean_f ( eind , pind , ichan ) + & ( denf * intens_fac ) * sum ( intensity ) endif !$OMP END CRITICAL(fida_wght) end subroutine store_fw_photons_at_chan","tags":"","loc":"proc/store_fw_photons_at_chan.html","title":"store_fw_photons_at_chan – FIDASIM"},{"text":"public subroutine store_fw_photons(eind, pind, pos, vi, denf, photons) Store FIDA weight photons in fweight Arguments Type Intent Optional Attributes Name integer, intent(in) :: eind Energy index integer, intent(in) :: pind Pitch index real(kind=Float64), intent(in), dimension(3) :: pos Position of neutral real(kind=Float64), intent(in), dimension(3) :: vi Velocity of neutral [cm/s] real(kind=Float64), intent(in) :: denf Fast-ion density [cm&#94;-3] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] Calls proc~~store_fw_photons~~CallsGraph proc~store_fw_photons store_fw_photons proc~get_indices get_indices proc~store_fw_photons->proc~get_indices proc~get_fields get_fields proc~store_fw_photons->proc~get_fields proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~store_fw_photons->proc~store_fw_photons_at_chan proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~get_position get_position proc~get_fields->proc~get_position proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~spectrum spectrum proc~store_fw_photons_at_chan->proc~spectrum proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff var panprocstore_fw_photonsCallsGraph = svgPanZoom('#procstore_fw_photonsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~store_fw_photons~~CalledByGraph proc~store_fw_photons store_fw_photons proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~store_fw_photons program~fidasim fidasim program~fidasim->proc~fida_weights_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code store_fw_photons Source Code subroutine store_fw_photons ( eind , pind , pos , vi , denf , photons ) !+ Store FIDA weight photons in [[libfida:fweight]] integer , intent ( in ) :: eind !+ Energy index integer , intent ( in ) :: pind !+ Pitch index real ( Float64 ), dimension ( 3 ), intent ( in ) :: pos !+ Position of neutral real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Velocity of neutral [cm/s] real ( Float64 ), intent ( in ) :: denf !+ Fast-ion density [cm&#94;-3] real ( Float64 ), intent ( in ) :: photons !+ Photons from [[libfida:colrad]] [Ph/(s*cm&#94;3)] real ( Float64 ) :: dlength , sigma_pi type ( LocalEMFields ) :: fields integer ( Int32 ), dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: vp type ( LOSInters ) :: inter integer :: ichan , nchan , i call get_indices ( pos , ind ) inter = spec_chords % inter ( ind ( 1 ), ind ( 2 ), ind ( 3 )) nchan = inter % nchan if ( nchan . eq . 0 ) return call get_fields ( fields , pos = pos ) loop_over_channels : do i = 1 , nchan ichan = inter % los_elem ( i )% id dlength = inter % los_elem ( i )% length sigma_pi = spec_chords % los ( ichan )% sigma_pi vp = pos - spec_chords % los ( ichan )% lens call store_fw_photons_at_chan ( ichan , eind , pind , & vp , vi , fields , dlength , sigma_pi , denf , photons ) enddo loop_over_channels end subroutine store_fw_photons","tags":"","loc":"proc/store_fw_photons.html","title":"store_fw_photons – FIDASIM"},{"text":"public subroutine get_nlaunch(nr_markers, papprox, papprox_tot, nlaunch) Sets the number of MC markers launched from each beam_grid cell Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: nr_markers Approximate total number of markers to launch real(kind=Float64), intent(in), dimension(:,:,:) :: papprox beam_grid cell weights real(kind=Float64), intent(in) :: papprox_tot Total cell weights real(kind=Float64), intent(out), dimension(:,:,:) :: nlaunch Number of mc markers to launch for each cell: nlaunch(x,y,z) Calls proc~~get_nlaunch~~CallsGraph proc~get_nlaunch get_nlaunch proc~randu randu proc~get_nlaunch->proc~randu omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~get_nlaunch~~CalledByGraph proc~get_nlaunch get_nlaunch proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_nlaunch proc~dcx dcx proc~dcx->proc~get_nlaunch proc~halo halo proc~halo->proc~get_nlaunch proc~npa_f npa_f proc~npa_f->proc~get_nlaunch proc~fida_f fida_f proc~fida_f->proc~get_nlaunch program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~npa_f program~fidasim->proc~fida_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_nlaunch Source Code subroutine get_nlaunch ( nr_markers , papprox , papprox_tot , nlaunch ) !+ Sets the number of MC markers launched from each [[libfida:beam_grid]] cell integer ( Int64 ), intent ( in ) :: nr_markers !+ Approximate total number of markers to launch real ( Float64 ), dimension (:,:,:), intent ( in ) :: papprox !+ [[libfida:beam_grid]] cell weights real ( Float64 ), intent ( in ) :: papprox_tot !+ Total cell weights real ( Float64 ), dimension (:,:,:), intent ( out ) :: nlaunch !+ Number of mc markers to launch for each cell: nlaunch(x,y,z) integer :: i , j , k , cc real ( Float64 ), dimension (:), allocatable :: randomu do i = 1 , 1000 nlaunch (:,:,:) = papprox (:,:,:) / papprox_tot * nr_markers * ( 1. + i * 0.01 ) if ( sum ( nlaunch ). gt . nr_markers ) then exit endif enddo allocate ( randomu ( count ( nlaunch . gt . 0 ))) call randu ( randomu ) cc = 1 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx if ( nlaunch ( i , j , k ). gt . 0. ) then if ( mod ( nlaunch ( i , j , k ), 1. ). gt . randomu ( cc )) then nlaunch ( i , j , k ) = nlaunch ( i , j , k ) + 1. endif cc = cc + 1 endif enddo enddo enddo do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx nlaunch ( i , j , k ) = floor ( nlaunch ( i , j , k )) enddo enddo enddo deallocate ( randomu ) end subroutine get_nlaunch","tags":"","loc":"proc/get_nlaunch.html","title":"get_nlaunch – FIDASIM"},{"text":"public subroutine pitch_to_vec(pitch, gyroangle, fields, vi_norm) Calculates velocity vector from pitch, gyroangle and fields Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: pitch Pitch real(kind=Float64), intent(in) :: gyroangle Gyroangle [radians] type( LocalEMFields ), intent(in) :: fields Electromagnetic fields real(kind=Float64), intent(out), dimension(3) :: vi_norm Normalized velocity vector Called By proc~~pitch_to_vec~~CalledByGraph proc~pitch_to_vec pitch_to_vec proc~gyro_radius gyro_radius proc~gyro_radius->proc~pitch_to_vec proc~gyro_correction gyro_correction proc~gyro_correction->proc~pitch_to_vec proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~pitch_to_vec proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~gyro_correction proc~fida_f fida_f proc~fida_f->proc~gyro_correction proc~neutron_mc neutron_mc proc~neutron_mc->proc~gyro_correction proc~fida_mc fida_mc proc~fida_mc->proc~gyro_correction proc~neutron_f neutron_f proc~neutron_f->proc~gyro_correction program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~fida_mc program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pitch_to_vec Source Code subroutine pitch_to_vec ( pitch , gyroangle , fields , vi_norm ) !+ Calculates velocity vector from pitch, gyroangle and fields real ( Float64 ), intent ( in ) :: pitch !+ Pitch real ( Float64 ), intent ( in ) :: gyroangle !+ Gyroangle [radians] type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields real ( Float64 ), dimension ( 3 ), intent ( out ) :: vi_norm !+ Normalized velocity vector real ( Float64 ) :: sinus sinus = sqrt ( max ( 1.d0 - pitch ** 2 , 0.d0 )) vi_norm = ( sinus * cos ( gyroangle ) * fields % a_norm + & pitch * fields % b_norm + & sinus * sin ( gyroangle ) * fields % c_norm ) end subroutine pitch_to_vec","tags":"","loc":"proc/pitch_to_vec.html","title":"pitch_to_vec – FIDASIM"},{"text":"public subroutine gyro_step(vi, fields, r_gyro) Calculates gyro-step Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: vi Ion velocity type( LocalEMFields ), intent(in) :: fields Electro-magnetic fields real(kind=Float64), intent(out), dimension(3) :: r_gyro Gyro-step\n Gyro-radius vector from particle position to guiding center Calls proc~~gyro_step~~CallsGraph proc~gyro_step gyro_step proc~cross_product cross_product proc~gyro_step->proc~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~gyro_step~~CalledByGraph proc~gyro_step gyro_step proc~gyro_radius gyro_radius proc~gyro_radius->proc~gyro_step proc~gyro_correction gyro_correction proc~gyro_correction->proc~gyro_step proc~npa_weights npa_weights proc~npa_weights->proc~gyro_step proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~gyro_correction proc~fida_f fida_f proc~fida_f->proc~gyro_correction proc~neutron_mc neutron_mc proc~neutron_mc->proc~gyro_correction proc~fida_mc fida_mc proc~fida_mc->proc~gyro_correction proc~neutron_f neutron_f proc~neutron_f->proc~gyro_correction program~fidasim fidasim program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~fida_mc program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code gyro_step Source Code subroutine gyro_step ( vi , fields , r_gyro ) !+ Calculates gyro-step real ( Float64 ), dimension ( 3 ), intent ( in ) :: vi !+ Ion velocity type ( LocalEMFields ), intent ( in ) :: fields !+ Electro-magnetic fields real ( Float64 ), dimension ( 3 ), intent ( out ) :: r_gyro !+ Gyro-step !+ Gyro-radius vector from particle position to guiding center real ( Float64 ), dimension ( 3 ) :: vxB , rg_uvw , uvw , cuvrxb , b_rtz , grad_B , rg_rtz real ( Float64 ) :: one_over_omega , phi , R , rg_r , vpar , term1 , term2 if ( inputs % no_flr . eq . 0 ) then one_over_omega = inputs % ab * mass_u / ( fields % b_abs * e0 ) vxB = cross_product ( vi , fields % b_norm ) vpar = dot_product ( vi , fields % b_norm ) r_gyro = vxB * one_over_omega !points towards gyrocenter !! Second order correction approximation derived from !! Belova, E. V., N. N. Gorelenkov, and C. Z. Cheng. !! \"Self-consistent equilibrium model of low aspect-ratio !! toroidal plasma with energetic beam ions.\" !! Physics of Plasmas (1994-present) 10.8 (2003): 3240-3251. !! Appendix A: Last equation uvw = fields % uvw R = sqrt ( uvw ( 1 ) ** 2 + uvw ( 2 ) ** 2 ) phi = atan2 ( uvw ( 2 ), uvw ( 1 )) if ( fields % machine_coords ) then rg_uvw = r_gyro else rg_uvw = matmul ( beam_grid % basis , r_gyro ) endif rg_r = rg_uvw ( 1 ) * cos ( phi ) + rg_uvw ( 2 ) * sin ( phi ) b_rtz ( 1 ) = fields % br / fields % b_abs b_rtz ( 2 ) = fields % bt / fields % b_abs b_rtz ( 3 ) = fields % bz / fields % b_abs cuvrxb ( 1 ) = - fields % dbt_dz / fields % b_abs cuvrxb ( 2 ) = ( fields % dbr_dz - fields % dbz_dr ) / fields % b_abs cuvrxb ( 3 ) = fields % dbt_dr / fields % b_abs term1 = vpar * one_over_omega * dot_product ( b_rtz , cuvrxb ) grad_B ( 1 ) = ( fields % br * fields % dbr_dr + fields % bt * fields % dbt_dr + fields % bz * fields % dbz_dr ) / & fields % b_abs grad_B ( 2 ) = 0.0 grad_B ( 3 ) = ( fields % br * fields % dbr_dz + fields % bt * fields % dbt_dz + fields % bz * fields % dbz_dz ) / & fields % b_abs rg_rtz ( 1 ) = rg_uvw ( 1 ) * cos ( phi ) + rg_uvw ( 2 ) * sin ( phi ) rg_rtz ( 2 ) = 0.0 rg_rtz ( 3 ) = rg_uvw ( 3 ) term2 = - 1.0 / ( 2.0 * fields % b_abs ) * dot_product ( rg_rtz , grad_B ) r_gyro = r_gyro * ( 1.0 - term1 - term2 ) if ( 1.0 - term1 - term2 . le . 0.0 ) then write ( * , * ) 'GYRO_STEP: Gyro correction results in negative distances: ' , & 1.0 - term1 - term2 stop endif else r_gyro = 0.d0 endif end subroutine gyro_step","tags":"","loc":"proc/gyro_step.html","title":"gyro_step – FIDASIM"},{"text":"public subroutine gyro_correction(fields, energy, pitch, rp, vp, phi_in) Calculates gyro correction for Guiding Center MC distribution calculation Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: fields Electromagnetic fields at guiding center real(kind=Float64), intent(in) :: energy Energy of particle real(kind=Float64), intent(in) :: pitch Particle pitch w.r.t the magnetic field real(kind=Float64), intent(out), dimension(3) :: rp Particle position real(kind=Float64), intent(out), dimension(3) :: vp Particle velocity real(kind=Float64), intent(in), optional :: phi_in Gyro-angle Calls proc~~gyro_correction~~CallsGraph proc~gyro_correction gyro_correction proc~randu randu proc~gyro_correction->proc~randu proc~pitch_to_vec pitch_to_vec proc~gyro_correction->proc~pitch_to_vec proc~gyro_step gyro_step proc~gyro_correction->proc~gyro_step omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~cross_product cross_product proc~gyro_step->proc~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~gyro_correction~~CalledByGraph proc~gyro_correction gyro_correction proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~gyro_correction proc~fida_f fida_f proc~fida_f->proc~gyro_correction proc~neutron_mc neutron_mc proc~neutron_mc->proc~gyro_correction proc~fida_mc fida_mc proc~fida_mc->proc~gyro_correction proc~neutron_f neutron_f proc~neutron_f->proc~gyro_correction program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_f program~fidasim->proc~neutron_mc program~fidasim->proc~fida_mc program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code gyro_correction Source Code subroutine gyro_correction ( fields , energy , pitch , rp , vp , phi_in ) !+ Calculates gyro correction for Guiding Center MC distribution calculation type ( LocalEMFields ), intent ( in ) :: fields !+ Electromagnetic fields at guiding center real ( Float64 ), intent ( in ) :: energy !+ Energy of particle real ( Float64 ), intent ( in ) :: pitch !+ Particle pitch w.r.t the magnetic field real ( Float64 ), dimension ( 3 ), intent ( out ) :: rp !+ Particle position real ( Float64 ), dimension ( 3 ), intent ( out ) :: vp !+ Particle velocity real ( Float64 ), intent ( in ), optional :: phi_in !+ Gyro-angle real ( Float64 ), dimension ( 3 ) :: vi_norm , r_step real ( Float64 ), dimension ( 1 ) :: randomu real ( Float64 ) :: vabs , phi vabs = sqrt ( energy / ( v2_to_E_per_amu * inputs % ab )) if ( present ( phi_in )) then phi = phi_in else !! Sample gyroangle call randu ( randomu ) phi = 2 * pi * randomu ( 1 ) endif !! Calculate velocity vector call pitch_to_vec ( pitch , phi , fields , vi_norm ) vp = vabs * vi_norm !! Move to particle location call gyro_step ( vp , fields , r_step ) rp = fields % pos - r_step end subroutine gyro_correction","tags":"","loc":"proc/gyro_correction.html","title":"gyro_correction – FIDASIM"},{"text":"public subroutine mc_fastion(ind, fields, eb, ptch, denf) Samples a Guiding Center Fast-ion distribution function at a given beam_grid index Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind beam_grid index type( LocalEMFields ), intent(out) :: fields Electromagnetic fields at the guiding center real(kind=Float64), intent(out) :: eb Energy of the fast ion real(kind=Float64), intent(out) :: ptch Pitch of the fast ion real(kind=Float64), intent(out) :: denf Fast-ion density at guiding center Calls proc~~mc_fastion~~CallsGraph proc~mc_fastion mc_fastion proc~randu randu proc~mc_fastion->proc~randu proc~get_fields get_fields proc~mc_fastion->proc~get_fields interface~randind randind proc~mc_fastion->interface~randind proc~get_distribution get_distribution proc~mc_fastion->proc~get_distribution omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~get_position get_position proc~get_fields->proc~get_position proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~get_distribution->proc~get_position proc~xyz_to_uvw xyz_to_uvw proc~get_distribution->proc~xyz_to_uvw interface~interpol interpol proc~get_distribution->interface~interpol proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff var panprocmc_fastionCallsGraph = svgPanZoom('#procmc_fastionCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~mc_fastion~~CalledByGraph proc~mc_fastion mc_fastion proc~fida_f fida_f proc~fida_f->proc~mc_fastion proc~npa_f npa_f proc~npa_f->proc~mc_fastion program~fidasim fidasim program~fidasim->proc~fida_f program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code mc_fastion Source Code subroutine mc_fastion ( ind , fields , eb , ptch , denf ) !+ Samples a Guiding Center Fast-ion distribution function at a given [[libfida:beam_grid]] index integer , dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] index type ( LocalEMFields ), intent ( out ) :: fields !+ Electromagnetic fields at the guiding center real ( Float64 ), intent ( out ) :: eb !+ Energy of the fast ion real ( Float64 ), intent ( out ) :: ptch !+ Pitch of the fast ion real ( Float64 ), intent ( out ) :: denf !+ Fast-ion density at guiding center real ( Float64 ), dimension ( fbm % nenergy , fbm % npitch ) :: fbeam real ( Float64 ), dimension ( 3 ) :: rg real ( Float64 ), dimension ( 3 ) :: randomu3 integer , dimension ( 2 , 1 ) :: ep_ind call randu ( randomu3 ) rg ( 1 ) = beam_grid % xc ( ind ( 1 )) + beam_grid % dr ( 1 ) * ( randomu3 ( 1 ) - 0.5 ) rg ( 2 ) = beam_grid % yc ( ind ( 2 )) + beam_grid % dr ( 2 ) * ( randomu3 ( 2 ) - 0.5 ) rg ( 3 ) = beam_grid % zc ( ind ( 3 )) + beam_grid % dr ( 3 ) * ( randomu3 ( 3 ) - 0.5 ) denf = 0.d0 call get_fields ( fields , pos = rg ) if (. not . fields % in_plasma ) return call get_distribution ( fbeam , denf , pos = rg , coeffs = fields % c ) call randind ( fbeam , ep_ind ) call randu ( randomu3 ) eb = fbm % energy ( ep_ind ( 1 , 1 )) + fbm % dE * ( randomu3 ( 1 ) - 0.5 ) ptch = fbm % pitch ( ep_ind ( 2 , 1 )) + fbm % dp * ( randomu3 ( 2 ) - 0.5 ) end subroutine mc_fastion","tags":"","loc":"proc/mc_fastion.html","title":"mc_fastion – FIDASIM"},{"text":"public subroutine mc_halo(ind, vhalo, ri, plasma_in) Sample thermal Maxwellian distribution at beam_grid indices ind Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind beam_grid indices real(kind=Float64), intent(out), dimension(3) :: vhalo Velocity [cm/s] real(kind=Float64), intent(out), optional dimension(3) :: ri Position in beam_grid cell type( LocalProfiles ), intent(in), optional :: plasma_in Plasma parameters Calls proc~~mc_halo~~CallsGraph proc~mc_halo mc_halo proc~randu randu proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~get_plasma get_plasma proc~mc_halo->proc~get_plasma omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~get_position get_position proc~get_plasma->proc~get_position proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~rng_normal->proc~rng_uniform proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff var panprocmc_haloCallsGraph = svgPanZoom('#procmc_haloCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~mc_halo~~CalledByGraph proc~mc_halo mc_halo proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~mc_halo proc~dcx dcx proc~dcx->proc~mc_halo proc~get_beam_cx_prob get_beam_cx_prob proc~dcx->proc~get_beam_cx_prob proc~get_beam_cx_prob->proc~mc_halo proc~halo halo proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo proc~fida_f fida_f program~fidasim->proc~fida_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_f->proc~get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~npa_mc->proc~get_beam_cx_prob proc~npa_weights->proc~get_beam_cx_prob proc~npa_f->proc~get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code mc_halo Source Code subroutine mc_halo ( ind , vhalo , ri , plasma_in ) !+ Sample thermal Maxwellian distribution at [[libfida:beam_grid]] indices `ind` integer , dimension ( 3 ), intent ( in ) :: ind !+ [[libfida:beam_grid]] indices real ( Float64 ), dimension ( 3 ), intent ( out ) :: vhalo !+ Velocity [cm/s] real ( Float64 ), dimension ( 3 ), intent ( out ), optional :: ri !+ Position in [[libfida:beam_grid]] cell type ( LocalProfiles ), intent ( in ), optional :: plasma_in !+ Plasma parameters type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( 3 ) :: random3 if (. not . present ( plasma_in )) then if ( present ( ri )) then call randu ( random3 ) ri ( 1 ) = beam_grid % xc ( ind ( 1 )) + beam_grid % dr ( 1 ) * ( random3 ( 1 ) - 0.5 ) ri ( 2 ) = beam_grid % yc ( ind ( 2 )) + beam_grid % dr ( 2 ) * ( random3 ( 2 ) - 0.5 ) ri ( 3 ) = beam_grid % zc ( ind ( 3 )) + beam_grid % dr ( 3 ) * ( random3 ( 3 ) - 0.5 ) call get_plasma ( plasma , pos = ri ) else call get_plasma ( plasma , ind = ind ) endif else plasma = plasma_in endif call randn ( random3 ) vhalo = plasma % vrot + sqrt ( plasma % ti * 0.5 / ( v2_to_E_per_amu * inputs % ai )) * random3 !![cm/s] end subroutine mc_halo","tags":"","loc":"proc/mc_halo.html","title":"mc_halo – FIDASIM"},{"text":"public subroutine mc_nbi(vnbi, efrac, rnbi, err) Generates a neutral beam particle trajectory Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(3) :: vnbi Velocity [cm/s] integer, intent(in) :: efrac Beam neutral type (1,2,3) real(kind=Float64), intent(out), dimension(3) :: rnbi Starting position on beam_grid logical, intent(out) :: err Error Code Calls proc~~mc_nbi~~CallsGraph proc~mc_nbi mc_nbi proc~in_plasma in_plasma proc~mc_nbi->proc~in_plasma proc~randu randu proc~mc_nbi->proc~randu proc~grid_intersect grid_intersect proc~mc_nbi->proc~grid_intersect proc~randn randn proc~mc_nbi->proc~randn proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~rng_normal->proc~rng_uniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~mc_nbi~~CalledByGraph proc~mc_nbi mc_nbi proc~ndmc ndmc proc~ndmc->proc~mc_nbi program~fidasim fidasim program~fidasim->proc~ndmc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code mc_nbi Source Code subroutine mc_nbi ( vnbi , efrac , rnbi , err ) !+ Generates a neutral beam particle trajectory integer , intent ( in ) :: efrac !+ Beam neutral type (1,2,3) real ( Float64 ), dimension ( 3 ), intent ( out ) :: vnbi !+ Velocity [cm/s] real ( Float64 ), dimension ( 3 ), intent ( out ) :: rnbi !+ Starting position on [[libfida:beam_grid]] logical , intent ( out ) :: err !+ Error Code real ( Float64 ), dimension ( 3 ) :: r_exit real ( Float64 ), dimension ( 3 ) :: uvw_src !! Start position on ion source real ( Float64 ), dimension ( 3 ) :: xyz_src !! Start position on ion source real ( Float64 ), dimension ( 3 ) :: uvw_ray !! NBI velocity in uvw coords real ( Float64 ), dimension ( 3 ) :: xyz_ray !! NBI velocity in xyz coords real ( Float64 ), dimension ( 3 ) :: xyz_ape !! Aperture plane intersection point real ( Float64 ), dimension ( 2 ) :: randomu !! uniform random numbers real ( Float64 ), dimension ( 2 ) :: randomn !! normal random numbers real ( Float64 ) :: length , sqrt_rho , theta integer :: i , j logical :: inp , valid_trajectory err = . False . valid_trajectory = . False . rejection_loop : do i = 1 , 1000 call randu ( randomu ) select case ( nbi % shape ) case ( 1 ) ! Uniformally sample in rectangle xyz_src ( 1 ) = 0.d0 xyz_src ( 2 ) = nbi % widy * 2.d0 * ( randomu ( 1 ) - 0.5d0 ) xyz_src ( 3 ) = nbi % widz * 2.d0 * ( randomu ( 2 ) - 0.5d0 ) case ( 2 ) ! Uniformally sample in ellipse sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) xyz_src ( 1 ) = 0.d0 xyz_src ( 2 ) = nbi % widy * sqrt_rho * cos ( theta ) xyz_src ( 3 ) = nbi % widz * sqrt_rho * sin ( theta ) end select !! Create random velocity vector call randn ( randomn ) xyz_ray ( 1 ) = 1.d0 xyz_ray ( 2 ) = ( - xyz_src ( 2 ) / nbi % focy + tan ( nbi % divy ( efrac ) * randomn ( 1 ))) xyz_ray ( 3 ) = ( - xyz_src ( 3 ) / nbi % focz + tan ( nbi % divz ( efrac ) * randomn ( 2 ))) aperture_loop : do j = 1 , nbi % naperture xyz_ape = xyz_ray * nbi % adist ( j ) + xyz_src select case ( nbi % ashape ( j )) case ( 1 ) if (( abs ( xyz_ape ( 2 ) - nbi % aoffy ( j )). gt . nbi % awidy ( j )). or .& ( abs ( xyz_ape ( 3 ) - nbi % aoffz ( j )). gt . nbi % awidz ( j ))) then cycle rejection_loop endif case ( 2 ) if (((( xyz_ape ( 2 ) - nbi % aoffy ( j )) * nbi % awidz ( j )) ** 2 + & (( xyz_ape ( 3 ) - nbi % aoffz ( j )) * nbi % awidy ( j )) ** 2 ). gt . & ( nbi % awidy ( j ) * nbi % awidz ( j )) ** 2 ) then cycle rejection_loop endif end select enddo aperture_loop valid_trajectory = . True . !! Convert to beam centerline coordinates to beam grid coordinates uvw_src = matmul ( nbi % basis , xyz_src ) + nbi % src uvw_ray = matmul ( nbi % basis , xyz_ray ) exit rejection_loop enddo rejection_loop !Set Default trajectory in case rejection sampling fails if (. not . valid_trajectory ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"MC_NBI: Failed to find trajectory though aperture(s). Using beam centerline.\" endif uvw_src = nbi % src uvw_ray = nbi % axis endif vnbi = uvw_ray / norm2 ( uvw_ray ) !! Determine start position on beam grid call grid_intersect ( uvw_src , vnbi , length , rnbi , r_exit ) if ( length . le . 0.0 ) then err = . True . nbi_outside = nbi_outside + 1 endif !! Check if start position is in the plasma call in_plasma ( rnbi , inp ) if ( inp ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"MC_NBI: A beam neutral has started inside the plasma.\" write ( * , '(a)' ) \"Move the beam grid closer to the source to fix\" endif stop endif !! Determine velocity of neutrals corrected by efrac vnbi = vnbi * nbi % vinj / sqrt ( real ( efrac )) end subroutine mc_nbi","tags":"","loc":"proc/mc_nbi.html","title":"mc_nbi – FIDASIM"},{"text":"public subroutine ndmc() Calculates neutral beam deposition and spectra Arguments None Calls proc~~ndmc~~CallsGraph proc~ndmc ndmc interface~randind randind proc~ndmc->interface~randind proc~track track proc~ndmc->proc~track proc~mc_nbi mc_nbi proc~ndmc->proc~mc_nbi proc~get_plasma get_plasma proc~ndmc->proc~get_plasma proc~colrad colrad proc~ndmc->proc~colrad proc~randu randu proc~ndmc->proc~randu proc~store_bes_photons store_bes_photons proc~ndmc->proc~store_bes_photons proc~store_neutrals store_neutrals proc~ndmc->proc~store_neutrals proc~store_births store_births proc~ndmc->proc~store_births proc~get_indices get_indices proc~track->proc~get_indices proc~in_plasma in_plasma proc~track->proc~in_plasma proc~mc_nbi->proc~randu proc~mc_nbi->proc~in_plasma proc~grid_intersect grid_intersect proc~mc_nbi->proc~grid_intersect proc~randn randn proc~mc_nbi->proc~randn proc~get_plasma->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~store_bes_photons->proc~get_indices proc~get_fields get_fields proc~store_bes_photons->proc~get_fields proc~spectrum spectrum proc~store_bes_photons->proc~spectrum proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform proc~lubksb lubksb proc~matinv->proc~lubksb proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~get_rate_matrix->interface~interpol_coeff proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balance balance proc~eigen->proc~balance proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~elmhes->proc~rswap proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~get_fields->proc~in_plasma proc~get_fields->proc~get_position proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors var panprocndmcCallsGraph = svgPanZoom('#procndmcCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~ndmc~~CalledByGraph proc~ndmc ndmc program~fidasim fidasim program~fidasim->proc~ndmc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ndmc Source Code subroutine ndmc !+ Calculates neutral beam deposition and spectra integer :: neut_type !! full half third energy real ( Float64 ) :: nlaunch !! nr. of markers real ( Float64 ) :: nneutrals !! # NBI particles real ( Float64 ), dimension ( 3 ) :: vnbi !! velocities(full..) real ( Float64 ), dimension ( 3 ) :: rnbi !! initial position integer ( Int64 ) :: jj , ii , kk , cnt integer :: ncell type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks integer ( Int64 ), dimension ( 3 ) :: nl_birth type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: states , dens real ( Float64 ) :: photons , iflux integer ( Int32 ), dimension ( 3 ) :: ind real ( Float64 ), dimension ( 1 ) :: randomu integer , dimension ( 1 ) :: randi logical :: err if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) inputs % n_nbi endif !! # of injected neutrals = NBI power/energy_per_particle nneutrals = 1.d6 * nbi % pinj / ( 1.d3 * nbi % einj * e0 & * ( nbi % current_fractions ( 1 ) & + nbi % current_fractions ( 2 ) / 2.d0 & + nbi % current_fractions ( 3 ) / 3.d0 ) ) nlaunch = real ( inputs % n_nbi ) cnt = 0 !$OMP PARALLEL DO schedule(guided) & !$OMP& private(vnbi,rnbi,tracks,ncell,plasma,nl_birth,randi, & !$OMP& states,dens,iflux,photons,neut_type,jj,ii,kk,ind,err) loop_over_markers : do ii = 1 , inputs % n_nbi if ( inputs % calc_birth . ge . 1 ) then !! Determine the type of birth particle (1, 2, or 3) nl_birth = 0 do kk = 1 , inputs % n_birth call randind ( nbi % current_fractions , randi ) nl_birth ( randi ( 1 )) = nl_birth ( randi ( 1 )) + 1 enddo endif energy_fractions : do neut_type = 1 , 3 !! (type = 1: full energy, =2: half energy, =3: third energy call mc_nbi ( vnbi , neut_type , rnbi , err ) if ( err ) cycle energy_fractions call track ( rnbi , vnbi , tracks , ncell ) if ( ncell . eq . 0 ) cycle energy_fractions !! Solve collisional radiative model along track states = 0.d0 states ( 1 ) = nneutrals * nbi % current_fractions ( neut_type ) / beam_grid % dv loop_along_track : do jj = 1 , ncell iflux = sum ( states ) ind = tracks ( jj )% ind call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vnbi , tracks ( jj )% time , states , dens , photons ) call store_neutrals ( ind , neut_type , dens / nlaunch ) tracks ( jj )% flux = ( iflux - sum ( states )) * beam_grid % dv / nlaunch if ( inputs % calc_birth . ge . 1 ) then call store_births ( ind , neut_type , tracks ( jj )% flux ) endif if (( photons . gt . 0.d0 ). and .( inputs % calc_bes . ge . 1 )) then call store_bes_photons ( tracks ( jj )% pos , vnbi , photons / nlaunch , neut_type ) endif enddo loop_along_track if ( inputs % calc_birth . ge . 1 ) then !! Sample according to deposited flux along neutral trajectory !$OMP CRITICAL(ndmc_birth) do kk = 1 , nl_birth ( neut_type ) call randind ( tracks ( 1 : ncell )% flux , randi ) call randu ( randomu ) birth % neut_type ( birth % cnt ) = neut_type birth % ind (:, birth % cnt ) = tracks ( randi ( 1 ))% ind birth % vi (:, birth % cnt ) = vnbi birth % ri (:, birth % cnt ) = tracks ( randi ( 1 ))% pos + & vnbi * ( tracks ( randi ( 1 ))% time * ( randomu ( 1 ) - 0.5 )) birth % cnt = birth % cnt + 1 enddo !$OMP END CRITICAL(ndmc_birth) endif enddo energy_fractions if ( inputs % verbose . ge . 2 ) then cnt = cnt + 1 WRITE ( * , '(f7.2,\"% completed\",a,$)' ) 100 * cnt / nlaunch , char ( 13 ) endif enddo loop_over_markers !$OMP END PARALLEL DO if ( nbi_outside . gt . 0 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(T4,a, f6.2)' ) 'Percent of markers outside the grid: ' , & 10 0. * nbi_outside / ( 3. * inputs % n_nbi ) endif if ( sum ( neut % dens ). eq . 0 ) stop 'Beam does not intersect the grid!' endif end subroutine ndmc","tags":"","loc":"proc/ndmc.html","title":"ndmc – FIDASIM"},{"text":"public subroutine bremsstrahlung() Calculates bremsstrahlung Arguments None Calls proc~~bremsstrahlung~~CallsGraph proc~bremsstrahlung bremsstrahlung proc~randu randu proc~bremsstrahlung->proc~randu proc~line_basis line_basis proc~bremsstrahlung->proc~line_basis proc~get_plasma get_plasma proc~bremsstrahlung->proc~get_plasma omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~tb_zyx tb_zyx proc~line_basis->proc~tb_zyx proc~get_position get_position proc~get_plasma->proc~get_position proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff var panprocbremsstrahlungCallsGraph = svgPanZoom('#procbremsstrahlungCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bremsstrahlung~~CalledByGraph proc~bremsstrahlung bremsstrahlung program~fidasim fidasim program~fidasim->proc~bremsstrahlung Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bremsstrahlung Source Code subroutine bremsstrahlung !+ Calculates bremsstrahlung type ( LocalProfiles ) :: plasma integer :: i , ichan , nc , ic real ( Float64 ) :: dlength , dlambda , gaunt , max_length real ( Float64 ) :: spot_size , theta , sqrt_rho real ( Float64 ), dimension ( 2 ) :: randomu real ( Float64 ), dimension ( 3 ) :: vi , xyz , r0 real ( Float64 ), dimension ( 3 , 3 ) :: basis real ( Float64 ), dimension (:), allocatable :: lambda_arr , brems allocate ( lambda_arr ( inputs % nlambda )) allocate ( brems ( inputs % nlambda )) do i = 1 , inputs % nlambda lambda_arr ( i ) = 10 * (( i - 0.5 ) * inputs % dlambda + inputs % lambdamin ) ! [A] enddo dlambda = 10 * inputs % dlambda ![A] dlength = 0.3 !cm !! $OMP PARALLEL DO schedule(guided) private(ichan,xyz,vi,basis,spot_size, & !! $OMP& ic, nc,randomu,sqrt_rho,theta,r0,plasma,gaunt,brems) loop_over_channels : do ichan = 1 , spec_chords % nchan xyz = spec_chords % los ( ichan )% lens vi = spec_chords % los ( ichan )% axis vi = vi / norm2 ( vi ) spot_size = spec_chords % los ( ichan )% spot_size call line_basis ( xyz , vi , basis ) if ( spot_size . le . 0.d0 ) then nc = 1 else nc = 100 endif do ic = 1 , nc call randu ( randomu ) sqrt_rho = sqrt ( randomu ( 1 )) theta = 2 * pi * randomu ( 2 ) r0 ( 1 ) = 0.d0 r0 ( 2 ) = spot_size * sqrt_rho * cos ( theta ) r0 ( 3 ) = spot_size * sqrt_rho * sin ( theta ) r0 = matmul ( basis , r0 ) + xyz ! Find edge of plasma call get_plasma ( plasma , pos = r0 ) max_length = 0.0 do while (. not . plasma % in_plasma ) r0 = r0 + vi * dlength ! move dlength call get_plasma ( plasma , pos = r0 ) max_length = max_length + dlength if ( max_length . gt . 300 ) cycle loop_over_channels enddo ! Calculate bremsstrahlung along los do while ( plasma % in_plasma ) if ( plasma % te . gt . 0.0 ) then gaunt = 5.542 - ( 3.108 - log ( plasma % te )) * ( 0.6905 - 0.1323 / plasma % zeff ) brems = 7.57d-9 * gaunt * plasma % dene ** 2 * plasma % zeff / ( lambda_arr & * sqrt ( plasma % te * 100 0.0 )) * exp ( - h_planck * c0 / ( lambda_arr * plasma % te * 100 0.0 )) & * dlambda * ( 4.d0 * pi ) * 1.d-4 spec % brems (:, ichan ) = spec % brems (:, ichan ) + ( brems * dlength * 1.d-2 ) / nc endif ! Take a step r0 = r0 + vi * dlength call get_plasma ( plasma , pos = r0 ) enddo enddo if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) 100 * ichan / real ( spec_chords % nchan ), char ( 13 ) endif enddo loop_over_channels !! $OMP END PARALLEL DO deallocate ( lambda_arr , brems ) end subroutine bremsstrahlung","tags":"","loc":"proc/bremsstrahlung.html","title":"bremsstrahlung – FIDASIM"},{"text":"public subroutine dcx() Calculates Direct Charge Exchange (DCX) neutral density and spectra Arguments None Calls proc~~dcx~~CallsGraph proc~dcx dcx proc~get_nlaunch get_nlaunch proc~dcx->proc~get_nlaunch proc~track track proc~dcx->proc~track proc~mc_halo mc_halo proc~dcx->proc~mc_halo proc~get_plasma get_plasma proc~dcx->proc~get_plasma proc~colrad colrad proc~dcx->proc~colrad proc~store_bes_photons store_bes_photons proc~dcx->proc~store_bes_photons proc~store_neutrals store_neutrals proc~dcx->proc~store_neutrals proc~get_beam_cx_prob get_beam_cx_prob proc~dcx->proc~get_beam_cx_prob proc~randu randu proc~get_nlaunch->proc~randu proc~get_indices get_indices proc~track->proc~get_indices proc~in_plasma in_plasma proc~track->proc~in_plasma proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~get_plasma->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~store_bes_photons->proc~get_indices proc~get_fields get_fields proc~store_bes_photons->proc~get_fields proc~spectrum spectrum proc~store_bes_photons->proc~spectrum proc~get_beam_cx_prob->proc~mc_halo proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform proc~lubksb lubksb proc~matinv->proc~lubksb proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~get_rate_matrix->interface~interpol_coeff proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balance balance proc~eigen->proc~balance proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~elmhes->proc~rswap proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~get_fields->proc~in_plasma proc~get_fields->proc~get_position proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~neut_rates->interface~interpol_coeff var panprocdcxCallsGraph = svgPanZoom('#procdcxCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~dcx~~CalledByGraph proc~dcx dcx program~fidasim fidasim program~fidasim->proc~dcx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code dcx Source Code subroutine dcx !+ Calculates Direct Charge Exchange (DCX) neutral density and spectra integer :: i , j , k !indices of cells integer ( Int64 ) :: idcx !! counter real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vihalo integer , dimension ( 3 ) :: ind !! actual cell integer , dimension ( 3 ) :: neut_types = [ 1 , 2 , 3 ] !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( Float64 ), dimension ( nlevs ) :: prob !!  Prob. for CX !! Collisiional radiative model along track real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states integer :: ncell type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks !! Particle tracks integer :: jj !! counter along track real ( Float64 ) :: tot_denn , photons !! photon flux real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch !! approx. density real ( Float64 ) :: papprox_tot , ccnt , inv_ng halo_iter_dens ( halo_type ) = 0.d0 papprox = 0.d0 papprox_tot = 0.d0 tot_denn = 0.d0 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) tot_denn = sum ( neut % dens (:, nbif_type , i , j , k )) + & sum ( neut % dens (:, nbih_type , i , j , k )) + & sum ( neut % dens (:, nbit_type , i , j , k )) papprox ( i , j , k ) = tot_denn * ( plasma % denp - plasma % denf ) if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo call get_nlaunch ( inputs % n_dcx , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( sum ( nlaunch ), Int64 ) endif ccnt = 0.d0 inv_ng = 10 0.0 / real ( beam_grid % ngrid ) loop_along_z : do k = 1 , beam_grid % nz loop_along_y : do j = 1 , beam_grid % ny loop_along_x : do i = 1 , beam_grid % nx !! Loop over the markers !$OMP PARALLEL DO schedule(guided) private(idcx,ind,vihalo, & !$OMP& ri,tracks,ncell,prob,denn,states,jj,photons,plasma) loop_over_dcx : do idcx = 1 , int ( nlaunch ( i , j , k ), Int64 ) !! Calculate ri,vhalo and track ind = [ i , j , k ] call mc_halo ( ind , vihalo , ri ) call track ( ri , vihalo , tracks , ncell ) if ( ncell . eq . 0 ) cycle loop_over_dcx !! Calculate CX probability call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vihalo , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle loop_over_dcx !! Solve collisional radiative model along track call get_plasma ( plasma , pos = tracks ( 1 )% pos ) states = prob * ( plasma % denp - plasma % denf ) loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , thermal_ion , vihalo , tracks ( jj )% time , states , denn , photons ) call store_neutrals ( tracks ( jj )% ind , halo_type , denn / nlaunch ( i , j , k ), plasma % in_plasma ) if (( photons . gt . 0.d0 ). and .( inputs % calc_bes . ge . 1 )) then call store_bes_photons ( tracks ( jj )% pos , vihalo , photons / nlaunch ( i , j , k ), halo_type ) endif enddo loop_along_track enddo loop_over_dcx !$OMP END PARALLEL DO ccnt = ccnt + 1 if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) ccnt * inv_ng , char ( 13 ) endif enddo loop_along_x enddo loop_along_y enddo loop_along_z end subroutine dcx","tags":"","loc":"proc/dcx.html","title":"dcx – FIDASIM"},{"text":"public subroutine halo() Calculates halo neutral density and spectra Arguments None Calls proc~~halo~~CallsGraph proc~halo halo proc~get_nlaunch get_nlaunch proc~halo->proc~get_nlaunch proc~track track proc~halo->proc~track proc~mc_halo mc_halo proc~halo->proc~mc_halo proc~get_plasma get_plasma proc~halo->proc~get_plasma proc~colrad colrad proc~halo->proc~colrad proc~store_bes_photons store_bes_photons proc~halo->proc~store_bes_photons proc~store_neutrals store_neutrals proc~halo->proc~store_neutrals proc~get_beam_cx_prob get_beam_cx_prob proc~halo->proc~get_beam_cx_prob proc~randu randu proc~get_nlaunch->proc~randu proc~get_indices get_indices proc~track->proc~get_indices proc~in_plasma in_plasma proc~track->proc~in_plasma proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~get_plasma->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~store_bes_photons->proc~get_indices proc~get_fields get_fields proc~store_bes_photons->proc~get_fields proc~spectrum spectrum proc~store_bes_photons->proc~spectrum proc~get_beam_cx_prob->proc~mc_halo proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform proc~lubksb lubksb proc~matinv->proc~lubksb proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~get_rate_matrix->interface~interpol_coeff proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balance balance proc~eigen->proc~balance proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~elmhes->proc~rswap proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~get_fields->proc~in_plasma proc~get_fields->proc~get_position proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~neut_rates->interface~interpol_coeff var panprochaloCallsGraph = svgPanZoom('#prochaloCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~halo~~CalledByGraph proc~halo halo program~fidasim fidasim program~fidasim->proc~halo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code halo Source Code subroutine halo !+ Calculates halo neutral density and spectra integer :: i , j , k !indices of cells integer ( Int64 ) :: ihalo !! counter real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vihalo !! velocity bulk plasma ion integer , dimension ( 3 ) :: ind !! actual cell !! Determination of the CX probability type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( Float64 ), dimension ( nlevs ) :: prob !!  Prob. for CX !! Collisiional radiative model along track real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states integer :: ncell type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks !! Particle Tracks integer :: jj !! counter along track real ( Float64 ) :: tot_denn , photons !! photon flux real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch !! approx. density real ( Float64 ) :: papprox_tot , ccnt , inv_ng !! Halo iteration integer :: hh !! counters real ( Float64 ) :: dcx_dens , halo_iteration_dens integer :: s1type ! halo iteration integer :: s2type ! halo iteration s1type = fida_type s2type = brems_type dcx_dens = halo_iter_dens ( halo_type ) if ( dcx_dens . eq . 0 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'HALO: Density of DCX-neutrals is zero' endif stop endif inv_ng = 10 0.0 / real ( beam_grid % ngrid ) neut % dens (:, s1type ,:,:,:) = neut % dens (:, halo_type ,:,:,:) iterations : do hh = 1 , 200 papprox = 0.d0 papprox_tot = 0.d0 tot_denn = 0.d0 halo_iter_dens ( s2type ) = 0.d0 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) tot_denn = sum ( neut % dens (:, s1type , i , j , k )) papprox ( i , j , k ) = tot_denn * ( plasma % denp - plasma % denf ) if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo call get_nlaunch ( inputs % n_halo , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( sum ( nlaunch ), Int64 ) endif ccnt = 0.d0 !$OMP PARALLEL DO schedule(guided) collapse(3) private(i,j,k,ihalo,ind,vihalo, & !$OMP& ri,tracks,ncell,prob,denn,states,jj,photons,plasma) loop_along_z : do k = 1 , beam_grid % nz loop_along_y : do j = 1 , beam_grid % ny loop_along_x : do i = 1 , beam_grid % nx !! Loop over the markers loop_over_halos : do ihalo = 1 , int ( nlaunch ( i , j , k ), Int64 ) !! Calculate ri,vhalo and track ind = [ i , j , k ] call mc_halo ( ind , vihalo , ri ) call track ( ri , vihalo , tracks , ncell ) if ( ncell . eq . 0 ) cycle loop_over_halos !! Calculate CX probability call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vihalo ,[ s1type ], prob ) if ( sum ( prob ). le . 0. ) cycle loop_over_halos !! Solve collisional radiative model along track call get_plasma ( plasma , pos = tracks ( 1 )% pos ) states = prob * plasma % denp loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , thermal_ion , vihalo , tracks ( jj )% time , states , denn , photons ) call store_neutrals ( tracks ( jj )% ind , s2type , & denn / nlaunch ( i , j , k ), plasma % in_plasma ) if (( photons . gt . 0.d0 ). and .( inputs % calc_bes . ge . 1 )) then call store_bes_photons ( tracks ( jj )% pos , vihalo , photons / nlaunch ( i , j , k ), halo_type ) endif enddo loop_along_track enddo loop_over_halos ccnt = ccnt + 1 if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) ccnt * inv_ng , char ( 13 ) endif enddo loop_along_x enddo loop_along_y enddo loop_along_z !$OMP END PARALLEL DO halo_iteration_dens = halo_iter_dens ( s2type ) neut % dens (:, halo_type ,:,:,:) = neut % dens (:, halo_type ,:,:,:) & + neut % dens (:, s2type ,:,:,:) neut % dens (:, s1type ,:,:,:) = neut % dens (:, s2type ,:,:,:) neut % dens (:, s2type ,:,:,:) = 0. if ( halo_iteration_dens / dcx_dens . gt . 1 ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) \"HALO: Halo generation density exceeded DCX density. This shouldn't happen.\" endif exit iterations endif inputs % n_halo = int ( inputs % n_dcx * halo_iteration_dens / dcx_dens , Int64 ) if ( inputs % n_halo . lt . inputs % n_dcx * 0.01 ) exit iterations enddo iterations !! set the neutral density in s1type(fida_type) and s2type (brems) to 0! neut % dens (:, s1type ,:,:,:) = 0.d0 neut % dens (:, s2type ,:,:,:) = 0.d0 end subroutine halo","tags":"","loc":"proc/halo.html","title":"halo – FIDASIM"},{"text":"public subroutine fida_f() Calculate FIDA emission using a Fast-ion distribution function F(E,p,r,z) Arguments None Calls proc~~fida_f~~CallsGraph proc~fida_f fida_f proc~get_nlaunch get_nlaunch proc~fida_f->proc~get_nlaunch proc~store_fida_photons store_fida_photons proc~fida_f->proc~store_fida_photons proc~colrad colrad proc~fida_f->proc~colrad proc~track track proc~fida_f->proc~track proc~get_plasma get_plasma proc~fida_f->proc~get_plasma proc~get_beam_cx_prob get_beam_cx_prob proc~fida_f->proc~get_beam_cx_prob proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~gyro_correction gyro_correction proc~fida_f->proc~gyro_correction proc~randu randu proc~get_nlaunch->proc~randu proc~get_indices get_indices proc~store_fida_photons->proc~get_indices proc~get_fields get_fields proc~store_fida_photons->proc~get_fields proc~spectrum spectrum proc~store_fida_photons->proc~spectrum proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~track->proc~get_indices proc~in_plasma in_plasma proc~track->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~get_plasma->proc~in_plasma proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~mc_halo mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~mc_fastion->proc~randu proc~mc_fastion->proc~get_fields interface~randind randind proc~mc_fastion->interface~randind proc~get_distribution get_distribution proc~mc_fastion->proc~get_distribution proc~gyro_correction->proc~randu proc~pitch_to_vec pitch_to_vec proc~gyro_correction->proc~pitch_to_vec proc~gyro_step gyro_step proc~gyro_correction->proc~gyro_step omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~get_fields->proc~get_position proc~get_fields->proc~in_plasma proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~lubksb lubksb proc~matinv->proc~lubksb proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~get_rate_matrix->interface~interpol_coeff proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balance balance proc~eigen->proc~balance proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~elmhes->proc~rswap proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~neut_rates->interface~interpol_coeff proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform proc~get_distribution->proc~get_position proc~get_distribution->proc~xyz_to_uvw interface~interpol interpol proc~get_distribution->interface~interpol proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~cross_product cross_product proc~gyro_step->proc~cross_product var panprocfida_fCallsGraph = svgPanZoom('#procfida_fCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~fida_f~~CalledByGraph proc~fida_f fida_f program~fidasim fidasim program~fidasim->proc~fida_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code fida_f Source Code subroutine fida_f !+ Calculate FIDA emission using a Fast-ion distribution function F(E,p,r,z) integer :: i , j , k , ip !! indices  x,y,z of cells integer ( Int64 ) :: iion real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions real ( Float64 ) :: denf !! fast-ion density integer , dimension ( 3 ) :: ind !! new actual cell integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] logical :: los_intersect !! Determination of the CX probability type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma real ( Float64 ), dimension ( nlevs ) :: prob !! Prob. for CX !! Collisiional radiative model along track integer :: ncell integer :: jj !! counter along track type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks real ( Float64 ) :: photons !! photon flux real ( Float64 ), dimension ( nlevs ) :: states !! Density of n-states real ( Float64 ), dimension ( nlevs ) :: denn !! Number of particles to launch integer ( kind = 8 ) :: pcnt real ( Float64 ) :: papprox_tot , inv_maxcnt , cnt , eb , ptch integer , dimension ( 3 , beam_grid % ngrid ) :: pcell real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch !! approx. density !! Estimate how many particles to launch in each cell papprox = 0.d0 papprox_tot = 0.d0 pcnt = 1 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) papprox ( i , j , k ) = ( sum ( neut % dens (:, nbif_type , i , j , k )) + & sum ( neut % dens (:, nbih_type , i , j , k )) + & sum ( neut % dens (:, nbit_type , i , j , k )) + & sum ( neut % dens (:, halo_type , i , j , k ))) * & plasma % denf if ( papprox ( i , j , k ). gt . 0 ) then pcell (:, pcnt ) = ind pcnt = pcnt + 1 endif if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo pcnt = pcnt - 1 inv_maxcnt = 10 0.0 / real ( pcnt ) call get_nlaunch ( inputs % n_fida , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( sum ( nlaunch ), Int64 ) endif !! Loop over all cells that have neutrals cnt = 0.d0 loop_over_cells : do ip = 1 , int ( pcnt ) i = pcell ( 1 , ip ) j = pcell ( 2 , ip ) k = pcell ( 3 , ip ) ind = [ i , j , k ] !$OMP PARALLEL DO schedule(guided) private(ip,iion,vi,ri,fields, & !$OMP tracks,ncell,jj,plasma,prob,denn,states,photons,denf,eb,ptch) loop_over_fast_ions : do iion = 1 , int ( nlaunch ( i , j , k ), Int64 ) !! Sample fast ion distribution for velocity and position call mc_fastion ( ind , fields , eb , ptch , denf ) if ( denf . eq . 0.0 ) cycle loop_over_fast_ions !! Correct for gyro motion and get particle position and velocity call gyro_correction ( fields , eb , ptch , ri , vi ) !! Find the particles path through the beam grid call track ( ri , vi , tracks , ncell , los_intersect ) if (. not . los_intersect ) cycle loop_over_fast_ions if ( ncell . eq . 0 ) cycle loop_over_fast_ions !! Calculate CX probability with beam and halo neutrals call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle loop_over_fast_ions !! Calculate initial states of particle states = prob * denf !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fida_photons ( tracks ( jj )% pos , vi , photons / nlaunch ( i , j , k )) enddo loop_along_track enddo loop_over_fast_ions !$OMP END PARALLEL DO cnt = cnt + 1 if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_cells end subroutine fida_f","tags":"","loc":"proc/fida_f.html","title":"fida_f – FIDASIM"},{"text":"public subroutine fida_mc() Calculate FIDA emission using a Monte Carlo Fast-ion distribution Arguments None Calls proc~~fida_mc~~CallsGraph proc~fida_mc fida_mc proc~colrad colrad proc~fida_mc->proc~colrad proc~store_fida_photons store_fida_photons proc~fida_mc->proc~store_fida_photons proc~track track proc~fida_mc->proc~track proc~uvw_to_xyz uvw_to_xyz proc~fida_mc->proc~uvw_to_xyz proc~get_plasma get_plasma proc~fida_mc->proc~get_plasma proc~get_beam_cx_prob get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~randu randu proc~fida_mc->proc~randu proc~get_fields get_fields proc~fida_mc->proc~get_fields proc~gyro_correction gyro_correction proc~fida_mc->proc~gyro_correction proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~store_fida_photons->proc~get_fields proc~get_indices get_indices proc~store_fida_photons->proc~get_indices proc~spectrum spectrum proc~store_fida_photons->proc~spectrum proc~track->proc~get_indices proc~in_plasma in_plasma proc~track->proc~in_plasma proc~get_plasma->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~mc_halo mc_halo proc~get_beam_cx_prob->proc~mc_halo omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~get_fields->proc~in_plasma proc~get_fields->proc~get_position proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~gyro_correction->proc~randu proc~pitch_to_vec pitch_to_vec proc~gyro_correction->proc~pitch_to_vec proc~gyro_step gyro_step proc~gyro_correction->proc~gyro_step proc~lubksb lubksb proc~matinv->proc~lubksb proc~ludcmp ludcmp proc~matinv->proc~ludcmp interface~interpol_coeff interpol_coeff proc~get_rate_matrix->interface~interpol_coeff proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balance balance proc~eigen->proc~balance proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~rswap RSWAP proc~balance->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~elmhes->proc~rswap proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~in_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw proc~neut_rates->interface~interpol_coeff proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform proc~cross_product cross_product proc~gyro_step->proc~cross_product var panprocfida_mcCallsGraph = svgPanZoom('#procfida_mcCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~fida_mc~~CalledByGraph proc~fida_mc fida_mc program~fidasim fidasim program~fidasim->proc~fida_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code fida_mc Source Code subroutine fida_mc !+ Calculate FIDA emission using a Monte Carlo Fast-ion distribution integer :: iion , iphi , nphi type ( FastIon ) :: fast_ion type ( LocalEMFields ) :: fields type ( LocalProfiles ) :: plasma real ( Float64 ) :: phi real ( Float64 ), dimension ( 3 ) :: ri !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions !! Determination of the CX probability real ( Float64 ), dimension ( nlevs ) :: denn !!  neutral dens (n=1-4) real ( Float64 ), dimension ( nlevs ) :: prob !! Prob. for CX !! Collisiional radiative model along track real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states integer :: ncell type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks logical :: los_intersect integer :: jj !! counter along track real ( Float64 ) :: photons !! photon flux integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ) :: s , c real ( Float64 ) :: maxcnt , inv_maxcnt , cnt real ( Float64 ), dimension ( 1 ) :: randomu maxcnt = particles % nparticle inv_maxcnt = 10 0.d0 / maxcnt nphi = ceiling ( dble ( inputs % n_fida ) / particles % nparticle ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( particles % nparticle * nphi , Int64 ) endif cnt = 0.0 !$OMP PARALLEL DO schedule(guided) private(iion,iphi,fast_ion,vi,ri,phi,tracks,s,c, & !$OMP& randomu,plasma,fields,uvw,uvw_vi,ncell,jj,prob,denn,los_intersect,states,photons) loop_over_fast_ions : do iion = 1 , particles % nparticle fast_ion = particles % fast_ion ( iion ) cnt = cnt + 1 if ( fast_ion % vabs . eq . 0 ) cycle loop_over_fast_ions if (. not . fast_ion % cross_grid ) cycle loop_over_fast_ions phi_loop : do iphi = 1 , nphi !! Pick random torodial angle call randu ( randomu ) phi = fast_ion % phi_enter + fast_ion % delta_phi * randomu ( 1 ) s = sin ( phi ) ; c = cos ( phi ) !! Calculate position in machine coordinates uvw ( 1 ) = fast_ion % r * c uvw ( 2 ) = fast_ion % r * s uvw ( 3 ) = fast_ion % z !! Convert to beam grid coordinates call uvw_to_xyz ( uvw , ri ) if ( inputs % dist_type . eq . 2 ) then !! Get electomagnetic fields call get_fields ( fields , pos = ri ) !! Correct for gyro motion and get particle position and velocity call gyro_correction ( fields , fast_ion % energy , fast_ion % pitch , ri , vi ) else !! Full Orbit !! Calculate velocity vector uvw_vi ( 1 ) = c * fast_ion % vr - s * fast_ion % vt uvw_vi ( 2 ) = s * fast_ion % vr + c * fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) endif !! Track particle through grid call track ( ri , vi , tracks , ncell , los_intersect ) if (. not . los_intersect ) cycle phi_loop if ( ncell . eq . 0 ) cycle phi_loop !! Calculate CX probability call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle phi_loop !! Calculate the spectra produced in each cell along the path states = prob * fast_ion % weight / nphi loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fida_photons ( tracks ( jj )% pos , vi , photons , fast_ion % class ) enddo loop_along_track enddo phi_loop if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_fast_ions !$OMP END PARALLEL DO end subroutine fida_mc","tags":"","loc":"proc/fida_mc.html","title":"fida_mc – FIDASIM"},{"text":"public subroutine npa_f() Calculate NPA flux using a fast-ion distribution function F(E,p,r,z) Arguments None Calls proc~~npa_f~~CallsGraph proc~npa_f npa_f proc~get_nlaunch get_nlaunch proc~npa_f->proc~get_nlaunch proc~store_npa store_npa proc~npa_f->proc~store_npa proc~get_beam_cx_prob get_beam_cx_prob proc~npa_f->proc~get_beam_cx_prob proc~get_plasma get_plasma proc~npa_f->proc~get_plasma proc~get_indices get_indices proc~npa_f->proc~get_indices proc~npa_gyro_range npa_gyro_range proc~npa_f->proc~npa_gyro_range proc~gyro_surface gyro_surface proc~npa_f->proc~gyro_surface proc~gyro_trajectory gyro_trajectory proc~npa_f->proc~gyro_trajectory proc~attenuate attenuate proc~npa_f->proc~attenuate proc~mc_fastion mc_fastion proc~npa_f->proc~mc_fastion proc~hit_npa_detector hit_npa_detector proc~npa_f->proc~hit_npa_detector proc~randu randu proc~get_nlaunch->proc~randu proc~xyz_to_uvw xyz_to_uvw proc~store_npa->proc~xyz_to_uvw proc~get_fields get_fields proc~store_npa->proc~get_fields proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~mc_halo mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~get_position get_position proc~get_plasma->proc~get_position proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~gyro_range gyro_range proc~npa_gyro_range->proc~gyro_range proc~approx_eq approx_eq proc~npa_gyro_range->proc~approx_eq proc~attenuate->proc~get_plasma proc~colrad colrad proc~attenuate->proc~colrad proc~mc_fastion->proc~randu proc~mc_fastion->proc~get_fields interface~randind randind proc~mc_fastion->interface~randind proc~get_distribution get_distribution proc~mc_fastion->proc~get_distribution proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector->proc~line_plane_intersect proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~get_fields->proc~get_position proc~get_fields->proc~in_plasma proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~neut_rates->interface~interpol_coeff proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform proc~boundary_edge boundary_edge proc~gyro_range->proc~boundary_edge proc~line_gyro_surface_intersect line_gyro_surface_intersect proc~gyro_range->proc~line_gyro_surface_intersect proc~gyro_surface_coordinates gyro_surface_coordinates proc~gyro_range->proc~gyro_surface_coordinates proc~in_gyro_surface in_gyro_surface proc~gyro_range->proc~in_gyro_surface proc~gyro_range->proc~line_plane_intersect proc~gyro_range->proc~in_boundary proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~lubksb lubksb proc~matinv->proc~lubksb proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~get_rate_matrix->interface~interpol_coeff proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balance balance proc~eigen->proc~balance proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~elmhes->proc~rswap proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~get_distribution->proc~xyz_to_uvw proc~get_distribution->proc~get_position interface~interpol interpol proc~get_distribution->interface~interpol proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff var panprocnpa_fCallsGraph = svgPanZoom('#procnpa_fCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~npa_f~~CalledByGraph proc~npa_f npa_f program~fidasim fidasim program~fidasim->proc~npa_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code npa_f Source Code subroutine npa_f !+ Calculate NPA flux using a fast-ion distribution function F(E,p,r,z) integer :: i , j , k , det , ip integer ( Int64 ) :: iion real ( Float64 ), dimension ( 3 ) :: rg , ri , rf , vi integer , dimension ( 3 ) :: ind , pind real ( Float64 ) :: denf integer , dimension ( 3 , beam_grid % ngrid ) :: pcell type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields type ( GyroSurface ) :: gs real ( Float64 ), dimension ( 2 , 4 ) :: gyrange integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] real ( Float64 ), dimension ( nlevs ) :: prob real ( Float64 ), dimension ( nlevs ) :: states real ( Float64 ) :: flux , theta , dtheta , eb , ptch integer :: inpa , pcnt , ichan , nrange , ir real ( Float64 ) :: papprox_tot , maxcnt , cnt , inv_maxcnt real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch papprox = 0.d0 papprox_tot = 0.d0 pcnt = 1 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) papprox ( i , j , k ) = ( sum ( neut % dens (:, nbif_type , i , j , k )) + & sum ( neut % dens (:, nbih_type , i , j , k )) + & sum ( neut % dens (:, nbit_type , i , j , k )) + & sum ( neut % dens (:, halo_type , i , j , k ))) * & plasma % denf if ( papprox ( i , j , k ). gt . 0 ) then pcell (:, pcnt ) = ind pcnt = pcnt + 1 endif if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo pcnt = pcnt - 1 maxcnt = real ( pcnt ) inv_maxcnt = 10 0.0 / maxcnt call get_nlaunch ( inputs % n_npa , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i12)' ) int ( sum ( nlaunch ), Int64 ) endif !! Loop over all cells that can contribute to NPA signal cnt = 0.d0 loop_over_cells : do ip = 1 , int ( pcnt ) i = pcell ( 1 , ip ) j = pcell ( 2 , ip ) k = pcell ( 3 , ip ) ind = [ i , j , k ] !$OMP PARALLEL DO schedule(guided) private(iion,ichan,fields,nrange,gyrange, & !$OMP& pind,vi,ri,rf,det,plasma,prob,states,flux,denf,eb,ptch,gs,ir,theta,dtheta) loop_over_fast_ions : do iion = 1 , int ( nlaunch ( i , j , k ), Int64 ) !! Sample fast ion distribution for energy and pitch call mc_fastion ( ind , fields , eb , ptch , denf ) if ( denf . eq . 0.0 ) cycle loop_over_fast_ions call gyro_surface ( fields , eb , ptch , gs ) detector_loop : do ichan = 1 , npa_chords % nchan call npa_gyro_range ( ichan , gs , gyrange , nrange ) if ( nrange . eq . 0 ) cycle detector_loop gyro_range_loop : do ir = 1 , nrange dtheta = gyrange ( 2 , ir ) theta = gyrange ( 1 , ir ) + 0.5 * dtheta call gyro_trajectory ( gs , theta , ri , vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf , ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"NPA_F: Missed Detector \" , ichan endif cycle gyro_range_loop endif !! Get beam grid indices at ri call get_indices ( ri , pind ) !! Calculate CX probability with beam and halo neutrals call get_beam_cx_prob ( pind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle gyro_range_loop !! Attenuate states as the particle move through plasma states = prob * denf call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = ( dtheta / ( 2 * pi )) * sum ( states ) * beam_grid % dv / nlaunch ( i , j , k ) call store_npa ( det , ri , rf , vi , flux ) enddo gyro_range_loop enddo detector_loop enddo loop_over_fast_ions !$OMP END PARALLEL DO cnt = cnt + 1 if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_cells if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Number of NPA particles that hit a detector: \",i8)' ) npa % npart endif end subroutine npa_f","tags":"","loc":"proc/npa_f.html","title":"npa_f – FIDASIM"},{"text":"public subroutine npa_mc() Calculate NPA flux using a Monte Carlo fast-ion distribution Arguments None Calls proc~~npa_mc~~CallsGraph proc~npa_mc npa_mc proc~store_npa store_npa proc~npa_mc->proc~store_npa proc~get_beam_cx_prob get_beam_cx_prob proc~npa_mc->proc~get_beam_cx_prob proc~attenuate attenuate proc~npa_mc->proc~attenuate proc~get_indices get_indices proc~npa_mc->proc~get_indices proc~npa_gyro_range npa_gyro_range proc~npa_mc->proc~npa_gyro_range proc~uvw_to_xyz uvw_to_xyz proc~npa_mc->proc~uvw_to_xyz proc~gyro_surface gyro_surface proc~npa_mc->proc~gyro_surface proc~gyro_trajectory gyro_trajectory proc~npa_mc->proc~gyro_trajectory proc~randu randu proc~npa_mc->proc~randu proc~get_fields get_fields proc~npa_mc->proc~get_fields proc~hit_npa_detector hit_npa_detector proc~npa_mc->proc~hit_npa_detector proc~store_npa->proc~get_fields proc~xyz_to_uvw xyz_to_uvw proc~store_npa->proc~xyz_to_uvw proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~mc_halo mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~get_plasma get_plasma proc~attenuate->proc~get_plasma proc~colrad colrad proc~attenuate->proc~colrad proc~gyro_range gyro_range proc~npa_gyro_range->proc~gyro_range proc~approx_eq approx_eq proc~npa_gyro_range->proc~approx_eq omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~get_position get_position proc~get_fields->proc~get_position proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector->proc~line_plane_intersect proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary interface~interpol_coeff interpol_coeff proc~neut_rates->interface~interpol_coeff proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~mc_halo->proc~get_plasma proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~get_plasma->proc~get_position proc~get_plasma->proc~in_plasma proc~rng_normal->proc~rng_uniform proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol_coeff proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~lubksb lubksb proc~matinv->proc~lubksb proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~get_rate_matrix->interface~interpol_coeff proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balance balance proc~eigen->proc~balance proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~elmhes->proc~rswap proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~boundary_edge boundary_edge proc~gyro_range->proc~boundary_edge proc~line_gyro_surface_intersect line_gyro_surface_intersect proc~gyro_range->proc~line_gyro_surface_intersect proc~gyro_surface_coordinates gyro_surface_coordinates proc~gyro_range->proc~gyro_surface_coordinates proc~in_gyro_surface in_gyro_surface proc~gyro_range->proc~in_gyro_surface proc~gyro_range->proc~line_plane_intersect proc~gyro_range->proc~in_boundary var panprocnpa_mcCallsGraph = svgPanZoom('#procnpa_mcCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~npa_mc~~CalledByGraph proc~npa_mc npa_mc program~fidasim fidasim program~fidasim->proc~npa_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code npa_mc Source Code subroutine npa_mc !+ Calculate NPA flux using a Monte Carlo fast-ion distribution integer :: iion , iphi , nphi type ( FastIon ) :: fast_ion real ( Float64 ) :: phi , theta , dtheta real ( Float64 ), dimension ( 3 ) :: ri , rf , rg , vi integer :: det , j , ichan , ir , nrange type ( LocalEMFields ) :: fields type ( GyroSurface ) :: gs real ( Float64 ), dimension ( nlevs ) :: prob real ( Float64 ), dimension ( nlevs ) :: states real ( Float64 ) :: flux integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] integer , dimension ( 3 ) :: ind real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ), dimension ( 2 , 4 ) :: gyrange real ( Float64 ) :: s , c real ( Float64 ) :: maxcnt , inv_maxcnt , cnt real ( Float64 ), dimension ( 1 ) :: randomu maxcnt = particles % nparticle inv_maxcnt = 10 0.d0 / maxcnt nphi = ceiling ( dble ( inputs % n_npa ) / particles % nparticle ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( particles % nparticle * nphi , Int64 ) endif cnt = 0.0 !$OMP PARALLEL DO schedule(guided) private(iion,iphi,ind,fast_ion,vi,ri,rf,phi,s,c,ir, & !$OMP& randomu,rg,fields,uvw,uvw_vi,prob,states,flux,det,ichan,gs,nrange,gyrange,theta,dtheta) loop_over_fast_ions : do iion = 1 , particles % nparticle cnt = cnt + 1 fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0 ) cycle loop_over_fast_ions if (. not . fast_ion % cross_grid ) cycle loop_over_fast_ions phi_loop : do iphi = 1 , nphi !! Pick random torodial angle call randu ( randomu ) phi = fast_ion % phi_enter + fast_ion % delta_phi * randomu ( 1 ) s = sin ( phi ) ; c = cos ( phi ) !! Calculate position in machine coordinates uvw ( 1 ) = fast_ion % r * c uvw ( 2 ) = fast_ion % r * s uvw ( 3 ) = fast_ion % z if ( inputs % dist_type . eq . 2 ) then !! Convert to beam grid coordinates call uvw_to_xyz ( uvw , rg ) !! Get electomagnetic fields call get_fields ( fields , pos = rg ) !! Correct for gyro motion and get position and velocity call gyro_surface ( fields , fast_ion % energy , fast_ion % pitch , gs ) detector_loop : do ichan = 1 , npa_chords % nchan call npa_gyro_range ( ichan , gs , gyrange , nrange ) if ( nrange . eq . 0 ) cycle detector_loop gyro_range_loop : do ir = 1 , nrange dtheta = gyrange ( 2 , ir ) theta = gyrange ( 1 , ir ) + 0.5 * dtheta call gyro_trajectory ( gs , theta , ri , vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf , det = ichan ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , * ) \"NPA_MC: Missed Detector \" , ichan endif cycle gyro_range_loop endif !! Get beam grid indices at ri call get_indices ( ri , ind ) !! Calculate CX probability with beam and halo neutrals call get_beam_cx_prob ( ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle gyro_range_loop !! Attenuate states as the particle move through plasma states = prob * fast_ion % weight / nphi call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = ( dtheta / ( 2 * pi )) * sum ( states ) * beam_grid % dv call store_npa ( det , ri , rf , vi , flux , fast_ion % class ) enddo gyro_range_loop enddo detector_loop else !! Full Orbit !! Convert to beam grid coordinates call uvw_to_xyz ( uvw , ri ) !! Calculate velocity vector uvw_vi ( 1 ) = c * fast_ion % vr - s * fast_ion % vt uvw_vi ( 2 ) = s * fast_ion % vr + c * fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) !! Check if particle hits a NPA detector call hit_npa_detector ( ri , vi , det , rf ) if ( det . eq . 0 ) cycle phi_loop !! Get beam grid indices at ri call get_indices ( ri , ind ) !! Calculate CX probability with beam and halo neutrals call get_beam_cx_prob ( ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle phi_loop !! Attenuate states as the particle moves though plasma states = prob * fast_ion % weight / nphi call attenuate ( ri , rf , vi , states ) !! Store NPA Flux flux = sum ( states ) * beam_grid % dv call store_npa ( det , ri , rf , vi , flux , fast_ion % class ) endif enddo phi_loop if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_fast_ions !$OMP END PARALLEL DO if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Number of NPA particles that hit a detector: \",i8)' ) npa % npart endif end subroutine npa_mc","tags":"","loc":"proc/npa_mc.html","title":"npa_mc – FIDASIM"},{"text":"public subroutine neutron_f() Calculate neutron emission rate using a fast-ion distribution function F(E,p,r,z) Arguments None Calls proc~~neutron_f~~CallsGraph proc~neutron_f neutron_f proc~get_neutron_rate get_neutron_rate proc~neutron_f->proc~get_neutron_rate proc~write_neutrons write_neutrons proc~neutron_f->proc~write_neutrons proc~store_neutrons store_neutrons proc~neutron_f->proc~store_neutrons proc~uvw_to_xyz uvw_to_xyz proc~neutron_f->proc~uvw_to_xyz proc~get_plasma get_plasma proc~neutron_f->proc~get_plasma proc~gyro_correction gyro_correction proc~neutron_f->proc~gyro_correction proc~get_fields get_fields proc~neutron_f->proc~get_fields interface~interpol_coeff interpol_coeff proc~get_neutron_rate->interface~interpol_coeff h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_neutrons->h5ltset_attribute_string_f h5fcreate_f h5fcreate_f proc~write_neutrons->h5fcreate_f h5open_f h5open_f proc~write_neutrons->h5open_f h5close_f h5close_f proc~write_neutrons->h5close_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_neutrons->h5ltmake_dataset_double_f h5fclose_f h5fclose_f proc~write_neutrons->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_neutrons->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~get_position get_position proc~get_plasma->proc~get_position proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~randu randu proc~gyro_correction->proc~randu proc~pitch_to_vec pitch_to_vec proc~gyro_correction->proc~pitch_to_vec proc~gyro_step gyro_step proc~gyro_correction->proc~gyro_step proc~get_fields->proc~get_position proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~in_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~cross_product cross_product proc~gyro_step->proc~cross_product var panprocneutron_fCallsGraph = svgPanZoom('#procneutron_fCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~neutron_f~~CalledByGraph proc~neutron_f neutron_f program~fidasim fidasim program~fidasim->proc~neutron_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code neutron_f Source Code subroutine neutron_f !+ Calculate neutron emission rate using a fast-ion distribution function F(E,p,r,z) integer :: ir , iz , ie , ip , iphi , nphi type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( Float64 ) :: eb , pitch , r , z real ( Float64 ) :: erel , rate real ( Float64 ), dimension ( 3 ) :: rg , ri real ( Float64 ), dimension ( 3 ) :: vi real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ) :: vnet_square , factor real ( Float64 ) :: maxcnt , inv_maxcnt , cnt allocate ( neutron % weight ( fbm % nenergy , fbm % npitch , fbm % nr , fbm % nz )) neutron % weight = 0.d0 nphi = 20 maxcnt = fbm % nr * fbm % nz inv_maxcnt = 10 0.d0 / maxcnt cnt = 0.0 !$OMP PARALLEL DO schedule(guided) private(fields,vi,ri,rg,pitch,eb,& !$OMP& ir,iz,ie,ip,iphi,plasma,factor,uvw,uvw_vi,vnet_square,rate,erel) z_loop : do iz = 1 , fbm % nz r_loop : do ir = 1 , fbm % nr cnt = cnt + 1 !! Calculate position uvw ( 1 ) = fbm % r ( ir ) uvw ( 2 ) = 0.d0 uvw ( 3 ) = fbm % z ( iz ) call uvw_to_xyz ( uvw , rg ) !! Get fields call get_fields ( fields , pos = rg ) if (. not . fields % in_plasma ) cycle r_loop factor = 2 * pi * fbm % r ( ir ) * fbm % dE * fbm % dp * fbm % dr * fbm % dz / nphi !! Loop over energy/pitch/phi pitch_loop : do ip = 1 , fbm % npitch pitch = fbm % pitch ( ip ) energy_loop : do ie = 1 , fbm % nenergy eb = fbm % energy ( ie ) gyro_loop : do iphi = 1 , nphi call gyro_correction ( fields , eb , pitch , ri , vi ) !! Get plasma parameters at particle position call get_plasma ( plasma , pos = ri ) if (. not . plasma % in_plasma ) cycle gyro_loop !! Calculate effective beam energy vnet_square = dot_product ( vi - plasma % vrot , vi - plasma % vrot ) ![cm/s] erel = v2_to_E_per_amu * inputs % ab * vnet_square ![kev] !! Get neutron production rate call get_neutron_rate ( plasma , erel , rate ) neutron % weight ( ie , ip , ir , iz ) = neutron % weight ( ie , ip , ir , iz ) & + rate * factor rate = rate * fbm % f ( ie , ip , ir , iz ) * factor !! Store neutrons call store_neutrons ( rate ) enddo gyro_loop enddo energy_loop enddo pitch_loop if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo r_loop enddo z_loop !$OMP END PARALLEL DO if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,A,ES14.5,\" [neutrons/s]\")' ), 'Rate:   ' , sum ( neutron % rate ) write ( * , '(30X,a)' ) '' endif call write_neutrons () end subroutine neutron_f","tags":"","loc":"proc/neutron_f.html","title":"neutron_f – FIDASIM"},{"text":"public subroutine neutron_mc() Calculate neutron flux using a Monte Carlo Fast-ion distribution Arguments None Calls proc~~neutron_mc~~CallsGraph proc~neutron_mc neutron_mc proc~get_neutron_rate get_neutron_rate proc~neutron_mc->proc~get_neutron_rate proc~write_neutrons write_neutrons proc~neutron_mc->proc~write_neutrons proc~store_neutrons store_neutrons proc~neutron_mc->proc~store_neutrons proc~uvw_to_xyz uvw_to_xyz proc~neutron_mc->proc~uvw_to_xyz proc~get_plasma get_plasma proc~neutron_mc->proc~get_plasma proc~gyro_correction gyro_correction proc~neutron_mc->proc~gyro_correction proc~get_fields get_fields proc~neutron_mc->proc~get_fields interface~interpol_coeff interpol_coeff proc~get_neutron_rate->interface~interpol_coeff h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_neutrons->h5ltset_attribute_string_f h5fcreate_f h5fcreate_f proc~write_neutrons->h5fcreate_f h5open_f h5open_f proc~write_neutrons->h5open_f h5close_f h5close_f proc~write_neutrons->h5close_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_neutrons->h5ltmake_dataset_double_f h5fclose_f h5fclose_f proc~write_neutrons->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_neutrons->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~get_position get_position proc~get_plasma->proc~get_position proc~in_plasma in_plasma proc~get_plasma->proc~in_plasma proc~randu randu proc~gyro_correction->proc~randu proc~pitch_to_vec pitch_to_vec proc~gyro_correction->proc~pitch_to_vec proc~gyro_step gyro_step proc~gyro_correction->proc~gyro_step proc~get_fields->proc~get_position proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~in_plasma->interface~interpol_coeff proc~xyz_to_uvw xyz_to_uvw proc~in_plasma->proc~xyz_to_uvw omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~cross_product cross_product proc~gyro_step->proc~cross_product var panprocneutron_mcCallsGraph = svgPanZoom('#procneutron_mcCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~neutron_mc~~CalledByGraph proc~neutron_mc neutron_mc program~fidasim fidasim program~fidasim->proc~neutron_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code neutron_mc Source Code subroutine neutron_mc !+ Calculate neutron flux using a Monte Carlo Fast-ion distribution integer :: iion , nphi , iphi type ( FastIon ) :: fast_ion type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( Float64 ) :: eb , rate real ( Float64 ), dimension ( 3 ) :: ri , rg real ( Float64 ), dimension ( 3 ) :: vi real ( Float64 ), dimension ( 3 ) :: uvw , uvw_vi real ( Float64 ) :: vnet_square real ( Float64 ) :: maxcnt , inv_maxcnt , cnt maxcnt = particles % nparticle inv_maxcnt = 10 0.d0 / maxcnt if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) particles % nparticle endif cnt = 0.0 rate = 0.0 nphi = 20 !$OMP PARALLEL DO schedule(guided) private(iion,fast_ion,vi,ri,rg, & !$OMP& plasma,fields,uvw,uvw_vi,vnet_square,rate,eb,iphi) loop_over_fast_ions : do iion = 1 , particles % nparticle cnt = cnt + 1 fast_ion = particles % fast_ion ( iion ) if ( fast_ion % vabs . eq . 0.d0 ) cycle loop_over_fast_ions !! Calculate position uvw ( 1 ) = fast_ion % r uvw ( 2 ) = 0.0 uvw ( 3 ) = fast_ion % z if ( inputs % dist_type . eq . 2 ) then call uvw_to_xyz ( uvw , rg ) !! Get electomagnetic fields call get_fields ( fields , pos = rg ) if (. not . fields % in_plasma ) cycle loop_over_fast_ions gyro_loop : do iphi = 1 , nphi !! Correct for Gyro-motion call gyro_correction ( fields , fast_ion % energy , fast_ion % pitch , ri , vi ) !! Get plasma parameters call get_plasma ( plasma , pos = ri ) if (. not . plasma % in_plasma ) cycle gyro_loop !! Calculate effective beam energy vnet_square = dot_product ( vi - plasma % vrot , vi - plasma % vrot ) ![cm/s] eb = v2_to_E_per_amu * inputs % ab * vnet_square ![kev] !! Get neutron production rate call get_neutron_rate ( plasma , eb , rate ) rate = rate * fast_ion % weight * ( 2 * pi / fast_ion % delta_phi ) * beam_grid % dv / nphi !! Store neutrons call store_neutrons ( rate , fast_ion % class ) enddo gyro_loop else call uvw_to_xyz ( uvw , ri ) !! Get plasma parameters call get_plasma ( plasma , pos = ri ) if (. not . plasma % in_plasma ) cycle loop_over_fast_ions !! Calculate effective beam energy uvw_vi ( 1 ) = fast_ion % vr uvw_vi ( 2 ) = fast_ion % vt uvw_vi ( 3 ) = fast_ion % vz vi = matmul ( beam_grid % inv_basis , uvw_vi ) vnet_square = dot_product ( vi - plasma % vrot , vi - plasma % vrot ) ![cm/s] eb = v2_to_E_per_amu * inputs % ab * vnet_square ![kev] !! Get neutron production rate call get_neutron_rate ( plasma , eb , rate ) rate = rate * fast_ion % weight * ( 2 * pi / fast_ion % delta_phi ) * beam_grid % dv !! Store neutrons call store_neutrons ( rate , fast_ion % class ) endif if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_fast_ions !$OMP END PARALLEL DO if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,A,ES14.5,\" [neutrons/s]\")' ), 'Rate:   ' , sum ( neutron % rate ) write ( * , '(30X,a)' ) '' endif call write_neutrons () end subroutine neutron_mc","tags":"","loc":"proc/neutron_mc.html","title":"neutron_mc – FIDASIM"},{"text":"public subroutine fida_weights_mc() Calculates FIDA weights Arguments None Calls proc~~fida_weights_mc~~CallsGraph proc~fida_weights_mc fida_weights_mc interface~randind randind proc~fida_weights_mc->interface~randind proc~get_nlaunch get_nlaunch proc~fida_weights_mc->proc~get_nlaunch proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~colrad colrad proc~fida_weights_mc->proc~colrad proc~track track proc~fida_weights_mc->proc~track proc~write_fida_weights write_fida_weights proc~fida_weights_mc->proc~write_fida_weights proc~get_ep_denf get_ep_denf proc~fida_weights_mc->proc~get_ep_denf proc~get_plasma get_plasma proc~fida_weights_mc->proc~get_plasma proc~gyro_correction gyro_correction proc~fida_weights_mc->proc~gyro_correction proc~randu randu proc~fida_weights_mc->proc~randu proc~get_fields get_fields proc~fida_weights_mc->proc~get_fields proc~get_beam_cx_prob get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~get_nlaunch->proc~randu proc~store_fw_photons->proc~get_fields proc~get_indices get_indices proc~store_fw_photons->proc~get_indices proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~store_fw_photons->proc~store_fw_photons_at_chan proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~track->proc~get_indices proc~in_plasma in_plasma proc~track->proc~in_plasma h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_fida_weights->h5ltset_attribute_string_f h5open_f h5open_f proc~write_fida_weights->h5open_f h5close_f h5close_f proc~write_fida_weights->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_fida_weights->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_fida_weights->h5ltmake_dataset_int_f h5fcreate_f h5fcreate_f proc~write_fida_weights->h5fcreate_f proc~xyz_to_uvw xyz_to_uvw proc~get_ep_denf->proc~xyz_to_uvw interface~interpol interpol proc~get_ep_denf->interface~interpol proc~get_position get_position proc~get_ep_denf->proc~get_position proc~get_plasma->proc~in_plasma proc~get_plasma->proc~get_position proc~gyro_correction->proc~randu proc~pitch_to_vec pitch_to_vec proc~gyro_correction->proc~pitch_to_vec proc~gyro_step gyro_step proc~gyro_correction->proc~gyro_step omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~get_fields->proc~in_plasma proc~get_fields->proc~get_position proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~mc_halo mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~spectrum spectrum proc~store_fw_photons_at_chan->proc~spectrum proc~lubksb lubksb proc~matinv->proc~lubksb proc~ludcmp ludcmp proc~matinv->proc~ludcmp interface~interpol_coeff interpol_coeff proc~get_rate_matrix->interface~interpol_coeff proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balance balance proc~eigen->proc~balance proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~rswap RSWAP proc~balance->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~elmhes->proc~rswap proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~in_plasma->interface~interpol_coeff proc~in_plasma->proc~xyz_to_uvw proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~cross_product cross_product proc~gyro_step->proc~cross_product proc~neut_rates->interface~interpol_coeff proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform var panprocfida_weights_mcCallsGraph = svgPanZoom('#procfida_weights_mcCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~fida_weights_mc~~CalledByGraph proc~fida_weights_mc fida_weights_mc program~fidasim fidasim program~fidasim->proc~fida_weights_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code fida_weights_mc Source Code subroutine fida_weights_mc !+ Calculates FIDA weights integer :: i , j , k !! indices  x,y,z of cells integer ( Int64 ) :: iion , ip real ( Float64 ), dimension ( 3 ) :: ri , rg !! start position real ( Float64 ), dimension ( 3 ) :: vi !! velocity of fast ions integer , dimension ( 3 ) :: ind !! new actual cell integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] logical :: los_intersect !! Determination of the CX probability type ( LocalProfiles ) :: plasma type ( LocalEMFields ) :: fields real ( Float64 ), dimension ( nlevs ) :: prob !! Prob. for CX !! Collisiional radiative model along track integer :: ncell integer :: jj !! counter along track type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks real ( Float64 ) :: photons !! photon flux real ( Float64 ), dimension ( nlevs ) :: states !! Density of n-states real ( Float64 ), dimension ( nlevs ) :: denn integer :: nwav real ( Float64 ) :: etov2 , energy , pitch real ( Float64 ) :: dE , dP , dEdP real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr integer , dimension ( 1 ) :: ienergy , ipitch real ( Float64 ), dimension ( 3 ) :: randomu3 !! Number of particles to launch integer ( kind = 8 ) :: pcnt real ( Float64 ) :: papprox_tot , inv_maxcnt , cnt , fbm_denf , phase_area integer , dimension ( 3 , beam_grid % ngrid ) :: pcell real ( Float64 ), dimension ( beam_grid % nx , beam_grid % ny , beam_grid % nz ) :: papprox , nlaunch !! approx. density nwav = inputs % nlambda_wght !! define arrays !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) dEdP = dE * dP phase_area = dEdP * real ( inputs % np_wght ) * real ( inputs % ne_wght ) !! allocate storage arrays allocate ( fweight % weight ( nwav , inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( fweight % mean_f ( inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Number of Channels: \",i5)' ) spec_chords % nchan write ( * , '(T2,\"Nlambda: \",i4)' ) nwav write ( * , '(T2,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T2,\"Maximum Energy: \",f7.2)' ) inputs % emax_wght write ( * , '(T2,\"LOS averaged: \",a)' ) \"False\" endif !! zero out arrays fweight % weight = 0.d0 fweight % mean_f = 0.d0 etov2 = 1.d0 / ( v2_to_E_per_amu * inputs % ab ) !! Estimate how many particles to launch in each cell papprox = 0.d0 papprox_tot = 0.d0 pcnt = 1 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx ind = [ i , j , k ] call get_plasma ( plasma , ind = ind ) papprox ( i , j , k ) = ( sum ( neut % dens (:, nbif_type , i , j , k )) + & sum ( neut % dens (:, nbih_type , i , j , k )) + & sum ( neut % dens (:, nbit_type , i , j , k )) + & sum ( neut % dens (:, halo_type , i , j , k ))) if ( papprox ( i , j , k ). gt . 0 ) then pcell (:, pcnt ) = ind pcnt = pcnt + 1 endif if ( plasma % in_plasma ) papprox_tot = papprox_tot + papprox ( i , j , k ) enddo enddo enddo pcnt = pcnt - 1 inv_maxcnt = 10 0.0 / real ( pcnt ) call get_nlaunch ( 10 * inputs % n_fida , papprox , papprox_tot , nlaunch ) if ( inputs % verbose . ge . 1 ) then write ( * , '(T6,\"# of markers: \",i9)' ) int ( sum ( nlaunch ), Int64 ) endif !! Loop over all cells that have neutrals cnt = 0.d0 loop_over_cells : do ip = 1 , int ( pcnt ) i = pcell ( 1 , ip ) j = pcell ( 2 , ip ) k = pcell ( 3 , ip ) ind = [ i , j , k ] !$OMP PARALLEL DO schedule(guided) private(iion,vi,ri,rg,ienergy,ipitch, & !$OMP tracks,ncell,jj,plasma,fields,prob,denn,states,photons,energy,pitch, & !$OMP los_intersect,randomu3,fbm_denf) loop_over_fast_ions : do iion = 1 , int ( nlaunch ( i , j , k ), Int64 ) !! Sample fast ion distribution uniformally call randind ( inputs % ne_wght , ienergy ) call randind ( inputs % np_wght , ipitch ) call randu ( randomu3 ) energy = ebarr ( ienergy ( 1 )) + dE * ( randomu3 ( 1 ) - 0.5 ) pitch = ptcharr ( ipitch ( 1 )) + dP * ( randomu3 ( 2 ) - 0.5 ) if ( energy . le . 0 ) cycle loop_over_fast_ions call randu ( randomu3 ) rg = [ beam_grid % xc ( i ), beam_grid % yc ( j ), beam_grid % zc ( k )] + beam_grid % dr * ( randomu3 - 0.5 ) !! Get velocity call get_fields ( fields , pos = rg ) if (. not . fields % in_plasma ) cycle loop_over_fast_ions call gyro_correction ( fields , energy , pitch , ri , vi ) fbm_denf = 0.0 if ( inputs % dist_type . eq . 1 ) then call get_ep_denf ( energy , pitch , fbm_denf , coeffs = fields % c ) endif !! Find the particles path through the beam grid call track ( ri , vi , tracks , ncell , los_intersect ) if (. not . los_intersect ) cycle loop_over_fast_ions if ( ncell . eq . 0 ) cycle loop_over_fast_ions !! Calculate CX probability with beam and halo neutrals call get_beam_cx_prob ( tracks ( 1 )% ind , ri , vi , neut_types , prob ) if ( sum ( prob ). le . 0. ) cycle loop_over_fast_ions states = prob * 1.d20 !! Calculate the spectra produced in each cell along the path loop_along_track : do jj = 1 , ncell call get_plasma ( plasma , pos = tracks ( jj )% pos ) call colrad ( plasma , beam_ion , vi , tracks ( jj )% time , states , denn , photons ) call store_fw_photons ( ienergy ( 1 ), ipitch ( 1 ), & tracks ( jj )% pos , vi , fbm_denf , photons / nlaunch ( i , j , k )) enddo loop_along_track enddo loop_over_fast_ions !$OMP END PARALLEL DO cnt = cnt + 1 if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) cnt * inv_maxcnt , char ( 13 ) endif enddo loop_over_cells fweight % weight = (( 1.d-20 ) * phase_area / dEdP ) * fweight % weight fweight % mean_f = (( 1.d-20 ) * phase_area / dEdP ) * fweight % mean_f call write_fida_weights () end subroutine fida_weights_mc","tags":"","loc":"proc/fida_weights_mc.html","title":"fida_weights_mc – FIDASIM"},{"text":"public subroutine fida_weights_los() Calculates LOS averaged FIDA weights Arguments None Calls proc~~fida_weights_los~~CallsGraph proc~fida_weights_los fida_weights_los proc~get_ep_denf get_ep_denf proc~fida_weights_los->proc~get_ep_denf proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~grid_intersect grid_intersect proc~fida_weights_los->proc~grid_intersect proc~write_fida_weights write_fida_weights proc~fida_weights_los->proc~write_fida_weights proc~track track proc~fida_weights_los->proc~track proc~pitch_to_vec pitch_to_vec proc~fida_weights_los->proc~pitch_to_vec proc~get_plasma get_plasma proc~fida_weights_los->proc~get_plasma proc~colrad colrad proc~fida_weights_los->proc~colrad proc~neut_rates neut_rates proc~fida_weights_los->proc~neut_rates proc~get_fields get_fields proc~fida_weights_los->proc~get_fields proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~fida_weights_los->proc~store_fw_photons_at_chan proc~xyz_to_uvw xyz_to_uvw proc~get_ep_denf->proc~xyz_to_uvw interface~interpol interpol proc~get_ep_denf->interface~interpol proc~get_position get_position proc~get_ep_denf->proc~get_position proc~mc_halo->proc~get_plasma proc~randu randu proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_fida_weights->h5ltset_attribute_string_f h5open_f h5open_f proc~write_fida_weights->h5open_f h5close_f h5close_f proc~write_fida_weights->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_fida_weights->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_fida_weights->h5ltmake_dataset_int_f h5fcreate_f h5fcreate_f proc~write_fida_weights->h5fcreate_f proc~get_indices get_indices proc~track->proc~get_indices proc~in_plasma in_plasma proc~track->proc~in_plasma proc~get_plasma->proc~get_position proc~get_plasma->proc~in_plasma proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen interface~interpol_coeff interpol_coeff proc~neut_rates->interface~interpol_coeff proc~get_fields->proc~get_position proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~spectrum spectrum proc~store_fw_photons_at_chan->proc~spectrum proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol_coeff proc~lubksb lubksb proc~matinv->proc~lubksb proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~get_rate_matrix->interface~interpol_coeff proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balance balance proc~eigen->proc~balance proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~elmhes->proc~rswap proc~comdiv Comdiv proc~hqrvec->proc~comdiv var panprocfida_weights_losCallsGraph = svgPanZoom('#procfida_weights_losCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~fida_weights_los~~CalledByGraph proc~fida_weights_los fida_weights_los program~fidasim fidasim program~fidasim->proc~fida_weights_los Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code fida_weights_los Source Code subroutine fida_weights_los !+ Calculates LOS averaged FIDA weights type ( LocalProfiles ) :: plasma , plasma_cell type ( LocalEMFields ) :: fields , fields_cell real ( Float64 ) :: denf real ( Float64 ) :: wght , wght_tot real ( Float64 ) :: photons !! photon flux real ( Float64 ) :: length type ( ParticleTrack ), dimension ( beam_grid % ntrack ) :: tracks integer :: nwav integer ( Int32 ) :: i , j , k , ienergy , cid , cind integer ( Int32 ) :: ipitch , igyro , icell , ichan real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr , phiarr real ( Float64 ), dimension (:,:), allocatable :: mean_f real ( Float64 ), dimension ( 3 ) :: vi , vi_norm , vp real ( Float64 ), dimension ( 3 ) :: vnbi_f , vnbi_h , vnbi_t , vhalo real ( Float64 ), dimension ( 3 ) :: r_enter , r_exit real ( Float64 ) :: vabs , dE , dP !! Determination of the CX probability real ( Float64 ), dimension ( nlevs ) :: fdens , hdens , tdens , halodens real ( Float64 ), dimension ( nlevs ) :: rates real ( Float64 ), dimension ( nlevs ) :: states ! Density of n-states real ( Float64 ), dimension ( nlevs ) :: denn ! Density of n-states !! COLRAD real ( Float64 ) :: dt , max_dens , dlength , sigma_pi type ( LOSInters ) :: inter real ( Float64 ) :: eb , ptch , phi !! Solution of differential equation integer , dimension ( 3 ) :: ind !!actual cell real ( Float64 ), dimension ( 3 ) :: ri integer ( Int32 ) :: ncell real ( Float64 ) :: etov2 , dEdP nwav = inputs % nlambda_wght !! Define energy array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! Define pitch array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) dEdP = dE * dP !! define gyro - array allocate ( phiarr ( inputs % nphi_wght )) do i = 1 , inputs % nphi_wght phiarr ( i ) = real ( i - 0.5 ) * 2.d0 * pi / real ( inputs % nphi_wght ) enddo !! allocate storage arrays allocate ( fweight % mean_f ( inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( fweight % weight ( nwav , inputs % ne_wght , inputs % np_wght , spec_chords % nchan )) allocate ( mean_f ( inputs % ne_wght , inputs % np_wght )) !! zero out arrays fweight % weight = 0.d0 fweight % mean_f = 0.d0 mean_f = 0.d0 if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Number of Channels: \",i5)' ) spec_chords % nchan write ( * , '(T2,\"Nlambda: \",i4)' ) nwav write ( * , '(T2,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T2,\"Npitch: \",i3)' ) inputs % np_wght write ( * , '(T2,\"Ngyro: \", i3)' ) inputs % nphi_wght write ( * , '(T2,\"Maximum Energy: \",f7.2)' ) inputs % emax_wght write ( * , '(T2,\"LOS averaged: \",a)' ) \"True\" write ( * , * ) '' endif etov2 = 1.0 / ( v2_to_E_per_amu * inputs % ab ) chan_loop : do ichan = 1 , spec_chords % nchan fdens = 0.d0 ; hdens = 0.d0 ; tdens = 0.d0 ; halodens = 0.d0 plasma = plasma * 0.d0 fields = fields * 0.d0 wght_tot = 0.d0 mean_f = 0.d0 do k = 1 , beam_grid % nz do j = 1 , beam_grid % ny do i = 1 , beam_grid % nx inter = spec_chords % inter ( i , j , k ) cid = 0 cind = 0 do while ( cid . ne . ichan . and . cind . lt . inter % nchan ) cind = cind + 1 cid = inter % los_elem ( cind )% id enddo if ( cid . eq . ichan ) then ind = [ i , j , k ] dlength = inter % los_elem ( cind )% length fdens = fdens + neut % dens (:, nbif_type , i , j , k ) * dlength hdens = hdens + neut % dens (:, nbih_type , i , j , k ) * dlength tdens = tdens + neut % dens (:, nbit_type , i , j , k ) * dlength halodens = halodens + neut % dens (:, halo_type , i , j , k ) * dlength wght = sum ( neut % dens ( 3 , 1 : 4 , i , j , k )) * dlength call get_plasma ( plasma_cell , ind = ind ) call get_fields ( fields_cell , ind = ind ) plasma = plasma + wght * plasma_cell fields = fields + wght * fields_cell if ( inputs % dist_type . eq . 1 ) then do ipitch = 1 , inputs % np_wght do ienergy = 1 , inputs % ne_wght call get_ep_denf ( ebarr ( ienergy ), ptcharr ( ipitch ), denf , coeffs = fields_cell % c ) mean_f ( ienergy , ipitch ) = mean_f ( ienergy , ipitch ) + wght * denf enddo enddo endif wght_tot = wght_tot + wght endif enddo enddo enddo if ( wght_tot . le . 0 ) then if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Skipping channel \",i5,\": Neutral density is zero\")' ) ichan endif cycle chan_loop else plasma = plasma / wght_tot plasma % in_plasma = . True . fields = fields / wght_tot fields % in_plasma = . True . mean_f = mean_f / wght_tot if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Channel: \",i5)' ) ichan write ( * , '(T4,\"Radius: \",f7.2)' ) spec_chords % radius ( ichan ) write ( * , '(T4,\"Mean Fast-ion Density: \",ES14.5)' ) sum ( mean_f ) * dEdP write ( * , * ) '' endif endif ri = plasma % pos vp = ri - spec_chords % los ( ichan )% lens vnbi_f = ri - nbi % src vnbi_f = vnbi_f / norm2 ( vnbi_f ) * nbi % vinj vnbi_h = vnbi_f / sqrt ( 2.d0 ) vnbi_t = vnbi_f / sqrt ( 3.d0 ) sigma_pi = spec_chords % los ( ichan )% sigma_pi dlength = 1.d0 !$OMP PARALLEL DO schedule(guided) collapse(3) private(eb,vabs,ptch,phi,vi,vi_norm, & !$OMP& r_enter,r_exit,length,max_dens,ind,tracks,ncell,dt,icell,states,rates, & !$OMP& vhalo,denn,denf,photons,ienergy,ipitch,igyro) do ienergy = 1 , inputs % ne_wght do ipitch = 1 , inputs % np_wght do igyro = 1 , inputs % nphi_wght eb = ebarr ( ienergy ) vabs = sqrt ( eb * etov2 ) ptch = ptcharr ( ipitch ) phi = phiarr ( igyro ) call pitch_to_vec ( ptch , phi , fields , vi_norm ) vi = vabs * vi_norm call grid_intersect ( ri , vi , length , r_enter , r_exit ) call track ( r_enter , vi , tracks , ncell ) max_dens = 0.d0 do icell = 1 , ncell ind = tracks ( icell )% ind tracks ( icell )% flux = sum ( neut % dens ( 3 , 1 : 4 , ind ( 1 ), ind ( 2 ), ind ( 3 ))) if ( tracks ( icell )% flux . gt . max_dens ) max_dens = tracks ( icell )% flux enddo dt = 0.d0 do icell = 1 , ncell if ( tracks ( icell )% flux . gt .( 0.5 * max_dens )) then dt = dt + tracks ( icell )% time endif enddo states = 0.d0 call neut_rates ( fdens , vi , vnbi_f , rates ) states = states + rates call neut_rates ( hdens , vi , vnbi_h , rates ) states = states + rates call neut_rates ( tdens , vi , vnbi_t , rates ) states = states + rates do i = 1 , int ( n_halo_neutrate ) call mc_halo ( ind , vhalo , plasma_in = plasma ) call neut_rates ( halodens , vi , vhalo , rates ) states = states + rates / real ( n_halo_neutrate ) enddo call colrad ( plasma , beam_ion , vi , dt , states , denn , photons ) denf = mean_f ( ienergy , ipitch ) * dEdP photons = photons / real ( inputs % nphi_wght ) call store_fw_photons_at_chan ( ichan , ienergy , ipitch , & vp , vi , fields , dlength , sigma_pi , denf , photons ) enddo enddo enddo !$OMP END PARALLEL DO enddo chan_loop fweight % mean_f = fweight % mean_f / ( dEdP ) call write_fida_weights () end subroutine fida_weights_los","tags":"","loc":"proc/fida_weights_los.html","title":"fida_weights_los – FIDASIM"},{"text":"public subroutine npa_weights() Calculates NPA weights Arguments None Calls proc~~npa_weights~~CallsGraph proc~npa_weights npa_weights proc~get_ep_denf get_ep_denf proc~npa_weights->proc~get_ep_denf proc~write_npa_weights write_npa_weights proc~npa_weights->proc~write_npa_weights proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~get_beam_cx_prob get_beam_cx_prob proc~npa_weights->proc~get_beam_cx_prob proc~gyro_step gyro_step proc~npa_weights->proc~gyro_step proc~get_fields get_fields proc~npa_weights->proc~get_fields proc~hit_npa_detector hit_npa_detector proc~npa_weights->proc~hit_npa_detector proc~xyz_to_uvw xyz_to_uvw proc~get_ep_denf->proc~xyz_to_uvw interface~interpol interpol proc~get_ep_denf->interface~interpol proc~get_position get_position proc~get_ep_denf->proc~get_position h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_npa_weights->h5ltset_attribute_string_f h5open_f h5open_f proc~write_npa_weights->h5open_f proc~write_beam_grid write_beam_grid proc~write_npa_weights->proc~write_beam_grid h5close_f h5close_f proc~write_npa_weights->h5close_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f h5fclose_f h5fclose_f proc~write_npa_weights->h5fclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_npa_weights->h5ltmake_dataset_int_f h5fcreate_f h5fcreate_f proc~write_npa_weights->h5fcreate_f proc~get_plasma get_plasma proc~attenuate->proc~get_plasma proc~colrad colrad proc~attenuate->proc~colrad proc~neut_rates neut_rates proc~get_beam_cx_prob->proc~neut_rates proc~mc_halo mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~cross_product cross_product proc~gyro_step->proc~cross_product proc~get_fields->proc~get_position proc~in_plasma in_plasma proc~get_fields->proc~in_plasma proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector->proc~line_plane_intersect proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr interface~interpol_coeff interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~write_beam_grid->proc~xyz_to_uvw proc~write_beam_grid->h5ltset_attribute_string_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->h5ltmake_dataset_int_f h5gclose_f h5gclose_f proc~write_beam_grid->h5gclose_f h5gcreate_f h5gcreate_f proc~write_beam_grid->h5gcreate_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~get_plasma->proc~get_position proc~get_plasma->proc~in_plasma proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~in_plasma->proc~xyz_to_uvw proc~in_plasma->interface~interpol_coeff proc~lubksb lubksb proc~matinv->proc~lubksb proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~get_rate_matrix->interface~interpol_coeff proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balance balance proc~eigen->proc~balance proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~elmhes->proc~rswap proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~neut_rates->interface~interpol_coeff proc~mc_halo->proc~get_plasma proc~randu randu proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform var panprocnpa_weightsCallsGraph = svgPanZoom('#procnpa_weightsCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~npa_weights~~CalledByGraph proc~npa_weights npa_weights program~fidasim fidasim program~fidasim->proc~npa_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code npa_weights Source Code subroutine npa_weights !+ Calculates NPA weights type ( LocalEMFields ) :: fields type ( NPAProbability ) :: phit real ( Float64 ) :: pitch real ( Float64 ) :: pcxa integer ( Int32 ) :: det integer ( Int32 ) :: ii , jj , kk , i , ic !!indices integer , dimension ( 1 ) :: ipitch real ( Float64 ), dimension ( 3 ) :: vi , vi_norm real ( Float64 ) :: vabs , fbm_denf , dE , dP , ccnt real ( Float64 ), dimension ( nlevs ) :: pcx !! Rate coefficiants for CX real ( Float64 ), dimension ( nlevs ) :: states , states_i ! Density of n-states integer , dimension ( 4 ) :: neut_types = [ 1 , 2 , 3 , 4 ] real ( Float64 ), dimension ( 3 ) :: pos , dpos , r_gyro integer ( Int32 ) :: ichan real ( Float64 ), dimension (:), allocatable :: ebarr , ptcharr !! define energy - array allocate ( ebarr ( inputs % ne_wght )) do i = 1 , inputs % ne_wght ebarr ( i ) = real ( i - 0.5 ) * inputs % emax_wght / real ( inputs % ne_wght ) enddo dE = abs ( ebarr ( 2 ) - ebarr ( 1 )) !! define pitch - array allocate ( ptcharr ( inputs % np_wght )) do i = 1 , inputs % np_wght ptcharr ( i ) = real ( i - 0.5 ) * 2. / real ( inputs % np_wght ) - 1. enddo dP = abs ( ptcharr ( 2 ) - ptcharr ( 1 )) if ( inputs % verbose . ge . 1 ) then write ( * , '(T2,\"Number of Channels: \",i3)' ) npa_chords % nchan write ( * , '(T2,\"Nenergy: \",i3)' ) inputs % ne_wght write ( * , '(T2,\"Npitch: \",i3)' ) inputs % np_wght write ( * , '(T2,\"Maximum energy: \",f7.2)' ) inputs % emax_wght write ( * , * ) '' endif !! define storage arrays allocate ( nweight % emissivity ( beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % attenuation ( inputs % ne_wght , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % cx ( inputs % ne_wght , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz , & npa_chords % nchan )) allocate ( nweight % weight ( inputs % ne_wght , & inputs % np_wght , & npa_chords % nchan )) allocate ( nweight % flux ( inputs % ne_wght , npa_chords % nchan )) nweight % emissivity = 0.d0 nweight % attenuation = 0.d0 nweight % cx = 0.d0 nweight % weight = 0.d0 nweight % flux = 0.d0 loop_over_channels : do ichan = 1 , npa_chords % nchan if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,\"Channel: \",i3)' ) ichan write ( * , '(T4,\"Radius: \",f10.3)' ) npa_chords % radius ( ichan ) endif ccnt = 0.d0 !$OMP PARALLEL DO schedule(guided) collapse(3) private(ii,jj,kk,fields,phit,& !$OMP& ic,det,pos,dpos,r_gyro,pitch,ipitch,vabs,vi,pcx,pcxa,states,states_i,vi_norm,fbm_denf) loop_along_z : do kk = 1 , beam_grid % nz loop_along_y : do jj = 1 , beam_grid % ny loop_along_x : do ii = 1 , beam_grid % nx phit = npa_chords % phit ( ii , jj , kk , ichan ) if ( phit % p . gt . 0.d0 ) then pos = [ beam_grid % xc ( ii ), beam_grid % yc ( jj ), beam_grid % zc ( kk )] call get_fields ( fields , pos = pos ) if (. not . fields % in_plasma ) cycle loop_along_x !!Check if it hits a detector just to make sure dpos = phit % eff_rd vi_norm = phit % dir call hit_npa_detector ( pos , vi_norm , det ) if ( det . ne . ichan ) then if ( inputs % verbose . ge . 0 ) then write ( * , '(a)' ) 'NPA_WEIGHTS: Missed detector' endif cycle loop_along_x endif !! Determine the angle between the B-field and the Line of Sight pitch = phit % pitch ipitch = minloc ( abs ( ptcharr - pitch )) loop_over_energy : do ic = 1 , inputs % ne_wght !! energy loop vabs = sqrt ( ebarr ( ic ) / ( v2_to_E_per_amu * inputs % ab )) vi = vi_norm * vabs !!Correct for gyro orbit call gyro_step ( vi , fields , r_gyro ) fbm_denf = 0 if ( inputs % dist_type . eq . 1 ) then !get dist at guiding center call get_ep_denf ( ebarr ( ic ), pitch , fbm_denf , pos = ( pos + r_gyro )) endif if ( fbm_denf . ne . fbm_denf ) cycle loop_over_energy !! -------------- calculate CX probability -------!! call get_beam_cx_prob ([ ii , jj , kk ], pos , vi , neut_types , pcx ) if ( sum ( pcx ). le . 0 ) cycle loop_over_energy !!Calculate attenuation states = pcx * 1.0d14 !!needs to be large aribitrary number so colrad works states_i = states call attenuate ( pos , dpos , vi , states ) pcxa = sum ( states ) / sum ( states_i ) !$OMP CRITICAL(npa_wght) nweight % attenuation ( ic , ii , jj , kk , ichan ) = pcxa nweight % cx ( ic , ii , jj , kk , ichan ) = sum ( pcx ) nweight % weight ( ic , ipitch ( 1 ), ichan ) = nweight % weight ( ic , ipitch ( 1 ), ichan ) + & 2 * sum ( pcx ) * pcxa * phit % p * beam_grid % dv / dP nweight % flux ( ic , ichan ) = nweight % flux ( ic , ichan ) + & 2 * beam_grid % dv * fbm_denf * sum ( pcx ) * pcxa * phit % p !Factor of 2 above is to convert fbm to ions/(cm&#94;3 dE (domega/4pi)) nweight % emissivity ( ii , jj , kk , ichan ) = nweight % emissivity ( ii , jj , kk , ichan ) + & 2 * fbm_denf * sum ( pcx ) * pcxa * phit % p * dE !$OMP END CRITICAL(npa_wght) enddo loop_over_energy endif ccnt = ccnt + 1 if ( inputs % verbose . ge . 2 ) then WRITE ( * , '(f7.2,\"% completed\",a,$)' ) ccnt / real ( beam_grid % ngrid ) * 100 , char ( 13 ) endif enddo loop_along_x enddo loop_along_y enddo loop_along_z !$OMP END PARALLEL DO if ( inputs % verbose . ge . 1 ) then write ( * , '(T4,A,ES14.5)' ), 'Flux:   ' , sum ( nweight % flux (:, ichan )) * dE write ( * , '(T4,A,ES14.5)' ), 'Weight: ' , sum ( nweight % weight (:,:, ichan )) * dE * dP write ( * , * ) '' endif enddo loop_over_channels call write_npa_weights () end subroutine npa_weights","tags":"","loc":"proc/npa_weights.html","title":"npa_weights – FIDASIM"},{"text":"public interface assignment(=) Allows for assigning Profiles , LocalProfiles , EMFields , LocalEMFields , FastIon , and NPAParticle Calls interface~~assignment(=)~~CallsGraph interface~assignment(=) assignment(=) proc~pp_assign pp_assign interface~assignment(=)->proc~pp_assign proc~lpp_assign lpp_assign interface~assignment(=)->proc~lpp_assign proc~lplp_assign lplp_assign interface~assignment(=)->proc~lplp_assign proc~fast_ion_assign fast_ion_assign interface~assignment(=)->proc~fast_ion_assign proc~ff_assign ff_assign interface~assignment(=)->proc~ff_assign proc~lflf_assign lflf_assign interface~assignment(=)->proc~lflf_assign proc~lff_assign lff_assign interface~assignment(=)->proc~lff_assign proc~plp_assign plp_assign interface~assignment(=)->proc~plp_assign proc~flf_assign flf_assign interface~assignment(=)->proc~flf_assign proc~npa_part_assign npa_part_assign interface~assignment(=)->proc~npa_part_assign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures pp_assign lpp_assign plp_assign lplp_assign ff_assign lff_assign flf_assign lflf_assign fast_ion_assign npa_part_assign Module Procedures public subroutine pp_assign (p1, p2) Defines how to assign Profiles types to eachother Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 public subroutine lpp_assign (p1, p2) Defines how to assign a Profiles type to a LocalProfiles type Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 public subroutine plp_assign (p1, p2) Defines how to assign a LocalProfiles type to a Profiles type Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine lplp_assign (p1, p2) Defines how to assign LocalProfiles types to eachother Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine ff_assign (p1, p2) Defines how to assign EMFields types to eachother Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 public subroutine lff_assign (p1, p2) Defines how to assign a EMFields type to a LocalEMFields type Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 public subroutine flf_assign (p1, p2) Defines how to assign a LocalEMFields type to a EMFields type Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine lflf_assign (p1, p2) Defines how to assign LocalEMFields types to eachother Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine fast_ion_assign (p1, p2) Defines how to assign FastIon types to eachother Arguments Type Intent Optional Attributes Name type( FastIon ), intent(out) :: p1 type( FastIon ), intent(in) :: p2 public subroutine npa_part_assign (p1, p2) Defines how to assign NPAParticle types to eachother Arguments Type Intent Optional Attributes Name type( NPAParticle ), intent(out) :: p1 type( NPAParticle ), intent(in) :: p2","tags":"","loc":"interface/assignment(=).html","title":"assignment(=) – FIDASIM"},{"text":"public interface operator(+) Allows for adding Profiles , LocalProfiles , EMFields , and LocalEMFields Calls interface~~operator(+)~~CallsGraph interface~operator(+) operator(+) proc~ff_add ff_add interface~operator(+)->proc~ff_add proc~lflf_add lflf_add interface~operator(+)->proc~lflf_add proc~pp_add pp_add interface~operator(+)->proc~pp_add proc~lplp_add lplp_add interface~operator(+)->proc~lplp_add proc~calc_perp_vectors calc_perp_vectors proc~lflf_add->proc~calc_perp_vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures pp_add lplp_add ff_add lflf_add Module Procedures public function pp_add (p1, p2) result(p3) Defines how to add two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_add (p1, p2) result(p3) Defines how to add two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ff_add (p1, p2) result(p3) Defines how to add two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function lflf_add (p1, p2) result(p3) Defines how to add two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields )","tags":"","loc":"interface/operator(+).html","title":"operator(+) – FIDASIM"},{"text":"public interface operator(-) Allows for subtracting Profiles , LocalProfiles , EMFields , and LocalEMFields Calls interface~~operator(-)~~CallsGraph interface~operator(-) operator(-) proc~lplp_subtract lplp_subtract interface~operator(-)->proc~lplp_subtract proc~lflf_subtract lflf_subtract interface~operator(-)->proc~lflf_subtract proc~pp_subtract pp_subtract interface~operator(-)->proc~pp_subtract proc~ff_subtract ff_subtract interface~operator(-)->proc~ff_subtract proc~calc_perp_vectors calc_perp_vectors proc~lflf_subtract->proc~calc_perp_vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures pp_subtract lplp_subtract ff_subtract lflf_subtract Module Procedures public function pp_subtract (p1, p2) result(p3) Defines how to subtract two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_subtract (p1, p2) result(p3) Defines how to subtract two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ff_subtract (p1, p2) result(p3) Defines how to subtract two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function lflf_subtract (p1, p2) result(p3) Defines how to subtract two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields )","tags":"","loc":"interface/operator(-).html","title":"operator(-) – FIDASIM"},{"text":"public interface operator(*) Allows for multiplying Profiles , LocalProfiles , EMFields , and LocalEMFields by scalars Calls interface~~operator(*)~~CallsGraph interface~operator(*) operator(*) proc~sf_multiply sf_multiply interface~operator(*)->proc~sf_multiply proc~fs_multiply fs_multiply interface~operator(*)->proc~fs_multiply proc~slp_multiply slp_multiply interface~operator(*)->proc~slp_multiply proc~lps_multiply lps_multiply interface~operator(*)->proc~lps_multiply proc~lfs_multiply lfs_multiply interface~operator(*)->proc~lfs_multiply proc~slf_multiply slf_multiply interface~operator(*)->proc~slf_multiply proc~sp_multiply sp_multiply interface~operator(*)->proc~sp_multiply proc~ps_multiply ps_multiply interface~operator(*)->proc~ps_multiply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures sp_multiply ps_multiply lps_multiply slp_multiply sf_multiply fs_multiply lfs_multiply slf_multiply Module Procedures public function sp_multiply (real_scalar, p1) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( Profiles ), intent(in) :: p1 Return Value type( Profiles ) public function ps_multiply (p1, real_scalar) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_multiply (p1, real_scalar) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function slp_multiply (real_scalar, p1) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalProfiles ), intent(in) :: p1 Return Value type( LocalProfiles ) public function sf_multiply (real_scalar, p1) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( EMFields ), intent(in) :: p1 Return Value type( EMFields ) public function fs_multiply (p1, real_scalar) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) public function lfs_multiply (p1, real_scalar) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields ) public function slf_multiply (real_scalar, p1) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalEMFields ), intent(in) :: p1 Return Value type( LocalEMFields )","tags":"","loc":"interface/operator(*).html","title":"operator(*) – FIDASIM"},{"text":"public interface operator(/) Allows for dividing Profiles , LocalProfiles , EMFields , and LocalEMFields by scalars Calls interface~~operator(SLASH)~~CallsGraph interface~operator(SLASH) operator(/) proc~ps_divide ps_divide interface~operator(SLASH)->proc~ps_divide proc~fs_divide fs_divide interface~operator(SLASH)->proc~fs_divide proc~lfs_divide lfs_divide interface~operator(SLASH)->proc~lfs_divide proc~lps_divide lps_divide interface~operator(SLASH)->proc~lps_divide Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures ps_divide lps_divide fs_divide lfs_divide Module Procedures public function ps_divide (p1, real_scalar) result(p3) Defines how to divide Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_divide (p1, real_scalar) result(p3) Defines how to divide LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function fs_divide (p1, real_scalar) result(p3) Defines how to divide EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) public function lfs_divide (p1, real_scalar) result(p3) Defines how to divide LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields )","tags":"","loc":"interface/operator(SLASH).html","title":"operator(/) – FIDASIM"},{"text":"public interface interpol_coeff Calculates linear interpolation coefficients Calls interface~~interpol_coeff~~CallsGraph interface~interpol_coeff interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~interpol_coeff~~CalledByGraph interface~interpol_coeff interpol_coeff proc~interpol2d_2d_arr interpol2D_2D_arr proc~interpol2d_2d_arr->interface~interpol_coeff proc~in_plasma in_plasma proc~in_plasma->interface~interpol_coeff proc~interpol2d_arr interpol2D_arr proc~interpol2d_arr->interface~interpol_coeff proc~get_neutron_rate get_neutron_rate proc~get_neutron_rate->interface~interpol_coeff proc~get_rate_matrix get_rate_matrix proc~get_rate_matrix->interface~interpol_coeff proc~neut_rates neut_rates proc~neut_rates->interface~interpol_coeff proc~interpol1d_arr interpol1D_arr proc~interpol1d_arr->interface~interpol_coeff interface~interpol interpol interface~interpol->proc~interpol2d_2d_arr interface~interpol->proc~interpol2d_arr interface~interpol->proc~interpol1d_arr proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~get_plasma get_plasma proc~fida_weights_mc->proc~get_plasma proc~track track proc~fida_weights_mc->proc~track proc~get_fields get_fields proc~fida_weights_mc->proc~get_fields proc~get_beam_cx_prob get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~colrad colrad proc~fida_weights_mc->proc~colrad proc~npa_weights npa_weights proc~npa_weights->proc~get_ep_denf proc~npa_weights->proc~get_fields proc~attenuate attenuate proc~npa_weights->proc~attenuate proc~npa_weights->proc~get_beam_cx_prob proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~neut_rates proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~track proc~fida_weights_los->proc~get_fields proc~mc_halo mc_halo proc~fida_weights_los->proc~mc_halo proc~fida_weights_los->proc~colrad program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_los proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~ndmc ndmc program~fidasim->proc~ndmc proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~dcx dcx program~fidasim->proc~dcx proc~halo halo program~fidasim->proc~halo proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~read_chords read_chords program~fidasim->proc~read_chords proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~read_npa read_npa program~fidasim->proc~read_npa proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~mc_fastion->proc~get_fields proc~fida_f->proc~mc_fastion proc~fida_f->proc~get_plasma proc~fida_f->proc~track proc~fida_f->proc~get_beam_cx_prob proc~store_fida_photons store_fida_photons proc~fida_f->proc~store_fida_photons proc~fida_f->proc~colrad proc~npa_f->proc~mc_fastion proc~npa_f->proc~get_plasma proc~npa_f->proc~attenuate proc~npa_f->proc~get_beam_cx_prob proc~store_npa store_npa proc~npa_f->proc~store_npa proc~mc_nbi mc_nbi proc~mc_nbi->proc~in_plasma proc~get_plasma->proc~in_plasma proc~track->proc~in_plasma proc~read_mc read_mc proc~read_mc->proc~in_plasma proc~get_fields->proc~in_plasma proc~ndmc->proc~mc_nbi proc~ndmc->proc~get_plasma proc~ndmc->proc~track proc~store_bes_photons store_bes_photons proc~ndmc->proc~store_bes_photons proc~ndmc->proc~colrad proc~neutron_mc->proc~get_neutron_rate proc~neutron_mc->proc~get_plasma proc~neutron_mc->proc~get_fields proc~dcx->proc~get_plasma proc~dcx->proc~track proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~dcx->proc~store_bes_photons proc~dcx->proc~colrad proc~halo->proc~get_plasma proc~halo->proc~track proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~halo->proc~store_bes_photons proc~halo->proc~colrad proc~mc_halo->proc~get_plasma proc~attenuate->proc~get_plasma proc~attenuate->proc~colrad proc~bremsstrahlung->proc~get_plasma proc~neutron_f->proc~get_neutron_rate proc~neutron_f->proc~get_plasma proc~neutron_f->proc~get_fields proc~fida_mc->proc~get_plasma proc~fida_mc->proc~track proc~fida_mc->proc~get_fields proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~store_fida_photons proc~fida_mc->proc~colrad proc~get_beam_cx_prob->proc~neut_rates proc~get_beam_cx_prob->proc~mc_halo proc~npa_mc->proc~get_fields proc~npa_mc->proc~attenuate proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~store_npa proc~read_chords->proc~track proc~read_distribution->proc~read_mc proc~store_fida_photons->proc~get_fields proc~read_npa->proc~get_fields proc~store_npa->proc~get_fields proc~store_fw_photons->proc~get_fields proc~store_bes_photons->proc~get_fields proc~colrad->proc~get_rate_matrix var paninterfaceinterpol_coeffCalledByGraph = svgPanZoom('#interfaceinterpol_coeffCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures interpol1D_coeff interpol1D_coeff_arr interpol2D_coeff interpol2D_coeff_arr Module Procedures public subroutine interpol1D_coeff (xmin, dx, nx, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa value real(kind=Float64), intent(in) :: dx Absissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol1D_coeff_arr (x, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol2D_coeff (xmin, dx, nx, ymin, dy, ny, xout, yout, c, err) Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa real(kind=Float64), intent(in) :: dx Abscissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: ymin Minimum ordinate real(kind=Float64), intent(in) :: dy Ordinate spacing integer, intent(in) :: ny Number of ordinates points real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol2D_coeff_arr (x, y, xout, yout, c, err) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in), dimension(:) :: y Ordinate values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code","tags":"","loc":"interface/interpol_coeff.html","title":"interpol_coeff – FIDASIM"},{"text":"public interface interpol Performs linear/bilinear interpolation Calls interface~~interpol~~CallsGraph interface~interpol interpol proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr interface~interpol_coeff interpol_coeff proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~interpol~~CalledByGraph interface~interpol interpol proc~get_ep_denf get_ep_denf proc~get_ep_denf->interface~interpol proc~get_distribution get_distribution proc~get_distribution->interface~interpol proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~get_ep_denf proc~npa_weights npa_weights proc~npa_weights->proc~get_ep_denf proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~get_ep_denf program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~npa_weights program~fidasim->proc~fida_weights_los proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~mc_fastion mc_fastion proc~mc_fastion->proc~get_distribution proc~fida_f->proc~mc_fastion proc~npa_f->proc~mc_fastion Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures interpol1D_arr interpol2D_arr interpol2D_2D_arr Module Procedures public subroutine interpol1D_arr (x, y, xout, yout, err, coeffs) Performs linear interpolation on a uniform 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of y real(kind=Float64), intent(in), dimension(:) :: y Values at abscissa values x : y(x) real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(out) :: yout Interpolant: y(xout) integer, intent(out), optional :: err Error code type( InterpolCoeffs1D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol2D_arr (x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:) :: z Values at the abscissa/ordinates: z(x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out) :: zout Interpolant: z(xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol2D_2D_arr (x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid of 2D arrays z(:,:,x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:,:,:) :: z Values at the abscissa/ordinates: z(:,:,x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out), dimension(:,:) :: zout Interpolant: z(:,:,xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients","tags":"","loc":"interface/interpol.html","title":"interpol – FIDASIM"},{"text":"public subroutine check_compression_availability() Checks whether dataset compression is available Arguments None Calls proc~~check_compression_availability~~CallsGraph proc~check_compression_availability check_compression_availability h5zfilter_avail_f h5zfilter_avail_f proc~check_compression_availability->h5zfilter_avail_f h5close_f h5close_f proc~check_compression_availability->h5close_f h5open_f h5open_f proc~check_compression_availability->h5open_f h5zget_filter_info_f h5zget_filter_info_f proc~check_compression_availability->h5zget_filter_info_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~check_compression_availability~~CalledByGraph proc~check_compression_availability check_compression_availability program~fidasim fidasim program~fidasim->proc~check_compression_availability program~generate_tables generate_tables program~generate_tables->proc~check_compression_availability Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code check_compression_availability Source Code subroutine check_compression_availability !+ Checks whether dataset compression is available IMPLICIT NONE logical :: shuffle_avail , gzip_avail integer :: gzip_info , shuf_info , filter_info_both integer :: error call h5open_f ( error ) filter_info_both = ior ( H5Z_FILTER_ENCODE_ENABLED_F , H5Z_FILTER_DECODE_ENABLED_F ) !! Check for GZIP filter call h5zfilter_avail_f ( H5Z_FILTER_DEFLATE_F , gzip_avail , error ) call h5zget_filter_info_f ( H5Z_FILTER_DEFLATE_F , gzip_info , error ) if (. not . gzip_avail ) then print * , 'HDF5: gzip filter is not available' compress_data = . False . endif if ( filter_info_both . ne . gzip_info ) then print * , 'HDF5: gzip filter is not available for encoding and decoding' compress_data = . False . endif !! Check for SHUFFLE filter call h5zfilter_avail_f ( H5Z_FILTER_SHUFFLE_F , shuffle_avail , error ) call h5zget_filter_info_f ( H5Z_FILTER_SHUFFLE_F , shuf_info , error ) if (. not . shuffle_avail ) then print * , 'HDF5: shuffle filter is not available' compress_data = . False . endif if ( filter_info_both . ne . shuf_info ) then print * , 'HDF5: shuffle filter is not available for encoding and decoding' compress_data = . False . endif if (. not . compress_data ) then print * , 'HDF5: Compression is not available. Proceeding without compression.' endif call h5close_f ( error ) end subroutine check_compression_availability","tags":"","loc":"proc/check_compression_availability.html","title":"check_compression_availability – FIDASIM"},{"text":"public subroutine h5ltread_dataset_int_scalar_f(loc_id, dset_name, x, error) Write a scalar 32-bit integer Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(inout) :: x Data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltread_dataset_int_scalar_f~~CallsGraph proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltread_dataset_int_scalar_f~~CalledByGraph proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_tables read_tables proc~read_tables->proc~h5ltread_dataset_int_scalar_f proc~read_atomic_cross read_atomic_cross proc~read_tables->proc~read_atomic_cross proc~read_nuclear_rates read_nuclear_rates proc~read_tables->proc~read_nuclear_rates proc~read_atomic_rates read_atomic_rates proc~read_tables->proc~read_atomic_rates proc~read_f read_f proc~read_f->proc~h5ltread_dataset_int_scalar_f proc~read_distribution read_distribution proc~read_distribution->proc~h5ltread_dataset_int_scalar_f proc~read_distribution->proc~read_f proc~read_mc read_mc proc~read_distribution->proc~read_mc proc~read_chords read_chords proc~read_chords->proc~h5ltread_dataset_int_scalar_f proc~read_neutrals read_neutrals proc~read_neutrals->proc~h5ltread_dataset_int_scalar_f proc~read_atomic_cross->proc~h5ltread_dataset_int_scalar_f proc~read_npa read_npa proc~read_npa->proc~h5ltread_dataset_int_scalar_f proc~read_mc->proc~h5ltread_dataset_int_scalar_f proc~read_beam read_beam proc~read_beam->proc~h5ltread_dataset_int_scalar_f proc~read_equilibrium read_equilibrium proc~read_equilibrium->proc~h5ltread_dataset_int_scalar_f proc~read_nuclear_rates->proc~h5ltread_dataset_int_scalar_f proc~read_atomic_rates->proc~h5ltread_dataset_int_scalar_f program~fidasim fidasim program~fidasim->proc~read_tables program~fidasim->proc~read_distribution program~fidasim->proc~read_chords program~fidasim->proc~read_neutrals program~fidasim->proc~read_npa program~fidasim->proc~read_beam program~fidasim->proc~read_equilibrium Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltread_dataset_int_scalar_f Source Code subroutine h5ltread_dataset_int_scalar_f ( loc_id , dset_name , x , error ) !+ Write a scalar 32-bit integer IMPLICIT NONE integer ( HID_T ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( inout ) :: x !+ Data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HSIZE_T ), dimension ( 1 ) :: dims ( 1 ) = 1 integer , dimension ( 1 ) :: dummy call h5ltread_dataset_int_f ( loc_id , dset_name , dummy , dims , error ) x = dummy ( 1 ) end subroutine h5ltread_dataset_int_scalar_f","tags":"","loc":"proc/h5ltread_dataset_int_scalar_f.html","title":"h5ltread_dataset_int_scalar_f – FIDASIM"},{"text":"public subroutine h5ltread_dataset_double_scalar_f(loc_id, dset_name, x, error) Write a scalar 64-bit float Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create real(kind=double), intent(inout) :: x Data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltread_dataset_double_scalar_f~~CallsGraph proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltread_dataset_double_scalar_f~~CalledByGraph proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_beam read_beam proc~read_beam->proc~h5ltread_dataset_double_scalar_f proc~read_atomic_cross read_atomic_cross proc~read_atomic_cross->proc~h5ltread_dataset_double_scalar_f proc~read_nuclear_rates read_nuclear_rates proc~read_nuclear_rates->proc~h5ltread_dataset_double_scalar_f proc~read_atomic_rates read_atomic_rates proc~read_atomic_rates->proc~h5ltread_dataset_double_scalar_f program~fidasim fidasim program~fidasim->proc~read_beam proc~read_tables read_tables program~fidasim->proc~read_tables proc~read_tables->proc~read_atomic_cross proc~read_tables->proc~read_nuclear_rates proc~read_tables->proc~read_atomic_rates Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltread_dataset_double_scalar_f Source Code subroutine h5ltread_dataset_double_scalar_f ( loc_id , dset_name , x , error ) !+ Write a scalar 64-bit float IMPLICIT NONE integer ( HID_T ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create real ( double ), intent ( inout ) :: x !+ Data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HSIZE_T ), dimension ( 1 ) :: dims ( 1 ) = 1 real ( double ), dimension ( 1 ) :: dummy call h5ltread_dataset_double_f ( loc_id , dset_name , dummy , dims , error ) x = dummy ( 1 ) end subroutine h5ltread_dataset_double_scalar_f","tags":"","loc":"proc/h5ltread_dataset_double_scalar_f.html","title":"h5ltread_dataset_double_scalar_f – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_double_f_1(loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_double_f_1~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_double_f_1~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_npa program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~neutron_mc->proc~write_neutrons proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_1CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_1CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltmake_compressed_dataset_double_f_1 Source Code subroutine h5ltmake_compressed_dataset_double_f_1 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 1 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), dimension ( dims ( 1 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_1","tags":"","loc":"proc/h5ltmake_compressed_dataset_double_f_1.html","title":"h5ltmake_compressed_dataset_double_f_1 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_double_f_2(loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_double_f_2~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_double_f_2~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_npa program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~neutron_mc->proc~write_neutrons proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_2CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_2CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltmake_compressed_dataset_double_f_2 Source Code subroutine h5ltmake_compressed_dataset_double_f_2 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 2 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), dimension ( dims ( 1 ), dims ( 2 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_2","tags":"","loc":"proc/h5ltmake_compressed_dataset_double_f_2.html","title":"h5ltmake_compressed_dataset_double_f_2 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_double_f_3(loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_double_f_3~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_double_f_3~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_npa program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~neutron_mc->proc~write_neutrons proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_3CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_3CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltmake_compressed_dataset_double_f_3 Source Code subroutine h5ltmake_compressed_dataset_double_f_3 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 3 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_3","tags":"","loc":"proc/h5ltmake_compressed_dataset_double_f_3.html","title":"h5ltmake_compressed_dataset_double_f_3 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_double_f_4(loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_double_f_4~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_double_f_4~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_npa program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~neutron_mc->proc~write_neutrons proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_4CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_4CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltmake_compressed_dataset_double_f_4 Source Code subroutine h5ltmake_compressed_dataset_double_f_4 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 4 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_4","tags":"","loc":"proc/h5ltmake_compressed_dataset_double_f_4.html","title":"h5ltmake_compressed_dataset_double_f_4 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_double_f_5(loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_double_f_5~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_double_f_5~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_npa program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~neutron_mc->proc~write_neutrons proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_5CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_5CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltmake_compressed_dataset_double_f_5 Source Code subroutine h5ltmake_compressed_dataset_double_f_5 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 5 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_5","tags":"","loc":"proc/h5ltmake_compressed_dataset_double_f_5.html","title":"h5ltmake_compressed_dataset_double_f_5 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_double_f_6(loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_double_f_6~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_double_f_6~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_npa program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~neutron_mc->proc~write_neutrons proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_6CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_6CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltmake_compressed_dataset_double_f_6 Source Code subroutine h5ltmake_compressed_dataset_double_f_6 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 6 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_6","tags":"","loc":"proc/h5ltmake_compressed_dataset_double_f_6.html","title":"h5ltmake_compressed_dataset_double_f_6 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_double_f_7(loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_double_f_7~~CallsGraph proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_double_f_7~~CalledByGraph proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_npa program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~neutron_mc->proc~write_neutrons proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var panproch5ltmake_compressed_dataset_double_f_7CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_double_f_7CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltmake_compressed_dataset_double_f_7 Source Code subroutine h5ltmake_compressed_dataset_double_f_7 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 64-bit float dataset of dimension 7 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension real ( double ), intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 ), dims ( 7 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_double_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_DOUBLE , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_DOUBLE , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_double_f_7","tags":"","loc":"proc/h5ltmake_compressed_dataset_double_f_7.html","title":"h5ltmake_compressed_dataset_double_f_7 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_int_f_1(loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_int_f_1~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_1->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_deflate_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_1->h5screate_simple_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_1->h5ltmake_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_int_f_1~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa var panproch5ltmake_compressed_dataset_int_f_1CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_int_f_1CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltmake_compressed_dataset_int_f_1 Source Code subroutine h5ltmake_compressed_dataset_int_f_1 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 1 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_1","tags":"","loc":"proc/h5ltmake_compressed_dataset_int_f_1.html","title":"h5ltmake_compressed_dataset_int_f_1 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_int_f_2(loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_int_f_2~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_2->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_deflate_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_2->h5screate_simple_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2->h5ltmake_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_int_f_2~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa var panproch5ltmake_compressed_dataset_int_f_2CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_int_f_2CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltmake_compressed_dataset_int_f_2 Source Code subroutine h5ltmake_compressed_dataset_int_f_2 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 2 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_2","tags":"","loc":"proc/h5ltmake_compressed_dataset_int_f_2.html","title":"h5ltmake_compressed_dataset_int_f_2 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_int_f_3(loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_int_f_3~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_3->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_deflate_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_3->h5screate_simple_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3->h5ltmake_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_int_f_3~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa var panproch5ltmake_compressed_dataset_int_f_3CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_int_f_3CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltmake_compressed_dataset_int_f_3 Source Code subroutine h5ltmake_compressed_dataset_int_f_3 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 3 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_3","tags":"","loc":"proc/h5ltmake_compressed_dataset_int_f_3.html","title":"h5ltmake_compressed_dataset_int_f_3 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_int_f_4(loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_int_f_4~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_4->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_deflate_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_4->h5screate_simple_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_4->h5ltmake_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_int_f_4~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa var panproch5ltmake_compressed_dataset_int_f_4CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_int_f_4CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltmake_compressed_dataset_int_f_4 Source Code subroutine h5ltmake_compressed_dataset_int_f_4 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 4 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 )), intent ( in ) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_4","tags":"","loc":"proc/h5ltmake_compressed_dataset_int_f_4.html","title":"h5ltmake_compressed_dataset_int_f_4 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_int_f_5(loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_int_f_5~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_5->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_deflate_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_5->h5screate_simple_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_5->h5ltmake_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_int_f_5~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa var panproch5ltmake_compressed_dataset_int_f_5CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_int_f_5CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltmake_compressed_dataset_int_f_5 Source Code subroutine h5ltmake_compressed_dataset_int_f_5 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 5 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_5","tags":"","loc":"proc/h5ltmake_compressed_dataset_int_f_5.html","title":"h5ltmake_compressed_dataset_int_f_5 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_int_f_6(loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_int_f_6~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_6->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_deflate_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_6->h5screate_simple_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_6->h5ltmake_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_int_f_6~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa var panproch5ltmake_compressed_dataset_int_f_6CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_int_f_6CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltmake_compressed_dataset_int_f_6 Source Code subroutine h5ltmake_compressed_dataset_int_f_6 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 6 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_6","tags":"","loc":"proc/h5ltmake_compressed_dataset_int_f_6.html","title":"h5ltmake_compressed_dataset_int_f_6 – FIDASIM"},{"text":"public subroutine h5ltmake_compressed_dataset_int_f_7(loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Calls proc~~h5ltmake_compressed_dataset_int_f_7~~CallsGraph proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_deflate_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_7->h5screate_simple_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_7->h5ltmake_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~h5ltmake_compressed_dataset_int_f_7~~CalledByGraph proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa var panproch5ltmake_compressed_dataset_int_f_7CalledByGraph = svgPanZoom('#proch5ltmake_compressed_dataset_int_f_7CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h5ltmake_compressed_dataset_int_f_7 Source Code subroutine h5ltmake_compressed_dataset_int_f_7 ( loc_id ,& dset_name , rank , dims , buf , error ) !+ Write a compressed 32-bit integer dataset of dimension 7 IMPLICIT NONE integer ( hid_t ), intent ( in ) :: loc_id !+ HDF5 file or group identifier character ( len =* ), intent ( in ) :: dset_name !+ Name of the dataset to create integer , intent ( in ) :: rank !+ Number of dimensions of dataspace integer ( HSIZE_T ), dimension ( * ), intent ( in ) :: dims !+ Array of the size of each dimension integer , intent ( in ), & dimension ( dims ( 1 ), dims ( 2 ), dims ( 3 ), dims ( 4 ), dims ( 5 ), dims ( 6 ), dims ( 7 )) :: buf !+ Buffer with data to be written to the dataset integer , intent ( out ) :: error !+ HDF5 error code integer ( HID_T ) :: did , sid , plist_id if (. not . compress_data ) then call h5ltmake_dataset_int_f ( loc_id , dset_name , rank , dims , buf , error ) else call h5screate_simple_f ( rank , dims , sid , error ) call h5pcreate_f ( H5P_DATASET_CREATE_F , plist_id , error ) call h5pset_shuffle_f ( plist_id , error ) call h5pset_deflate_f ( plist_id , 9 , error ) call h5pset_chunk_f ( plist_id , rank , dims , error ) call h5dcreate_f ( loc_id , dset_name , H5T_NATIVE_INTEGER , sid , & did , error , dcpl_id = plist_id ) call h5dwrite_f ( did , H5T_NATIVE_INTEGER , buf , dims , error ) call h5sclose_f ( sid , error ) call h5pclose_f ( plist_id , error ) call h5dclose_f ( did , error ) endif end subroutine h5ltmake_compressed_dataset_int_f_7","tags":"","loc":"proc/h5ltmake_compressed_dataset_int_f_7.html","title":"h5ltmake_compressed_dataset_int_f_7 – FIDASIM"},{"text":"public interface h5ltmake_compressed_dataset_double_f Write a compressed datasets of 64-bit floats Calls interface~~h5ltmake_compressed_dataset_double_f~~CallsGraph interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var paninterfaceh5ltmake_compressed_dataset_double_fCallsGraph = svgPanZoom('#interfaceh5ltmake_compressed_dataset_double_fCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~h5ltmake_compressed_dataset_double_f~~CalledByGraph interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_einstein write_einstein proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons write_neutrons proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid proc~write_fida_weights write_fida_weights proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights write_npa_weights proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->proc~write_beam_grid proc~write_spectra write_spectra proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals write_neutrals proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->proc~write_beam_grid proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx write_dcx proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->proc~write_beam_grid proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_einstein program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bb_h_e program~generate_tables->proc~write_bb_d_d program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bb_h_aq program~generate_tables->proc~write_bb_h_h program~generate_tables->proc~write_bt_h_e program~fidasim fidasim program~fidasim->proc~write_npa program~fidasim->proc~write_birth_profile program~fidasim->proc~write_spectra program~fidasim->proc~write_neutrals program~fidasim->proc~write_dcx proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_f->proc~write_neutrons proc~neutron_mc->proc~write_neutrons proc~fida_weights_mc->proc~write_fida_weights proc~fida_weights_los->proc~write_fida_weights proc~npa_weights->proc~write_npa_weights var paninterfaceh5ltmake_compressed_dataset_double_fCalledByGraph = svgPanZoom('#interfaceh5ltmake_compressed_dataset_double_fCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_7 Module Procedures public subroutine h5ltmake_compressed_dataset_double_f_1 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_2 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_3 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_4 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_5 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_6 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_7 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code","tags":"","loc":"interface/h5ltmake_compressed_dataset_double_f.html","title":"h5ltmake_compressed_dataset_double_f – FIDASIM"},{"text":"public interface h5ltmake_compressed_dataset_int_f Write a compressed dataset of 32-bit integers Calls interface~~h5ltmake_compressed_dataset_int_f~~CallsGraph interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_1->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_deflate_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_1->h5screate_simple_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5dcreate_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_1->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5ltmake_dataset_int_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~h5ltmake_compressed_dataset_int_f~~CalledByGraph interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f proc~write_birth_profile write_birth_profile proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f proc~write_npa write_npa proc~write_npa->interface~h5ltmake_compressed_dataset_int_f program~fidasim fidasim program~fidasim->proc~write_birth_profile program~fidasim->proc~write_npa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_7 Module Procedures public subroutine h5ltmake_compressed_dataset_int_f_1 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_2 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_3 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_4 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_5 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_6 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_7 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code","tags":"","loc":"interface/h5ltmake_compressed_dataset_int_f.html","title":"h5ltmake_compressed_dataset_int_f – FIDASIM"},{"text":"public function sub2ind(dims, subs) result(ind) Calculates the linear index of an array with dimensions dims and\n subcripts subs Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: dims Dimension of Array integer, intent(in), dimension(:) :: subs Subscripts to convert Return Value integer Linear index Called By proc~~sub2ind~~CalledByGraph proc~sub2ind sub2ind proc~get_value get_value proc~get_value->proc~sub2ind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code sub2ind Source Code function sub2ind ( dims , subs ) result ( ind ) !+ Calculates the linear index of an array with dimensions `dims` and !+ subcripts `subs` integer , dimension (:), intent ( in ) :: dims !+ Dimension of Array integer , dimension (:), intent ( in ) :: subs !+ Subscripts to convert integer :: ind !+ Linear index integer :: k , l , p ind = subs ( 1 ) do k = 2 , size ( dims ) p = dims ( 1 ) do l = 2 , k - 1 p = p * dims ( l ) enddo ind = ind + p * ( subs ( k ) - 1 ) enddo end function sub2ind","tags":"","loc":"proc/sub2ind.html","title":"sub2ind – FIDASIM"},{"text":"public function rng_uniform(self) result(u) Generate a uniformally-distributed random number in the range [0,1) Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator Return Value real(kind=Float64) Uniform random deviate Called By proc~~rng_uniform~~CalledByGraph proc~rng_uniform rng_uniform proc~randu randu proc~randu->proc~rng_uniform proc~rng_normal rng_normal proc~rng_normal->proc~rng_uniform proc~get_nlaunch get_nlaunch proc~get_nlaunch->proc~randu proc~ndmc ndmc proc~ndmc->proc~randu proc~mc_nbi mc_nbi proc~ndmc->proc~mc_nbi proc~read_chords read_chords proc~read_chords->proc~randu proc~mc_halo mc_halo proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~mc_fastion mc_fastion proc~mc_fastion->proc~randu proc~npa_mc npa_mc proc~npa_mc->proc~randu proc~get_beam_cx_prob get_beam_cx_prob proc~npa_mc->proc~get_beam_cx_prob proc~gyro_correction gyro_correction proc~gyro_correction->proc~randu proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~randu proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~randu proc~fida_weights_mc->proc~get_nlaunch proc~fida_weights_mc->proc~gyro_correction proc~fida_weights_mc->proc~get_beam_cx_prob proc~mc_nbi->proc~randu proc~mc_nbi->proc~randn proc~fida_mc fida_mc proc~fida_mc->proc~randu proc~fida_mc->proc~gyro_correction proc~fida_mc->proc~get_beam_cx_prob proc~dcx dcx proc~dcx->proc~get_nlaunch proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~halo halo proc~halo->proc~get_nlaunch proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~npa_f npa_f proc~npa_f->proc~get_nlaunch proc~npa_f->proc~mc_fastion proc~npa_f->proc~get_beam_cx_prob proc~fida_f fida_f proc~fida_f->proc~get_nlaunch proc~fida_f->proc~mc_fastion proc~fida_f->proc~gyro_correction proc~fida_f->proc~get_beam_cx_prob program~fidasim fidasim program~fidasim->proc~ndmc program~fidasim->proc~read_chords program~fidasim->proc~npa_mc program~fidasim->proc~bremsstrahlung program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_mc program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~npa_f program~fidasim->proc~fida_f proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~fida_weights_los->proc~mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~npa_weights->proc~get_beam_cx_prob proc~neutron_mc->proc~gyro_correction proc~neutron_f->proc~gyro_correction proc~randn->proc~rng_normal var panprocrng_uniformCalledByGraph = svgPanZoom('#procrng_uniformCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code rng_uniform Source Code function rng_uniform ( self ) result ( u ) !+ Generate a uniformally-distributed random number in the range [0,1) type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator real ( Float64 ) :: u !+ Uniform random deviate integer ( Int32 ) :: ix , iy , k ix = self % state ( 1 ) iy = self % state ( 2 ) ix = ieor ( ix , ishft ( ix , 13 )) ix = ieor ( ix , ishft ( ix , - 17 )) ix = ieor ( ix , ishft ( ix , 5 )) k = iy / IQ iy = IA * ( iy - k * IQ ) - IR * k if ( iy . lt . 0 ) iy = iy + IM self % state ( 1 ) = ix self % state ( 2 ) = iy u = am * ior ( iand ( IM , ieor ( ix , iy )), 1 ) end function rng_uniform","tags":"","loc":"proc/rng_uniform.html","title":"rng_uniform – FIDASIM"},{"text":"public function rng_normal(self) result(n) Generate a normally-distributed random number with mean 0 and standard deviation 1 Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator Return Value real(kind=Float64) Normal random deviate Calls proc~~rng_normal~~CallsGraph proc~rng_normal rng_normal proc~rng_uniform rng_uniform proc~rng_normal->proc~rng_uniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~rng_normal~~CalledByGraph proc~rng_normal rng_normal proc~randn randn proc~randn->proc~rng_normal proc~mc_halo mc_halo proc~mc_halo->proc~randn proc~mc_nbi mc_nbi proc~mc_nbi->proc~randn proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~mc_halo proc~dcx dcx proc~dcx->proc~mc_halo proc~get_beam_cx_prob get_beam_cx_prob proc~dcx->proc~get_beam_cx_prob proc~get_beam_cx_prob->proc~mc_halo proc~halo halo proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo proc~fida_f fida_f program~fidasim->proc~fida_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~ndmc ndmc program~fidasim->proc~ndmc proc~fida_f->proc~get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~npa_mc->proc~get_beam_cx_prob proc~npa_weights->proc~get_beam_cx_prob proc~npa_f->proc~get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~ndmc->proc~mc_nbi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code rng_normal Source Code function rng_normal ( self ) result ( n ) !+ Generate a normally-distributed random number with mean 0 and standard deviation 1 type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator real ( Float64 ) :: n !+ Normal random deviate real ( Float64 ), parameter :: s = 0.449871d0 real ( Float64 ), parameter :: t = 0.386595d0 real ( Float64 ), parameter :: a = 0.196000d0 real ( Float64 ), parameter :: b = 0.254720d0 real ( Float64 ), parameter :: r1 = 0.27597d0 real ( Float64 ), parameter :: r2 = 0.27846d0 real ( Float64 ) :: u , v , x , y , q do u = rng_uniform ( self ) v = rng_uniform ( self ) v = 1.7156d0 * ( v - 0.5d0 ) x = u - s y = abs ( v ) + t q = x ** 2 + y * ( a * y - b * x ) if ( q . lt . r1 ) exit if ( q . gt . r2 ) cycle if (( v ** 2 ). lt .( - 4.0 * log ( u ) * u ** 2 )) exit enddo n = v / u end function rng_normal","tags":"","loc":"proc/rng_normal.html","title":"rng_normal – FIDASIM"},{"text":"public function get_value(SA, subs) result(val) Gets value of sparse array SA at the subscripts subs Arguments Type Intent Optional Attributes Name type( SparseArray ), intent(in) :: SA Sparse Array integer, intent(in), dimension(:) :: subs Subscripts of Sparse Array Return Value real(kind=Float64) Value of SA at subs Calls proc~~get_value~~CallsGraph proc~get_value get_value proc~sub2ind sub2ind proc~get_value->proc~sub2ind Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code get_value Source Code function get_value ( SA , subs ) result ( val ) !+ Gets value of sparse array `SA` at the subscripts `subs` type ( SparseArray ), intent ( in ) :: SA !+ Sparse Array integer , dimension (:), intent ( in ) :: subs !+ Subscripts of Sparse Array real ( Float64 ) :: val !+ Value of `SA` at `subs` integer :: ind , cind val = 0.d0 if ( SA % nnz . eq . 0 ) return ind = sub2ind ( SA % dims , subs ) cind = search_sorted_first ( SA % inds , ind ) if ( ind . eq . SA % inds ( cind )) then val = SA % vals ( cind ) endif end function get_value","tags":"","loc":"proc/get_value.html","title":"get_value – FIDASIM"},{"text":"public subroutine ind2sub(dims, ind, subs) Calculate the subscripts subs into an array with dimensions dims given the corresponding linear index ind Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: dims Dimensions of array integer, intent(in) :: ind Linear index integer, intent(out), dimension(:) :: subs Subscripts corresponding to the linear index Source Code ind2sub Source Code subroutine ind2sub ( dims , ind , subs ) !+ Calculate the subscripts `subs` into an array with dimensions `dims` !+ given the corresponding linear index `ind` integer , dimension (:), intent ( in ) :: dims !+ Dimensions of array integer , intent ( in ) :: ind !+ Linear index integer , dimension (:), intent ( out ) :: subs !+ Subscripts corresponding to the linear index integer :: i , ndims , ind1 , ind2 ind1 = ind ndims = size ( dims ) do i = 1 , ndims - 1 ind2 = ( ind1 - 1 ) / dims ( i ) + 1 subs ( i ) = ind1 - dims ( i ) * ( ind2 - 1 ) ind1 = ind2 enddo subs ( ndims ) = ind1 end subroutine ind2sub","tags":"","loc":"proc/ind2sub.html","title":"ind2sub – FIDASIM"},{"text":"public subroutine rng_init(self, seed) Procedure to initialize a random number generator with a seed Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator integer(kind=Int32), intent(in) :: seed Initial Seed Value Source Code rng_init Source Code subroutine rng_init ( self , seed ) !+ Procedure to initialize a random number generator with a seed type ( rng_type ), intent ( inout ) :: self !+ Random Number Generator integer ( Int32 ), intent ( in ) :: seed !+ Initial Seed Value self % state ( 1 ) = ieor ( 777755555 , abs ( seed )) self % state ( 2 ) = ior ( ieor ( 888889999 , abs ( seed )), 1 ) end subroutine rng_init","tags":"","loc":"proc/rng_init.html","title":"rng_init – FIDASIM"},{"text":"public subroutine randu(randomu) Generate an array of uniformally-distributed random deviates Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:) :: randomu Array of uniform random deviates Calls proc~~randu~~CallsGraph proc~randu randu omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~randu~~CalledByGraph proc~randu randu proc~get_nlaunch get_nlaunch proc~get_nlaunch->proc~randu proc~ndmc ndmc proc~ndmc->proc~randu proc~mc_nbi mc_nbi proc~ndmc->proc~mc_nbi proc~read_chords read_chords proc~read_chords->proc~randu proc~mc_halo mc_halo proc~mc_halo->proc~randu proc~mc_fastion mc_fastion proc~mc_fastion->proc~randu proc~npa_mc npa_mc proc~npa_mc->proc~randu proc~get_beam_cx_prob get_beam_cx_prob proc~npa_mc->proc~get_beam_cx_prob proc~gyro_correction gyro_correction proc~gyro_correction->proc~randu proc~bremsstrahlung bremsstrahlung proc~bremsstrahlung->proc~randu proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->proc~randu proc~fida_weights_mc->proc~get_nlaunch proc~fida_weights_mc->proc~gyro_correction proc~fida_weights_mc->proc~get_beam_cx_prob proc~mc_nbi->proc~randu proc~fida_mc fida_mc proc~fida_mc->proc~randu proc~fida_mc->proc~gyro_correction proc~fida_mc->proc~get_beam_cx_prob proc~dcx dcx proc~dcx->proc~get_nlaunch proc~dcx->proc~mc_halo proc~dcx->proc~get_beam_cx_prob proc~halo halo proc~halo->proc~get_nlaunch proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob proc~npa_f npa_f proc~npa_f->proc~get_nlaunch proc~npa_f->proc~mc_fastion proc~npa_f->proc~get_beam_cx_prob proc~fida_f fida_f proc~fida_f->proc~get_nlaunch proc~fida_f->proc~mc_fastion proc~fida_f->proc~gyro_correction proc~fida_f->proc~get_beam_cx_prob program~fidasim fidasim program~fidasim->proc~ndmc program~fidasim->proc~read_chords program~fidasim->proc~npa_mc program~fidasim->proc~bremsstrahlung program~fidasim->proc~fida_weights_mc program~fidasim->proc~fida_mc program~fidasim->proc~dcx program~fidasim->proc~halo program~fidasim->proc~npa_f program~fidasim->proc~fida_f proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~fida_weights_los->proc~mc_halo proc~get_beam_cx_prob->proc~mc_halo proc~npa_weights->proc~get_beam_cx_prob proc~neutron_mc->proc~gyro_correction proc~neutron_f->proc~gyro_correction Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code randu Source Code subroutine randu ( randomu ) !+ Generate an array of uniformally-distributed random deviates real ( Float64 ), dimension (:), intent ( out ) :: randomu !+ Array of uniform random deviates integer :: i , thread_id #ifdef _OMP thread_id = OMP_get_thread_num () + 1 #else thread_id = 1 #endif randomu = 0.d0 do i = 1 , size ( randomu ) randomu ( i ) = rng_uniform ( rng ( thread_id )) enddo end subroutine randu","tags":"","loc":"proc/randu.html","title":"randu – FIDASIM"},{"text":"public subroutine randn(randomn) Generate an array of normally-distributed random deviates Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:) :: randomn Array of normal random deviates Calls proc~~randn~~CallsGraph proc~randn randn omp_get_thread_num omp_get_thread_num proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_uniform rng_uniform proc~rng_normal->proc~rng_uniform Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~randn~~CalledByGraph proc~randn randn proc~mc_halo mc_halo proc~mc_halo->proc~randn proc~mc_nbi mc_nbi proc~mc_nbi->proc~randn proc~fida_weights_los fida_weights_los proc~fida_weights_los->proc~mc_halo proc~dcx dcx proc~dcx->proc~mc_halo proc~get_beam_cx_prob get_beam_cx_prob proc~dcx->proc~get_beam_cx_prob proc~get_beam_cx_prob->proc~mc_halo proc~halo halo proc~halo->proc~mc_halo proc~halo->proc~get_beam_cx_prob program~fidasim fidasim program~fidasim->proc~fida_weights_los program~fidasim->proc~dcx program~fidasim->proc~halo proc~fida_f fida_f program~fidasim->proc~fida_f proc~fida_mc fida_mc program~fidasim->proc~fida_mc proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~npa_weights npa_weights program~fidasim->proc~npa_weights proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~ndmc ndmc program~fidasim->proc~ndmc proc~fida_f->proc~get_beam_cx_prob proc~fida_mc->proc~get_beam_cx_prob proc~npa_mc->proc~get_beam_cx_prob proc~npa_weights->proc~get_beam_cx_prob proc~npa_f->proc~get_beam_cx_prob proc~fida_weights_mc->proc~get_beam_cx_prob proc~ndmc->proc~mc_nbi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code randn Source Code subroutine randn ( randomn ) !+ Generate an array of normally-distributed random deviates real ( Float64 ), dimension (:), intent ( out ) :: randomn !+ Array of normal random deviates integer :: i , thread_id #ifdef _OMP thread_id = OMP_get_thread_num () + 1 #else thread_id = 1 #endif randomn = 0.d0 do i = 1 , size ( randomn ) randomn ( i ) = rng_normal ( rng ( thread_id )) enddo end subroutine randn","tags":"","loc":"proc/randn.html","title":"randn – FIDASIM"},{"text":"public interface randind Procedure for generating a random array index/subscripts Called By interface~~randind~~CalledByGraph interface~randind randind proc~fida_weights_mc fida_weights_mc proc~fida_weights_mc->interface~randind proc~mc_fastion mc_fastion proc~mc_fastion->interface~randind proc~ndmc ndmc proc~ndmc->interface~randind program~fidasim fidasim program~fidasim->proc~fida_weights_mc program~fidasim->proc~ndmc proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~fida_f->proc~mc_fastion proc~npa_f->proc~mc_fastion Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures randind_n randind_w_1 randind_w_2 Module Procedures private subroutine randind_n(n, randomi) Generate a array of uniformally-distributed random integers in the range [1, n] Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Largest possible value integer, intent(out), dimension(:) :: randomi Array of uniform deviates private subroutine randind_w_1(w, randomi) Generate an array of random indices of an 1D array distributed according to w Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: w 1D array of index weights integer, intent(out), dimension(:) :: randomi Random indices private subroutine randind_w_2(w, randomi) Generate an array of random subscripts of an 2D array distributed according to w Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:) :: w 2D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts","tags":"","loc":"interface/randind.html","title":"randind – FIDASIM"},{"text":"public interface sparse Creates a sparse array from a dense array Module Procedures sparse_1 sparse_2 sparse_3 sparse_4 Module Procedures private subroutine sparse_1(A, SA) Routine to create a 1D sparse array from a 1D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array private subroutine sparse_2(A, SA) Routine to create a 2D sparse array from a 2D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array private subroutine sparse_3(A, SA) Routine to create a 3D sparse array from a 3D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:,:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array private subroutine sparse_4(A, SA) Routine to create a 4D sparse array from a 4D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:,:,:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array","tags":"","loc":"interface/sparse.html","title":"sparse – FIDASIM"},{"text":"public interface deriv Procedure for finding derivatives from an array Called By interface~~deriv~~CalledByGraph interface~deriv deriv proc~read_equilibrium read_equilibrium proc~read_equilibrium->interface~deriv program~fidasim fidasim program~fidasim->proc~read_equilibrium Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures deriv_1d deriv_2d Module Procedures private subroutine deriv_1d(x, y, yp) Uses 3 point lagrangian method to calculate the derivative of an array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x X Values real(kind=Float64), intent(in), dimension(:) :: y Y Values real(kind=Float64), intent(out), dimension(:) :: yp Derivative of Y w.r.t. X private subroutine deriv_2d(x, y, z, zxp, zyp) Uses 3 point lagrangian method to calculate the partial derivative\n of an array Z w.r.t X and Y Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x X Values real(kind=Float64), intent(in), dimension(:) :: y Y Values real(kind=Float64), intent(in), dimension(:,:) :: z Z Values real(kind=Float64), intent(out), dimension(:,:) :: zxp Derivative of Z w.r.t. X real(kind=Float64), intent(out), dimension(:,:) :: zyp Derivative of Z w.r.t. Y","tags":"","loc":"interface/deriv.html","title":"deriv – FIDASIM"},{"text":"public function p_cx_1_janev(Erel) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=1 state at energy Erel Equation H&#94;+ + H(1) \\rightarrow H(\\forall m) + H&#94;+ References Eq. 44 and Table 9 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_1_janev~~CalledByGraph proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev p_cx_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_n->proc~p_cx_1 proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_2->proc~p_cx_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_janevCalledByGraph = svgPanZoom('#procp_cx_1_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_1_janev Source Code function p_cx_1_janev ( Erel ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=1 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 3.2345d0 , 2.3588d2 , 2.3713d0 , & 3.8371d-2 , 3.8068d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ), parameter :: n = 1.d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_1_janev","tags":"","loc":"proc/p_cx_1_janev.html","title":"p_cx_1_janev – FIDASIM"},{"text":"public function p_cx_2_janev(Erel) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=2 state at energy Erel Equation H&#94;+ + H(2) \\rightarrow H(\\forall m) + H&#94;+ References Eq. 44 and Table 9 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_2_janev~~CalledByGraph proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev p_cx_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_n->proc~p_cx_1 proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_2->proc~p_cx_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_2_janevCalledByGraph = svgPanZoom('#procp_cx_2_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_2_janev Source Code function p_cx_2_janev ( Erel ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 9.2750d-1 , 6.5040d3 , 2.0699d1 , & 1.3405d-2 , 3.0842d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ), parameter :: n = 2.d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_2_janev","tags":"","loc":"proc/p_cx_2_janev.html","title":"p_cx_2_janev – FIDASIM"},{"text":"public function p_cx_3_janev(Erel) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=3 state at energy Erel Equation H&#94;+ + H(3) \\rightarrow H(\\forall m) + H&#94;+ References Eq. 44 and Table 9 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_3_janev~~CalledByGraph proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev p_cx_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_n->proc~p_cx_1 proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_2->proc~p_cx_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_3_janevCalledByGraph = svgPanZoom('#procp_cx_3_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_3_janev Source Code function p_cx_3_janev ( Erel ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 3.7271d-1 , 2.7645d6 , 1.4857d3 , & 1.5720d-3 , 3.0842d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ), parameter :: n = 3.d0 real ( Float64 ) :: Ehat Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_3_janev","tags":"","loc":"proc/p_cx_3_janev.html","title":"p_cx_3_janev – FIDASIM"},{"text":"public function p_cx_n_janev(Erel, n) result(sigma) Calculates cross section for proton-Hydrogen charge exchange interactions from the n \\geq 4 state at energy Erel Equation H&#94;+ + H(n \\geq 4) \\rightarrow H(\\forall m) + H&#94;+ References Eq. 44 and Table 9 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_n_janev~~CalledByGraph proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev p_cx_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_n->proc~p_cx_1 proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_2->proc~p_cx_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_n_janevCalledByGraph = svgPanZoom('#procp_cx_n_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_n_janev Source Code function p_cx_n_janev ( Erel , n ) result ( sigma ) !+Calculates cross section for proton-Hydrogen charge exchange interactions from the n \\geq 4 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n \\geq 4) \\rightarrow H(\\forall m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: a = [ 2.1336d-1 , 1.0000d10 , 1.3426d6 , & 1.8184d-3 , 3.0842d-6 , 1.1832d-10 ] !+ Fitting Parameters from Table 9 in Ref. 2 real ( Float64 ) :: Ehat if ( n . lt . 4 ) then write ( * , '(a)' ) \"P_CX_N_JANEV: n cannot be less than 4\" stop endif Ehat = Erel * n ** 2.0 sigma = ( 1.d-16 * a ( 1 ) * ( n ** 4 )) * log ( a ( 2 ) / Ehat + a ( 3 )) / & ( 1.d0 + a ( 4 ) * Ehat + a ( 5 ) * Ehat ** ( 3.5 ) + a ( 6 ) * Ehat ** ( 5.4 )) end function p_cx_n_janev","tags":"","loc":"proc/p_cx_n_janev.html","title":"p_cx_n_janev – FIDASIM"},{"text":"public function p_cx_janev(Erel, n) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n state at energy Erel Equation H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ References Eq. 44 and Table 9 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~p_cx_janev~~CallsGraph proc~p_cx_janev p_cx_janev proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_cx_janev~~CalledByGraph proc~p_cx_janev p_cx_janev proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_janev proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_janev proc~p_cx_n->proc~p_cx_1 proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_2->proc~p_cx_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_janevCalledByGraph = svgPanZoom('#procp_cx_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_janev Source Code function p_cx_janev ( Erel , n ) result ( sigma ) !+Calculates total cross section for proton-Hydrogen charge exchange interactions from the `n` state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ !+###References !+* Eq. 44 and Table 9 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer :: i i = min ( n , 4 ) select case ( i ) case ( 0 ) stop case ( 1 ) sigma = p_cx_1_janev ( Erel ) case ( 2 ) sigma = p_cx_2_janev ( Erel ) case ( 3 ) sigma = p_cx_3_janev ( Erel ) case DEFAULT sigma = p_cx_n_janev ( Erel , n ) end select end function p_cx_janev","tags":"","loc":"proc/p_cx_janev.html","title":"p_cx_janev – FIDASIM"},{"text":"public function p_cx_1_1_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=1 state at energy Erel Equation H&#94;+ + H(1) \\rightarrow H(1) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_1_1_adas~~CalledByGraph proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_1 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_1 proc~p_cx_n->proc~p_cx_3 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_1_adasCalledByGraph = svgPanZoom('#procp_cx_1_1_adasCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_1_1_adas Source Code function p_cx_1_1_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=1 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(1) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 7 ), parameter :: a = [ - 3.496092687d2 , 4.724931484d2 , & - 2.720493064d2 , 8.158564625d1 , & - 1.339790721d1 , 1.138706949d0 , & - 3.914774156d-2 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 1.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 1.0d3 fac = Erel ** ( - 0.2 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_1_1_adas","tags":"","loc":"proc/p_cx_1_1_adas.html","title":"p_cx_1_1_adas – FIDASIM"},{"text":"public function p_cx_1_2_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=2 state at energy Erel Equation H&#94;+ + H(1) \\rightarrow H(2) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_1_2_adas~~CalledByGraph proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_1 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_1 proc~p_cx_n->proc~p_cx_2 proc~p_cx_n->proc~p_cx_3 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_2_adasCalledByGraph = svgPanZoom('#procp_cx_1_2_adasCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_1_2_adas Source Code function p_cx_1_2_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(2) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 9 ), parameter :: a = [ - 4.036239511d3 , 6.941235312d3 , & - 5.186974866d3 , 2.194885201d3 , & - 5.765960509d2 , 9.653534186d1 , & - 1.008066138d1 , 6.010731909d-1 ,& - 1.567417031d-2 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 1.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 1.0d3 fac = Erel ** ( 0.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_1_2_adas","tags":"","loc":"proc/p_cx_1_2_adas.html","title":"p_cx_1_2_adas – FIDASIM"},{"text":"public function p_cx_1_3_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=3 state at energy Erel Equation H&#94;+ + H(1) \\rightarrow H(3) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_1_3_adas~~CalledByGraph proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_1 proc~p_cx_n->proc~p_cx_3 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_3_adasCalledByGraph = svgPanZoom('#procp_cx_1_3_adasCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_1_3_adas Source Code function p_cx_1_3_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(3) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ 7.037287586d4 , - 1.479161477d5 , & 1.370120708d5 , - 7.343180122d4 , & 2.509832081d4 , - 5.674317075d3 , & 8.487767749d2 , - 8.102284612d1 , & 4.480007503d0 , - 1.093512342d-1 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 2.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 2.0d3 fac = ( Erel ** ( 1.4 )) / 2.8 endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_1_3_adas","tags":"","loc":"proc/p_cx_1_3_adas.html","title":"p_cx_1_3_adas – FIDASIM"},{"text":"public function p_cx_1_4_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=4 state at energy Erel Equation H&#94;+ + H(1) \\rightarrow H(4) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_1_4_adas~~CalledByGraph proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_1 p_cx_1 proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1 proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_3->proc~p_cx_1 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_cx_1_4_adasCalledByGraph = svgPanZoom('#procp_cx_1_4_adasCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_1_4_adas Source Code function p_cx_1_4_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=1 state to the m=4 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(4) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ 6.826447557d4 , - 1.431980004d5 , & 1.323968679d5 , - 7.083995050d4 , & 2.417608863d4 , - 5.458418789d3 , & 8.154875237d2 , - 7.776012846d1 , & 4.295431731d0 , - 1.047567211d-1 ] real ( Float64 ) :: e , ee , fac , l , p e = Erel * 1.d3 if ( e . ge . 2.d3 ) then ee = max ( e , 1.0 ) fac = 1.d0 else ee = 2.0d3 fac = ( Erel ** ( 2.0 )) / 4.0 endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_1_4_adas","tags":"","loc":"proc/p_cx_1_4_adas.html","title":"p_cx_1_4_adas – FIDASIM"},{"text":"public function p_cx_1(Erel, m_max) result(sigma) Calculates an array of cross section for proton-Hydrogen charge exchange interactions\nfrom the n=1 state to m = 1.. m_max states at energy Erel Note Cross sections are normalized to the total cross sections calculated by p_cx_janev Equation H&#94;+ + H(1) \\rightarrow H(m=1..m_{max}) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [cm&#94;2] Calls proc~~p_cx_1~~CallsGraph proc~p_cx_1 p_cx_1 proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_janev p_cx_janev proc~p_cx_1->proc~p_cx_janev proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_cx_1~~CalledByGraph proc~p_cx_1 p_cx_1 proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_1 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_1 proc~p_cx_n->proc~p_cx_3 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_1 Source Code function p_cx_1 ( Erel , m_max ) result ( sigma ) !+Calculates an array of cross section for proton-Hydrogen charge exchange interactions !+from the n=1 state to m = 1..`m_max` states at energy `Erel` !+ !+@note Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]] !+###Equation !+ H&#94;+ + H(1) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] integer :: i real ( Float64 ) :: norm_fac sigma = 0.d0 do i = 1 , m_max select case ( i ) case ( 1 ) sigma ( 1 ) = p_cx_1_1_adas ( Erel ) case ( 2 ) sigma ( 2 ) = p_cx_1_2_adas ( Erel ) case ( 3 ) sigma ( 3 ) = p_cx_1_3_adas ( Erel ) case ( 4 ) sigma ( 4 ) = p_cx_1_4_adas ( Erel ) case DEFAULT sigma ( i ) = 0.d0 end select enddo !Normalize to Janev norm_fac = p_cx_janev ( Erel , 1 ) / sum ( sigma ) sigma = norm_fac * sigma end function p_cx_1","tags":"","loc":"proc/p_cx_1.html","title":"p_cx_1 – FIDASIM"},{"text":"public function p_cx_2_2_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=2 state to the m=2 state at energy Erel Equation H&#94;+ + H(2) \\rightarrow H(2) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_2_2_adas~~CalledByGraph proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_2 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_2_2_adas Source Code function p_cx_2_2_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=2 state to the m=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(2) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a2s = [ - 1.896015167d6 , 4.431727330d6 , & - 4.627815357d6 , 2.843068107d6 , & - 1.137952956d6 , 3.100801094d5 , & - 5.825744660d4 , 7.452319142d3 , & - 6.212350647d2 , 3.047712749d1 , & - 6.682658463d-1 ] real ( Float64 ), dimension ( 11 ), parameter :: a2p = [ - 1.614213508d5 , 3.772469288d5 , & - 3.924736424d5 , 2.393127027d5 , & - 9.470300966d4 , 2.541276100d4 , & - 4.682860453d3 , 5.851219013d2 , & - 4.744504549d1 , 2.254460913d0 , & - 4.767235839d-2 ] real ( Float64 ), parameter :: n = 2.d0 real ( Float64 ) :: e , ee , fac , l , sigma2s , sigma2p e = Erel * 1.d3 * n ** 2.0 if ( Erel . le . 1.5d2 ) then ee = max ( e , 1.d3 ) fac = 1.d0 else ee = 1.5e5 * n ** 2.d0 fac = 2.d15 * (( e * 1.d-3 ) ** ( - 5.5 )) endif l = log10 ( ee ) sigma2s = a2s ( 1 ) + a2s ( 2 ) * l + a2s ( 3 ) * l ** 2.0 + a2s ( 4 ) * l ** 3.0 + & a2s ( 5 ) * l ** 4.0 + a2s ( 6 ) * l ** 5.0 + a2s ( 7 ) * l ** 6.0 + & a2s ( 8 ) * l ** 7.0 + a2s ( 9 ) * l ** 8.0 + a2s ( 10 ) * l ** 9.0 + a2s ( 11 ) * l ** 1 0.0 sigma2s = 1 0.d0 ** ( sigma2s ) sigma2p = a2p ( 1 ) + a2p ( 2 ) * l + a2p ( 3 ) * l ** 2.0 + a2p ( 4 ) * l ** 3.0 + & a2p ( 5 ) * l ** 4.0 + a2p ( 6 ) * l ** 5.0 + a2p ( 7 ) * l ** 6.0 + & a2p ( 8 ) * l ** 7.0 + a2p ( 9 ) * l ** 8.0 + a2p ( 10 ) * l ** 9.0 + a2p ( 11 ) * l ** 1 0.0 sigma2p = 1 0.d0 ** ( sigma2p ) sigma = fac * ( 0.25 * sigma2s + 0.75 * sigma2p ) end function p_cx_2_2_adas","tags":"","loc":"proc/p_cx_2_2_adas.html","title":"p_cx_2_2_adas – FIDASIM"},{"text":"public function p_cx_2_3_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=2 state to the m=3 state at energy Erel Equation H&#94;+ + H(2) \\rightarrow H(3) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_2_3_adas~~CalledByGraph proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_2 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_2_3_adas Source Code function p_cx_2_3_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=2 state to the m=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(3) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a2s = [ - 3.513030327d5 , 9.281116596d5 , & - 1.086843398d6 , 7.437325055d5 , & - 3.296609685d5 , 9.897503768d4 , & - 2.039707143d4 , 2.850670244d3 , & - 2.587092857d2 , 1.377382945d1 , & - 3.268306303d-1 ] real ( Float64 ), dimension ( 11 ), parameter :: a2p = [ - 1.901264631d5 , 5.124716103d5 , & - 6.101921504d5 , 4.234717934d5 , & - 1.899866398d5 , 5.764464326d4 , & - 1.199087959d4 , 1.689900512d3 , & - 1.545334374d2 , 8.285001228d0 , & - 1.978656474d-1 ] real ( Float64 ), parameter :: n = 2.d0 real ( Float64 ) :: ee , l , sigma2s , sigma2p ee = max ( Erel * 1.d3 * n ** 2.d0 , 1.d3 ) l = log10 ( ee ) sigma2s = a2s ( 1 ) + a2s ( 2 ) * l + a2s ( 3 ) * l ** 2.0 + a2s ( 4 ) * l ** 3.0 + & a2s ( 5 ) * l ** 4.0 + a2s ( 6 ) * l ** 5.0 + a2s ( 7 ) * l ** 6.0 + & a2s ( 8 ) * l ** 7.0 + a2s ( 9 ) * l ** 8.0 + a2s ( 10 ) * l ** 9.0 + a2s ( 11 ) * l ** 1 0.0 sigma2s = 1 0.d0 ** ( sigma2s ) sigma2p = a2p ( 1 ) + a2p ( 2 ) * l + a2p ( 3 ) * l ** 2.0 + a2p ( 4 ) * l ** 3.0 + & a2p ( 5 ) * l ** 4.0 + a2p ( 6 ) * l ** 5.0 + a2p ( 7 ) * l ** 6.0 + & a2p ( 8 ) * l ** 7.0 + a2p ( 9 ) * l ** 8.0 + a2p ( 10 ) * l ** 9.0 + a2p ( 11 ) * l ** 1 0.0 sigma2p = 1 0.d0 ** ( sigma2p ) sigma = ( 0.25 * sigma2s + 0.75 * sigma2p ) end function p_cx_2_3_adas","tags":"","loc":"proc/p_cx_2_3_adas.html","title":"p_cx_2_3_adas – FIDASIM"},{"text":"public function p_cx_2(Erel, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n=2 state to m = 1.. m_max states at energy Erel Note Cross sections are normalized to the total cross sections calculated by p_cx_janev . Note Cross sections for the n=2 \\rightarrow m=1 states are calculated via\nequivalence principle using p_cx_1_2_adas . Note Cross Sections for m \\geq 4 are calculated by \"spreading\" their\nexpected total cross sections among the m \\geq 4 states. Equation H&#94;+ + H(2) \\rightarrow H(m=1..m_{max}) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [cm&#94;2] Calls proc~~p_cx_2~~CallsGraph proc~p_cx_2 p_cx_2 proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~m_spread m_spread proc~p_cx_2->proc~m_spread proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_janev p_cx_janev proc~p_cx_2->proc~p_cx_janev proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_cx_2~~CalledByGraph proc~p_cx_2 p_cx_2 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_2 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_2 Source Code function p_cx_2 ( Erel , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen charge exchange interactions !+from the n=2 state to m = 1..`m_max` states at energy `Erel` !+ !+@note !+Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]]. !+ !+@note !+Cross sections for the n=2 \\rightarrow m=1 states are calculated via !+equivalence principle using [[p_cx_1_2_adas(proc)]]. !+ !+@note !+Cross Sections for m \\geq 4 are calculated by \"spreading\" their !+expected total cross sections among the m \\geq 4 states. !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] real ( Float64 ), parameter :: n2 = 4.d0 integer :: i real ( Float64 ) :: En , Em , sigma_n , norm_fac sigma = 0.d0 do i = 1 , min ( m_max , 3 ) select case ( i ) case ( 1 ) sigma ( 1 ) = p_cx_1_2_adas ( Erel * n2 ) / n2 case ( 2 ) sigma ( 2 ) = p_cx_2_2_adas ( Erel ) case ( 3 ) sigma ( 3 ) = p_cx_2_3_adas ( Erel ) end select enddo sigma_n = max ( p_cx_janev ( Erel , 2 ) - sum ( sigma ), 0.d0 ) call m_spread ( 2 , m_max , sigma_n , sigma ) norm_fac = p_cx_janev ( Erel , 2 ) / sum ( sigma ) sigma = sigma * norm_fac end function p_cx_2","tags":"","loc":"proc/p_cx_2.html","title":"p_cx_2 – FIDASIM"},{"text":"public function p_cx_3_2_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=2 state at energy Erel Equation H&#94;+ + H(3) \\rightarrow H(2) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_3_2_adas~~CalledByGraph proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_3_2_adas Source Code function p_cx_3_2_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=2 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(2) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a = [ - 1.149224555d6 , 2.750368877d6 , & - 2.942222842d6 , 1.852584954d6 , & - 7.603284323d5 , 2.125284465d5 , & - 4.097580431d4 , 5.380901722d3 , & - 4.606297192d2 , 2.321345254d1 , & - 5.230186707d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2.0 fac = 1.d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0.d0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_2_adas","tags":"","loc":"proc/p_cx_3_2_adas.html","title":"p_cx_3_2_adas – FIDASIM"},{"text":"public function p_cx_3_3_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=3 state at energy Erel Equation H&#94;+ + H(3) \\rightarrow H(3) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_3_3_adas~~CalledByGraph proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_3_3_adas Source Code function p_cx_3_3_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=3 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(3) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ - 4.302808608d4 , 9.499298161d4 , & - 9.264698488d4 , 5.236947172d4 , & - 1.890479538d4 , 4.519068626d3 , & - 7.152485009d2 , 7.227063167d1 , & - 4.230036444d0 , 1.092702525d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2 fac = 0.85d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_3_adas","tags":"","loc":"proc/p_cx_3_3_adas.html","title":"p_cx_3_3_adas – FIDASIM"},{"text":"public function p_cx_3_4_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=4 state at energy Erel Equation H&#94;+ + H(3) \\rightarrow H(4) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_3_4_adas~~CalledByGraph proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_3_4_adas Source Code function p_cx_3_4_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=4 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(4) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 9 ), parameter :: a = [ 1.705303425d4 , - 3.316878090d4 , & 2.792556433d4 , - 1.330264490d4 , & 3.921666688d3 , - 7.327555138d2 , & 8.476342861d1 , - 5.551987930d0 , & 1.577120745d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2.0 fac = 0.82d16 * ( Erel * n ** 2.0 ) ** ( - 5.5 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_4_adas","tags":"","loc":"proc/p_cx_3_4_adas.html","title":"p_cx_3_4_adas – FIDASIM"},{"text":"public function p_cx_3_5_adas(Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=5 state at energy Erel Equation H&#94;+ + H(3) \\rightarrow H(5) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_3_5_adas~~CalledByGraph proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_3_5_adas Source Code function p_cx_3_5_adas ( Erel ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to the m=5 state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(5) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a = [ - 2.786268232d2 , 4.269683825d4 , & - 8.973561028d4 , 8.365732310d4 , & - 4.524587937d4 , 1.563630402d4 , & - 3.580391824d3 , 5.432527332d2 , & - 5.267599631d1 , 2.962329657d0 , & - 7.362649692d-2 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_5_adas","tags":"","loc":"proc/p_cx_3_5_adas.html","title":"p_cx_3_5_adas – FIDASIM"},{"text":"public function p_cx_3_6inf_adas(Erel) result(sigma) Calculates total cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to \\forall \\; m \\geq 6 states at energy Erel Equation H&#94;+ + H(3) \\rightarrow H(\\forall \\; m \\geq 6) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_cx_3_6inf_adas~~CalledByGraph proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_3_6inf_adas Source Code function p_cx_3_6inf_adas ( Erel ) result ( sigma ) !+Calculates total cross section for a proton-Hydrogen charge exchange interaction !+from the n=3 state to \\forall \\; m \\geq 6 states at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(\\forall \\; m \\geq 6) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: a = [ 7.146969470d5 , - 1.665413326d6 , & 1.735840441d6 , - 1.065792786d6 , & 4.269334710d5 , - 1.165954977d5 , & 2.198700496d4 , - 2.827160468d3 , & 2.372409350d2 , - 1.173264972d1 , & 2.596865877d-1 ] real ( Float64 ), parameter :: n = 3.0 real ( Float64 ) :: ee , fac , l , p if ( Erel . lt . 9 0.0 ) then ee = max ( Erel * 1.d3 * n ** 2.0 , 1.d3 ) !keV to eV fac = 1.d0 else ee = 9 0.0 * 1.d3 * n ** 2.0 fac = 2.d20 * ( Erel * n ** 2.0 ) ** ( - 7.0 ) endif l = log10 ( ee ) p = a ( 1 ) + a ( 2 ) * l + a ( 3 ) * l ** 2.0 + a ( 4 ) * l ** 3.0 + & a ( 5 ) * l ** 4.0 + a ( 6 ) * l ** 5.0 + a ( 7 ) * l ** 6.0 + & a ( 8 ) * l ** 7.0 + a ( 9 ) * l ** 8.0 + a ( 10 ) * l ** 9.0 + a ( 11 ) * l ** 1 0.0 sigma = fac * ( 1 0.d0 ** p ) end function p_cx_3_6inf_adas","tags":"","loc":"proc/p_cx_3_6inf_adas.html","title":"p_cx_3_6inf_adas – FIDASIM"},{"text":"public function p_cx_3(Erel, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n=3 state to m = 1.. m_max states at energy Erel Note Cross sections are normalized to the total cross sections calculated by p_cx_janev . Note Cross sections for the n=3 \\rightarrow m=1 states are calculated via\nequivalence principle using p_cx_1_3_adas . Note Cross Sections for m \\geq 6 are calculated by \"spreading\" their\nexpected total cross sections among the  m \\geq 6 states. Equation H&#94;+ + H(3) \\rightarrow H(m=1..m_{max}) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [cm&#94;2] Calls proc~~p_cx_3~~CallsGraph proc~p_cx_3 p_cx_3 proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_1 p_cx_1 proc~p_cx_3->proc~p_cx_1 proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~m_spread m_spread proc~p_cx_3->proc~m_spread proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_janev p_cx_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1->proc~p_cx_janev proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_cx_3~~CalledByGraph proc~p_cx_3 p_cx_3 proc~p_cx_n p_cx_n proc~p_cx_n->proc~p_cx_3 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_3 Source Code function p_cx_3 ( Erel , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen charge exchange interactions !+from the n=3 state to m = 1..`m_max` states at energy `Erel` !+ !+@note !+Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]]. !+ !+@note !+Cross sections for the n=3 \\rightarrow m=1 states are calculated via !+equivalence principle using [[p_cx_1_3_adas(proc)]]. !+ !+@note !+Cross Sections for m \\geq 6 are calculated by \"spreading\" their !+expected total cross sections among the  m \\geq 6 states. !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] real ( Float64 ), parameter :: n2 = 9.d0 real ( Float64 ) :: eb , En , Em , sigma_m6 , norm_fac real ( Float64 ), dimension ( m_max ) :: sigma1 sigma = 0.d0 sigma1 = 0.d0 sigma1 = p_cx_1 ( Erel * n2 , m_max ) sigma ( 1 ) = p_cx_1_3_adas ( Erel * n2 ) / n2 sigma ( 2 ) = p_cx_3_2_adas ( Erel ) sigma ( 3 ) = p_cx_3_3_adas ( Erel ) sigma ( 4 ) = p_cx_3_4_adas ( Erel ) if ( m_max . ge . 5 ) then sigma ( 5 ) = p_cx_3_5_adas ( Erel ) endif if ( m_max . ge . 6 ) then sigma_m6 = p_cx_3_6inf_adas ( Erel ) call m_spread ( 3 , m_max , sigma_m6 , sigma ) endif norm_fac = p_cx_janev ( Erel , 3 ) / sum ( sigma ) sigma = sigma * norm_fac end function p_cx_3","tags":"","loc":"proc/p_cx_3.html","title":"p_cx_3 – FIDASIM"},{"text":"public function p_cx_n(Erel, n, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n state to m = 1.. m_max states at energy Erel Note Cross sections are normalized to the total cross sections calculated by p_cx_janev . Note Cross sections for some transitions are calculated via the equivalence principle or\nby \"spreading\" their expected total cross sections among the non-filled m states. Equation H&#94;+ + H(n) \\rightarrow H(m=1..m_{max}) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [cm&#94;2] Calls proc~~p_cx_n~~CallsGraph proc~p_cx_n p_cx_n proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_1->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_cx_n~~CalledByGraph proc~p_cx_n p_cx_n proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_n Source Code function p_cx_n ( Erel , n , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen charge exchange interactions !+from the `n` state to m = 1..`m_max` states at energy `Erel` !+ !+@note !+Cross sections are normalized to the total cross sections calculated by !+[[p_cx_janev(proc)]]. !+ !+@note !+Cross sections for some transitions are calculated via the equivalence principle or !+by \"spreading\" their expected total cross sections among the non-filled m states. !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of `m` states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the index refers to the `m`'th state [cm&#94;2] real ( Float64 ), dimension ( m_max ) :: sigma2 , sigma3 real ( Float64 ) :: sigma_n , e , norm_fac sigma = 0.d0 select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_cx_1 ( Erel , m_max ) return case ( 2 ) sigma = p_cx_2 ( Erel , m_max ) return case ( 3 ) sigma = p_cx_3 ( Erel , m_max ) return case ( 4 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 1 ) = p_cx_1_4_adas ( e / ( 1.0 ** 2.0 )) * ( 1.d0 / n ) ** 2.0 sigma ( 2 ) = sigma2 ( 4 ) * ( 2.d0 / n ) ** 2.0 sigma ( 3 ) = p_cx_3_4_adas ( e / ( 3.0 ** 2.0 )) * ( 3.d0 / n ) ** 2.0 case ( 5 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 2 ) = sigma2 ( 5 ) * ( 2.d0 / n ) ** 2.0 sigma ( 3 ) = p_cx_3_5_adas ( e / ( 3.0 ** 2.0 )) * ( 3.d0 / n ) ** 2.0 case ( 6 ) e = Erel * n ** 2.0 sigma2 = p_cx_2 ( e / ( 2.0 ** 2.0 ), m_max ) sigma ( 2 ) = sigma2 ( 6 ) * ( 2.d0 / n ) ** 2.0 sigma3 = p_cx_3 ( e / ( 3.0 ** 2.0 ), m_max ) * ( 3.d0 / n ) ** 2.0 sigma ( 3 ) = sigma3 ( 6 ) case DEFAULT end select sigma_n = max ( p_cx_janev ( Erel , n ) - sum ( sigma ), 0.0 ) call m_spread ( n , m_max , sigma_n , sigma ) norm_fac = p_cx_janev ( Erel , n ) / sum ( sigma ) sigma = norm_fac * sigma end function p_cx_n","tags":"","loc":"proc/p_cx_n.html","title":"p_cx_n – FIDASIM"},{"text":"public function p_cx_n_m(Erel, n, m) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n state to the m state at energy Erel Equation H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~p_cx_n_m~~CallsGraph proc~p_cx_n_m p_cx_n_m proc~p_cx_n p_cx_n proc~p_cx_n_m->proc~p_cx_n proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_1->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx_n_m Source Code function p_cx_n_m ( Erel , n , m ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen charge exchange interaction !+from the `n` state to the `m` state at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer :: m_max = 12 real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = p_cx_n ( Erel , n , m_max ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function p_cx_n_m","tags":"","loc":"proc/p_cx_n_m.html","title":"p_cx_n_m – FIDASIM"},{"text":"public function p_cx(Erel, n_max, m_max) result(sigma) Calculates a matrix of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy Erel Equation H&#94;+ + H(n=1..n_{max}) \\rightarrow H(m=1..m_{max}) + H&#94;+ References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of initial atomic energy levels/states integer, intent(in) :: m_max Number of final atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max,m_max) Matrix of cross sections where the subscripts correspond\n to the n \\rightarrow m transitions: p_cx[n,m] [cm&#94;2] Calls proc~~p_cx~~CallsGraph proc~p_cx p_cx proc~p_cx_n p_cx_n proc~p_cx->proc~p_cx_n proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_1->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_cx~~CalledByGraph proc~p_cx p_cx proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_cx Source Code function p_cx ( Erel , n_max , m_max ) result ( sigma ) !+Calculates a matrix of cross sections for proton-Hydrogen charge exchange interactions !+from the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy `Erel` !+ !+###Equation !+ H&#94;+ + H(n=1..n_{max}) \\rightarrow H(m=1..m_{max}) + H&#94;+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: Erel !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n_max !+ Number of initial atomic energy levels/states integer , intent ( in ) :: m_max !+ Number of final atomic energy levels/states real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts correspond !+ to the n \\rightarrow m transitions: p_cx[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = p_cx_n ( Erel , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function p_cx","tags":"","loc":"proc/p_cx.html","title":"p_cx – FIDASIM"},{"text":"public function p_ioniz_1_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=1 state at energy eb Equation H&#94;+ + H(1) \\rightarrow H&#94;+ + H&#94;+ + e References Eq. 40 and Table 8 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_ioniz_1_janev~~CalledByGraph proc~p_ioniz_1_janev p_ioniz_1_janev proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_1_janev proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_ioniz_1_janev Source Code function p_ioniz_1_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=1 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 40 and Table 8 in Ref. 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 2.0160d-3 , 3.7154d0 , & 3.9890d-2 , 3.1413d-1 , & 2.1254d0 , 6.3990d3 , & 6.1897d1 , 9.2731d3 ] !+ Fitting Parameters from Table 8 in Ref. 2 real ( Float64 ), parameter :: n2 = 1.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_1_janev","tags":"","loc":"proc/p_ioniz_1_janev.html","title":"p_ioniz_1_janev – FIDASIM"},{"text":"public function p_ioniz_2_omullane(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=2 state at energy eb Equation H&#94;+ + H(2) \\rightarrow H&#94;+ + H&#94;+ + e References Eq. 5 and Table 1 in Ref. 3 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_ioniz_2_omullane~~CalledByGraph proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_2_omullane proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_ioniz_2_omullane Source Code function p_ioniz_2_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=2 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 3.9330d-3 , 1.8188d0 , & 1.8870d-2 , 6.7489d-3 , & 1.3768d0 , 6.8852d2 , & 9.6435d1 , 5.6515d23 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 4.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_2_omullane","tags":"","loc":"proc/p_ioniz_2_omullane.html","title":"p_ioniz_2_omullane – FIDASIM"},{"text":"public function p_ioniz_3_omullane(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=3 state at energy eb Equation H&#94;+ + H(3) \\rightarrow H&#94;+ + H&#94;+ + e References Eq. 5 and Table 1 in Ref. 3 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_ioniz_3_omullane~~CalledByGraph proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_ioniz_3_omullane Source Code function p_ioniz_3_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=3 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1076d-2 , 1.6197d0 , & 6.7154d-3 , 5.1188d-3 , & 1.8549d0 , 2.3696d2 , & 7.8286d1 , 1.0926d23 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 9.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_3_omullane","tags":"","loc":"proc/p_ioniz_3_omullane.html","title":"p_ioniz_3_omullane – FIDASIM"},{"text":"public function p_ioniz_4_omullane(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=4 state at energy eb Equation H&#94;+ + H(4) \\rightarrow H&#94;+ + H&#94;+ + e References Eq. 5 and Table 1 in Ref. 3 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_ioniz_4_omullane~~CalledByGraph proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_ioniz_4_omullane Source Code function p_ioniz_4_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(4) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1033d-2 , 1.6281d0 , & 5.5955d-3 , 7.2023d-3 , & 1.7358d0 , 2.2755d2 , & 8.6339d1 , 3.9151d29 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 1 6.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_4_omullane","tags":"","loc":"proc/p_ioniz_4_omullane.html","title":"p_ioniz_4_omullane – FIDASIM"},{"text":"public function p_ioniz_5_omullane(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=5 state at energy eb Equation H&#94;+ + H(5) \\rightarrow H&#94;+ + H&#94;+ + e References Eq. 5 and Table 1 in Ref. 3 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_ioniz_5_omullane~~CalledByGraph proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n p_ioniz_n proc~p_ioniz_n->proc~p_ioniz_5_omullane proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_ioniz_5_omullane Source Code function p_ioniz_5_omullane ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the n=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(5) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 5 and Table 1 in Ref. 3 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.1297d-2 , 1.8685d0 , & 1.5038d-2 , 1.1195d-1 , & 1.0538d0 , 8.6096d2 , & 8.9939d1 , 1.9249d4 ] !+ Fitting Parameters from Table 1 in Ref. 3 real ( Float64 ), parameter :: n2 = 2 5.d0 real ( Float64 ) :: Ehat real ( Float64 ) :: p1 , p2 , p3 Ehat = eb * n2 p1 = b ( 1 ) * ( n2 ) ** 2.0 p2 = Ehat ** b ( 2 ) * exp ( - b ( 3 ) * Ehat ) / ( 1.d0 + b ( 4 ) * Ehat ** b ( 5 )) p3 = ( b ( 6 ) * exp ( - b ( 7 ) / Ehat ) * log ( 1.d0 + b ( 8 ) * Ehat ) ) / Ehat sigma = 1.0d-16 * p1 * ( p2 + p3 ) end function p_ioniz_5_omullane","tags":"","loc":"proc/p_ioniz_5_omullane.html","title":"p_ioniz_5_omullane – FIDASIM"},{"text":"public function p_ioniz_n(eb, n) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n th state at energy eb Equation H&#94;+ + H(n) \\rightarrow H&#94;+ + H&#94;+ + e References Eq. 40 and Table 8 in Ref. 2 for n=1 atomic_tables Eq. 5 and Table 1 in Ref. 3 for n \\geq 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~p_ioniz_n~~CallsGraph proc~p_ioniz_n p_ioniz_n proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n->proc~p_ioniz_5_omullane proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz_1_janev p_ioniz_1_janev proc~p_ioniz_n->proc~p_ioniz_1_janev proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n->proc~p_ioniz_2_omullane Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_ioniz_n~~CalledByGraph proc~p_ioniz_n p_ioniz_n proc~p_ioniz p_ioniz proc~p_ioniz->proc~p_ioniz_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_ioniz_n Source Code function p_ioniz_n ( eb , n ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact ionization interaction !+from the `n`th state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 40 and Table 8 in Ref. 2 for n=1 [[atomic_tables(module)]] !+* Eq. 5 and Table 1 in Ref. 3 for n \\geq 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_ioniz_1_janev ( eb ) case ( 2 ) sigma = p_ioniz_2_omullane ( eb ) case ( 3 ) sigma = p_ioniz_3_omullane ( eb ) case ( 4 ) sigma = p_ioniz_4_omullane ( eb ) case DEFAULT sigma = p_ioniz_5_omullane ( eb ) * ( n / 5.d0 ) ** 4 end select end function p_ioniz_n","tags":"","loc":"proc/p_ioniz_n.html","title":"p_ioniz_n – FIDASIM"},{"text":"public function p_ioniz(eb, n_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen impact ionization interactions\nfrom the n = 1.. n_max state at energy eb Equation H&#94;+ + H(n=1..n_{max}) \\rightarrow H&#94;+ + H&#94;+ + e References Eq. 40 and Table 8 in Ref. 2 for n=1 atomic_tables Eq. 5 and Table 1 in Ref. 3 for n \\geq 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of initial atomic energy level/state Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the index refers to the n 'th state [cm&#94;2] Calls proc~~p_ioniz~~CallsGraph proc~p_ioniz p_ioniz proc~p_ioniz_n p_ioniz_n proc~p_ioniz->proc~p_ioniz_n proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n->proc~p_ioniz_5_omullane proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz_1_janev p_ioniz_1_janev proc~p_ioniz_n->proc~p_ioniz_1_janev proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n->proc~p_ioniz_2_omullane Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_ioniz~~CalledByGraph proc~p_ioniz p_ioniz proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_ioniz Source Code function p_ioniz ( eb , n_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen impact ionization interactions !+from the n = 1..`n_max` state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n=1..n_{max}) \\rightarrow H&#94;+ + H&#94;+ + e !+###References !+* Eq. 40 and Table 8 in Ref. 2 for n=1 [[atomic_tables(module)]] !+* Eq. 5 and Table 1 in Ref. 3 for n \\geq 2 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n_max !+ Number of initial atomic energy level/state real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the index refers to the `n`'th state [cm&#94;2] integer :: i do i = 1 , n_max sigma ( i ) = p_ioniz_n ( eb , i ) enddo end function p_ioniz","tags":"","loc":"proc/p_ioniz.html","title":"p_ioniz – FIDASIM"},{"text":"public function p_excit_1_2_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=2 state at energy eb Equation  H&#94;+ + H(1) \\rightarrow H&#94;+ + H(2)  References Eq. 29.b and Table 4 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_excit_1_2_janev~~CalledByGraph proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_2_janevCalledByGraph = svgPanZoom('#procp_excit_1_2_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_1_2_janev Source Code function p_excit_1_2_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=2 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(2)  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: a = [ 3 4.433d0 , 8.5476d0 , & 7.8501d0 , - 9.2217d0 , & 1.8020d-2 , 1.6931d0 , & 1.9422d-3 , 2.9068d0 , & 4 4.507d0 , 0.56870d0 ] !+ Fitting parameters from Table 4 in Ref. 2 sigma = 1.d-16 * a ( 1 ) * ( a ( 2 ) * exp ( - a ( 3 ) * eb ) / ( eb ** a ( 4 )) + & a ( 5 ) * exp ( - a ( 6 ) / eb ) / ( 1. + a ( 7 ) * eb ** a ( 8 )) + & exp ( - a ( 9 ) / eb ) * log ( 1. + a ( 10 ) * eb ) / eb ) end function p_excit_1_2_janev","tags":"","loc":"proc/p_excit_1_2_janev.html","title":"p_excit_1_2_janev – FIDASIM"},{"text":"public function p_excit_1_3_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=3 state at energy eb Equation  H&#94;+ + H(1) \\rightarrow H&#94;+ + H(3)  References Eq. 30 and Table 5 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_excit_1_3_janev~~CalledByGraph proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_3_janevCalledByGraph = svgPanZoom('#procp_excit_1_3_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_1_3_janev Source Code function p_excit_1_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=3 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(3)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 6.1950d0 , 5.5162d-3 , & 0.29114d0 , - 4.5264d0 , & 6.0311d0 , - 2.0679d0 , & 3 5.773d0 , 0.54818d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_3_janev","tags":"","loc":"proc/p_excit_1_3_janev.html","title":"p_excit_1_3_janev – FIDASIM"},{"text":"public function p_excit_1_4_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=4 state at energy eb Equation  H&#94;+ + H(1) \\rightarrow H&#94;+ + H(4)  References Eq. 30 and Table 5 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_excit_1_4_janev~~CalledByGraph proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_4_janevCalledByGraph = svgPanZoom('#procp_excit_1_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_1_4_janev Source Code function p_excit_1_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(4)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 2.0661d0 , 5.1335d-4 , & 0.28953d0 , - 2.2849d0 , & 0.11528d0 , - 4.8970d0 , & 3 4.975d0 , 0.91213d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_4_janev","tags":"","loc":"proc/p_excit_1_4_janev.html","title":"p_excit_1_4_janev – FIDASIM"},{"text":"public function p_excit_1_5_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=5 state at energy eb Equation  H&#94;+ + H(1) \\rightarrow H&#94;+ + H(5)  References Eq. 30 and Table 5 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_excit_1_5_janev~~CalledByGraph proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_5_janevCalledByGraph = svgPanZoom('#procp_excit_1_5_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_1_5_janev Source Code function p_excit_1_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(5)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 1.2449d0 , 3.0826d-4 , & 0.31063d0 , - 2.4161d0 , & 0.024664d0 , - 6.3726d0 , & 3 2.291d0 , 0.21176d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_5_janev","tags":"","loc":"proc/p_excit_1_5_janev.html","title":"p_excit_1_5_janev – FIDASIM"},{"text":"public function p_excit_1_6_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=6 state at energy eb Equation  H&#94;+ + H(1) \\rightarrow H&#94;+ + H(6)  References Eq. 30 and Table 5 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_excit_1_6_janev~~CalledByGraph proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_1_6_janevCalledByGraph = svgPanZoom('#procp_excit_1_6_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_1_6_janev Source Code function p_excit_1_6_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=1 state to the m=6 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(6)  !+ !+###References !+* Eq. 30 and Table 5 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: b = [ 0.63771d0 , 3.2949d-4 , & 0.25757d0 , - 2.2950d0 , & 0.050796d0 , - 5.5986d0 , & 3 7.174d0 , 0.39265d0 ] !+ Fitting parameters from Table 5 in Ref. 2 sigma = 1.d-16 * b ( 1 ) * ( b ( 2 ) * exp ( - b ( 3 ) * eb ) / & ( eb ** b ( 4 ) + b ( 5 ) * eb ** b ( 6 )) + & exp ( - b ( 7 ) / eb ) * log ( 1. + b ( 8 ) * eb ) / eb ) end function p_excit_1_6_janev","tags":"","loc":"proc/p_excit_1_6_janev.html","title":"p_excit_1_6_janev – FIDASIM"},{"text":"public function p_excit_1_janev(eb, m_max) result(sigma) Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from\nthe n=1 state to the m=1..{m_max} state at energy eb Equation  H&#94;+ + H(1) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 1  References Eq. 29.b and Table 4 in Ref. 2 for m = 2 atomic_tables Eq. 30 and Table 5 in Ref. 2 for m = 3-6 atomic_tables Eq. 31 and Table 5 in Ref. 2 for m \\gt 6 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n=1 to m [cm&#94;2] Calls proc~~p_excit_1_janev~~CallsGraph proc~p_excit_1_janev p_excit_1_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_excit_1_janev~~CalledByGraph proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_1_janev Source Code function p_excit_1_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from !+the n=1 state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(1) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 1  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for m \\gt 6 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from n=1 to m [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = p_excit_1_2_janev ( eb ) case ( 3 ) sigma ( 3 ) = p_excit_1_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = p_excit_1_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_1_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_1_6_janev ( eb ) case DEFAULT sigma ( m ) = p_excit_1_6_janev ( eb ) * ( 6.0 / real ( m )) ** 3.0 end select enddo end function p_excit_1_janev","tags":"","loc":"proc/p_excit_1_janev.html","title":"p_excit_1_janev – FIDASIM"},{"text":"public function p_excit_2_3_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=3 state at energy eb Equation  H&#94;+ + H(2) \\rightarrow H&#94;+ + H(3)  References Eq. 32 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_excit_2_3_janev~~CalledByGraph proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_3_janevCalledByGraph = svgPanZoom('#procp_excit_2_3_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_2_3_janev Source Code function p_excit_2_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=3 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(3)  !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 39 4.51d0 , 0.013597d0 , & 0.16565d0 , - 0.8949d0 , & 2 1.606d0 , 0.62426d0 ] !+ Fitting parameters from Table 6 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_3_janev","tags":"","loc":"proc/p_excit_2_3_janev.html","title":"p_excit_2_3_janev – FIDASIM"},{"text":"public function p_excit_2_4_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=4 state at energy eb Equation  H&#94;+ + H(2) \\rightarrow H&#94;+ + H(4)  References Eq. 32 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_excit_2_4_janev~~CalledByGraph proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_4_janevCalledByGraph = svgPanZoom('#procp_excit_2_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_2_4_janev Source Code function p_excit_2_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(4)  !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 5 0.744d0 , 0.014398d0 , & 0.31584d0 , - 1.4799d0 , & 1 9.416d0 , 4.0262d0 ] !+ Fitting parameters from Table 6 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_4_janev","tags":"","loc":"proc/p_excit_2_4_janev.html","title":"p_excit_2_4_janev – FIDASIM"},{"text":"public function p_excit_2_5_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=5 state at energy eb Equation  H&#94;+ + H(2) \\rightarrow H&#94;+ + H(5)  References Eq. 32 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_excit_2_5_janev~~CalledByGraph proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_5_janevCalledByGraph = svgPanZoom('#procp_excit_2_5_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_2_5_janev Source Code function p_excit_2_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(5)  !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 1 8.264d0 , 0.013701d0 , & 0.31711d0 , - 1.4775d0 , & 1 8.973d0 , 2.9056d0 ] !+ Fitting parameters from Table 6 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_2_5_janev","tags":"","loc":"proc/p_excit_2_5_janev.html","title":"p_excit_2_5_janev – FIDASIM"},{"text":"public function p_excit_2_6_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=6 state at energy eb Equation  H&#94;+ + H(2) \\rightarrow H&#94;+ + H(6)  References Eq. 33 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~p_excit_2_6_janev~~CallsGraph proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_excit_2_6_janev~~CalledByGraph proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_6_janevCalledByGraph = svgPanZoom('#procp_excit_2_6_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_2_6_janev Source Code function p_excit_2_6_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=6 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(6)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 4.61d-1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_6_janev","tags":"","loc":"proc/p_excit_2_6_janev.html","title":"p_excit_2_6_janev – FIDASIM"},{"text":"public function p_excit_2_7_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=7 state at energy eb Equation  H&#94;+ + H(2) \\rightarrow H&#94;+ + H(7)  References Eq. 33 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~p_excit_2_7_janev~~CallsGraph proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_excit_2_7_janev~~CalledByGraph proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_7_janevCalledByGraph = svgPanZoom('#procp_excit_2_7_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_2_7_janev Source Code function p_excit_2_7_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=7 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(7)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 2.475d-1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_7_janev","tags":"","loc":"proc/p_excit_2_7_janev.html","title":"p_excit_2_7_janev – FIDASIM"},{"text":"public function p_excit_2_8_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=8 state at energy eb Equation  H&#94;+ + H(2) \\rightarrow H&#94;+ + H(8)  References Eq. 33 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~p_excit_2_8_janev~~CallsGraph proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_excit_2_8_janev~~CalledByGraph proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_8_janevCalledByGraph = svgPanZoom('#procp_excit_2_8_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_2_8_janev Source Code function p_excit_2_8_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=8 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(8)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.465d-1 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_8_janev","tags":"","loc":"proc/p_excit_2_8_janev.html","title":"p_excit_2_8_janev – FIDASIM"},{"text":"public function p_excit_2_9_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=9 state at energy eb Equation  H&#94;+ + H(2) \\rightarrow H&#94;+ + H(9)  References Eq. 33 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~p_excit_2_9_janev~~CallsGraph proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_excit_2_9_janev~~CalledByGraph proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_9_janevCalledByGraph = svgPanZoom('#procp_excit_2_9_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_2_9_janev Source Code function p_excit_2_9_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=9 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(9)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 9.2d-2 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_9_janev","tags":"","loc":"proc/p_excit_2_9_janev.html","title":"p_excit_2_9_janev – FIDASIM"},{"text":"public function p_excit_2_10_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=10 state at energy eb Equation  H&#94;+ + H(2) \\rightarrow H&#94;+ + H(10)  References Eq. 33 and Table 6 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~p_excit_2_10_janev~~CallsGraph proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_excit_2_10_janev~~CalledByGraph proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_2_10_janevCalledByGraph = svgPanZoom('#procp_excit_2_10_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_2_10_janev Source Code function p_excit_2_10_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=2 state to the m=10 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(10)  !+ !+###References !+* Eq. 33 and Table 6 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 6.05d-2 sigma = A * p_excit_2_5_janev ( eb ) end function p_excit_2_10_janev","tags":"","loc":"proc/p_excit_2_10_janev.html","title":"p_excit_2_10_janev – FIDASIM"},{"text":"public function p_excit_2_janev(eb, m_max) result(sigma) Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from\nthe n=2 state to the m=1..{m_max} state at energy eb Equation  H&#94;+ + H(2) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 2 References Eq. 32 and Table 6 in Ref. 2 for m \\le 5 atomic_tables Eq. 33 and Table 6 in Ref. 2 for m = 6-10 atomic_tables Eq. 34 and Table 6 in Ref. 2 for m \\gt 10 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n=2 to m [cm&#94;2] Calls proc~~p_excit_2_janev~~CallsGraph proc~p_excit_2_janev p_excit_2_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_excit_2_janev~~CalledByGraph proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_2_janev Source Code function p_excit_2_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from !+the n=2 state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(2) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 2 !+ !+###References !+* Eq. 32 and Table 6 in Ref. 2 for m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for m \\gt 10 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from n=2 to m [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = p_excit_2_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = p_excit_2_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_2_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_2_6_janev ( eb ) case ( 7 ) sigma ( 7 ) = p_excit_2_7_janev ( eb ) case ( 8 ) sigma ( 8 ) = p_excit_2_8_janev ( eb ) case ( 9 ) sigma ( 9 ) = p_excit_2_9_janev ( eb ) case ( 10 ) sigma ( 10 ) = p_excit_2_10_janev ( eb ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / real ( m )) ** 3.0 end select enddo end function p_excit_2_janev","tags":"","loc":"proc/p_excit_2_janev.html","title":"p_excit_2_janev – FIDASIM"},{"text":"public function p_excit_3_4_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=4 state at energy eb Equation  H&#94;+ + H(3) \\rightarrow H&#94;+ + H(4)  References Eq. 35 and Table 7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_excit_3_4_janev~~CalledByGraph proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_4_janevCalledByGraph = svgPanZoom('#procp_excit_3_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_3_4_janev Source Code function p_excit_3_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=4 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(4)  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 124 7.5d0 , 0.068781d0 , & 0.521176d0 , - 1.2722d0 , & 1 1.319d0 , 2.6235d0 ] !+ Fitting parameters from Table 7 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_4_janev","tags":"","loc":"proc/p_excit_3_4_janev.html","title":"p_excit_3_4_janev – FIDASIM"},{"text":"public function p_excit_3_5_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=5 state at energy eb Equation  H&#94;+ + H(3) \\rightarrow H&#94;+ + H(5)  References Eq. 35 and Table 7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_excit_3_5_janev~~CalledByGraph proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_5_janevCalledByGraph = svgPanZoom('#procp_excit_3_5_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_3_5_janev Source Code function p_excit_3_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=5 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(5)  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 19 0.59d0 , 0.073307d0 , & 0.54177d0 , - 1.2894d0 , & 1 1.096d0 , 2.9098d0 ] !+ Fitting parameters from Table 7 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_5_janev","tags":"","loc":"proc/p_excit_3_5_janev.html","title":"p_excit_3_5_janev – FIDASIM"},{"text":"public function p_excit_3_6_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=6 state at energy eb Equation  H&#94;+ + H(3) \\rightarrow H&#94;+ + H(6)  References Eq. 35 and Table 7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~p_excit_3_6_janev~~CalledByGraph proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_6_janevCalledByGraph = svgPanZoom('#procp_excit_3_6_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_3_6_janev Source Code function p_excit_3_6_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=6 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(6)  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: c = [ 6 3.494d0 , 0.077953d0 , & 0.53461d0 , - 1.2881d0 , & 1 1.507d0 , 4.3417d0 ] !+ Fitting parameters from Table 7 in Ref. 2 sigma = 1.d-16 * c ( 1 ) * ( c ( 2 ) * exp ( - c ( 3 ) * eb ) / ( eb ** c ( 4 )) + & exp ( - c ( 5 ) / eb ) * log ( 1. + c ( 6 ) * eb ) / eb ) end function p_excit_3_6_janev","tags":"","loc":"proc/p_excit_3_6_janev.html","title":"p_excit_3_6_janev – FIDASIM"},{"text":"public function p_excit_3_7_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=7 state at energy eb Equation  H&#94;+ + H(3) \\rightarrow H&#94;+ + H(7)  References Eq. 36 and Table 7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~p_excit_3_7_janev~~CallsGraph proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_excit_3_7_janev~~CalledByGraph proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_7_janevCalledByGraph = svgPanZoom('#procp_excit_3_7_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_3_7_janev Source Code function p_excit_3_7_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=7 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(7)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 4.67d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_7_janev","tags":"","loc":"proc/p_excit_3_7_janev.html","title":"p_excit_3_7_janev – FIDASIM"},{"text":"public function p_excit_3_8_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=8 state at energy eb Equation  H&#94;+ + H(3) \\rightarrow H&#94;+ + H(8)  References Eq. 36 and Table 7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~p_excit_3_8_janev~~CallsGraph proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_excit_3_8_janev~~CalledByGraph proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_8_janevCalledByGraph = svgPanZoom('#procp_excit_3_8_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_3_8_janev Source Code function p_excit_3_8_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=8 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(8)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 2.545d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_8_janev","tags":"","loc":"proc/p_excit_3_8_janev.html","title":"p_excit_3_8_janev – FIDASIM"},{"text":"public function p_excit_3_9_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=9 state at energy eb Equation  H&#94;+ + H(3) \\rightarrow H&#94;+ + H(9)  References Eq. 36 and Table 7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~p_excit_3_9_janev~~CallsGraph proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_excit_3_9_janev~~CalledByGraph proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_9_janevCalledByGraph = svgPanZoom('#procp_excit_3_9_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_3_9_janev Source Code function p_excit_3_9_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=9 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(9)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.54d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_9_janev","tags":"","loc":"proc/p_excit_3_9_janev.html","title":"p_excit_3_9_janev – FIDASIM"},{"text":"public function p_excit_3_10_janev(eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=10 state at energy eb Equation  H&#94;+ + H(3) \\rightarrow H&#94;+ + H(10)  References Eq. 36 and Table 7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~p_excit_3_10_janev~~CallsGraph proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_excit_3_10_janev~~CalledByGraph proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h var panprocp_excit_3_10_janevCalledByGraph = svgPanZoom('#procp_excit_3_10_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_3_10_janev Source Code function p_excit_3_10_janev ( eb ) result ( sigma ) !+Calculates cross section for a proton-Hydrogen impact excitation transition from !+the n=3 state to the m=10 state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(10)  !+ !+###References !+* Eq. 36 and Table 7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.0d-1 sigma = A * p_excit_3_6_janev ( eb ) end function p_excit_3_10_janev","tags":"","loc":"proc/p_excit_3_10_janev.html","title":"p_excit_3_10_janev – FIDASIM"},{"text":"public function p_excit_3_janev(eb, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen impact excitation transitions from\nthe n=3 state to the m=1..{m_max} state at energy eb Equation  H&#94;+ + H(3) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 3  References Eq. 35 and Table 7 in Ref. 2 for m \\le 6 atomic_tables Eq. 36 and Table 7 in Ref. 2 for m = 7-10 atomic_tables Eq. 37 and Table 7 in Ref. 2 for m \\gt 10 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n=3 to m [cm&#94;2] Calls proc~~p_excit_3_janev~~CallsGraph proc~p_excit_3_janev p_excit_3_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_excit_3_janev~~CalledByGraph proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n p_excit_n proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_3_janev Source Code function p_excit_3_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for proton-Hydrogen impact excitation transitions from !+the n=3 state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(3) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt 3  !+ !+###References !+* Eq. 35 and Table 7 in Ref. 2 for m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for m \\gt 10 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from n=3 to m [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = 0.d0 case ( 4 ) sigma ( 4 ) = p_excit_3_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = p_excit_3_5_janev ( eb ) case ( 6 ) sigma ( 6 ) = p_excit_3_6_janev ( eb ) case ( 7 ) sigma ( 7 ) = p_excit_3_7_janev ( eb ) case ( 8 ) sigma ( 8 ) = p_excit_3_8_janev ( eb ) case ( 9 ) sigma ( 9 ) = p_excit_3_9_janev ( eb ) case ( 10 ) sigma ( 10 ) = p_excit_3_10_janev ( eb ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / real ( m )) ** 3.0 end select enddo end function p_excit_3_janev","tags":"","loc":"proc/p_excit_3_janev.html","title":"p_excit_3_janev – FIDASIM"},{"text":"public function p_excit_n(eb, n, m_max) result(sigma) Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from\nthe n state to the m=1..{m_max} state at energy eb Equation  H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt n  References Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 atomic_tables Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 atomic_tables Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 atomic_tables Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 atomic_tables Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 atomic_tables Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 atomic_tables Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 atomic_tables Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 atomic_tables Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 atomic_tables Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n to m [cm&#94;2] Calls proc~~p_excit_n~~CallsGraph proc~p_excit_n p_excit_n proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_excit_n~~CalledByGraph proc~p_excit_n p_excit_n proc~p_excit_n_m p_excit_n_m proc~p_excit_n_m->proc~p_excit_n proc~p_excit p_excit proc~p_excit->proc~p_excit_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_n Source Code function p_excit_n ( eb , n , m_max ) result ( sigma ) !+Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from !+the `n` state to the m=1..{m_max} state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 [[atomic_tables(module)]] !+* Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refer to the transition !+ from `n` to m [cm&#94;2] integer :: m real ( Float64 ) :: nf , mf , Etil , s , D , A , G , L , F real ( Float64 ) :: y , zpl , zmi , C2pl , C2mi , H sigma = 0.d0 select case ( n ) case ( 0 ) stop case ( 1 ) sigma = p_excit_1_janev ( eb , m_max ) case ( 2 ) sigma = p_excit_2_janev ( eb , m_max ) case ( 3 ) sigma = p_excit_3_janev ( eb , m_max ) case DEFAULT nf = real ( n ) m_loop : do m = 1 , m_max if ( n . ge . m ) then sigma ( m ) = 0.d0 cycle m_loop endif mf = real ( m ) Etil = Eb / 2 5.0 s = ( mf - nf ) D = exp ( - 1.0 / ( nf * mf * Etil ** 2.0 )) A = 8.0 / ( 3.0 * s ) * ( mf / ( s * nf )) ** 3 * ( 0.184 - 0.04 / s ** ( 2.0 / 3.0 )) * & ( 1.0 - 0.2 * s / ( nf * mf )) ** ( 1.0 + 2.0 * s ) G = 0.5 * ( Etil * nf ** 2.0 / ( mf - 1.0 / mf ) ) ** 3. L = log ( 1.0 + 0.53 * Etil ** 2.0 * nf * ( mf - 2.0 / mf ) / ( 1.0 + 0.4 * Etil )) F = ( 1.0 - 0.3 * s * D / ( nf * mf ) ) ** ( 1.0 + 2.0 * s ) y = 1.0 / ( 1.0 - D * log ( 18 * s ) / ( 4.0 * s ) ) zpl = 2.0 / ( Etil * nf ** 2 * ( ( 2.0 - ( nf / mf ) ** 2 ) ** 0.5 + 1.0 )) zmi = 2.0 / ( Etil * nf ** 2 * ( ( 2.0 - ( nf / mf ) ** 2 ) ** 0.5 - 1.0 )) C2pl = zpl ** 2 * log ( 1.0 + 2.0 * zpl / 3.0 ) / ( 2.0 * y + 3.0 * zpl / 2.0 ) C2mi = zmi ** 2 * log ( 1.0 + 2.0 * zmi / 3.0 ) / ( 2.0 * y + 3.0 * zmi / 2.0 ) H = C2mi - C2pl sigma ( m ) = (( 8.8d-17 * n ** 4 ) / Etil ) * ( A * L * D + F * G * H ) enddo m_loop end select end function p_excit_n","tags":"","loc":"proc/p_excit_n.html","title":"p_excit_n – FIDASIM"},{"text":"public function p_excit_n_m(eb, n, m) result(sigma) Calculates the cross section for a proton-Hydrogen impact excitation transition from\nthe n state to the m state at energy eb Equation  H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m), m \\gt n  References Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 atomic_tables Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 atomic_tables Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 atomic_tables Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 atomic_tables Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 atomic_tables Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 atomic_tables Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 atomic_tables Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 atomic_tables Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 atomic_tables Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~p_excit_n_m~~CallsGraph proc~p_excit_n_m p_excit_n_m proc~p_excit_n p_excit_n proc~p_excit_n_m->proc~p_excit_n proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit_n_m Source Code function p_excit_n_m ( eb , n , m ) result ( sigma ) !+Calculates the cross section for a proton-Hydrogen impact excitation transition from !+the `n` state to the `m` state at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m), m \\gt n  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 [[atomic_tables(module)]] !+* Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = p_excit_n ( eb , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function p_excit_n_m","tags":"","loc":"proc/p_excit_n_m.html","title":"p_excit_n_m – FIDASIM"},{"text":"public function p_excit(eb, n_max, m_max) result(sigma) Calculates a matrix of cross sections for a proton-Hydrogen impact excitation transitions\nfrom the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy eb Equation  H&#94;+ + H(n=1..n_{max}) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt n  References Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 atomic_tables Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 atomic_tables Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 atomic_tables Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 atomic_tables Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 atomic_tables Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 atomic_tables Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 atomic_tables Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 atomic_tables Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 atomic_tables Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of final atomic energy levels/states integer, intent(in) :: m_max Number of initial atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max,m_max) Matrix of cross sections where the subscripts correspond\n to the n \\rightarrow m transitions: p_excit[n,m] [cm&#94;2] Calls proc~~p_excit~~CallsGraph proc~p_excit p_excit proc~p_excit_n p_excit_n proc~p_excit->proc~p_excit_n proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~p_excit~~CalledByGraph proc~p_excit p_excit proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code p_excit Source Code function p_excit ( eb , n_max , m_max ) result ( sigma ) !+Calculates a matrix of cross sections for a proton-Hydrogen impact excitation transitions !+from the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy `eb` !+ !+###Equation !+ H&#94;+ + H(n=1..n_{max}) \\rightarrow H&#94;+ + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 29.b and Table 4 in Ref. 2 for n = 1 and m = 2 [[atomic_tables(module)]] !+* Eq. 30 and Table 5 in Ref. 2 for n = 1 and m = 3-6 [[atomic_tables(module)]] !+* Eq. 31 and Table 5 in Ref. 2 for n = 1 and m \\gt 6 [[atomic_tables(module)]] !+* Eq. 32 and Table 6 in Ref. 2 for n = 2 and m \\le 5 [[atomic_tables(module)]] !+* Eq. 33 and Table 6 in Ref. 2 for n = 2 and m = 6-10 [[atomic_tables(module)]] !+* Eq. 34 and Table 6 in Ref. 2 for n = 2 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 35 and Table 7 in Ref. 2 for n = 3 and m \\le 6 [[atomic_tables(module)]] !+* Eq. 36 and Table 7 in Ref. 2 for n = 3 and m = 7-10 [[atomic_tables(module)]] !+* Eq. 37 and Table 7 in Ref. 2 for n = 3 and m \\gt 10 [[atomic_tables(module)]] !+* Eq. 38-39 in Ref. 2 for n \\gt 3 and m \\gt 4 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of initial atomic energy levels/states integer , intent ( in ) :: n_max !+ Number of final atomic energy levels/states real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts correspond !+ to the n \\rightarrow m transitions: p_excit[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = p_excit_n ( eb , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function p_excit","tags":"","loc":"proc/p_excit.html","title":"p_excit – FIDASIM"},{"text":"public function e_ioniz_1_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n=1 state at energy eb Equation  e + H(1) \\rightarrow e + H&#94;+ + e References Eq. 14 and Table 3 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~e_ioniz_1_janev~~CalledByGraph proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n e_ioniz_n proc~e_ioniz_n->proc~e_ioniz_1_janev proc~e_ioniz e_ioniz proc~e_ioniz->proc~e_ioniz_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_ioniz_1_janev Source Code function e_ioniz_1_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the n=1 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer , parameter :: n = 1 !+ Initial atomic energy level/state real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.18450d0 , - 0.032226d0 , & - 0.034539d0 , 1.4003d0 , & - 2.8115d0 , 2.2986d0 ] !+ Fitting parameters from Table 3 in Ref. 2 real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1.d3 !keV to eV x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1.d-13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) sigma = max ( sigma , 0.d0 ) end function e_ioniz_1_janev","tags":"","loc":"proc/e_ioniz_1_janev.html","title":"e_ioniz_1_janev – FIDASIM"},{"text":"public function e_ioniz_2_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n=2 state at energy eb Equation  e + H(2) \\rightarrow e + H&#94;+ + e References Eq. 14 and Table 3 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~e_ioniz_2_janev~~CalledByGraph proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n e_ioniz_n proc~e_ioniz_n->proc~e_ioniz_2_janev proc~e_ioniz e_ioniz proc~e_ioniz->proc~e_ioniz_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_ioniz_2_janev Source Code function e_ioniz_2_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the n=2 state at energy `eb` !+ !+###Equation !+ e + H(2) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer , parameter :: n = 2 !+ Initial atomic energy level/state real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.14784d0 , 0.0080871d0 , & - 0.062270d0 , 1.9414d0 , & - 2.1980d0 , 0.95894d0 ] !+ Fitting parameters from Table 3 in Ref. 2 real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1.d3 !keV to eV x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1.d-13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) sigma = max ( sigma , 0.d0 ) end function e_ioniz_2_janev","tags":"","loc":"proc/e_ioniz_2_janev.html","title":"e_ioniz_2_janev – FIDASIM"},{"text":"public function e_ioniz_3_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n=3 state at energy eb Equation  e + H(3) \\rightarrow e + H&#94;+ + e References Eq. 14 and Table 3 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~e_ioniz_3_janev~~CalledByGraph proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n e_ioniz_n proc~e_ioniz_n->proc~e_ioniz_3_janev proc~e_ioniz e_ioniz proc~e_ioniz->proc~e_ioniz_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_ioniz_3_janev Source Code function e_ioniz_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the n=3 state at energy `eb` !+ !+###Equation !+ e + H(3) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] integer , parameter :: n = 3 !+ Initial atomic energy level/state real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.058463d0 , - 0.051272d0 , & 0.85310d0 , - 0.57014d0 , & 0.76684d0 , 0.00d0 ] !+ Fitting parameters from Table 3 in Ref. 2 real ( Float64 ) :: Edn2 real ( Float64 ) :: e , x real ( Float64 ) :: s Edn2 = 1 3.6 / real ( n ) ** 2 e = eb * 1.d3 !keV to eV if ( e . ge . 1.5 ) then x = ( 1.0 - Edn2 / e ) s = A ( 2 ) * x + A ( 3 ) * ( x ** 2.0 ) + A ( 4 ) * ( x ** 3.0 ) + A ( 5 ) * ( x ** 4.0 ) + A ( 6 ) * ( x ** 5.0 ) sigma = (( 1.d-13 ) / ( Edn2 * e )) * ( A ( 1 ) * log ( e / Edn2 ) + s ) else sigma = 0.d0 endif end function e_ioniz_3_janev","tags":"","loc":"proc/e_ioniz_3_janev.html","title":"e_ioniz_3_janev – FIDASIM"},{"text":"public function e_ioniz_n(eb, n) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n state at energy eb Equation  e + H(n) \\rightarrow e + H&#94;+ + e References Eq. 14 and Table 3 in Ref. 2 atomic_tables Eq. 15-16 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~e_ioniz_n~~CallsGraph proc~e_ioniz_n e_ioniz_n proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n->proc~e_ioniz_2_janev proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n->proc~e_ioniz_1_janev proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n->proc~e_ioniz_3_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~e_ioniz_n~~CalledByGraph proc~e_ioniz_n e_ioniz_n proc~e_ioniz e_ioniz proc~e_ioniz->proc~e_ioniz_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_ioniz_n Source Code function e_ioniz_n ( eb , n ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact ionization from !+the `n` state at energy `eb` !+ !+###Equation !+ e + H(n) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+* Eq. 15-16 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ) :: rn , xn , Edn2 real ( Float64 ) :: g0 , g1 , g2 , An , b , Bn select case ( n ) case ( 0 ) stop case ( 1 ) sigma = e_ioniz_1_janev ( eb ) case ( 2 ) sigma = e_ioniz_2_janev ( eb ) case ( 3 ) sigma = e_ioniz_3_janev ( eb ) case DEFAULT rn = 1.94 / n ** 1.57 Edn2 = 1 3.6 / n ** 2.0 xn = ( eb * 1.d3 ) / Edn2 g0 = 0.9935 + 0.2328 / n - 0.1296 / n ** 2.0 g1 = - ( 1.0 / n ) * ( 0.6282 - 0.5598 / n + 0.5299 / n ** 2.0 ) g2 = ( 1.0 / n ** 2.0 ) * ( 0.3887 - 1.181 / n + 1.47 / n ** 2.0 ) An = 3 2.0 * n / ( 3.0 * sqrt ( 3.0 ) * PI ) * ( g0 / 3.0 + g1 / 4.0 + g2 / 5.0 ) b = ( 1.0 / n ) * ( 4.0 - 1 8.63 / n + 3 6.24 / n ** 2.0 - 2 8.09 / n ** 3.0 ) Bn = ( 2.0 / 3.0 ) * ( n ** 2.0 ) * ( 5.0 + b ) if ( xn . gt . 1 ) then sigma = 1.76 * n ** 2 / xn * ( 1.0 - exp ( - rn * xn )) * & ( An * log ( xn ) + ( Bn - An * log ( 2.0 * n ** 2 )) * & ( 1.0 - 1.0 / xn ) ** 2 ) * 1.e-16 else sigma = 0.d0 endif end select end function e_ioniz_n","tags":"","loc":"proc/e_ioniz_n.html","title":"e_ioniz_n – FIDASIM"},{"text":"public function e_ioniz(eb, n_max) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact ionization from\nthe n=1..n_{max} states at energy eb Equation  e + H(n=1..n_{max}) \\rightarrow e + H&#94;+ + e References Eq. 14 and Table 3 in Ref. 2 atomic_tables Eq. 15-16 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n_max Number of initial atomic energy levels/states to calculate Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the n'th index refers to a ionization from the n'th state [cm&#94;2] Calls proc~~e_ioniz~~CallsGraph proc~e_ioniz e_ioniz proc~e_ioniz_n e_ioniz_n proc~e_ioniz->proc~e_ioniz_n proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n->proc~e_ioniz_2_janev proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n->proc~e_ioniz_1_janev proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n->proc~e_ioniz_3_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~e_ioniz~~CalledByGraph proc~e_ioniz e_ioniz proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_ioniz Source Code function e_ioniz ( eb , n_max ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact ionization from !+the n=1..n_{max} states at energy `eb` !+ !+###Equation !+ e + H(n=1..n_{max}) \\rightarrow e + H&#94;+ + e !+ !+###References !+* Eq. 14 and Table 3 in Ref. 2 [[atomic_tables(module)]] !+* Eq. 15-16 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n_max !+ Number of initial atomic energy levels/states to calculate real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the n'th index refers to a ionization from the n'th state [cm&#94;2] integer :: i do i = 1 , n_max sigma ( i ) = e_ioniz_n ( eb , i ) enddo end function e_ioniz","tags":"","loc":"proc/e_ioniz.html","title":"e_ioniz – FIDASIM"},{"text":"public function e_excit_1_2_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=2 state at energy eb Equation  e + H(1) \\rightarrow e + H(2)  References Eq. 4 and Table 1 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~e_excit_1_2_janev~~CalledByGraph proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e var panproce_excit_1_2_janevCalledByGraph = svgPanZoom('#proce_excit_1_2_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_excit_1_2_janev Source Code function e_excit_1_2_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=2 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(2)  !+ !+###References !+* Eq. 4 and Table 1 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 0.2d0 real ( Float64 ), parameter :: a = 0.228d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: b = 0.1865d0 !+ Fitting paramter from Table 2 in Ref. 2 real ( Float64 ), parameter :: c = 0.5025d0 !+ Fitting paramter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 6 ), parameter :: An = [ 4.4979d0 , 1.4182d0 , & - 2 0.877d0 , 4 9.735d0 , & - 4 6.249d0 , 1 7.442d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ( ecoll ) / deltaE if (( ecoll . gt . 1 0.2 ). and .( ecoll . le . 1 1.56 )) then sigma = 1.d-16 * ( a + b * ( ecoll - deltaE )) return endif if (( ecoll . ge . 1 1.56 ). and .( ecoll . le . 1 2.23 )) then sigma = 1.d-16 * c return endif if ( ecoll . ge . 1 2.23 ) then s = An ( 2 ) + An ( 3 ) / x + An ( 4 ) / x ** 2.0 + An ( 5 ) / x ** 3.0 + An ( 6 ) / x ** 4.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( An ( 1 ) * log ( x ) + s ) return endif if ( x . le . 1.0 ) then sigma = 0.0 return endif end function e_excit_1_2_janev","tags":"","loc":"proc/e_excit_1_2_janev.html","title":"e_excit_1_2_janev – FIDASIM"},{"text":"public function e_excit_1_3_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=3 state at energy eb Equation  e + H(1) \\rightarrow e + H(3)  References Eq. 5 and Table 2 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~e_excit_1_3_janev~~CalledByGraph proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e var panproce_excit_1_3_janevCalledByGraph = svgPanZoom('#proce_excit_1_3_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_excit_1_3_janev Source Code function e_excit_1_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=3 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(3)  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 2.09d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: alpha = 0.38277d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.75448d0 , 0.42956d0 , & - 0.58288d0 , 1.0693d0 , & 0.d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_1_3_janev","tags":"","loc":"proc/e_excit_1_3_janev.html","title":"e_excit_1_3_janev – FIDASIM"},{"text":"public function e_excit_1_4_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=4 state at energy eb Equation  e + H(1) \\rightarrow e + H(4)  References Eq. 5 and Table 2 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~e_excit_1_4_janev~~CalledByGraph proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e var panproce_excit_1_4_janevCalledByGraph = svgPanZoom('#proce_excit_1_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_excit_1_4_janev Source Code function e_excit_1_4_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=4 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(4)  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 2.75d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: alpha = 0.41844d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.24300d0 , 0.24846d0 , & 0.19701d0 , 0.d0 , & 0.d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_1_4_janev","tags":"","loc":"proc/e_excit_1_4_janev.html","title":"e_excit_1_4_janev – FIDASIM"},{"text":"public function e_excit_1_5_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=5 state at energy eb Equation  e + H(1) \\rightarrow e + H(5)  References Eq. 5 and Table 2 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~e_excit_1_5_janev~~CalledByGraph proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e var panproce_excit_1_5_janevCalledByGraph = svgPanZoom('#proce_excit_1_5_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_excit_1_5_janev Source Code function e_excit_1_5_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=5 state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(5)  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1 3.06d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), parameter :: alpha = 0.45929d0 !+ Fitting parameter from Table 2 in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 0.11508d0 , 0.13092d0 , & 0.23581d0 , 0.d0 , & 0.d0 ] !+ Fitting parameters from Table 2 in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_1_5_janev","tags":"","loc":"proc/e_excit_1_5_janev.html","title":"e_excit_1_5_janev – FIDASIM"},{"text":"public function e_excit_f(n, m) result(fnm) Oscillator strength for a n \\rightarrow m transition due to electron-Hydrogen impact excitation References Eqs. 11-13 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Oscillator strength Called By proc~~e_excit_f~~CalledByGraph proc~e_excit_f e_excit_f proc~e_excit_1_janev e_excit_1_janev proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_f proc~e_excit_n->proc~e_excit_1_janev proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_excit_f Source Code function e_excit_f ( n , m ) result ( fnm ) !+ Oscillator strength for a `n`\\rightarrow`m` transition due to electron-Hydrogen impact excitation !+ !+###References !+* Eqs. 11-13 in Ref. 2 [[atomic_tables(module)]] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: fnm !+ Oscillator strength real ( Float64 ), dimension ( 3 ) :: g real ( Float64 ) :: x , nf , mf , gs nf = real ( n ) mf = real ( m ) x = 1.0 - ( nf / mf ) ** 2.0 select case ( n ) case ( 1 ) g = [ 1.133 , - 0.4059 , 0.0714 ] case ( 2 ) g = [ 1.0785 , - 0.2319 , 0.02947 ] case DEFAULT g ( 1 ) = 0.9935 + 0.2328 / nf - 0.1296 / nf ** 2 g ( 2 ) =- 1.0 / nf * ( 0.6282 - 0.5598 / nf + 0.5299 / nf ** 2 ) g ( 3 ) = 1.0 / nf ** 2.0 * ( 0.3887 - 1.1810 / nf + 1.4700 / nf ** 2 ) end select gs = g ( 1 ) + g ( 2 ) / x + g ( 3 ) / x ** 2 fnm = 3 2.0 / ( 3.0 * sqrt ( 3.0 ) * PI ) * nf / mf ** 3 * 1 / x ** 3 * gs end function e_excit_f","tags":"","loc":"proc/e_excit_f.html","title":"e_excit_f – FIDASIM"},{"text":"public function e_excit_1_janev(eb, m_max) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=1..m_{max} state at energy eb Equation  e + H(1) \\rightarrow e + H(m=1..m_{max})  References Eq. 5 and Table 2 in Ref. 2 atomic_tables Eqs. 6-7 in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=1 state to the m'th state [cm&#94;2] Calls proc~~e_excit_1_janev~~CallsGraph proc~e_excit_1_janev e_excit_1_janev proc~e_excit_f e_excit_f proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~e_excit_1_janev~~CalledByGraph proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_1_janev proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_excit_1_janev Source Code function e_excit_1_janev ( eb , m_max ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from !+the n=1 state to the m=1..m_{max} state at energy `eb` !+ !+###Equation !+ e + H(1) \\rightarrow e + H(m=1..m_{max})  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=1 state to the m'th state [cm&#94;2] integer :: m real ( Float64 ) :: x , y , A , B , deltaE do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = e_excit_1_2_janev ( eb ) case ( 3 ) sigma ( 3 ) = e_excit_1_3_janev ( eb ) case ( 4 ) sigma ( 4 ) = e_excit_1_4_janev ( eb ) case ( 5 ) sigma ( 5 ) = e_excit_1_5_janev ( eb ) case DEFAULT y = 1.0 - ( 1.d0 / m ) ** 2.0 deltaE = 1 3.6 * y x = ( eb * 1.d3 ) / deltaE A = 2.0 * e_excit_f ( 1 , m ) / y B = 4.0 / ( m ** 3.0 * y ) * ( 1.0 + 4.0 / ( 3.0 * y ) - 0.603 / y ** 2.0 ) sigma ( m ) = 1.76e-16 / ( y * x ) * ( 1.0 - exp ( - 0.45 * y * x )) * & ( A * ( log ( x ) + 1.0 / ( 2.0 * x )) + ( B - A * log ( 2.0 / y )) * & ( 1.0 - 1.0 / x )) if ( x . le . 1.0 ) sigma ( m ) = 0.d0 end select enddo end function e_excit_1_janev","tags":"","loc":"proc/e_excit_1_janev.html","title":"e_excit_1_janev – FIDASIM"},{"text":"public function e_excit_2_3_janev(eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=2 state to the m=3 state at energy eb Equation  e + H(2) \\rightarrow e + H(3)  References Eq. 5 in Ref. 2 atomic_tables Section 2.1.1 B in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~e_excit_2_3_janev~~CalledByGraph proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n e_excit_n proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_excit_2_3_janev Source Code function e_excit_2_3_janev ( eb ) result ( sigma ) !+Calculates cross section for a electron-Hydrogen impact excitation transition from !+the n=2 state to the m=3 state at energy `eb` !+ !+###Equation !+ e + H(2) \\rightarrow e + H(3)  !+ !+###References !+* Eq. 5 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: sigma0 = 5.984d0 real ( Float64 ), parameter :: deltaE = 1.8888d0 !+ Energy difference between n=1 and n=3: !+ \\Delta E = 13.6\\left (\\frac{1}{2&#94;2} - \\frac{1}{3&#94;2}\\right ) real ( Float64 ), parameter :: alpha = 1.3196d0 !+ Fitting parameter from Section 2.1.1 B in Ref. 2 real ( Float64 ), dimension ( 5 ), parameter :: A = [ 3 8.906d0 , 5.2373d0 , 11 9.25d0 , & - 59 5.39d0 , 81 6.71d0 ] !+ Fitting parameters from Section 2.1.1 B in Ref. 2 real ( Float64 ) :: ecoll , x , s ecoll = eb * 1.d3 x = ecoll / deltaE s = A ( 2 ) + A ( 3 ) / x + A ( 4 ) / x ** 2.0 + A ( 5 ) / x ** 3.0 sigma = 1.d-16 * sigma0 / ( deltaE * x ) * ( 1.0 - 1.0 / x ) ** alpha * ( A ( 1 ) * log ( x ) + s ) if ( x . le . 1.0 ) sigma = 0.d0 end function e_excit_2_3_janev","tags":"","loc":"proc/e_excit_2_3_janev.html","title":"e_excit_2_3_janev – FIDASIM"},{"text":"public function e_excit_n(eb, n, m_max) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from\nthe n state to the m=1..m_{max} state at energy eb Equation  e + H(n) \\rightarrow e + H(m=1..m_{max}), m \\gt n  References Eq. 5 and Table 2 in Ref. 2 atomic_tables Eqs. 6-7 in Ref. 2 atomic_tables Section 2.1.1 B in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n \\rightarrow m state [cm&#94;2] Calls proc~~e_excit_n~~CallsGraph proc~e_excit_n e_excit_n proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~e_excit_n~~CalledByGraph proc~e_excit_n e_excit_n proc~e_excit e_excit proc~e_excit->proc~e_excit_n proc~e_excit_n_m e_excit_n_m proc~e_excit_n_m->proc~e_excit_n proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_excit_n Source Code function e_excit_n ( eb , n , m_max ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from !+the `n` state to the m=1..m_{max} state at energy `eb` !+ !+###Equation !+ e + H(n) \\rightarrow e + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the `n`\\rightarrow`m` state [cm&#94;2] integer :: m real ( Float64 ) :: nf , mf real ( Float64 ) :: x , y , A , B , bn , r , deltaE nf = real ( n ) if ( n . eq . 1 ) then sigma = e_excit_1_janev ( eb , m_max ) else m_loop : do m = 1 , m_max mf = real ( m ) if ( n . ge . m ) then sigma ( m ) = 0.d0 cycle m_loop endif if (( n . eq . 2 ). and .( m . eq . 3 )) then sigma ( m ) = e_excit_2_3_janev ( eb ) else deltaE = 1 3.6 * ( 1.0 / nf ** 2 - 1.0 / mf ** 2 ) x = ( eb * 1.d3 ) / deltaE y = 1.0 - ( nf / mf ) ** 2 r = 1.94 / nf ** 1.57 A = 2.0 * nf ** 2 * e_excit_f ( n , m ) / y bn = 1.0 / nf * ( 4.0 - 1 8.63 / nf + 3 6.24 / nf ** 2 - 2 8.09 / nf ** 3 ) B = 4.0 * nf ** 4 / ( mf ** 3 * y ** 2 ) * ( 1.0 + 4.0 / ( 3.0 * y ) + bn / y ** 2.0 ) sigma ( m ) = 1.76e-16 * nf ** 2 / ( y * x ) * ( 1.0 - exp ( - r * y * x )) * & ( A * ( log ( x ) + 1.0 / ( 2.0 * x )) + ( B - A * log ( 2.0 * n ** 2.0 / y )) * & ( 1.0 - 1.0 / x )) if ( x . le . 1.0 ) sigma ( m ) = 0.d0 endif enddo m_loop endif end function e_excit_n","tags":"","loc":"proc/e_excit_n.html","title":"e_excit_n – FIDASIM"},{"text":"public function e_excit_n_m(eb, n, m) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from\nthe n \\rightarrow m state at energy eb Equation  e + H(n) \\rightarrow e + H(m), m \\gt n  References Eq. 5 and Table 2 in Ref. 2 atomic_tables Eqs. 6-7 in Ref. 2 atomic_tables Section 2.1.1 B in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~e_excit_n_m~~CallsGraph proc~e_excit_n_m e_excit_n_m proc~e_excit_n e_excit_n proc~e_excit_n_m->proc~e_excit_n proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_excit_n_m Source Code function e_excit_n_m ( eb , n , m ) result ( sigma ) !+Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from !+the `n` \\rightarrow `m` state at energy `eb` !+ !+###Equation !+ e + H(n) \\rightarrow e + H(m), m \\gt n  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = e_excit_n ( eb , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function e_excit_n_m","tags":"","loc":"proc/e_excit_n_m.html","title":"e_excit_n_m – FIDASIM"},{"text":"public function e_excit(eb, n_max, m_max) result(sigma) Calculates a matrix of cross section for a proton-Hydrogen impact excitation transition\nfrom the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy eb Equation  e + H(n=1..n_{max}) \\rightarrow e + H(m=1..m_{max}), m \\gt n  References Eq. 5 and Table 2 in Ref. 2 atomic_tables Eqs. 6-7 in Ref. 2 atomic_tables Section 2.1.1 B in Ref. 2 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of final atomic energy levels/states integer, intent(in) :: m_max Number of initial atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max,m_max) Matrix of cross sections where the subscripts correspond\n to the n \\rightarrow m transitions: e_excit[n,m] [cm&#94;2] Calls proc~~e_excit~~CallsGraph proc~e_excit e_excit proc~e_excit_n e_excit_n proc~e_excit->proc~e_excit_n proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~e_excit~~CalledByGraph proc~e_excit e_excit proc~write_bb_h_e write_bb_H_e proc~write_bb_h_e->proc~e_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code e_excit Source Code function e_excit ( eb , n_max , m_max ) result ( sigma ) !+Calculates a matrix of cross section for a proton-Hydrogen impact excitation transition !+from the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy `eb` !+ !+###Equation !+ e + H(n=1..n_{max}) \\rightarrow e + H(m=1..m_{max}), m \\gt n  !+ !+###References !+* Eq. 5 and Table 2 in Ref. 2 [[atomic_tables(module)]] !+* Eqs. 6-7 in Ref. 2 [[atomic_tables(module)]] !+* Section 2.1.1 B in Ref. 2 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: m_max !+ Number of initial atomic energy levels/states integer , intent ( in ) :: n_max !+ Number of final atomic energy levels/states real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts correspond !+ to the n \\rightarrow m transitions: e_excit[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n do n = 1 , 12 sigma_full ( n ,:) = e_excit_n ( eb , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function e_excit","tags":"","loc":"proc/e_excit.html","title":"e_excit – FIDASIM"},{"text":"public function B5_cx_1_adas(eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Boron ion at energy eb Equation  B&#94;{5+} + H(1) \\rightarrow B&#94;{4+} + H&#94;+  References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~b5_cx_1_adas~~CalledByGraph proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code B5_cx_1_adas Source Code function B5_cx_1_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(1) \\rightarrow B&#94;{4+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 7 ), parameter :: A = [ 1.174052518d3 , - 1.793561728d3 , & 1.117522436d3 , - 3.679435571d2 , & 6.750816878d1 , - 6.542029074d0 , & 2.614113716d-1 ] real ( Float64 ) :: e , l , p e = max ( eb * 1.d3 , 1 0.0 ) l = log10 ( e ) if ( e . le . 4.d5 ) then p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 sigma = 1 0.d0 ** p else sigma = 0.d0 endif end function B5_cx_1_adas","tags":"","loc":"proc/b5_cx_1_adas.html","title":"B5_cx_1_adas – FIDASIM"},{"text":"public function B5_cx_2_adas(eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=2 state colliding with a fully stripped Boron ion at energy eb Equation  B&#94;{5+} + H(2) \\rightarrow B&#94;{4+} + H&#94;+  References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~b5_cx_2_adas~~CalledByGraph proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code B5_cx_2_adas Source Code function B5_cx_2_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=2 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(2) \\rightarrow B&#94;{4+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 10 ), parameter :: A = [ 6.603246818d1 , - 3.072575676d2 , & 5.030801019d2 , - 4.585636345d2 , & 2.568666393d2 , - 9.185150382d1 , & 2.100012584d1 , - 2.964174788d0 , & 2.346396110d-1 , - 7.943766873d-3 ] real ( Float64 ) :: e , l , p e = max ( eb * 1.d3 , 1 0.0 ) l = log10 ( e ) if ( e . le . 1.d5 ) then p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 sigma = 1 0.d0 ** p else sigma = 0.d0 endif end function B5_cx_2_adas","tags":"","loc":"proc/b5_cx_2_adas.html","title":"B5_cx_2_adas – FIDASIM"},{"text":"public function C6_cx_1_adas(eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Carbon ion at energy eb Equation  C&#94;{6+} + H(1) \\rightarrow C&#94;{5+} + H&#94;+  References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~c6_cx_1_adas~~CalledByGraph proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code C6_cx_1_adas Source Code function C6_cx_1_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(1) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 7 ), parameter :: A = [ 2.007882674d2 , - 3.546893286d2 , & 2.381542403d2 , - 8.355431742d1 , & 1.617519888d1 , - 1.638152470d0 , & 6.768953863d-2 ] real ( Float64 ) :: e , l , p e = max ( eb * 1.d3 , 1.5d3 ) l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 sigma = 1 0.d0 ** p end function C6_cx_1_adas","tags":"","loc":"proc/c6_cx_1_adas.html","title":"C6_cx_1_adas – FIDASIM"},{"text":"public function C6_cx_2_adas(eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=2 state colliding with a fully stripped Carbon ion at energy eb Equation  C&#94;{6+} + H(2) \\rightarrow C&#94;{5+} + H&#94;+  References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~c6_cx_2_adas~~CalledByGraph proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code C6_cx_2_adas Source Code function C6_cx_2_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=2 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(2) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 9.151879441d5 , - 2.134573133d6 , & 2.223792624d6 , - 1.362648703d6 , & 5.438401343d5 , - 1.477110500d5 , & 2.764972254d4 , - 3.522105245d3 , & 2.921934171d2 , - 1.425552507d1 , & 3.106007048d-1 ] real ( Float64 ) :: e , l , p e = max ( eb * 1.d3 , 1.5d3 ) * 2.0 ** 2 l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 + A ( 11 ) * l ** 10 sigma = 1 0.d0 ** p end function C6_cx_2_adas","tags":"","loc":"proc/c6_cx_2_adas.html","title":"C6_cx_2_adas – FIDASIM"},{"text":"public function C6_cx_3_adas(eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=3 state colliding with a fully stripped Carbon ion at energy eb Equation  C&#94;{6+} + H(3) \\rightarrow C&#94;{5+} + H&#94;+  References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~c6_cx_3_adas~~CalledByGraph proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code C6_cx_3_adas Source Code function C6_cx_3_adas ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=3 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(3) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 9.208877916d5 , - 2.147294379d6 , & 2.236451628d6 , - 1.370042347d6 , & 5.466461899d5 , - 1.484338816d5 , & 2.777765778d4 , - 3.537459450d3 , & 2.933884362d2 , - 1.430994136d1 , & 3.117002878d-1 ] real ( Float64 ) :: e , l , p e = max ( eb * 1.d3 , 1.5d3 ) * 3.0 ** 2 l = log10 ( e ) p = A ( 1 ) + A ( 2 ) * l + A ( 3 ) * l ** 2 + A ( 4 ) * l ** 3 + & A ( 5 ) * l ** 4 + A ( 6 ) * l ** 5 + A ( 7 ) * l ** 6 + & A ( 8 ) * l ** 7 + A ( 9 ) * l ** 8 + A ( 10 ) * l ** 9 + A ( 11 ) * l ** 10 sigma = 1 0.d0 ** p end function C6_cx_3_adas","tags":"","loc":"proc/c6_cx_3_adas.html","title":"C6_cx_3_adas – FIDASIM"},{"text":"public function Aq_cx_n_adas(eb, q, n) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Note Returns 0 if ADAS cross sections are not available for given inputs Equation  A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+  References Ref. 4 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~aq_cx_n_adas~~CallsGraph proc~aq_cx_n_adas Aq_cx_n_adas proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_cx_n_adas~~CalledByGraph proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_cx_n_adas Source Code function Aq_cx_n_adas ( eb , q , n ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+@note Returns 0 if ADAS cross sections are not available for given inputs !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] sigma = 0.d0 select case ( q ) case ( 5 ) if ( n . eq . 1 ) sigma = B5_cx_1_adas ( eb ) if ( n . eq . 2 ) sigma = B5_cx_2_adas ( eb ) case ( 6 ) if ( n . eq . 1 ) sigma = C6_cx_1_adas ( eb ) if ( n . eq . 2 ) sigma = C6_cx_2_adas ( eb ) if ( n . eq . 3 ) sigma = C6_cx_3_adas ( eb ) case DEFAULT sigma = 0.d0 end select end function Aq_cx_n_adas","tags":"","loc":"proc/aq_cx_n_adas.html","title":"Aq_cx_n_adas – FIDASIM"},{"text":"public function B5_cx_1_janev(eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Boron ion at energy eb Equation  B&#94;{5+} + H(1) \\rightarrow B&#94;{4+} + H&#94;+  References Page 166 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~b5_cx_1_janev~~CalledByGraph proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_janev proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocb5_cx_1_janevCalledByGraph = svgPanZoom('#procb5_cx_1_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code B5_cx_1_janev Source Code function B5_cx_1_janev ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(1) \\rightarrow B&#94;{4+} + H&#94;+  !+ !+###References !+* Page 166 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 3 1.226d0 , 1.1442d0 , & 4.8372d-8 , 3.0961d-10 , & 4.7205d0 , 6.2844d-7 , & 3.1297d0 , 0.12556d0 , & 0.30098d0 , 5.9607d-2 , & - 0.57923d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ** A ( 8 )) / & ( 1.0 + A ( 3 ) * eb ** 2 + A ( 4 ) * eb ** A ( 5 ) + & A ( 6 ) * eb ** A ( 7 )) + A ( 9 ) * exp ( - A ( 10 ) * eb ) / eb ** A ( 11 )) end function B5_cx_1_janev","tags":"","loc":"proc/b5_cx_1_janev.html","title":"B5_cx_1_janev – FIDASIM"},{"text":"public function C6_cx_1_janev(eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Carbon ion at energy eb Equation  C&#94;{6+} + H(1) \\rightarrow C&#94;{5+} + H&#94;+  References Page 168 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~c6_cx_1_janev~~CalledByGraph proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_janev proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocc6_cx_1_janevCalledByGraph = svgPanZoom('#procc6_cx_1_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code C6_cx_1_janev Source Code function C6_cx_1_janev ( eb ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(1) \\rightarrow C&#94;{5+} + H&#94;+  !+ !+###References !+* Page 168 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 11 ), parameter :: A = [ 41 8.18d0 , 2.1585d0 , & 3.4808d-4 , 5.3333d-9 , & 4.6556d0 , 0.33755d0 , & 0.81736d0 , 0.27874d0 , & 1.8003d-6 , 7.1033d-2 , & 0.53261d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ** A ( 8 )) / & ( 1.0 + A ( 3 ) * eb ** 2 + A ( 4 ) * eb ** A ( 5 ) + & A ( 6 ) * eb ** A ( 7 )) + A ( 9 ) * exp ( - A ( 10 ) * eb ) / eb ** A ( 11 )) end function C6_cx_1_janev","tags":"","loc":"proc/c6_cx_1_janev.html","title":"C6_cx_1_janev – FIDASIM"},{"text":"public function Aq_cx_n_janev(eb, q, n) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Equation  A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  References Page 166 in Ref. 5 atomic_tables Page 168 in Ref. 5 atomic_tables Page 174 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~aq_cx_n_janev~~CallsGraph proc~aq_cx_n_janev Aq_cx_n_janev proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_cx_n_janev~~CalledByGraph proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n Aq_cx_n proc~aq_cx_n->proc~aq_cx_n_janev proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_cx_n_janev Source Code function Aq_cx_n_janev ( eb , q , n ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Page 166 in Ref. 5 [[atomic_tables(module)]] !+* Page 168 in Ref. 5 [[atomic_tables(module)]] !+* Page 174 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 1.507d5 real ( Float64 ), parameter :: B = 1.974d-5 real ( Float64 ) :: etil , nf , qf nf = real ( n ) qf = real ( q ) if (( n . eq . 1 ). and .( q . eq . 5 )) then sigma = B5_cx_1_janev ( eb ) return endif if (( n . eq . 1 ). and .( q . eq . 6 )) then sigma = C6_cx_1_janev ( eb ) return endif if ( n . le . 1 ) then sigma = 0.d0 return endif etil = eb * ( nf ** 2.0 ) / ( qf ** 0.5 ) sigma = qf * nf ** 4 * 7.04d-16 * A / ( etil ** 3.5 * ( 1.0 + B * etil ** 2 )) * & ( 1.0 - exp ( - 2.0 * etil ** 3.5 * ( 1.0 + B * etil ** 2 ) / ( 3.0 * A ))) end function Aq_cx_n_janev","tags":"","loc":"proc/aq_cx_n_janev.html","title":"Aq_cx_n_janev – FIDASIM"},{"text":"public function Aq_cx_n(eb, q, n) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Note Uses ADAS(Ref. 4) cross sections if available else uses Janev (Ref. 5) cross sections Equation  A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  References Ref. 4 atomic_tables Page 166 in Ref. 5 atomic_tables Page 168 in Ref. 5 atomic_tables Page 174 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~aq_cx_n~~CallsGraph proc~aq_cx_n Aq_cx_n proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n->proc~aq_cx_n_janev proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_cx_n~~CalledByGraph proc~aq_cx_n Aq_cx_n proc~aq_cx Aq_cx proc~aq_cx->proc~aq_cx_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_cx_n Source Code function Aq_cx_n ( eb , q , n ) result ( sigma ) !+ Calculates the total charge exchange cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses ADAS(Ref. 4) cross sections if available else uses Janev (Ref. 5) cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] !+* Page 166 in Ref. 5 [[atomic_tables(module)]] !+* Page 168 in Ref. 5 [[atomic_tables(module)]] !+* Page 174 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] sigma = Aq_cx_n_adas ( eb , q , n ) if ( sigma . eq . 0.d0 ) then sigma = Aq_cx_n_janev ( eb , q , n ) endif end function Aq_cx_n","tags":"","loc":"proc/aq_cx_n.html","title":"Aq_cx_n – FIDASIM"},{"text":"public function Aq_cx(eb, q, n_max) result(sigma) Calculates an array of total charge exchange cross sections for a Neutral Hydrogen atom\nin the n=1...n_max states colliding with a ion with charge q at energy eb Note Uses ADAS(Ref. 4) cross sections if available else uses Janev (Ref. 5) cross sections Equation  A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  References Ref. 4 atomic_tables Page 174 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n_max Number of initial atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the n'th index refers to a charge exchange from the n'th state [cm&#94;2] Calls proc~~aq_cx~~CallsGraph proc~aq_cx Aq_cx proc~aq_cx_n Aq_cx_n proc~aq_cx->proc~aq_cx_n proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n->proc~aq_cx_n_janev proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_cx~~CalledByGraph proc~aq_cx Aq_cx proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_cx Source Code function Aq_cx ( eb , q , n_max ) result ( sigma ) !+ Calculates an array of total charge exchange cross sections for a Neutral Hydrogen atom !+in the n=1...n_max states colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses ADAS(Ref. 4) cross sections if available else uses Janev (Ref. 5) cross sections !+ !+###Equation !+ A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Ref. 4 [[atomic_tables(module)]] !+* Page 174 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n_max !+ Number of initial atomic energy levels/states real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the n'th index refers to a charge exchange from the n'th state [cm&#94;2] integer :: n do n = 1 , n_max sigma ( n ) = Aq_cx_n ( eb , q , n ) enddo end function Aq_cx","tags":"","loc":"proc/aq_cx.html","title":"Aq_cx – FIDASIM"},{"text":"public function B5_ioniz_1_janev(eb) result(sigma) Calculates the total ionization cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Boron ion at energy eb Equation  B&#94;{5+} + H(1) \\rightarrow B&#94;{5+} + H&#94;+ + e  References Page 152 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~b5_ioniz_1_janev~~CalledByGraph proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~aq_ioniz Aq_ioniz proc~aq_ioniz->proc~aq_ioniz_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code B5_ioniz_1_janev Source Code function B5_ioniz_1_janev ( eb ) result ( sigma ) !+ Calculates the total ionization cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Boron ion at energy `eb` !+ !+###Equation !+ B&#94;{5+} + H(1) \\rightarrow B&#94;{5+} + H&#94;+ + e  !+ !+###References !+* Page 152 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 8 ), parameter :: A = [ 35 1.52d0 , 23 3.63d0 , & 3.2952d3 , 5.3787d-6 , & 1.8834d-2 , - 2.2064d0 , & 7.2074d0 , - 3.78664d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ) * log ( 1 + A ( 3 ) * eb ) / eb & + A ( 4 ) * exp ( - A ( 5 ) * eb ) / (( eb ** A ( 6 )) + A ( 7 ) * ( eb ** A ( 8 )))) end function B5_ioniz_1_janev","tags":"","loc":"proc/b5_ioniz_1_janev.html","title":"B5_ioniz_1_janev – FIDASIM"},{"text":"public function C6_ioniz_1_janev(eb) result(sigma) Calculates the total ionization cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Carbon ion at energy eb Equation  C&#94;{6+} + H(1) \\rightarrow C&#94;{6+} + H&#94;+ + e  References Page 154 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) Called By proc~~c6_ioniz_1_janev~~CalledByGraph proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz_n->proc~c6_ioniz_1_janev proc~aq_ioniz Aq_ioniz proc~aq_ioniz->proc~aq_ioniz_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code C6_ioniz_1_janev Source Code function C6_ioniz_1_janev ( eb ) result ( sigma ) !+ Calculates the total ionization cross section for a Neutral Hydrogen atom !+in the n=1 state colliding with a fully stripped Carbon ion at energy `eb` !+ !+###Equation !+ C&#94;{6+} + H(1) \\rightarrow C&#94;{6+} + H&#94;+ + e  !+ !+###References !+* Page 154 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb real ( Float64 ) :: sigma real ( Float64 ), dimension ( 8 ), parameter :: A = [ 43 8.36d0 , 32 7.10d0 , & 1.4444d5 , 3.5212d-3 , & 8.3031d-3 , - 0.63731d0 , & 1.9116d4 , - 3.1003d0 ] sigma = 1.d-16 * A ( 1 ) * ( exp ( - A ( 2 ) / eb ) * log ( 1 + A ( 3 ) * eb ) / eb & + A ( 4 ) * exp ( - A ( 5 ) * eb ) / (( eb ** A ( 6 )) + A ( 7 ) * ( eb ** A ( 8 )))) end function C6_ioniz_1_janev","tags":"","loc":"proc/c6_ioniz_1_janev.html","title":"C6_ioniz_1_janev – FIDASIM"},{"text":"public function Aq_ioniz_n_janev(eb, q, n) result(sigma) Calculates the generic total ionization cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Equation  A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H&#94;+ + e, n \\gt 1, q \\gt 3  References Page 160 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~aq_ioniz_n_janev~~CalledByGraph proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz_n->proc~aq_ioniz_n_janev proc~aq_ioniz Aq_ioniz proc~aq_ioniz->proc~aq_ioniz_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_ioniz_n_janev Source Code function Aq_ioniz_n_janev ( eb , q , n ) result ( sigma ) !+ Calculates the generic total ionization cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H&#94;+ + e, n \\gt 1, q \\gt 3  !+ !+###References !+* Page 160 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: M = 0.283d0 real ( Float64 ), parameter :: B = 4.04d0 real ( Float64 ), parameter :: c = 13 7.d0 real ( Float64 ), parameter :: g = 0.662d0 real ( Float64 ), parameter :: lambda = 0.76d0 real ( Float64 ) :: nf , qf , u , v , sigma_b nf = real ( n ) qf = real ( q ) v = sqrt ( eb / 2 5. ) u = nf * v sigma_b = 3.52d-16 * ( nf ** 4 ) * ( qf ** 2 ) / ( u ** 2 ) * & ( M * ( log (( u ** 2 ) / ( c ** 2 - u ** 2 )) - ( u ** 2 ) / ( c ** 2 )) + B - g / u ** 2 ) sigma_b = max ( sigma_b , 0.d0 ) sigma = exp ( - lambda * qf / u ** 2 ) * sigma_b end function Aq_ioniz_n_janev","tags":"","loc":"proc/aq_ioniz_n_janev.html","title":"Aq_ioniz_n_janev – FIDASIM"},{"text":"public function Aq_ioniz_n(eb, q, n) result(sigma) Calculates the total ionization cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Note Uses specialized cross sections if available else uses generic cross sections Equation  A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  References Page 152 in Ref. 5 atomic_tables Page 154 in Ref. 5 atomic_tables Page 160 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~aq_ioniz_n~~CallsGraph proc~aq_ioniz_n Aq_ioniz_n proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n->proc~aq_ioniz_n_janev proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n->proc~c6_ioniz_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_ioniz_n~~CalledByGraph proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz Aq_ioniz proc~aq_ioniz->proc~aq_ioniz_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_ioniz_n Source Code function Aq_ioniz_n ( eb , q , n ) result ( sigma ) !+ Calculates the total ionization cross section for a Neutral Hydrogen atom !+in the `n` state colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Page 152 in Ref. 5 [[atomic_tables(module)]] !+* Page 154 in Ref. 5 [[atomic_tables(module)]] !+* Page 160 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] if (( q . eq . 5 ). and .( n . eq . 1 )) then sigma = B5_ioniz_1_janev ( eb ) return endif if (( q . eq . 6 ). and .( n . eq . 1 )) then sigma = C6_ioniz_1_janev ( eb ) return endif sigma = Aq_ioniz_n_janev ( eb , q , n ) end function Aq_ioniz_n","tags":"","loc":"proc/aq_ioniz_n.html","title":"Aq_ioniz_n – FIDASIM"},{"text":"public function Aq_ioniz(eb, q, n_max) result(sigma) Calculates an array of total ionization cross sections for a Neutral Hydrogen atom\nin the n=1...n_max states colliding with a ion with charge q at energy eb Note Uses specialized cross sections if available else uses generic cross sections Equation  A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  References Page 152 in Ref. 5 atomic_tables Page 154 in Ref. 5 atomic_tables Page 160 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n_max Number of initial states n to calculate Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the n'th index refers to a ionization from the n'th state [cm&#94;2] Calls proc~~aq_ioniz~~CallsGraph proc~aq_ioniz Aq_ioniz proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz->proc~aq_ioniz_n proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n->proc~aq_ioniz_n_janev proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n->proc~c6_ioniz_1_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_ioniz~~CalledByGraph proc~aq_ioniz Aq_ioniz proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_ioniz program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_ioniz Source Code function Aq_ioniz ( eb , q , n_max ) result ( sigma ) !+ Calculates an array of total ionization cross sections for a Neutral Hydrogen atom !+in the n=1...n_max states colliding with a ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{(q-1)+} + H&#94;+, q \\gt 3  !+ !+###References !+* Page 152 in Ref. 5 [[atomic_tables(module)]] !+* Page 154 in Ref. 5 [[atomic_tables(module)]] !+* Page 160 in Ref. 5 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Relative collision energy [keV/amu] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n_max !+ Number of initial states n to calculate real ( Float64 ), dimension ( n_max ) :: sigma !+ Array of cross sections where the n'th index refers to a ionization from the n'th state [cm&#94;2] integer :: n do n = 1 , n_max sigma ( n ) = Aq_ioniz_n ( eb , q , n ) enddo end function Aq_ioniz","tags":"","loc":"proc/aq_ioniz.html","title":"Aq_ioniz – FIDASIM"},{"text":"public function Aq_excit_1_2_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=2 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(2), q \\gt 4  References Page 132 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~aq_excit_1_2_janev~~CalledByGraph proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_1_2_janevCalledByGraph = svgPanZoom('#procaq_excit_1_2_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_1_2_janev Source Code function Aq_excit_1_2_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=2 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(2), q \\gt 4  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 3 8.738d0 , 3 7.033d0 , & 0.39862d0 , 7.7582d-5 , & 0.25402d0 , - 2.7418d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_2_janev","tags":"","loc":"proc/aq_excit_1_2_janev.html","title":"Aq_excit_1_2_janev – FIDASIM"},{"text":"public function Aq_excit_1_3_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=3 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(3), q \\gt 4  References Page 134 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~aq_excit_1_3_janev~~CalledByGraph proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_1_3_janevCalledByGraph = svgPanZoom('#procaq_excit_1_3_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_1_3_janev Source Code function Aq_excit_1_3_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=3 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(3), q \\gt 4  !+ !+###References !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 4.3619d0 , 5 7.451d0 , & 2 1.001d0 , 2.3292d-4 , & 0.083130d0 , - 2.2364d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_3_janev","tags":"","loc":"proc/aq_excit_1_3_janev.html","title":"Aq_excit_1_3_janev – FIDASIM"},{"text":"public function Aq_excit_1_4_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=4 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(4), q \\gt 4  References Page 134 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~aq_excit_1_4_janev~~CalledByGraph proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_1_4_janevCalledByGraph = svgPanZoom('#procaq_excit_1_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_1_4_janev Source Code function Aq_excit_1_4_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=4 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(4), q \\gt 4  !+ !+###References !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 1.3730d0 , 6 0.710d0 , & 3 1.797d0 , 2.0207d-4 , & 0.082513d0 , - 2.3055d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_4_janev","tags":"","loc":"proc/aq_excit_1_4_janev.html","title":"Aq_excit_1_4_janev – FIDASIM"},{"text":"public function Aq_excit_1_5_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=5 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(5), q \\gt 4  References Page 136 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~aq_excit_1_5_janev~~CalledByGraph proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_1_5_janevCalledByGraph = svgPanZoom('#procaq_excit_1_5_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_1_5_janev Source Code function Aq_excit_1_5_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=5 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(5), q \\gt 4  !+ !+###References !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 0.56565d0 , 6 7.333d0 , & 5 5.290d0 , 2.1595d-4 , & 0.081624d0 , - 2.1971d0 ] real ( Float64 ) :: Etil , xsi , qf qf = real ( q ) etil = eb / qf xsi = 2. ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.d-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_1_5_janev","tags":"","loc":"proc/aq_excit_1_5_janev.html","title":"Aq_excit_1_5_janev – FIDASIM"},{"text":"public function Aq_excit_1_janev(eb, q, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4  References Page 132 in Ref. 5 atomic_tables Page 134 in Ref. 5 atomic_tables Page 136 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=1 state to the m'th state [cm&#94;2] Calls proc~~aq_excit_1_janev~~CallsGraph proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_1_janev~~CalledByGraph proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_1_janev Source Code function Aq_excit_1_janev ( eb , q , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=1 state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(1) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=1 state to the m'th state [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = Aq_excit_1_2_janev ( eb , q ) case ( 3 ) sigma ( 3 ) = Aq_excit_1_3_janev ( eb , q ) case ( 4 ) sigma ( 4 ) = Aq_excit_1_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_1_5_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 5 ) * ( 5.0 / m ) ** 3.0 end select enddo end function Aq_excit_1_janev","tags":"","loc":"proc/aq_excit_1_janev.html","title":"Aq_excit_1_janev – FIDASIM"},{"text":"public function Aq_excit_2_3_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=3 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(3), q \\gt 3  References Page 138 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~aq_excit_2_3_janev~~CalledByGraph proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_3_janevCalledByGraph = svgPanZoom('#procaq_excit_2_3_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_2_3_janev Source Code function Aq_excit_2_3_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=3 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(3), q \\gt 3  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 35 8.03d0 , 2 5.283d0 , & 1.4726d0 , 0.014398d0 , & 0.12207d0 , - 0.86210d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_3_janev","tags":"","loc":"proc/aq_excit_2_3_janev.html","title":"Aq_excit_2_3_janev – FIDASIM"},{"text":"public function Aq_excit_2_4_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=4 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(4), q \\gt 3  References Page 138 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~aq_excit_2_4_janev~~CalledByGraph proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_4_janevCalledByGraph = svgPanZoom('#procaq_excit_2_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_2_4_janev Source Code function Aq_excit_2_4_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=4 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(4), q \\gt 3  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 5 0.744d0 , 1 9.416d0 , & 4.0262d0 , 0.014398d0 , & 0.31584d0 , - 1.4799d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_4_janev","tags":"","loc":"proc/aq_excit_2_4_janev.html","title":"Aq_excit_2_4_janev – FIDASIM"},{"text":"public function Aq_excit_2_5_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=5 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(5), q \\gt 3  References Page 138 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~aq_excit_2_5_janev~~CalledByGraph proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_5_janevCalledByGraph = svgPanZoom('#procaq_excit_2_5_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_2_5_janev Source Code function Aq_excit_2_5_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=5 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(5), q \\gt 3  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 1 8.264d0 , 1 8.973d0 , & 2.9056d0 , 0.013701d0 , & 0.31711d0 , - 1.4775d0 ] real ( Float64 ) :: etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.5238 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_2_5_janev","tags":"","loc":"proc/aq_excit_2_5_janev.html","title":"Aq_excit_2_5_janev – FIDASIM"},{"text":"public function Aq_excit_2_6_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=6 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(6), q \\gt 3  References Page 140 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~aq_excit_2_6_janev~~CallsGraph proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_2_6_janev~~CalledByGraph proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_6_janevCalledByGraph = svgPanZoom('#procaq_excit_2_6_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_2_6_janev Source Code function Aq_excit_2_6_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=6 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(6), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.4610d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_6_janev","tags":"","loc":"proc/aq_excit_2_6_janev.html","title":"Aq_excit_2_6_janev – FIDASIM"},{"text":"public function Aq_excit_2_7_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=7 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(7), q \\gt 3  References Page 140 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~aq_excit_2_7_janev~~CallsGraph proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_2_7_janev~~CalledByGraph proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_7_janevCalledByGraph = svgPanZoom('#procaq_excit_2_7_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_2_7_janev Source Code function Aq_excit_2_7_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=7 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(7), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.2475d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_7_janev","tags":"","loc":"proc/aq_excit_2_7_janev.html","title":"Aq_excit_2_7_janev – FIDASIM"},{"text":"public function Aq_excit_2_8_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=8 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(8), q \\gt 3  References Page 140 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~aq_excit_2_8_janev~~CallsGraph proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_2_8_janev~~CalledByGraph proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_8_janevCalledByGraph = svgPanZoom('#procaq_excit_2_8_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_2_8_janev Source Code function Aq_excit_2_8_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=8 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(8), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.1465d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_8_janev","tags":"","loc":"proc/aq_excit_2_8_janev.html","title":"Aq_excit_2_8_janev – FIDASIM"},{"text":"public function Aq_excit_2_9_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=9 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(9), q \\gt 3  References Page 140 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~aq_excit_2_9_janev~~CallsGraph proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_2_9_janev~~CalledByGraph proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_9_janevCalledByGraph = svgPanZoom('#procaq_excit_2_9_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_2_9_janev Source Code function Aq_excit_2_9_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=9 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(9), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.092d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_9_janev","tags":"","loc":"proc/aq_excit_2_9_janev.html","title":"Aq_excit_2_9_janev – FIDASIM"},{"text":"public function Aq_excit_2_10_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=10 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(10), q \\gt 3  References Page 140 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~aq_excit_2_10_janev~~CallsGraph proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_2_10_janev~~CalledByGraph proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_2_10_janevCalledByGraph = svgPanZoom('#procaq_excit_2_10_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_2_10_janev Source Code function Aq_excit_2_10_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=10 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(10), q \\gt 3  !+ !+###References !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.0605d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = A * hi * Aq_excit_2_5_janev ( eb , q ) end function Aq_excit_2_10_janev","tags":"","loc":"proc/aq_excit_2_10_janev.html","title":"Aq_excit_2_10_janev – FIDASIM"},{"text":"public function Aq_excit_2_janev(eb, q, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4, m \\gt n  References Page 138 in Ref. 5 atomic_tables Page 140 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=2 state to the m'th state [cm&#94;2] Calls proc~~aq_excit_2_janev~~CallsGraph proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_2_janev~~CalledByGraph proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_2_janev Source Code function Aq_excit_2_janev ( eb , q , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=2 state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(2) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4, m \\gt n  !+ !+###References !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=2 state to the m'th state [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = Aq_excit_2_3_janev ( eb , q ) case ( 4 ) sigma ( 4 ) = Aq_excit_2_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_2_5_janev ( eb , q ) case ( 6 ) sigma ( 6 ) = Aq_excit_2_6_janev ( eb , q ) case ( 7 ) sigma ( 7 ) = Aq_excit_2_7_janev ( eb , q ) case ( 8 ) sigma ( 8 ) = Aq_excit_2_8_janev ( eb , q ) case ( 9 ) sigma ( 9 ) = Aq_excit_2_9_janev ( eb , q ) case ( 10 ) sigma ( 10 ) = Aq_excit_2_10_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / m ) ** 3.0 end select enddo end function Aq_excit_2_janev","tags":"","loc":"proc/aq_excit_2_janev.html","title":"Aq_excit_2_janev – FIDASIM"},{"text":"public function Aq_excit_3_4_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=4 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(4), q \\gt 3  References Page 142 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~aq_excit_3_4_janev~~CalledByGraph proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_4_janevCalledByGraph = svgPanZoom('#procaq_excit_3_4_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_3_4_janev Source Code function Aq_excit_3_4_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=4 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(4), q \\gt 3  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 124 7.5d0 , 1 1.319d0 , & 2.6235d0 , 0.068781d0 , & 0.521176d0 , - 1.2722d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_4_janev","tags":"","loc":"proc/aq_excit_3_4_janev.html","title":"Aq_excit_3_4_janev – FIDASIM"},{"text":"public function Aq_excit_3_5_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=5 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(5), q \\gt 3  References Page 142 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~aq_excit_3_5_janev~~CalledByGraph proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_5_janevCalledByGraph = svgPanZoom('#procaq_excit_3_5_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_3_5_janev Source Code function Aq_excit_3_5_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=5 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(5), q \\gt 3  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 19 0.59d0 , 1 1.096d0 , & 2.9098d0 , 0.073307d0 , & 0.54177d0 , - 1.2894d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_5_janev","tags":"","loc":"proc/aq_excit_3_5_janev.html","title":"Aq_excit_3_5_janev – FIDASIM"},{"text":"public function Aq_excit_3_6_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=6 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(6), q \\gt 3  References Page 142 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~aq_excit_3_6_janev~~CalledByGraph proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_6_janevCalledByGraph = svgPanZoom('#procaq_excit_3_6_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_3_6_janev Source Code function Aq_excit_3_6_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=6 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(6), q \\gt 3  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 6 ), parameter :: A = [ 6 3.494d0 , 1 1.507d0 , & 4.3417d0 , 0.077953d0 , & 0.53461d0 , - 1.2881d0 ] real ( Float64 ) :: Etil , qf , xsi qf = real ( q ) etil = eb / qf xsi = 2.0 ** ( 0.397 * ( 1 - sqrt ( 2.0 / qf ))) sigma = qf * 1.e-16 * xsi * A ( 1 ) * ( exp ( - A ( 2 ) / etil ) * log ( 1 + A ( 3 ) * etil ) / etil & + A ( 4 ) * exp ( - A ( 5 ) * etil ) / etil ** A ( 6 )) end function Aq_excit_3_6_janev","tags":"","loc":"proc/aq_excit_3_6_janev.html","title":"Aq_excit_3_6_janev – FIDASIM"},{"text":"public function Aq_excit_3_7_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=7 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(7), q \\gt 3  References Page 144 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~aq_excit_3_7_janev~~CallsGraph proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_3_7_janev~~CalledByGraph proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_7_janevCalledByGraph = svgPanZoom('#procaq_excit_3_7_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_3_7_janev Source Code function Aq_excit_3_7_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=7 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(7), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.4670d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_7_janev","tags":"","loc":"proc/aq_excit_3_7_janev.html","title":"Aq_excit_3_7_janev – FIDASIM"},{"text":"public function Aq_excit_3_8_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=8 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(8), q \\gt 3  References Page 144 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~aq_excit_3_8_janev~~CallsGraph proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_3_8_janev~~CalledByGraph proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_8_janevCalledByGraph = svgPanZoom('#procaq_excit_3_8_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_3_8_janev Source Code function Aq_excit_3_8_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=8 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(8), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.2545d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_8_janev","tags":"","loc":"proc/aq_excit_3_8_janev.html","title":"Aq_excit_3_8_janev – FIDASIM"},{"text":"public function Aq_excit_3_9_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=9 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(9), q \\gt 3  References Page 144 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~aq_excit_3_9_janev~~CallsGraph proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_3_9_janev~~CalledByGraph proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_9_janevCalledByGraph = svgPanZoom('#procaq_excit_3_9_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_3_9_janev Source Code function Aq_excit_3_9_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=9 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(9), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.1540d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_9_janev","tags":"","loc":"proc/aq_excit_3_9_janev.html","title":"Aq_excit_3_9_janev – FIDASIM"},{"text":"public function Aq_excit_3_10_janev(eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=10 state due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(10), q \\gt 3  References Page 144 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~aq_excit_3_10_janev~~CallsGraph proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_3_10_janev~~CalledByGraph proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq var panprocaq_excit_3_10_janevCalledByGraph = svgPanZoom('#procaq_excit_3_10_janevCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_3_10_janev Source Code function Aq_excit_3_10_janev ( eb , q ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=10 state due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(10), q \\gt 3  !+ !+###References !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), parameter :: A = 0.1d0 real ( Float64 ) :: hi hi = 2.0 ** ( 0.397 * ( 1.0 - sqrt ( 2.0 / q ))) sigma = hi * A * Aq_excit_3_6_janev ( eb , q ) end function Aq_excit_3_10_janev","tags":"","loc":"proc/aq_excit_3_10_janev.html","title":"Aq_excit_3_10_janev – FIDASIM"},{"text":"public function Aq_excit_3_janev(eb, q, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4, m \\gt n  References Page 142 in Ref. 5 atomic_tables Page 144 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=3 state to the m'th state [cm&#94;2] Calls proc~~aq_excit_3_janev~~CallsGraph proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_3_janev~~CalledByGraph proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_3_janev Source Code function Aq_excit_3_janev ( eb , q , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=3 state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(3) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 4, m \\gt n  !+ !+###References !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the n=3 state to the m'th state [cm&#94;2] integer :: m sigma = 0.d0 do m = 1 , m_max select case ( m ) case ( 1 ) sigma ( 1 ) = 0.d0 case ( 2 ) sigma ( 2 ) = 0.d0 case ( 3 ) sigma ( 3 ) = 0.d0 case ( 4 ) sigma ( 4 ) = Aq_excit_3_4_janev ( eb , q ) case ( 5 ) sigma ( 5 ) = Aq_excit_3_5_janev ( eb , q ) case ( 6 ) sigma ( 6 ) = Aq_excit_3_6_janev ( eb , q ) case ( 7 ) sigma ( 7 ) = Aq_excit_3_7_janev ( eb , q ) case ( 8 ) sigma ( 8 ) = Aq_excit_3_8_janev ( eb , q ) case ( 9 ) sigma ( 9 ) = Aq_excit_3_9_janev ( eb , q ) case ( 10 ) sigma ( 10 ) = Aq_excit_3_10_janev ( eb , q ) case DEFAULT sigma ( m ) = sigma ( 10 ) * ( 1 0.0 / m ) ** 3.0 end select enddo end function Aq_excit_3_janev","tags":"","loc":"proc/aq_excit_3_janev.html","title":"Aq_excit_3_janev – FIDASIM"},{"text":"public function Aq_excit_n_janev(eb, q, n, m_max) result(sigma) Calculates an array of the generic excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Equation  A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n, n \\gt 3  References Page 146 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n state to the m'th state [cm&#94;2] Called By proc~~aq_excit_n_janev~~CalledByGraph proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n Aq_excit_n proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_n_janev Source Code function Aq_excit_n_janev ( eb , q , n , m_max ) result ( sigma ) !+Calculates an array of the generic excitation cross sections for a neutral Hydrogen atom transitioning from !+the `n` state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n, n \\gt 3  !+ !+###References !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the `n` state to the m'th state [cm&#94;2] integer :: m real ( Float64 ) :: nf , mf , qf , etil , hi , s real ( Float64 ) :: D , A , G , L , F , H , y , zpl , zmi , C2pl , C2mi nf = real ( n ) qf = real ( q ) sigma = 0.d0 m_loop : do m = 1 , m_max mf = real ( m ) if ( n . ge . m ) then sigma ( m ) = 0.d0 cycle m_loop endif etil = eb / ( 2 5.0 * qf ) hi = 2.0 ** ( 0.322 * ( 1.0 - sqrt ( 2.0 / qf ))) s = ( mf - nf ) D = exp ( - 1.0 / ( nf * mf * etil ** 2 )) A = 8.0 / ( 3.0 * s ) * ( mf / ( s * nf )) ** 3 * ( 0.184 - 0.04 / s ** ( 2.0 / 3.0 )) * & ( 1.0 - 0.2 * s / ( nf * mf )) ** ( 1.0 + 2.0 * s ) G = 0.5 * ( etil * nf ** 2.0 / ( mf - 1.0 / mf )) ** 3.0 L = log ( 1.0 + 0.53 * etil ** 2.0 * nf * ( mf - 2.0 / mf ) / ( 1.0 + 0.4 * etil )) F = ( 1.0 - 0.3 * s * D / ( nf * mf )) ** ( 1.0 + 2.0 * s ) y = 1.0 / ( 1.0 - D * log ( 18 * s ) / ( 4.0 * s )) zpl = 2.0 / ( etil * nf ** 2 * ( sqrt ( 2.0 - nf ** 2 / mf ** 2 ) + 1.0 )) zmi = 2.0 / ( etil * nf ** 2 * ( sqrt ( 2.0 - nf ** 2 / mf ** 2 ) - 1.0 )) C2pl = zpl ** 2 * log ( 1.0 + 2.0 * zpl / 3.0 ) / ( 2.0 * y + 3.0 * zpl / 2.0 ) C2mi = zmi ** 2 * log ( 1.0 + 2.0 * zmi / 3.0 ) / ( 2.0 * y + 3.0 * zmi / 2.0 ) H = C2mi - C2pl sigma ( m ) = q * hi * 8.86e-17 * nf ** 4 / etil * ( A * D * L + F * G * H ) enddo m_loop end function Aq_excit_n_janev","tags":"","loc":"proc/aq_excit_n_janev.html","title":"Aq_excit_n_janev – FIDASIM"},{"text":"public function Aq_excit_n(eb, q, n, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Note Uses specialized cross sections if available else uses generic cross sections Equation  A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n, n \\gt 3  References Page 132 in Ref. 5 atomic_tables Page 134 in Ref. 5 atomic_tables Page 136 in Ref. 5 atomic_tables Page 138 in Ref. 5 atomic_tables Page 140 in Ref. 5 atomic_tables Page 142 in Ref. 5 atomic_tables Page 142 in Ref. 5 atomic_tables Page 144 in Ref. 5 atomic_tables Page 146 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n state to the m'th state [cm&#94;2] Calls proc~~aq_excit_n~~CallsGraph proc~aq_excit_n Aq_excit_n proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_excit_n~~CalledByGraph proc~aq_excit_n Aq_excit_n proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit Aq_excit proc~aq_excit->proc~aq_excit_n proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_n Source Code function Aq_excit_n ( eb , q , n , m_max ) result ( sigma ) !+Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the `n` state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n, n \\gt 3  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( m_max ) :: sigma !+ Array of cross sections where the m'th index refers to !+an excitation from the `n` state to the m'th state [cm&#94;2] select case ( n ) case ( 0 ) stop case ( 1 ) sigma = Aq_excit_1_janev ( eb , q , m_max ) case ( 2 ) sigma = Aq_excit_2_janev ( eb , q , m_max ) case ( 3 ) sigma = Aq_excit_3_janev ( eb , q , m_max ) case DEFAULT sigma = Aq_excit_n_janev ( eb , q , n , m_max ) end select end function Aq_excit_n","tags":"","loc":"proc/aq_excit_n.html","title":"Aq_excit_n – FIDASIM"},{"text":"public function Aq_excit_n_m(eb, q, n, m) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n \\rightarrow m state due to a collision an ion with charge q at energy eb Note Uses specialized cross sections if available else uses generic cross sections Equation  A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m), q \\gt 3, m \\gt n  References Page 132 in Ref. 5 atomic_tables Page 134 in Ref. 5 atomic_tables Page 136 in Ref. 5 atomic_tables Page 138 in Ref. 5 atomic_tables Page 140 in Ref. 5 atomic_tables Page 142 in Ref. 5 atomic_tables Page 142 in Ref. 5 atomic_tables Page 144 in Ref. 5 atomic_tables Page 146 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] Calls proc~~aq_excit_n_m~~CallsGraph proc~aq_excit_n_m Aq_excit_n_m proc~aq_excit_n Aq_excit_n proc~aq_excit_n_m->proc~aq_excit_n proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit_n_m Source Code function Aq_excit_n_m ( eb , q , n , m ) result ( sigma ) !+Calculates the excitation cross section for a neutral Hydrogen atom transitioning from !+the `n`\\rightarrow`m` state due to a collision an ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n) \\rightarrow A&#94;{q+} + H(m), q \\gt 3, m \\gt n  !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m !+ Final atomic energy level/state real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 12 ) :: sigma_m sigma_m = Aq_excit_n ( eb , q , n , 12 ) if ( m . le . 0 ) then sigma = sum ( sigma_m ) else sigma = sigma_m ( m ) endif end function Aq_excit_n_m","tags":"","loc":"proc/aq_excit_n_m.html","title":"Aq_excit_n_m – FIDASIM"},{"text":"public function Aq_excit(eb, q, n_max, m_max) result(sigma) Calculates an matrix of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=1.. n_max state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Note Uses specialized cross sections if available else uses generic cross sections Equation  A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n References Page 132 in Ref. 5 atomic_tables Page 134 in Ref. 5 atomic_tables Page 136 in Ref. 5 atomic_tables Page 138 in Ref. 5 atomic_tables Page 140 in Ref. 5 atomic_tables Page 142 in Ref. 5 atomic_tables Page 142 in Ref. 5 atomic_tables Page 144 in Ref. 5 atomic_tables Page 146 in Ref. 5 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n_max Number of n states to calculate integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(n_max, m_max) Matrix of cross sections where the subscripts refers to\nan excitation from the n state to the m'th state: Aq_excit[n,m] [cm&#94;2] Calls proc~~aq_excit~~CallsGraph proc~aq_excit Aq_excit proc~aq_excit_n Aq_excit_n proc~aq_excit->proc~aq_excit_n proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~aq_excit~~CalledByGraph proc~aq_excit Aq_excit proc~write_bb_h_aq write_bb_H_Aq proc~write_bb_h_aq->proc~aq_excit program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code Aq_excit Source Code function Aq_excit ( eb , q , n_max , m_max ) result ( sigma ) !+Calculates an matrix of the excitation cross sections for a neutral Hydrogen atom transitioning from !+the n=1..`n_max` state to the m=1..`m_max` states due to a collision an ion with charge `q` at energy `eb` !+ !+@note Uses specialized cross sections if available else uses generic cross sections !+ !+###Equation !+ A&#94;{q+} + H(n=1..n_{max}) \\rightarrow A&#94;{q+} + H(m=1..m_{max}), q \\gt 3, m \\gt n !+ !+###References !+* Page 132 in Ref. 5 [[atomic_tables(module)]] !+* Page 134 in Ref. 5 [[atomic_tables(module)]] !+* Page 136 in Ref. 5 [[atomic_tables(module)]] !+* Page 138 in Ref. 5 [[atomic_tables(module)]] !+* Page 140 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 142 in Ref. 5 [[atomic_tables(module)]] !+* Page 144 in Ref. 5 [[atomic_tables(module)]] !+* Page 146 in Ref. 5 [[atomic_tables(module)]] !+ real ( Float64 ), intent ( in ) :: eb !+ Collision energy [keV] integer , intent ( in ) :: q !+ Ion charge integer , intent ( in ) :: n_max !+ Number of n states to calculate integer , intent ( in ) :: m_max !+ Number of m states to calculate real ( Float64 ), dimension ( n_max , m_max ) :: sigma !+ Matrix of cross sections where the subscripts refers to !+an excitation from the `n` state to the m'th state: Aq_excit[n,m] [cm&#94;2] real ( Float64 ), dimension ( 12 , 12 ) :: sigma_full integer :: n , m do n = 1 , 12 sigma_full ( n ,:) = Aq_excit_n ( eb , q , n , 12 ) enddo sigma = sigma_full ( 1 : n_max , 1 : m_max ) end function Aq_excit","tags":"","loc":"proc/aq_excit.html","title":"Aq_excit – FIDASIM"},{"text":"public function d_d_fusion_t(eb) result(sigma) Calculates total cross section at a given Deuterium energy, eb ,\nfor the Tritium branch of Deuterium-Deutrium nuclear reactions Equation  D + D \\rightarrow T(1.01 MeV) + p(3.02 MeV) (50%) References Equations 8-9 Table IV in Ref. 7 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Deuterium energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~d_d_fusion_t~~CalledByGraph proc~d_d_fusion_t d_d_fusion_t proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->proc~d_d_fusion_t program~generate_tables generate_tables program~generate_tables->proc~write_bb_d_d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code d_d_fusion_t Source Code function d_d_fusion_t ( eb ) result ( sigma ) !+Calculates total cross section at a given Deuterium energy, `eb`, !+for the Tritium branch of Deuterium-Deutrium nuclear reactions !+ !+###Equation !+ D + D \\rightarrow T(1.01 MeV) + p(3.02 MeV) (50%) !+ !+###References !+* Equations 8-9 !+* Table IV in Ref. 7 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Deuterium energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 5 ), parameter :: A = [ 5.5576d4 , 2.1054d2 , & - 3.2638d-2 , 1.4987d-6 , & 1.8181d-10 ] real ( Float64 ), dimension ( 4 ), parameter :: B = [ 0.d0 , 0.d0 , 0.d0 , 0.d0 ] real ( Float64 ), parameter :: Bg = 3 1.3970 real ( Float64 ) :: S , E E = min ( max ( eb , 0.5 ), 500 0.0 ) S = ( A ( 1 ) + E * ( A ( 2 ) + E * ( A ( 3 ) + E * ( A ( 4 ) + E * A ( 5 ))))) / & ( 1 + E * ( B ( 1 ) + E * ( B ( 2 ) + E * ( B ( 3 ) + E * B ( 4 ))))) sigma = ( 1.0d-27 ) * ( S / ( E * exp ( Bg / sqrt ( E )))) end function d_d_fusion_t","tags":"","loc":"proc/d_d_fusion_t.html","title":"d_d_fusion_t – FIDASIM"},{"text":"public function d_d_fusion_he(eb) result(sigma) Calculates total cross section at a given deuterium energy, eb ,\nfor the Helium-3 branch of Deuterium-Deutrium nuclear reactions Equation  D + D \\rightarrow He&#94;3(0.82 MeV) + n(2.45 MeV) (50%) References Equations 8-9 Table IV in Ref. 7 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Deuterium energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~d_d_fusion_he~~CalledByGraph proc~d_d_fusion_he d_d_fusion_he proc~write_bb_d_d write_bb_D_D proc~write_bb_d_d->proc~d_d_fusion_he program~generate_tables generate_tables program~generate_tables->proc~write_bb_d_d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code d_d_fusion_he Source Code function d_d_fusion_he ( eb ) result ( sigma ) !+Calculates total cross section at a given deuterium energy, `eb`, !+for the Helium-3 branch of Deuterium-Deutrium nuclear reactions !+ !+###Equation !+ D + D \\rightarrow He&#94;3(0.82 MeV) + n(2.45 MeV) (50%) !+ !+###References !+* Equations 8-9 !+* Table IV in Ref. 7 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Deuterium energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 5 ), parameter :: A = [ 5.3701d4 , 3.3027d2 , & - 1.2706d-1 , 2.9327d-5 , & - 2.5151d-9 ] real ( Float64 ), dimension ( 4 ), parameter :: B = [ 0.d0 , 0.d0 , 0.d0 , 0.d0 ] real ( Float64 ), parameter :: Bg = 3 1.3970 real ( Float64 ) :: S , E E = min ( max ( eb , 0.5 ), 490 0.0 ) S = ( A ( 1 ) + E * ( A ( 2 ) + E * ( A ( 3 ) + E * ( A ( 4 ) + E * A ( 5 ))))) / & ( 1 + E * ( B ( 1 ) + E * ( B ( 2 ) + E * ( B ( 3 ) + E * B ( 4 ))))) sigma = ( 1.0d-27 ) * ( S / ( E * exp ( Bg / sqrt ( E )))) end function d_d_fusion_he","tags":"","loc":"proc/d_d_fusion_he.html","title":"d_d_fusion_he – FIDASIM"},{"text":"public function d_t_fusion(eb) result(sigma) Calculates total cross section at a given deuterium energy, eb ,\nfor Deuterium-Tritium nuclear reactions in the range [0.5-550 keV] Equation  D + T \\rightarrow He&#94;4(3.5 MeV) + n(14.1 MeV) References Equations 8-9 Table IV, VI in Ref. 7 atomic_tables Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Deuterium energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] Called By proc~~d_t_fusion~~CalledByGraph proc~d_t_fusion d_t_fusion proc~write_bb_d_t write_bb_D_T proc~write_bb_d_t->proc~d_t_fusion Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code d_t_fusion Source Code function d_t_fusion ( eb ) result ( sigma ) !+Calculates total cross section at a given deuterium energy, `eb`, !+for Deuterium-Tritium nuclear reactions in the range [0.5-550 keV] !+ !+###Equation !+ D + T \\rightarrow He&#94;4(3.5 MeV) + n(14.1 MeV) !+ !+###References !+* Equations 8-9 !+* Table IV, VI in Ref. 7 [[atomic_tables(module)]] real ( Float64 ), intent ( in ) :: eb !+ Deuterium energy [keV] real ( Float64 ) :: sigma !+ Cross Section [cm&#94;2] real ( Float64 ), dimension ( 5 ), parameter :: A1 = [ 6.927d4 , 7.454d8 , & 2.050d6 , 5.2002d4 , & 0.d0 ] real ( Float64 ), dimension ( 4 ), parameter :: B1 = [ 6.38d1 , - 9.95d-1 , & 6.981d-5 , 1.728d-4 ] real ( Float64 ), dimension ( 5 ), parameter :: A2 = [ - 1.4714d6 , 0.d0 , & 0.d0 , 0.d0 , 0.d0 ] real ( Float64 ), dimension ( 4 ), parameter :: B2 = [ - 8.4127d-3 , 4.7983d-6 , & - 1.0748d-9 , 8.5184d-14 ] real ( Float64 ), parameter :: Bg = 3 4.3827 real ( Float64 ), dimension ( 5 ) :: A real ( Float64 ), dimension ( 4 ) :: B real ( Float64 ) :: S , E E = min ( max ( eb , 0.5 ), 470 0.0 ) if ( E . le . 53 0.0 ) then A = A1 B = B1 else A = A2 B = B2 endif S = ( A ( 1 ) + E * ( A ( 2 ) + E * ( A ( 3 ) + E * ( A ( 4 ) + E * A ( 5 ))))) / & ( 1 + E * ( B ( 1 ) + E * ( B ( 2 ) + E * ( B ( 3 ) + E * B ( 4 ))))) sigma = ( 1.0d-27 ) * ( S / ( E * exp ( Bg / sqrt ( E )))) end function d_t_fusion","tags":"","loc":"proc/d_t_fusion.html","title":"d_t_fusion – FIDASIM"},{"text":"public function simpsons_rule(f, dx) result(I) Performs 1D integration using Simpsons rule ###References\n* Simpson's rule Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: f Array of equally spaced f(x) values real(kind=Float64), intent(in) :: dx Spacing between x values Return Value real(kind=Float64) Called By proc~~simpsons_rule~~CalledByGraph proc~simpsons_rule simpsons_rule proc~bt_maxwellian_n bt_maxwellian_n proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_n_m bt_maxwellian_n_m proc~bt_maxwellian_n_m->proc~simpsons_rule proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m proc~bt_maxwellian_q_n_m->proc~simpsons_rule proc~bt_maxwellian_eb bt_maxwellian_eb proc~bt_maxwellian_eb->proc~simpsons_rule proc~bt_maxwellian_q_n bt_maxwellian_q_n proc~bt_maxwellian_q_n->proc~simpsons_rule interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m interface~bt_maxwellian->proc~bt_maxwellian_eb interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~bt_maxwellian proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~bt_maxwellian proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~bt_maxwellian proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~bt_maxwellian proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~bt_maxwellian program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code simpsons_rule Source Code function simpsons_rule ( f , dx ) result ( I ) !+ Performs 1D integration using Simpsons rule !+ !+ ###References !+* [Simpson's rule](http://mathworld.wolfram.com/SimpsonsRule.html) real ( Float64 ), dimension (:), intent ( in ) :: f !+ Array of equally spaced f(x) values real ( Float64 ), intent ( in ) :: dx !+ Spacing between x values real ( Float64 ) :: I integer :: s , ii s = size ( f ) I = 0.d0 if ( mod ( s , 2 ). eq . 1 ) then write ( * , '(a)' ) \"Length of array must be even\" return endif I = f ( 1 ) do ii = 2 , s - 1 if ( mod ( ii , 2 ). eq . 1 ) then I = I + 4.0 * f ( ii ) else I = I + 2.0 * f ( ii ) endif enddo I = I + f ( s ) I = ( dx / 3.0 ) * I end function simpsons_rule","tags":"","loc":"proc/simpsons_rule.html","title":"simpsons_rule – FIDASIM"},{"text":"public subroutine m_spread(n, m_max, sigma_tot, sigma) Spreads the total charge exchange cross section, sigma_tot ,\n among the non-filled m states of sigma according to an exponential Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states in sigma real(kind=Float64), intent(in) :: sigma_tot Amount of \"cross section\" to spread about the non-filled m state of sigma real(kind=Float64), intent(inout), dimension(m_max) :: sigma Array of cross sections from the n state to m=1.. m_max [cm&#94;2] Called By proc~~m_spread~~CalledByGraph proc~m_spread m_spread proc~p_cx_3 p_cx_3 proc~p_cx_3->proc~m_spread proc~p_cx_2 p_cx_2 proc~p_cx_2->proc~m_spread proc~p_cx_n p_cx_n proc~p_cx_n->proc~m_spread proc~p_cx_n->proc~p_cx_3 proc~p_cx_n->proc~p_cx_2 proc~p_cx p_cx proc~p_cx->proc~p_cx_n proc~p_cx_n_m p_cx_n_m proc~p_cx_n_m->proc~p_cx_n proc~write_bb_h_h write_bb_H_H proc~write_bb_h_h->proc~p_cx program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code m_spread Source Code subroutine m_spread ( n , m_max , sigma_tot , sigma ) !+ Spreads the total charge exchange cross section, `sigma_tot`, !+ among the non-filled m states of `sigma` according to an exponential integer , intent ( in ) :: n !+ Initial atomic energy level/state integer , intent ( in ) :: m_max !+ Number of m states in `sigma` real ( Float64 ), intent ( in ) :: sigma_tot !+ Amount of \"cross section\" to spread about the non-filled m state of sigma real ( Float64 ), dimension ( m_max ), intent ( inout ) :: sigma !+ Array of cross sections from the `n` state to m=1..`m_max` [cm&#94;2] real ( Float64 ) :: En , Em real ( Float64 ) :: norm_fac real ( Float64 ), dimension ( m_max ) :: sigma_m integer :: m sigma_m = 0.d0 En = 1 3.6 / ( real ( n ) ** 2.0 ) do m = 1 , m_max Em = 1 3.6 / ( real ( m ) ** 2.0 ) if ( sigma ( m ). eq . 0.d0 ) then sigma_m ( m ) = ( sigma_tot / sqrt ( 2.0 * PI )) * exp ( - 0.5 * ( En - Em ) ** 2.0 ) endif enddo norm_fac = sigma_tot / sum ( sigma_m ) do m = 1 , m_max if ( sigma ( m ). eq . 0.d0 ) sigma ( m ) = sigma_m ( m ) * norm_fac if ( sigma ( m ). ne . sigma ( m )) sigma ( m ) = 0.d0 enddo end subroutine m_spread","tags":"","loc":"proc/m_spread.html","title":"m_spread – FIDASIM"},{"text":"public subroutine bt_maxwellian_eb(fn, T, eb, am, ab, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] Calls proc~~bt_maxwellian_eb~~CallsGraph proc~bt_maxwellian_eb bt_maxwellian_eb proc~simpsons_rule simpsons_rule proc~bt_maxwellian_eb->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bt_maxwellian_eb~~CalledByGraph proc~bt_maxwellian_eb bt_maxwellian_eb interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_eb proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~bt_maxwellian proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~bt_maxwellian proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~bt_maxwellian proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~bt_maxwellian proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~bt_maxwellian program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bt_maxwellian_eb Source Code subroutine bt_maxwellian_eb ( fn , T , eb , am , ab , rate ) !+ Calculates Maxwellian reaction rate for a beam with atomic mass `ab` and energy `eb` !+firing into a target with atomic mass `am` and temperature `T` which has a cross section given by the function `fn` interface function fn ( a ) !+Cross section function real ( 8 ) :: fn !sigma real ( 8 ), intent ( in ) :: a !eb end function fn end interface real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] integer :: n_vr real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( 32 ) :: vr real ( Float64 ), dimension ( 32 ) :: fr integer :: n_vz real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( 62 ) :: vz real ( Float64 ), dimension ( 62 ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , v_therm , dE integer :: i , j n_vr = 32 vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo n_vz = 62 vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 sig = fn ( erel ) fr ( j ) = sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm end subroutine bt_maxwellian_eb","tags":"","loc":"proc/bt_maxwellian_eb.html","title":"bt_maxwellian_eb – FIDASIM"},{"text":"public subroutine bt_maxwellian_n(fn, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a, b) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] Calls proc~~bt_maxwellian_n~~CallsGraph proc~bt_maxwellian_n bt_maxwellian_n proc~simpsons_rule simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bt_maxwellian_n~~CalledByGraph proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_n proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~bt_maxwellian proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~bt_maxwellian proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~bt_maxwellian proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~bt_maxwellian proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~bt_maxwellian program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bt_maxwellian_n Source Code subroutine bt_maxwellian_n ( fn , T , eb , am , ab , n , rate ) !+ Calculates Maxwellian reaction rate for a beam with atomic mass `ab`, energy `eb`, and energy level `n` !+firing into a target with atomic mass `am` and temperature `T` which has a cross section given by the function `fn` interface function fn ( a , b ) !+Cross section function real ( 8 ) :: fn !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !n end function fn end interface real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] logical :: dxc integer :: n_vr real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( 32 ) :: vr real ( Float64 ), dimension ( 32 ) :: fr integer :: n_vz real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( 62 ) :: vz real ( Float64 ), dimension ( 62 ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , v_therm , dE integer :: i , j n_vr = 32 vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo n_vz = 62 vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) dE = ( 1 3.6d-3 ) / ( n ** 2.0 ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 !for electron interactions fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( erel . ge . dE ) then sig = fn ( erel / ared , n ) else sig = 0.d0 endif fr ( j ) = sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm end subroutine bt_maxwellian_n","tags":"","loc":"proc/bt_maxwellian_n.html","title":"bt_maxwellian_n – FIDASIM"},{"text":"public subroutine bt_maxwellian_q_n(fqn, q, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqn Arguments Type Intent Optional Attributes Name public function fqn(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] Calls proc~~bt_maxwellian_q_n~~CallsGraph proc~bt_maxwellian_q_n bt_maxwellian_q_n proc~simpsons_rule simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bt_maxwellian_q_n~~CalledByGraph proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~bt_maxwellian proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~bt_maxwellian proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~bt_maxwellian proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~bt_maxwellian proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~bt_maxwellian program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bt_maxwellian_q_n Source Code subroutine bt_maxwellian_q_n ( fqn , q , T , eb , am , ab , n , rate ) !+ Calculates Maxwellian reaction rate for a beam with atomic mass `ab`, energy `eb`, and energy level `n` !+firing into a target with atomic mass `am`, temperature `T`, and charge `q`  which has a cross section given by the function `fqn` interface function fqn ( a , b , c ) !+Cross section function real ( 8 ) :: fqn !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !q integer , intent ( in ) :: c !n end function fqn end interface integer , intent ( in ) :: q !+Target charge real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] integer :: n_vr real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( 32 ) :: vr real ( Float64 ), dimension ( 32 ) :: fr integer :: n_vz real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( 62 ) :: vz real ( Float64 ), dimension ( 62 ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , v_therm , dE integer :: i , j n_vr = 32 vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo n_vz = 62 vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) dE = ( 1 3.6d-3 ) / ( n ** 2.0 ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( erel . ge . dE ) then sig = fqn ( erel / ared , q , n ) else sig = 0.d0 endif fr ( j ) = sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm end subroutine bt_maxwellian_q_n","tags":"","loc":"proc/bt_maxwellian_q_n.html","title":"bt_maxwellian_q_n – FIDASIM"},{"text":"public subroutine bt_maxwellian_n_m(fnm, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fnm Arguments Type Intent Optional Attributes Name public function fnm(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate Calls proc~~bt_maxwellian_n_m~~CallsGraph proc~bt_maxwellian_n_m bt_maxwellian_n_m proc~simpsons_rule simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bt_maxwellian_n_m~~CalledByGraph proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~bt_maxwellian proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~bt_maxwellian proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~bt_maxwellian proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~bt_maxwellian proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~bt_maxwellian program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bt_maxwellian_n_m Source Code subroutine bt_maxwellian_n_m ( fnm , T , eb , am , ab , n , m , rate , deexcit ) !+ Calculates Maxwellian reaction rate for a `n`\\rightarrow)`m` transition due to a beam with atomic mass `ab` and energy `eb` !+firing into a target with atomic mass `am` and temperature `T` which has a cross section given by the function `fnm` interface function fnm ( a , b , c ) !+Cross section function real ( 8 ) :: fnm !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !n integer , intent ( in ) :: c !m end function fnm end interface real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state integer , intent ( in ) :: m !+Final atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] logical , intent ( in ), optional :: deexcit !+Calculate de-excitation reaction rate logical :: dxc integer :: n_vr real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( 32 ) :: vr real ( Float64 ), dimension ( 32 ) :: fr integer :: n_vz real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( 62 ) :: vz real ( Float64 ), dimension ( 62 ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , dE , factor , En , Em , v_therm integer :: i , j if ( present ( deexcit )) then dxc = deexcit else dxc = . False . endif n_vr = 32 vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo n_vz = 62 vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo En = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / n ) ** 2.0 ) Em = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / m ) ** 2.0 ) dE = Em - En T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( dxc ) then factor = ( erel + dE ) / erel erel = erel + dE else factor = 1.0 endif if ( erel . ge . dE ) then sig = fnm ( erel / ared , n , m ) else sig = 0.d0 endif fr ( j ) = factor * sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm if ( dxc ) rate = rate * ( real ( n ) / real ( m )) ** 2.0 end subroutine bt_maxwellian_n_m","tags":"","loc":"proc/bt_maxwellian_n_m.html","title":"bt_maxwellian_n_m – FIDASIM"},{"text":"public subroutine bt_maxwellian_q_n_m(fqnm, q, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqnm Arguments Type Intent Optional Attributes Name public function fqnm(a, b, c, d) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate Calls proc~~bt_maxwellian_q_n_m~~CallsGraph proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m proc~simpsons_rule simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bt_maxwellian_q_n_m~~CalledByGraph proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian bt_maxwellian interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~bt_maxwellian proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~bt_maxwellian proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~bt_maxwellian proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~bt_maxwellian proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~bt_maxwellian program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bt_maxwellian_q_n_m Source Code subroutine bt_maxwellian_q_n_m ( fqnm , q , T , eb , am , ab , n , m , rate , deexcit ) !+ Calculates Maxwellian reaction rate for a `n`\\rightarrow)`m` transition due to a beam with atomic mass `ab` and energy `eb` !+firing into a target with atomic mass `am`, temperature `T`, and charge `q` which has a cross section given by the function `fqnm` interface function fqnm ( a , b , c , d ) !+Cross section function real ( 8 ) :: fqnm !sigma real ( 8 ), intent ( in ) :: a !eb integer , intent ( in ) :: b !q integer , intent ( in ) :: c !n integer , intent ( in ) :: d !m end function fqnm end interface integer , intent ( in ) :: q !+Target charge real ( Float64 ), intent ( in ) :: T !+Target temperature [keV] real ( Float64 ), intent ( in ) :: eb !+Beam energy [keV] real ( Float64 ), intent ( in ) :: am !+Target atomic mass [amu] real ( Float64 ), intent ( in ) :: ab !+Beam atomic mass [amu] integer , intent ( in ) :: n !+Initial atomic energy level/state integer , intent ( in ) :: m !+Final atomic energy level/state real ( Float64 ), intent ( out ) :: rate !+Reaction Rate [cm&#94;3/s] logical , intent ( in ), optional :: deexcit !+Calculate de-excitation reaction rate logical :: dxc integer :: n_vr real ( Float64 ) :: vr_max , dvr real ( Float64 ), dimension ( 32 ) :: vr real ( Float64 ), dimension ( 32 ) :: fr integer :: n_vz real ( Float64 ) :: vz_max , dvz real ( Float64 ), dimension ( 62 ) :: vz real ( Float64 ), dimension ( 62 ) :: fz real ( Float64 ) :: T_per_amu , eb_per_amu , ared , sig , sig_eff real ( Float64 ) :: zb , u2_to_erel , u2 , erel , dE , factor , En , Em , v_therm integer :: i , j if ( present ( deexcit )) then dxc = deexcit else dxc = . False . endif n_vr = 32 vr_max = 4.d0 dvr = vr_max / ( n_vr - 1.d0 ) do i = 1 , n_vr vr ( i ) = ( i - 1 ) * dvr enddo n_vz = 62 vz_max = 4.d0 dvz = 2.0 * vz_max / ( n_vz - 1.d0 ) do i = 1 , n_vz vz ( i ) = ( i - 1 ) * dvz - vz_max enddo En = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / n ) ** 2.0 ) Em = ( 1 3.6d-3 ) * ( 1.0 - ( 1.d0 / m ) ** 2.0 ) dE = Em - En T_per_amu = max ( T , 1.d-6 ) / am eb_per_amu = eb / ab ared = am * ab / ( am + ab ) v_therm = 1.384d6 * sqrt ( T_per_amu * 1.d3 ) zb = sqrt ( eb_per_amu / T_per_amu ) u2_to_erel = ared * T_per_amu if ( ared . lt . 0.5 ) ared = 1.0 fz = 0.d0 fr = 0.d0 do i = 1 , n_vz do j = 1 , n_vr u2 = ( zb - vz ( i )) ** 2.0 + vr ( j ) ** 2.0 erel = u2_to_erel * u2 if ( dxc ) then factor = ( erel + dE ) / erel erel = erel + dE else factor = 1.0 endif if ( erel . ge . dE ) then sig = fqnm ( erel / ared , q , n , m ) else sig = 0.d0 endif fr ( j ) = factor * sig * sqrt ( u2 ) * exp ( - ( vz ( i ) ** 2.0 + vr ( j ) ** 2.0 )) * vr ( j ) enddo fz ( i ) = simpsons_rule ( fr , dvr ) enddo sig_eff = ( 2.0 / sqrt ( PI )) * simpsons_rule ( fz , dvz ) rate = sig_eff * v_therm if ( dxc ) rate = rate * ( real ( n ) / real ( m )) ** 2.0 end subroutine bt_maxwellian_q_n_m","tags":"","loc":"proc/bt_maxwellian_q_n_m.html","title":"bt_maxwellian_q_n_m – FIDASIM"},{"text":"public subroutine write_einstein(id, n_max, m_max) Write Einstein coefficients to HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate Calls proc~~write_einstein~~CallsGraph proc~write_einstein write_einstein interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_einstein->h5ltset_attribute_string_f h5gcreate_f h5gcreate_f proc~write_einstein->h5gcreate_f h5gclose_f h5gclose_f proc~write_einstein->h5gclose_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_einstein->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_einsteinCallsGraph = svgPanZoom('#procwrite_einsteinCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_einstein~~CalledByGraph proc~write_einstein write_einstein program~generate_tables generate_tables program~generate_tables->proc~write_einstein Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_einstein Source Code subroutine write_einstein ( id , n_max , m_max ) !+ Write Einstein coefficients to HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate real ( Float64 ), dimension ( n_max , m_max ) :: ein integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: error ein (:,:) = EINSTEIN ( 1 : n_max , 1 : m_max ) call h5gcreate_f ( id , \"spontaneous\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , m_max ] call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_compressed_dataset_double_f ( gid , \"einstein\" , 2 , dim2 , ein , error ) call h5ltset_attribute_string_f ( id , \"spontaneous\" , \"description\" , & \"Atomic rates for spontaneous emission/deexcitation\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"description\" , & \"n/m resolved einstein coefficients: einstein(n,m)\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"units\" , \"1/s\" , error ) call h5ltset_attribute_string_f ( gid , \"einstein\" , \"reaction\" , & \"H(n) -> H(m) + ph, n > m\" , error ) call h5gclose_f ( gid , error ) end subroutine write_einstein","tags":"","loc":"proc/write_einstein.html","title":"write_einstein – FIDASIM"},{"text":"public subroutine write_bb_H_H(id, namelist_file, n_max, m_max) Write Hydrogen-Hydrogen interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate Calls proc~~write_bb_h_h~~CallsGraph proc~write_bb_h_h write_bb_H_H h5gclose_f h5gclose_f proc~write_bb_h_h->h5gclose_f proc~p_excit p_excit proc~write_bb_h_h->proc~p_excit h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bb_h_h->h5ltset_attribute_string_f h5gcreate_f h5gcreate_f proc~write_bb_h_h->h5gcreate_f proc~p_ioniz p_ioniz proc~write_bb_h_h->proc~p_ioniz h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bb_h_h->h5ltmake_dataset_double_f proc~p_cx p_cx proc~write_bb_h_h->proc~p_cx h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bb_h_h->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~p_excit_n p_excit_n proc~p_excit->proc~p_excit_n proc~p_ioniz_n p_ioniz_n proc~p_ioniz->proc~p_ioniz_n proc~p_cx_n p_cx_n proc~p_cx->proc~p_cx_n proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n->proc~p_ioniz_5_omullane proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz_1_janev p_ioniz_1_janev proc~p_ioniz_n->proc~p_ioniz_1_janev proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n->proc~p_ioniz_2_omullane proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_1->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_bb_h_hCallsGraph = svgPanZoom('#procwrite_bb_h_hCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_bb_h_h~~CalledByGraph proc~write_bb_h_h write_bb_H_H program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_bb_H_H Source Code subroutine write_bb_H_H ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Hydrogen interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:), allocatable :: cx , excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: i , cnt , error logical :: exis NAMELIST / H_H_cross / nenergy , emin , emax nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_H: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_H_cross ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( cx ( n_max , m_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 write ( * , '(a)' ) \"---- H-H cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = 1 , nenergy eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb cx (:,:, i ) = p_cx ( eb , n_max , m_max ) excit (:,:, i ) = p_excit ( eb , n_max , m_max ) ioniz (:, i ) = p_ioniz ( eb , n_max ) cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"H_H\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 3 , dim3 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_H\" , \"description\" , & \"Cross sections for Hydrogen-Hydrogen interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n/m resolved charge exchange cross sections: cx(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"H(+) + H(n) -> H(m) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , cx , excit , ioniz ) end subroutine write_bb_H_H","tags":"","loc":"proc/write_bb_h_h.html","title":"write_bb_H_H – FIDASIM"},{"text":"public subroutine write_bb_H_e(id, namelist_file, n_max, m_max) Write Hydrogen-Electron interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate Calls proc~~write_bb_h_e~~CallsGraph proc~write_bb_h_e write_bb_H_e h5gclose_f h5gclose_f proc~write_bb_h_e->h5gclose_f proc~e_ioniz e_ioniz proc~write_bb_h_e->proc~e_ioniz h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bb_h_e->h5ltset_attribute_string_f h5gcreate_f h5gcreate_f proc~write_bb_h_e->h5gcreate_f proc~e_excit e_excit proc~write_bb_h_e->proc~e_excit h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bb_h_e->h5ltmake_dataset_double_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bb_h_e->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~e_ioniz_n e_ioniz_n proc~e_ioniz->proc~e_ioniz_n proc~e_excit_n e_excit_n proc~e_excit->proc~e_excit_n proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n->proc~e_ioniz_2_janev proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n->proc~e_ioniz_1_janev proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n->proc~e_ioniz_3_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_bb_h_eCallsGraph = svgPanZoom('#procwrite_bb_h_eCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_bb_h_e~~CalledByGraph proc~write_bb_h_e write_bb_H_e program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_bb_H_e Source Code subroutine write_bb_H_e ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Electron interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: i , cnt , error logical :: exis NAMELIST / H_e_cross / nenergy , emin , emax nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_E: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_e_cross ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0.d0 ioniz = 0.d0 excit = 0.d0 write ( * , '(a)' ) \"---- H-e cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = 1 , nenergy eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb excit (:,:, i ) = e_excit ( eb , n_max , m_max ) ioniz (:, i ) = e_ioniz ( eb , n_max ) cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"H_e\" , gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_e\" , \"description\" , & \"Cross sections for Hydrogen-Electron interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum Energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum Energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"e- + H(n) -> e- + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"e- + H(n) -> e- + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , ioniz , excit ) end subroutine write_bb_H_e","tags":"","loc":"proc/write_bb_h_e.html","title":"write_bb_H_e – FIDASIM"},{"text":"public subroutine write_bb_H_Aq(id, namelist_file, n_max, m_max) Write Hydrogen-Impurity interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate Calls proc~~write_bb_h_aq~~CallsGraph proc~write_bb_h_aq write_bb_H_Aq proc~aq_cx Aq_cx proc~write_bb_h_aq->proc~aq_cx proc~aq_ioniz Aq_ioniz proc~write_bb_h_aq->proc~aq_ioniz h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bb_h_aq->h5ltset_attribute_string_f proc~aq_excit Aq_excit proc~write_bb_h_aq->proc~aq_excit h5gcreate_f h5gcreate_f proc~write_bb_h_aq->h5gcreate_f h5gclose_f h5gclose_f proc~write_bb_h_aq->h5gclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bb_h_aq->h5ltmake_dataset_double_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bb_h_aq->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~aq_cx_n Aq_cx_n proc~aq_cx->proc~aq_cx_n proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz->proc~aq_ioniz_n proc~aq_excit_n Aq_excit_n proc~aq_excit->proc~aq_excit_n proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n->proc~aq_cx_n_janev proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n->proc~aq_ioniz_n_janev proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n->proc~c6_ioniz_1_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_bb_h_aqCallsGraph = svgPanZoom('#procwrite_bb_h_aqCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_bb_h_aq~~CalledByGraph proc~write_bb_h_aq write_bb_H_Aq program~generate_tables generate_tables program~generate_tables->proc~write_bb_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_bb_H_Aq Source Code subroutine write_bb_H_Aq ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Impurity interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate integer :: q real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: cx , ioniz real ( Float64 ), dimension (:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 character ( len = 10 ) :: aname character ( len = 5 ) :: asym integer :: i , cnt , error logical :: exis NAMELIST / H_Aq_cross / q , nenergy , emin , emax nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 q = 6 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_H_Aq: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_Aq_cross ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( ioniz ( n_max , nenergy )) allocate ( cx ( n_max , nenergy )) allocate ( excit ( n_max , m_max , nenergy )) ebarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 select case ( q ) case ( 5 ) aname = \"Boron\" asym = \"H_B5\" case ( 6 ) aname = \"Carbon\" asym = \"H_C6\" case DEFAULT aname = \"Impurity\" asym = \"H_Aq\" end select write ( * , '(a)' ) \"---- H-\" // trim ( adjustl ( aname )) // \" cross sections settings ----\" write ( * , '(T2,\"q = \", i2)' ), q write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = 1 , nenergy eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb cx (:, i ) = Aq_cx ( eb , q , n_max ) ioniz (:, i ) = Aq_ioniz ( eb , q , n_max ) excit (:,:, i ) = Aq_excit ( eb , q , n_max , m_max ) cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy ), char ( 13 ) enddo call h5gcreate_f ( id , trim ( adjustl ( asym )), gid , error ) dim1 = [ 1 ] dim2 = [ n_max , nenergy ] dim3 = [ n_max , m_max , nenergy ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 2 , dim2 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 2 , dim2 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 3 , dim3 , excit , error ) call h5ltset_attribute_string_f ( id , trim ( adjustl ( asym )), \"description\" , & \"Cross sections for Hydrogen-\" // trim ( adjustl ( aname )) // \" interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Nucleon energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV/amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV/amu\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n resolved charge exchange / electron capture cross sections: cx(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"A(q+) + H(n) -> A((q-1)+) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved excitation cross sections: excitation(n,m,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(m), m > n\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization cross sections: ionization(n,energy)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , ioniz , cx , excit ) end subroutine write_bb_H_Aq","tags":"","loc":"proc/write_bb_h_aq.html","title":"write_bb_H_Aq – FIDASIM"},{"text":"public subroutine write_bb_D_D(id, namelist_file) Write Deuterium-Deuterium interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings Calls proc~~write_bb_d_d~~CallsGraph proc~write_bb_d_d write_bb_D_D interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bb_d_d->h5ltset_attribute_string_f h5gcreate_f h5gcreate_f proc~write_bb_d_d->h5gcreate_f h5gclose_f h5gclose_f proc~write_bb_d_d->h5gclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bb_d_d->h5ltmake_dataset_double_f proc~d_d_fusion_he d_d_fusion_he proc~write_bb_d_d->proc~d_d_fusion_he h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bb_d_d->h5ltmake_dataset_int_f proc~d_d_fusion_t d_d_fusion_t proc~write_bb_d_d->proc~d_d_fusion_t proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_bb_d_dCallsGraph = svgPanZoom('#procwrite_bb_d_dCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_bb_d_d~~CalledByGraph proc~write_bb_d_d write_bb_D_D program~generate_tables generate_tables program~generate_tables->proc~write_bb_d_d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_bb_D_D Source Code subroutine write_bb_D_D ( id , namelist_file ) !+ Write Deuterium-Deuterium interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer :: nbranch = 2 real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: i , cnt , error logical :: exis NAMELIST / D_D_cross / nenergy , emin , emax nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_D_D: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_D_cross ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( fusion ( nenergy , nbranch )) ebarr = 0.d0 fusion = 0.d0 write ( * , '(a)' ) \"---- D-D cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = 1 , nenergy eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb fusion ( i , 1 ) = d_d_fusion_t ( eb ) fusion ( i , 2 ) = d_d_fusion_he ( eb ) cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"D_D\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] dim2 = [ nenergy , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 2 , dim2 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_D\" , \"description\" , & \"Cross sections for Deuterium-Deuterium interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Deuterium energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Cross sections for the Tritium[1] and He3[2] branches of D-D nuclear reactions: fusion(energy, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + D -> [1] T(1.01 MeV) + p(3.02 MeV) (50%); [2] He3(0.82 MeV) + n(2.45 MeV) (50%)\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , fusion ) end subroutine write_bb_D_D","tags":"","loc":"proc/write_bb_d_d.html","title":"write_bb_D_D – FIDASIM"},{"text":"public subroutine write_bb_D_T(id, namelist_file) Write Deuterium-Tritium interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings Calls proc~~write_bb_d_t~~CallsGraph proc~write_bb_d_t write_bb_D_T proc~d_t_fusion d_t_fusion proc~write_bb_d_t->proc~d_t_fusion h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bb_d_t->h5ltset_attribute_string_f h5gcreate_f h5gcreate_f proc~write_bb_d_t->h5gcreate_f h5gclose_f h5gclose_f proc~write_bb_d_t->h5gclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bb_d_t->h5ltmake_dataset_double_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bb_d_t->h5ltmake_dataset_int_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bb_d_t->interface~h5ltmake_compressed_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_bb_d_tCallsGraph = svgPanZoom('#procwrite_bb_d_tCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_bb_D_T Source Code subroutine write_bb_D_T ( id , namelist_file ) !+ Write Deuterium-Tritium interaction cross sections to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer :: nbranch = 1 real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ), dimension (:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer :: i , cnt , error logical :: exis NAMELIST / D_T_cross / nenergy , emin , emax nenergy = 200 ; emin = 1.d-3 ; emax = 8.d2 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BB_D_T: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_T_cross ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( fusion ( nenergy , nbranch )) ebarr = 0.d0 fusion = 0.d0 write ( * , '(a)' ) \"---- D-T cross sections settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , * ) '' cnt = 0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) !$OMP PARALLEL DO private(i, eb) do i = 1 , nenergy eb = 1 0.d0 ** ( log10 ( emin ) + ( i - 1 ) * dlogE ) ebarr ( i ) = eb fusion ( i , 1 ) = d_t_fusion ( eb ) cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy ), char ( 13 ) enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"D_T\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) dim1 = [ nenergy ] dim2 = [ nenergy , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 2 , dim2 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_T\" , \"description\" , & \"Cross sections for Deuterium-Tritium interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Deuterium energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Total cross sections for D-T nuclear reactions: fusion(deuterium energy, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;2\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + T -> He4(3.5 MeV) + n(14.1 MeV)\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , fusion ) end subroutine write_bb_D_T","tags":"","loc":"proc/write_bb_d_t.html","title":"write_bb_D_T – FIDASIM"},{"text":"public subroutine write_bt_H_H(id, namelist_file, n_max, m_max) Write Hydrogen-Hydrogen reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate Calls proc~~write_bt_h_h~~CallsGraph proc~write_bt_h_h write_bt_H_H interface~bt_maxwellian bt_maxwellian proc~write_bt_h_h->interface~bt_maxwellian h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bt_h_h->h5ltset_attribute_string_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_h_h->h5ltmake_dataset_int_f h5gclose_f h5gclose_f proc~write_bt_h_h->h5gclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_h_h->h5ltmake_dataset_double_f h5gcreate_f h5gcreate_f proc~write_bt_h_h->h5gcreate_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~bt_maxwellian_eb bt_maxwellian_eb interface~bt_maxwellian->proc~bt_maxwellian_eb proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~simpsons_rule simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule proc~bt_maxwellian_eb->proc~simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_bt_h_hCallsGraph = svgPanZoom('#procwrite_bt_h_hCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_bt_h_h~~CalledByGraph proc~write_bt_h_h write_bt_H_H program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_bt_H_H Source Code subroutine write_bt_H_H ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Hydrogen reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit , cx integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 4 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a logical :: exis NAMELIST / H_H_rates / nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_H: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_H_rates ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( cx ( n_max , m_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) ebarr = 0.d0 tarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 a (:, 1 ) = [ H1_amu , H1_amu ] a (:, 2 ) = [ H1_amu , H2_amu ] a (:, 3 ) = [ H2_amu , H1_amu ] a (:, 4 ) = [ H2_amu , H2_amu ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo write ( * , '(a)' ) \"---- H-H reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = 1 , nenergy eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max call bt_maxwellian ( p_cx_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) cx ( n , m , ie , it , ia ) = rate if ( m . gt . n ) then call bt_maxwellian ( p_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( p_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( p_ioniz_n , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"H_H\" , gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 5 , dim5 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_H\" , \"description\" , & \"Beam-Target reaction rates for Hydrogen(beam)-Hydrogen(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n/m resolved charge exchange reaction rates: cx(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"H(+) + H(n) -> H(m) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"H(+) + H(n) -> H(+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , tarr , cx , excit , ioniz ) end subroutine write_bt_H_H","tags":"","loc":"proc/write_bt_h_h.html","title":"write_bt_H_H – FIDASIM"},{"text":"public subroutine write_bt_H_e(id, namelist_file, n_max, m_max) Write Hydrogen-Electron reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate Calls proc~~write_bt_h_e~~CallsGraph proc~write_bt_h_e write_bt_H_e interface~bt_maxwellian bt_maxwellian proc~write_bt_h_e->interface~bt_maxwellian h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bt_h_e->h5ltset_attribute_string_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_h_e->h5ltmake_dataset_int_f h5gclose_f h5gclose_f proc~write_bt_h_e->h5gclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_h_e->h5ltmake_dataset_double_f h5gcreate_f h5gcreate_f proc~write_bt_h_e->h5gcreate_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~bt_maxwellian_eb bt_maxwellian_eb interface~bt_maxwellian->proc~bt_maxwellian_eb proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~simpsons_rule simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule proc~bt_maxwellian_eb->proc~simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_bt_h_eCallsGraph = svgPanZoom('#procwrite_bt_h_eCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_bt_h_e~~CalledByGraph proc~write_bt_h_e write_bt_H_e program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_bt_H_e Source Code subroutine write_bt_H_e ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Electron reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 2 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a logical :: exis NAMELIST / H_e_rates / nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_E: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_e_rates ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) ebarr = 0.d0 ioniz = 0.d0 excit = 0.d0 a (:, 1 ) = [ H1_amu , e_amu ] a (:, 2 ) = [ H2_amu , e_amu ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo write ( * , '(a)' ) \"---- H-e reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = 1 , nenergy eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max if ( m . gt . n ) then call bt_maxwellian ( e_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( e_excit_n_m , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( e_ioniz_n , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"H_e\" , gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , \"H_e\" , \"description\" , & \"Beam-Target reaction rates for Hydrogen(beam)-Electron(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"e- + H(n) -> e- + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"e- + H(n) -> e- + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , tarr , excit , ioniz ) end subroutine write_bt_H_e","tags":"","loc":"proc/write_bt_h_e.html","title":"write_bt_H_e – FIDASIM"},{"text":"public subroutine write_bt_H_Aq(id, namelist_file, n_max, m_max) Write Hydrogen-Impurity reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate Calls proc~~write_bt_h_aq~~CallsGraph proc~write_bt_h_aq write_bt_H_Aq interface~bt_maxwellian bt_maxwellian proc~write_bt_h_aq->interface~bt_maxwellian h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bt_h_aq->h5ltset_attribute_string_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_h_aq->h5ltmake_dataset_int_f h5gclose_f h5gclose_f proc~write_bt_h_aq->h5gclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_h_aq->h5ltmake_dataset_double_f h5gcreate_f h5gcreate_f proc~write_bt_h_aq->h5gcreate_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~bt_maxwellian_eb bt_maxwellian_eb interface~bt_maxwellian->proc~bt_maxwellian_eb proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~simpsons_rule simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule proc~bt_maxwellian_eb->proc~simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_bt_h_aqCallsGraph = svgPanZoom('#procwrite_bt_h_aqCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_bt_h_aq~~CalledByGraph proc~write_bt_h_aq write_bt_H_Aq program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_bt_H_Aq Source Code subroutine write_bt_H_Aq ( id , namelist_file , n_max , m_max ) !+ Write Hydrogen-Impurity reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer , intent ( in ) :: n_max !+ Number of initial atomic energy states to calculate integer , intent ( in ) :: m_max !+ Number of final atomic energy states to calculate integer :: q real ( Float64 ) :: mass real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:,:), allocatable :: ioniz , cx real ( Float64 ), dimension (:,:,:,:,:), allocatable :: excit integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 2 ) :: dim2 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer ( HSIZE_T ), dimension ( 4 ) :: dim4 integer ( HSIZE_T ), dimension ( 5 ) :: dim5 integer :: ie , it , ia , n , m , error , cnt real ( Float64 ) :: rate integer , parameter :: n_bt_amu = 2 real ( Float64 ), dimension ( 2 , n_bt_amu ) :: a character ( len = 10 ) :: aname character ( len = 5 ) :: asym logical :: exis NAMELIST / H_Aq_rates / q , mass , nenergy , emin , emax , ntemp , tmin , tmax q = 6 ; mass = C_amu nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_H_Aq: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = H_Aq_rates ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( ioniz ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( cx ( n_max , nenergy , ntemp , n_bt_amu )) allocate ( excit ( n_max , m_max , nenergy , ntemp , n_bt_amu )) select case ( q ) case ( 5 ) aname = \"Boron\" asym = \"H_B5\" case ( 6 ) aname = \"Carbon\" asym = \"H_C6\" case DEFAULT aname = \"Impurity\" asym = \"H_Aq\" end select ebarr = 0.d0 ioniz = 0.d0 cx = 0.d0 excit = 0.d0 a (:, 1 ) = [ H1_amu , mass ] a (:, 2 ) = [ H2_amu , mass ] dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo write ( * , '(a)' ) \"---- H-\" // trim ( adjustl ( aname )) // \" reaction rates settings ----\" write ( * , '(T2,\"q = \", i2)' ), q write ( * , '(T2,\"mass = \",f7.2, \" amu\")' ) mass write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' cnt = 0 !$OMP PARALLEL DO private(ie, it, ia, n, m, eb, ti, rate) do ie = 1 , nenergy eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) do ia = 1 , n_bt_amu do n = 1 , n_max do m = 1 , m_max if ( m . gt . n ) then call bt_maxwellian ( Aq_excit_n_m , q , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , rate ) excit ( n , m , ie , it , ia ) = rate call bt_maxwellian ( Aq_excit_n_m , q , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , m , & rate , deexcit = . True .) excit ( m , n , ie , it , ia ) = rate endif enddo call bt_maxwellian ( Aq_cx_n , q , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) cx ( n , ie , it , ia ) = rate call bt_maxwellian ( Aq_ioniz_n , q , ti , eb , & a ( 2 , ia ), a ( 1 , ia ), n , rate ) ioniz ( n , ie , it , ia ) = rate enddo enddo cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , trim ( adjustl ( asym )), gid , error ) dim1 = [ 1 ] dim4 = [ n_max , nenergy , ntemp , n_bt_amu ] dim5 = [ n_max , m_max , nenergy , ntemp , n_bt_amu ] call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_int_f ( gid , \"n_bt_amu\" , 0 , dim1 , [ n_bt_amu ], error ) call h5ltmake_dataset_int_f ( gid , \"n_max\" , 0 , dim1 , [ n_max ], error ) call h5ltmake_dataset_int_f ( gid , \"m_max\" , 0 , dim1 , [ m_max ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim2 = [ 2 , n_bt_amu ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 2 , dim2 , a , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"cx\" , 4 , dim4 , cx , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"ionization\" , 4 , dim4 , ioniz , error ) call h5ltmake_compressed_dataset_double_f ( gid , \"excitation\" , 5 , dim5 , excit , error ) call h5ltset_attribute_string_f ( id , trim ( adjustl ( asym )), \"description\" , & \"Beam-Target reaction rates for Hydrogen(beam)-\" // trim ( adjustl ( aname )) // & \"(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"n_bt_amu\" , \"description\" , & \"Number of beam-target amu combinations\" , error ) call h5ltset_attribute_string_f ( gid , \"n_max\" , \"description\" , & \"Number of initial energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"m_max\" , \"description\" , & \"Number of final energy levels\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Combinations of beam-target amu's e.g. b_amu, t_amu = bt_amu[:,i]\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"description\" , & \"n-resolved charge exchange reaction rates: cx(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"cx\" , \"reaction\" , & \"A(q+) + H(n) -> A((q-1)+) + H(+)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"description\" , & \"n/m resolved (de-)excitation reaction rates: excitation(n,m,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"excitation\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(m); m > n excitation, m < n de-excitation\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"description\" , & \"n resolved ionization reaction rates: ionization(n,energy,temp,bt_amu)\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"ionization\" , \"reaction\" , & \"A(q+) + H(n) -> A(q+) + H(+) + e-\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , tarr , excit , ioniz ) end subroutine write_bt_H_Aq","tags":"","loc":"proc/write_bt_h_aq.html","title":"write_bt_H_Aq – FIDASIM"},{"text":"public subroutine write_bt_D_D(id, namelist_file) Write Deuterium-Deuterium reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings Calls proc~~write_bt_d_d~~CallsGraph proc~write_bt_d_d write_bt_D_D interface~bt_maxwellian bt_maxwellian proc~write_bt_d_d->interface~bt_maxwellian h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bt_d_d->h5ltset_attribute_string_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_d_d->h5ltmake_dataset_int_f h5gclose_f h5gclose_f proc~write_bt_d_d->h5gclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_d_d->h5ltmake_dataset_double_f h5gcreate_f h5gcreate_f proc~write_bt_d_d->h5gcreate_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~bt_maxwellian_eb bt_maxwellian_eb interface~bt_maxwellian->proc~bt_maxwellian_eb proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~simpsons_rule simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule proc~bt_maxwellian_eb->proc~simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_bt_d_dCallsGraph = svgPanZoom('#procwrite_bt_d_dCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~write_bt_d_d~~CalledByGraph proc~write_bt_d_d write_bt_D_D program~generate_tables generate_tables program~generate_tables->proc~write_bt_d_d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_bt_D_D Source Code subroutine write_bt_D_D ( id , namelist_file ) !+ Write Deuterium-Deuterium reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer :: nbranch = 2 real ( Float64 ), dimension ( 2 ) :: bt_amu = [ H2_amu , H2_amu ] real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: ie , it , error , cnt real ( Float64 ) :: rate_a , rate_b logical :: exis NAMELIST / D_D_rates / nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_D_D: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_D_rates ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( fusion ( nenergy , ntemp , nbranch )) ebarr = 0.d0 tarr = 0.d0 fusion = 0.d0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo write ( * , '(a)' ) \"---- D-D reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' cnt = 0 !$OMP PARALLEL DO private(ie, it, eb, ti, rate_a, rate_b) do ie = 1 , nenergy eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) call bt_maxwellian ( d_d_fusion_t , ti , eb , bt_amu ( 1 ), bt_amu ( 2 ), rate_a ) call bt_maxwellian ( d_d_fusion_he , ti , eb , bt_amu ( 2 ), bt_amu ( 2 ), rate_b ) fusion ( ie , it , 1 ) = rate_a fusion ( ie , it , 2 ) = rate_b cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"D_D\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim1 = [ 2 ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 1 , dim1 , bt_amu , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) dim3 = [ nenergy , ntemp , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 3 , dim3 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_D\" , \"description\" , & \"Beam-Target reaction rates for Deuterium(beam)-Deuterium(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Isotope mass of the beam and target species respectively\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"units\" , \"amu\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Beam-Target reaction rates for T/He3 branches of D-D nuclear reactions: fusion(energy, temp, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + D -> [1] T(1.01 MeV) + p(3.02 MeV) (50%); [2] He3(0.82 MeV) + n(2.45 MeV) (50%)\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , tarr , fusion ) end subroutine write_bt_D_D","tags":"","loc":"proc/write_bt_d_d.html","title":"write_bt_D_D – FIDASIM"},{"text":"public subroutine write_bt_D_T(id, namelist_file) Write Deuterium-Tritium reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings Calls proc~~write_bt_d_t~~CallsGraph proc~write_bt_d_t write_bt_D_T interface~bt_maxwellian bt_maxwellian proc~write_bt_d_t->interface~bt_maxwellian h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_bt_d_t->h5ltset_attribute_string_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_bt_d_t->h5ltmake_dataset_int_f h5gclose_f h5gclose_f proc~write_bt_d_t->h5gclose_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_d_t->h5ltmake_dataset_double_f h5gcreate_f h5gcreate_f proc~write_bt_d_t->h5gcreate_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_bt_d_t->interface~h5ltmake_compressed_dataset_double_f proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~bt_maxwellian_eb bt_maxwellian_eb interface~bt_maxwellian->proc~bt_maxwellian_eb proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~simpsons_rule simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule proc~bt_maxwellian_eb->proc~simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f var panprocwrite_bt_d_tCallsGraph = svgPanZoom('#procwrite_bt_d_tCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code write_bt_D_T Source Code subroutine write_bt_D_T ( id , namelist_file ) !+ Write Deuterium-Tritium reaction rates to a HDF5 file integer ( HID_T ), intent ( inout ) :: id !+ HDF5 file or group object id character ( len =* ), intent ( in ) :: namelist_file !+ Namelist file that contains settings integer :: nbranch = 1 real ( Float64 ), dimension ( 2 ) :: bt_amu = [ H2_amu , H3_amu ] real ( Float64 ) :: emin real ( Float64 ) :: emax integer :: nenergy real ( Float64 ) :: tmin real ( Float64 ) :: tmax integer :: ntemp real ( Float64 ) :: eb real ( Float64 ) :: dlogE real ( Float64 ), dimension (:), allocatable :: ebarr real ( Float64 ) :: ti real ( Float64 ) :: dlogT real ( Float64 ), dimension (:), allocatable :: tarr real ( Float64 ), dimension (:,:,:), allocatable :: fusion integer ( HID_T ) :: gid integer ( HSIZE_T ), dimension ( 1 ) :: dim1 integer ( HSIZE_T ), dimension ( 3 ) :: dim3 integer :: ie , it , error , cnt real ( Float64 ) :: rate logical :: exis NAMELIST / D_T_rates / nenergy , emin , emax , ntemp , tmin , tmax nenergy = 100 ; emin = 1.d-3 ; emax = 4.d2 ntemp = 100 ; tmin = 1.d-3 ; tmax = 2.d1 inquire ( file = namelist_file , exist = exis ) if (. not . exis ) then write ( * , '(a,a)' ) 'WRITE_BT_D_T: Input file does not exist: ' , trim ( namelist_file ) write ( * , '(a)' ) 'Continuing with default settings...' else open ( 13 , file = namelist_file ) read ( 13 , NML = D_T_rates ) close ( 13 ) endif allocate ( ebarr ( nenergy )) allocate ( tarr ( ntemp )) allocate ( fusion ( nenergy , ntemp , nbranch )) ebarr = 0.d0 tarr = 0.d0 fusion = 0.d0 dlogE = ( log10 ( emax ) - log10 ( emin )) / ( nenergy - 1 ) do ie = 1 , nenergy ebarr ( ie ) = 1 0.d0 ** ( log10 ( emin ) + ( ie - 1 ) * dlogE ) enddo dlogT = ( log10 ( tmax ) - log10 ( tmin )) / ( ntemp - 1 ) do it = 1 , ntemp tarr ( it ) = 1 0.d0 ** ( log10 ( tmin ) + ( it - 1 ) * dlogT ) enddo write ( * , '(a)' ) \"---- D-T reaction rates settings ----\" write ( * , '(T2,\"Emin = \",e9.2, \" keV\")' ) emin write ( * , '(T2,\"Emax = \",e9.2, \" keV\")' ) emax write ( * , '(T2,\"Nenergy = \", i4)' ) nenergy write ( * , '(T2,\"Tmin = \",e9.2, \" keV\")' ) tmin write ( * , '(T2,\"Tmax = \",e9.2, \" keV\")' ) tmax write ( * , '(T2,\"Ntemp = \", i4)' ) ntemp write ( * , * ) '' cnt = 0 !$OMP PARALLEL DO private(ie, it, eb, ti, rate) do ie = 1 , nenergy eb = ebarr ( ie ) do it = 1 , ntemp ti = tarr ( it ) call bt_maxwellian ( d_t_fusion , ti , eb , bt_amu ( 1 ), bt_amu ( 2 ), rate ) fusion ( ie , it , 1 ) = rate cnt = cnt + 1 WRITE ( * , '(f7.2,\"%\",a,$)' ) 100 * cnt / real ( nenergy * ntemp ), char ( 13 ) enddo enddo !$OMP END PARALLEL DO call h5gcreate_f ( id , \"D_T\" , gid , error ) dim1 = [ 1 ] call h5ltmake_dataset_int_f ( gid , \"nbranch\" , 0 , dim1 , [ nbranch ], error ) call h5ltmake_dataset_int_f ( gid , \"nenergy\" , 0 , dim1 , [ nenergy ], error ) call h5ltmake_dataset_int_f ( gid , \"ntemp\" , 0 , dim1 , [ ntemp ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogE\" , 0 , dim1 , [ dlogE ], error ) call h5ltmake_dataset_double_f ( gid , \"emin\" , 0 , dim1 , [ emin ], error ) call h5ltmake_dataset_double_f ( gid , \"emax\" , 0 , dim1 , [ emax ], error ) call h5ltmake_dataset_double_f ( gid , \"dlogT\" , 0 , dim1 , [ dlogT ], error ) call h5ltmake_dataset_double_f ( gid , \"tmin\" , 0 , dim1 , [ tmin ], error ) call h5ltmake_dataset_double_f ( gid , \"tmax\" , 0 , dim1 , [ tmax ], error ) dim1 = [ 2 ] call h5ltmake_compressed_dataset_double_f ( gid , \"bt_amu\" , 1 , dim1 , bt_amu , error ) dim1 = [ nenergy ] call h5ltmake_compressed_dataset_double_f ( gid , \"energy\" , 1 , dim1 , ebarr , error ) dim1 = [ ntemp ] call h5ltmake_compressed_dataset_double_f ( gid , \"temperature\" , 1 , dim1 , tarr , error ) dim3 = [ nenergy , ntemp , nbranch ] call h5ltmake_compressed_dataset_double_f ( gid , \"fusion\" , 3 , dim3 , fusion , error ) call h5ltset_attribute_string_f ( id , \"D_T\" , \"description\" , & \"Beam-Target reaction rates for Deuterium(beam)-Tritium(target) interactions\" , error ) call h5ltset_attribute_string_f ( gid , \"nbranch\" , \"description\" , & \"Number of reaction branches\" , error ) call h5ltset_attribute_string_f ( gid , \"nenergy\" , \"description\" , & \"Number of energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"ntemp\" , \"description\" , & \"Number of target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"description\" , & \"Energy values\" , error ) call h5ltset_attribute_string_f ( gid , \"energy\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"description\" , & \"Energy spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogE\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"description\" , & \"Minimum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"description\" , & \"Maximum energy\" , error ) call h5ltset_attribute_string_f ( gid , \"emax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"description\" , & \"Target temperature values\" , error ) call h5ltset_attribute_string_f ( gid , \"temperature\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"description\" , & \"Temperature spacing in log-10\" , error ) call h5ltset_attribute_string_f ( gid , \"dlogT\" , \"units\" , \"log10(keV)\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"description\" , & \"Minimum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmin\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"description\" , & \"Maximum temperature\" , error ) call h5ltset_attribute_string_f ( gid , \"tmax\" , \"units\" , \"keV\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"description\" , & \"Isotope mass of the beam and target species respectively\" , error ) call h5ltset_attribute_string_f ( gid , \"bt_amu\" , \"units\" , \"amu\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"description\" , & \"Beam-Target reaction rates for D-T nuclear reactions: fusion(energy, temperature, branch)\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"units\" , \"cm&#94;3/s\" , error ) call h5ltset_attribute_string_f ( gid , \"fusion\" , \"reaction\" , & \"D + T -> He4(3.5 MeV) + n(14.1 MeV)\" , error ) call h5gclose_f ( gid , error ) deallocate ( ebarr , tarr , fusion ) end subroutine write_bt_D_T","tags":"","loc":"proc/write_bt_d_t.html","title":"write_bt_D_T – FIDASIM"},{"text":"public subroutine print_default_namelist() Prints out the default settings as a namelist Arguments None Called By proc~~print_default_namelist~~CalledByGraph proc~print_default_namelist print_default_namelist program~generate_tables generate_tables program~generate_tables->proc~print_default_namelist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code print_default_namelist Source Code subroutine print_default_namelist !+ Prints out the default settings as a namelist write ( * , '(a)' ) \"!Default Atomic Table Settings\" write ( * , '(a)' ) \"&general_settings\" write ( * , '(a)' ) \"n_max = 12,    !Number of initial atomic energy levels\" write ( * , '(a)' ) \"m_max = 12,    !Number of final atomic energy levels\" write ( * , '(a)' ) \"tables_file = './atomic_tables.h5'\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Hydrogen Cross Sections\" write ( * , '(a)' ) \"&H_H_cross\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Electron Cross Sections\" write ( * , '(a)' ) \"&H_e_cross\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Impurity Cross Sections\" write ( * , '(a)' ) \"&H_Aq_cross\" write ( * , '(a)' ) \"q = 6,         !Impurity charge: Boron: 5, Carbon: 6, ...\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Deuterium-Deuterium Nuclear Cross Sections\" write ( * , '(a)' ) \"&D_D_cross\" write ( * , '(a)' ) \"nenergy = 200, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 8.0E2   !Maximum energy [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Hydrogen Reaction Rates\" write ( * , '(a)' ) \"&H_H_rates\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum ion temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum ion temperature [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Electron Reaction Rates\" write ( * , '(a)' ) \"&H_e_rates\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum electron temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum electron temperature [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Hydrogen-Impurity Reaction Rates\" write ( * , '(a)' ) \"&H_Aq_rates\" write ( * , '(a)' ) \"q = 6,         !Impurity charge: Boron: 5, Carbon: 6, ...\" write ( * , '(a)' ) \"mass = 12.011, !Impurity mass [amu]\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum ion temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum ion temperature [keV]\" write ( * , '(a)' ) \"/\" write ( * , '(a)' ) \"!Deuterium-Deuterium Nuclear Reaction Rates\" write ( * , '(a)' ) \"&D_D_rates\" write ( * , '(a)' ) \"nenergy = 100, !Number of energy values\" write ( * , '(a)' ) \"emin = 1.0E-3, !Minimum energy [keV]\" write ( * , '(a)' ) \"emax = 4.0E2,  !Maximum energy [keV]\" write ( * , '(a)' ) \"ntemp = 100,   !Number of temperature values\" write ( * , '(a)' ) \"tmin = 1.0E-3, !Minimum deuterium temperature [keV]\" write ( * , '(a)' ) \"tmax = 2.0E1   !Maximum deuterium temperature [keV]\" write ( * , '(a)' ) \"/\" end subroutine print_default_namelist","tags":"","loc":"proc/print_default_namelist.html","title":"print_default_namelist – FIDASIM"},{"text":"public interface bt_maxwellian Calculates the reaction rate coefficients given beam energy eb and target temperature T where the velocity distribution of the target is a Maxwellian Calls interface~~bt_maxwellian~~CallsGraph interface~bt_maxwellian bt_maxwellian proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~bt_maxwellian_eb bt_maxwellian_eb interface~bt_maxwellian->proc~bt_maxwellian_eb proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~simpsons_rule simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule proc~bt_maxwellian_eb->proc~simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~bt_maxwellian~~CalledByGraph interface~bt_maxwellian bt_maxwellian proc~write_bt_h_aq write_bt_H_Aq proc~write_bt_h_aq->interface~bt_maxwellian proc~write_bt_d_d write_bt_D_D proc~write_bt_d_d->interface~bt_maxwellian proc~write_bt_d_t write_bt_D_T proc~write_bt_d_t->interface~bt_maxwellian proc~write_bt_h_h write_bt_H_H proc~write_bt_h_h->interface~bt_maxwellian proc~write_bt_h_e write_bt_H_e proc~write_bt_h_e->interface~bt_maxwellian program~generate_tables generate_tables program~generate_tables->proc~write_bt_h_aq program~generate_tables->proc~write_bt_d_d program~generate_tables->proc~write_bt_h_h program~generate_tables->proc~write_bt_h_e Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bt_maxwellian_eb bt_maxwellian_n bt_maxwellian_n_m bt_maxwellian_q_n bt_maxwellian_q_n_m Module Procedures public subroutine bt_maxwellian_eb (fn, T, eb, am, ab, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] public subroutine bt_maxwellian_n (fn, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a, b) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] public subroutine bt_maxwellian_n_m (fnm, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fnm Arguments Type Intent Optional Attributes Name public function fnm(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate public subroutine bt_maxwellian_q_n (fqn, q, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqn Arguments Type Intent Optional Attributes Name public function fqn(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] public subroutine bt_maxwellian_q_n_m (fqnm, q, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqnm Arguments Type Intent Optional Attributes Name public function fqnm(a, b, c, d) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate","tags":"","loc":"interface/bt_maxwellian.html","title":"bt_maxwellian – FIDASIM"},{"text":"A basic libary for calculating matrix eigen-decompositions and inverses Used By module~~eigensystem~~UsedByGraph module~eigensystem eigensystem module~libfida libfida module~eigensystem->module~libfida program~fidasim fidasim module~libfida->program~fidasim Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables long float double ONE TWO ZERO XMACH_EPS MAXIT Functions comabs outerprod Subroutines RSWAP balance balback elmhes elmtrans Comdiv hqrvec hqr2 eigen swap ludcmp lubksb matinv Variables Type Visibility Attributes Name Initial integer, public, parameter :: long = kind(int(1)) integer, public, parameter :: float = kind(1.e0) integer, public, parameter :: double = kind(1.d0) real(kind=double), public, parameter :: ONE = 1.d0 real(kind=double), public, parameter :: TWO = 2.d0 real(kind=double), public, parameter :: ZERO = 0.d0 real(kind=double), public, parameter :: XMACH_EPS = 2.22d-16 integer, public, parameter :: MAXIT = 50 Functions public function comabs (ar, ai) Calculates absolute value of a complex number a Arguments Type Intent Optional Attributes Name real(kind=double) :: ar Real part of a real(kind=double) :: ai Imaginary part of a Return Value real(kind=double) Absolute value of a public function outerprod (a, b) Calculates outer product Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:) :: a real(kind=double), intent(in), dimension(:) :: b Return Value real(kind=double),\n  dimension(size(a),size(b)) Subroutines public subroutine RSWAP (a, b) Swaps values a and b Arguments Type Intent Optional Attributes Name real(kind=double) :: a real(kind=double) :: b public subroutine balance (n, mat, scal, low, high) Balances the matrix so that the rows with zero entries\noff the diagonal are isolated and the remaining columns and rows\nare resized to have one norm close to 1. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of mat real(kind=double) :: mat (0:n,0:n) n x n scaled matrix real(kind=double) :: scal (0:n) Contains isolated eigenvalue in the positions 0- low and high - n -1\n its other components contain the scaling factors for transforming mat integer, intent(out) :: low integer, intent(out) :: high public subroutine balback (n, low, high, scal, eivec) Reverses the balancing of balance for the eigenvectors Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of matrix integer, intent(in) :: low First nonzero row integer, intent(in) :: high Last nonzero row real(kind=double), intent(in) :: scal (0:n) Scaling data from balance real(kind=double), intent(inout) :: eivec (0:n,0:n) public subroutine elmhes (n, low, high, mat, perm) Transforms the matrix mat to upper Hessenberg form. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of mat integer, intent(in) :: low First nonzero row integer, intent(in) :: high Last nonzero row real(kind=double), intent(inout) :: mat (0:n,0:n) is stored in the lower triangle integer, intent(out) :: perm (0:n) Permutation vector for elmtrans public subroutine elmtrans (n, low, high, mat, perm, h) Elmtrans copies the Hessenberg matrix stored in mat to h Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Dimension of mat integer, intent(in) :: low First nonzero row integer, intent(in) :: high Last nonzero row real(kind=double), intent(in) :: mat (0:n,0:n) n x n input matrix integer, intent(in) :: perm (0:n) Permutation data from elmhes real(kind=double), intent(out) :: h (0:n,0:n) Hessenberg matrix public subroutine Comdiv (ar, ai, br, bi, cr, ci, rc) Performs complex division c = a / b Arguments Type Intent Optional Attributes Name real(kind=double) :: ar Real part of numerator real(kind=double) :: ai Imaginary part of numerator real(kind=double) :: br Real part of denominator real(kind=double) :: bi Imaginary part of denominator real(kind=double) :: cr Real part of quotient real(kind=double) :: ci Imaginary part of quotient integer :: rc return code public subroutine hqrvec (n, low, high, h, wr, wi, eivec, rc) Computes the eigenvectors for the eigenvalues found in hqr2 Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double) :: h (0:n,0:n) real(kind=double), intent(in) :: wr (0:n) real(kind=double), intent(in) :: wi (0:n) real(kind=double), intent(out) :: eivec (0:n,0:n) integer :: rc public subroutine hqr2 (n, low, high, h, wr, wi, eivec, cnt, rc) Computes the eigenvalues and (if vec = True) the eigenvectors\nof an  n * n upper Hessenberg matrix. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: low integer, intent(in) :: high real(kind=double), intent(out) :: h (0:n,0:n) real(kind=double), intent(out) :: wr (0:n) real(kind=double), intent(out) :: wi (0:n) real(kind=double), intent(out) :: eivec (0:n,0:n) integer, intent(out) :: cnt (0:n) integer, intent(out) :: rc public subroutine eigen (n, matrix, eigvec, eigval) The subroutine eigen  determines all eigenvalues and (if desired)\nall eigenvectors of a real square  n * n  matrix via the QR method\nin the version of Martin, Parlett, Peters, Reinsch and Wilkinson. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=double), intent(in), dimension(n,n) :: matrix real(kind=double), intent(out), dimension(n,n) :: eigvec real(kind=double), intent(out), dimension(n) :: eigval public subroutine swap (a, b) Swap arrays a and b Arguments Type Intent Optional Attributes Name real(kind=double), intent(inout), dimension(:) :: a real(kind=double), intent(inout), dimension(:) :: b public subroutine ludcmp (a, indx, d) Calculates LU decomposition Arguments Type Intent Optional Attributes Name real(kind=double), intent(inout), dimension(:,:) :: a integer, intent(out), dimension(:) :: indx real(kind=double), intent(out) :: d public subroutine lubksb (a, indx, b) Does LU back substitution Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:,:) :: a integer, intent(in), dimension(:) :: indx real(kind=double), intent(inout), dimension(:) :: b public subroutine matinv (a, b) Matrix inversion with LU-decomposition Arguments Type Intent Optional Attributes Name real(kind=double), intent(in), dimension(:,:) :: a real(kind=double), intent(out), dimension(:,:) :: b","tags":"","loc":"module/eigensystem.html","title":"eigensystem – FIDASIM"},{"text":"Uses: H5LT HDF5 hdf5_extra eigensystem utilities module~~libfida~~UsesGraph module~libfida libfida module~eigensystem eigensystem module~eigensystem->module~libfida module~hdf5_extra hdf5_extra module~hdf5_extra->module~libfida module~utilities utilities module~utilities->module~libfida H5LT H5LT H5LT->module~libfida H5LT->module~hdf5_extra HDF5 HDF5 HDF5->module~libfida HDF5->module~hdf5_extra omp_lib omp_lib omp_lib->module~utilities Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Main FIDASIM library Used By module~~libfida~~UsedByGraph module~libfida libfida program~fidasim fidasim module~libfida->program~fidasim Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables version charlim namelist_file nbif_type nbih_type nbit_type halo_type fida_type brems_type ntypes beam_ion thermal_ion e_amu H_1_amu H_2_amu B5_amu C6_amu mass_u e0 pi c0 h_planck lambda0 v2_to_E_per_amu n_stark stark_wavel stark_intens stark_pi stark_sigma nlevs n_halo_neutrate colrad_threshold halo_iter_dens nbi_outside beam_grid inter_grid fbm particles equil nbi tables npa spec_chords npa_chords inputs birth neut spec neutron fweight nweight Interfaces assignment(=) operator(+) operator(-) operator(*) operator(/) interpol_coeff interpol Derived Types InterpolCoeffs1D InterpolCoeffs2D BeamGrid InterpolationGrid Profiles LocalProfiles EMFields LocalEMFields Equilibrium FastIonDistribution FastIon FastIonParticles NeutralBeam AtomicCrossSection AtomicRates NuclearRates AtomicTables LineOfSight LOSElement LOSInters SpectralChords BoundedPlane NPADetector NPAProbability NPAChords NPAParticle NPAResults BirthProfile Spectra NeutronRate NeutralDensity FIDAWeights NPAWeights SimulationInputs ParticleTrack GyroSurface Functions pp_add pp_subtract lplp_add lplp_subtract ps_multiply sp_multiply ps_divide lps_multiply slp_multiply lps_divide ff_add ff_subtract fs_multiply sf_multiply fs_divide lflf_add lflf_subtract lfs_multiply slf_multiply lfs_divide approx_eq approx_ge approx_le cross_product in_boundary in_gyro_surface in_grid gyro_radius Subroutines print_banner fast_ion_assign npa_part_assign pp_assign lpp_assign plp_assign lplp_assign ff_assign lff_assign flf_assign lflf_assign read_inputs make_beam_grid read_beam read_chords read_npa read_equilibrium read_f read_mc read_distribution read_atomic_cross read_atomic_rates read_nuclear_rates read_tables write_beam_grid write_birth_profile write_dcx write_neutrals write_npa write_spectra write_neutrons write_fida_weights write_npa_weights read_neutrals tb_zyx line_basis plane_basis line_plane_intersect boundary_edge gyro_surface line_gyro_surface_intersect gyro_surface_coordinates gyro_trajectory gyro_range npa_gyro_range hit_npa_detector xyz_to_uvw uvw_to_xyz grid_intersect circle_grid_intersect get_indices get_position track interpol1D_coeff interpol1D_coeff_arr interpol2D_coeff interpol2D_coeff_arr interpol1D_arr interpol2D_arr interpol2D_2D_arr in_plasma get_plasma calc_perp_vectors get_fields get_distribution get_ep_denf store_neutrals store_births store_npa neut_rates get_neutron_rate get_beam_cx_prob get_rate_matrix colrad attenuate spectrum store_bes_photons store_fida_photons store_neutrons store_fw_photons_at_chan store_fw_photons get_nlaunch pitch_to_vec gyro_step gyro_correction mc_fastion mc_halo mc_nbi ndmc bremsstrahlung dcx halo fida_f fida_mc npa_f npa_mc neutron_f neutron_mc fida_weights_mc fida_weights_los npa_weights Variables Type Visibility Attributes Name Initial character(len=30), public :: version = '' FIDASIM version number integer, public, parameter :: charlim = 150 Defines character limit for files and directories character(len=charlim), public :: namelist_file Input namelist file integer, public, parameter :: nbif_type = 1 Identifier for full energy NBI neutral interaction integer, public, parameter :: nbih_type = 2 Identifier for half energy NBI neutral interaction integer, public, parameter :: nbit_type = 3 Identifier for third energy NBI neutral interaction integer, public, parameter :: halo_type = 4 Identifier for halo neutral interaction integer, public, parameter :: fida_type = 5 Identifier for fida neutral interaction integer, public, parameter :: brems_type = 6 Identifier for bremsstrahlung interaction. Acts as dummy type integer, public, parameter :: ntypes = 6 Number of different types of neutrals integer, public, parameter :: beam_ion = 1 Identifier for a beam ion integer, public, parameter :: thermal_ion = 2 Identifier for a thermal ion real(kind=Float64), public, parameter :: e_amu = 5.485799093287202d-4 Atomic mass of an electron [amu] real(kind=Float64), public, parameter :: H_1_amu = 1.00782504d0 Atomic mass of Hydrogen-1 [amu] real(kind=Float64), public, parameter :: H_2_amu = 2.0141017778d0 Atomic mass of Hydrogen-2 [amu] real(kind=Float64), public, parameter :: B5_amu = 10.81d0 Atomic mass of Boron [amu] real(kind=Float64), public, parameter :: C6_amu = 12.011d0 Atomic mass of Carbon [amu] real(kind=Float64), public, parameter :: mass_u = 1.6605402d-27 Atomic mass unit [kg] real(kind=Float64), public, parameter :: e0 = 1.60217733d-19 Electron charge [C] real(kind=Float64), public, parameter :: pi = 3.14159265358979323846264d0 Pi real(kind=Float64), public, parameter :: c0 = 2.99792458d+08 Speed of light [m/s] real(kind=Float64), public, parameter :: h_planck = 4.135667516d-15 Planck's constant [eV*s] real(kind=Float64), public, parameter :: lambda0 = 656.1d0 D-alpha emission line [nm] real(kind=Float64), public, parameter :: v2_to_E_per_amu = mass_u/(2.*e0*1.d3)*1.d-4 cm&#94;2/s&#94;2 to keV conversion factor integer, public, parameter :: n_stark = 15 Number of Stark lines real(kind=Float64), public, parameter, dimension(n_stark) :: stark_wavel = [-2.20200d-07, -1.65200d-07, -1.37700d-07, -1.10200d-07, -8.26400d-08, -5.51000d-08, -2.75600d-08, 0.00000d0, 2.75700d-08, 5.51500d-08, 8.27400d-08, 1.10300d-07, 1.38000d-07, 1.65600d-07, 2.20900d-07] Stark wavelengths [nm*m/V] real(kind=Float64), public, parameter, dimension(n_stark) :: stark_intens = [1.000d0, 18.00d0, 16.00d0, 1681.d0, 2304.d0, 729.0d0, 1936.d0, 5490.d0, 1936.d0, 729.0d0, 2304.d0, 1681.d0, 16.00d0, 18.00d0, 1.000d0] Stark Intensities integer, public, parameter, dimension(n_stark) :: stark_pi = [1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1] Pi line indicators integer, public, parameter, dimension(n_stark) :: stark_sigma = 1-stark_pi Sigma line indicators integer, public, parameter :: nlevs = 6 Number of atomic energy levels real(kind=Float64), public, parameter :: n_halo_neutrate = 20. Number of times to average halo H_H_cx real(kind=Float64), public :: colrad_threshold = 1.d6 colrad threshold real(kind=Float64), public, dimension(ntypes) :: halo_iter_dens = 0.d0 Keeps track of how of each generations halo density integer, public :: nbi_outside = 0 Keeps track of how many beam neutrals do not hit the beam_grid type( BeamGrid ), public, save :: beam_grid Variable containing beam grid definition type( InterpolationGrid ), public, save :: inter_grid Variable containing interpolation grid definition type( FastIonDistribution ), public, save :: fbm Variable containing the fast-ion distribution function type( FastIonParticles ), public, save :: particles Variable containing a MC fast-ion distribution type( Equilibrium ), public, save :: equil Variable containing the plasma parameters and fields type( NeutralBeam ), public, save :: nbi Variable containing the neutral beam geometry and settings type( AtomicTables ), public, save :: tables Variable containing the atomic tables type( NPAResults ), public, save :: npa Variable for storing the calculated NPA results type( SpectralChords ), public, save :: spec_chords Variable containing the spectral system definition type( NPAChords ), public, save :: npa_chords Variable containing the NPA system definition type( SimulationInputs ), public, save :: inputs Variable containing the simulation inputs type( BirthProfile ), public, save :: birth Variable for storing the calculated birth profile type( NeutralDensity ), public, save :: neut Variable for storing the calculated beam density type( Spectra ), public, save :: spec Variable for storing the calculated spectra type( NeutronRate ), public, save :: neutron Variable for storing the neutron rate type( FIDAWeights ), public, save :: fweight Variable for storing the calculated FIDA weights type( NPAWeights ), public, save :: nweight Variable for storing the calculated NPA weights Interfaces public interface assignment(=) Allows for assigning Profiles , LocalProfiles , EMFields , LocalEMFields , FastIon , and NPAParticle public subroutine pp_assign (p1, p2) Defines how to assign Profiles types to eachother Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 public subroutine lpp_assign (p1, p2) Defines how to assign a Profiles type to a LocalProfiles type Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 public subroutine plp_assign (p1, p2) Defines how to assign a LocalProfiles type to a Profiles type Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine lplp_assign (p1, p2) Defines how to assign LocalProfiles types to eachother Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine ff_assign (p1, p2) Defines how to assign EMFields types to eachother Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 public subroutine lff_assign (p1, p2) Defines how to assign a EMFields type to a LocalEMFields type Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 public subroutine flf_assign (p1, p2) Defines how to assign a LocalEMFields type to a EMFields type Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine lflf_assign (p1, p2) Defines how to assign LocalEMFields types to eachother Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine fast_ion_assign (p1, p2) Defines how to assign FastIon types to eachother Arguments Type Intent Optional Attributes Name type( FastIon ), intent(out) :: p1 type( FastIon ), intent(in) :: p2 public subroutine npa_part_assign (p1, p2) Defines how to assign NPAParticle types to eachother Arguments Type Intent Optional Attributes Name type( NPAParticle ), intent(out) :: p1 type( NPAParticle ), intent(in) :: p2 public interface operator(+) Allows for adding Profiles , LocalProfiles , EMFields , and LocalEMFields public function pp_add (p1, p2) result(p3) Defines how to add two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_add (p1, p2) result(p3) Defines how to add two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ff_add (p1, p2) result(p3) Defines how to add two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function lflf_add (p1, p2) result(p3) Defines how to add two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) public interface operator(-) Allows for subtracting Profiles , LocalProfiles , EMFields , and LocalEMFields public function pp_subtract (p1, p2) result(p3) Defines how to subtract two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_subtract (p1, p2) result(p3) Defines how to subtract two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ff_subtract (p1, p2) result(p3) Defines how to subtract two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function lflf_subtract (p1, p2) result(p3) Defines how to subtract two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) public interface operator(*) Allows for multiplying Profiles , LocalProfiles , EMFields , and LocalEMFields by scalars public function sp_multiply (real_scalar, p1) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( Profiles ), intent(in) :: p1 Return Value type( Profiles ) public function ps_multiply (p1, real_scalar) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_multiply (p1, real_scalar) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function slp_multiply (real_scalar, p1) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalProfiles ), intent(in) :: p1 Return Value type( LocalProfiles ) public function sf_multiply (real_scalar, p1) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( EMFields ), intent(in) :: p1 Return Value type( EMFields ) public function fs_multiply (p1, real_scalar) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) public function lfs_multiply (p1, real_scalar) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields ) public function slf_multiply (real_scalar, p1) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalEMFields ), intent(in) :: p1 Return Value type( LocalEMFields ) public interface operator(/) Allows for dividing Profiles , LocalProfiles , EMFields , and LocalEMFields by scalars public function ps_divide (p1, real_scalar) result(p3) Defines how to divide Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_divide (p1, real_scalar) result(p3) Defines how to divide LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function fs_divide (p1, real_scalar) result(p3) Defines how to divide EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) public function lfs_divide (p1, real_scalar) result(p3) Defines how to divide LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields ) public interface interpol_coeff Calculates linear interpolation coefficients public subroutine interpol1D_coeff (xmin, dx, nx, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa value real(kind=Float64), intent(in) :: dx Absissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol1D_coeff_arr (x, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol2D_coeff (xmin, dx, nx, ymin, dy, ny, xout, yout, c, err) Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa real(kind=Float64), intent(in) :: dx Abscissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: ymin Minimum ordinate real(kind=Float64), intent(in) :: dy Ordinate spacing integer, intent(in) :: ny Number of ordinates points real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol2D_coeff_arr (x, y, xout, yout, c, err) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in), dimension(:) :: y Ordinate values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public interface interpol Performs linear/bilinear interpolation public subroutine interpol1D_arr (x, y, xout, yout, err, coeffs) Performs linear interpolation on a uniform 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of y real(kind=Float64), intent(in), dimension(:) :: y Values at abscissa values x : y(x) real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(out) :: yout Interpolant: y(xout) integer, intent(out), optional :: err Error code type( InterpolCoeffs1D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol2D_arr (x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:) :: z Values at the abscissa/ordinates: z(x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out) :: zout Interpolant: z(xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol2D_2D_arr (x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid of 2D arrays z(:,:,x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:,:,:) :: z Values at the abscissa/ordinates: z(:,:,x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out), dimension(:,:) :: zout Interpolant: z(:,:,xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients Derived Types type, public :: InterpolCoeffs1D Linear Interpolation Coefficients and indices Components Type Visibility Attributes Name Initial integer, public :: i = 0 Index of position right before xout real(kind=Float64), public :: b1 = 0.d0 Coefficient for y(i) term real(kind=Float64), public :: b2 = 0.d0 Coefficient for y(i+1) term type, public :: InterpolCoeffs2D 2D Linear Interpolation Coefficients and indices Components Type Visibility Attributes Name Initial integer, public :: i = 0 Index of abscissa before xout integer, public :: j = 0 Index of ordinate before yout real(kind=Float64), public :: b11 = 0.d0 Coefficient for z(i,j) term real(kind=Float64), public :: b12 = 0.d0 Coefficient for z(i,j+1) term real(kind=Float64), public :: b21 = 0.d0 Coefficient for z(i+1,j) term real(kind=Float64), public :: b22 = 0.d0 Coefficient for z(i+1,j+1) term type, public :: BeamGrid Defines a 3D grid for neutral beam calculations Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nx Number of cells in the x direction integer(kind=Int32), public :: ny Number of cells in the y direction integer(kind=Int32), public :: nz Number of cells in the z direction real(kind=Float64), public :: xmin Minimum x value real(kind=Float64), public :: xmax Maximum x value real(kind=Float64), public :: ymin Minimum y value real(kind=Float64), public :: ymax Maximum y value real(kind=Float64), public :: zmin Minimum z value real(kind=Float64), public :: zmax Maximum z value real(kind=Float64), public :: alpha Tait-Bryan angle for a rotation about z [radians] real(kind=Float64), public :: beta Tait-Bryan angle for a rotation about y' [radians] real(kind=Float64), public :: gamma Tait-Bryan angle for a rotation about x\" [radians] real(kind=Float64), public :: drmin Minimum cell spacing: min(dx,dy,dz) real(kind=Float64), public :: dv Cell volume [cm&#94;3] real(kind=Float64), public :: volume Grid volume [cm&#94;3] integer(kind=Int32), public :: ntrack Maximum number of cell for particle tracking integer(kind=Int32), public :: ngrid Number of cells real(kind=Float64), public, dimension(3) :: origin Origin of beam grid in machine coordinates real(kind=Float64), public, dimension(3) :: center Center of beam grid in beam coordinates real(kind=Float64), public, dimension(3) :: dr Cell spacings [dx, dy, dz] real(kind=Float64), public, dimension(3) :: lwh Grid [length(x), width(y), height(z)] real(kind=Float64), public, dimension(3,3) :: basis Beam grid basis for converting from beam coordinates(xyz)\nto machine coordinates(uvw): (\\uvw = B*xyz + origin) real(kind=Float64), public, dimension(3,3) :: inv_basis Inverse basis for reverse transformation: (\\xyz = B&#94;{-1}*(uvw - origin)) real(kind=Float64), public, dimension(:), allocatable :: xc x positions of cell centers real(kind=Float64), public, dimension(:), allocatable :: yc y positions of cell centers real(kind=Float64), public, dimension(:), allocatable :: zc z positions of cell centers type, public :: InterpolationGrid Defines a 2D R-Z grid for interpolating plasma parameters and fields Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nr Number of Radii integer(kind=Int32), public :: nz Number of Z values real(kind=Float64), public :: dr Radial spacing [cm] real(kind=Float64), public :: dz Vertical spacing [cm] real(kind=Float64), public :: da Grid element area [cm&#94;2] real(kind=Float64), public, dimension(:), allocatable :: r Radii values [cm] real(kind=Float64), public, dimension(:), allocatable :: z Z values [cm] real(kind=Float64), public, dimension(:,:), allocatable :: r2d 2D R grid [cm] real(kind=Float64), public, dimension(:,:), allocatable :: z2d 2D Z grid [cm] type, public :: Profiles Torodial symmetric plasma parameters at a given R-Z Components Type Visibility Attributes Name Initial real(kind=Float64), public :: dene = 0.d0 Electron density [cm&#94;{-3}] real(kind=Float64), public :: denp = 0.d0 Ion density [cm&#94;{-3}] real(kind=Float64), public :: denimp = 0.d0 Impurity density [cm&#94;{-3}] real(kind=Float64), public :: denf = 0.d0 Fast-ion density [cm&#94;{-3}] real(kind=Float64), public :: te = 0.d0 Electron temperature [kev] real(kind=Float64), public :: ti = 0.d0 Ion temperature [kev] real(kind=Float64), public :: zeff = 0.d0 Effective Nuclear Charge real(kind=Float64), public :: vr = 0.d0 Plasma rotation in radial direction real(kind=Float64), public :: vt = 0.d0 Plasma rotation in torodial/phi direction real(kind=Float64), public :: vz = 0.d0 Plasma rotation in z direction type, public, extends( Profiles ) :: LocalProfiles Plasma parameters at given position Components Type Visibility Attributes Name Initial real(kind=Float64), public :: dene = 0.d0 Electron density [cm&#94;{-3}] real(kind=Float64), public :: denp = 0.d0 Ion density [cm&#94;{-3}] real(kind=Float64), public :: denimp = 0.d0 Impurity density [cm&#94;{-3}] real(kind=Float64), public :: denf = 0.d0 Fast-ion density [cm&#94;{-3}] real(kind=Float64), public :: te = 0.d0 Electron temperature [kev] real(kind=Float64), public :: ti = 0.d0 Ion temperature [kev] real(kind=Float64), public :: zeff = 0.d0 Effective Nuclear Charge real(kind=Float64), public :: vr = 0.d0 Plasma rotation in radial direction real(kind=Float64), public :: vt = 0.d0 Plasma rotation in torodial/phi direction real(kind=Float64), public :: vz = 0.d0 Plasma rotation in z direction logical, public :: in_plasma = .False. Indicates whether plasma parameters are valid/known logical, public :: machine_coords = .False. Indicates whether vectors are in machine coordinates real(kind=Float64), public, dimension(3) :: pos = 0.d0 Position in beam grid coordinates real(kind=Float64), public, dimension(3) :: uvw = 0.d0 Position in machine coordinates real(kind=Float64), public, dimension(3) :: vrot = 0.d0 Plasma rotation in beam grid coordinates type( InterpolCoeffs2D ), public :: c Linear Interpolation Coefficients and indicies for interpolation at pos type, public :: EMFields Torodial symmetric electro-magnetic fields at given R-Z Components Type Visibility Attributes Name Initial real(kind=Float64), public :: br = 0.d0 Radial magnetic field [T] real(kind=Float64), public :: bt = 0.d0 Torodial magnetic field [T] real(kind=Float64), public :: bz = 0.d0 Vertical magnetic field [T] real(kind=Float64), public :: er = 0.d0 Radial electric field [V/m] real(kind=Float64), public :: et = 0.d0 Torodial electric field [V/m] real(kind=Float64), public :: ez = 0.d0 Vertical electric field [V/m] real(kind=Float64), public :: dbr_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbr_dz = 0.d0 Vertical derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbt_dr = 0.d0 Radial derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbt_dz = 0.d0 Vertical derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbz_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbz_dz = 0.d0 Vertical derivative of the vertical magnetic field [T/m] type, public, extends( EMFields ) :: LocalEMFields Electro-magnetic fields at given position Components Type Visibility Attributes Name Initial real(kind=Float64), public :: br = 0.d0 Radial magnetic field [T] real(kind=Float64), public :: bt = 0.d0 Torodial magnetic field [T] real(kind=Float64), public :: bz = 0.d0 Vertical magnetic field [T] real(kind=Float64), public :: er = 0.d0 Radial electric field [V/m] real(kind=Float64), public :: et = 0.d0 Torodial electric field [V/m] real(kind=Float64), public :: ez = 0.d0 Vertical electric field [V/m] real(kind=Float64), public :: dbr_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbr_dz = 0.d0 Vertical derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbt_dr = 0.d0 Radial derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbt_dz = 0.d0 Vertical derivative of the torodial magnetic field [T/m] real(kind=Float64), public :: dbz_dr = 0.d0 Radial derivative of the radial magnetic field [T/m] real(kind=Float64), public :: dbz_dz = 0.d0 Vertical derivative of the vertical magnetic field [T/m] logical, public :: in_plasma = .False. Indicates whether fields are valid/known logical, public :: machine_coords = .False. Indicates whether vectors are in machine coordinates real(kind=Float64), public :: b_abs = 0.d0 Magnitude of magnetic field real(kind=Float64), public :: e_abs = 0.d0 Magnitude of electrin field real(kind=Float64), public, dimension(3) :: pos = 0.d0 Position in beam grid coordinates real(kind=Float64), public, dimension(3) :: uvw = 0.d0 Position in machine coordinates real(kind=Float64), public, dimension(3) :: b_norm = 0.d0 Direction of magnetic field in beam grid coordinates real(kind=Float64), public, dimension(3) :: a_norm = 0.d0 Vector perpendicular to b_norm and c_norm real(kind=Float64), public, dimension(3) :: c_norm = 0.d0 Vector perpendicular to b_norm and a_norm real(kind=Float64), public, dimension(3) :: e_norm = 0.d0 Direction of electric field in beam grid coordinates type( InterpolCoeffs2D ), public :: c Linear Interpolation Coefficients and indicies for interpolation at pos type, public :: Equilibrium MHD Equilbrium Components Type Visibility Attributes Name Initial type( EMFields ), public, dimension(:,:), allocatable :: fields Electro-magnetic fields at points defined in inter_grid type( Profiles ), public, dimension(:,:), allocatable :: plasma Plasma parameters at points defined in inter_grid real(kind=Float64), public, dimension(:,:), allocatable :: mask Indicates whether fields and plasma are well-defined at points defined in inter_grid type, public :: FastIonDistribution Defines a Guiding Center Fast-ion Distribution Function: F(E,p,R,Z) Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nenergy Number of energies integer(kind=Int32), public :: npitch Number of pitches integer(kind=Int32), public :: nr Number of radii integer(kind=Int32), public :: nz Number of z values real(kind=Float64), public :: dE Energy spacing [keV] real(kind=Float64), public :: dp Pitch spacing real(kind=Float64), public :: dr Radial spacing [cm] real(kind=Float64), public :: dz Z spacing [cm] real(kind=Float64), public :: emin Minimum energy [keV] real(kind=Float64), public :: emax Maximum energy [keV] real(kind=Float64), public :: e_range Energy interval length [keV] real(kind=Float64), public :: pmin Minimum pitch real(kind=Float64), public :: pmax Maximum pitch real(kind=Float64), public :: p_range Pitch interval length real(kind=Float64), public :: n_tot = 0.d0 Total Number of fast-ions real(kind=Float64), public, dimension(:), allocatable :: energy Energy values [keV] real(kind=Float64), public, dimension(:), allocatable :: pitch Pitch w.r.t. the magnetic field real(kind=Float64), public, dimension(:), allocatable :: r Radius [cm] real(kind=Float64), public, dimension(:), allocatable :: z Z [cm] real(kind=Float64), public, dimension(:,:), allocatable :: denf Fast-ion density defined on the inter_grid : denf(R,Z) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: f Fast-ion distribution function defined on the inter_grid : F(E,p,R,Z) type, public :: FastIon Defines a fast-ion Components Type Visibility Attributes Name Initial logical, public :: cross_grid = .False. Indicates whether the fast-ion crosses the beam_grid real(kind=Float64), public :: r = 0.d0 Radial position of fast-ion [cm] real(kind=Float64), public :: z = 0.d0 Vertical position of fast-ion [cm] real(kind=Float64), public :: phi_enter = 0.d0 Torodial/phi position where fast-ion enters the beam_grid [radians] real(kind=Float64), public :: delta_phi = 2*pi Angle subtended by the beam_grid at (r,z) real(kind=Float64), public :: energy = 0.d0 Energy [keV] real(kind=Float64), public :: pitch = 0.d0 Pitch w.r.t. the magnetic field real(kind=Float64), public :: vabs = 0.d0 Speed [cm/s] real(kind=Float64), public :: vr = 0.d0 Radial velocity [cm/s] real(kind=Float64), public :: vt = 0.d0 Torodial velocity [cm/s] real(kind=Float64), public :: vz = 0.d0 Z velocity [cm/s] real(kind=Float64), public :: weight = 0.d0 Particle weight: How many fast-ions does particle represent. integer(kind=Int32), public :: class = 0 Orbit class id type, public :: FastIonParticles Collection of fast-ion particles Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nparticle = 0 Number of particles integer(kind=Int32), public :: nclass = 1 Number of orbit classes type( FastIon ), public, dimension(:), allocatable :: fast_ion Fast-ion particles type, public :: NeutralBeam Defines a neutral beam with +x defined to be into the plasma Components Type Visibility Attributes Name Initial character(len=25), public :: name = '' Beam name integer, public :: shape Beam source shape 1=\"rectangular\", 2=\"circular\" real(kind=Float64), public :: widy Half width of source in y direction real(kind=Float64), public :: widz Half height of source in z direction real(kind=Float64), public :: focy Focal length in y direction real(kind=Float64), public :: focz Focal length in z direction real(kind=Float64), public :: einj NBI voltage  [kV] real(kind=Float64), public :: pinj NBI power    [MW] real(kind=Float64), public :: vinj NBI velocity [cm/s] real(kind=Float64), public :: alpha Z rotation not same as beam_grid alpha real(kind=Float64), public :: beta Tilt rotation not same as beam_grid beta real(kind=Float64), public, dimension(3) :: divy Energy dependent divergence in y direction real(kind=Float64), public, dimension(3) :: divz Energy dependent divergence in z direction real(kind=Float64), public, dimension(3) :: current_fractions Fractions of full, half, and third energy neutrals real(kind=Float64), public, dimension(3) :: src Position of source in beam grid coordinates [cm] real(kind=Float64), public, dimension(3) :: axis Beam centerline integer, public :: naperture Number of beam apertures integer, public, dimension(:), allocatable :: ashape Aperture shape 1=\"rectangular\", 2=\"circular\" real(kind=Float64), public, dimension(:), allocatable :: awidy Half width of the aperture(s) in y direction real(kind=Float64), public, dimension(:), allocatable :: awidz Half height of the aperture(s) in z direction real(kind=Float64), public, dimension(:), allocatable :: aoffy Horizontal (y) offset of the aperture(s) relative to the beam centerline [cm] real(kind=Float64), public, dimension(:), allocatable :: aoffz Vertical (z) offset of the aperture(s) relative to the beam centerline [cm] real(kind=Float64), public, dimension(:), allocatable :: adist Distance from the center of the beam source grid to the aperture(s) plane [cm] real(kind=Float64), public, dimension(3,3) :: basis Beam basis for converting from centerline coordinates to beam grid coordinates real(kind=Float64), public, dimension(3,3) :: inv_basis Inverse basis for reverse transfomation type, public :: AtomicCrossSection Defines a n/m-resolved atomic cross section table Components Type Visibility Attributes Name Initial integer, public :: nenergy = 1 Number of beam energies real(kind=Float64), public :: logemin = 0.d0 Log-10 minimum energy real(kind=Float64), public :: logemax = 0.d0 Log-10 maximum energy integer, public :: n_max = nlevs Number of initial atomic energy levels integer, public :: m_max = nlevs Number of final atomic energy levels real(kind=Float64), public :: dlogE = 0.d0 Log-10 energy spacing real(kind=Float64), public :: minlog_cross Log-10 minimum cross section real(kind=Float64), public, dimension(:,:,:), allocatable :: log_cross Log-10 cross sections type, public :: AtomicRates Defines an atomic table for populating and de-populating reaction rates Components Type Visibility Attributes Name Initial integer, public :: nenergy = 1 Number of beam energies real(kind=Float64), public :: logemin = 0.d0 Log-10 minimum energy real(kind=Float64), public :: logemax = 0.d0 Log-10 maximum energy integer, public :: ntemp = 1 Number of target temperatures real(kind=Float64), public :: logtmin = 0.d0 Log-10 minimum temperature real(kind=Float64), public :: logtmax = 0.d0 Log-10 maximum temperature integer, public :: n_max = nlevs Number of initial atomic energy levels integer, public :: m_max = nlevs Number of final atomic energy levels real(kind=Float64), public :: dlogE = 0.d0 Log-10 energy spacing real(kind=Float64), public :: dlogT = 0.d0 Log-10 temperature spacing real(kind=Float64), public :: minlog_pop = 0.d0 Log-10 minimum reaction rates for populating transistions real(kind=Float64), public :: minlog_depop = 0.d0 Log-10 minimum reaction rates for de-populating transistions real(kind=Float64), public, dimension(2) :: ab = 0.d0 Atomic mass of beam and thermal ions respectively [amu] real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: log_pop Log-10 reaction rates for populating transistions real(kind=Float64), public, dimension(:,:,:,:), allocatable :: log_depop Log-10 reaction rates for de-populating transistions type, public :: NuclearRates Nuclear reaction rates Components Type Visibility Attributes Name Initial integer, public :: nbranch = 1 Number of reaction branches integer, public :: nenergy = 1 Number of beam energies real(kind=Float64), public :: logemin = 0.d0 Log-10 minimum energy real(kind=Float64), public :: logemax = 0.d0 Log-10 maximum energy integer, public :: ntemp = 1 Number of target temperatures real(kind=Float64), public :: logtmin = 0.d0 Log-10 minimum temperature real(kind=Float64), public :: logtmax = 0.d0 Log-10 maximum temperature real(kind=Float64), public :: dlogE = 0.d0 Log-10 energy spacing real(kind=Float64), public :: dlogT = 0.d0 Log-10 temperature spacing real(kind=Float64), public :: minlog_rate = 0.d0 Log-10 minimum reaction rate real(kind=Float64), public, dimension(2) :: bt_amu = 0.d0 Isotope mass of beam and thermal ions respectively [amu] real(kind=Float64), public, dimension(:,:,:), allocatable :: log_rate Log-10 reaction rates: log_rate(energy, temperature, branch) type, public :: AtomicTables Atomic tables for various types of interactions Components Type Visibility Attributes Name Initial type( AtomicCrossSection ), public :: H_H_cx Hydrogen-Hydrogen charge exchange n/m-resolved cross sections type( AtomicRates ), public :: H_H Hydrogen-Hydrogen reaction rates type( AtomicRates ), public :: H_e Hydrogen-Electron reaction rates type( AtomicRates ), public :: H_Aq Hydrogen-Impurity reaction rates real(kind=Float64), public, dimension(nlevs,nlevs) :: einstein Einstein coefficients for spontaneous emission type( NuclearRates ), public :: D_D Deuterium-Deuterium reaction rates type, public :: LineOfSight Defines a line of sight Components Type Visibility Attributes Name Initial real(kind=Float64), public :: sigma_pi = 1.d0 Ratio of sigma to pi line intensity real(kind=Float64), public :: spot_size = 0.d0 Radius of spot size [cm] real(kind=Float64), public, dimension(3) :: lens = 0.d0 Lens location in beam grid coordinates real(kind=Float64), public, dimension(3) :: axis = 0.d0 Optical axis in beam grid coordinates type, public :: LOSElement Defines a element of a line of sight and cell intersection Components Type Visibility Attributes Name Initial integer, public :: id Line of sight index real(kind=Float64), public :: length Length of crossing type, public :: LOSInters Defines the channels that intersect a cell Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 Number of channels that intersect type( LOSElement ), public, dimension(:), allocatable :: los_elem Array of crossing type, public :: SpectralChords Defines an spectral diagnostic system Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 Number of channels type( LineOfSight ), public, dimension(:), allocatable :: los Line of sight array real(kind=Float64), public, dimension(:), allocatable :: radius Radius of each line of sight type( LOSInters ), public, dimension(:,:,:), allocatable :: inter Array of LOS intersections with beam_grid type, public :: BoundedPlane Defines a plane with a circular or rectangular boundary Components Type Visibility Attributes Name Initial integer, public :: shape = 0 Boundary shape 1=\"Rectangular\", 2=\"circular\" real(kind=Float64), public :: hh = 0.d0 Half height of boundary [cm] real(kind=Float64), public :: hw = 0.d0 Half width of boundary [cm] real(kind=Float64), public, dimension(3) :: origin = 0.d0 Origin of plane in machine coordinates real(kind=Float64), public, dimension(3,3) :: basis = 0.d0 Basis vectors basis(:,1) = u_1 is plane normal real(kind=Float64), public, dimension(3,3) :: inv_basis = 0.d0 Inverse basis type, public :: NPADetector Defines a NPA detector Components Type Visibility Attributes Name Initial type( BoundedPlane ), public :: detector Detecting plane of NPA detector type( BoundedPlane ), public :: aperture Aperture plane of NPA detector type, public :: NPAProbability Type to contain the probability of hitting a NPA detector Components Type Visibility Attributes Name Initial real(kind=Float64), public :: p = 0.d0 Hit probability real(kind=Float64), public :: pitch = -2.d0 Pitch real(kind=Float64), public, dimension(3) :: eff_rd = 0.d0 Effective position of detector real(kind=Float64), public, dimension(3) :: dir = 0.d0 Trajectory direction type, public :: NPAChords Defines a NPA system Components Type Visibility Attributes Name Initial integer, public :: nchan = 0 Number of channels type( NPADetector ), public, dimension(:), allocatable :: det NPA detector array real(kind=Float64), public, dimension(:), allocatable :: radius Radius [cm] logical, public, dimension(:,:,:), allocatable :: hit Indicates whether a particle can hit any NPA detector from a grid cell: hit(x,y,z) type( NPAProbability ), public, dimension(:,:,:,:), allocatable :: phit Probability of hitting a detector from a grid cell: phit(x,y,z,chan) type, public :: NPAParticle Defines a NPA particle Components Type Visibility Attributes Name Initial integer, public :: detector = 0 Detector NPA particle hit real(kind=Float64), public :: xi = 0.d0 Initial x position real(kind=Float64), public :: yi = 0.d0 Initial y position real(kind=Float64), public :: zi = 0.d0 Initial z position real(kind=Float64), public :: xf = 0.d0 Final x position real(kind=Float64), public :: yf = 0.d0 Final y position real(kind=Float64), public :: zf = 0.d0 Final z position real(kind=Float64), public :: weight = 0.d0 NPA particle weight real(kind=Float64), public :: energy = 0.d0 Birth Energy [keV] real(kind=Float64), public :: pitch = 0.d0 Birth Pitch type, public :: NPAResults MC NPA result structure Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: nchan = 0 Number of NPA channels integer(kind=Int32), public :: npart = 0 Number of particles that hit a detector integer(kind=Int32), public :: nmax = 1000000 Maximum allowed number of particles grows if necessary integer(kind=Int32), public :: nenergy = 100 Number of energy values type( NPAParticle ), public, dimension(:), allocatable :: part Array of NPA particles real(kind=Float64), public, dimension(:), allocatable :: energy Energy array [keV] real(kind=Float64), public, dimension(:,:,:), allocatable :: flux Neutral particle flux: flux(energy,chan, orbit_type) [neutrals/(s*dE)] type, public :: BirthProfile Birth profile structure Components Type Visibility Attributes Name Initial integer, public :: cnt = 1 Particle counter integer, public, dimension(:), allocatable :: neut_type Particle birth type (1=Full, 2=Half, 3=Third) real(kind=Float64), public, dimension(:,:), allocatable :: ri Particle birth position [cm] real(kind=Float64), public, dimension(:,:), allocatable :: vi Particle birth velocity [cm/s] integer, public, dimension(:,:), allocatable :: ind Particle beam_grid indices real(kind=Float64), public, dimension(:,:,:,:), allocatable :: dens Birth density: dens(neutral_type,x,y,z) [fast-ions/(s*cm&#94;3)] type, public :: Spectra Spectra storage structure Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:), allocatable :: brems Bremsstruhlung: brems(lambda,chan) real(kind=Float64), public, dimension(:,:,:), allocatable :: bes Beam emission: bes(lambda,chan,neutral_type) real(kind=Float64), public, dimension(:,:,:), allocatable :: fida FIDA emission: fida(lambda,chan,orbit_type) type, public :: NeutronRate Neutron storage structure Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:), allocatable :: rate Neutron rate: rate(orbit_type) [neutrons/sec] real(kind=Float64), public, dimension(:,:,:,:), allocatable :: weight Neutron rate weight: weight(E,p,R,Z) type, public :: NeutralDensity Neutral density structure Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: dens Neutral density: dens(lev,neutral_type,x,y,z) type, public :: FIDAWeights FIDA weights structure Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:,:), allocatable :: mean_f Estimate of mean fast-ion distribution function \"seen\" by LOS: mean_f(E,p,chan) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: weight FIDA weight function: weight(lambda,E,p,chan) type, public :: NPAWeights NPA weights structure Components Type Visibility Attributes Name Initial real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: attenuation Attenuation fraction: attenuation(E,x,y,z,chan) real(kind=Float64), public, dimension(:,:,:,:,:), allocatable :: cx Charge Exchange reaction rates: cx(E,x,y,z,chan) real(kind=Float64), public, dimension(:,:,:,:), allocatable :: emissivity Emissivity: emissivity(x,y,z,chan) [neutrals/(s*dV)] real(kind=Float64), public, dimension(:,:,:), allocatable :: weight NPA weight function: weight(E,p,chan) [neutrals/(s fast-ion dE*dP)] real(kind=Float64), public, dimension(:,:), allocatable :: flux Neutral particle flux: flux(E,chan) [neutrals/(s*dE)] type, public :: SimulationInputs Simulation settings structure Components Type Visibility Attributes Name Initial integer(kind=Int32), public :: shot_number Shot Number real(kind=Float64), public :: time Shot time [s] character(len=charlim), public :: runid = '' FIDASIM run ID character(len=charlim), public :: result_dir = '' Result directory character(len=charlim), public :: tables_file = '' Atomic tables file character(len=charlim), public :: geometry_file = '' FIDASIM input file containing geometric quantities character(len=charlim), public :: equilibrium_file = '' FIDASIM input file containing the plasma parameters and fields character(len=charlim), public :: distribution_file = '' FIDASIM input file containing the fast-ion distribution character(len=charlim), public :: neutrals_file = '' FIDASIM output/input file containing beam neutral density.\n Used when load_neutrals is set. integer(kind=Int64), public :: n_fida Number of FIDA mc markers integer(kind=Int64), public :: n_npa Number of NPA mc markers integer(kind=Int64), public :: n_nbi Number of neutral beam mc markers integer(kind=Int64), public :: n_dcx Number of direct charge exchange (DCX) mc markers integer(kind=Int64), public :: n_halo Number of halo mc markers integer(kind=Int64), public :: n_birth Number of birth particles per n_nbi integer(kind=Int32), public :: calc_spec Calculate spectra: 0 = off, 1=on integer(kind=Int32), public :: calc_brems Calculate bremmstruhlung: 0 = off, 1=on integer(kind=Int32), public :: calc_bes Calculate BES: 0 = off, 1=on integer(kind=Int32), public :: calc_fida Calculate FIDA: 0 = off, 1=on integer(kind=Int32), public :: load_neutrals Load neutrals from file: 0 = off, 1=on integer(kind=Int32), public :: calc_npa Calculate NPA: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: calc_fida_wght Calculate FIDA weight: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: calc_npa_wght Calculate NPA weights: 0 = off, 1=on, 2=on++ integer(kind=Int32), public :: calc_birth Calculate birth profile: 0 = off, 1=on integer(kind=Int32), public :: calc_neutron Calculate neutron flux: 0 = off, 1=on integer(kind=Int32), public :: no_flr Turns off Finite Larmor Radius effects: 0=off, 1=on integer(kind=Int32), public :: dump_dcx Output DCX density and spectra: 0 = off, 1=on integer(kind=Int32), public :: verbose real(kind=Float64), public :: ab Atomic mass of beam neutrals integer(kind=Int32), public :: impurity_charge Impurity proton number real(kind=Float64), public :: ai Atomic mass of thermal ions integer(kind=Int32), public :: dist_type Type of fast-ion distribution integer(kind=Int32), public :: nlambda Number of wavelength to calculate real(kind=Float64), public :: dlambda Wavelength spacing [nm] real(kind=Float64), public :: lambdamin Minimum wavelength [nm] real(kind=Float64), public :: lambdamax Maximum wavelength [nm] integer(kind=Int32), public :: ne_wght Number of energies in weight functions integer(kind=Int32), public :: np_wght Number of pitches in weight functions integer(kind=Int32), public :: nphi_wght Number of gyro-angles to average over in weight functions integer(kind=Int32), public :: nlambda_wght Number of wavelength to calculate in weight functions real(kind=Float64), public :: emax_wght Maximum energy in weight functions [keV] real(kind=Float64), public :: lambdamin_wght Minimum wavelength in weight functions [nm] real(kind=Float64), public :: lambdamax_wght Maximum wavelength in weight functions [nm] type, public :: ParticleTrack Stores properties seen when traveling through a 3D grid Components Type Visibility Attributes Name Initial real(kind=Float64), public :: time = 0.d0 Time/distance/... in cell real(kind=Float64), public :: flux = 0.d0 Flux/density/... in cell integer(kind=Int32), public, dimension(3) :: ind = 0 Indices of cell real(kind=Float64), public, dimension(3) :: pos = 0.d0 Midpoint of track in cell [cm] type, public :: GyroSurface Surface containing the fast-ion velocity vectors for all values of the\n gyro-angle. It takes the form of a hyperboloid \n (x(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(cos(\\gamma + \\pi/2) - \\omega_i t sin(\\gamma + \\pi/2)) \n (y(\\gamma,t) = \\alpha \\sqrt{1-\\rm{pitch}&#94;2}(sin(\\gamma + \\pi/2) + \\omega_i t cos(\\gamma + \\pi/2)) \n (z(\\gamma,t) = \\alpha \\omega_i \\rm{pitch} t\n where \\gamma is the gyro-angle, \\omega_i is the ion\n gyro-frequency and \\alpha = V/\\omega_i  Components Type Visibility Attributes Name Initial real(kind=Float64), public :: v = 0.d0 Particle speed real(kind=Float64), public :: omega = 0.d0 Ion gyro-frequency real(kind=Float64), public, dimension(3) :: axes Semi-axes of the hyperboloid, i.e. a, b, c coefficients real(kind=Float64), public, dimension(3) :: center = 0.d0 Center of the gyrosurface real(kind=Float64), public, dimension(3,3) :: A = 0.d0 Coefficients of quartic surface i.e. basis*diagm(1/a&#94;2,1/b&#94;2,1/c&#94;2)*basis' real(kind=Float64), public, dimension(3,3) :: basis = 0.d0 Basis of coordinate system of gyrosurface Functions public function pp_add (p1, p2) result(p3) Defines how to add two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function pp_subtract (p1, p2) result(p3) Defines how to subtract two Profiles types Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 type( Profiles ), intent(in) :: p2 Return Value type( Profiles ) public function lplp_add (p1, p2) result(p3) Defines how to add two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function lplp_subtract (p1, p2) result(p3) Defines how to subtract two LocalProfiles types Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 type( LocalProfiles ), intent(in) :: p2 Return Value type( LocalProfiles ) public function ps_multiply (p1, real_scalar) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) public function sp_multiply (real_scalar, p1) result(p3) Defines how to multiply Profiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( Profiles ), intent(in) :: p1 Return Value type( Profiles ) public function ps_divide (p1, real_scalar) result(p3) Defines how to divide Profiles types by a scalar Arguments Type Intent Optional Attributes Name type( Profiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( Profiles ) public function lps_multiply (p1, real_scalar) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function slp_multiply (real_scalar, p1) result(p3) Defines how to multiply LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalProfiles ), intent(in) :: p1 Return Value type( LocalProfiles ) public function lps_divide (p1, real_scalar) result(p3) Defines how to divide LocalProfiles types by a scalar Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalProfiles ) public function ff_add (p1, p2) result(p3) Defines how to add two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function ff_subtract (p1, p2) result(p3) Defines how to subtract two EMFields types Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 type( EMFields ), intent(in) :: p2 Return Value type( EMFields ) public function fs_multiply (p1, real_scalar) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) public function sf_multiply (real_scalar, p1) result(p3) Defines how to multiply EMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( EMFields ), intent(in) :: p1 Return Value type( EMFields ) public function fs_divide (p1, real_scalar) result(p3) Defines how to divide EMFields types by a scalar Arguments Type Intent Optional Attributes Name type( EMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( EMFields ) public function lflf_add (p1, p2) result(p3) Defines how to add two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) public function lflf_subtract (p1, p2) result(p3) Defines how to subtract two LocalEMFields types Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 type( LocalEMFields ), intent(in) :: p2 Return Value type( LocalEMFields ) public function lfs_multiply (p1, real_scalar) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields ) public function slf_multiply (real_scalar, p1) result(p3) Defines how to multiply LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: real_scalar type( LocalEMFields ), intent(in) :: p1 Return Value type( LocalEMFields ) public function lfs_divide (p1, real_scalar) result(p3) Defines how to divide LocalEMFields types by a scalar Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: p1 real(kind=Float64), intent(in) :: real_scalar Return Value type( LocalEMFields ) public function approx_eq (x, y, tol) result(a) Inexact equality comparison: x ~= y true if abs(x-y) <= tol else false Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: x First value in comparison real(kind=Float64), intent(in) :: y Second value in comparison real(kind=Float64), intent(in) :: tol Equality tolerance Return Value logical public function approx_ge (x, y, tol) result(a) Inexact greater than or equal to comparison: x >~= y Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: x First value in comparison real(kind=Float64), intent(in) :: y Second value in comparison real(kind=Float64), intent(in) :: tol Equality tolerance Return Value logical public function approx_le (x, y, tol) result(a) Inexact less then or equal to comparison: x <~= y Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: x First value in comparison real(kind=Float64), intent(in) :: y Second value in comparison real(kind=Float64), intent(in) :: tol Equality tolerance Return Value logical public function cross_product (u, v) result(s) Calculates the cross product of two vectors: u x v Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: u real(kind=Float64), intent(in), dimension(3) :: v Return Value real(kind=Float64),\n  dimension(3) public function in_boundary (bplane, p) result(in_b) Indicator function for determining if a point on a plane is within the plane boundary Arguments Type Intent Optional Attributes Name type( BoundedPlane ), intent(in) :: bplane Plane with boundary real(kind=Float64), intent(in), dimension(3) :: p Point on plane Return Value logical public function in_gyro_surface (gs, p) result(in_gs) Indicator function for determining if a point is inside the gyro_surface Arguments Type Intent Optional Attributes Name type( GyroSurface ), intent(in) :: gs Gyro-surface real(kind=Float64), intent(in), dimension(3) :: p Point Return Value logical public function in_grid (xyz) result(ing) Determines if a position pos is in the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: xyz Position in beam grid coordinates [cm] Return Value logical Indicates whether the position is in the beam grid public function gyro_radius (fields, energy, pitch) result(gyro_rad) Calculates mean gyro-radius Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: fields Electromagnetic fields at guiding center real(kind=Float64), intent(in) :: energy Energy of particle real(kind=Float64), intent(in) :: pitch Particle pitch w.r.t the magnetic field Return Value real(kind=Float64) Mean gyro-radius Subroutines public subroutine print_banner () Prints FIDASIM banner Arguments None public subroutine fast_ion_assign (p1, p2) Defines how to assign FastIon types to eachother Arguments Type Intent Optional Attributes Name type( FastIon ), intent(out) :: p1 type( FastIon ), intent(in) :: p2 public subroutine npa_part_assign (p1, p2) Defines how to assign NPAParticle types to eachother Arguments Type Intent Optional Attributes Name type( NPAParticle ), intent(out) :: p1 type( NPAParticle ), intent(in) :: p2 public subroutine pp_assign (p1, p2) Defines how to assign Profiles types to eachother Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 public subroutine lpp_assign (p1, p2) Defines how to assign a Profiles type to a LocalProfiles type Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( Profiles ), intent(in) :: p2 public subroutine plp_assign (p1, p2) Defines how to assign a LocalProfiles type to a Profiles type Arguments Type Intent Optional Attributes Name type( Profiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine lplp_assign (p1, p2) Defines how to assign LocalProfiles types to eachother Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(inout) :: p1 type( LocalProfiles ), intent(in) :: p2 public subroutine ff_assign (p1, p2) Defines how to assign EMFields types to eachother Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 public subroutine lff_assign (p1, p2) Defines how to assign a EMFields type to a LocalEMFields type Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( EMFields ), intent(in) :: p2 public subroutine flf_assign (p1, p2) Defines how to assign a LocalEMFields type to a EMFields type Arguments Type Intent Optional Attributes Name type( EMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine lflf_assign (p1, p2) Defines how to assign LocalEMFields types to eachother Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(inout) :: p1 type( LocalEMFields ), intent(in) :: p2 public subroutine read_inputs () Reads input namelist file and stores the results into inputs , nbi , and beam_grid 20 for suffixes and seperators e.g. /, _npa.h5, ... Arguments None public subroutine make_beam_grid () Makes [[libfida:beam_grid] from user defined inputs Arguments None public subroutine read_beam () Reads neutral beam geometry and stores the quantities in nbi Arguments None public subroutine read_chords () Reads the spectral geometry and stores the quantities in spec_chords Arguments None public subroutine read_npa () Reads the NPA geometry and stores the quantities in npa_chords Arguments None public subroutine read_equilibrium () Reads in the interpolation grid, plasma parameters, and fields\n and stores the quantities in inter_grid and equil Arguments None public subroutine read_f (fid, error) Reads in the fast-ion distribution function and stores the quantities in fbm Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: fid HDF5 file ID integer, intent(out) :: error Error code public subroutine read_mc (fid, error) Reads in a MC particle fast-ion distribution and puts them in particles Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: fid HDF5 file ID integer, intent(out) :: error Error code public subroutine read_distribution () Reads in the fast-ion distribution Arguments None public subroutine read_atomic_cross (fid, grp, cross) Reads in a cross section table from file\n and puts it into a AtomicCrossSection type Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid HDF5 file ID character(len=*), intent(in) :: grp HDF5 group to read from type( AtomicCrossSection ), intent(inout) :: cross Atomic cross section public subroutine read_atomic_rates (fid, grp, b_amu, t_amu, rates) Reads in a atomic reaction rates table from file\n and puts it into a AtomicRates type Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid HDF5 file ID character(len=*), intent(in) :: grp HDF5 group to read from real(kind=Float64), intent(in), dimension(2) :: b_amu Atomic masses of \"beam\" species (beam ion and thermal ion) real(kind=Float64), intent(in) :: t_amu Atomic mass of \"target\" species (thermal ion) type( AtomicRates ), intent(inout) :: rates Atomic reaction rates public subroutine read_nuclear_rates (fid, grp, rates) Reads in a nuclear reaction rates table from file\n and puts it into a NuclearRates type Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: fid HDF5 file ID character(len=*), intent(in) :: grp HDF5 group to read from type( NuclearRates ), intent(inout) :: rates Atomic reaction rates public subroutine read_tables () Reads in atomic tables from file and stores them in tables Arguments None public subroutine write_beam_grid (id, error) Write beam_grid to an HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file ID integer, intent(out) :: error Error code public subroutine write_birth_profile () Writes birth to a HDF5 file Arguments None public subroutine write_dcx () Writes the direct charge exchange (DCX) neutrals and spectra to a HDF5 file Arguments None public subroutine write_neutrals () Writes neut to a HDF5 file Arguments None public subroutine write_npa () Writes npa to a HDF5 file Arguments None public subroutine write_spectra () Writes Spectra to a HDF5 file Arguments None public subroutine write_neutrons () Writes neutron to a HDF5 file Arguments None public subroutine write_fida_weights () Writes fweight to a HDF5 file Arguments None public subroutine write_npa_weights () Writes nweight to a HDF5 file Arguments None public subroutine read_neutrals () Reads neutral density from file and puts it in neut Arguments None public subroutine tb_zyx (alpha, beta, gamma, basis, inv_basis) Creates active rotation matrix for z-y'-x\" rotation given Tait-Bryan angles Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: alpha Angle of rotation about z real(kind=Float64), intent(in) :: beta Angle of rotation about y' real(kind=Float64), intent(in) :: gamma Angle of rotation about x\" real(kind=Float64), intent(out), dimension(3,3) :: basis Rotation matrix/basis for transforming from rotated to non-rotated coordinates real(kind=Float64), intent(out), optional dimension(3,3) :: inv_basis Inverse basis for reverse transformation public subroutine line_basis (r0, v0, basis, inv_basis) Calculates basis from a line with +x in the direction of line Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Starting point of line [cm] real(kind=Float64), intent(in), dimension(3) :: v0 Direction of line real(kind=Float64), intent(out), dimension(3,3) :: basis Basis for transforming from line coordinates to cartesian real(kind=Float64), intent(out), optional dimension(3,3) :: inv_basis Inverse basis for the reverse transformation cartesian to line public subroutine plane_basis (center, redge, tedge, basis, inv_basis) Calculates basis from 3 points on a plane with +z being the plane normal Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: center Plane origin real(kind=Float64), intent(in), dimension(3) :: redge Right edge of plane real(kind=Float64), intent(in), dimension(3) :: tedge Top edge of plane real(kind=Float64), intent(out), dimension(3,3) :: basis Basis for transforming from plane to cartesian coordinates real(kind=Float64), intent(out), optional dimension(3,3) :: inv_basis Inverse basis for the reverse transformation cartesian to plane public subroutine line_plane_intersect (l0, l, p0, n, p, t) Calculates the intersection of a line and a plane Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: l0 Point on line real(kind=Float64), intent(in), dimension(3) :: l Ray of line real(kind=Float64), intent(in), dimension(3) :: p0 Point on plane real(kind=Float64), intent(in), dimension(3) :: n Normal vector of plane real(kind=Float64), intent(out), dimension(3) :: p Line-plane intersect point real(kind=Float64), intent(out) :: t \"time\" to intersect public subroutine boundary_edge (bplane, bedge, nb) Returns 3 x nb array containing points along the BoundedPlane's boundary edge Arguments Type Intent Optional Attributes Name type( BoundedPlane ), intent(in) :: bplane Bounded plane real(kind=Float64), intent(out), dimension(:,:) :: bedge Boundary edge points of bounded plane integer, intent(out) :: nb Number of points in boundary edge public subroutine gyro_surface (fields, energy, pitch, gs) Calculates the surface of all possible trajectories Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: fields Electromagnetic fields at guiding center real(kind=Float64), intent(in) :: energy Energy of particle real(kind=Float64), intent(in) :: pitch Particle pitch w.r.t the magnetic field type( GyroSurface ), intent(out) :: gs Gyro-surface public subroutine line_gyro_surface_intersect (r0, v0, gs, t) Calculates the times of intersection of a line and a gyro-surface Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Point on line real(kind=Float64), intent(in), dimension(3) :: v0 Direction of line type( GyroSurface ), intent(in) :: gs Gyro-surface real(kind=Float64), intent(out), dimension(2) :: t \"time\" to intersect public subroutine gyro_surface_coordinates (gs, p, u) Calculates the parametric coordinates, u , of point p on the gyro_surface Arguments Type Intent Optional Attributes Name type( GyroSurface ), intent(in) :: gs Gyro_surface real(kind=Float64), intent(in), dimension(3) :: p Point on gyro_surface real(kind=Float64), intent(out), dimension(2) :: u Parametric coordinates (gyro-angle, t) public subroutine gyro_trajectory (gs, theta, ri, vi) Calculate particle trajectory for a given gyro-angle and gyro-surface Arguments Type Intent Optional Attributes Name type( GyroSurface ), intent(in) :: gs Gyro-Surface real(kind=Float64), intent(in) :: theta Gyro-angle real(kind=Float64), dimension(3) :: ri Particle position real(kind=Float64), dimension(3) :: vi Particle Velocity public subroutine gyro_range (b, gs, gyrange, nrange) Calculates the range(s) of gyro-angles that would land within a bounded plane Arguments Type Intent Optional Attributes Name type( BoundedPlane ), intent(in) :: b Bounded Plane type( GyroSurface ), intent(in) :: gs Gyro-surface real(kind=Float64), intent(out), dimension(2,4) :: gyrange (theta, dtheta) values integer, intent(out) :: nrange Number of ranges. 1 <= nrange <= 4 public subroutine npa_gyro_range (ichan, gs, gyrange, nrange) Calculates range of gyro-angles that would hit the NPA detector Arguments Type Intent Optional Attributes Name integer, intent(in) :: ichan Index of NPA detector type( GyroSurface ), intent(in) :: gs real(kind=Float64), intent(out), dimension(2,4) :: gyrange integer, intent(out) :: nrange public subroutine hit_npa_detector (r0, v0, d_index, rd, det) Routine to check if a particle will hit a NPA detector Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Starting point of particle real(kind=Float64), intent(in), dimension(3) :: v0 Particle velocity integer, intent(out) :: d_index Index of NPA detector. Zero if particle doesn't hit real(kind=Float64), intent(out), optional dimension(3) :: rd Point where particle hit detector integer, intent(in), optional :: det Index of NPA detector to check public subroutine xyz_to_uvw (xyz, uvw) Convert beam coordinate xyz to machine coordinate uvw Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: xyz real(kind=Float64), intent(out), dimension(3) :: uvw public subroutine uvw_to_xyz (uvw, xyz) Convert machine coordinate uvw to beam coordinate xyz Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: uvw real(kind=Float64), intent(out), dimension(3) :: xyz public subroutine grid_intersect (r0, v0, length, r_enter, r_exit, center_in, lwh_in) Calculates a particles intersection length with the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Initial position of particle [cm] real(kind=Float64), intent(in), dimension(3) :: v0 Velocity of particle [cm/s] real(kind=Float64), intent(out) :: length Intersection length [cm] real(kind=Float64), intent(out), dimension(3) :: r_enter Point where particle enters beam_grid real(kind=Float64), intent(out), dimension(3) :: r_exit Point where particle exits beam_grid real(kind=Float64), intent(in), optional dimension(3) :: center_in Alternative grid center real(kind=Float64), intent(in), optional dimension(3) :: lwh_in Alternative grid [length,width,height] public subroutine circle_grid_intersect (r0, e1, e2, radius, phi_enter, phi_exit) Calculates the intersection arclength of a circle with the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: r0 Position of center enter of the circle in beam grid coordinates [cm] real(kind=Float64), intent(in), dimension(3) :: e1 Unit vector pointing towards (R, 0) (r,phi) position of the circle in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: e2 Unit vector pointing towards (R, pi/2) (r,phi) position of the circle in beam grid coordinates real(kind=Float64), intent(in) :: radius Radius of circle [cm] real(kind=Float64), intent(out) :: phi_enter Phi value where the circle entered the beam_grid [rad] real(kind=Float64), intent(out) :: phi_exit Phi value where the circle exits the beam_grid [rad] public subroutine get_indices (pos, ind) Find closests beam_grid indices ind to position pos Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position [cm] integer(kind=Int32), intent(out), dimension(3) :: ind Closest indices to position public subroutine get_position (ind, pos) Get position pos given beam_grid indices ind Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind beam_grid indices real(kind=Float64), intent(out), dimension(3) :: pos Position [cm] public subroutine track (rin, vin, tracks, ncell, los_intersect) Computes the path of a neutral through the beam_grid Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: rin Initial position of particle real(kind=Float64), intent(in), dimension(3) :: vin Initial velocity of particle type( ParticleTrack ), intent(inout), dimension(:) :: tracks Array of ParticleTrack type integer(kind=Int32), intent(out) :: ncell Number of cells that a particle crosses logical, intent(out), optional :: los_intersect Indicator whether particle intersects a LOS in spec_chords public subroutine interpol1D_coeff (xmin, dx, nx, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa value real(kind=Float64), intent(in) :: dx Absissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol1D_coeff_arr (x, xout, c, err) Linear interpolation coefficients and index for a 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate type( InterpolCoeffs1D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol2D_coeff (xmin, dx, nx, ymin, dy, ny, xout, yout, c, err) Bilinear interpolation coefficients and indicies for a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: xmin Minimum abscissa real(kind=Float64), intent(in) :: dx Abscissa spacing integer, intent(in) :: nx Number of abscissa real(kind=Float64), intent(in) :: ymin Minimum ordinate real(kind=Float64), intent(in) :: dy Ordinate spacing integer, intent(in) :: ny Number of ordinates points real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol2D_coeff_arr (x, y, xout, yout, c, err) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x Abscissa values real(kind=Float64), intent(in), dimension(:) :: y Ordinate values real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(in) :: yout Ordinate value to interpolate type( InterpolCoeffs2D ), intent(out) :: c Interpolation Coefficients integer, intent(out), optional :: err Error code public subroutine interpol1D_arr (x, y, xout, yout, err, coeffs) Performs linear interpolation on a uniform 1D grid y(x) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of y real(kind=Float64), intent(in), dimension(:) :: y Values at abscissa values x : y(x) real(kind=Float64), intent(in) :: xout Abscissa value to interpolate real(kind=Float64), intent(out) :: yout Interpolant: y(xout) integer, intent(out), optional :: err Error code type( InterpolCoeffs1D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol2D_arr (x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid z(x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:) :: z Values at the abscissa/ordinates: z(x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out) :: zout Interpolant: z(xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine interpol2D_2D_arr (x, y, z, xout, yout, zout, err, coeffs) Performs bilinear interpolation on a 2D grid of 2D arrays z(:,:,x,y) Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x The abscissa values of z real(kind=Float64), intent(in), dimension(:) :: y The ordinate values of z real(kind=Float64), intent(in), dimension(:,:,:,:) :: z Values at the abscissa/ordinates: z(:,:,x,y) real(kind=Float64), intent(in) :: xout The abscissa value to interpolate real(kind=Float64), intent(in) :: yout The ordinate value to interpolate real(kind=Float64), intent(out), dimension(:,:) :: zout Interpolant: z(:,:,xout,yout) integer, intent(out), optional :: err Error code type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine in_plasma (xyz, inp, machine_coords, coeffs, uvw_out) Indicator subroutine to determine if a position is in a region where\n the plasma parameter and fields are valid/known Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: xyz Position in beam coordinates logical, intent(out) :: inp Indicates whether plasma parameters and fields are valid/known logical, intent(in), optional :: machine_coords Indicates that xyz is in machine coordinates type( InterpolCoeffs2D ), intent(out), optional :: coeffs Linear Interpolation coefficients used in calculation real(kind=Float64), intent(out), optional dimension(3) :: uvw_out Position in machine coordinates public subroutine get_plasma (plasma, pos, ind) Gets plasma parameters at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(out) :: plasma Plasma parameters at pos / ind real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices public subroutine calc_perp_vectors (b, a, c) Calculates normalized vectors that are perpendicular to b\n such that a x c = b_norm Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: b real(kind=Float64), intent(out), dimension(3) :: a real(kind=Float64), intent(out), dimension(3) :: c public subroutine get_fields (fields, pos, ind, machine_coords) Gets electro-magnetic fields at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(out) :: fields Electro-magnetic fields at pos / ind real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices logical, intent(in), optional :: machine_coords Indicates that pos is machine coordinates public subroutine get_distribution (fbeam, denf, pos, ind, coeffs) Gets Guiding Center distribution at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:,:) :: fbeam Guiding Center Fast-ion distribution at pos / ind : F(E,p) real(kind=Float64), intent(out) :: denf Guiding Center Fast-ion density at pos / ind [fast-ions/cm&#94;3] real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine get_ep_denf (energy, pitch, denf, pos, ind, coeffs) Get guiding center fast-ion density at given energy and pitch\n at position pos or beam_grid indices ind Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: energy Energy [keV] real(kind=Float64), intent(in) :: pitch Pitch real(kind=Float64), intent(out) :: denf Fast-ion density [fast-ions/(cm&#94;3 dE dp)] real(kind=Float64), intent(in), optional dimension(3) :: pos Position in beam grid coordinates integer(kind=Int32), intent(in), optional dimension(3) :: ind beam_grid indices type( InterpolCoeffs2D ), intent(in), optional :: coeffs Precomputed Linear Interpolation Coefficients public subroutine store_neutrals (ind, neut_type, dens, store_iter) Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind beam_grid indices integer, intent(in) :: neut_type Neutral type real(kind=Float64), intent(in), dimension(:) :: dens Neutral density [neutrals/cm&#94;3] logical, intent(in), optional :: store_iter Store DCX/Halo iteration density in halo_iter_dens public subroutine store_births (ind, neut_type, dflux) Store birth particles/density in birth Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind beam_grid indices integer(kind=Int32), intent(in) :: neut_type Neutral type real(kind=Float64), intent(in) :: dflux Deposited flux public subroutine store_npa (det, ri, rf, vn, flux, orbit_class) Store NPA particles in npa Arguments Type Intent Optional Attributes Name integer, intent(in) :: det Detector/Channel Number real(kind=Float64), intent(in), dimension(3) :: ri Birth position in beam coordinates [cm] real(kind=Float64), intent(in), dimension(3) :: rf Detector position in beam coordinates [cm] real(kind=Float64), intent(in), dimension(3) :: vn Particle velocity [cm/s] real(kind=Float64), intent(in) :: flux Neutral flux [neutrals/s] integer, intent(in), optional :: orbit_class Orbit class ID public subroutine neut_rates (denn, vi, vn, rates) Get neutralization/cx rates Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(nlevs) :: denn Neutral density [cm&#94;-3] real(kind=Float64), intent(in), dimension(3) :: vi Ion velocity [cm/s] real(kind=Float64), intent(in), dimension(3) :: vn Neutral velocity [cm/s] real(kind=Float64), intent(out), dimension(nlevs) :: rates Reaction rates [1/s] public subroutine get_neutron_rate (plasma, eb, rate) Gets neutron rate for a beam with energy eb interacting with a target plasma Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma Plasma Paramters real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(out) :: rate Neutron reaction rate [1/s] public subroutine get_beam_cx_prob (ind, pos, v_ion, types, prob) Get probability of a thermal ion charge exchanging with types neutrals Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in), dimension(3) :: ind beam_grid indices real(kind=Float64), intent(in), dimension(3) :: pos Interaction position in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: v_ion Ion velocity [cm/s] integer(kind=Int32), intent(in), dimension(:) :: types Neutral types real(kind=Float64), intent(out), dimension(nlevs) :: prob Charge exchange rate/probability [1/s] public subroutine get_rate_matrix (plasma, i_type, eb, rmat) Gets rate matrix for use in colrad Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma Plasma parameters integer, intent(in) :: i_type Ion type real(kind=Float64), intent(in) :: eb Ion energy [keV] real(kind=Float64), intent(out), dimension(nlevs,nlevs) :: rmat Rate matrix public subroutine colrad (plasma, i_type, vn, dt, states, dens, photons) Evolve density of states in time dt via collisional radiative model Arguments Type Intent Optional Attributes Name type( LocalProfiles ), intent(in) :: plasma Plasma parameters integer, intent(in) :: i_type Ion/Neutral type (beam,thermal) real(kind=Float64), intent(in), dimension(:) :: vn Neutral velocitiy [cm/s] real(kind=Float64), intent(in) :: dt Time interval [s] real(kind=Float64), intent(inout), dimension(:) :: states Density of states real(kind=Float64), intent(out), dimension(nlevs) :: dens Density of neutrals real(kind=Float64), intent(out) :: photons Emitted photons(3->2) public subroutine attenuate (ri, rf, vi, states, dstep_in) Attenuate states along a trajectory Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: ri Initial position in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: rf Final position in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: vi Initial velocity of neutral real(kind=Float64), intent(inout), dimension(nlevs) :: states Density of states real(kind=Float64), intent(in), optional :: dstep_in Step length [cm] public subroutine spectrum (vecp, vi, fields, sigma_pi, photons, dlength, lambda, intensity) Calculates doppler shift and stark splitting Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: vecp Vector directing towards optical head real(kind=Float64), intent(in), dimension(3) :: vi Particle velocity type( LocalEMFields ), intent(in) :: fields Electro-magnetic fields real(kind=Float64), intent(in) :: sigma_pi Sigma-pi ratio real(kind=Float64), intent(in) :: photons Photon density from colrad real(kind=Float64), intent(in) :: dlength LOS intersection length with beam_grid cell particle is in real(kind=Float64), intent(out), dimension(n_stark) :: lambda Wavelengths [nm] real(kind=Float64), intent(out), dimension(n_stark) :: intensity Spectra intensities [Ph/(s cm&#94;2 starkline)] public subroutine store_bes_photons (pos, vi, photons, neut_type) Store BES photons in Spectra Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position of neutral in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: vi Velocitiy of neutral [cm/s] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] integer, intent(in) :: neut_type Neutral type (full,half,third,halo) public subroutine store_fida_photons (pos, vi, photons, orbit_class) Store fida photons in Spectra Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: pos Position of neutral in beam grid coordinates real(kind=Float64), intent(in), dimension(3) :: vi Velocitiy of neutral [cm/s] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] integer, intent(in), optional :: orbit_class Orbit class ID public subroutine store_neutrons (rate, orbit_class) Store neutron rate in neutron Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: rate Neutron rate [neutrons/sec] integer, intent(in), optional :: orbit_class Orbit class ID public subroutine store_fw_photons_at_chan (ichan, eind, pind, vp, vi, fields, dlength, sigma_pi, denf, photons) Store FIDA weight photons in fweight for a specific channel Arguments Type Intent Optional Attributes Name integer, intent(in) :: ichan Channel index integer, intent(in) :: eind Energy index integer, intent(in) :: pind Pitch index real(kind=Float64), intent(in), dimension(3) :: vp Vector pointing toward optical head real(kind=Float64), intent(in), dimension(3) :: vi Velocity of neutral [cm/s] type( LocalEMFields ), intent(in) :: fields Electro-magnetic fields real(kind=Float64), intent(in) :: dlength LOS intersection length with beam_grid cell particle is in real(kind=Float64), intent(in) :: sigma_pi Sigma-pi ratio for channel real(kind=Float64), intent(in) :: denf Fast-ion density [cm&#94;-3] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] public subroutine store_fw_photons (eind, pind, pos, vi, denf, photons) Store FIDA weight photons in fweight Arguments Type Intent Optional Attributes Name integer, intent(in) :: eind Energy index integer, intent(in) :: pind Pitch index real(kind=Float64), intent(in), dimension(3) :: pos Position of neutral real(kind=Float64), intent(in), dimension(3) :: vi Velocity of neutral [cm/s] real(kind=Float64), intent(in) :: denf Fast-ion density [cm&#94;-3] real(kind=Float64), intent(in) :: photons Photons from colrad [Ph/(s*cm&#94;3)] public subroutine get_nlaunch (nr_markers, papprox, papprox_tot, nlaunch) Sets the number of MC markers launched from each beam_grid cell Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: nr_markers Approximate total number of markers to launch real(kind=Float64), intent(in), dimension(:,:,:) :: papprox beam_grid cell weights real(kind=Float64), intent(in) :: papprox_tot Total cell weights real(kind=Float64), intent(out), dimension(:,:,:) :: nlaunch Number of mc markers to launch for each cell: nlaunch(x,y,z) public subroutine pitch_to_vec (pitch, gyroangle, fields, vi_norm) Calculates velocity vector from pitch, gyroangle and fields Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: pitch Pitch real(kind=Float64), intent(in) :: gyroangle Gyroangle [radians] type( LocalEMFields ), intent(in) :: fields Electromagnetic fields real(kind=Float64), intent(out), dimension(3) :: vi_norm Normalized velocity vector public subroutine gyro_step (vi, fields, r_gyro) Calculates gyro-step Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(3) :: vi Ion velocity type( LocalEMFields ), intent(in) :: fields Electro-magnetic fields real(kind=Float64), intent(out), dimension(3) :: r_gyro Gyro-step\n Gyro-radius vector from particle position to guiding center public subroutine gyro_correction (fields, energy, pitch, rp, vp, phi_in) Calculates gyro correction for Guiding Center MC distribution calculation Arguments Type Intent Optional Attributes Name type( LocalEMFields ), intent(in) :: fields Electromagnetic fields at guiding center real(kind=Float64), intent(in) :: energy Energy of particle real(kind=Float64), intent(in) :: pitch Particle pitch w.r.t the magnetic field real(kind=Float64), intent(out), dimension(3) :: rp Particle position real(kind=Float64), intent(out), dimension(3) :: vp Particle velocity real(kind=Float64), intent(in), optional :: phi_in Gyro-angle public subroutine mc_fastion (ind, fields, eb, ptch, denf) Samples a Guiding Center Fast-ion distribution function at a given beam_grid index Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind beam_grid index type( LocalEMFields ), intent(out) :: fields Electromagnetic fields at the guiding center real(kind=Float64), intent(out) :: eb Energy of the fast ion real(kind=Float64), intent(out) :: ptch Pitch of the fast ion real(kind=Float64), intent(out) :: denf Fast-ion density at guiding center public subroutine mc_halo (ind, vhalo, ri, plasma_in) Sample thermal Maxwellian distribution at beam_grid indices ind Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(3) :: ind beam_grid indices real(kind=Float64), intent(out), dimension(3) :: vhalo Velocity [cm/s] real(kind=Float64), intent(out), optional dimension(3) :: ri Position in beam_grid cell type( LocalProfiles ), intent(in), optional :: plasma_in Plasma parameters public subroutine mc_nbi (vnbi, efrac, rnbi, err) Generates a neutral beam particle trajectory Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(3) :: vnbi Velocity [cm/s] integer, intent(in) :: efrac Beam neutral type (1,2,3) real(kind=Float64), intent(out), dimension(3) :: rnbi Starting position on beam_grid logical, intent(out) :: err Error Code public subroutine ndmc () Calculates neutral beam deposition and spectra Arguments None public subroutine bremsstrahlung () Calculates bremsstrahlung Arguments None public subroutine dcx () Calculates Direct Charge Exchange (DCX) neutral density and spectra Arguments None public subroutine halo () Calculates halo neutral density and spectra Arguments None public subroutine fida_f () Calculate FIDA emission using a Fast-ion distribution function F(E,p,r,z) Arguments None public subroutine fida_mc () Calculate FIDA emission using a Monte Carlo Fast-ion distribution Arguments None public subroutine npa_f () Calculate NPA flux using a fast-ion distribution function F(E,p,r,z) Arguments None public subroutine npa_mc () Calculate NPA flux using a Monte Carlo fast-ion distribution Arguments None public subroutine neutron_f () Calculate neutron emission rate using a fast-ion distribution function F(E,p,r,z) Arguments None public subroutine neutron_mc () Calculate neutron flux using a Monte Carlo Fast-ion distribution Arguments None public subroutine fida_weights_mc () Calculates FIDA weights Arguments None public subroutine fida_weights_los () Calculates LOS averaged FIDA weights Arguments None public subroutine npa_weights () Calculates NPA weights Arguments None","tags":"","loc":"module/libfida.html","title":"libfida – FIDASIM"},{"text":"Uses: H5LT HDF5 module~~hdf5_extra~~UsesGraph module~hdf5_extra hdf5_extra H5LT H5LT H5LT->module~hdf5_extra HDF5 HDF5 HDF5->module~hdf5_extra Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. A library for writing compressed HDF5 files Used By module~~hdf5_extra~~UsedByGraph module~hdf5_extra hdf5_extra program~fidasim fidasim module~hdf5_extra->program~fidasim program~generate_tables generate_tables module~hdf5_extra->program~generate_tables module~libfida libfida module~hdf5_extra->module~libfida module~atomic_tables atomic_tables module~hdf5_extra->module~atomic_tables module~libfida->program~fidasim module~atomic_tables->program~generate_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_int_f Subroutines check_compression_availability h5ltread_dataset_int_scalar_f h5ltread_dataset_double_scalar_f h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_7 Interfaces public interface h5ltmake_compressed_dataset_double_f Write a compressed datasets of 64-bit floats public subroutine h5ltmake_compressed_dataset_double_f_1 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_2 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_3 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_4 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_5 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_6 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_7 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public interface h5ltmake_compressed_dataset_int_f Write a compressed dataset of 32-bit integers public subroutine h5ltmake_compressed_dataset_int_f_1 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_2 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_3 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_4 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_5 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_6 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_7 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code Subroutines public subroutine check_compression_availability () Checks whether dataset compression is available Arguments None public subroutine h5ltread_dataset_int_scalar_f (loc_id, dset_name, x, error) Write a scalar 32-bit integer Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(inout) :: x Data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltread_dataset_double_scalar_f (loc_id, dset_name, x, error) Write a scalar 64-bit float Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create real(kind=double), intent(inout) :: x Data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_1 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_2 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_3 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_4 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_5 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_6 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_double_f_7 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 64-bit float dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension real(kind=double), intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_1 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 1 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_2 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 2 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_3 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 3 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_4 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 4 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_5 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 5 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_6 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 6 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code public subroutine h5ltmake_compressed_dataset_int_f_7 (loc_id, dset_name, rank, dims, buf, error) Write a compressed 32-bit integer dataset of dimension 7 Arguments Type Intent Optional Attributes Name integer(kind=hid_t), intent(in) :: loc_id HDF5 file or group identifier character(len=*), intent(in) :: dset_name Name of the dataset to create integer, intent(in) :: rank Number of dimensions of dataspace integer(kind=HSIZE_T), intent(in), dimension(*) :: dims Array of the size of each dimension integer, intent(in), dimension(dims(1),dims(2),dims(3),dims(4),dims(5),dims(6),dims(7)) :: buf Buffer with data to be written to the dataset integer, intent(out) :: error HDF5 error code","tags":"","loc":"module/hdf5_extra.html","title":"hdf5_extra – FIDASIM"},{"text":"Uses: omp_lib module~~utilities~~UsesGraph module~utilities utilities omp_lib omp_lib omp_lib->module~utilities Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Utilities for parallel random number generation and sparse arrays Used By module~~utilities~~UsedByGraph module~utilities utilities module~libfida libfida module~utilities->module~libfida program~fidasim fidasim module~libfida->program~fidasim Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables AM rng Interfaces randind sparse deriv Derived Types rng_type SparseArray Functions sub2ind rng_uniform rng_normal get_value Subroutines ind2sub rng_init randu randn Variables Type Visibility Attributes Name Initial real(kind=Float64), protected :: AM = nearest(1.0, -1.0)/IM type( rng_type ), public, dimension(:), allocatable :: rng Interfaces public interface randind Procedure for generating a random array index/subscripts private subroutine randind_n(n, randomi) Generate a array of uniformally-distributed random integers in the range [1, n] Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Largest possible value integer, intent(out), dimension(:) :: randomi Array of uniform deviates private subroutine randind_w_1(w, randomi) Generate an array of random indices of an 1D array distributed according to w Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: w 1D array of index weights integer, intent(out), dimension(:) :: randomi Random indices private subroutine randind_w_2(w, randomi) Generate an array of random subscripts of an 2D array distributed according to w Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:) :: w 2D array of subscript weights integer, intent(out), dimension(:,:) :: randomi A 2D (ndim, :) array of random subscripts public interface sparse Creates a sparse array from a dense array private subroutine sparse_1(A, SA) Routine to create a 1D sparse array from a 1D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array private subroutine sparse_2(A, SA) Routine to create a 2D sparse array from a 2D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array private subroutine sparse_3(A, SA) Routine to create a 3D sparse array from a 3D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:,:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array private subroutine sparse_4(A, SA) Routine to create a 4D sparse array from a 4D dense array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:,:,:,:) :: A Dense Array type( SparseArray ), intent(out) :: SA Sparse Array public interface deriv Procedure for finding derivatives from an array private subroutine deriv_1d(x, y, yp) Uses 3 point lagrangian method to calculate the derivative of an array Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x X Values real(kind=Float64), intent(in), dimension(:) :: y Y Values real(kind=Float64), intent(out), dimension(:) :: yp Derivative of Y w.r.t. X private subroutine deriv_2d(x, y, z, zxp, zyp) Uses 3 point lagrangian method to calculate the partial derivative\n of an array Z w.r.t X and Y Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: x X Values real(kind=Float64), intent(in), dimension(:) :: y Y Values real(kind=Float64), intent(in), dimension(:,:) :: z Z Values real(kind=Float64), intent(out), dimension(:,:) :: zxp Derivative of Z w.r.t. X real(kind=Float64), intent(out), dimension(:,:) :: zyp Derivative of Z w.r.t. Y Derived Types type, public :: rng_type Random Number Generator Derived Type Components Type Visibility Attributes Name Initial integer(kind=Int32), public, dimension(ns) :: state type, public :: SparseArray Components Type Visibility Attributes Name Initial integer, public :: nnz = 0 Number of non-zero elements integer, public :: nd = 0 Number of dimensions integer, public, dimension(:), allocatable :: dims Dimensions of array integer, public, dimension(:), allocatable :: inds Linear index of non-zero elements real(kind=Float64), public, dimension(:), allocatable :: vals Array values Functions public function sub2ind (dims, subs) result(ind) Calculates the linear index of an array with dimensions dims and\n subcripts subs Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: dims Dimension of Array integer, intent(in), dimension(:) :: subs Subscripts to convert Return Value integer Linear index public function rng_uniform (self) result(u) Generate a uniformally-distributed random number in the range [0,1) Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator Return Value real(kind=Float64) Uniform random deviate public function rng_normal (self) result(n) Generate a normally-distributed random number with mean 0 and standard deviation 1 Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator Return Value real(kind=Float64) Normal random deviate public function get_value (SA, subs) result(val) Gets value of sparse array SA at the subscripts subs Arguments Type Intent Optional Attributes Name type( SparseArray ), intent(in) :: SA Sparse Array integer, intent(in), dimension(:) :: subs Subscripts of Sparse Array Return Value real(kind=Float64) Value of SA at subs Subroutines public subroutine ind2sub (dims, ind, subs) Calculate the subscripts subs into an array with dimensions dims given the corresponding linear index ind Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: dims Dimensions of array integer, intent(in) :: ind Linear index integer, intent(out), dimension(:) :: subs Subscripts corresponding to the linear index public subroutine rng_init (self, seed) Procedure to initialize a random number generator with a seed Arguments Type Intent Optional Attributes Name type( rng_type ), intent(inout) :: self Random Number Generator integer(kind=Int32), intent(in) :: seed Initial Seed Value public subroutine randu (randomu) Generate an array of uniformally-distributed random deviates Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:) :: randomu Array of uniform random deviates public subroutine randn (randomn) Generate an array of normally-distributed random deviates Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(out), dimension(:) :: randomn Array of normal random deviates","tags":"","loc":"module/utilities.html","title":"utilities – FIDASIM"},{"text":"Uses: H5LT HDF5 hdf5_extra module~~atomic_tables~~UsesGraph module~atomic_tables atomic_tables module~hdf5_extra hdf5_extra module~hdf5_extra->module~atomic_tables H5LT H5LT H5LT->module~atomic_tables H5LT->module~hdf5_extra HDF5 HDF5 HDF5->module~atomic_tables HDF5->module~hdf5_extra Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Library for calculating atomic cross sections and reaction rate coefficients for Hydrogen interactions References W.L. Wiese, M.W. Smith, and B.M. Glennon. Atomic Transition Probabilities. Volume 1. Hydrogen through Neon .\nNational Bureau of Standards Washington DC Institute for Basic Standards, 1966. R.K. Janev, D. Reiter, and  U. Samm. Collision processes in low-temperature hydrogen plasmas .\nForschungszentrum Jülich, Zentralbibliothek, 2003. M. O'Mullane. Review of proton impact driven ionisation from the excited levels in neutral hydrogen beams .\nADAS note, 2009. ADAS: Atomic Data and Analysis Structure R.K. Janev and J.J. Smith. Cross sections for collision processes of hydrogen atoms\nwith electrons, protons and multiply charged ions. Atomic and Plasma-Material Interaction Data for Fusion:\nVolume 4, 1993. Reinhold, C. O., R. E. Olson, and W. Fritsch. Excitation of atomic hydrogen by fully stripped ions. Physical Review A 41.9 1990. Bosch, H-S., and G. M. Hale. Improved formulas for fusion cross-sections and thermal reactivities. Nuclear fusion 32.4 1992. Used By module~~atomic_tables~~UsedByGraph module~atomic_tables atomic_tables program~generate_tables generate_tables module~atomic_tables->program~generate_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables PI e_amu H1_amu H2_amu H3_amu He3_amu B_amu C_amu B_q C_q EINSTEIN Interfaces bt_maxwellian Functions p_cx_1_janev p_cx_2_janev p_cx_3_janev p_cx_n_janev p_cx_janev p_cx_1_1_adas p_cx_1_2_adas p_cx_1_3_adas p_cx_1_4_adas p_cx_1 p_cx_2_2_adas p_cx_2_3_adas p_cx_2 p_cx_3_2_adas p_cx_3_3_adas p_cx_3_4_adas p_cx_3_5_adas p_cx_3_6inf_adas p_cx_3 p_cx_n p_cx_n_m p_cx p_ioniz_1_janev p_ioniz_2_omullane p_ioniz_3_omullane p_ioniz_4_omullane p_ioniz_5_omullane p_ioniz_n p_ioniz p_excit_1_2_janev p_excit_1_3_janev p_excit_1_4_janev p_excit_1_5_janev p_excit_1_6_janev p_excit_1_janev p_excit_2_3_janev p_excit_2_4_janev p_excit_2_5_janev p_excit_2_6_janev p_excit_2_7_janev p_excit_2_8_janev p_excit_2_9_janev p_excit_2_10_janev p_excit_2_janev p_excit_3_4_janev p_excit_3_5_janev p_excit_3_6_janev p_excit_3_7_janev p_excit_3_8_janev p_excit_3_9_janev p_excit_3_10_janev p_excit_3_janev p_excit_n p_excit_n_m p_excit e_ioniz_1_janev e_ioniz_2_janev e_ioniz_3_janev e_ioniz_n e_ioniz e_excit_1_2_janev e_excit_1_3_janev e_excit_1_4_janev e_excit_1_5_janev e_excit_f e_excit_1_janev e_excit_2_3_janev e_excit_n e_excit_n_m e_excit B5_cx_1_adas B5_cx_2_adas C6_cx_1_adas C6_cx_2_adas C6_cx_3_adas Aq_cx_n_adas B5_cx_1_janev C6_cx_1_janev Aq_cx_n_janev Aq_cx_n Aq_cx B5_ioniz_1_janev C6_ioniz_1_janev Aq_ioniz_n_janev Aq_ioniz_n Aq_ioniz Aq_excit_1_2_janev Aq_excit_1_3_janev Aq_excit_1_4_janev Aq_excit_1_5_janev Aq_excit_1_janev Aq_excit_2_3_janev Aq_excit_2_4_janev Aq_excit_2_5_janev Aq_excit_2_6_janev Aq_excit_2_7_janev Aq_excit_2_8_janev Aq_excit_2_9_janev Aq_excit_2_10_janev Aq_excit_2_janev Aq_excit_3_4_janev Aq_excit_3_5_janev Aq_excit_3_6_janev Aq_excit_3_7_janev Aq_excit_3_8_janev Aq_excit_3_9_janev Aq_excit_3_10_janev Aq_excit_3_janev Aq_excit_n_janev Aq_excit_n Aq_excit_n_m Aq_excit d_d_fusion_t d_d_fusion_he d_t_fusion simpsons_rule Subroutines m_spread bt_maxwellian_eb bt_maxwellian_n bt_maxwellian_q_n bt_maxwellian_n_m bt_maxwellian_q_n_m write_einstein write_bb_H_H write_bb_H_e write_bb_H_Aq write_bb_D_D write_bb_D_T write_bt_H_H write_bt_H_e write_bt_H_Aq write_bt_D_D write_bt_D_T print_default_namelist Variables Type Visibility Attributes Name Initial real(kind=Float64), public, parameter :: PI = 3.14159265d0 real(kind=Float64), public, parameter :: e_amu = 5.485799093287202d-4 Atomic mass of an electron [amu] real(kind=Float64), public, parameter :: H1_amu = 1.00782504d0 Atomic mass of Hydrogen-1 (protium) [amu] real(kind=Float64), public, parameter :: H2_amu = 2.0141017778d0 Atomic mass of Hydrogen-2 (deuterium) [amu] real(kind=Float64), public, parameter :: H3_amu = 3.0160492d0 Atomic mass of Hydrogen-3 (tritium) [amu] real(kind=Float64), public, parameter :: He3_amu = 3.0160293d0 Atomic mass of Helium-3 [amu] real(kind=Float64), public, parameter :: B_amu = 10.81d0 Atomic mass of Boron [amu] real(kind=Float64), public, parameter :: C_amu = 12.011d0 Atomic mass of Carbon [amu] integer, public, parameter :: B_q = 5 Proton number of Boron integer, public, parameter :: C_q = 6 Proton number of Carbon real(kind=Float64), public, parameter, dimension(15,15) :: EINSTEIN = reshape([0.d0, 4.699d8, 5.575d7, 1.278d7, 4.125d6, 1.644d6, 7.568d5, 3.869d5, 2.143d5, 1.263d5, 7.834d4, 5.066d4, 3.393d4, 2.341d4, 1.657d4, 0.d0, 0.d0, 4.410d7, 8.419d6, 2.530d6, 9.732d5, 4.389d5, 2.215d5, 1.216d5, 7.122d4, 4.397d4, 2.834d4, 1.893d4, 1.303d4, 9.210d3, 0.d0, 0.d0, 0.d0, 8.986d6, 2.201d6, 7.783d5, 3.358d5, 1.651d5, 8.905d4, 5.156d4, 3.156d4, 2.021d4, 1.343d4, 9.211d3, 6.490d3, 0.d0, 0.d0, 0.d0, 0.d0, 2.699d6, 7.711d5, 3.041d5, 1.424d5, 7.459d4, 4.235d4, 2.556d4, 1.620d4, 1.069d4, 7.288d3, 5.110d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.025d6, 3.253d5, 1.388d5, 6.908d4, 3.800d4, 2.246d4, 1.402d4, 9.148d3, 6.185d3, 4.308d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 4.561d5, 1.561d5, 7.065d4, 3.688d4, 2.110d4, 1.288d4, 8.271d3, 5.526d3, 3.815d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 2.272d5, 8.237d4, 3.905d4, 2.117d4, 1.250d4, 7.845d3, 5.156d3, 3.516d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.233d5, 4.676d4, 2.301d4, 1.287d4, 7.804d3, 5.010d3, 3.359d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 7.141d4, 2.812d4, 1.427d4, 8.192d3, 5.080d3, 3.325d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 4.377d4, 1.774d4, 9.231d3, 5.417d3, 3.324d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 2.799d4, 1.163d4, 6.186d3, 3.699d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.857d4, 7.884d3, 4.271d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 1.271d4, 5.496d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 8.933d3, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0, 0.d0], [15, 15]) Einstein coefficients for spontaneous emission from state initial state n to final state m References: H - Table A in Ref. 1 atomic_tables Interfaces public interface bt_maxwellian Calculates the reaction rate coefficients given beam energy eb and target temperature T where the velocity distribution of the target is a Maxwellian public subroutine bt_maxwellian_eb (fn, T, eb, am, ab, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] public subroutine bt_maxwellian_n (fn, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a, b) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] public subroutine bt_maxwellian_n_m (fnm, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fnm Arguments Type Intent Optional Attributes Name public function fnm(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate public subroutine bt_maxwellian_q_n (fqn, q, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqn Arguments Type Intent Optional Attributes Name public function fqn(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] public subroutine bt_maxwellian_q_n_m (fqnm, q, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqnm Arguments Type Intent Optional Attributes Name public function fqnm(a, b, c, d) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate Functions public function p_cx_1_janev (Erel) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=1 state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_2_janev (Erel) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=2 state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_3_janev (Erel) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n=3 state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_n_janev (Erel, n) result(sigma) Calculates cross section for proton-Hydrogen charge exchange interactions from the n \\geq 4 state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_janev (Erel, n) result(sigma) Calculates total cross section for proton-Hydrogen charge exchange interactions from the n state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_1_1_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=1 state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_1_2_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=2 state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_1_3_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=3 state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_1_4_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=1 state to the m=4 state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_1 (Erel, m_max) result(sigma) Calculates an array of cross section for proton-Hydrogen charge exchange interactions\nfrom the n=1 state to m = 1.. m_max states at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [cm&#94;2] public function p_cx_2_2_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=2 state to the m=2 state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_2_3_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=2 state to the m=3 state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_2 (Erel, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n=2 state to m = 1.. m_max states at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [cm&#94;2] public function p_cx_3_2_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=2 state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_3_3_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=3 state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_3_4_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=4 state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_3_5_adas (Erel) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to the m=5 state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_3_6inf_adas (Erel) result(sigma) Calculates total cross section for a proton-Hydrogen charge exchange interaction\nfrom the n=3 state to \\forall \\; m \\geq 6 states at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx_3 (Erel, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n=3 state to m = 1.. m_max states at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [cm&#94;2] public function p_cx_n (Erel, n, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n state to m = 1.. m_max states at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the index refers to the m 'th state [cm&#94;2] public function p_cx_n_m (Erel, n, m) result(sigma) Calculates cross section for a proton-Hydrogen charge exchange interaction\nfrom the n state to the m state at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_cx (Erel, n_max, m_max) result(sigma) Calculates a matrix of cross sections for proton-Hydrogen charge exchange interactions\nfrom the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy Erel Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: Erel Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of initial atomic energy levels/states integer, intent(in) :: m_max Number of final atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max,m_max) Matrix of cross sections where the subscripts correspond\n to the n \\rightarrow m transitions: p_cx[n,m] [cm&#94;2] public function p_ioniz_1_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=1 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_ioniz_2_omullane (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=2 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_ioniz_3_omullane (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=3 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_ioniz_4_omullane (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=4 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_ioniz_5_omullane (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n=5 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_ioniz_n (eb, n) result(sigma) Calculates cross section for a proton-Hydrogen impact ionization interaction\nfrom the n th state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_ioniz (eb, n_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen impact ionization interactions\nfrom the n = 1.. n_max state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of initial atomic energy level/state Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the index refers to the n 'th state [cm&#94;2] public function p_excit_1_2_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=2 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_1_3_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=3 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_1_4_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=4 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_1_5_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=5 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_1_6_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=1 state to the m=6 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_1_janev (eb, m_max) result(sigma) Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from\nthe n=1 state to the m=1..{m_max} state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n=1 to m [cm&#94;2] public function p_excit_2_3_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=3 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_2_4_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=4 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_2_5_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=5 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_2_6_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=6 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_2_7_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=7 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_2_8_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=8 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_2_9_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=9 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_2_10_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=2 state to the m=10 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_2_janev (eb, m_max) result(sigma) Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from\nthe n=2 state to the m=1..{m_max} state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n=2 to m [cm&#94;2] public function p_excit_3_4_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=4 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_3_5_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=5 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_3_6_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=6 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_3_7_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=7 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_3_8_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=8 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_3_9_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=9 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_3_10_janev (eb) result(sigma) Calculates cross section for a proton-Hydrogen impact excitation transition from\nthe n=3 state to the m=10 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit_3_janev (eb, m_max) result(sigma) Calculates an array of cross sections for proton-Hydrogen impact excitation transitions from\nthe n=3 state to the m=1..{m_max} state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n=3 to m [cm&#94;2] public function p_excit_n (eb, n, m_max) result(sigma) Calculates an array of cross sections for a proton-Hydrogen impact excitation transitions from\nthe n state to the m=1..{m_max} state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refer to the transition\n from n to m [cm&#94;2] public function p_excit_n_m (eb, n, m) result(sigma) Calculates the cross section for a proton-Hydrogen impact excitation transition from\nthe n state to the m state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] public function p_excit (eb, n_max, m_max) result(sigma) Calculates a matrix of cross sections for a proton-Hydrogen impact excitation transitions\nfrom the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of final atomic energy levels/states integer, intent(in) :: m_max Number of initial atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max,m_max) Matrix of cross sections where the subscripts correspond\n to the n \\rightarrow m transitions: p_excit[n,m] [cm&#94;2] public function e_ioniz_1_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n=1 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function e_ioniz_2_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n=2 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function e_ioniz_3_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n=3 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function e_ioniz_n (eb, n) result(sigma) Calculates cross section for a electron-Hydrogen impact ionization from\nthe n state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] public function e_ioniz (eb, n_max) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact ionization from\nthe n=1..n_{max} states at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n_max Number of initial atomic energy levels/states to calculate Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the n'th index refers to a ionization from the n'th state [cm&#94;2] public function e_excit_1_2_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=2 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function e_excit_1_3_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=3 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function e_excit_1_4_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=4 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function e_excit_1_5_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=5 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function e_excit_f (n, m) result(fnm) Oscillator strength for a n \\rightarrow m transition due to electron-Hydrogen impact excitation Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Oscillator strength public function e_excit_1_janev (eb, m_max) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from\nthe n=1 state to the m=1..m_{max} state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=1 state to the m'th state [cm&#94;2] public function e_excit_2_3_janev (eb) result(sigma) Calculates cross section for a electron-Hydrogen impact excitation transition from\nthe n=2 state to the m=3 state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function e_excit_n (eb, n, m_max) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from\nthe n state to the m=1..m_{max} state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n \\rightarrow m state [cm&#94;2] public function e_excit_n_m (eb, n, m) result(sigma) Calculates an array of cross sections for a electron-Hydrogen impact excitation transition from\nthe n \\rightarrow m state at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] public function e_excit (eb, n_max, m_max) result(sigma) Calculates a matrix of cross section for a proton-Hydrogen impact excitation transition\nfrom the n=1..n_{max} \\rightarrow m=1..m_{max} states at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: n_max Number of final atomic energy levels/states integer, intent(in) :: m_max Number of initial atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max,m_max) Matrix of cross sections where the subscripts correspond\n to the n \\rightarrow m transitions: e_excit[n,m] [cm&#94;2] public function B5_cx_1_adas (eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Boron ion at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function B5_cx_2_adas (eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=2 state colliding with a fully stripped Boron ion at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function C6_cx_1_adas (eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Carbon ion at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function C6_cx_2_adas (eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=2 state colliding with a fully stripped Carbon ion at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function C6_cx_3_adas (eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=3 state colliding with a fully stripped Carbon ion at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_cx_n_adas (eb, q, n) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] public function B5_cx_1_janev (eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Boron ion at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function C6_cx_1_janev (eb) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Carbon ion at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_cx_n_janev (eb, q, n) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_cx_n (eb, q, n) result(sigma) Calculates the total charge exchange cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_cx (eb, q, n_max) result(sigma) Calculates an array of total charge exchange cross sections for a Neutral Hydrogen atom\nin the n=1...n_max states colliding with a ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n_max Number of initial atomic energy levels/states Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the n'th index refers to a charge exchange from the n'th state [cm&#94;2] public function B5_ioniz_1_janev (eb) result(sigma) Calculates the total ionization cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Boron ion at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function C6_ioniz_1_janev (eb) result(sigma) Calculates the total ionization cross section for a Neutral Hydrogen atom\nin the n=1 state colliding with a fully stripped Carbon ion at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Return Value real(kind=Float64) public function Aq_ioniz_n_janev (eb, q, n) result(sigma) Calculates the generic total ionization cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_ioniz_n (eb, q, n) result(sigma) Calculates the total ionization cross section for a Neutral Hydrogen atom\nin the n state colliding with a ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_ioniz (eb, q, n_max) result(sigma) Calculates an array of total ionization cross sections for a Neutral Hydrogen atom\nin the n=1...n_max states colliding with a ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Relative collision energy [keV/amu] integer, intent(in) :: q Ion charge integer, intent(in) :: n_max Number of initial states n to calculate Return Value real(kind=Float64),\n  dimension(n_max) Array of cross sections where the n'th index refers to a ionization from the n'th state [cm&#94;2] public function Aq_excit_1_2_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=2 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_1_3_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=3 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_1_4_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=4 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_1_5_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=5 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_1_janev (eb, q, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=1 state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=1 state to the m'th state [cm&#94;2] public function Aq_excit_2_3_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=3 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_2_4_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=4 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_2_5_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=5 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_2_6_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=6 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_2_7_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=7 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_2_8_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=8 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_2_9_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=9 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_2_10_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=10 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_2_janev (eb, q, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=2 state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=2 state to the m'th state [cm&#94;2] public function Aq_excit_3_4_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=4 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_3_5_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=5 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_3_6_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=6 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_3_7_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=7 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_3_8_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=8 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_3_9_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=9 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_3_10_janev (eb, q) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=10 state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit_3_janev (eb, q, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=3 state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n=3 state to the m'th state [cm&#94;2] public function Aq_excit_n_janev (eb, q, n, m_max) result(sigma) Calculates an array of the generic excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n state to the m'th state [cm&#94;2] public function Aq_excit_n (eb, q, n, m_max) result(sigma) Calculates an array of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(m_max) Array of cross sections where the m'th index refers to\nan excitation from the n state to the m'th state [cm&#94;2] public function Aq_excit_n_m (eb, q, n, m) result(sigma) Calculates the excitation cross section for a neutral Hydrogen atom transitioning from\nthe n \\rightarrow m state due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state Return Value real(kind=Float64) Cross Section [cm&#94;2] public function Aq_excit (eb, q, n_max, m_max) result(sigma) Calculates an matrix of the excitation cross sections for a neutral Hydrogen atom transitioning from\nthe n=1.. n_max state to the m=1.. m_max states due to a collision an ion with charge q at energy eb Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Collision energy [keV] integer, intent(in) :: q Ion charge integer, intent(in) :: n_max Number of n states to calculate integer, intent(in) :: m_max Number of m states to calculate Return Value real(kind=Float64),\n  dimension(n_max, m_max) Matrix of cross sections where the subscripts refers to\nan excitation from the n state to the m'th state: Aq_excit[n,m] [cm&#94;2] public function d_d_fusion_t (eb) result(sigma) Calculates total cross section at a given Deuterium energy, eb ,\nfor the Tritium branch of Deuterium-Deutrium nuclear reactions Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Deuterium energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function d_d_fusion_he (eb) result(sigma) Calculates total cross section at a given deuterium energy, eb ,\nfor the Helium-3 branch of Deuterium-Deutrium nuclear reactions Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Deuterium energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function d_t_fusion (eb) result(sigma) Calculates total cross section at a given deuterium energy, eb ,\nfor Deuterium-Tritium nuclear reactions in the range [0.5-550 keV] Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in) :: eb Deuterium energy [keV] Return Value real(kind=Float64) Cross Section [cm&#94;2] public function simpsons_rule (f, dx) result(I) Performs 1D integration using Simpsons rule Arguments Type Intent Optional Attributes Name real(kind=Float64), intent(in), dimension(:) :: f Array of equally spaced f(x) values real(kind=Float64), intent(in) :: dx Spacing between x values Return Value real(kind=Float64) Subroutines public subroutine m_spread (n, m_max, sigma_tot, sigma) Spreads the total charge exchange cross section, sigma_tot ,\n among the non-filled m states of sigma according to an exponential Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m_max Number of m states in sigma real(kind=Float64), intent(in) :: sigma_tot Amount of \"cross section\" to spread about the non-filled m state of sigma real(kind=Float64), intent(inout), dimension(m_max) :: sigma Array of cross sections from the n state to m=1.. m_max [cm&#94;2] public subroutine bt_maxwellian_eb (fn, T, eb, am, ab, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] public subroutine bt_maxwellian_n (fn, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am and temperature T which has a cross section given by the function fn Arguments Type Intent Optional Attributes Name public function fn(a, b) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] public subroutine bt_maxwellian_q_n (fqn, q, T, eb, am, ab, n, rate) Calculates Maxwellian reaction rate for a beam with atomic mass ab , energy eb , and energy level n firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqn Arguments Type Intent Optional Attributes Name public function fqn(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] public subroutine bt_maxwellian_n_m (fnm, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am and temperature T which has a cross section given by the function fnm Arguments Type Intent Optional Attributes Name public function fnm(a, b, c) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c Return Value real(kind=8) real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate public subroutine bt_maxwellian_q_n_m (fqnm, q, T, eb, am, ab, n, m, rate, deexcit) Calculates Maxwellian reaction rate for a n (\\rightarrow) m transition due to a beam with atomic mass ab and energy eb firing into a target with atomic mass am , temperature T , and charge q which has a cross section given by the function fqnm Arguments Type Intent Optional Attributes Name public function fqnm(a, b, c, d) Cross section function Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a integer, intent(in) :: b integer, intent(in) :: c integer, intent(in) :: d Return Value real(kind=8) integer, intent(in) :: q Target charge real(kind=Float64), intent(in) :: T Target temperature [keV] real(kind=Float64), intent(in) :: eb Beam energy [keV] real(kind=Float64), intent(in) :: am Target atomic mass [amu] real(kind=Float64), intent(in) :: ab Beam atomic mass [amu] integer, intent(in) :: n Initial atomic energy level/state integer, intent(in) :: m Final atomic energy level/state real(kind=Float64), intent(out) :: rate Reaction Rate [cm&#94;3/s] logical, intent(in), optional :: deexcit Calculate de-excitation reaction rate public subroutine write_einstein (id, n_max, m_max) Write Einstein coefficients to HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate public subroutine write_bb_H_H (id, namelist_file, n_max, m_max) Write Hydrogen-Hydrogen interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate public subroutine write_bb_H_e (id, namelist_file, n_max, m_max) Write Hydrogen-Electron interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate public subroutine write_bb_H_Aq (id, namelist_file, n_max, m_max) Write Hydrogen-Impurity interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate public subroutine write_bb_D_D (id, namelist_file) Write Deuterium-Deuterium interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings public subroutine write_bb_D_T (id, namelist_file) Write Deuterium-Tritium interaction cross sections to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings public subroutine write_bt_H_H (id, namelist_file, n_max, m_max) Write Hydrogen-Hydrogen reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate public subroutine write_bt_H_e (id, namelist_file, n_max, m_max) Write Hydrogen-Electron reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate public subroutine write_bt_H_Aq (id, namelist_file, n_max, m_max) Write Hydrogen-Impurity reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings integer, intent(in) :: n_max Number of initial atomic energy states to calculate integer, intent(in) :: m_max Number of final atomic energy states to calculate public subroutine write_bt_D_D (id, namelist_file) Write Deuterium-Deuterium reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings public subroutine write_bt_D_T (id, namelist_file) Write Deuterium-Tritium reaction rates to a HDF5 file Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(inout) :: id HDF5 file or group object id character(len=*), intent(in) :: namelist_file Namelist file that contains settings public subroutine print_default_namelist () Prints out the default settings as a namelist Arguments None","tags":"","loc":"module/atomic_tables.html","title":"atomic_tables – FIDASIM"},{"text":"Uses: libfida hdf5_extra omp_lib program~~fidasim~~UsesGraph program~fidasim fidasim omp_lib omp_lib omp_lib->program~fidasim module~utilities utilities omp_lib->module~utilities module~libfida libfida module~libfida->program~fidasim module~hdf5_extra hdf5_extra module~hdf5_extra->program~fidasim module~hdf5_extra->module~libfida module~eigensystem eigensystem module~eigensystem->module~libfida module~utilities->module~libfida H5LT H5LT H5LT->module~libfida H5LT->module~hdf5_extra HDF5 HDF5 HDF5->module~libfida HDF5->module~hdf5_extra Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FIDASIM 1.0.1 Calls program~~fidasim~~CallsGraph program~fidasim fidasim proc~fida_f fida_f program~fidasim->proc~fida_f proc~npa_f npa_f program~fidasim->proc~npa_f proc~read_tables read_tables program~fidasim->proc~read_tables proc~write_birth_profile write_birth_profile program~fidasim->proc~write_birth_profile proc~read_neutrals read_neutrals program~fidasim->proc~read_neutrals proc~check_compression_availability check_compression_availability program~fidasim->proc~check_compression_availability proc~npa_weights npa_weights program~fidasim->proc~npa_weights rng rng program~fidasim->rng proc~fida_weights_mc fida_weights_mc program~fidasim->proc~fida_weights_mc proc~read_equilibrium read_equilibrium program~fidasim->proc~read_equilibrium proc~fida_mc fida_mc program~fidasim->proc~fida_mc omp_set_num_threads omp_set_num_threads program~fidasim->omp_set_num_threads proc~bremsstrahlung bremsstrahlung program~fidasim->proc~bremsstrahlung proc~read_npa read_npa program~fidasim->proc~read_npa proc~print_banner print_banner program~fidasim->proc~print_banner proc~dcx dcx program~fidasim->proc~dcx proc~read_beam read_beam program~fidasim->proc~read_beam omp_get_num_procs omp_get_num_procs program~fidasim->omp_get_num_procs proc~make_beam_grid make_beam_grid program~fidasim->proc~make_beam_grid proc~read_inputs read_inputs program~fidasim->proc~read_inputs proc~ndmc ndmc program~fidasim->proc~ndmc rng_init rng_init program~fidasim->rng_init proc~write_dcx write_dcx program~fidasim->proc~write_dcx proc~halo halo program~fidasim->proc~halo proc~neutron_f neutron_f program~fidasim->proc~neutron_f proc~neutron_mc neutron_mc program~fidasim->proc~neutron_mc proc~read_distribution read_distribution program~fidasim->proc~read_distribution proc~fida_weights_los fida_weights_los program~fidasim->proc~fida_weights_los proc~read_chords read_chords program~fidasim->proc~read_chords proc~write_spectra write_spectra program~fidasim->proc~write_spectra proc~write_neutrals write_neutrals program~fidasim->proc~write_neutrals proc~npa_mc npa_mc program~fidasim->proc~npa_mc proc~write_npa write_npa program~fidasim->proc~write_npa proc~get_nlaunch get_nlaunch proc~fida_f->proc~get_nlaunch proc~store_fida_photons store_fida_photons proc~fida_f->proc~store_fida_photons proc~colrad colrad proc~fida_f->proc~colrad proc~track track proc~fida_f->proc~track proc~get_plasma get_plasma proc~fida_f->proc~get_plasma proc~get_beam_cx_prob get_beam_cx_prob proc~fida_f->proc~get_beam_cx_prob proc~mc_fastion mc_fastion proc~fida_f->proc~mc_fastion proc~gyro_correction gyro_correction proc~fida_f->proc~gyro_correction proc~npa_f->proc~get_nlaunch proc~npa_f->proc~get_plasma proc~npa_f->proc~get_beam_cx_prob proc~npa_f->proc~mc_fastion proc~get_indices get_indices proc~npa_f->proc~get_indices proc~store_npa store_npa proc~npa_f->proc~store_npa proc~npa_gyro_range npa_gyro_range proc~npa_f->proc~npa_gyro_range proc~gyro_surface gyro_surface proc~npa_f->proc~gyro_surface proc~gyro_trajectory gyro_trajectory proc~npa_f->proc~gyro_trajectory proc~attenuate attenuate proc~npa_f->proc~attenuate proc~hit_npa_detector hit_npa_detector proc~npa_f->proc~hit_npa_detector proc~h5ltread_dataset_int_scalar_f h5ltread_dataset_int_scalar_f proc~read_tables->proc~h5ltread_dataset_int_scalar_f h5close_f h5close_f proc~read_tables->h5close_f h5fclose_f h5fclose_f proc~read_tables->h5fclose_f proc~read_atomic_cross read_atomic_cross proc~read_tables->proc~read_atomic_cross h5open_f h5open_f proc~read_tables->h5open_f proc~read_nuclear_rates read_nuclear_rates proc~read_tables->proc~read_nuclear_rates h5fopen_f h5fopen_f proc~read_tables->h5fopen_f h5ltread_dataset_double_f h5ltread_dataset_double_f proc~read_tables->h5ltread_dataset_double_f proc~read_atomic_rates read_atomic_rates proc~read_tables->proc~read_atomic_rates proc~xyz_to_uvw xyz_to_uvw proc~write_birth_profile->proc~xyz_to_uvw proc~write_birth_profile->h5close_f proc~write_birth_profile->h5fclose_f proc~write_birth_profile->h5open_f interface~h5ltmake_compressed_dataset_int_f h5ltmake_compressed_dataset_int_f proc~write_birth_profile->interface~h5ltmake_compressed_dataset_int_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~write_birth_profile->h5ltset_attribute_string_f proc~write_beam_grid write_beam_grid proc~write_birth_profile->proc~write_beam_grid interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_birth_profile->interface~h5ltmake_compressed_dataset_double_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_birth_profile->h5ltmake_dataset_int_f h5fcreate_f h5fcreate_f proc~write_birth_profile->h5fcreate_f proc~read_neutrals->proc~h5ltread_dataset_int_scalar_f proc~read_neutrals->h5close_f proc~read_neutrals->h5fclose_f proc~read_neutrals->h5open_f proc~read_neutrals->h5fopen_f proc~read_neutrals->h5ltread_dataset_double_f h5gclose_f h5gclose_f proc~read_neutrals->h5gclose_f h5gopen_f h5gopen_f proc~read_neutrals->h5gopen_f proc~check_compression_availability->h5close_f proc~check_compression_availability->h5open_f h5zfilter_avail_f h5zfilter_avail_f proc~check_compression_availability->h5zfilter_avail_f h5zget_filter_info_f h5zget_filter_info_f proc~check_compression_availability->h5zget_filter_info_f proc~npa_weights->proc~get_beam_cx_prob proc~get_fields get_fields proc~npa_weights->proc~get_fields proc~gyro_step gyro_step proc~npa_weights->proc~gyro_step proc~npa_weights->proc~attenuate proc~npa_weights->proc~hit_npa_detector proc~get_ep_denf get_ep_denf proc~npa_weights->proc~get_ep_denf proc~write_npa_weights write_npa_weights proc~npa_weights->proc~write_npa_weights proc~fida_weights_mc->proc~get_nlaunch proc~fida_weights_mc->proc~colrad proc~fida_weights_mc->proc~track proc~fida_weights_mc->proc~get_plasma proc~fida_weights_mc->proc~get_beam_cx_prob proc~fida_weights_mc->proc~gyro_correction proc~randu randu proc~fida_weights_mc->proc~randu proc~fida_weights_mc->proc~get_fields interface~randind randind proc~fida_weights_mc->interface~randind proc~fida_weights_mc->proc~get_ep_denf proc~store_fw_photons store_fw_photons proc~fida_weights_mc->proc~store_fw_photons proc~write_fida_weights write_fida_weights proc~fida_weights_mc->proc~write_fida_weights proc~read_equilibrium->proc~h5ltread_dataset_int_scalar_f proc~read_equilibrium->h5close_f proc~read_equilibrium->h5fclose_f proc~read_equilibrium->h5open_f proc~read_equilibrium->h5fopen_f proc~read_equilibrium->h5ltread_dataset_double_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~read_equilibrium->h5ltread_dataset_int_f proc~read_equilibrium->h5gclose_f proc~read_equilibrium->h5gopen_f interface~deriv deriv proc~read_equilibrium->interface~deriv proc~fida_mc->proc~store_fida_photons proc~fida_mc->proc~colrad proc~fida_mc->proc~track proc~fida_mc->proc~get_plasma proc~fida_mc->proc~get_beam_cx_prob proc~fida_mc->proc~gyro_correction proc~fida_mc->proc~randu proc~fida_mc->proc~get_fields proc~uvw_to_xyz uvw_to_xyz proc~fida_mc->proc~uvw_to_xyz proc~bremsstrahlung->proc~get_plasma proc~bremsstrahlung->proc~randu proc~line_basis line_basis proc~bremsstrahlung->proc~line_basis proc~read_npa->proc~get_fields proc~read_npa->proc~hit_npa_detector proc~read_npa->proc~h5ltread_dataset_int_scalar_f proc~read_npa->h5close_f proc~read_npa->h5fclose_f proc~read_npa->h5open_f proc~read_npa->h5fopen_f proc~read_npa->h5ltread_dataset_double_f proc~read_npa->h5ltread_dataset_int_f h5ltpath_valid_f h5ltpath_valid_f proc~read_npa->h5ltpath_valid_f proc~read_npa->h5gclose_f proc~read_npa->h5gopen_f proc~read_npa->proc~uvw_to_xyz proc~plane_basis plane_basis proc~read_npa->proc~plane_basis h5ltread_dataset_string_f h5ltread_dataset_string_f proc~read_npa->h5ltread_dataset_string_f proc~grid_intersect grid_intersect proc~read_npa->proc~grid_intersect proc~dcx->proc~get_nlaunch proc~dcx->proc~colrad proc~dcx->proc~track proc~dcx->proc~get_plasma proc~dcx->proc~get_beam_cx_prob proc~mc_halo mc_halo proc~dcx->proc~mc_halo proc~store_bes_photons store_bes_photons proc~dcx->proc~store_bes_photons proc~store_neutrals store_neutrals proc~dcx->proc~store_neutrals proc~read_beam->proc~h5ltread_dataset_int_scalar_f proc~read_beam->h5close_f proc~read_beam->h5fclose_f proc~read_beam->h5open_f proc~read_beam->h5fopen_f proc~read_beam->h5ltread_dataset_double_f proc~read_beam->h5ltread_dataset_int_f proc~read_beam->h5ltpath_valid_f proc~h5ltread_dataset_double_scalar_f h5ltread_dataset_double_scalar_f proc~read_beam->proc~h5ltread_dataset_double_scalar_f proc~read_beam->h5gclose_f proc~read_beam->h5gopen_f proc~read_beam->proc~uvw_to_xyz proc~tb_zyx tb_zyx proc~read_beam->proc~tb_zyx proc~read_beam->h5ltread_dataset_string_f proc~make_beam_grid->proc~tb_zyx proc~ndmc->proc~colrad proc~ndmc->proc~track proc~ndmc->proc~get_plasma proc~ndmc->proc~randu proc~ndmc->interface~randind proc~ndmc->proc~store_bes_photons proc~ndmc->proc~store_neutrals proc~mc_nbi mc_nbi proc~ndmc->proc~mc_nbi proc~store_births store_births proc~ndmc->proc~store_births proc~write_dcx->h5close_f proc~write_dcx->h5fclose_f proc~write_dcx->h5open_f proc~write_dcx->h5ltset_attribute_string_f proc~write_dcx->proc~write_beam_grid proc~write_dcx->interface~h5ltmake_compressed_dataset_double_f proc~write_dcx->h5ltmake_dataset_int_f proc~write_dcx->h5fcreate_f proc~halo->proc~get_nlaunch proc~halo->proc~colrad proc~halo->proc~track proc~halo->proc~get_plasma proc~halo->proc~get_beam_cx_prob proc~halo->proc~mc_halo proc~halo->proc~store_bes_photons proc~halo->proc~store_neutrals proc~neutron_f->proc~get_plasma proc~neutron_f->proc~gyro_correction proc~neutron_f->proc~get_fields proc~neutron_f->proc~uvw_to_xyz proc~get_neutron_rate get_neutron_rate proc~neutron_f->proc~get_neutron_rate proc~write_neutrons write_neutrons proc~neutron_f->proc~write_neutrons proc~store_neutrons store_neutrons proc~neutron_f->proc~store_neutrons proc~neutron_mc->proc~get_plasma proc~neutron_mc->proc~gyro_correction proc~neutron_mc->proc~get_fields proc~neutron_mc->proc~uvw_to_xyz proc~neutron_mc->proc~get_neutron_rate proc~neutron_mc->proc~write_neutrons proc~neutron_mc->proc~store_neutrons proc~read_distribution->proc~h5ltread_dataset_int_scalar_f proc~read_distribution->h5close_f proc~read_distribution->h5fclose_f proc~read_distribution->h5open_f proc~read_distribution->h5fopen_f proc~read_f read_f proc~read_distribution->proc~read_f proc~read_mc read_mc proc~read_distribution->proc~read_mc proc~fida_weights_los->proc~colrad proc~fida_weights_los->proc~track proc~fida_weights_los->proc~get_plasma proc~fida_weights_los->proc~get_fields proc~neut_rates neut_rates proc~fida_weights_los->proc~neut_rates proc~fida_weights_los->proc~mc_halo proc~pitch_to_vec pitch_to_vec proc~fida_weights_los->proc~pitch_to_vec proc~fida_weights_los->proc~get_ep_denf proc~fida_weights_los->proc~write_fida_weights proc~store_fw_photons_at_chan store_fw_photons_at_chan proc~fida_weights_los->proc~store_fw_photons_at_chan proc~fida_weights_los->proc~grid_intersect proc~read_chords->proc~track proc~read_chords->proc~randu proc~read_chords->proc~h5ltread_dataset_int_scalar_f proc~read_chords->h5close_f proc~read_chords->h5fclose_f proc~read_chords->h5open_f proc~read_chords->h5fopen_f proc~read_chords->h5ltread_dataset_double_f proc~read_chords->h5ltpath_valid_f proc~read_chords->h5gclose_f proc~read_chords->h5gopen_f proc~read_chords->proc~uvw_to_xyz proc~read_chords->proc~line_basis proc~read_chords->h5ltread_dataset_string_f proc~read_chords->proc~grid_intersect proc~write_spectra->h5close_f proc~write_spectra->h5fclose_f proc~write_spectra->h5open_f proc~write_spectra->h5ltset_attribute_string_f proc~write_spectra->interface~h5ltmake_compressed_dataset_double_f proc~write_spectra->h5ltmake_dataset_int_f proc~write_spectra->h5fcreate_f proc~write_neutrals->h5close_f proc~write_neutrals->h5fclose_f proc~write_neutrals->h5open_f proc~write_neutrals->h5ltset_attribute_string_f proc~write_neutrals->proc~write_beam_grid proc~write_neutrals->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrals->h5ltmake_dataset_int_f proc~write_neutrals->h5fcreate_f proc~npa_mc->proc~get_beam_cx_prob proc~npa_mc->proc~randu proc~npa_mc->proc~get_indices proc~npa_mc->proc~get_fields proc~npa_mc->proc~store_npa proc~npa_mc->proc~npa_gyro_range proc~npa_mc->proc~gyro_surface proc~npa_mc->proc~gyro_trajectory proc~npa_mc->proc~attenuate proc~npa_mc->proc~hit_npa_detector proc~npa_mc->proc~uvw_to_xyz proc~write_npa->h5close_f proc~write_npa->h5fclose_f proc~write_npa->h5open_f proc~write_npa->interface~h5ltmake_compressed_dataset_int_f proc~write_npa->h5ltset_attribute_string_f proc~write_npa->interface~h5ltmake_compressed_dataset_double_f proc~write_npa->h5ltmake_dataset_int_f proc~write_npa->h5fcreate_f proc~write_npa->h5gclose_f h5gcreate_f h5gcreate_f proc~write_npa->h5gcreate_f proc~get_nlaunch->proc~randu proc~store_fida_photons->proc~get_indices proc~store_fida_photons->proc~get_fields proc~spectrum spectrum proc~store_fida_photons->proc~spectrum proc~matinv matinv proc~colrad->proc~matinv proc~get_rate_matrix get_rate_matrix proc~colrad->proc~get_rate_matrix proc~eigen eigen proc~colrad->proc~eigen proc~track->proc~get_indices proc~in_plasma in_plasma proc~track->proc~in_plasma proc~get_position get_position proc~get_plasma->proc~get_position proc~get_plasma->proc~in_plasma proc~get_beam_cx_prob->proc~neut_rates proc~get_beam_cx_prob->proc~mc_halo proc~mc_fastion->proc~randu proc~mc_fastion->proc~get_fields proc~mc_fastion->interface~randind proc~get_distribution get_distribution proc~mc_fastion->proc~get_distribution proc~gyro_correction->proc~randu proc~gyro_correction->proc~pitch_to_vec proc~gyro_correction->proc~gyro_step omp_get_thread_num omp_get_thread_num proc~randu->omp_get_thread_num proc~rng_uniform rng_uniform proc~randu->proc~rng_uniform proc~calc_perp_vectors calc_perp_vectors proc~get_fields->proc~calc_perp_vectors proc~get_fields->proc~get_position proc~get_fields->proc~in_plasma proc~in_plasma->proc~xyz_to_uvw interface~interpol_coeff interpol_coeff proc~in_plasma->interface~interpol_coeff proc~interpol1d_coeff_arr interpol1D_coeff_arr interface~interpol_coeff->proc~interpol1d_coeff_arr proc~interpol2d_coeff_arr interpol2D_coeff_arr interface~interpol_coeff->proc~interpol2d_coeff_arr proc~interpol1d_coeff interpol1D_coeff interface~interpol_coeff->proc~interpol1d_coeff proc~interpol2d_coeff interpol2D_coeff interface~interpol_coeff->proc~interpol2d_coeff proc~interpol1d_coeff_arr->proc~interpol1d_coeff proc~interpol2d_coeff_arr->proc~interpol2d_coeff proc~lubksb lubksb proc~matinv->proc~lubksb proc~ludcmp ludcmp proc~matinv->proc~ludcmp proc~get_rate_matrix->interface~interpol_coeff proc~elmtrans elmtrans proc~eigen->proc~elmtrans proc~balance balance proc~eigen->proc~balance proc~balback balback proc~eigen->proc~balback proc~hqr2 hqr2 proc~eigen->proc~hqr2 proc~elmhes elmhes proc~eigen->proc~elmhes proc~swap swap proc~ludcmp->proc~swap proc~outerprod outerprod proc~ludcmp->proc~outerprod proc~rswap RSWAP proc~balance->proc~rswap proc~balback->proc~rswap proc~hqrvec hqrvec proc~hqr2->proc~hqrvec proc~elmhes->proc~rswap proc~comdiv Comdiv proc~hqrvec->proc~comdiv proc~neut_rates->interface~interpol_coeff proc~mc_halo->proc~get_plasma proc~mc_halo->proc~randu proc~randn randn proc~mc_halo->proc~randn proc~randn->omp_get_thread_num proc~rng_normal rng_normal proc~randn->proc~rng_normal proc~rng_normal->proc~rng_uniform proc~get_distribution->proc~get_position proc~get_distribution->proc~xyz_to_uvw interface~interpol interpol proc~get_distribution->interface~interpol proc~interpol2d_arr interpol2D_arr interface~interpol->proc~interpol2d_arr proc~interpol1d_arr interpol1D_arr interface~interpol->proc~interpol1d_arr proc~interpol2d_2d_arr interpol2D_2D_arr interface~interpol->proc~interpol2d_2d_arr proc~interpol2d_arr->interface~interpol_coeff proc~interpol1d_arr->interface~interpol_coeff proc~interpol2d_2d_arr->interface~interpol_coeff proc~cross_product cross_product proc~gyro_step->proc~cross_product proc~store_npa->proc~get_fields proc~store_npa->proc~xyz_to_uvw proc~gyro_range gyro_range proc~npa_gyro_range->proc~gyro_range proc~approx_eq approx_eq proc~npa_gyro_range->proc~approx_eq proc~attenuate->proc~colrad proc~attenuate->proc~get_plasma proc~line_plane_intersect line_plane_intersect proc~hit_npa_detector->proc~line_plane_intersect proc~in_boundary in_boundary proc~hit_npa_detector->proc~in_boundary proc~boundary_edge boundary_edge proc~gyro_range->proc~boundary_edge proc~line_gyro_surface_intersect line_gyro_surface_intersect proc~gyro_range->proc~line_gyro_surface_intersect proc~gyro_surface_coordinates gyro_surface_coordinates proc~gyro_range->proc~gyro_surface_coordinates proc~in_gyro_surface in_gyro_surface proc~gyro_range->proc~in_gyro_surface proc~gyro_range->proc~line_plane_intersect proc~gyro_range->proc~in_boundary proc~h5ltread_dataset_int_scalar_f->h5ltread_dataset_int_f proc~read_atomic_cross->proc~h5ltread_dataset_int_scalar_f proc~read_atomic_cross->h5ltread_dataset_double_f proc~read_atomic_cross->h5ltpath_valid_f proc~read_atomic_cross->proc~h5ltread_dataset_double_scalar_f proc~read_nuclear_rates->proc~h5ltread_dataset_int_scalar_f proc~read_nuclear_rates->h5ltread_dataset_double_f proc~read_nuclear_rates->h5ltpath_valid_f proc~read_nuclear_rates->proc~h5ltread_dataset_double_scalar_f proc~read_atomic_rates->proc~h5ltread_dataset_int_scalar_f proc~read_atomic_rates->h5ltread_dataset_double_f proc~read_atomic_rates->h5ltpath_valid_f proc~read_atomic_rates->proc~h5ltread_dataset_double_scalar_f h5ltget_dataset_ndims_f h5ltget_dataset_ndims_f proc~read_atomic_rates->h5ltget_dataset_ndims_f proc~h5ltread_dataset_double_scalar_f->h5ltread_dataset_double_f proc~h5ltmake_compressed_dataset_int_f_1 h5ltmake_compressed_dataset_int_f_1 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_1 proc~h5ltmake_compressed_dataset_int_f_5 h5ltmake_compressed_dataset_int_f_5 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_5 proc~h5ltmake_compressed_dataset_int_f_6 h5ltmake_compressed_dataset_int_f_6 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_6 proc~h5ltmake_compressed_dataset_int_f_3 h5ltmake_compressed_dataset_int_f_3 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_3 proc~h5ltmake_compressed_dataset_int_f_7 h5ltmake_compressed_dataset_int_f_7 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_7 proc~h5ltmake_compressed_dataset_int_f_2 h5ltmake_compressed_dataset_int_f_2 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_2 proc~h5ltmake_compressed_dataset_int_f_4 h5ltmake_compressed_dataset_int_f_4 interface~h5ltmake_compressed_dataset_int_f->proc~h5ltmake_compressed_dataset_int_f_4 proc~write_beam_grid->proc~xyz_to_uvw proc~write_beam_grid->h5ltset_attribute_string_f proc~write_beam_grid->interface~h5ltmake_compressed_dataset_double_f proc~write_beam_grid->h5ltmake_dataset_int_f proc~write_beam_grid->h5gclose_f proc~write_beam_grid->h5gcreate_f proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 proc~h5ltmake_compressed_dataset_int_f_1->h5ltmake_dataset_int_f h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_1->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_deflate_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5pcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_int_f_1->h5dclose_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_1->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_1->h5screate_simple_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_7->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5ltmake_dataset_int_f proc~h5ltmake_compressed_dataset_int_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_int_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_int_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_int_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_int_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_int_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~get_ep_denf->proc~get_position proc~get_ep_denf->proc~xyz_to_uvw proc~get_ep_denf->interface~interpol proc~write_npa_weights->h5close_f proc~write_npa_weights->h5fclose_f proc~write_npa_weights->h5open_f proc~write_npa_weights->h5ltset_attribute_string_f proc~write_npa_weights->proc~write_beam_grid proc~write_npa_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_npa_weights->h5ltmake_dataset_int_f proc~write_npa_weights->h5fcreate_f proc~store_fw_photons->proc~get_indices proc~store_fw_photons->proc~get_fields proc~store_fw_photons->proc~store_fw_photons_at_chan proc~write_fida_weights->h5close_f proc~write_fida_weights->h5fclose_f proc~write_fida_weights->h5open_f proc~write_fida_weights->h5ltset_attribute_string_f proc~write_fida_weights->interface~h5ltmake_compressed_dataset_double_f proc~write_fida_weights->h5ltmake_dataset_int_f proc~write_fida_weights->h5fcreate_f proc~store_fw_photons_at_chan->proc~spectrum proc~line_basis->proc~tb_zyx proc~plane_basis->proc~cross_product proc~store_bes_photons->proc~get_indices proc~store_bes_photons->proc~get_fields proc~store_bes_photons->proc~spectrum proc~mc_nbi->proc~randu proc~mc_nbi->proc~in_plasma proc~mc_nbi->proc~randn proc~mc_nbi->proc~grid_intersect proc~get_neutron_rate->interface~interpol_coeff proc~write_neutrons->h5close_f proc~write_neutrons->h5fclose_f proc~write_neutrons->h5open_f proc~write_neutrons->h5ltset_attribute_string_f proc~write_neutrons->interface~h5ltmake_compressed_dataset_double_f proc~write_neutrons->h5ltmake_dataset_int_f proc~write_neutrons->h5fcreate_f proc~write_neutrons->h5ltmake_dataset_double_f proc~read_f->proc~h5ltread_dataset_int_scalar_f proc~read_f->h5ltread_dataset_double_f proc~read_mc->proc~in_plasma proc~read_mc->proc~h5ltread_dataset_int_scalar_f proc~read_mc->h5ltread_dataset_double_f proc~read_mc->h5ltread_dataset_int_f proc~read_mc->proc~uvw_to_xyz proc~circle_grid_intersect circle_grid_intersect proc~read_mc->proc~circle_grid_intersect proc~circle_grid_intersect->proc~approx_eq proc~circle_grid_intersect->proc~grid_intersect proc~in_grid in_grid proc~circle_grid_intersect->proc~in_grid proc~approx_ge approx_ge proc~in_grid->proc~approx_ge proc~approx_le approx_le proc~in_grid->proc~approx_le proc~approx_ge->proc~approx_eq proc~approx_le->proc~approx_eq var panprogramfidasimCallsGraph = svgPanZoom('#programfidasimCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables arg time_arr time_start time_end i narg nthreads max_threads hour minu sec Source Code fidasim Variables Type Attributes Name Initial character(len=3) :: arg = '' integer, dimension(8) :: time_arr integer, dimension(8) :: time_start integer, dimension(8) :: time_end integer :: i integer :: narg integer :: nthreads integer :: max_threads integer :: hour integer :: minu integer :: sec Source Code program fidasim !+ FIDASIM {!../VERSION!} use libfida use hdf5_extra #ifdef _OMP use omp_lib #endif implicit none character ( 3 ) :: arg = '' integer , dimension ( 8 ) :: time_arr , time_start , time_end !Time array integer :: i , narg , nthreads , max_threads integer :: hour , minu , sec #ifdef _VERSION version = _ VERSION #endif call print_banner () narg = command_argument_count () if ( narg . eq . 0 ) then write ( * , '(a)' ) \"usage: ./fidasim namelist_file [num_threads]\" stop else call get_command_argument ( 1 , namelist_file ) endif !! Check if compression is possible call check_compression_availability () !! measure time call date_and_time ( values = time_start ) call read_inputs () #ifdef _OMP max_threads = OMP_get_num_procs () if ( narg . ge . 2 ) then call get_command_argument ( 2 , arg ) read ( arg , '(i3)' ) nthreads else nthreads = max_threads endif max_threads = min ( nthreads , max_threads ) if ( inputs % verbose . ge . 1 ) then write ( * , '(a)' ) \"---- OpenMP settings ----\" write ( * , '(T2,\"Number of threads: \",i2)' ) max_threads write ( * , * ) '' endif call OMP_set_num_threads ( max_threads ) #else max_threads = 1 #endif !! ---------------------------------------------------------- !! ------ INITIALIZE THE RANDOM NUMBER GENERATOR  ----------- !! ---------------------------------------------------------- allocate ( rng ( max_threads )) do i = 1 , max_threads call rng_init ( rng ( i ), 932117 + i ) enddo !! ---------------------------------------------------------- !! ------- READ GRIDS, PROFILES, LOS, TABLES, & FBM -------- !! ---------------------------------------------------------- call make_beam_grid () call read_equilibrium () call read_beam () call read_tables () call read_distribution () allocate ( spec_chords % inter ( beam_grid % nx , beam_grid % ny , beam_grid % nz )) if (( inputs % calc_spec . ge . 1 ). or .( inputs % calc_fida_wght . ge . 1 )) then call read_chords () endif if (( inputs % calc_npa . ge . 1 ). or .( inputs % calc_npa_wght . ge . 1 )) then call read_npa () endif !! ---------------------------------------------------------- !! --------------- ALLOCATE THE RESULT ARRAYS --------------- !! ---------------------------------------------------------- !! neutral density array! allocate ( neut % dens ( nlevs , ntypes , beam_grid % nx , beam_grid % ny , beam_grid % nz )) neut % dens = 0.d0 !! birth profile if ( inputs % calc_birth . ge . 1 ) then allocate ( birth % dens ( 3 , & beam_grid % nx , & beam_grid % ny , & beam_grid % nz )) allocate ( birth % neut_type ( int ( inputs % n_birth * inputs % n_nbi ))) allocate ( birth % ind ( 3 , int ( inputs % n_birth * inputs % n_nbi ))) allocate ( birth % ri ( 3 , int ( inputs % n_birth * inputs % n_nbi ))) allocate ( birth % vi ( 3 , int ( inputs % n_birth * inputs % n_nbi ))) birth % neut_type = 0 birth % dens = 0.d0 birth % ind = 0 birth % ri = 0.d0 birth % vi = 0.d0 endif if ( inputs % calc_spec . ge . 1 ) then allocate ( spec % brems ( inputs % nlambda , spec_chords % nchan )) allocate ( spec % bes ( inputs % nlambda , spec_chords % nchan , 4 )) allocate ( spec % fida ( inputs % nlambda , spec_chords % nchan , particles % nclass )) spec % brems = 0.d0 spec % bes = 0.d0 spec % fida = 0.d0 endif if ( inputs % calc_npa . ge . 1 ) then npa % nchan = npa_chords % nchan allocate ( npa % part ( npa % nmax )) if ( inputs % dist_type . eq . 1 ) then npa % nenergy = fbm % nenergy allocate ( npa % energy ( npa % nenergy )) npa % energy = fbm % energy else allocate ( npa % energy ( npa % nenergy )) do i = 1 , npa % nenergy npa % energy ( i ) = real ( i - 0.5 ) enddo endif allocate ( npa % flux ( npa % nenergy , npa % nchan , particles % nclass )) npa % flux = 0.0 endif if ( inputs % calc_neutron . ge . 1 ) then allocate ( neutron % rate ( particles % nclass )) neutron % rate = 0.d0 endif !! ----------------------------------------------------------------------- !! --------------- CALCULATE/LOAD the BEAM and HALO DENSITY--------------- !! ----------------------------------------------------------------------- if ( inputs % load_neutrals . eq . 1 ) then call read_neutrals () else !! ----------- BEAM NEUTRALS ---------- !! call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'ndmc:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call ndmc if ( inputs % calc_birth . eq . 1 ) then call write_birth_profile () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' !! ---------- DCX (Direct charge exchange) ---------- !! call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'dcx:     ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call dcx () if ( inputs % dump_dcx . eq . 1 ) call write_dcx () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' !! ---------- HALO ---------- !! call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'halo:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call halo () !! ---------- WRITE NEUTRALS ---------- !! call write_neutrals () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ----------------------------------------------------------------------- !!----------------------------- BREMSSTRAHLUNG --------------------------- !! ----------------------------------------------------------------------- if ( inputs % calc_brems . ge . 1 ) then call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'bremsstrahlung:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call bremsstrahlung () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ----------------------------------------------------------------------- !! --------------------- CALCULATE the FIDA RADIATION -------------------- !! ----------------------------------------------------------------------- if ( inputs % calc_fida . ge . 1 ) then call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'fida:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif if ( inputs % dist_type . eq . 1 ) then call fida_f () else call fida_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_spec . ge . 1 ) then call write_spectra () write ( * , '(30X,a)' ) '' endif !! ----------------------------------------------------------------------- !! ----------------------- CALCULATE the NPA FLUX ------------------------ !! ----------------------------------------------------------------------- if ( inputs % calc_npa . ge . 1 ) then call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'npa:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif if ( inputs % dist_type . eq . 1 ) then call npa_f () else call npa_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_npa . ge . 1 ) then call write_npa () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ------------------------------------------------------------------- !! ------------------- Calculation of neutron flux ------------------- !! ------------------------------------------------------------------- if ( inputs % calc_neutron . ge . 1 ) then call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'neutron rate:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif if ( inputs % dist_type . eq . 1 ) then call neutron_f () else call neutron_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif !! ------------------------------------------------------------------- !! ----------- Calculation of weight functions ----------------------- !! ------------------------------------------------------------------- if ( inputs % calc_fida_wght . ge . 1 ) then colrad_threshold = 0. !! to speed up simulation! call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'fida weight function:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif if ( inputs % calc_fida_wght . eq . 1 ) then call fida_weights_los () else call fida_weights_mc () endif if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif if ( inputs % calc_npa_wght . ge . 1 ) then call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'npa weight function:    ' , & time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call npa_weights () if ( inputs % verbose . ge . 1 ) write ( * , '(30X,a)' ) '' endif call date_and_time ( values = time_arr ) if ( inputs % verbose . ge . 1 ) then write ( * , '(A,I2,\":\",I2.2,\":\",I2.2)' ) 'END: hour, minute, second: ' ,& time_arr ( 5 ), time_arr ( 6 ), time_arr ( 7 ) endif call date_and_time ( values = time_end ) hour = time_end ( 5 ) - time_start ( 5 ) minu = time_end ( 6 ) - time_start ( 6 ) sec = time_end ( 7 ) - time_start ( 7 ) if ( minu . lt . 0. ) then minu = minu + 60 hour = hour - 1 endif if ( sec . lt . 0. ) then sec = sec + 60 minu = minu - 1 endif if ( inputs % verbose . ge . 1 ) then write ( * , '(A,18X,I2,\":\",I2.2,\":\",I2.2)' ) 'duration:' , hour , minu , sec endif end program fidasim","tags":"","loc":"program/fidasim.html","title":"fidasim – FIDASIM"},{"text":"Uses: atomic_tables H5LT HDF5 hdf5_extra omp_lib program~~generate_tables~~UsesGraph program~generate_tables generate_tables HDF5 HDF5 HDF5->program~generate_tables module~hdf5_extra hdf5_extra HDF5->module~hdf5_extra module~atomic_tables atomic_tables HDF5->module~atomic_tables module~hdf5_extra->program~generate_tables module~hdf5_extra->module~atomic_tables omp_lib omp_lib omp_lib->program~generate_tables module~atomic_tables->program~generate_tables H5LT H5LT H5LT->program~generate_tables H5LT->module~hdf5_extra H5LT->module~atomic_tables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Tabulates cross sections and reaction rates and writes them to a HDF5 file Calls program~~generate_tables~~CallsGraph program~generate_tables generate_tables proc~write_einstein write_einstein program~generate_tables->proc~write_einstein proc~write_bt_h_h write_bt_H_H program~generate_tables->proc~write_bt_h_h h5gclose_f h5gclose_f program~generate_tables->h5gclose_f proc~print_default_namelist print_default_namelist program~generate_tables->proc~print_default_namelist proc~write_bb_h_h write_bb_H_H program~generate_tables->proc~write_bb_h_h h5close_f h5close_f program~generate_tables->h5close_f proc~write_bt_h_e write_bt_H_e program~generate_tables->proc~write_bt_h_e proc~write_bb_h_e write_bb_H_e program~generate_tables->proc~write_bb_h_e h5open_f h5open_f program~generate_tables->h5open_f proc~check_compression_availability check_compression_availability program~generate_tables->proc~check_compression_availability h5gcreate_f h5gcreate_f program~generate_tables->h5gcreate_f h5fcreate_f h5fcreate_f program~generate_tables->h5fcreate_f proc~write_bb_d_d write_bb_D_D program~generate_tables->proc~write_bb_d_d proc~write_bb_h_aq write_bb_H_Aq program~generate_tables->proc~write_bb_h_aq proc~write_bt_d_d write_bt_D_D program~generate_tables->proc~write_bt_d_d omp_set_num_threads omp_set_num_threads program~generate_tables->omp_set_num_threads h5fclose_f h5fclose_f program~generate_tables->h5fclose_f h5ltset_attribute_string_f h5ltset_attribute_string_f program~generate_tables->h5ltset_attribute_string_f omp_get_num_procs omp_get_num_procs program~generate_tables->omp_get_num_procs proc~write_bt_h_aq write_bt_H_Aq program~generate_tables->proc~write_bt_h_aq proc~write_einstein->h5gclose_f proc~write_einstein->h5gcreate_f proc~write_einstein->h5ltset_attribute_string_f interface~h5ltmake_compressed_dataset_double_f h5ltmake_compressed_dataset_double_f proc~write_einstein->interface~h5ltmake_compressed_dataset_double_f h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~write_einstein->h5ltmake_dataset_int_f proc~write_bt_h_h->h5gclose_f proc~write_bt_h_h->h5gcreate_f proc~write_bt_h_h->h5ltset_attribute_string_f proc~write_bt_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_h->h5ltmake_dataset_int_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~write_bt_h_h->h5ltmake_dataset_double_f interface~bt_maxwellian bt_maxwellian proc~write_bt_h_h->interface~bt_maxwellian proc~write_bb_h_h->h5gclose_f proc~write_bb_h_h->h5gcreate_f proc~write_bb_h_h->h5ltset_attribute_string_f proc~write_bb_h_h->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_h->h5ltmake_dataset_int_f proc~write_bb_h_h->h5ltmake_dataset_double_f proc~p_excit p_excit proc~write_bb_h_h->proc~p_excit proc~p_ioniz p_ioniz proc~write_bb_h_h->proc~p_ioniz proc~p_cx p_cx proc~write_bb_h_h->proc~p_cx proc~write_bt_h_e->h5gclose_f proc~write_bt_h_e->h5gcreate_f proc~write_bt_h_e->h5ltset_attribute_string_f proc~write_bt_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_e->h5ltmake_dataset_int_f proc~write_bt_h_e->h5ltmake_dataset_double_f proc~write_bt_h_e->interface~bt_maxwellian proc~write_bb_h_e->h5gclose_f proc~write_bb_h_e->h5gcreate_f proc~write_bb_h_e->h5ltset_attribute_string_f proc~write_bb_h_e->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_e->h5ltmake_dataset_int_f proc~write_bb_h_e->h5ltmake_dataset_double_f proc~e_ioniz e_ioniz proc~write_bb_h_e->proc~e_ioniz proc~e_excit e_excit proc~write_bb_h_e->proc~e_excit proc~check_compression_availability->h5close_f proc~check_compression_availability->h5open_f h5zfilter_avail_f h5zfilter_avail_f proc~check_compression_availability->h5zfilter_avail_f h5zget_filter_info_f h5zget_filter_info_f proc~check_compression_availability->h5zget_filter_info_f proc~write_bb_d_d->h5gclose_f proc~write_bb_d_d->h5gcreate_f proc~write_bb_d_d->h5ltset_attribute_string_f proc~write_bb_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_d_d->h5ltmake_dataset_int_f proc~write_bb_d_d->h5ltmake_dataset_double_f proc~d_d_fusion_he d_d_fusion_he proc~write_bb_d_d->proc~d_d_fusion_he proc~d_d_fusion_t d_d_fusion_t proc~write_bb_d_d->proc~d_d_fusion_t proc~write_bb_h_aq->h5gclose_f proc~write_bb_h_aq->h5gcreate_f proc~write_bb_h_aq->h5ltset_attribute_string_f proc~write_bb_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bb_h_aq->h5ltmake_dataset_int_f proc~write_bb_h_aq->h5ltmake_dataset_double_f proc~aq_cx Aq_cx proc~write_bb_h_aq->proc~aq_cx proc~aq_ioniz Aq_ioniz proc~write_bb_h_aq->proc~aq_ioniz proc~aq_excit Aq_excit proc~write_bb_h_aq->proc~aq_excit proc~write_bt_d_d->h5gclose_f proc~write_bt_d_d->h5gcreate_f proc~write_bt_d_d->h5ltset_attribute_string_f proc~write_bt_d_d->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_d_d->h5ltmake_dataset_int_f proc~write_bt_d_d->h5ltmake_dataset_double_f proc~write_bt_d_d->interface~bt_maxwellian proc~write_bt_h_aq->h5gclose_f proc~write_bt_h_aq->h5gcreate_f proc~write_bt_h_aq->h5ltset_attribute_string_f proc~write_bt_h_aq->interface~h5ltmake_compressed_dataset_double_f proc~write_bt_h_aq->h5ltmake_dataset_int_f proc~write_bt_h_aq->h5ltmake_dataset_double_f proc~write_bt_h_aq->interface~bt_maxwellian proc~h5ltmake_compressed_dataset_double_f_7 h5ltmake_compressed_dataset_double_f_7 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_7 proc~h5ltmake_compressed_dataset_double_f_2 h5ltmake_compressed_dataset_double_f_2 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_2 proc~h5ltmake_compressed_dataset_double_f_1 h5ltmake_compressed_dataset_double_f_1 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_1 proc~h5ltmake_compressed_dataset_double_f_3 h5ltmake_compressed_dataset_double_f_3 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_3 proc~h5ltmake_compressed_dataset_double_f_4 h5ltmake_compressed_dataset_double_f_4 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_4 proc~h5ltmake_compressed_dataset_double_f_5 h5ltmake_compressed_dataset_double_f_5 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_5 proc~h5ltmake_compressed_dataset_double_f_6 h5ltmake_compressed_dataset_double_f_6 interface~h5ltmake_compressed_dataset_double_f->proc~h5ltmake_compressed_dataset_double_f_6 h5dwrite_f h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_7->h5dwrite_f h5sclose_f h5sclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5sclose_f h5pset_deflate_f h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_deflate_f h5dcreate_f h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5dcreate_f h5pset_chunk_f h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_chunk_f h5pclose_f h5pclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5pclose_f h5dclose_f h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_7->h5ltmake_dataset_double_f h5pset_shuffle_f h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_7->h5pset_shuffle_f h5screate_simple_f h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_7->h5screate_simple_f h5pcreate_f h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_7->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_2->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_2->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_2->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_2->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_2->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_2->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_2->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_1->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_1->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_1->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_1->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_1->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_1->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_1->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_3->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_3->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_3->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_3->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_3->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_3->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_3->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_4->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_4->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_4->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_4->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_4->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_4->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_4->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_5->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_5->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_5->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_5->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_5->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_5->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_5->h5pcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dwrite_f proc~h5ltmake_compressed_dataset_double_f_6->h5sclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_deflate_f proc~h5ltmake_compressed_dataset_double_f_6->h5dcreate_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_chunk_f proc~h5ltmake_compressed_dataset_double_f_6->h5pclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5dclose_f proc~h5ltmake_compressed_dataset_double_f_6->h5ltmake_dataset_double_f proc~h5ltmake_compressed_dataset_double_f_6->h5pset_shuffle_f proc~h5ltmake_compressed_dataset_double_f_6->h5screate_simple_f proc~h5ltmake_compressed_dataset_double_f_6->h5pcreate_f proc~bt_maxwellian_n bt_maxwellian_n interface~bt_maxwellian->proc~bt_maxwellian_n proc~bt_maxwellian_q_n bt_maxwellian_q_n interface~bt_maxwellian->proc~bt_maxwellian_q_n proc~bt_maxwellian_q_n_m bt_maxwellian_q_n_m interface~bt_maxwellian->proc~bt_maxwellian_q_n_m proc~bt_maxwellian_eb bt_maxwellian_eb interface~bt_maxwellian->proc~bt_maxwellian_eb proc~bt_maxwellian_n_m bt_maxwellian_n_m interface~bt_maxwellian->proc~bt_maxwellian_n_m proc~simpsons_rule simpsons_rule proc~bt_maxwellian_n->proc~simpsons_rule proc~bt_maxwellian_q_n->proc~simpsons_rule proc~bt_maxwellian_q_n_m->proc~simpsons_rule proc~bt_maxwellian_eb->proc~simpsons_rule proc~bt_maxwellian_n_m->proc~simpsons_rule proc~p_excit_n p_excit_n proc~p_excit->proc~p_excit_n proc~p_ioniz_n p_ioniz_n proc~p_ioniz->proc~p_ioniz_n proc~p_cx_n p_cx_n proc~p_cx->proc~p_cx_n proc~p_excit_2_janev p_excit_2_janev proc~p_excit_n->proc~p_excit_2_janev proc~p_excit_1_janev p_excit_1_janev proc~p_excit_n->proc~p_excit_1_janev proc~p_excit_3_janev p_excit_3_janev proc~p_excit_n->proc~p_excit_3_janev proc~p_excit_2_3_janev p_excit_2_3_janev proc~p_excit_2_janev->proc~p_excit_2_3_janev proc~p_excit_2_10_janev p_excit_2_10_janev proc~p_excit_2_janev->proc~p_excit_2_10_janev proc~p_excit_2_8_janev p_excit_2_8_janev proc~p_excit_2_janev->proc~p_excit_2_8_janev proc~p_excit_2_9_janev p_excit_2_9_janev proc~p_excit_2_janev->proc~p_excit_2_9_janev proc~p_excit_2_5_janev p_excit_2_5_janev proc~p_excit_2_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev p_excit_2_6_janev proc~p_excit_2_janev->proc~p_excit_2_6_janev proc~p_excit_2_4_janev p_excit_2_4_janev proc~p_excit_2_janev->proc~p_excit_2_4_janev proc~p_excit_2_7_janev p_excit_2_7_janev proc~p_excit_2_janev->proc~p_excit_2_7_janev proc~p_excit_1_2_janev p_excit_1_2_janev proc~p_excit_1_janev->proc~p_excit_1_2_janev proc~p_excit_1_5_janev p_excit_1_5_janev proc~p_excit_1_janev->proc~p_excit_1_5_janev proc~p_excit_1_6_janev p_excit_1_6_janev proc~p_excit_1_janev->proc~p_excit_1_6_janev proc~p_excit_1_3_janev p_excit_1_3_janev proc~p_excit_1_janev->proc~p_excit_1_3_janev proc~p_excit_1_4_janev p_excit_1_4_janev proc~p_excit_1_janev->proc~p_excit_1_4_janev proc~p_excit_3_4_janev p_excit_3_4_janev proc~p_excit_3_janev->proc~p_excit_3_4_janev proc~p_excit_3_8_janev p_excit_3_8_janev proc~p_excit_3_janev->proc~p_excit_3_8_janev proc~p_excit_3_10_janev p_excit_3_10_janev proc~p_excit_3_janev->proc~p_excit_3_10_janev proc~p_excit_3_5_janev p_excit_3_5_janev proc~p_excit_3_janev->proc~p_excit_3_5_janev proc~p_excit_3_9_janev p_excit_3_9_janev proc~p_excit_3_janev->proc~p_excit_3_9_janev proc~p_excit_3_6_janev p_excit_3_6_janev proc~p_excit_3_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev p_excit_3_7_janev proc~p_excit_3_janev->proc~p_excit_3_7_janev proc~p_excit_2_10_janev->proc~p_excit_2_5_janev proc~p_excit_2_8_janev->proc~p_excit_2_5_janev proc~p_excit_2_9_janev->proc~p_excit_2_5_janev proc~p_excit_2_6_janev->proc~p_excit_2_5_janev proc~p_excit_2_7_janev->proc~p_excit_2_5_janev proc~p_excit_3_8_janev->proc~p_excit_3_6_janev proc~p_excit_3_10_janev->proc~p_excit_3_6_janev proc~p_excit_3_9_janev->proc~p_excit_3_6_janev proc~p_excit_3_7_janev->proc~p_excit_3_6_janev proc~p_ioniz_4_omullane p_ioniz_4_omullane proc~p_ioniz_n->proc~p_ioniz_4_omullane proc~p_ioniz_5_omullane p_ioniz_5_omullane proc~p_ioniz_n->proc~p_ioniz_5_omullane proc~p_ioniz_3_omullane p_ioniz_3_omullane proc~p_ioniz_n->proc~p_ioniz_3_omullane proc~p_ioniz_1_janev p_ioniz_1_janev proc~p_ioniz_n->proc~p_ioniz_1_janev proc~p_ioniz_2_omullane p_ioniz_2_omullane proc~p_ioniz_n->proc~p_ioniz_2_omullane proc~p_cx_janev p_cx_janev proc~p_cx_n->proc~p_cx_janev proc~p_cx_3 p_cx_3 proc~p_cx_n->proc~p_cx_3 proc~p_cx_1_4_adas p_cx_1_4_adas proc~p_cx_n->proc~p_cx_1_4_adas proc~p_cx_1 p_cx_1 proc~p_cx_n->proc~p_cx_1 proc~p_cx_2 p_cx_2 proc~p_cx_n->proc~p_cx_2 proc~m_spread m_spread proc~p_cx_n->proc~m_spread proc~p_cx_3_4_adas p_cx_3_4_adas proc~p_cx_n->proc~p_cx_3_4_adas proc~p_cx_3_5_adas p_cx_3_5_adas proc~p_cx_n->proc~p_cx_3_5_adas proc~p_cx_1_janev p_cx_1_janev proc~p_cx_janev->proc~p_cx_1_janev proc~p_cx_3_janev p_cx_3_janev proc~p_cx_janev->proc~p_cx_3_janev proc~p_cx_n_janev p_cx_n_janev proc~p_cx_janev->proc~p_cx_n_janev proc~p_cx_2_janev p_cx_2_janev proc~p_cx_janev->proc~p_cx_2_janev proc~p_cx_3->proc~p_cx_janev proc~p_cx_3->proc~p_cx_1 proc~p_cx_3->proc~m_spread proc~p_cx_3->proc~p_cx_3_4_adas proc~p_cx_3->proc~p_cx_3_5_adas proc~p_cx_3_2_adas p_cx_3_2_adas proc~p_cx_3->proc~p_cx_3_2_adas proc~p_cx_3_3_adas p_cx_3_3_adas proc~p_cx_3->proc~p_cx_3_3_adas proc~p_cx_1_3_adas p_cx_1_3_adas proc~p_cx_3->proc~p_cx_1_3_adas proc~p_cx_3_6inf_adas p_cx_3_6inf_adas proc~p_cx_3->proc~p_cx_3_6inf_adas proc~p_cx_1->proc~p_cx_janev proc~p_cx_1->proc~p_cx_1_4_adas proc~p_cx_1->proc~p_cx_1_3_adas proc~p_cx_1_1_adas p_cx_1_1_adas proc~p_cx_1->proc~p_cx_1_1_adas proc~p_cx_1_2_adas p_cx_1_2_adas proc~p_cx_1->proc~p_cx_1_2_adas proc~p_cx_2->proc~p_cx_janev proc~p_cx_2->proc~m_spread proc~p_cx_2->proc~p_cx_1_2_adas proc~p_cx_2_3_adas p_cx_2_3_adas proc~p_cx_2->proc~p_cx_2_3_adas proc~p_cx_2_2_adas p_cx_2_2_adas proc~p_cx_2->proc~p_cx_2_2_adas proc~e_ioniz_n e_ioniz_n proc~e_ioniz->proc~e_ioniz_n proc~e_excit_n e_excit_n proc~e_excit->proc~e_excit_n proc~e_ioniz_2_janev e_ioniz_2_janev proc~e_ioniz_n->proc~e_ioniz_2_janev proc~e_ioniz_1_janev e_ioniz_1_janev proc~e_ioniz_n->proc~e_ioniz_1_janev proc~e_ioniz_3_janev e_ioniz_3_janev proc~e_ioniz_n->proc~e_ioniz_3_janev proc~e_excit_1_janev e_excit_1_janev proc~e_excit_n->proc~e_excit_1_janev proc~e_excit_2_3_janev e_excit_2_3_janev proc~e_excit_n->proc~e_excit_2_3_janev proc~e_excit_f e_excit_f proc~e_excit_n->proc~e_excit_f proc~e_excit_1_janev->proc~e_excit_f proc~e_excit_1_3_janev e_excit_1_3_janev proc~e_excit_1_janev->proc~e_excit_1_3_janev proc~e_excit_1_2_janev e_excit_1_2_janev proc~e_excit_1_janev->proc~e_excit_1_2_janev proc~e_excit_1_5_janev e_excit_1_5_janev proc~e_excit_1_janev->proc~e_excit_1_5_janev proc~e_excit_1_4_janev e_excit_1_4_janev proc~e_excit_1_janev->proc~e_excit_1_4_janev proc~aq_cx_n Aq_cx_n proc~aq_cx->proc~aq_cx_n proc~aq_ioniz_n Aq_ioniz_n proc~aq_ioniz->proc~aq_ioniz_n proc~aq_excit_n Aq_excit_n proc~aq_excit->proc~aq_excit_n proc~aq_cx_n_adas Aq_cx_n_adas proc~aq_cx_n->proc~aq_cx_n_adas proc~aq_cx_n_janev Aq_cx_n_janev proc~aq_cx_n->proc~aq_cx_n_janev proc~b5_cx_1_adas B5_cx_1_adas proc~aq_cx_n_adas->proc~b5_cx_1_adas proc~c6_cx_2_adas C6_cx_2_adas proc~aq_cx_n_adas->proc~c6_cx_2_adas proc~c6_cx_1_adas C6_cx_1_adas proc~aq_cx_n_adas->proc~c6_cx_1_adas proc~c6_cx_3_adas C6_cx_3_adas proc~aq_cx_n_adas->proc~c6_cx_3_adas proc~b5_cx_2_adas B5_cx_2_adas proc~aq_cx_n_adas->proc~b5_cx_2_adas proc~c6_cx_1_janev C6_cx_1_janev proc~aq_cx_n_janev->proc~c6_cx_1_janev proc~b5_cx_1_janev B5_cx_1_janev proc~aq_cx_n_janev->proc~b5_cx_1_janev proc~b5_ioniz_1_janev B5_ioniz_1_janev proc~aq_ioniz_n->proc~b5_ioniz_1_janev proc~aq_ioniz_n_janev Aq_ioniz_n_janev proc~aq_ioniz_n->proc~aq_ioniz_n_janev proc~c6_ioniz_1_janev C6_ioniz_1_janev proc~aq_ioniz_n->proc~c6_ioniz_1_janev proc~aq_excit_2_janev Aq_excit_2_janev proc~aq_excit_n->proc~aq_excit_2_janev proc~aq_excit_n_janev Aq_excit_n_janev proc~aq_excit_n->proc~aq_excit_n_janev proc~aq_excit_1_janev Aq_excit_1_janev proc~aq_excit_n->proc~aq_excit_1_janev proc~aq_excit_3_janev Aq_excit_3_janev proc~aq_excit_n->proc~aq_excit_3_janev proc~aq_excit_2_7_janev Aq_excit_2_7_janev proc~aq_excit_2_janev->proc~aq_excit_2_7_janev proc~aq_excit_2_10_janev Aq_excit_2_10_janev proc~aq_excit_2_janev->proc~aq_excit_2_10_janev proc~aq_excit_2_6_janev Aq_excit_2_6_janev proc~aq_excit_2_janev->proc~aq_excit_2_6_janev proc~aq_excit_2_4_janev Aq_excit_2_4_janev proc~aq_excit_2_janev->proc~aq_excit_2_4_janev proc~aq_excit_2_5_janev Aq_excit_2_5_janev proc~aq_excit_2_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev Aq_excit_2_9_janev proc~aq_excit_2_janev->proc~aq_excit_2_9_janev proc~aq_excit_2_8_janev Aq_excit_2_8_janev proc~aq_excit_2_janev->proc~aq_excit_2_8_janev proc~aq_excit_2_3_janev Aq_excit_2_3_janev proc~aq_excit_2_janev->proc~aq_excit_2_3_janev proc~aq_excit_1_4_janev Aq_excit_1_4_janev proc~aq_excit_1_janev->proc~aq_excit_1_4_janev proc~aq_excit_1_5_janev Aq_excit_1_5_janev proc~aq_excit_1_janev->proc~aq_excit_1_5_janev proc~aq_excit_1_2_janev Aq_excit_1_2_janev proc~aq_excit_1_janev->proc~aq_excit_1_2_janev proc~aq_excit_1_3_janev Aq_excit_1_3_janev proc~aq_excit_1_janev->proc~aq_excit_1_3_janev proc~aq_excit_3_4_janev Aq_excit_3_4_janev proc~aq_excit_3_janev->proc~aq_excit_3_4_janev proc~aq_excit_3_10_janev Aq_excit_3_10_janev proc~aq_excit_3_janev->proc~aq_excit_3_10_janev proc~aq_excit_3_5_janev Aq_excit_3_5_janev proc~aq_excit_3_janev->proc~aq_excit_3_5_janev proc~aq_excit_3_9_janev Aq_excit_3_9_janev proc~aq_excit_3_janev->proc~aq_excit_3_9_janev proc~aq_excit_3_8_janev Aq_excit_3_8_janev proc~aq_excit_3_janev->proc~aq_excit_3_8_janev proc~aq_excit_3_6_janev Aq_excit_3_6_janev proc~aq_excit_3_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev Aq_excit_3_7_janev proc~aq_excit_3_janev->proc~aq_excit_3_7_janev proc~aq_excit_2_7_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_10_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_6_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_9_janev->proc~aq_excit_2_5_janev proc~aq_excit_2_8_janev->proc~aq_excit_2_5_janev proc~aq_excit_3_10_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_9_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_8_janev->proc~aq_excit_3_6_janev proc~aq_excit_3_7_janev->proc~aq_excit_3_6_janev var panprogramgenerate_tablesCallsGraph = svgPanZoom('#programgenerate_tablesCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables namelist_file arg tables_file n_max m_max time_arr time_start time_end hour minu sec argc max_threads nthreads fid gid error exis Variables Type Attributes Name Initial character(len=200) :: namelist_file character(len=3) :: arg character(len=200) :: tables_file = '' integer :: n_max integer :: m_max integer, dimension(8) :: time_arr integer, dimension(8) :: time_start integer, dimension(8) :: time_end integer :: hour integer :: minu integer :: sec integer :: argc integer :: max_threads integer :: nthreads integer(kind=HID_T) :: fid integer(kind=HID_T) :: gid integer :: error logical :: exis","tags":"","loc":"program/generate_tables.html","title":"generate_tables – FIDASIM"},{"text":"Introduction In fusion plasmas fast-ions can undergo the following process with injected neutral Hydrogen:\n H&#94;+ + H(n) \\rightarrow H&#94;\\ast(m) + H&#94;+ \nwhere H&#94;\\ast(m) is an excited state of Hydrogen.\nThe newly created fast-neutral H&#94;\\ast(m) can then be collisionally de-excited to a lower state, emitting a doppler shifted photon as illustrated below. Both the fast-neutral and the photon contain information about the velocity of fast-ion before it was neutralized.\nThere are two types diagnostics that take advantage of this fact: Fast-ion D-α (FIDA) diagnostics and Neutral Particle Analyzers (NPA).\nThe interpretation of the diagnostic signals requires modeling of the above process which has a complicated dependence on the plasma parameters, electromagnetic fields, and neutral beam and diagnostic geometry. Towards this end, FIDASIM was created. History The very first implementation of FIDASIM was written by Yadong Luo and Bill Heidbrink while Yadong was working on his thesis .\nSubsequently, Deyong Liu added features to simulate NPA signals. The IDL version of the code was distributed for public use and documented in a journal publication . Originally, FIDASIM was written in the IDL programming language and was prohibitively slow.\nAs a part of his thesis Ben Geiger wrote a version of FIDASIM written in Fortran 90.\nThis prototype version was parallelized using OpenMP and was orders of magnitude faster but was not as easy to use as the IDL version and was difficult to port to different devices. Most recently, Luke Stagner as a part of his thesis has rewritten Ben Geiger's Fortran 90 version to be compatible with any axisymmetric fusion device as well as additional functionality.\nLuke has also put special effort on making FIDASIM user friendly; the result of which you are currently reading and should be eternally grateful. Capabilities Currently, FIDASIM has routines for calculating: Neutral beam deposition and birth profile Halo neutral density Visible Bremsstrahlung Beam and Halo spectra FIDA spectra NPA Flux FIDA and NPA phase-space sensitivities i.e. weight functions Installation For installation instructions check out our Getting Started guide.","tags":"","loc":"page//index.html","title":"User Guide – FIDASIM"},{"text":"Getting Started Welcome the the FIDASIM Getting Started guide. Click the section that catches your fancy. Installation Preprocessing Inputs Running FIDASIM Reading Outputs Devices using FIDASIM","tags":"","loc":"page/01_getting_started/index.html","title":"Getting Started – FIDASIM"},{"text":"Installing FIDASIM So you have decided to install FIDASIM. Don't worry this should be relatively painless. Note If you experiance problems installing FIDASIM you did something wrong and you should let us know so we can laugh at you (and also help you) The following code snippets assumes you are using a BASH shell.\nTo figure out what shell you currently have run echo $SHELL to find out. Installing FIDASIM Dependencies Getting FIDASIM source Downloading source directly Cloning the git repository Setting up environmental variables Building FIDASIM Generating Atomic Tables Run a test case Now what Dependencies FIDASIM has the following dependencies: Linux because all other operating systems are inferior Make for building FIDASIM. Fortran, C, and C++ compilers. GNU(>v4.6) and Intel(>13) compilers are supported.\n  Note you cannot mix and match different compilers. Anaconda Python for python scripts and pre-processing. IDL for pre-processing (Optional) zlib for file compression. HDF5 1.8.16 for reading and writing data files (Included) EFIT for electro-magnetic fields (Partially Included) git for version control (Optional) Ford for creating HTML documentation (Optional) LinkChecker for validating HTML documentation (Optional) Getting FIDASIM source It's rather difficult to run software you haven't downloaded. There are two ways of getting the source code. Downloading source directly The most recent version of FIDASIM (1.0.1) can be downloaded from here Once you have downloaded the .tar.gz or .zip file unpack it using the following commands. tar -zxf FIDASIM-1.0.1.tar.gz or if you downloaded the .zip file unzip FIDASIM-1.0.1.zip There should now be a directory named FIDASIM-1.0.1 in your current directory. Enter the directory using cd FIDASIM-1.0.1 Cloning the git repository If you are planning to develop FIDASIM it is best to use git. git clone https://github.com/D3DEnergetic/FIDASIM.git FIDASIM cd FIDASIM By default you will be on the master branch which may or may not be in a usable state.\nTo use the release version run the command git checkout v1.0.1 Setting up environmental variables FIDASIM needs to know where some things are so you have to set the following environmental variables in your .bashrc file located in your home directory. export FIDASIM_DIR = /path/to/fidasim/install/directory export FC = gfortran #use 'ifort' for Intel Fortran compiler export CC = gcc #use 'icc' for Intel C compiler export CXX = g++ #use 'icpc' for Intel C++ compiler #For using helper routines export PATH = $FIDASIM_DIR /deps/hdf5/bin: $FIDASIM_DIR /lib/scripts: $PATH export IDL_PATH = \"+ $FIDASIM_DIR : $IDL_PATH :<IDL_DEFAULT>\" export PYTHONPATH = $FIDASIM_DIR /lib/python: $PYTHONPATH ulimit -s unlimited #Omit this if you like segfaults replacing /path/to/fidasim/install/directory with the real directory. To set the environmental variables in the current shell run source ~/.bashrc Building FIDASIM Once you are in the source directory (and have all the dependencies installed) run the following make Once running, go get a coffee since it will take a while because HDF5 is being built as well. Once make has completed check if FIDASIM compiled correctly. user@computer:~/FIDASIM-1.0.1$ ./fidasim\n   ____ ____ ___   ___    ____ ____ __  ___\n  / __//  _// _ \\ / _ | / __//  _// | /  /\n / _/ _/ / / // // __ | _ \\ \\ _/ / / / | _/ /\n/_/  /___//____//_/ | _ | /___//___//_/  /_/\n\nVersion: 1 .0.1\n\nFIDASIM is released as open source code under the MIT Licence.\nFor more information visit http://d3denergetic.github.io/FIDASIM/\n\nusage: ./fidasim namelist_file [ num_threads ] Good job! You installed FIDASIM! But wait there's more. Generating Atomic Tables Calculating reaction rates on the fly is time consuming so we need to pre-compute them to save time.\nThe following code snippit will generate the atomic tables using the default settings.\nThe default settings should be appropriate for most use cases, however, it may be necessary to generate custom atomic tables.\nIn that case edit the file tables/default_settings.dat before running the following command make atomic_tables Warning This is computationally expensive so make sure you run this on a computer\nwhere you won't get angry emails for using up all the CPU's.\nOptionally you can add NTHREADS=# to the command to set the number of threads. Now would be a good time to get more coffee... or maybe a nap. Run a test case From within IDL IDL > run_tests, \"/place/where/you/want/the/output\" Some stuff that will make sense later will flash by and when its done you should see something like SUCCESS: FIDASIM pre-processing completed\nTo run FIDASIM use the following command\n/u/lstagner/FIDASIM/fidasim /p/fida/lstagner/TEST/test_1a_inputs.dat Now do what the computer says.\nThink of as good practice for when the robots take over . It should print out the following. [lstagner@dawson061]% /u/lstagner/FIDASIM/fidasim /p/fida/lstagner/TEST/test_1a_inputs.dat\n   ____ ____ ___   ___    ____ ____ __  ___\n  / __//  _// _ \\ / _ |  / __//  _//  |/  /\n / _/ _/ / / // // __ | _\\ \\ _/ / / /|_/ /\n/_/  /___//____//_/ |_|/___//___//_/  /_/\n\nVersion: 1.0.0\n\nFIDASIM is released as open source code under the MIT Licence.\nFor more information visit http://d3denergetic.github.io/FIDASIM/\n\n---- Shot settings ----\n Shot:        1\n Time: 1000 [ms]\n Runid: test_1a\n\n---- Input files ----\n Tables file: /u/lstagner/FIDASIM/tables/atomic_tables.h5\n Geometry file: /p/fida/lstagner/TEST/test_1a_geometry.h5\n Equilibrium file: /p/fida/lstagner/TEST/test_1a_equilibrium.h5\n Distribution file: /p/fida/lstagner/TEST/test_1a_distribution.h5\n\n---- OpenMP settings ----\n Number of threads: 16\n\n---- Beam grid settings ----\n Nx:  50\n Ny:  60\n Nz:  70\n dV:  8.00 [cm&#94;3]\n alpha:  0.00 [rad]\n beta:   0.00 [rad]\n gamma:  0.00 [rad]\n origin: [   0.00,   0.00,   0.00] [cm]\n\n---- Interpolation grid settings ----\n Nr:  70\n Nz: 100\n dA: 4.10 [cm&#94;2]\n\n---- Neutral beam settings ----\n Beam: test_beam\n Power:    1.70 [MW]\n Voltage: 72.50 [keV]\n\n---- Atomic tables settings ----\n Maximum n/m:  6\n Beam/Fast-ion mass:  2.014 [amu]\n Thermal/Bulk-ion mass:  2.014 [amu]\n Impurity mass: 12.011 [amu]\n\n---- Fast-ion distribution settings ----\n Distribution type: Fast-ion Density Function F(energy,pitch,R,Z)\n Nenergy =   6\n Npitch  =   6\n Energy range = [67.33, 75.44]\n Pitch  range = [-0.10, 0.10]\n\n---- FIDA/BES settings ----\n FIDA/BES System: SPECTRAL\n Number of channels:   3\n\n---- NPA settings ----\n NPA System: NPA\n Number of channels:   3\n Calculating hit probabilities for NPA channels\n\nndmc:     1:43:23\n     # of markers:     50000\n   birth profile written to: /p/fida/lstagner/TEST/test_1a_birth.h5\n\ndcx:      1:43:41\n     # of markers:    505020\n   dcx written to: /p/fida/lstagner/TEST/test_1a_dcx.h5\n\nhalo:     1:44:32\n     # of markers:    505180\n     # of markers:    310573\n     # of markers:    188148\n     # of markers:    110872\n     # of markers:     62806\n     # of markers:     32484\n     # of markers:     13881\n   neutral density written to: /p/fida/lstagner/TEST/test_1a_neutrals.h5\n\nbremsstrahlung:     1:46:25\n\nfida:     1:46:25\n     # of markers:   5049813\n\n   Spectra written to: /p/fida/lstagner/TEST/test_1a_spectra.h5\n\nnpa:     1:47:46\n     # of markers:    505074\nNumber of NPA particles that hit a detector:   125638\n\n   NPA data written to: /p/fida/lstagner/TEST/test_1a_npa.h5\n\nfida weight function:     1:49:46\n Number of Channels:   3\n Nlambda: 1000\n Nenergy:  50\n Npitch:  50\n Ngyro: 100\n Maximum Energy:  100.00\n LOS averaged: True\n\n   Channel:   1\n   Radius:  200.00\n   Mean Fast-ion Density:    7.97429E+11\n\n   Channel:   2\n   Radius:  170.00\n   Mean Fast-ion Density:    7.98346E+11\n\n   Channel:   3\n   Radius:  140.00\n   Mean Fast-ion Density:    7.98330E+11\n\n   FIDA weights written to: /p/fida/lstagner/TEST/test_1a_fida_weights.h5\n\nnpa weight function:     1:50:02\n Number of Channels:   3\n Nenergy:  50\n Npitch:  50\n Maximum energy:  100.00\n\n   Channel:   1\n   Radius:    200.000\n   Flux:      1.22243E+14\n   Weight:    3.79893E+03\n\n   Channel:   2\n   Radius:    170.000\n   Flux:      1.07364E+14\n   Weight:    1.85565E+03\n\n   Channel:   3\n   Radius:    140.000\n   Flux:      3.46488E+13\n   Weight:    8.81099E+02\n\n   NPA weights written to: /p/fida/lstagner/TEST/test_1a_npa_weights.h5\n\nEND: hour, minute, second:  1:53:07\nduration:                   0:15:53 Congratulations! You followed the instructions. Now what Most likely you won't be satisfied by just running a test case. Click here to learn how to make the input files used by FIDASIM.","tags":"","loc":"page/01_getting_started/01_install.html","title":"Installation – FIDASIM"},{"text":"Preprocessing Inputs Preprocessing Inputs Create FIDASIM input files using PREFIDA Making Grids Reading GEQDSK files Extracting GEQDSK file and Plasma Parameters from TRANSP Translating NUBEAM Neutral Beam Geometry Extracting the Fast-ion Distribution Function from TRANSP/NUBEAM Reading NUBEAM/SPIRAL Fast-ion Distributions Create FIDASIM input files using PREFIDA FIDASIM requires inputs to be in a specific format.\nPREFIDA( IDL , Python ) is an routine that takes the required inputs, checks their validity, and transforms them into a form FIDASIM understands. PREFIDA is called as follows IDL > prefida, inputs, grid, nbi, plasma, fields, dist , spec = spec, npa = npa or using Python >>> import fidasim >>> fidasim . prefida ( inputs , grid , nbi , plasma , fields , dist , spec = spec , npa = npa ) where arguments are defined as follows. Click the argument's description for extreme detail. inputs : General Settings grid : Interpolation grid nbi : Neutral Beam Geometry fields : Electromagnetic Fields plasma : Plasma Parameters dist : Fast-ion Distribution spec : Spectral Geometry npa : NPA Geometry PREFIDA will create the following files Namelist File Geometry File Equilibrium File Distribution File Most devices may have already setup helper routines to make running FIDASIM and Prefida easy. \nClick here to find out if someone has done your work for you. Making Grids PREFIDA uses two types of grids: the Interpolation Grid and the Beam Grid . \nThe Interpolation Grid is 2D grid in the R-Z plane and as the name suggests it is used for interpolating the plasma parameters and the electromagnetic fields . \nThe routine rz_grid ( IDL , Python ) can be used to easily create the interpolation grid structure. IDL > grid = rz_grid(rmin,rmax,nr,zmin,zmax,nz) or in Python >>> from fidasim.utils import rz_grid >>> grid = rz_grid ( rmin , rmax , nr , zmin , zmax , nz ) The beam grid is a 3D grid used for most of the calculations in FIDASIM. It represents the 3D volume where the neutral beam lives and interacts with the plasma. \nTo maximize the resolution of this grid it is useful to align the beam grid with the beam centerline.\nThe routine beam_grid ( IDL , Python ) calculates from the neutral beam geometry the optimal beam grid settings that would align the grid with the beam sightline. IDL > bgrid = beam_grid(nbi,rstart) or in Python >>> from fidasim.utils import beam_grid >>> bgrid = beam_grid ( nbi , rstart ) Reading GEQDSK files Most tokamaks use EFIT to reconstruct the MHD equilibrium.\nTo make things easy we provide the IDL routine read_geqdsk.pro to calculate the fields structure from EFITs GEQDSK file. IDL> fields = read_geqdsk('g159243.00300',grid,flux=flux) where grid is the interpolation grid and the flux keyword is a named variable that recieves the torodial flux upon executation. Extracting GEQDSK file and Plasma Parameters from TRANSP It is convenient to grab FIDASIM inputs from previously calculated TRANSP runs. The python script, extract_transp_geqdsk , can be used to extract the MHD equilibrium from TRANSP's .DATA* files .\nFor example: extract_transp_geqdsk /p/transparch/result/NSTX/14 159243H06 will create a GEQDSK file for every .DATA* file in the 159243H06 TRANSP run.\nRun extract_transp_geqdsk -h for the full documentation. The IDL routine extract_transp_plasma.pro creates the plasma structure at a given time. IDL> plasma = extract_transp_plasma(\"159243H06.CDF\",1.02,grid,flux) where grid is the interpolation grid and flux is the torodial flux. Translating NUBEAM Neutral Beam Geometry The IDL routine nubeam_geometry.pro can be used to translate the NUBEAM neutral beam geometry definition into the correct format . IDL> nbi = nubeam_geometry(nubeam) where nubeam is a structure containing the NUBEAM geometry variables taken from the TRANSP namelist. Extracting the Fast-ion Distribution Function from TRANSP/NUBEAM The python script, extract_transp_fbm , provides a easy way to extract the fast-ion distribution. For example: extract_transp_fbm /p/transparch/result/NSTX/14 159243H06 extracts a distribution function for every .DATA* file in the 159243H06 TRANSP run.\nRun extract_transp_fbm -h for the full documentation. Reading NUBEAM/SPIRAL Fast-ion Distributions Out of the box, FIDASIM provides IDL routines for reading different fast-ion distributions.\nWe provide routines for: read_nubeam.pro : TRANSP/NUBEAM distribution functions read_mc_nubeam.pro : Monte Carlo TRANSP/NUBEAM Guiding Center distribution read_spiral.pro : SPIRAL Guiding Center distribution IDL> f = read_nubeam(nubeam_distribution,grid,btipsign = -1) \nIDL> mcf = read_mc_nubeam(mc_nubeam_distribution,Ntotal=1e19,btipsign=-1)\nIDL> s = read_spiral(spiral_file,Ntotal=1e19,btipsign=-1)","tags":"","loc":"page/01_getting_started/02_preprocess.html","title":"Preprocessing Inputs – FIDASIM"},{"text":"Running FIDASIM Running FIDASIM Recommended Hardware Running Interactively Submitting to a clusters job schedular using submit_fidasim Running FIDASIM is as easy as running lstagner@computer:~/FIDASIM$ ./fidasim \n   ____ ____ ___   ___    ____ ____ __  ___\n  / __//  _// _ \\ / _ |  / __//  _//  |/  /\n / _/ _/ / / // // __ | _\\ \\ _/ / / /|_/ / \n/_/  /___//____//_/ |_|/___//___//_/  /_/  \n\nVersion: 1.0.0\n\nFIDASIM is released as open source code under the MIT Licence.\nFor more information visit http://d3denergetic.github.io/FIDASIM/\n\nusage: ./fidasim namelist_file [num_threads] Actually having FIDASIM produce something takes a bit of thought Recommended Hardware The following settings will give a reasonable runtime. 32 threads on a shared memory node (All calculations are done on a single node) At least 2 GB of memory Warning By default FIDASIM will use all the threads available. If another process is hogging a core it will cause FIDASIM to stall. To prevent this use the num_threads optional argument Running Interactively [lstagner@dawson061]% ./fidasim /p/fida/lstagner/TEST/test_1a_inputs.dat 16\n   ____ ____ ___   ___    ____ ____ __  ___\n  / __//  _// _ \\ / _ |  / __//  _//  |/  /\n / _/ _/ / / // // __ | _\\ \\ _/ / / /|_/ / \n/_/  /___//____//_/ |_|/___//___//_/  /_/  \n\nVersion: 1.0.0\n\nFIDASIM is released as open source code under the MIT Licence.\nFor more information visit http://d3denergetic.github.io/FIDASIM/\n\n---- Shot settings ----\n Shot:        1\n Time: 1000 [ms]\n Runid: test_1a\n\n---- Input files ----\n Tables file: /u/lstagner/FIDASIM/tables/atomic_tables.h5\n Geometry file: /p/fida/lstagner/TEST/test_1a_geometry.h5\n Equilibrium file: /p/fida/lstagner/TEST/test_1a_equilibrium.h5\n Distribution file: /p/fida/lstagner/TEST/test_1a_distribution.h5\n\n---- OpenMP settings ----\n Number of threads: 16\n\n---- Beam grid settings ----\n Nx:  50\n Ny:  60\n Nz:  70\n dV:  8.00 [cm&#94;3]\n alpha:  0.00 [rad]\n beta:   0.00 [rad]\n gamma:  0.00 [rad]\n origin: [   0.00,   0.00,   0.00] [cm]\n\n---- Interpolation grid settings ----\n Nr:  70\n Nz: 100\n dA: 4.10 [cm&#94;2]\n\n---- Neutral beam settings ----\n Beam: test_beam               \n Power:    1.70 [MW]\n Voltage: 72.50 [keV]\n\n---- Atomic tables settings ----\n Maximum n/m:  6\n Beam/Fast-ion mass:  2.014 [amu]\n Thermal/Bulk-ion mass:  2.014 [amu]\n Impurity mass: 12.011 [amu]\n\n---- Fast-ion distribution settings ----\n Distribution type: Fast-ion Density Function F(energy,pitch,R,Z)\n Nenergy =   6\n Npitch  =   6\n Energy range = [67.33, 75.44]\n Pitch  range = [-0.10, 0.10]\n\n---- FIDA/BES settings ----\n FIDA/BES System: SPECTRAL\n Number of channels:   3\n\n---- NPA settings ----\n NPA System: NPA\n Number of channels:   3\n Calculating hit probabilities for NPA channels\n\nndmc:     1:43:23\n     # of markers:     50000\n   birth profile written to: /p/fida/lstagner/TEST/test_1a_birth.h5\n\ndcx:      1:43:41\n     # of markers:    505020\n   dcx written to: /p/fida/lstagner/TEST/test_1a_dcx.h5\n\nhalo:     1:44:32\n     # of markers:    505180\n     # of markers:    310573\n     # of markers:    188148\n     # of markers:    110872\n     # of markers:     62806\n     # of markers:     32484\n     # of markers:     13881\n   neutral density written to: /p/fida/lstagner/TEST/test_1a_neutrals.h5\n\nbremsstrahlung:     1:46:25\n\nfida:     1:46:25\n     # of markers:   5049813\n\n   Spectra written to: /p/fida/lstagner/TEST/test_1a_spectra.h5\n\nnpa:     1:47:46\n     # of markers:    505074\nNumber of NPA particles that hit a detector:   125638\n\n   NPA data written to: /p/fida/lstagner/TEST/test_1a_npa.h5\n\nfida weight function:     1:49:46\n Number of Channels:   3\n Nlambda: 1000\n Nenergy:  50\n Npitch:  50\n Ngyro: 100\n Maximum Energy:  100.00\n LOS averaged: True\n\n   Channel:   1\n   Radius:  200.00\n   Mean Fast-ion Density:    7.97429E+11\n\n   Channel:   2\n   Radius:  170.00\n   Mean Fast-ion Density:    7.98346E+11\n\n   Channel:   3\n   Radius:  140.00\n   Mean Fast-ion Density:    7.98330E+11\n\n   FIDA weights written to: /p/fida/lstagner/TEST/test_1a_fida_weights.h5\n\nnpa weight function:     1:50:02\n Number of Channels:   3\n Nenergy:  50\n Npitch:  50\n Maximum energy:  100.00\n\n   Channel:   1\n   Radius:    200.000\n   Flux:      1.22243E+14\n   Weight:    3.79893E+03\n\n   Channel:   2\n   Radius:    170.000\n   Flux:      1.07364E+14\n   Weight:    1.85565E+03\n\n   Channel:   3\n   Radius:    140.000\n   Flux:      3.46488E+13\n   Weight:    8.81099E+02\n\n   NPA weights written to: /p/fida/lstagner/TEST/test_1a_npa_weights.h5\n\nEND: hour, minute, second:  1:53:07\nduration:                   0:15:53 Submitting to a clusters job schedular using submit_fidasim submit_fidasim is a python routine that schedules a FIDASIM job on a cluster. For example lstagner@computer:~$ submit_fidasim /u/lstagner/TEST will submit any incomplete FIDASIM runs in the /u/lstagner/TEST directory. Alternatively lstagner@computer:~$ submit_fidasim /u/lstagner/TEST/test_1a_inputs.dat will submit just the test_1a FIDASIM run.\nSlurm and PBS resource managers are supported. Run submit_fidasim -h for the full documentation.","tags":"","loc":"page/01_getting_started/03_running.html","title":"Running FIDASIM – FIDASIM"},{"text":"Reading FIDASIM Outputs Reading FIDASIM Outputs Using HDF5 tools Using IDL Using Python Using Julia Using HDF5 tools The HDF5 installation provides several useful tools for inspecting HDF5 files. lstagner@computer:~/TEST$ h5ls test_1a_geometry.h5\nnbi                      Group\nnpa                      Group\nspec                     Group\nlstagner@computer:~/TEST$ h5ls test_1a_geometry.h5/nbi\naxis                     Dataset {3}\ndata_source              Dataset {SCALAR}\ndivy                     Dataset {3}\ndivz                     Dataset {3}\nfocy                     Dataset {SCALAR}\nfocz                     Dataset {SCALAR}\nname                     Dataset {SCALAR}\nshape                    Dataset {SCALAR}\nsrc                      Dataset {3}\nwidy                     Dataset {SCALAR}\nwidz                     Dataset {SCALAR}\nlstagner@computer:~/TEST$ h5ls -v test_1a_geometry.h5/nbi/src\nOpened \"test_1a_geometry.h5\" with sec2 driver.\nsrc                      Dataset {3/3}\n    Attribute: description scalar\n        Type:      47-byte null-terminated ASCII string\n        Data:  \"Position of the center of the beam source grid\"\n    Attribute: units scalar\n        Type:      3-byte null-terminated ASCII string\n        Data:  \"cm\"\n    Location:  1:5024\n    Links:     1\n    Chunks:    {3} 24 bytes\n    Storage:   24 logical bytes, 19 allocated bytes, 126.32% utilization\n    Filter-0:  shuffle-2 OPT {8}\n    Filter-1:  deflate-1 OPT {9}\n    Type:      native double\nlstagner@computer:~/TEST$ h5ls -d test_1a_geometry.h5/nbi/src\nsrc                      Dataset {3}\n    Data:\n        (0) 0, -502, 0 Using IDL The IDL routine read_hdf5.pro is provided to read any HDF5 file. IDL > f = read_hdf5( \"./test_1a_geometry.h5\" )\nIDL > help ,f ** Structure < 190eff78 > , 4 tags, length = 1848 , data length = 1830 , refs = 1 : NBI             STRUCT -> < Anonymous > Array[ 1 ]\n   NPA             STRUCT -> < Anonymous > Array[ 1 ]\n   SPEC            STRUCT -> < Anonymous > Array[ 1 ]\n   DESCRIPTION STRING 'Geometric quantities for FIDASIM' IDL > help ,f.nbi ** Structure < 190bc848 > , 13 tags, length = 504 , data length = 498 , refs = 2 : AXIS STRUCT -> < Anonymous > Array[ 1 ]\n   DATA_SOURCE     STRUCT -> < Anonymous > Array[ 1 ]\n   DIVY            STRUCT -> < Anonymous > Array[ 1 ]\n   DIVZ            STRUCT -> < Anonymous > Array[ 1 ]\n   FOCY            STRUCT -> < Anonymous > Array[ 1 ]\n   FOCZ            STRUCT -> < Anonymous > Array[ 1 ]\n   NAME            STRUCT -> < Anonymous > Array[ 1 ]\n   SHAPE           STRUCT -> < Anonymous > Array[ 1 ]\n   SRC             STRUCT -> < Anonymous > Array[ 1 ]\n   WIDY            STRUCT -> < Anonymous > Array[ 1 ]\n   WIDZ            STRUCT -> < Anonymous > Array[ 1 ]\n   DESCRIPTION STRING 'Neutral Beam Geometry' COORDINATE_SYSTEM STRING 'Right-handed cartesian' IDL > help ,f.nbi.src ** Structure < 1909ade8 > , 3 tags, length = 56 , data length = 56 , refs = 2 : DESCRIPTION STRING 'Position of the center of the beam source grid' UNITS STRING 'cm' DATA DOUBLE Array[ 3 ] Using Python The h5py library can be used to read and write HDF5 files. >>> import h5py as h5 >>> f = h5 . File ( \"./test_1a_geometry.h5\" ) >>> [ k for k in f . keys ()] [ 'nbi' , 'npa' , 'spec' ] >>> [ k for k in f [ 'nbi' ] . keys ()] [ 'axis' , 'data_source' , 'divy' , 'divz' , 'focy' , 'focz' , 'name' , 'shape' , 'src' , 'widy' , 'widz' ] >>> f [ \"/nbi/src\" ] . value array ([ 0. , - 502. , 0. ]) Using Julia The HDF5.jl library can be used to read and write HDF5 files. julia > using HDF5 julia > f = h5open ( \"test_1a_geometry.h5\" ) HDF5 data file : test_1a_geometry . h5 julia > names ( f ) 3 - element Array { ByteString , 1 } : \"nbi\" \"npa\" \"spec\" julia > names ( f [ \"/nbi\" ]) 11 - element Array { ByteString , 1 } : \"axis\" \"data_source\" \"divy\" \"divz\" \"focy\" \"focz\" \"name\" \"shape\" \"src\" \"widy\" \"widz\" julia > read ( f [ \"/nbi/src\" ]) 3 - element Array { Float64 , 1 } : 0.0 - 502.0 0.0 julia > h5read ( \"test_1a_geometry.h5\" , \"/nbi/src\" ) 3 - element Array { Float64 , 1 } : 0.0 - 502.0 0.0","tags":"","loc":"page/01_getting_started/04_reading.html","title":"Reading Outputs – FIDASIM"},{"text":"DIII-D FIDASIM is being used at DIII-D for simulating and validating their FIDA and NPA diagnostics.\nIt it also being used in charge exchange recombination spectroscopy to validate deuterium density measurements. The routines for running a DIII-D FIDASIM run are available here A FIDASIM module containing the DIII-D specific routines is available on the Iris cluster. module load fidasim fidasim NSTX-U FIDASIM is being used at NSTX-U for simulating and validating their FIDA and NPA diagnostics. The routines for running a NSTX-U FIDASIM run are available here","tags":"","loc":"page/01_getting_started/05_devices.html","title":"Devices using FIDASIM – FIDASIM"},{"text":"Physics Plasma Parameters, Fields, and Distributions Atomic Tables Collisional Radiative Model Neutral Beam and Halo Spectroscopy Neutral Particle Analyzer Phase-space Sensitivities","tags":"","loc":"page/02_physics/index.html","title":"Physics – FIDASIM"},{"text":"Plasma Parameters and Fields Distributions Guiding Center Distribution Function: F(E,p,R,Z) Guiding Center Monte Carlo Distribution Full-orbit Monte Carlo Distribution Relevent Namelist Settings Fortran References table {\nwidth: 100%;\n}\ntable,th,td {\nborder: 1px solid black;\nborder-collapse: collapse;\n}\nth, td {\npadding: 5px;\n}\nth {\ntext-align: center;\n} Plasma Parameters and Fields It is common in Tokamaks to input the plasma parameters and fields as flux functions.\nHowever, this approach makes several assumptions that may not be true in non-tokamak devices.\nIn FIDASIM the plasma parameters and fields are mapped onto a 2D R-Z grid.\nThis only assumes axisymmetric profiles within the region of interest.\nIn addition to plasma parameters a boolean mask is used to indicate where the plasma and fields are well defined. FIDASIM reads the plasma parameters and fields from an HDF5 file structured as follows... [runid]_equilibrium.h5\n├── plasma          \n└── fields where the plasma group has the following datasets Variable Type Rank Dimensions Units Description nr Int16 0 NA NA Number of radii nz Int16 0 NA NA Number of z values r Float64 1 [ nr ] cm Array of radii z Float64 1 [ nz ] cm Array of z values r2d Float64 2 [ nr , nz ] cm 2D array of radii r = r2d(r,z) z2d Float64 2 [ nr , nz ] cm 2D array of z values z = z2d(r,z) time Float64 0 NA s Time when the plasma parameter data was collected data_source String 0 NA NA Source of the plasma parameter data mask Int16 2 [ nr , nz ] NA Boolean mask that indicates where the plasma is well defined te Float64 2 [ nr , nz ] keV Electron temperature ti Float64 2 [ nr , nz ] keV Ion temperature dene Float64 2 [ nr , nz ] cm&#94;-3 Electron density zeff Float64 2 [ nr , nz ] NA Z-effective vr Float64 2 [ nr , nz ] cm/s Radial component of the bulk plasma rotation/flow vt Float64 2 [ nr , nz ] cm/s Torodial/Phi component of the bulk plasma rotation/flow vz Float64 2 [ nr , nz ] cm/s Z component of the bulk plasma rotation/flow and where the fields group has the following datasets Variable Type Rank Dimensions Units Description nr Int16 0 NA NA Number of radii nz Int16 0 NA NA Number of z values r Float64 1 [ nr ] cm Array of radii z Float64 1 [ nz ] cm Array of z values r2d Float64 2 [ nr , nz ] cm 2D array of radii r = r2d(r,z) z2d Float64 2 [ nr , nz ] cm 2D array of z values z = z2d(r,z) time Float64 0 NA s Time when the fields data were collected/reconstructed data_source String 0 NA NA Source of the fields data mask Int16 2 [ nr , nz ] NA Boolean mask that indicates where the fields are well defined br Float64 2 [ nr , nz ] T Radial component of the magnetic field bt Float64 2 [ nr , nz ] T Torodial/Phi component of the magnetic field bz Float64 2 [ nr , nz ] T Z component of the magnetic field er Float64 2 [ nr , nz ] V/m Radial component of the electric field et Float64 2 [ nr , nz ] V/m Torodial/Phi component of the electric field ez Float64 2 [ nr , nz ] V/m Z component of the electric field Distributions The fast-ion distribution function typically does not have a functional form.\nThis means that we need to input the fast-ion distribution function into FIDASIM.\nFIDASIM accepts three different types of fast-ion distributions. Guiding Center Distribution Function: F(E,p,R,Z) Guiding Center Monte Carlo distribution Full-orbit Monte Carlo distribution Supporting different types of distributions greatly facilitates the study of fast-ion transport. FIDASIM reads the fast-ion distribution from an HDF5 file that has the following variables depending on the distribution type. Guiding Center Distribution Function: F(E,p,R,Z) Variable Type Rank Dimensions Units Description type Int16 0 NA NA Distribution type (1) nr Int16 0 NA NA Number of radii nz Int16 0 NA NA Number of z values r Float64 1 [ nr ] cm Array of radii z Float64 1 [ nz ] cm Array of z values r2d Float64 2 [ nr , nz ] cm 2D array of radii r = r2d(r,z) z2d Float64 2 [ nr , nz ] cm 2D array of z values z = z2d(r,z) time Float64 0 NA s Time of the distribution data_source String 0 NA NA Source of the distribution data nenergy Int16 0 NA NA Number of energy values npitch Int16 0 NA NA Number of pitch values energy Float64 1 [ nenergy ] keV Energy array pitch Float64 1 [ npitch ] NA Pitch array w.r.t magnetic field denf Float64 2 [ nr , nz ] cm&#94;-3 Fast-ion density f Float64 4 [ nenergy , npitch , nr , nz ] fast-ions/(dE dP cm&#94;3) Fast-ion distribution F(E,p,R,Z) The Guiding Center Distribution Function is a function of Energy, pitch, R, and Z.\nThe distribution is mapped on the same R-Z grid as the plasma parameters and fields. Guiding Center Monte Carlo Distribution Variable Type Rank Dimensions Units Description type Int16 0 NA NA Distribution type (2) time Float64 0 NA s Time of the distribution data_source String 0 NA NA Source of the distribution data nparticle Int32 0 NA NA Number of MC particles nclass Int16 0 NA NA Number of orbit classes class Int16 1 [ nparticle ] NA Orbit class of the MC particle weight Float64 1 [ nparticle ] fast-ions Weight of the MC particle r Float64 1 [ nparticle ] cm R positions of the MC particle z Float64 1 [ nparticle ] cm Z positions of the MC particle energy Float64 1 [ nparticle ] keV Energy of the MC particle pitch Float64 1 [ nparticle ] NA Pitch w.r.t the magnetic field of the MC particle The sum( weight ) = # of Fast-ions in phase space sampled by the MC particles. The class variable can take values in the range of 1: nclass . \nIf there are multiple classes of particles the FIDA signal for each class will be calculated. Full-orbit Monte Carlo Distribution Variable Type Rank Dimensions Units Description type Int16 0 NA NA Distribution type (3) time Float64 0 NA s Time of the distribution data_source String 0 NA NA Source of the distribution data nparticle Int32 0 NA NA Number of MC particles nclass Int16 0 NA NA Number of orbit classes class Int16 1 [ nparticle ] NA Orbit class of the MC particle weight Float64 1 [ nparticle ] fast-ions Weight of the MC particle r Float64 1 [ nparticle ] cm R positions of the MC particle z Float64 1 [ nparticle ] cm Z positions of the MC particle vr Float64 1 [ nparticle ] cm/s Radial component of the MC particle velocity vt Float64 1 [ nparticle ] cm/s Torodial/Phi component of the MC particle velocity vz Float64 1 [ nparticle ] cm/s Z component of the MC particle velocity The sum( weight ) = # of Fast-ions in phase space sampled by the MC particles. The class variable can take values in the range of 1: nclass .\nIf there are multiple classes of particles the FIDA signal for each class will be calculated. Relevent Namelist Settings ai : Ion mass [amu] impurity_charge : Impurity charge number 5=Boron, 6=Carbon, ... ab : Fast/Beam-ion mass [amu] equilibrium_file : Equilibrium file location distribution_file : Distribution file location Fortran References InterpolationGrid : Definition of R-Z grid Profiles and LocalProfiles : Derived type for Plasma parameters EMFields and LocalEMFields : Derived type for Fields get_plasma : Gets plasma parameters at a given position get_fields : Gets fields at a given position get_distribution : Gets fast-ion distribution at a given position read_equilibrium : Reads equilbrium file into Equilibrium structure FastIonDistribution : Derived type for describing GC distribution functions FastIon : Derived type for describing a Monte Carlo particle FastIonParticles : Defines a distribution of Monte Carlo particles read_distribution : Reads distribution file","tags":"","loc":"page/02_physics/01_plasma.html","title":"Plasma Parameters, Fields, and Distributions – FIDASIM"},{"text":"Atomic Cross Sections Approximate Hydrogen Charge Exchange Cross Sections Generating Tables Atomic Data References Relevent Namelist Settings Fortran References Hydrogen-Hydrogen Interactions H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m), \\, m \\gt n H&#94;+ + H(n) \\rightarrow H&#94;+ + H&#94;+ + e Hydrogen-Electron Interactions e + H(n) \\rightarrow e + H(m),\\, m \\gt n e + H(n) \\rightarrow e + H&#94;+ + e Hydrogen-Carbon₆ Interactions C&#94;{6+} + H(n) \\rightarrow C&#94;{5+} + H&#94;+ C&#94;{6+} + H(n) \\rightarrow C&#94;{6+} + H(m), \\, m \\gt n C&#94;{6+} + H(n) \\rightarrow C&#94;{6+} + H&#94;+ + e Atomic Cross Sections As a neutral particle travels through a plasma it undergoes several different types of interactions Charge Exchange with Hydrogen and Impurities Excitation with Electrons, Hydrogen, and Impurities Ionization with Electrons, Hydrogen, and Impurities These cross sections, as well as Maxwellian averaged reaction rates, are pre-computed over a range of logarithmically spaced collision energies and target temperatures. Approximate Hydrogen Charge Exchange Cross Sections Some of atomic transitions needed by FIDASIM are not available.\nIn particular, FIDASIM needs the n/m-resolved charge exchange cross sections.\nWhile certain transitions are available through ADAS [4] others are not, as such, certain approximations are needed to fill out the table. For instance, we use the equivalence principle (reversibility formula) to mirror the known ADAS cross sections.\n\\sigma(n_f \\rightarrow n_i) = \\frac{E_i}{E_f} \\frac{n_i&#94;2}{n_f&#94;2} \\sigma(n_i \\rightarrow n_f)\nThis however is insufficient to completly fill out the table. Additionally, since the total cross sections for a transition from a given n to any m are given by Janev[2] we can then also assume that the probability of a transition from the n \\rightarrow m state decreases exponentially with energy difference between the states we can \"spread\" the total cross section amoung the different m levels. Note Total cross sections for n>4 are not available so the n=4 total cross sections are used.\nAlso we normalize the m levels to the Janev tables for consistancy. A summary of the various approximations used in the charge exchange tables is given in the table below. (Spreading is done over m/rows) .tg  {border-collapse:collapse;border-spacing:0;margin:0 auto;}\n.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}\n.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;}\n.tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}\n.tg .tg-fo0g{font-weight:bold;background-color:#009901;color:#ffffff;text-align:center;vertical-align:top}\n.tg .tg-0mq6{font-weight:bold;background-color:#fe0000;color:#ffffff;text-align:center;vertical-align:top}\n.tg .tg-bq31{font-weight:bold;background-color:#3166ff;color:#ffffff;text-align:center;vertical-align:top} H-H Charge Exchange Data Source n \\ m 1 2 3 4 5 6 Total 1 ADAS ADAS ADAS ADAS Spread Spread Janev(n=1) 2 Equivalence ADAS ADAS Spread Spread Spread Janev(n=2) 3 Equivalence ADAS ADAS ADAS ADAS Spread ADAS/Janev(n=3) 4 Equivalence Equivalence Equivalence Spread Spread Spread Janev(n=4) 5 Spread Equivalence Equivalence Spread Spread Spread Janev(n=4) 6 Spread Equivalence Equivalence Spread Spread Spread Janev(n=4) Generating Tables FIDASIM provides a routine, generate_tables to generate the atomic tables. \nTo generate the atomic tables with the default settings all you need to do is, from the install directory, run make atomic_tables Warning This is computationally expensive so make sure you run this on a computer \nwhere you won't get angry emails for using up all the CPU's.\nOptionally you can add NTHREADS=# to the command to set the number of threads. The default settings should be appropriate for most devices but in some cases it may be necessary to generate custom tables.\nFor instance, the default tables are calculated assuming the main impurity is Carbon-6 so it would be inappropriate to the default tables if you have a different main impurity.\nTo generate custom tables from the tables directory run ./generate_tables > table_settings.dat to generate the namelist file that contains the default settings. Edit this file to change the settings. After editing the namelist file run ./generate_tables table_settings.dat [ NUM_THREADS ] <-- NUM_THREADS is optional and wait for a couple of hours depending on the number of threads used. Atomic Data References The atomic data is taken from a variety of sources [1-5] W.L. Wiese, M.W. Smith, and B.M. Glennon. Atomic Transition Probabilities. Volume 1. Hydrogen through Neon . National Bureau of Standards Washington DC Institute for Basic Standards, 1966. R.K. Janev, D. Reiter, and  U. Samm. Collision processes in low-temperature hydrogen plasmas . Forschungszentrum Jülich, Zentralbibliothek, 2003. M. O'Mullane. Review of proton impact driven ionisation from the excited levels in neutral hydrogen beams . ADAS note, 2009. ADAS: Atomic Data and Analysis Structure R.K. Janev and J.J. Smith. Cross sections for collision processes of hydrogen atoms with electrons, protons and multiply charged ions. Atomic and Plasma-Material Interaction Data for Fusion: Volume 4, 1993. Reinhold, C. O., R. E. Olson, and W. Fritsch. Excitation of atomic hydrogen by fully stripped ions. Physical Review A 41.9 1990. A more precice references can be found in the Fortran function documentation. For example, p_cx_janev Relevent Namelist Settings tables_file : Location of atomic tables file Fortran References atomic_tables : Module containing routines to calculate atomic tables and reaction rates generate_tables : Program to create atomic tables file AtomicCrossSection : Defines a n/m-resolved atomic cross section table AtomicRates : Defines an atomic table for populating and de-populating reaction rates AtomicTables : Atomic tables for various types of interactions need by FIDASIM read_atomic_cross : Reads atomic cross section from file read_atomic_rates : Reads atomic rates from file read_tables : Reads all cross sections and rates needed by FIDASIM m_spread : Spreads total n cross section amoung m states Hydrogen-Hydrogen Interactions H&#94;+ + H(n) \\rightarrow H(m) + H&#94;+ H&#94;+ + H(n) \\rightarrow H&#94;+ + H(m), \\, m \\gt n H&#94;+ + H(n) \\rightarrow H&#94;+ + H&#94;+ + e Hydrogen-Electron Interactions e + H(n) \\rightarrow e + H(m),\\, m \\gt n e + H(n) \\rightarrow e + H&#94;+ + e Hydrogen-Carbon₆ Interactions C&#94;{6+} + H(n) \\rightarrow C&#94;{5+} + H&#94;+ C&#94;{6+} + H(n) \\rightarrow C&#94;{6+} + H(m), \\, m \\gt n C&#94;{6+} + H(n) \\rightarrow C&#94;{6+} + H&#94;+ + e","tags":"","loc":"page/02_physics/02_atomic_tables.html","title":"Atomic Tables – FIDASIM"},{"text":"Collisional Radiative Model Fortran References Collisional Radiative Model The collisions that a neutral particle experiences as it travels through a plasma changes the distribution of its energy level population.\nThe types of collisions that FIDASIM takes into account is as follows Spontaneous decay: A_{m \\rightarrow n} / A_{n \\rightarrow m} Electron-impact excitation/de-excitation: q&#94;e_{m \\rightarrow n} / q&#94;e_{n \\rightarrow m} Ion-impact excitation/de-excitation: q&#94;i_{m \\rightarrow n} / q&#94;i_{n \\rightarrow m} Impurity-impact excitation/de-excitation: q&#94;Z_{m \\rightarrow n} / q&#94;Z_{n \\rightarrow m} Electron-impact ionization: I&#94;e_n Ion-impact ionization: I&#94;i_n Impurity-impact ionization: I&#94;Z_n Charge exchange with ions: X&#94;i_n Charge exchange with impurities: X&#94;Z_n The above rate coefficients have units of cm&#94;3/s and are calculated by averaging the respective collisional cross sections with a Maxwellian of the relevent species.\nThe population of the n&#94;{th} energy level of a neutral atom, f_n, can be described by the following time dependent differential equation\n\n\\frac{df_n}{dt} = - \\left ( \\sum_{k=i,Z} f_n d_k X&#94;k_n + \\sum_{k=e,i,Z} f_n d_k I&#94;k_n \\right ) \\\\\n+ \\sum_{m>n} \\left (f_m A_{m \\rightarrow n} + \\sum_{k=e,i,Z} (f_m d_k q&#94;k_{m \\rightarrow n} - f_n d_k q&#94;k_{n \\rightarrow m}) \\right ) \\\\\n+ \\sum_{n>m} \\left (-f_n A_{n \\rightarrow m} + \\sum_{k=e,i,Z} (f_m d_k q&#94;k_{m \\rightarrow n} - f_n d_k q&#94;k_{n \\rightarrow m}) \\right )\n\nwhere the d_k are the respective target densities. By rearranging the terms and letting q&#94;k_{n \\rightarrow m} represent excitation/de-excitation depending on the order of the indices we can get the following equation\n\n\\frac{df_n}{dt} = C_{n,n} f_n + \\sum_{m \\ne n} C_{n,m} f_m\n\nwhere\n\nC_{n,n} = - \\left [ \\sum_{k=i,Z} d_k X&#94;k_n + \\sum_{k=e,i,Z} d_k I&#94;k_n + \\sum_{m \\ne n} \\left ( A_{n \\rightarrow m} + \\sum_{k=e,i,Z} d_k q&#94;k_{n \\rightarrow m} \\right ) \\right ]\n\nand \n\nC_{n,m} = A_{m \\rightarrow n} + \\sum_{k=e,i,Z} d_k q&#94;k_{m \\rightarrow n}\n The system of differential equations can be compactly represented as a matrix multiplication.\n\n\\frac{d \\mathbf{f}}{dt} = \\mathbf{C} \\cdot \\mathbf{f}\n The solution of this matrix differential equation takes the form of a matrix exponential \\mathbf{f}(t) = e&#94;{\\mathbf{C} t} \\cdot \\mathbf{f}(0) = \\mathbf{S} \\cdot e&#94;{\\mathbf{\\Lambda} t} \\cdot \\mathbf{S}&#94;{-1} \\cdot \\mathbf{f}(0) where \\mathbf{f}(t) is a vector of the neutral population flux [1/s] for each energy state at time t, \\mathbf{S} is the matrix of the eigenvectors of  \\mathbf{C}  and  \\mathbf{\\Lambda}  is a diagonal matrix containing the eigenvalues of  \\mathbf{C} . \nThe fractional flux of a neutral traveling through a uniform plasma is shown below. As you can see the relative populations between states converges fairly quickly. The number of neutrals in a given state after a time t, \\mathbf{n}(t), is given by \\mathbf{n}(t) = \\mathbf{S} \\cdot ( \\mathbf{\\Lambda}&#94;{-1} \\cdot e&#94;{\\mathbf{\\Lambda} t} - \\mathbf{\\Lambda}&#94;{-1} ) \\cdot \\mathbf{S}&#94;{-1} \\cdot \\mathbf{f}(0)  If t represents the time spent inside a grid cell the neutral density can be calculated by dividing the above equation by V_{cell}.\nThe total neutral density of a mc marker is shown below. As you can see over time the total number of neutrals decreases exponentially. Fortran References colrad : Fortran implementation get_rate_matrix : Constructs rate matrix A AtomicRates : Derived type that stores populating and de-populating transitions","tags":"","loc":"page/02_physics/03_colrad.html","title":"Collisional Radiative Model – FIDASIM"},{"text":"table {\nwidth: 100%;\n}\ntable,th,td {\nborder: 1px solid black;\nborder-collapse: collapse;\n}\nth, td {\npadding: 5px;\n}\nth {\ntext-align: center;\n} Beam Grid Neutral Beam Geometry Neutral Beam Density DCX and Halo Density Relevent Namelist Settings Fortran References Beam Grid The neutrals densities calculated by FIDASIM are stored in a 3D grid.\nFIDASIM requires that the grid be axis-aligned to easily track particles through the grid.\nHowever, it is extremely useful to be able to align the grid along the beam centerline.\nTo facilitate this FIDASIM allows the user to define arbitrary Cartesian coordinate system (beam grid coordinates) that all calculations are done in. FIDASIM uses Tait-Bryan rotation angles ( alpha , beta , gamma ) to define a intrinsic rotation matrix, R, that is used to transform from beam grid coordinates(xyz) to machine coordinates(uvw)\n \\mathrm{uvw = R \\cdot xyz + origin} \nIf the rotation angles and origin are set to zero then the rotation matrix is the Identity matrix and the coordinate system is identical to machine coordinates (Standard Cartesian). Understanding these variables can be difficult and can best be described by an example. With your right hand point your index finger pointing in the +x direction with your middle finger and thumb pointing in the +y and +z direction respectively. Rotate about your thumb (z-axis) by alpha (ccw = +angle, cw = -angle) Rotate about your middle finger (y'-axis) by beta Rotate about your index finger (x\"-axis) by gamma Move your right hand to the origin Define (x|y|z)_(min|max) by this coordinate system with your index finger being the new +x-axis The beam grid is defined in the namelist file ( [runid]_inputs.dat ) and are defined as follows Variable Type Rank Dimensions Units Description nx Int16 0 NA NA Number of cells in the X direction ny Int16 0 NA NA Number of cells in the Y direction nz Int16 0 NA NA Number of cells in the Z direction xmin Float64 0 NA cm Minimum X value in beam grid coordinates xmax Float64 0 NA cm Maximum X value in beam grid coordinates ymin Float64 0 NA cm Minimum Y value in beam grid coordinates ymax Float64 0 NA cm Maximum Y value in beam grid coordinates zmin Float64 0 NA cm Minimum Z value in beam grid coordinates zmax Float64 0 NA cm Maximum Z value in beam grid coordinates alpha Float64 0 NA rad Tait-Bryan rotation angle about z-axis beta Float64 0 NA rad Tait-Bryan rotation angle about y'-axis gamma Float64 0 NA rad Tait-Bryan rotation angle about x\"-axis origin Float64 1 [3] cm Beam grid origin in Machine Coordinates Neutral Beam Geometry A neutral beam is defined by a source position and an axis such that a position along the beam centerline is defined as\n\\vec{C}(t) = \\vec{s} + \\vec{a} \\cdot t\nwhere \\vec{C}(t) is the position along the centerline parameterized by t, \\vec{s} is the source position in machine coordinates, and \\vec{a} is the axis. The ion source is defined by its shape (circular or rectangular), size (half width and height), focal length (vertical and horizontal), and divergence (energy dependent).\nThe neutral beam is simulated by firing particles from random positions on the source plate.\nThe trajectory of the particles is determined by the following equations (+x into the plasma)\nv_x = 1\nv_y = -\\frac{y_s}{f_y} + \\tan(\\mathcal{N}(0,\\beta_y&#94;2))\nv_z = -\\frac{z_s}{f_z} + \\tan(\\mathcal{N}(0,\\beta_z&#94;2))\nwhere y_s and z_s are random positions on the source plate in the horizontal and vertical directions respectively, \nf_{y/z} are the focal lengths, and \\beta_{y/z} are the divergences. Examples of different trajectories are shown below. Not shown above are the beam aperture(s) which collimates the neutral beam.\nApertures are represented in FIDASIM by their shape (circular or rectangular), size (half width and\nheight), offsets relative to the +x aligned beam centerline, and their distance from the source grid.\nIt is assumed that the plane of the aperture(s) is parallel to the plane of the source grid. FIDASIM reads in the neutral beam geometry from a HDF5 file ( [runid]_geometry.h5 ) that has the group nbi with the following datasets Variable Type Rank Dimensions Units Description name String 0 NA NA Name of the neutral beam shape Int16 0 NA NA Shape of the beam source grid (1=rect or 2=circ) data_source String 0 NA NA Source of the neutral beam geometry src Float64 1 [3] cm Position of the source grid in machine coordinates axis Float64 1 [3] NA Direction of the beam center line widy Float64 0 NA cm Source grid half-width in the horizontal direction widz Float64 0 NA cm Source grid half-height in the vertical direction divy Float64 1 [3] rad Horizontal beam divergence divz Float64 1 [3] rad Vertical beam divergence focy Float64 0 NA cm Horizontal focal length focz Float64 0 NA cm Vertical focal length naperture Int16 0 NA NA Number of apertures ashape Int16 1 [ naperture ] NA Shape of the aperture(s) (1=rect or 2=circ) awidy Float64 1 [ naperture ] cm Half-width of the aperture(s) awidz Float64 1 [ naperture ] cm Half-height of the aperture(s) aoffy Float64 1 [ naperture ] cm Horizontal (y) offset of the aperture(s) relative to the +x aligned beam centerline aoffz Float64 1 [ naperture ] cm Vertical (z) offset of the aperture(s) relative to the +x aligned beam centerline adist Float64 1 [ naperture ] cm Distance from the center of the beam source grid to the aperture(s) plane Neutral Beam Density Neutral Hydrogen beams usually contain atoms with different energies: H(E_{inj}) (Full), H(E_{inj}/2) (Half),H(E_{inj}/3) (Third).\nThis splitting of energy is due to multiple atomic and molecular species being accelerated to the same kinetic energy, E_{inj}.\nEach beam species will attenuate differently into the plasma and need to be treated separetely.\nIt is assumed that each neutral is in the ground state with initial flux given by\n F_i(n=1) = \\frac{dN_i}{dt} = C_i \\cdot \\frac{dN_{tot}}{dt} \nwhere C_i is current fraction for the i_{th} energy component and dN_{tot}/dt is the total flux of neutrals given by\n\\frac{dN_{tot}}{dt} = \\frac{P_{inj}}{C_1 E_{inj}+ C_2 E_{inj}/2 + C_3 E_{inj}/3} \nwhere P_{inj} is the beam power. Within each beam grid cell along the neutral trajectory the flux is modified using the collisional radiative model and the neutral density is calculated.\nThe figure below illustrates the different beam attenuation profiles. DCX and Halo Density A secondary source of neutrals come from the charge exchange reaction between beam neutrals and thermal ions (DCX).\nAfter neutralization, the newly created thermal neutrals travel ballistically and charge exchange with other thermal ions creating more neutrals (Halo).\nThis process is then repeated multiple times in a recursive fashion producing fewer and fewer neutrals.\nThe effect of this process is a Halo of neutrals surrounding the neutral beam. FIDASIM uses the following scheme to calculate the DCX+Halo contribution. \\rm{DCX:\\,\\,\\,} \\quad H_{t_0}&#94;+ + H_b \\rightarrow H_{t_0} + H_b&#94;+ \\rm{Halo\\,1:} \\quad H_{t_1}&#94;+ + H_{t_0} \\rightarrow H_{t_1} + H_{t_0}&#94;+ \\rm{Halo\\,2:} \\quad H_{t_2}&#94;+ + H_{t_1} \\rightarrow H_{t_2} + H_{t_1}&#94;+ \\vdots \\rm{Halo\\,n:} \\quad H_{t_n}&#94;+ + H_{t_{(n-1)}} \\rightarrow H_{t_n} + H_{t_{(n-1)}}&#94;+ After a few iterations the halo density converges and the calculation ends. Relevent Namelist Settings ab : Beam/Fast-ion mass [amu] pinj : Beam power [MW] einj : Beam Energy [keV] current_fractions : Current fractions load_neutrals : Load neutrals from file neutrals_file : Optional neutrals file dump_dcx : Optionally dump DCX density and spectra n_nbi : Number of NBI MC particles n_halo : Number of HALO MC particles n_dcx : Number of DCX MC particles calc_birth : Calculate birth profile (density & birth position and velocity) n_birth : Number of birth particles outputed Fortran References xyz_to_uvw : Transforms a point from beam grid coordinates to machine coordinates uvw_to_xyz : Transforms a point from machine coordinates to beam grid coordinates mc_nbi : Generates beam neutral trajectory ndmc : Calculates neutral beam density dcx : Calculates DCX contribution halo : Calculates Halo contribution write_dcx : Writes DCX neutrals to file write_neutrals : Writes neutrals to file","tags":"","loc":"page/02_physics/04_neutrals.html","title":"Neutral Beam and Halo – FIDASIM"},{"text":"table {\nwidth: 100%;\n}\ntable,th,td {\nborder: 1px solid black;\nborder-collapse: collapse;\n}\nth, td {\npadding: 5px;\n}\nth {\ntext-align: center;\n} Spectroscopic Geometry Types of Spectra Bremsstrahlung Emission by Neutrals Relevant Namelist Settings Fortran References Spectroscopic Geometry The spectroscopic geometry is defined similarily to the neutral beam.\nIt is defined by the lens position in machine coordinates and an optical axis.\nThe volume of the sightline is assumed to be cylindrical with radius, spot_size . If mirrors are present then the apparent positions of the lens as seen from the plasma are used.\nAdditionally, mirrors reflect the sigma and pi Stark lines differently due to a difference in polarization.\nThe experimentally determined ratio of the intensties of the sigma and pi lines, sigma_pi , is used to correct for this.\nIf there are no mirrors then sigma_pi is set to 1.0 . The full geometry specification is given below. Variable Type Rank Dimensions Units Description nchan Int32 0 NA NA Number of channels system String 0 NA NA Name of the spectrocopic system(s) data_source String 0 NA NA Source of the spectral geometry data id String 1 [ nchan ] NA Channel ID radius Float64 1 [ nchan ] cm Line of sight radius at midplane or tangency point lens Float64 2 [3, nchan ] cm Lens location in machine coordinates axis Float64 2 [3, nchan ] NA Optical axis/direction of the lines of sight spot_size Float64 1 [ nchan ] cm Radius of the collecting volume sigma_pi Float64 1 [ nchan ] NA Ratio of the intensities of the sigma and pi stark lines Types of Spectra FIDASIM can calculate the following spectra Bremsstrahlung Beam Emission (BES: Full, Half, Third) Halo Emission Fast-ion D-\\alpha (FIDA) Bremsstrahlung The largest source of background emission is visible bremsstrahlung. The local bremsstrahlung emissivity per unit wavelength is given by \\frac{dN_B}{d\\lambda} = 7.57 \\times 10&#94;{-9} \\,  g \\,  \\frac{n_e&#94;2 \\, Z_{eff}}{\\lambda \\, T_e&#94;{1/2}} e&#94;{-hc/\\lambda \\,T_e}  where \\lambda is the wavelength in angstroms, n_e is the electron density in cm&#94;{-3}, T_e is the electron temperature in eV.\nThe gaunt factor, g, depends on T_e and Z_{eff}. It can be approximated by  g = 5.542 - (3.108 - \\ln(T_e/1000))(0.6905 - 0.1323/Z_{eff})  To calculate the total emission \"seen\" by the line of sight the the local emissivity is integrated over the line of sight. Emission by Neutrals There are two processes in which neutrals can emit light: Excitation and Charge Exchange. Excitation is the primary method in which beam neutrals emit light (BES).\nIn short, a neutral particle collides with a charged particle, exciting into a higher energy (n=3) state.\nWhen the neutral particle relaxes (n: 3 \\rightarrow 2) it emits a doppler shifted (656.1 nm) photon. Charge Exchange is the process by which the Halo and FIDA light is created.\nIn a charge exchange reaction a thermal (Halo) or fast (FIDA) ion steals a electron from a neutral particle.\nThe newly created neutral is born in an excited (n=3 state and like the collisionally excited neutral it relaxes to a lower energy state (\\n=2) and emits a doppler shifted (656.1 nm) photon. The motion of a ion in a magnetic field induces an electric field which causes Stark Spitting of the the atoms energy levels.\nMost atoms the strength of the Stark effect is quadratic in low electric fields and linear for strong electric fields. \nUsually atoms never the linear regime but, due to degenerency between states of different angular momentum, hydrogenic atoms exhibit a linear Stark effect.\nThe linear Stark energy component shifts are given by the following equations. \\Delta \\mathcal{E} = 3nk\\frac{E}{Ze/4\\pi\\epsilon_0a_0&#94;2}R_y\\;\\, \\mathrm{for} \\;\\,k=0,\\pm 1,\\dots,\\pm (n-1) As seen from the above equation, each energy level is split into 2n-1 parts.\nFor the Balmer-alpha transition, this creates 15 distinct transitions from the n=3 \\rightarrow 2 state. The relative intensity of the different Stark lines is given by  I_{rel}(i) = S_I(i)\\,(1 \\pm (\\vec{v}_{ph} \\cdot \\vec{E})&#94;2) \n I_{rel}(i) = \\frac{I_{rel}(i)}{\\sum_i I_{rel}(i)}  where positive and negative sums refer to \\sigma and \\pi lines respectively and S_I are the calculated relative Stark intensities for each transition given by S_I = [1, 18, 16, 1681, 2304, 729, 1936, 5490, 1936, 729, 2304, 1681, 16, 18, 1]  Relevant Namelist Settings calc_fida : Calculate FIDA spectra calc_brems : Calculate Bremsstrahlung calc_bes : Calculate Beam Emission and Halo dump_dcx : Dump DCX spectra n_fida : Number of Monte Carlo particles used in FIDA spectra calculation n_nbi : Number of Monte Carlo particles used in BES spectra calculation n_dcx and n_halo : Number of particles used in Halo spectra calculation nlambda : Number of wavelength bins lambdamin : Minimum wavelength [nm] lambdamax : Maximum wavelength [nm] Fortran References bremsstrahlung : Calculates Bremsstrahlung spectrum : Calculates Doppler shift and Stark splitting. ndmc : Calculates BES spectra dcx : Calculates DCX neutrals contribution to the Halo spectra halo : Calculates thermal neutrals contribution to the Halo Spectra fida_f : Calculates FIDA light using a distribution function fida_mc : Calculates FIDA light using a particle distribution","tags":"","loc":"page/02_physics/05_spectra.html","title":"Spectra – FIDASIM"},{"text":"table {\nwidth: 100%;\n}\ntable,th,td {\nborder: 1px solid black;\nborder-collapse: collapse;\n}\nth, td {\npadding: 5px;\n}\nth {\ntext-align: center;\n} NPA Geometry Monte Carlo NPA calculation Relevant Namelist Settings Fortran References NPA Geometry An NPA detector is defined by an aperture for which neutral particles must pass through and an detector.\nThe aperture/detectors are defined by three points and a shape as shown in the figures above.\nIt is assumed that between the aperture and the detector that particles travel in straight lines i.e. there is no stripping foil. The full definition of the NPA detector is given below (right and left as implied by looking through the aperture at the detector) Variable Type Rank Dimensions Units Description nchan Int32 0 NA NA Number of channels system String 0 NA NA Name of the NPA system(s) data_source String 0 NA NA Source of the NPA geometry data id String 1 [ nchan ] NA Channel ID radius Float64 1 [ nchan ] cm Line of sight radius at midplane or tangency point a_shape Int16 1 [ nchan ] NA Shape of the aperture (1=rect, 2=circ) d_shape Int16 1 [ nchan ] NA Shape of the detector (1=rect, 2=circ) a_cent Float64 2 [3, nchan ] cm Position of the center of the aperture a_redge Float64 2 [3, nchan ] cm Position of the apertures right edge a_tedge Float64 2 [3, nchan ] cm Position of the apertures top edge d_cent Float64 2 [3, nchan ] cm Position of the center of the detector d_redge Float64 2 [3, nchan ] cm Position of the detectors right edge d_tedge Float64 2 [3, nchan ] cm Position of the detectors top edge Monte Carlo NPA calculation The Monte Carlo method of calculating the NPA flux (MC-NPA) is as follows Sample Fast-ion distribution function and get initial position and velocity Determine if particle would go through the NPA aperture and hit the detecting region. If not increase counter and goto 1 else goto 3 Charge exchange the ion (set initial state) and solve the collisional radiative model along particle track. Sum the final state of the neutral and bin the particle by its energy. Repeat N times This process works but is not very efficient. The main issue is that more often or not a particle would not hit the detector.\nThis causes very bad Monte Carlo noise in the calculated NPA flux.\nThe only way to get around this is to use a lot of particles which can be prohibitively expensive. It would be much faster to just fire the particles directly at the NPA detector and then scale the resultant flux by the probability of that trajectory occuring.\nThis is approach taken in the weight function method (WF-NPA) detailed here . An example of the calculated NPA flux for the two different methods are shown below. As you can see the WF-NPA method produces superior results at a fraction of the runtime. Relevant Namelist Settings n_npa : Number of Monte Carlo particles used in MC-NPA calculation calc_npa : Calculate NPA flux using the Monte Carlo Method calc_npa_wght : Calculate NPA weight function and flux using the weight function method ne_wght : Number of energies in weight function calculation np_wght : Number of pitches in weight function calculation emax_wght : Maximum energy in weight function calculation Fortran References read_npa : Reads NPA geometry and calculates NPA geometric factor npa_f : MC-NPA routine npa_weights : WF-NPA routine","tags":"","loc":"page/02_physics/06_npa.html","title":"Neutral Particle Analyzer – FIDASIM"},{"text":"Weight Functions FIDA NPA Weight Functions FIDASIM is capable of calculating phase space sensitivities, also known as \"weight\" functions.\nThese weight functions describe how sensitive a diagnostic is to a region of fast-ion phase space (Energy/pitch).\nAlternatively, you can think of weight functions as the probability of a region of phase space contributing to the diagnostic signal. When a weight function is convolved with a theoretical fast-ion distribution, the expected diagnostic signal is calculated.\nAn example of this process is shown below. FIDASIM can calculate weight functions for the FIDA and NPA diagnostics. FIDA The calculation of the FIDA weight function can be broken up into 3 parts. Probability of a fast-ion charge exchanging with a neutral to create a fast neutral. Probability of a fast neutral undergoing a Balmer-\\alpha transition and emitting a photon within the LOS. Probability of a photon landing in a certain wavelength region. The product of these probabilities will be proportional to the FIDA weight function. The probabilities mentioned above are implicitly local quantities, however, in reality the neutral population and the diagnostic geometry have spatial extent. \nThe (exact) expected FIDA signal is given by \nS(\\lambda) = \\sum_{cells} \\left (\\sum_{E,p} W_i(E,p,\\lambda) \\times F_i(E,p) \\, \\Delta E \\Delta p \\right )\n In order to calculate a single representative weight function for a given diagnostic (W(\\lambda,E,p), spatial averaging is needed. FIDASIM offers two different ways of calculating the FIDA weight functions; each using a different spatial averaging method. calc_fida_wght = 1 With this switch the FIDA weight function is calculated using LOS integrated neutral density and weighted plasma parameters given by \nk_{mean} = \\frac{\\int k \\times (d_{beam} + d_{halo}) \\,dl}{\\int (d_{beam} + d_{halo}) \\, dl}\n where k represents the various plasma parameters and distribution function. Using this method the FIDA spectra can be estimated by \n\nS_{approx}(\\lambda) = \\sum_{E,p} \\overline{W}(E,p,\\lambda) \\times \\overline{F}(E,p) \\Delta E \\Delta p\n where \\overline{W} is the weight function calculated with LOS-averaged quantities and \\overline{F} is the LOS-averaged fast-ion distribution function. calc_fida_wght = 2 With this switch it is assumed that over the line of sight the fast-ion distribution is approximately constant.\n\nS_{approx}(\\lambda) = \\sum_{E,p} \\overline{F}(E,p) \\times \\overline{W}(E,p,\\lambda) \\, \\Delta E \\Delta p\n\nwhere\n\n\\overline{W} = \\sum_{cells} W_i\n\nand\n\n\\overline{F}(E,p) = \\frac{\\sum_{cells} \\sum_{\\lambda} W_i(E,p,\\lambda) \\times F_i(E,p)}{\\sum_{\\lambda}\\overline{W}(E,p,\\lambda)}\n This method is more computationally intensive and uses a Monte Carlo method which introduces some noise.\nRegardless, this method is more accurate then the previous method and should be used in analysis where accuracy is paramount, e.g. velocity space tomography. Note The FIDA signal produced by calc_fida = 1 will sometimes significantly differ from the estimated FIDA spectra produced by convolving the weight functions with the fast-ion distribution. This is due to the approximations made in the weight function calculation. In general you can use the calc_fida=1 result to test the approximations used by calc_fida_wght=1/2 NPA The calculation of the NPA weight function can be broken up into 3 parts. Probability of a fast-ion charge exchanging with a neutral to create a fast neutral. Probability of a the fast neutrals trajectory hitting the NPA detector. See this paper Probability of a the fast neutral not being reabsorbed back into the plasma. The product of these probabilities will be proportional to the NPA weight function. The probabilities mentioned above are implicitly local quantities, however, in reality the neutral population and the diagnostic geometry have spatial extent. \nThe (exact) expected NPA signal is given by \nflux(E) = \\sum_{cells} \\left (\\sum_{p} W_i(E,p) \\times F_i(E,p) \\, \\Delta p \\right )\n The NPA weight functions are calculated using the same assumptions as the FIDA weight functions ( calc_fida_wght=2 ).\nHowever, since the calc_npa calculation is very slow and inefficient the NPA flux calculated here is exact. If calc_npa_wght = 2 is set then the individual compenents of the npa weight function are also outputed.","tags":"","loc":"page/02_physics/07_weights.html","title":"Weight Functions – FIDASIM"},{"text":"Technical Details PREFIDA Inputs","tags":"","loc":"page/03_technical/index.html","title":"Technical Details – FIDASIM"},{"text":"PREFIDA Inputs PREFIDA Inputs Inputs Structure General Settings Simulation Switches Monte Carlo Settings Neutral Beam Settings Plasma Settings Beam Grid Settings Wavelength Grid Settings Weight Function Settings Interpolation Grid Structure Neutral Beam Geometry Structure Fields Structure Plasma Structure Distribution Structure Fast-ion Distribution Function Guiding Center Monte Carlo Distribution Full-Orbit Monte Carlo Distribution Spectral Geometry Structure NPA Geometry Structure Inputs Structure The inputs structure contains the basic information needed by FIDASIM. General Settings table {\nwidth: 100%;\n}\ntable,th,td {\nborder: 1px solid black;\nborder-collapse: collapse;\n}\nth, td {\npadding: 5px;\n}\nth {\ntext-align: center;\n} Variable Type Rank Dimensions Units Description shot Int32 0 NA NA Shot Number time Float64 0 NA s Time runid String 0 NA NA Run ID comment String 0 NA NA Comment result_dir String 0 NA NA Result directory tables_file String 0 NA NA Atomic Tables file Simulation Switches The simulation switches can take values 0, 1, or 2. A value of zero and one will turn the calculation off and on respectively. \nA value of two will turn on additional functionality. Variable Type Rank Dimensions Units Description calc_bes Int16 0 NA NA Calculate Beam Emission and Halo spectra calc_brems Int16 0 NA NA Calculate Bremsstrahlung calc_fida Int16 0 NA NA Calculate FIDA spectra calc_npa Int16 0 NA NA Calculate NPA flux calc_birth Int16 0 NA NA Calculate Birth profile calc_fida_wght Int16 0 NA NA Calculate FIDA weight functions calc_npa_wght Int16 0 NA NA Calculate NPA weight functions dump_dcx Int16 0 NA NA Dump DCX neutrals and spectra Monte Carlo Settings These settings control the number of Monte Carlo particles used by FIDASIM.\nUsing too few particles will execute quickly but will be extremely noisy.\nContrarily, using too many particles will increase runtime but will have small Monte Carlo noise.\nThe following settings provide a good balance between runtime and Monte Carlo noise. n_fida = 5000000L n_npa = 5000000L n_nbi = 50000L n_dcx = 500000L n_halo = 500000L n_birth = 50000L Variable Type Rank Dimensions Units Description n_fida Int32 0 NA NA Number of FIDA MC particles n_npa Int32 0 NA NA Number of NPA MC particles n_nbi Int32 0 NA NA Number of NBI MC particles n_dcx Int32 0 NA NA Number of DCX MC particles n_halo Int32 0 NA NA Number of HALO MC particles n_birth Int32 0 NA NA Number of Birth particles outputed Neutral Beam Settings These variables define the neutral beam properties.\nCurrently the mass of the beam species, ab , can only be the mass either protium or deuterium.\nThe current_fractions variable must sum to one.\nClick here for more information. Variable Type Rank Dimensions Units Description ab Float64 0 NA amu Beam species mass pinj Float64 0 NA MW Beam power einj Float64 0 NA keV Beam energy current_fractions Float64 1 [3] NA Current fractions (Full, Half, Third) Plasma Settings These variables define the properties of the thermal plasma species.\nLike the ab variable, ai can only be the mass of either protium or deuterium\nClick here for more information. Variable Type Rank Dimensions Units Description ai Float64 0 NA amu Thermal Ion species mass impurity_charge Int16 0 NA NA Impurity Charge Beam Grid Settings These variables define a rotated coordinate system.\nClick here for more details. Variable Type Rank Dimensions Units Description nx Int16 0 NA NA Number of cells in the X direction ny Int16 0 NA NA Number of cells in the Y direction nz Int16 0 NA NA Number of cells in the Z direction xmin Float64 0 NA cm Minimum X value in beam grid coordinates xmax Float64 0 NA cm Maximum X value in beam grid coordinates ymin Float64 0 NA cm Minimum Y value in beam grid coordinates ymax Float64 0 NA cm Maximum Y value in beam grid coordinates zmin Float64 0 NA cm Minimum Z value in beam grid coordinates zmax Float64 0 NA cm Maximum Z value in beam grid coordinates alpha Float64 0 NA rad Tait-Bryan rotation angle about z-axis beta Float64 0 NA rad Tait-Bryan rotation angle about y'-axis gamma Float64 0 NA rad Tait-Bryan rotation angle about x\"-axis origin Float64 1 [3] cm Beam grid origin in Machine Coordinates Wavelength Grid Settings These variables define the wavelength grid. Using a fine wavelength has no performance penalty.\nClick here for more more information. Variable Type Rank Dimensions Units Description nlambda Int16 0 NA NA Number of wavelengths lambdamin Float64 0 NA nm Minimum wavelength lambdamax Float64 0 NA nm Maximum wavelength Weight Function Settings These variables define the setting for the calculation of weight functions.\nClick here for more information. Variable Type Rank Dimensions Units Description ne_wght Int16 0 NA NA Number of weight function energies np_wght Int16 0 NA NA Number of weight function pitches nphi_wght Int16 0 NA NA Number of gyro-angles emax_wght Float64 0 NA keV Maximum energy of weight functions nlambda_wght Int16 0 NA NA Number of weight function wavelengths lambdamin_wght Float64 0 NA nm Minimum weight function wavelength lambdamax_wght Float64 0 NA nm Maximum weight function wavelength Interpolation Grid Structure The grid structure contains the definition of the 2D R-Z grid that the plasma parameters and electromagnetic fields are mapped onto. Variable Type Rank Dimensions Units Description nr Int16 0 NA NA Number of radii nz Int16 0 NA NA Number of z values r Float64 1 [ nr ] cm Array of radii z Float64 1 [ nz ] cm Array of z values r2d Float64 2 [ nr , nz ] cm 2D array of radii r = r2d(r,z) z2d Float64 2 [ nr , nz ] cm 2D array of z values z = z2d(r,z) Neutral Beam Geometry Structure The nbi structure contains the neutral beam geometry.\nThe (a)shape of the source grid and apertures take the value of 1 or 2 for a rectangular and circular respectively.\nClick here for more information. Variable Type Rank Dimensions Units Description name String 0 NA NA Name of the neutral beam shape Int16 0 NA NA Shape of the beam source grid (1 or 2) data_source String 0 NA NA Source of the neutral beam geometry src Float64 1 [3] cm Position of the source grid in machine coordinates axis Float64 1 [3] NA Direction of the beam center line widy Float64 0 NA cm Source grid half-width in the horizontal direction widz Float64 0 NA cm Source grid half-height in the vertical direction divy Float64 1 [3] rad Horizontal beam divergence divz Float64 1 [3] rad Vertical beam divergence focy Float64 0 NA cm Horizontal focal length focz Float64 0 NA cm Vertical focal length naperture Int16 0 NA NA Number of apertures ashape Int16 1 [ naperture ] NA Shape of the aperture(s) (1 or 2) awidy Float64 1 [ naperture ] cm Half-width of the aperture(s) awidz Float64 1 [ naperture ] cm Half-height of the aperture(s) aoffy Float64 1 [ naperture ] cm Horizontal (y) offset of the aperture(s) relative to the +x aligned beam centerline aoffz Float64 1 [ naperture ] cm Vertical (z) offset of the aperture(s) relative to the +x aligned beam centerline adist Float64 1 [ naperture ] cm Distance from the center of the beam source grid to the aperture(s) plane Fields Structure This structure contain the electromagnetic fields mapped onto the interpolation grid.\nClick here for more information. Variable Type Rank Dimensions Units Description time Float64 0 NA s Time when the fields data were collected/reconstructed data_source String 0 NA NA Source of the fields data mask Int16 2 [ nr , nz ] NA Boolean mask that indicates where the fields are well defined br Float64 2 [ nr , nz ] T Radial component of the magnetic field bt Float64 2 [ nr , nz ] T Torodial/Phi component of the magnetic field bz Float64 2 [ nr , nz ] T Z component of the magnetic field er Float64 2 [ nr , nz ] V/m Radial component of the electric field et Float64 2 [ nr , nz ] V/m Torodial/Phi component of the electric field ez Float64 2 [ nr , nz ] V/m Z component of the electric field Plasma Structure This structure contain the plasma parameters mapped onto the interpolation grid.\nClick here for more information. Variable Type Rank Dimensions Units Description time Float64 0 NA s Time when the plasma parameter data was collected data_source String 0 NA NA Source of the plasma parameter data mask Int16 2 [ nr , nz ] NA Boolean mask that indicates where the plasma is well defined te Float64 2 [ nr , nz ] keV Electron temperature ti Float64 2 [ nr , nz ] keV Ion temperature dene Float64 2 [ nr , nz ] cm&#94;-3 Electron density zeff Float64 2 [ nr , nz ] NA Z-effective vr Float64 2 [ nr , nz ] cm/s Radial component of the bulk plasma rotation/flow vt Float64 2 [ nr , nz ] cm/s Torodial/Phi component of the bulk plasma rotation/flow vz Float64 2 [ nr , nz ] cm/s Z component of the bulk plasma rotation/flow Distribution Structure The dist structure contains the fast-ion distribution which can be one of three different types.\nClick here for more information. Fast-ion Distribution Function Variable Type Rank Dimensions Units Description type Int16 0 NA NA Distribution type (1) time Float64 0 NA s Time of the distribution data_source String 0 NA NA Source of the distribution data nenergy Int16 0 NA NA Number of energy values npitch Int16 0 NA NA Number of pitch values energy Float64 1 [ nenergy ] keV Energy array pitch Float64 1 [ npitch ] NA Pitch array w.r.t magnetic field denf Float64 2 [ nr , nz ] cm&#94;-3 Fast-ion density f Float64 4 [ nenergy , npitch , nr , nz ] fast-ions/(dE dP cm&#94;3) Fast-ion distribution F(E,p,R,Z) Guiding Center Monte Carlo Distribution The sum( weight ) = # of Fast-ions in phase space sampled by the MC particles. The class variable can take values in the range of 1: nclass . Variable Type Rank Dimensions Units Description type Int16 0 NA NA Distribution type (2) time Float64 0 NA s Time of the distribution data_source String 0 NA NA Source of the distribution data nparticle Int32 0 NA NA Number of MC particles nclass Int16 0 NA NA Number of orbit classes class Int16 1 [ nparticle ] NA Orbit class of the MC particle weight Float64 1 [ nparticle ] fast-ions Weight of the MC particle r Float64 1 [ nparticle ] cm R positions of the MC particle z Float64 1 [ nparticle ] cm Z positions of the MC particle energy Float64 1 [ nparticle ] keV Energy of the MC particle pitch Float64 1 [ nparticle ] NA Pitch w.r.t the magnetic field of the MC particle Full-Orbit Monte Carlo Distribution The sum( weight ) = # of Fast-ions in phase space sampled by the MC particles The class variable can take values in the range of 1: nclass . Variable Type Rank Dimensions Units Description type Int16 0 NA NA Distribution type (3) time Float64 0 NA s Time of the distribution data_source String 0 NA NA Source of the distribution data nparticle Int32 0 NA NA Number of MC particles nclass Int16 0 NA NA Number of orbit classes class Int16 1 [ nparticle ] NA Orbit class of the MC particle weight Float64 1 [ nparticle ] fast-ions Weight of the MC particle r Float64 1 [ nparticle ] cm R positions of the MC particle z Float64 1 [ nparticle ] cm Z positions of the MC particle vr Float64 1 [ nparticle ] cm/s Radial component of the MC particle velocity vt Float64 1 [ nparticle ] cm/s Torodial/Phi component of the MC particle velocity vz Float64 1 [ nparticle ] cm/s Z component of the MC particle velocity Spectral Geometry Structure This structure contains the geometry of the spectroscopic systems \nClick here for more more information. Variable Type Rank Dimensions Units Description nchan Int32 0 NA NA Number of channels system String 0 NA NA Name of the spectrocopic system(s) data_source String 0 NA NA Source of the spectral geometry data id String 1 [ nchan ] NA Channel ID radius Float64 1 [ nchan ] cm Line of sight radius at midplane or tangency point lens Float64 2 [3, nchan ] cm Lens location in machine coordinates axis Float64 2 [3, nchan ] NA Optical axis/direction of the lines of sight spot_size Float64 1 [ nchan ] cm Radius of the collecting volume sigma_pi Float64 1 [ nchan ] NA Ratio of the intensities of the sigma and pi stark lines NPA Geometry Structure This structure contains the geometry of the spectroscopic systems \nThe shapes of the detector and aperture can take the value 1 or 2 for a rectangular and circular aperture/detector respectively.\nClick here for more more information. Variable Type Rank Dimensions Units Description nchan Int32 0 NA NA Number of channels system String 0 NA NA Name of the NPA system(s) data_source String 0 NA NA Source of the NPA geometry data id String 1 [ nchan ] NA Channel ID radius Float64 1 [ nchan ] cm Line of sight radius at midplane or tangency point a_shape Int16 1 [ nchan ] NA Shape of the aperture d_shape Int16 1 [ nchan ] NA Shape of the detector a_cent Float64 2 [3, nchan ] cm Position of the center of the aperture a_redge Float64 2 [3, nchan ] cm Position of the apertures right edge a_tedge Float64 2 [3, nchan ] cm Position of the apertures top edge d_cent Float64 2 [3, nchan ] cm Position of the center of the detector d_redge Float64 2 [3, nchan ] cm Position of the detectors right edge d_tedge Float64 2 [3, nchan ] cm Position of the detectors top edge","tags":"","loc":"page/03_technical/01_prefida_inputs.html","title":"PREFIDA Inputs – FIDASIM"},{"text":"This page documents the common problems people encounter while running FIDASIM.\nPlease try these solutions before opening an issue on Github. Segfaults Execution Hangs Segfaults If you encounter a segfault make sure you have set the stacksize limit to unlimited. To do this for the bash shell run ulimit -s unlimited or for the tcsh shell run limit stacksize unlimited Execution Hangs By default FIDASIM will use all the threads available. \nIf another process is hogging a core it will cause FIDASIM to stall.\nTo prevent this use the num_threads optional argument as shown below fidasim ./test_1a_inputs.dat 8","tags":"","loc":"page/03_technical/02_trouble.html","title":"Troubleshooting – FIDASIM"}]}