!+Unit tests for the eigensystem module
@test
subroutine test_rswap()
    use eigensystem
    use funit
    implicit none

    real(8) :: a, b

    ! Test basic swap
    a = 1.5d0
    b = 2.5d0
    call RSWAP(a, b)

    @assertEqual(2.5d0, a, tolerance=1.0d-10)
    @assertEqual(1.5d0, b, tolerance=1.0d-10)

    ! Test swapping negative numbers
    a = -3.0d0
    b = 4.0d0
    call RSWAP(a, b)

    @assertEqual(4.0d0, a, tolerance=1.0d-10)
    @assertEqual(-3.0d0, b, tolerance=1.0d-10)

end subroutine test_rswap

@test
subroutine test_balance_identity_matrix()
    use eigensystem
    use funit
    implicit none

    integer, parameter :: n = 3
    real(8), dimension(0:n-1, 0:n-1) :: mat, mat_original
    real(8), dimension(0:n-1) :: scal
    integer :: low, high, i

    ! Create identity matrix
    mat = 0.0d0
    do i = 0, n-1
        mat(i,i) = 1.0d0
    end do
    mat_original = mat

    ! Balance the matrix
    call balance(n, mat, scal, low, high)

    ! Identity matrix should remain unchanged
    @assertEqual(0, low)
    @assertEqual(n-1, high)

    ! Check diagonal elements remain 1
    do i = 0, n-1
        @assertEqual(1.0d0, mat(i,i), tolerance=1.0d-10)
    end do

end subroutine test_balance_identity_matrix

@test
subroutine test_balance_simple_matrix()
    use eigensystem
    use funit
    implicit none

    integer, parameter :: n = 3
    real(8), dimension(0:n-1, 0:n-1) :: mat
    real(8), dimension(0:n-1) :: scal
    integer :: low, high

    ! Create a simple test matrix
    mat(0,0) = 1.0d0; mat(0,1) = 2.0d0; mat(0,2) = 0.0d0
    mat(1,0) = 0.0d0; mat(1,1) = 3.0d0; mat(1,2) = 4.0d0
    mat(2,0) = 0.0d0; mat(2,1) = 0.0d0; mat(2,2) = 5.0d0

    ! Balance the matrix
    call balance(n, mat, scal, low, high)

    ! Check that low and high are reasonable
    @assertTrue(low >= 0)
    @assertTrue(high <= n-1)
    @assertTrue(low <= high)

end subroutine test_balance_simple_matrix

@test
subroutine test_mat_inv_identity()
    use eigensystem
    use funit
    implicit none

    integer, parameter :: n = 3
    real(8), dimension(n,n) :: mat, mat_inv, product
    integer :: i, j, k

    ! Create identity matrix
    mat = 0.0d0
    do i = 1, n
        mat(i,i) = 1.0d0
    end do

    ! Inverse of identity should be identity
    mat_inv = mat_inv(mat, n)

    do i = 1, n
        do j = 1, n
            if (i == j) then
                @assertEqual(1.0d0, mat_inv(i,j), tolerance=1.0d-10)
            else
                @assertEqual(0.0d0, mat_inv(i,j), tolerance=1.0d-10)
            end if
        end do
    end do

end subroutine test_mat_inv_identity

@test
subroutine test_mat_inv_simple()
    use eigensystem
    use funit
    implicit none

    integer, parameter :: n = 2
    real(8), dimension(n,n) :: mat, mat_inv, product
    real(8) :: det
    integer :: i, j, k

    ! Create a simple 2x2 matrix
    mat(1,1) = 4.0d0; mat(1,2) = 3.0d0
    mat(2,1) = 2.0d0; mat(2,2) = 1.0d0

    ! Calculate determinant
    det = mat(1,1)*mat(2,2) - mat(1,2)*mat(2,1)

    ! Get inverse
    mat_inv = mat_inv(mat, n)

    ! Expected inverse: 1/det * [1, -3; -2, 4]
    @assertEqual(-0.5d0, mat_inv(1,1), tolerance=1.0d-10)
    @assertEqual(1.5d0, mat_inv(1,2), tolerance=1.0d-10)
    @assertEqual(1.0d0, mat_inv(2,1), tolerance=1.0d-10)
    @assertEqual(-2.0d0, mat_inv(2,2), tolerance=1.0d-10)

    ! Verify A * A^-1 = I
    product = 0.0d0
    do i = 1, n
        do j = 1, n
            do k = 1, n
                product(i,j) = product(i,j) + mat(i,k) * mat_inv(k,j)
            end do
        end do
    end do

    ! Check product is identity
    do i = 1, n
        do j = 1, n
            if (i == j) then
                @assertEqual(1.0d0, product(i,j), tolerance=1.0d-10)
            else
                @assertEqual(0.0d0, product(i,j), tolerance=1.0d-10)
            end if
        end do
    end do

end subroutine test_mat_inv_simple

@test
subroutine test_matmul_simple()
    use eigensystem
    use funit
    implicit none

    integer, parameter :: n = 2, m = 3, p = 2
    real(8), dimension(n,m) :: A
    real(8), dimension(m,p) :: B
    real(8), dimension(n,p) :: C, C_expected

    ! Initialize matrices
    A(1,1) = 1.0d0; A(1,2) = 2.0d0; A(1,3) = 3.0d0
    A(2,1) = 4.0d0; A(2,2) = 5.0d0; A(2,3) = 6.0d0

    B(1,1) = 7.0d0; B(1,2) = 8.0d0
    B(2,1) = 9.0d0; B(2,2) = 10.0d0
    B(3,1) = 11.0d0; B(3,2) = 12.0d0

    ! Expected result
    C_expected(1,1) = 58.0d0; C_expected(1,2) = 64.0d0
    C_expected(2,1) = 139.0d0; C_expected(2,2) = 154.0d0

    ! Calculate matrix multiplication
    C = matmul(A, B, n, m, p)

    ! Check results
    @assertEqual(C_expected, C, tolerance=1.0d-10)

end subroutine test_matmul_simple
